Directory structure:
└── utxostack-rgbplusplus-design/
    ├── README.md
    ├── LICENSE
    └── docs/
        ├── light-paper-cn.md
        ├── light-paper-en.md
        ├── lockscript-design-prd-cn.md
        ├── lockscript-design-prd-en.md
        ├── security-analysis-cn.md
        ├── security-analysis-en.md
        └── assets/

================================================
File: README.md
================================================
# RGBPlusPlus-design

This repository contains the early-stage design documents for the RGB++ protocol, intended for an open discussion. 

Please note that these documents are preliminary and may undergo further modifications. The contents should not be considered as the final standard or implementation.

**Please don't treat these documentation as the final standard or implementation.**

Documents list:

| # | EN | CN |
| -- | -- | -- |
| 00 | [RGB++ Protocol Whitepaper Draft](./docs/light-paper-en.md) | [RGB++ 协议白皮书草案](./docs/light-paper-cn.md) |
| 01 | [RGB++ Script Standard](./docs/lockscript-design-prd-en.md) | [RGB++ 合约规范](./docs/lockscript-design-prd-cn.md) |
| 02 | [CKB Bitcoin SPV Type Script](https://github.com/ckb-cell/ckb-bitcoin-spv-contracts/blob/master/contracts/ckb-bitcoin-spv-type-lock/README.md) | CKB BTC SPV 合约设计 |
| 03 | [CKB Bitcoin SPV Library Design](https://github.com/ckb-cell/ckb-bitcoin-spv/blob/master/docs/Design.md) | CKB Bitcoin SPV 库的设计 |
| 04 | [RGB++ Security Analysis](./docs/security-analysis-en.md) | [RGB++ 安全性分析](./docs/security-analysis-cn.md) |


================================================
File: LICENSE
================================================
MIT License

Copyright (c) 2024 CELL Studio

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


================================================
File: docs/light-paper-cn.md
================================================
# RGB++ Protocol Light Paper (Draft)

*Cipher from CELL Studio & Nervos Foundation*

> Special thanks to [Ajian](https://twitter.com/AurtrianAjian), [cyberorange](https://twitter.com/xcshuan), [Jan](https://twitter.com/busyforking), [Shawn](https://twitter.com/ShawnMelUni), and [DaPangDun](https://twitter.com/DaPangDunCrypto) for feedback and discussion.

# 简介

RGB++ 是一个基于 RGB 的扩展协议，利用一次性密封条和客户端验证技术来管理状态变更和交易验证。它通过同构绑定将比特币 UTXO 映射到 Nervos CKB 的 Cell 上，并利用 CKB 链和 Bitcoin 链上的脚本约束来验证状态计算的正确性和变更所有权的有效性。RGB++ 解决了原 RGB 协议在实际落地中的技术问题，并提供了更多的可能性，如区块链增强的客户端验证、交易折叠、共享状态与无主合约、非交互式转账等。它为比特币带来了无须跨链、不损失安全性的图灵完备合约扩展和性能扩展。

### 一次性密封

一次性密密封的概念最早由 [Peter Todd 在 2016 年](https://petertodd.org/2016/state-machine-consensus-building-blocks)提出，它允许你对一条消息锁上一个电子密封条，确保这条消息只能被使用一次。具体来说，我们可以使用比特币的未花费的交易输出（UTXO）作为消息的密封条，比特币系统的共识机制可以确保这些 UTXO 仅能被消费一次，也即这些密封条仅能被打开一次。

RGB 协议利用这种基于比特币 UTXO 的一次性密封条，将 RGB 状态变更与比特币 UTXO 的所有权对应。因此比特币系统确保了 RGB 的状态所有权，以及可以通过 UTXO 历史来追溯所有的状态变更。一次性密封为 RGB 协议提供了由 Bitcoin 共识保障的防双花安全和交易分支追溯功能。

### 客户端验证

RGB 协议包含的用户状态无法由比特币共识直接验证，用户必须通过链外计算确保 RGB 的状态变更符合预期。客户端验证技术允许用户只需要验证与自己有关的 UTXO 分支历史，而无需关心与自己无关的交易历史。RGB 的状态安全性通过客户端验证方式保障，不依赖任何中心化第三方。

### RGB 协议的问题

尽管 RGB 协议有非常多的优势，尤其它可以为 Bitcoin 提供几乎不妥协的合约扩展，但在实际应用中依然存在多个技术和产品问题。

**DA 问题**

普通用户如何生成或获取交易历史的证明。普通用户使用简单的客户端产品时，并没有能力或资源保存所有的历史交易，也因此难以向交易对手方提供交易证明。

**P2P 网络问题**

RGB 交易作为 Bitcoin 的扩展交易，需要依赖一个 P2P 网络进行传播。用户之间在进行转账交易时，也需要进行交互式操作，接收方需要提供收条。这些都依赖一个独立于 Bitcoin 网络的 P2P 网络。

**虚拟机与合约语言**

RGB 协议的虚拟机目前主要是采用了 AluVM，作为新的虚拟机，目前缺乏完善的开发工具和实践代码。

**无主合约问题**

RGB 协议目前尚无完善的无主合约（公共合约）的交互方案。这导致多方交互难以实现。


### RGB++ 同构绑定

![binding](./assets/wp-binding.png)

RGB++ 通过同构绑定技术解决了 RGB 协议遇到的问题，并赋予了 RGB 更多的可能性。在 RGB 协议中，最重要的两个组件是用来做所有权认定的 UTXO 和用来做状态管理与一次性密封的 commitment。RGB++ 的同构绑定将其中的 Bitcoin UTXO 一一映射到 CKB 的 Cell 上、使用 bitcoin utxo lock 来实现所有权同步，并使用 cell 的 data 和 type 来实现状态的维护。

### 区块链增强客户端验证

所有的 RGB++ 交易都会在 BTC 和 CKB 链上同步各出现一笔交易。前者与 RGB 协议的交易兼容，后者则取代了客户端验证的流程，用户只需要检查 CKB 上的相关交易即可验证这笔 RGB++ 交易的状态计算是否正确。但用户也可以不使用 CKB 链上的交易作为验证依据，利用 UTXO 的局部历史交易信息，用户可以脱离 CKB 链独立地对 RGB++ 交易进行验证（交易折叠等部分功能仍然需要依赖 CKB 的块头哈希做防双花验证）。

# RGB++ 交易流程

![tx-general](./assets/wp-tx-general.png)

### 链外计算

- 选中下一次要使用的一次性密封条，例如 btc_utxo#2
- 链外计算并生成一笔将要发送到 CKB 上的 RGB++ 交易: CKB_TX_B
- 链外计算 `commitment = hash(CKB_TX_B | btc_utxo#1 | btc_utxo#2)`

### BTC 交易提交

- 生成并发送一笔比特币交易 Bitcoin_TX_A, 输入消耗 `btc_utxo#1`，输出通过 OP_RETURN 加入上面的 commitment

### CKB 交易提交

- 发送上述 CKB 交易 CKB_TX_B
- 用户的最新状态由 `CKB_TX_B.output.data` 维护
- 下一次变更状态需要使用 `btc_utxo#2`、`CKB_TX_B.output`

### 链上验证

- Bitcoin 验证相关的 utxo 只能被指定用户花费一次
- CKB 上存在 Bitcoin 的轻客户端，它可以验证 Bitcoin 上的相关交易存在 Bitcoin 链上
    - Bitcoin 的相关交易作为 ckb 交易的 witness 被提交上来，协助验证
- CKB 进一步验证该 btc 交易花费了正确的 utxo
- CKB 进一步验证该 btc 交易承诺了正确的 commitment
- CKB 验证 CKB 上的状态转移符合预订的合约规则

## RGB++ 客户端

不同于 RGB 协议，RGB++ 的所有交易都在 CKB 上并由 CKB 脚本约束验证，因此 RGB++ 无须独立客户端，用户只需要访问 Bitcoin 和 CKB 轻客户端即可验证所有交易。其中 CKB 轻客户端同样使用 PoW 算法可以实现最近的若干个块头即可验证所有历史交易和状态，进而利用同构绑定验证 RGB++ 的所有交易。

# 交易折叠

RGB++ 协议将 Bitcoin UTXO 与 CKB Cell 进行同构绑定，实现了 CKB Cell 验证支持的图灵完备 Bitcoin UTXO 交易。如果我们进一步利用 CKB Cell 的可编程能力，那么我们可以将多笔 CKB 交易与一笔 Bitcoin RGB++ 交易对应，这样就可以将低速低吞吐量的 Bitcoin 链使用高性能的 CKB 链进行扩容。

![tx-fold](./assets/wp-tx-fold.png)

# 共享状态与无主合约

## 共享状态的平庸实现

共享状态一直是 UTXO 系统的难题，这里先讨论一种不考虑多人同时更新共享状态的平庸实现，再进一步讨论实际会采用的允许多人同时操作共享状态的解决方案。

考虑 CKB 上存在一个全局状态的 Cell，用来管理多用户共享的状态。典型地，它可以是一个算法稳定币的质押合约，用户将波动资产存入，并获得一个存款证明。全局状态由无主合约管理，所谓无主合约指的是任何人在满足合约的约束前提下都可以对状态进行变更，而不要求指定的数字签名提供方进行变更。无主合约的实现对协议的去中心化和抗审查有决定性的作用。

这里的平庸实现指的是 Global-state cell 有被其他用户占用的风险，这样 CKB TX 就会因为指定的 Global state utxo 不存在而无法成立。而 Bitcoin TX 需要先于 CKB TX 发送出来、并将其计算到 commitment 中，因此也无法进行后续的验证。

## 共享状态的状态争抢问题与解决方案

为了解决上述问题，我们引入了 Intent Cell 作为中介。用户将自己希望执行的动作确定性地写入 Intent Cell，后者则可以通过第三方聚合器的协作与全局状态 Cell 交互，批量将多方的 intent 进行计算，并将交互结果合并到标准的 shadow cell 上。

# 非交互式转账

原始 RGB 协议的一个问题是收款方需要提供一个自己的 live utxo 作为 invoice 才能实施转账，这种方式要求收款方必须在线才能完成一笔普通的交易，增加了用户理解难度和产品复杂度。RGB++ 可以利用图灵完备环境的优势，将交互行为放置在 ckb 环境里面，采用发送-领取两步操作来实现非交互式转账逻辑。

## 发送

用户 A 向用户 B 发送资产时，只需要获知 B 的地址，并在 RGB++ 交易中向该地址转账，而不需要收款人提供 utxo 或 invoice。

![send tx](./assets/wp-send.png)

## 领取

![claim tx](./assets/wp-claim.png)

CKB 的 lock 合约有能力验证 btc 地址对应的数字签名，因此接收方可以在 CKB 上构造 Tx C 来解锁对应的 CKB Cell，并将资产转移到自己的 utxo#2 上。从而完成了非交互式收款。

# Coins

RGB++ 上的 fungible 资产发行需要对应的数据结构标准和一致性验证标准。我们可以使用 ckb 的 xudt 标准作为它的同构绑定协议。

## 发行

RGB++ coins 的发行有很多种方式，包括并不限于中心化分发、空投、认购等方式。代币的总量也可以选择不设上限和预设上限两种。对于预设上限的代币，可以使用状态共享方案在每次发行时验证已发行总量小于等于预设上限。

## 转移

RGB++ coins 的转移非常简单，只需要将收款方和找零 utxo 分别对应到 ckb 的 shadow cell 即可。coins 的转移也可以通过交易折叠的方式只发生在 CKB 上，多笔交易后再将最后结果 commit 到 BTC 上。

## 隐私

xudt 是一个透明的代币协议，我们也可以采用支持金额隐私和流向隐私的代币协议来强化 RGB++ coins 的隐私保护特性。例如，我们可以使用 bulletproof 算法，将 data 中的内容变成盲化金额，并在每次转让的交易中提供金额一致且非负的零知识证明。这样，只有交易当事人知道当前交易的具体金额信息，第三方观察者无法获知金额数据。

此外，我们还可以使用环签名实现转账流向的盲化。用户的 coin 在 CKB 上转账给环签名混淆器，然后再回流到由 bitcoin utxo 管理的地址上。通过这种方式切断资金流的历史轨迹，从而完成地址的隐私保护。

# NFTs

## 发行

RGB++ 的 NFT 资产发行也可以利用到 ckb 上现有的 NFT 协议，包括不限于 Spore、mNFT 和 CoTA 协议。以 Spore 为例，它将所有的元数据均保留的链上，实现了数据可用性的 100% 安全。而 CoTA 协议则是利用状态压缩技术，将 NFT 信息和持有数据压缩在 32 字节的的 SMT 中，提供了极致的成本优势。

## 转移

RGB++ 中 NFT 的转让也非常简单，类似无须找零的 coins 转账。

![transfer](./assets/wp-transfer.png)

# 闪电网络联通

RGB 作为客户端验证协议天然支持状态通道和闪电网络，但受限于 Bitcoin 的脚本计算能力，在 Bitcoin 上实现非 btc 的闪电网络非常困难。通过 RGB++ 协议的包裹，我们可以基于 CKB 的图灵完备脚本系统实现 RGB++ 资产的状态通道以及闪电网络。这项技术有着巨大的商业前景，例如基于闪电网络的稳定币支付系统可以提供低于中心化系统的成本和性能优势，同时保障了去中心化和抗审查特性。

# 应用举例

## Airdrop

给定一个地址列表和金额列表，我们可以使用 RGB++ 实现完整的 airdrop 应用。我们假设待领空投数据和已领地址列表均以 SMT 的信息保存在 cell data 中。用户即可通过自己的地址领取空投。

## DEX & AMM

RGB++ 利用 UTXO 结构可以直接支持基于 UTXO 的资产交换协议，无须引入中介方。同时利用网格订单簿设计可以实现自动化做市商模式，有别于 Uniswap 的价格曲线做市商模式，**网格做市商模式**可定制化更强，更适合 UTXO 结构的资产交易。

![dex](./assets/wp-dex.png)

上面的例子是卖家挂单 RGB++ xudt，买家使用 Bitcoin 购买。交易结构为买家提供包含了足够数量 Bitcoin 的 buyer’s utxo 并提供 PBST 签名，买家则构造 CKB 上的交易来符合卖家的要求，最终买家将构造好的 CKB 交易发送给卖家，卖家将 BTC 交易和 CKB 交易先后上链完成交易。

# 总结

RGB++ 继承了 RGB 协议的核心思想，采用了不同的虚拟机和验证方案，用户无须独立的 RGB++ 客户端，只需要访问 Bitcoin 和 CKB 轻节点即可独立完成所有的验证。RGB++ 为 Bitcoin 带来了图灵完备合约扩展和数十倍的性能扩展。它没有使用任何跨链桥，而是使用了原生的客户端验证方案，确保了安全性和抗审查性。

================================================
File: docs/light-paper-en.md
================================================
# RGB++ Protocol Light Paper (Draft)

*Cipher from CELL Studio & Nervos Foundation*

> Special thanks to [Ajian](https://twitter.com/AurtrianAjian), [cyberorange](https://twitter.com/xcshuan), [Jan](https://twitter.com/busyforking), [Shawn](https://twitter.com/ShawnMelUni), and [DaPangDun](https://twitter.com/DaPangDunCrypto) for feedback and discussion.


# **Introduction**

RGB++ is an extended RGB protocol by using single-use seals and client-side validation techniques to manage state changes and transaction verification. It maps the UTXO set of Bitcoin to the Cell of Nervos CKB via isomorphic bindings, and leverages scripting constraints on both CKB and Bitcoin chains to ensure the correctness of the state computations and the validity of the change ownership.

Addressing technical challenges encountered in the implementation of the original RGB protocol, RGB++ brings a wide array of new possibilities including client-side validation, transaction folding, shared state across contracts, non-interactive transfers, and more. It introduces Turing-complete smart contract scalability and performance to Bitcoin without the need for cross-chain transactions and without compromising security. 

### **Single-Use Seals**

The concept of **single-use seals** was [first introduced by Peter Todd in July, 2016](https://petertodd.org/2016/state-machine-consensus-building-blocks). It allows for a lock of an electronic seal on a message, ensuring that the message can only be used once. Specifically,  Bitcoin’s Unspent Transaction Outputs (UTXOs) can server as seals for messages, and the Bitcoin system’s consensus mechanism ensures that these UTXOs can only be spent once, meaning that these seals can only be opened once.

The RGB protocol uses single-use seals, which is based on Bitcoin UTXOs, to map RGB state changes to Bitcoin UTXOs ownership. This allows the Bitcoin system to guarantee ownership of the RGB state, as well as traceability of all state changes through the UTXO history. With single-use seals, the RGB protocol inherits Bitcoin's double spending protection and transaction traceability, both enforced by Bitcoin's consensus mechanism. 

### **Client-side Validation**

The RGB protocol contains user state that cannot be directly verified by the Bitcoin consensus. This requires users to utilize off-chain computation to validate that RGB state changes meet expectations. Client-side validation enables users to only validate the relevant UTXO branch history, rather than irrelevant ones. RGB ‘s state security is provided through client-side validation without reliance on any centralized third party.

### **Problems with the RGB Protocol**

While the RGB protocol has many advantages, especially in providing Bitcoin with virtually uncompromising contract extensions, there are several technical and product issues in practice.

**DA Issues**

**DA(Decentralized Authentication)** refers to whether the average user can generate or obtain proof of transaction history. When using a simple client-side product, average users lack the ability or resources to store full historical transaction data, making it difficult to provide cryptographic proof of transactions to counterparties.

**P2P Network Issues**

As an extension of Bitcoin, RGB transactions rely on a P2P network for propagation.  Users also need to interact with each other when transferring money, for example, recipients need to provide receipts. This introduces dependencies on a P2P network that is independent of the Bitcoin network.

**Virtual Machines and Contract Languages Immaturity**

The RGB protocol currently uses AluVM as its primary virtual machine. As a new model, AluVM lacks mature development tools and code examples for practice.

**Problems of Shared States and Unhosted Contracts**

The RGB protocol presently lacks sophisticated solution for the interaction of unhosted contracts, which limits multi-party interactions to realize.

### **RGB++ isomorphic bindings**

![binding](./assets/wp-binding.png)

RGB++ uses isomorphic bindings to solve the problems encountered by the RGB protocol and unlock more possibilities. In RGB, the two most important components are UTXOs, determining ownership, while commitments manage state and single-use seals. In contrast, RGB++ leverages isomorphic bindings to map Bitcoin UTXOs to Nervos' Cell, ensuring ownership synchronization through the utilization of Bitcoin's UTXO locking scripts. Meanwhile, the state maintenance is managed by the data and type fields of Nervos Cells.

### **Blockchain Enhanced Client-side Validation**

All RGB++ transactions undergo synchronization, resulting in one transaction on both the BTC and CKB chains. The former is compatible with RGB protocol transactions, while the latter serves to replace the client-side validation process. Users only need to check the corresponding transaction on CKB to verify whether the state of the RGB++ transaction is correct.

Also, users also have the option not to use the transactions on the CKB chain as the basis for verifications. By utilizing the local historical transaction information of UTXO, users can independently verify the RGB++ transaction from the CKB chain (note: some functions, such as transaction folding, still need to rely on the block header hash of CKB for anti-double-spending verification).

# **RGB++ Transaction Process**

![tx-general](./assets/wp-tx-general.png)

### **Off-chain Computation**

- Select the next **Single-Use Seals to be used**, e.g. btc_utxo#2;
- Perform off-chain computation to generate an RGB++ transaction (**`CKB_TX_B`**) that will be sent to the CKB;
- Get off-chain calculation: **`commitment = hash(CKB_TX_B | btc_utxo#1 | btc_utxo#2)`**.

### **BTC Transaction Submission**

Generate and broadcast a Bitcoin transaction (**`Bitcoin_TX_A`**), input **`btc_utxo#1`** for consumption,  outputting the above commitment via OP_RETURN.

### CKB Transaction Submission

- Broadcast the CKB transaction (**`CKB_TX_B`**)  mentioned above;
- The user's latest state is maintained by **`CKB_TX_B.output.data`**;
- The next state change requires the use of  **`btc_utxo#2`** and **`CKB_TX_B.output`**;

### **On-chain Validation**

- UTXOs related to Bitcoin validations can only be spent once by a given user;
- A lightweight client on CKB validates the presence of relevant Bitcoin transactions on the Bitcoin chain;
- Bitcoin's related transactions are submitted as witnesses in the CKB transaction for verification;
- CKB then verifies that the BTC transaction spent the correct UTXO;
- CKB further verifies that the BTC transaction commits to the correct commitment;
- CKB verifies that the on-chain state transition complies with the predefined contract rules.

## **RGB++ Client**

In contrast to the RGB protocol, all RGB++ transactions are on CKB and are validated by CKB script constraints. Therefore, RGB++ doesn't require a standalone client; users only need to access Bitcoin and CKB light client to verify all transactions. The CKB light client employs he PoW algorithm to verify all historical transactions and states with just a few recent block headers, which in turn facilitates the use of isomorphic bindings for verifying all RGB++ transactions.

# **Transaction Folding**

The RGB++ protocol uses isomorphic bindings between Bitcoin UTXOs and CKB Cell, enabling the implementation of Turing-complete Bitcoin UTXO transactions validated by CKB Cell.  Specifically, by further leveraging the programmable capabilities of CKB Cells, multiple CKB transactions can be corresponded with a single Bitcoin RGB++ transaction. This approach allows the low speed, low throughput Bitcoin chain to  benefit from higher scalability with the high performance CKB chain.

![tx-fold](./assets/wp-tx-fold.png)

# **Shared State and Unhosted Contracts**

## Mediocre Implementation of Shared State

Shared state has always been a challenge in UTXO systems. Here, we will first discuss a mediocre implementation that does not consider simultaneous updates to the shared state by multiple parties. Then, we will delve into a more practical solution that allows multiple parties to operate on the shared state simultaneously.

Consider a global state cell on the CKB that manages the state shared by multiple users. Typically, it could be a staking contract for an algorithmic stablecoin, where users deposit volatile assets and receive a deposit proof. The global state is managed by an unhosted contract, meaning anyone can make changes to the state without requiring specific digital signatures from designated signatories. The implementation of an unhosted contract plays a crucial role in the decentralization and censorship resistance of the protocol.

A mediocre implementation in this context means that there is a risk that the Global state Cell is occupied by another user, causing CKB TX fail because the specified Global state utxo does not exist. As the Bitcoin TX needs to be sent out and computed into the commitment before the CKB TX, subsequent validation becomes impossible.

## **The Issue of State Contentions in Shared States and Solutions**

To address the above problem, we introduce the Intent Cell as an intermediary. Users can deterministically write down actions they wish to execute into the Intent Cell, which can interact with the global state Cell through the collaboration of a third-party aggregator, batch processing multiple parties’ intent and merging the results of the interaction into a standard shadow cell.

# **Non-Interactive Transfers**

One issue with the RGB protocol is receivers needs to provide a live UTXO as an invoice to initiate a transfer. This requires recipients stay online to complete a transaction, which increases the complexity for both user understanding and products. Instead, RGB++ leverages the Turing-complete environment by placing the interaction behavior in a CKB environment, and providing a two-step approach of send-receive to implement non-interactive transfer.

## **Send**

When user A sends assets to user B, user A only needs to know user B's address - transferring funds to that address in the RGB++ transaction without requiring user B to provide any UTXOs or invoices.

![send tx](./assets/wp-send.png)

## **Receive**

![claim tx](./assets/wp-claim.png)

The CKB lock contract has the ability to validate the digital signature of the BTC address. Therefore, the receiver can formulate a Tx C on CKB to unlock the corresponding CKB Cell and transfer the assets to their own utxo#2. This finalizes the non-interactive collection process.

# Coins

Issuing fungible assets on RGB++ requires corresponding data structure standards and consistency verification standards. We can adopt the  [xUDT standard on CKB](https://talk.nervos.org/t/rfc-extensible-udt/5337) as the isomorphic binding protocol.

## **Issuance**

There are many ways to issue fungible assets on RGB++, including but not limited to centralized distribution, airdrops, and subscriptions. The total supply of tokens can be either uncapped or pre-capped. For pre-capped tokens, a state sharing scheme can be employed during each issuance to validate that the total issued amount remains less than or equal to the preset cap.

## **Transfer**

Transferring RGB++ coins is a straightforward process, involving mapping the recipient and remaining UTXO balances to the shadow cell of CKB. Also, transferring coins can be streamlined exclusively on CKB through transaction foldings. After multiple transactions are completed, the final results will be committed to BTC.

![transfer](./assets/wp-transfer.png)


## Privacy

The xUDT protocol is a transparent token protocol. To enhance the privacy-preserving features of RGB++ coins, we can explore token protocols that offer both amount privacy and flow privacy. For instance, the bulletproof algorithm can be employed to transform the content in data into a blinded amount, with a zero-knowledge proof demonstrating the consistency and non-negativity of the amount in each transfer transaction. This ensures that only the parties involved in a transaction possess knowledge of the specific amount in the transaction, preventing third-party observers from accessing the date of amount.

Additionally, ring signatures can be used to realize the blinding of the transfer flow. The user's coins are transferred to the ring signature obfuscator on CKB and then redirected back to the address managed by the Bitcoin UTXO. This strategy hides the historical trace of capital flow, thereby achieving enhanced privacy protection for the address.

# NFTs

## Issuance

Issuing NFT assets on RGB++ can also utilize existing CKB NFT standards, including but not limited to the [Spore Protocol](https://spore.pro/), mNFT, and [CoTA protocol](https://talk.nervos.org/t/rfc-cota-a-compact-token-aggregator-standard-for-extremely-low-cost-nfts-and-fts/6338). Taking Spore Protocol as an example, it stores all metadata on-chain, achieving 100% security in data availability. The CoTA protocol, on the other hand, is a compact token aggregator standard which compresses NFT information and holds data in 32-byte SMTs, providing ultimate cost advantages.

## **Transfer**

The transfer of NFTs in RGB++ is also very simple, similar to a coins transfer with no change.

# **Lightning Network Connectivity**

RGB, functioning as a client-side authentication protocol, inherently supports state channels and the Lightning Network. However, due to Bitcoin's scripting limitations, it is very challenging to run non-BTC Lightning networks on the Bitcoin blockchain. By adopting the RGB++ protocol, we can leverage CKB's Turing-complete scripting system to implement state channels and Lightning networks specifically for RGB++ assets. Such technology holds significant commercial potential. For example, a stablecoin payment system built on the Lightning Network can deliver cost and performance advantages that surpass those offered by centralized systems while guaranteeing decentralization and censorship resistance.

# **Examples of Applications**

## Airdrop

Given a list of addresses and corresponding amounts, we can implement a complete airdrop application using RGB++. Assuming that both the pending airdrop data and the claimed address list are stored in cell data as SMT, users can easily collect airdrops from their own addresses.

## DEX & AMM

RGB++ optimizes the UTXO structure, facilitating seamless support for UTXO-based asset exchange protocols without the need for intermediaries. Additionally, RGB++ adopts a grid trading design to enhance its Automated Market Maker (AMM) model. In comparison to Uniswap's AMM model, the grid trading model offers enhanced customization and suitability for trading UTXO-based assets.

![dex](./assets/wp-dex.png)

The example above illustrates a scenario where a buyer is executing a purchase using $BTC in response to a seller's pending order for RGB++ xudt. As the transaction structure involves the buyer's utxo, containing sufficient amount of $BTC and a PBST signature, the buyer can creates a CKB transaction that meets the seller’s requirements. Afterwards, the buyer sends this signed CKB transaction to the seller. The seller then submits the BTC transaction and CKB transaction on-chain, one after the other, to complete the trade.

# **Summary**

RGB++ inherits the core idea of the RGB protocol while adopting a different virtual machine and validation scheme. Users can independently validate transactions by accessing Bitcoin and CKB light nodes, without needing a separate RGB++ client. In general, RGB++ brings Turing-complete contract scalability and achieves over ten times [performance scaling](https://www.ibm.com/docs/en/zos/2.1.0?topic=storage-tape-capacity-performance-scaling) to Bitcoin. Notably, instead of using cross-chain bridges, RGB++ implements native client-side validation for enhanced security and censorship resistance.

================================================
File: docs/lockscript-design-prd-cn.md
================================================
# RGB++ 合约规范

Authors: Cipher Wang, JJY

Contributors: CyberOrange, Ian, Jan

# 概述

## 关于同构绑定的要求和限制

同构绑定要求 RGB++ 交易必须在 BTC 上提交, 用户通过在 BTC 提交一次性密封来描述对 RGB++ cells 的操作。用户需要先构造 CKB raw tx 以及 RGB++ commitment，再把 commitment 提交到 BTC，最后再将 CKB TX 上链。这里面的一些约束条件有：

- RGB++ Cell 的 lock 中必须指定代表所有权的 BTC UTXO 信息（btc_tx + index）
- ckb_tx 中的 RGB++ Cell 依赖 btc_tx，如果 btc_tx.commitment 再包含 ckb_tx，这就死锁了，因此，**Commitment 只能包含 ckb tx 的部分信息**
    - Commitment 只会包含前 N 个 Inputs, Outputs
    - Commitment 必须覆盖所有 Type 不为空的 Inputs 以及 Outputs
    - CKB TX 可以在 N 个 Inputs, Outputs 后使用额外的 Type 为空的 Inputs, Outputs，构造者可以利用这个规则修改交易的手续费
- Cell 在创建时不会执行 Lock 脚本验证，因此任何人都可以创建 RGB++ Cell 并使用任意的 BTC UTXO 作为 Lock args，我们把这种交易理解成转移 cell 所有权到 BTC UTXO 上，此类的 Cell 在使用时与上述逻辑一致。

# 合约需求

需要如下合约：

- RGBPP_lock 用来处理与 RGB++ Cell 的解锁；
- BTC_TIME_lock 时间锁，当用户资产从 L1 leap 到 L2 时必须使用该 Lock 锁定一定区块数。

## 合约的 Config Cell

RGBPP_lock / BTC_TIME_lock 合约需要读取轻节点，因此我们必须保存相关合约的 type_hash。由于不希望引入硬编码的合约依赖，我们引入 Config Cell 的概念来解决此类配置问题。


部署合约时，要求 contract code cell 和 config cell 在同一笔交易的 outputs 内完成创建。

```yaml
# BTC_TIME_lock
inputs: any cells
outputs:
  BTC_TIME_lock code cell
  time_lock_config cell
...

# RGBPP_lock
inputs: any cells
outputs:
  RGBPP_lock code cell
  rgb_lock_config cell
...
```
合约通过以下方式找到 config cell

```yaml
1. load_script 找到目前的 合约的 type_hash
2. 通过 type_hash 找到 cell dep 符合且 out_point.index == 1 的 cell deps 的 index
3. load 这个 cell dep 的 data 即得到全局配置
```

```rust
struct RGBPPConfig {
  version: Uint16,
  // Type hash of bitcoin light client
  bitcoin_lc_type_hash: Byte32,
  // Type hash of bitcoin time lock contract
  bitcoin_time_lock_type_hash: Byte32,
}
```
每次更新合约都必须和 Config Cell 一起更新，并且遵守更新规则。

## 合约数据结构

### RGBPP_lock

```yaml
RGBPP_lock:
  code_hash: 
    RGBPP_lock
  args:
    out_index | %bitcoin_tx%
```

- RGBPP_lock:
    - out_index：UTXO index, Cell 的所有权属于该 UTXO
    - bitcoin_tx: BTC txid

### BTC_TIME_lock

```yaml
BTC_TIME_lock:
  args: lock_script | after | %new_bitcoin_tx%
```

- BTC Time lock:
    - lock_script 解锁后 Cell 的拥有者
    - after 要求 new_bitcoin_tx 超过 after 个确认后可以解锁

## RGBPP_Lock 解锁逻辑

<aside>
💡 用于 L1 地址(btc_utxo)持有的 RGB++ 资产 Cell
</aside>

**Cell 解锁验证流程**

![uib](./assets/lock-verify.png)

- 解锁者提供包含 RGB++ commitment 的 `btc_tx`：
    - 包含在 CKB 上的 BTC 轻客户端中
    - inputs 中包含与要解锁的 cell.lock 对应的 btc utxo input，即  `btc_tx.inputs[i] == previous_bitcoin_tx | out_index`
    - outputs 中有且仅有一个 OP_RETURN，包含 `commitment`
    - `self.lockargs.%new_bitcoin_tx% = btc_tx`
- 该 `commitment` 为以下内容的 hash，算法为 `double sha256(”RGB++” | messages)`
  - `version: u16`，必须为 0
  - `inputs_len:u8`
    - 表示 commitments 包含前 n 个 inputs cells
    - 必须 >= 1
    - 所有 type 不为空的 input cell 必须被包含在 inputs_len 中
  - `outputs_len:u8`
    - 表示 commitments 包含前 n 个 outputs cells
    - 必须 >= 1
    - 所有 type 不为空的 output cell 必须被包含在 outputs_len 中
  - `CKB_TX.inputs[:inputs_len]`
  - `CKB_TX.outputs_sub[:outputs_len]`, 包含全部数据，除了
    - 不包含 `lockargs.%new_bitcoin_tx% = btc_tx` 
- 交易中其余资产仍然被 RGB++ Lock 保护，即所有 outputs 中 type 不为空的 cells 必须使用以下两种 lock 之一
  - RGBPP_lock
  - BTC_TIME_lock
      - 要求 `lockargs.after ≥ 6`
      - 要求 `lockargs.new_bitcoin_tx == btc_tx`

**tips**

- inputs_len / outputs_len 可以由最后一个有 type 的 input / output cell 的位置计算出
- commitment 至少包含一个 input 和 output, 即使所有 inputs 和 outputs 的 type 都为空
- SDK 可以修改 commitment 之外的 cells 调整手续费

## BTC_TIME_lock 解锁逻辑

```yaml
lock.args: lock_hash | after | %new_bitcoin_tx%
```

- lock_script 为解锁后需要释放到的目标接受者
    - 解锁交易中每个 BTC_TIME_lock input 必须在相同 index 对应一个 output
    - output 的 lock 为 lock_script 其余字段 type, data, capacity 需要和 input 一致
- after 要求 new_bitcoin_tx 已经超过 after 个确认
- 解锁后的 cell 持有人的 lock 符合 lock_script

# 交易逻辑

## L1 转账/操作

**定义：CKB 上输入输出的资产 cell（定义：type ≠ null） 均为 RGBPP_lock**

```yaml
# BTC_TX
input:
  btc_utxo_1  # =(previous_btc_tx | out_index)
  ...
output:
  OP_RETURN: commitment
  btc_utxo_3  # =(new_bitcoin_tx | out_index)
  btc_utxo_4  # =(new_bitcoin_tx | out_index)

# CKB_TX
input:
  rgb-xudt:
    type:
      code: xudt
      args: <asset-id>
    lock:
      code: RGBPP_lock
      args: btc_utxo_1 = (out_index | previous_btc_tx)

output:
  xudt:
    type: xudt
    lock:
      code: RGBPP_lock
      args: out_index = 1 | %new_bitcoin_tx%

  xudt:
    type: xudt
    lock:
      code: RGBPP_lock
      args: out_index = 2 | %new_bitcoin_tx%
```

## L1 → L2 Leap 操作

**定义：CKB 上输入的资产 cell 的 lock 均为 RGB lock，输出的资产 cell 的 lock 至少一个或全部为 BTC_TIME_lock，其余为 RGBPP_lock**

这里需要在 CKB 上引入一种新的时间锁 Lock: **BTC_TIME_lock**

```yaml
# BTC_TX
input:
  btc_utxo_1
  ...
output:
  OP_RETURN: commitment
  btc_utxo_3

# CKB_TX
input:
  rgb_xudt:
    type: xudt
    lock:
      code: RGBPP_lock
      args: out_index | source_tx

output:
  rgb_xudt:
    type: xudt
    lock：
      code: BTC_TIME_lock
      args: lock_script | after | %new_bitcoin_tx%

  rgb_xudt:
    type: xudt
    lock:
      code: RGBPP_lock
      args: out_index=1 | %new_bitcoin_tx%
```

等到足够多的 BTC 区块确认后，可以解锁 BTC_TIME_lock 的 cell。

> 注意：每个 BTC_TIME_lock input 对应的 output 上必须存在对应解锁后的 cell, 除 lock 外其余字段保持不变

```yaml
# CKB_TX
input:
  rgb_xudt:
    type: xudt
    lock:
      code: BTC_TIME_lock
      args: lock_script | 6 | btc_tx

output:
  rgb_xudt:
    type: xudt
    lock:
      lock_script

witness:
  # proof of 6 confirmations after #btx_tx
```

## L2 → L1 Leap 操作

**定义：输入侧没有 RGB_lock，输出侧有 RGBPP_lock**

```yaml
# CKB TX
input:
  xudt:
    type: xudt
    lock:
      ckb_address1

output:
  xudt:
    type: xudt
    lock:
      ckb_address2

  rgb_xudt:
    type: xudt
    lock:    
      args: btc_utxo
```

# RGB++ 资产发行

## 纯 L1 方式发行 RGB++ 资产

使用 L1 方式发行 RGB++ 要求发行人使用 bitcoin 上的交易，utxo 或其他 id 作为身份标识符来发行资产，这样才可以做到无须 L2 辅助即可完全实现 CSV。具体发行方案有多种，我们这里列出两种简单方案。

### 直接发行

发行人需要先构造一个使用特定 BTC UTXO 作为 RGBPP_lock 的 issue_cell。该步骤无须经过同构绑定，后即可用这个 cell 进行一次性发行。

```yaml
# BTC TX
input:
  btc_utxo#0
  ...
output:
  commitment
  btc_utxo#1
  ...

# CKB TX
input:
  issue_cell:
    RGBPP_lock:
    args: btc_utxo#0
      
output:
  xudt_cell:
    data: amount
    type: 
      code: xudt
      args: hash(RGBPP_lock|btc_utxo#0)
    lock:
      code: RGBPP_lock
      args: btc_utxo#1
```
### 区块区间发行

区块区间发行需要将 xudt 的发行模式从 lock 发行改为 type 发行，即创建一种新的 xudt，或插件，使得发行的 xudt 的 type.args，即资产 id 不是 lockhash，而是某些 btc 链的参数即可

```yaml
# BTC TX
input:
  btc_utxo#0
  ...
output:
  commitment
  btc_utxo#1
  ...
  
# CKB TX
input:
  issue_cell:
    RGBPP_lock:
      args: btc_utxo#0

output:
  xudt_cell:
    data: amount
    type: 
      code: xudt_modified
      args: 
        hash_of:
          start_block,
          end_block,
          max_per_tx,
          token_name
    lock:
      code: RGBPP_lock
      args: btc_utxo#1
```

上面的例子中，在[start_block, end_block] 区间发起的交易，任何人都可以在 BTC L1 上实现公平发射发行，以平等的机会获得代币。

## L2 发行后跳转到 L1

比较简单，也更灵活，不再赘述。


================================================
File: docs/lockscript-design-prd-en.md
================================================
# RGB++ Script Standard

Authors: Cipher Wang, JJY

Contributors: CyberOrange, Ian, Jan

# Overview

## Requirements and Limitations on Isomorphic Binding

Isomorphic Binding requires that RGB++ transactions must be submitted on BTC chain, and that the user use single-use seals on BTC to describe the operation on RGB++ cells. The user needs to construct the CKB raw tx and the RGB++ commitment first, then submit the commitment to BTC, and finally send the CKB TX on-chain. 

However, there are some constraints:

- The BTC UTXO information that represents ownership must be specified in the `lock` of the RGB++ Cell (`btc_tx` + `index`).
- The RGB++ Cell in `ckb_tx` depends on `btc_tx`; if `btc_tx.commitment` includes `ckb_tx`, it results in a deadlock. Thus, **the commitment can only contain these following information of the CKB transaction**:
    - Commitment includes only the first N Inputs and Outputs;
    - Commitment must cover all Inputs and Outputs where `Type` is not null;
    - After the initial N Inputs and Outputs, the CKB transaction can include additional Inputs and Outputs with a null `Type`. This rule allows for modifications to the transaction fee.
- Cell is created without lock script validation, allowing anyone to create an RGB++ Cell using any BTC UTXO as `LockArgs`. This process essencially transfers ownership of the Cell to a BTC UTXO. Also, the operation of this type of Cell follows the same principles outlined above.

# Contract Requirements

The following contract is required:

- `RGBPP_lock`: this is designed to handle the unlocking process of the RGB++ Cell;
- `BTC_TIME_lock`: this is a time lock used to secure a specified number of blocks when assets leap from Layer 1 (L1) to Layer 2 (L2).

## **Config Cell** of the Contract

Both the `RGBPP_lock` and `BTC_TIME_lock` require the [BTC light client](https://github.com/ckb-cell/ckb-bitcoin-spv-contracts/blob/master/contracts/ckb-bitcoin-spv-type-lock/README.md) data, necessitating the storage of the associated contract's `type_hash`. To avoid hardcoded dependencies, the concept of Config Cell is introduced here to address this configuration issue.

When deploying a contract, both the `contract code cell` and the `config cell` must be included in the same transaction's outputs.

```
# BTC_TIME_lock
inputs: any cells
outputs:
  BTC_TIME_lock code cell
  time_lock_config cell
...

# RGBPP_lock
inputs: any cells
outputs:
  RGBPP_lock code cell
  rgb_lock_config cell
...
```

The contract follows these steps to identify Config Cell:

```
1. Use load_script to retrieve the type_hash of the current contract;
2. Use type_hash to identify the index that its cell dep matches and has out_point.index == 1;
3. Load the data from this cell dep to fetch global configuration settings.
```

```
struct RGBPPConfig {
  version: Uint16,
  // Type hash of bitcoin light client
  bitcoin_lc_type_hash: Byte32,
  // Type hash of bitcoin time lock contract
  bitcoin_time_lock_type_hash: Byte32,
}
```

Whenever the contract is updated, the Config Cell must be updated as well, and these updates must adhere to predefined rules.

## Data Structure of the Contract

### **RGBPP_lock**

```
RGBPP_lock:
  code_hash:
    RGBPP_lock
  args:
    out_index | %bitcoin_tx%
```

- `RGBPP_lock`:
    - out_index: UTXO index, the ownership of the Cell belongs to this UTXO
    - bitcoin_tx: BTC txid

### **BTC_TIME_lock**

```
BTC_TIME_lock:
  args: lock_script | after | %new_bitcoin_tx%
```

- `BTC_TIME_lock`:
    - refers to the owner of Cell once `lock_script` is unlocked;
    - `after` requires that `new_bitcoin_tx` can only be unlocked after it has received more than the number of confirmations specified by the `after` .

## **RGBPP_Lock Unlock Logic**

💡 For Cell of the RGB++ Asset on L1 Address (`btc_utxo`)

### **Cell Unlock Validation Process**

![uib](./assets/lock-verify.png)

The process for unlocking involves providing a `btc_tx` with the RGB++ commitment:

- It is included within the BTC light client on CKB.
- Inputs should include the BTC UTXO Input corresponding to the cell.lock to be unlocked, i.e., `btc_tx.inputs[i] == previous_bitcoin_tx | out_index`.
- Outputs must contain only one `OP_RETURN`, which include `commitment`.
- `self.lockargs.%new_bitcoin_tx% = btc_tx`.

The `commitment` is created using the `double sha256("RGB++" | messages)` method, and should satisfy the following rules:

- `version: u16` should always be 0;
- `inputs_len: u8`:
    - Specifies the commitment includes the first n input cells;
    - Must be >= 1;
    - All input cells with a non-null type must be included within `inputs_len` ;
- `outputs_len: u8`:
    - Specifies the commitment includes the first n output cells;
    - Must be >= 1;
    - All output cells with a non-null type must be included within `outputs_len` ;
- `CKB_TX.inputs[:inputs_len]` ;
- `CKB_TX.outputs_sub[:outputs_len]`includes all data except for:
    - `lockargs.%new_bitcoin_tx% = btc_tx` .

The remaining assets in the transaction is secured by the RGB++ Lock. All output cells that have a non-null type must use one of the following locks:

- `RGBPP_lock`
- `BTC_TIME_lock`, which requires:
    - `lockargs.after ≥ 6` ;
    - `lockargs.new_bitcoin_tx == btc_tx`.

Tips:

- `inputs_len` and `outputs_len` can be calculated by the position of the last input or output cell with a `type` ;
- The commitment must include at least one input and one output, even if all input `type` and output `type` are null;
- SDKs can alter cells outside of the commitment to adjust the transaction fee.

## **BTC_TIME_lock Unlock Logic**

```
lock.args: lock_hash | after | %new_bitcoin_tx%
```

- The `lock_script` identifies the recipient who will receive the assets after the lock is unlocked:
    - For each `BTC_TIME_Lock` input in a transaction, there must be a corresponding output at the same index;
    - The lock of the output must be `lock_script`, with the other fields such as `type`, `data`, and `capacity` must be identical to those in the input.
- `after` requires that the `new_bitcoin_tx` has more than the number of confirmations specified by the `after` ;
- after unlocking, the `lock` of the cell holder must match the `lock_script`.

# **Transaction Logic**

## **L1 Transfers/Operations**

**Definition**: The locks of `non-null asset type` inputs and outputs in a CKB transaction are all RGBPP_lock.

```
# BTC_TX
input:
  btc_utxo_1  # =(previous_btc_tx | out_index)
  ...
output:
  OP_RETURN: commitment
  btc_utxo_3  # =(new_bitcoin_tx | out_index)
  btc_utxo_4  # =(new_bitcoin_tx | out_index)

# CKB_TX
input:
  rgb-xudt:
    type:
      code: xudt
      args: <asset-id>
    lock:
      code: RGBPP_lock
      args: btc_utxo_1 = (out_index | previous_btc_tx)

output:
  xudt:
    type: xudt
    lock:
      code: RGBPP_lock
      args: out_index = 1 | %new_bitcoin_tx%

  xudt:
    type: xudt
    lock:
      code: RGBPP_lock
      args: out_index = 2 | %new_bitcoin_tx%
```

## L1 → L2 Leap

**Definition**: On CKB, the lock for input asset cell is `RGB_lock`. For output asset cells, at least one, and possibly all, will be `BTC_TIME_lock`; while the remaining output asset cells use `RGBPP_lock`.

`BTC_TIME_lock`, as a new type of timelock on CKB, is introduced here.

```
# BTC_TX
input:
  btc_utxo_1
  ...
output:
  OP_RETURN: commitment
  btc_utxo_3

# CKB_TX
input:
  rgb_xudt:
    type: xudt
    lock:
      code: RGBPP_lock
      args: out_index | source_tx

output:
  rgb_xudt:
    type: xudt
    lock：
      code: BTC_TIME_lock
      args: lock_script | after | %new_bitcoin_tx%

  rgb_xudt:
    type: xudt
    lock:
      code: RGBPP_lock
      args: out_index=1 | %new_bitcoin_tx%
```

After enough BTC blocks have been confirmed, the `BTC_TIME_lock` cells can be unlocked. 

> Note: Each output corresponding to a `BTC_TIME_lock` input must have an unlocked cell where all fields should remain unchanged from the input except for the lock field.
> 

```
# CKB_TX
input:
  rgb_xudt:
    type: xudt
    lock:
      code: BTC_TIME_lock
      args: lock_script | 6 | btc_tx

output:
  rgb_xudt:
    type: xudt
    lock:
      lock_script

witness:
  # proof of 6 confirmations after #btx_tx
```

## **L2 → L1 Leap**

**Definition**: No RGBPP_lock in the transaction Inputs, while Outputs has RGBPP_lock.



```
# CKB TX
input:
  xudt:
    type: xudt
    lock:
      ckb_address1

output:
  xudt:
    type: xudt
    lock:
      ckb_address2

  rgb_xudt:
    type: xudt
    lock:
      args: btc_utxo

```

# **RGB++ Asset Issuance**

## Bitcoin L1 Issuance of RGB++ Assets

To issue RGB++ assets using Bitcoin's Layer 1, the issuer must initiate a bitcoin transaction that uses UTXO or other id as an identifier. This method enables the implementation of CSV on Layer 1, eliminating the need for Layer 2 involvement. There are various issuance methods, the following sections will discuss two primary issuance methods: direct issuance and inter-block issuance.

### **Direct Issuance**

An issuer needs to create a specific UTXO as an issue_cell lock. The issue_cell will then be used for a one-time issuance.

```
# BTC TX
input:
  btc_utxo#0
  ...
output:
  commitment
  btc_utxo#1
  ...

# CKB TX
input:
  issue_cell:
    RGBPP_lock:
    args: btc_utxo#0

output:
  xudt_cell:
    data: amount
    type:
      code: xudt
      args: hash(RGBPP_lock|btc_utxo#0)
    lock:
      code: RGBPP_lock
      args: btc_utxo#1
```

### **Inter-block issuance**

Inter-block issuance involves altering the issuance mode of an extensible User-Defined Token ([xUDT](https://talk.nervos.org/t/rfc-extensible-udt/5337)) from `lock` to `type`. This means that the new xUDT's type.args (a.k.a. asset ID) is not lock_hash but some parameters on the BTC chain.

```
# BTC TX
input:
  btc_utxo#0
  ...
output:
  commitment
  btc_utxo#1
  ...

# CKB TX
input:
  issue_cell:
    RGBPP_lock:
      args: btc_utxo#0

output:
  xudt_cell:
    data: amount
    type:
      code: xudt_modified
      args:
        hash_of:
          start_block,
          end_block,
          max_per_tx,
          token_name
    lock:
      code: RGBPP_lock
      args: btc_utxo#1
```

In the above example, for transactions initiated within the [`start_block, end_block`] interval, anyone can executes a fair launch on BTC L1, ensuring that everyone has equal chance of token distribution.

## **Leap to L1 Following L2 Issuance**

This process is straightforward and offers greater flexibility, hence it will not be discussed in this document.


================================================
File: docs/security-analysis-cn.md
================================================
# RGB++ 深入讨论：安全性分析

*Cipher from CELL Studio & Nervos Foundation*

> Special thanks to [Ren Zhang](https://scholar.google.com/citations?hl=en&user=JB1uRvQAAAAJ), [Ian](https://github.com/doitian), and [c4605](https://talk.nervos.org/u/c4605/summary) for feedback and discussion.
> The RGB receiver optimization approach is inspired by [Jason Cai](https://twitter.com/CryptoStwith).

## **PoW 比你想象的更安全**
PoW 的安全性风险在于区块 revert/reorg，从而导致双花。只要有一个诚实矿工，用户的状态/资产就不会计算错误，只有可能出现因区块重整导致的双花交易损失。因此 PoW 的核心安全假设就是 N 个区块后交易就几乎不会被 revert 了，例如 Bitcoin 普遍认为 6 区块甚至更少即可。

显然，6确认的 BTC 肯定比1确认更安全，那么 PoW 确认数和安全性是线性关系吗？并不是，**推翻区块的难度随着区块深度指数增长**，这个指数增长具体的参数已经有几十篇论文在讨论了。随着时间的推移，大家发现“NC比从前以为的更安全”。

根据 [Ren Zhang](https://scholar.google.com/citations?hl=en&user=JB1uRvQAAAAJ) 博士的计算，假设敌手算力占比30%，要实现比特币中孤块率为0、6个块确认的安全性，当 CKB 的孤块率设定成 2.5% 的时候，需要23.29个块确认即可达到相同的安全性 。通过这样的等价关系，我们可以在后续的讨论中方便地讨论 RGB++ 协议中各种典型操作的安全性。

![pow](./assets/sa-pow.png)
***PoW 安全性的示意图（非理论计算）***

## **RGB 的安全性**
RGB 通过一次性密封和客户端验证的方式实现了在 Bitcoin UTXO 上绑定 RGB 的状态和合约，为 Bitcoin 提供了图灵完备的扩展。交易安全性有两类，一类是状态计算的正确性；一类是交易确定性，即双花风险。客户端验证确保了状态计算的正确性，每个人负责自己的状态，不依赖任何第三方。而基于 BTC UTXO 的一次性密封确保了双花 RGB 的难度和双花 BTC 的难度相同。因此，我们可以说** RGB 100% 继承了 Bitcoin 的安全性**。用户需要多安全，就按照比例等待多少个 BTC 确认即可。

## **RGB++ 的安全性**
### **L1 交易安全性**
RGB++ 的 L1 交易指的是 RGB++ 交易的 UTXO 的"持有人" 是 Bitcoin 的 UTXO。即只有消费 Bitcoin UTXO 才能操作或更新 RGB++ UTXO。这种情况下，虽然每一笔 RGB++ 交易都同步发起一笔 CKB 交易，但其安全性和 CKB 没有关系，CKB 仅作为 DA 和状态公示来使用。**这种情况下，RGB++ L1 的交易安全性和 RGB 交易相同，也是完全继承了 BTC 的安全性。**

### **L2 交易安全性**
L2 交易即 100% 发生在 CKB 上的交易，显然它的安全性 100% 由 CKB 负责。但由于开篇提出的 PoW 安全的非线性特性，24个区块的 ckb 确认即可等价于 6 确认的 BTC 确认，因此我们也可以说 L2 交易安全性与 L1 交易安全性等价（需要更多区块确认，但事实上更短确认时间）。

能做到这一点的前提是 RGB++ 的同构映射链必须是 PoW 的，如果它是 PoS 的链，无论等待多少个区块，它安全性上限都是 PoS 的 stake 量，无法与 Bitcoin 安全性等价。

### **JUMP 操作**
RGB++ 协议中用户的资产既可以在 Bitcoin 上流转，也可以随时到 CKB 上流转，或者反向操作。在切换的过程不需要跨链桥，更不需要信任任何多签方。我们将资产或状态在 Bitcoin 上和 CKB 上流转的切换称为 Jump。Jump 操作前后，影响 RBG++ 协议安全性的核心点在于：

- 一次性密封条，从使用 Bitcoin UTXO 变为使用 CKB UTXO，或相反

- 客户端验证所需要的数据保持不变，都是 CKB 上的同构绑定交易

Jump 操作时，用户需要在两条链上分别等待足够的区块数，以获得安全性。

## **兼顾用户体验**
根据上面的讨论，等待足够多的区块数确实可以获得足够的安全性，但用户体验实在太差了。考虑平庸的方案，每个 RGB++ L1 交易要等待 6 个 BTC 确认再进行下一次操作，每个 L2 交易要等待 24 个 CKB 确认再进行下一次操作，而 Jump 操作则需要等待 6 BTC + 24 CKB 确认。能否对这个方案进行优化呢？
### **RGB 收款方 UTXO 的优化**
考虑原 RGB 协议，为了实现交易隐私性，Bitcoin 上发起的 RGB 交易的收款方（以一个 Bitcoin utxo 表达）和这笔 Bitcoin 交易的 output 并不一致。这使得观察者无法通过追踪 bitcoin 交易的方式来追踪 RGB 交易。

但在 RGB++ 协议中，所有的 RGB++ 层交易都同构绑定并公示在 CKB 上，尽管极大地简化了用户的交易验证难度，也较为遗憾地损失了 RGB 协议的隐匿性（RGB++ 协议可以利用 CKB 的隐私层引入[更为强大的隐私属性](https://forum.grin.mw/t/a-draft-design-of-mimblewimble-on-nervos-ckb/7695)）。所以 RGB++ 协议在收款人方面做了调整，它不要求收款方预先提供一个自己的 UTXO，而只需要提供一个收款地址，RGB++ 交易本身在构造 BTC 交易时会生成一个 UTXO 指向该收款人地址。这样就可以完成非交互式转账，大幅简化了用户的操作流程。注意下面的示意图做了一些简化，为了实现同构绑定，某些包含在 BTC TX 和 CKB TX 中的字段不会被包含在 commitment 中，以防止出现互相包含的矛盾。

![payee](./assets/sa-payee.png)

### **交易串接**
上面的 RGB 非交互式转账的优化不仅仅有利于提升用户体验，对于交易确认的优化也有本质的作用。

![sequencing1](./assets/sa-sequencing1.png)

首先对于一个诚实的用户，尽管区块 reorg 经常发生，但只要该用户不主动进行双花交易，BTC 链上打包的用户交易是不变的，因此不会影响到 CKB 链上的 RGB++ 资产和状态。

考虑一笔 L1 RGB++ 交易，假设为了用户体验我们允许单块 BTC 交易确认即可发起同构交易，即在 CKB 构造同步的 RGB++ 资产交易。此时，对于恶意用户，TA 可能构造一笔新的 BTC 交易，取代之前的 BTC TX B，使得 CKB TX B‘ 找不到对应的 BTC 交易，但这时 CKB TX B’ 已经上链。这里的后果是，在 BTC 上被双花的 btc_utxo#2 在 CKB 上的同构映射 cell 已经在 CKB TX B’ 中消耗了，即使用户双花了 BTC 上的 utxo，他也无法双花 RGB++ 的资产，同时先前交易生成的 RGB++ cell 输出（ lock 为 btc_utxo#3）也因为链式交易的失效而被永久锁定。所以恶意用户在 BTC 上做双花交易不会有任何收益，还会导致自己的资产失效。

考虑一笔 L2 RGB++ 交易，它 100% 运行在 CKB 上，因此我们只需要符合原来的交易逻辑即可，即也可以在 dapp 中获得连续操作的体验。

最后考虑一笔 Jump 操作，用户将 RGB++ 资产从一个 Bitcoin UTXO 中转到一个 CKB 地址上，后续的操作会持续发生在 CKB 上，此时我们需要考虑因 Bitcoin TX revert 造成的 CKB 上资产复制的问题。

![sequencing2](./assets/sa-sequencing2.png)

考虑上面的交易，BTC_TX_A 和 CKB_TX_B 同构绑定，之后 BTC_TX_A 被重构成 BTC_TX_A’，此时同构绑定的交易 CKB_TX_B’ 无法通过 ckb 共识上链，因为它依赖的 input (lock= btc_utxo#1)已经在 CKB_TX_B 中被使用了。这就导致 BTC 上的交易和 CKB 的交易同构绑定失败。但注意，如果同构绑定失败，但相关的所有资产均被锁定，那么我们不认为出现了安全性问题。因为这种失败源自交易发起人主观攻击协议，那么TA的所有资产被永久锁定不是问题。

但图示的操作中，我们发现 CKB 上的两个输出，RGB++ cell 的 lock 是 btc_utxo#2，它依赖被 revert 的旧的 BTC 交易，因此被永久锁定，没问题。单另一个 ckb cell 则不受影响。这就造成了安全风险。

因此，我们引入一个新的 lock，暂定名为 btc_time_lock 通过提供额外的锁定逻辑来解决这个问题。

### **BTC Time Lock**
btc_time_lock 的核心参数有三个，分别是 lock_hash，after，和 bitcoin_tx。它具体的含意是：“仅当在参数中指定的 bitcoin_tx 被超过 after 个 btc 区块确认后，本 cell 才可以被解锁，且解锁后需要换成 lock_hash 指定的 lockscript(ckb 地址)”。 我们以上面的例子看一下 btc_time_lock 是如何工作的。

![time lock](./assets/sa-time-lock.png)

和之前的讨论相同，如果 BTC_TX_A 被 revert 了，对应的 RGB++ Cell 被永久锁定，而其他的 CKB cell 则按照要求被放置在 btc_time_lock 中，且他们被解锁的条件是 BTC_TX_A 经过了 6 个区块确认。那么显然由于 BTC_TX_A 不存在而因此被永久锁定。反过来讲，如果 6 个 btc 确认后，BTC_TX_A 仍然存在，那么该 CKB Cell 就可以正常使用。

## **总结**
总结来说，RGB++ 不论在 L1 还是在 L2 上都可以获得与 Bitcoin 相同级别的安全性，在 L1 和 L2 Jump 时，RGB++ 协议额外要求资产锁定 6 个或更多的 BTC 区块，以获得在跨层使用时一致的安全性。RGB++ 协议在不妥协安全性的前提下为 BTC 网络进行了图灵完备的补充和性能的扩展。

## References
[RGB++ 深入讨论(1): 安全性分析](https://talk.nervos.org/t/rgb-1/7798)  
[直播回顾｜RGB++ 的前世今生](https://talk.nervos.org/t/rgb/7817)

================================================
File: docs/security-analysis-en.md
================================================
# A Deep Dive into RGB++: Security Analysis 

*Cipher from CELL Studio & Nervos Foundation*

> Special thanks to [Ren Zhang](https://scholar.google.com/citations?hl=en&user=JB1uRvQAAAAJ), [Ian](https://github.com/doitian), and [c4605](https://talk.nervos.org/u/c4605/summary) for feedback and discussion.
> The RGB receiver optimization approach is inspired by [Jason Cai](https://twitter.com/CryptoStwith).

## **PoW is More Secure Than You Think**
The security concern in Proof-of-Work (PoW) lies in block revert/reorg which can enable double-spending attacks. Consider a network with an honest miner, a user’s status and assets would remain accurate, then only the block reorganization there could cause losses from double-spending. Consequently, the core security assumption of PoW is that transactions are highly unlikely to be reverted after N blocks. In Bitcoin’s case, 6 or fewer blocks are typically considered secure enough against double-spends.

Obviously, Bitcoin transactions with 6 confirmations are more secure than 1 confirmation. So is there a linear relationship between the number of PoW confirmations and security? No, **the difficulty of overturning a block increases exponentially as the depth of the block increases**. The precise parameters of this exponential security growth have been analyzed in dozens of research papers. What has become clear is that “N confirmations” provide greater security than previously thought.

According to calculations by Dr. [Ren Zhang](https://scholar.google.com/citations?hl=en&user=JB1uRvQAAAAJ), assuming that the adversary’s Hash rate accounts for 30%, CKB would need to maintain a 2.5% orphan block rate and require 23.29 confirmations to match the security of 6 confirmations on Bitcoin with a 0% orphan rate. This equivalence relationship provides a convenient way to discuss the security of various typical operations in the RGB++ protocol.

![pow](./assets/sa-pow.png)
***Schematic diagram of PoW security (non-theoretical calculation)***

## **Security of RGB**
RGB binds the status and contracts of RGB to Bitcoin UTXO using single use seals and client-side validation methods. This provides an extension of Turing-complete scalability for Bitcoin. There are two types of transaction security: 1) Correctness of state calculations, 2) Transaction certainty. Client-side validation ensures the correctness of state calculations. Everyone is responsible for their own state and does not rely on any third party. Single-use seals based on BTC UTXO ensure that the difficulty of double spending on RGB matches that of double spending on Bitcoin. Therefore, we can say that **RGB inherits 100% of Bitcoin’s security**. Users can achieve their desired security threshold by waiting for the corresponding number of Bitcoin confirmations.

## **Security of RGB++ Protocol**
### **L1 Transaction Security**
L1 transactions for RGB++ refer to that the “holder” of UTXOs for RGB++ transactions is the holder of Bitcoin’s UTXOs. That is, only consuming Bitcoin UTXO can operate or update RGB++ UTXO. In this model, although each RGB++ transaction initiates a parallel CKB transaction, its security does not rely on CKB. CKB is only utilized for data availability and status disclosure purposes. Therefore, the L1 transaction security of RGB++, identical to RGB protocol, fully inherits the security of Bitcoin.

### **L2 Transaction Security**
L2 transactions occur 100% on CKB, meaning CKB is responsible for 100% of L2 security. However,due to the non-linear security scaling of PoW chains previously mentioned, 24 block CKB confirmations provide equivalent security to 6 confirmed Bitcoin transactions. Therefore, we could believe that L2 transaction security matches L1 transaction security(more block confirmations needed but cost shorter time for the actual confirmation).

The prerequisite for realizing this equivalent security is that the RGB++ isomorphic mapping chain must be PoW. If it were a PoS chain, its security upper bound would be limited by the staking amount of PoS no matter the number of confirmed blocks, which cannot compare to Bitcoin’s security.

### **Jump Operation**
The RGB++ protocol enables users to seamlessly transfer their assets between Bitcoin and CKB in either direction at any time. There is no need for a cross-chain bridge during the switching process, and any reliance on multi-signature parties. This transition of assets or state between chains is called a Jump operation.

Before and after the Jump operation, the core points that affect the security of the RBG++ protocol are:

Single-use seals, from using Bitcoin UTXO to using CKB UTXO, or vice versa;
Unchanged client verification data on CKB as they are the isomorphic binding transactions on CKB.
During a Jump, users need to wait for sufficient block confirmations on both Bitcoin and CKB to to ensure the security.

### **Optimization of RGB Payee UTXO**
Considering the original RGB protocol, in order to achieve transaction privacy, the payee of the RGB transaction initiated on Bitcoin (i.e. Bitcoin UTXO) is not consistent with the output of theBitcoin transaction. This makes it impossible for observers to track RGB transactions similarly to Bitcoin transactions.

In contrast, in the RGB++ protocol, all transactions on RGB++ layer are isomorphically bound and published on CKB. Although it greatly simplifies user transaction verification, it, regrettably, compromises the anonymity of the orginal RGB protocol (the RGB++ protocol can leverage the privacy layer on CKB for [more powerful privacy attributes](https://forum.grin.mw/t/a-draft-design-of-mimblewimble-on-nervos-ckb/7695)). To address this, RGB++ adjusts the payee’s role, eliminating the need for the payee to provide their UTXO in advance. Only a payment address is required, as the RGB++ transaction will generate a UTXO pointing to the payee during a BTC transaction. In this way, non-interactive transfers can be completed, greatly simplifying the user’s operation process. Please Note that certain simplifications are made in the diagram below: to achieve isomorphic binding, some fields present in BTC and CKB transactions are excluded from commitment to prevent mutual inclusion conflicts.

![payee](./assets/sa-payee.png)

### **Transaction Sequencing**
As outlined above, the optimization of RGB non-interactive transfers, serves a dual purpose by significantly enhancing user experience and playing a pivotal role in the optimization of transaction confirmations.

![sequencing1](./assets/sa-sequencing1.png)

First, for an honest user, block reorgs on the BTC chain often occur but do not affect the validity of their transactions or associated RGB++ assets and status on the CKB chain, as long as they do not intentionally initiate double spending.

Consider an L1 RGB++ transaction, for better user experience, we allow a single block of BTC transactions to be confirmed to initiate isomorphic transactions, that is, construct a synchronized RGB++ asset transaction on CKB. At this point, a malicious user could construct a new BTC transaction to replace a previous BTC TX B, which means that CKB TX B’ cannot find the corresponding BTC transaction. However, the new CKB TX B’ has already been committed to the CKB chain. As a result, the isomorphic mapping cell on CKB of btc_utxo#2 which was double spent on BTC has been consumed in CKB TX B’. Even if the malicious user successfully double-spend utxo on BTC, he cannot double-spend the corresponding assets on RGB++. At the same time, the RGB++ cell output generated by the previous transaction (lock is btc_utxo#3) is also locked due to the failure of the chain transaction. In summary, malicious users cannot benefit from BTC double-spends and will cause their own RGB++ assets to become unusable.

For an L2 RGB++ transaction which runs 100% on CKB, we only need to comply with the original transaction logic. In other words, we can have a continuous experience within the dApp.

Finally, consider a “Jump” operation where a user transfers RGB++ assets from a Bitcoin UTXO to a CKB address and subsequent operations continue on CKB. In this case, we need to consider the problem of asset duplication on CKB caused by Bitcoin TX revert.

![sequencing2](./assets/sa-sequencing2.png)

Taking the above transaction, where BTC_TX_A on Bitcoin is isomorphically bound to CKB_TX_B on Nervos CKB, as an example. If BTC_TX_A gets reorganized as BTC_TX_A’, the isomorphic transaction CKB_TX_B’ cannot be validated through the CKB consensus, as it relies on the input (lock = btc_utxo#1), which has already been utilized in CKB_TX_B. Consequently, the isomorphic binding of transactions on BTC and CKB fails. Please note that if isomorphic binding fails while all related assets are locked, we do not consider it a security issue. This failure results from transaction initiator’s intentionally attacks, it should not be a problem that all his assets are permanently locked.

But as shown in the above figure, there are two outputs on CKB. The lock on the RGB++ cell is btc_utxo#2. Since it depends on the old BTC transaction that has been reverted, there is no issue with it being permanently locked. However, the other CKB cell remains unaffected, which brings a security risk.

Therefore, we introduce a new lock, tentatively named btc_time_lock, aiming to mitigate the issue by incorporating additional locking logic.

### **BTC Time Lock**
There are three core parameters of btc_time_lock: lock_hash，after，和 bitcoin_tx. Its specific meaning is: “Only when the bitcoin_tx specified in the parameter is confirmed by more than after btc blocks, this cell can then be unlocked. After unlocking, it needs to be replaced with the lock script (CKB address) specified by lock_hash.” Let’s use the above example to see how btc_time_lock works.

![time lock](./assets/sa-time-lock.png)

Same as the previous discussion, if BTC_TX_A is reverted, the corresponding RGB++ Cell will be permanently locked. The other CKB Cell is placed in btc_time_lock as required, with the condition for their unlock being the confirmation of BTC_TX_A by 6 blocks. Then, apparently, BTC_TX_A is permanently locked since it does not exist. On the other hand, if BTC_TX_A still exists after the confirmation from six BTC blocks, then the CKB Cell can function normally.

## **Summary**
In summary, the RGB++ protocol provide a level of security equivalent to Bitcoin, whether having jump operations on Layer 1 or Layer 2. Jump between L1 and L2 requires the additional step of locking assets for six or more BTC blocks, ensuring consistent security approach when across layers. The RGB++ protocol complements the BTC network by providing Turing-complete functionality and enhanced performance without compromising security.

## References
[A Deep Dive into RGB++: Security Analysis](https://talk.nervos.org/t/a-deep-dive-into-rgb-security-analysis-translation/7816)

