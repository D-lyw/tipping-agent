Directory structure:
└── utxostack-rgbpp-sdk/
    ├── README.md
    ├── Dockerfile
    ├── LICENSE
    ├── package.json
    ├── pnpm-lock.yaml
    ├── pnpm-workspace.yaml
    ├── vitest.config.mts
    ├── vitest.workspace.mts
    ├── .dockerignore
    ├── .eslintrc.json
    ├── .prettierignore
    ├── .prettierrc
    ├── apps/
    │   └── service/
    │       ├── README.md
    │       ├── docker-compose.yml
    │       ├── nest-cli.json
    │       ├── package.json
    │       ├── tsconfig.build.json
    │       ├── tsconfig.json
    │       ├── vitest.project.mts
    │       ├── .env.example
    │       ├── .gitignore
    │       ├── src/
    │       │   ├── app.module.ts
    │       │   ├── app.service.ts
    │       │   ├── env.ts
    │       │   ├── main.ts
    │       │   ├── json-rpc/
    │       │   │   ├── json-rpc.decorators.ts
    │       │   │   ├── json-rpc.module.ts
    │       │   │   └── json-rpc.server.ts
    │       │   ├── rgbpp/
    │       │   │   ├── rgbpp.module.ts
    │       │   │   ├── rgbpp.service.ts
    │       │   │   └── types.ts
    │       │   └── utils/
    │       │       ├── case.ts
    │       │       └── json.ts
    │       └── tests/
    │           └── Utils.test.ts
    ├── examples/
    │   ├── rgbpp/
    │   │   ├── README.md
    │   │   ├── env.ts
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── .env.example
    │   │   ├── logs/
    │   │   │   └── .gitkeep
    │   │   ├── shared/
    │   │   │   ├── btc-account.ts
    │   │   │   └── utils.ts
    │   │   ├── spore/
    │   │   │   ├── 4-transfer-spore.ts
    │   │   │   ├── 5-leap-spore-to-ckb.ts
    │   │   │   ├── 6-unlock-btc-time-cell.ts
    │   │   │   ├── 7-leap-spore-to-btc.ts
    │   │   │   ├── launch/
    │   │   │   │   ├── 0-cluster-info.ts
    │   │   │   │   ├── 1-prepare-cluster.ts
    │   │   │   │   ├── 2-create-cluster.ts
    │   │   │   │   └── 3-create-spores.ts
    │   │   │   └── local/
    │   │   │       ├── 4-transfer-spore.ts
    │   │   │       └── 5-leap-spore-to-ckb.ts
    │   │   └── xudt/
    │   │       ├── 1-ckb-leap-btc.ts
    │   │       ├── 2-btc-transfer.ts
    │   │       ├── 3-btc-leap-ckb.ts
    │   │       ├── 4-unlock-btc-time-cell.ts
    │   │       ├── btc-transfer-all/
    │   │       │   └── 1-btc-transfer-all.ts
    │   │       ├── compatible-xudt/
    │   │       │   ├── 1-ckb-leap-btc.ts
    │   │       │   ├── 2-btc-transfer.ts
    │   │       │   ├── 3-btc-leap-ckb.ts
    │   │       │   ├── 4-unlock-btc-time-cell.ts
    │   │       │   └── assets-api.ts
    │   │       ├── launch/
    │   │       │   ├── 0-rgbpp-token-info.ts
    │   │       │   ├── 1-prepare-launch.ts
    │   │       │   ├── 2-launch-rgbpp.ts
    │   │       │   └── 3-distribute-rgbpp.ts
    │   │       ├── local/
    │   │       │   ├── 2-btc-transfer.ts
    │   │       │   └── 3-btc-leap-ckb.ts
    │   │       └── offline/
    │   │           ├── 0-rgbpp-token-info.ts
    │   │           ├── 1-prepare-launch.ts
    │   │           ├── 2-launch-rgbpp.ts
    │   │           ├── 3-distribute-rgbpp.ts
    │   │           ├── 4-btc-leap-ckb.ts
    │   │           ├── 5-unlock-btc-time-cell.ts
    │   │           ├── 6-ckb-leap-btc.ts
    │   │           └── compatible-xudt/
    │   │               ├── 1-ckb-leap-btc.ts
    │   │               ├── 2-btc-transfer.ts
    │   │               ├── 3-btc-leap-ckb.ts
    │   │               └── 4-unlock-btc-time-cell.ts
    │   └── xudt-on-ckb/
    │       ├── README.md
    │       ├── 1-issue-xudt.ts
    │       ├── 2-transfer-xudt.ts
    │       ├── 3-generate-btc-time-cell.ts
    │       ├── env.ts
    │       ├── package.json
    │       ├── tsconfig.json
    │       └── .env.example
    ├── packages/
    │   ├── btc/
    │   │   ├── README.md
    │   │   ├── CHANGELOG.md
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── tsup.config.ts
    │   │   ├── .env.example
    │   │   ├── src/
    │   │   │   ├── address.ts
    │   │   │   ├── bitcoin.ts
    │   │   │   ├── error.ts
    │   │   │   ├── index.ts
    │   │   │   ├── script.ts
    │   │   │   ├── utils.ts
    │   │   │   ├── api/
    │   │   │   │   ├── sendBtc.ts
    │   │   │   │   ├── sendRbf.ts
    │   │   │   │   ├── sendRgbppUtxos.ts
    │   │   │   │   └── sendUtxos.ts
    │   │   │   ├── preset/
    │   │   │   │   ├── config.ts
    │   │   │   │   ├── network.ts
    │   │   │   │   └── types.ts
    │   │   │   ├── query/
    │   │   │   │   ├── cache.ts
    │   │   │   │   └── source.ts
    │   │   │   └── transaction/
    │   │   │       ├── build.ts
    │   │   │       ├── embed.ts
    │   │   │       ├── fee.ts
    │   │   │       └── utxo.ts
    │   │   └── tests/
    │   │       ├── Address.test.ts
    │   │       ├── DataSource.test.ts
    │   │       ├── Embed.test.ts
    │   │       ├── Network.test.ts
    │   │       ├── Script.test.ts
    │   │       ├── Transaction.test.ts
    │   │       ├── Utils.test.ts
    │   │       └── shared/
    │   │           ├── env.ts
    │   │           └── utils.ts
    │   ├── ckb/
    │   │   ├── README.md
    │   │   ├── CHANGELOG.md
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── tsup.config.ts
    │   │   ├── example/
    │   │   │   ├── launch.ts
    │   │   │   └── paymaster.ts
    │   │   └── src/
    │   │       ├── index.ts
    │   │       ├── collector/
    │   │       │   ├── collector.spec.ts
    │   │       │   ├── index.ts
    │   │       │   └── offline.ts
    │   │       ├── constants/
    │   │       │   └── index.ts
    │   │       ├── error/
    │   │       │   └── index.ts
    │   │       ├── paymaster/
    │   │       │   └── index.ts
    │   │       ├── rgbpp/
    │   │       │   ├── btc-jump-ckb.ts
    │   │       │   ├── btc-time.ts
    │   │       │   ├── btc-transfer.ts
    │   │       │   ├── ckb-builder.ts
    │   │       │   ├── ckb-jump-btc.ts
    │   │       │   ├── index.ts
    │   │       │   ├── launch.ts
    │   │       │   └── schemas.spec.ts
    │   │       ├── schemas/
    │   │       │   ├── customized.ts
    │   │       │   ├── lumos-molecule-codegen.json
    │   │       │   ├── generated/
    │   │       │   │   ├── blockchain.ts
    │   │       │   │   └── rgbpp.ts
    │   │       │   └── schemas/
    │   │       │       ├── blockchain.mol
    │   │       │       └── rgbpp.mol
    │   │       ├── spore/
    │   │       │   ├── cluster.ts
    │   │       │   ├── index.ts
    │   │       │   ├── leap.ts
    │   │       │   └── spore.ts
    │   │       ├── types/
    │   │       │   ├── collector.ts
    │   │       │   ├── common.ts
    │   │       │   ├── index.ts
    │   │       │   ├── rgbpp.ts
    │   │       │   ├── spore.ts
    │   │       │   └── spv.ts
    │   │       └── utils/
    │   │           ├── case-parser.spec.ts
    │   │           ├── case-parser.ts
    │   │           ├── cell-dep.spec.ts
    │   │           ├── cell-dep.ts
    │   │           ├── ckb-tx.spec.ts
    │   │           ├── ckb-tx.ts
    │   │           ├── hex.spec.ts
    │   │           ├── hex.ts
    │   │           ├── id.spec.ts
    │   │           ├── id.ts
    │   │           ├── index.ts
    │   │           ├── rgbpp.spec.ts
    │   │           ├── rgbpp.ts
    │   │           ├── spore.spec.ts
    │   │           └── spore.ts
    │   ├── rgbpp/
    │   │   ├── README.md
    │   │   ├── CHANGELOG.md
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── tsup.config.ts
    │   │   ├── .env.example
    │   │   ├── src/
    │   │   │   ├── btc.ts
    │   │   │   ├── ckb.ts
    │   │   │   ├── index.ts
    │   │   │   ├── service.ts
    │   │   │   └── rgbpp/
    │   │   │       ├── error.ts
    │   │   │       ├── summary/
    │   │   │       │   └── asset-summarizer.ts
    │   │   │       ├── types/
    │   │   │       │   └── xudt.ts
    │   │   │       ├── utils/
    │   │   │       │   ├── group.ts
    │   │   │       │   └── transaction.ts
    │   │   │       └── xudt/
    │   │   │           ├── btc-transfer-all.ts
    │   │   │           └── btc-transfer.ts
    │   │   └── tests/
    │   │       ├── Group.test.ts
    │   │       ├── RgbppXudt.test.ts
    │   │       ├── __snapshots__/
    │   │       │   └── RgbppXudt.test.ts.snap
    │   │       ├── mocked/
    │   │       │   └── 50-included-41-excluded.ts
    │   │       └── shared/
    │   │           ├── account.ts
    │   │           └── env.ts
    │   └── service/
    │       ├── README.md
    │       ├── CHANGELOG.md
    │       ├── package.json
    │       ├── tsconfig.json
    │       ├── tsup.config.ts
    │       ├── .env.example
    │       ├── src/
    │       │   ├── ckb-types.d.ts
    │       │   ├── error.ts
    │       │   ├── index.ts
    │       │   ├── utils.ts
    │       │   ├── service/
    │       │   │   ├── base.ts
    │       │   │   ├── index.ts
    │       │   │   ├── offline-service.ts
    │       │   │   └── service.ts
    │       │   └── types/
    │       │       ├── base.ts
    │       │       ├── btc.ts
    │       │       ├── index.ts
    │       │       └── rgbpp.ts
    │       └── tests/
    │           ├── Service.test.ts
    │           └── Utils.test.ts
    ├── tests/
    │   └── rgbpp/
    │       ├── env.ts
    │       ├── package.json
    │       ├── tsconfig.json
    │       ├── shared/
    │       │   ├── prepare-utxo.ts
    │       │   └── utils.ts
    │       ├── spore/
    │       │   ├── 4-transfer-spore.ts
    │       │   ├── 5-leap-spore-to-ckb.ts
    │       │   └── launch/
    │       │       ├── 0-cluster-info.ts
    │       │       ├── 1-prepare-cluster.ts
    │       │       ├── 2-create-cluster.ts
    │       │       └── 3-create-spores.ts
    │       ├── testnet/
    │       │   └── .gitkeep
    │       └── xudt/
    │           ├── 1-ckb-leap-btc.ts
    │           ├── 2-btc-transfer.ts
    │           ├── 3-btc-leap-ckb.ts
    │           ├── btc-transfer-all/
    │           │   └── 1-btc-transfer-all.ts
    │           ├── compatible-xudt/
    │           │   ├── 1-ckb-leap-btc.ts
    │           │   ├── 2-btc-transfer.ts
    │           │   └── 3-btc-leap-ckb.ts
    │           └── xudt-on-ckb/
    │               ├── 1-issue-xudt.ts
    │               └── 2-transfer-xudt.ts
    ├── .changeset/
    │   ├── README.md
    │   ├── changelog-format.cjs
    │   └── config.json
    ├── .github/
    │   └── workflows/
    │       ├── docker.yml
    │       ├── integration-test.yaml
    │       ├── release.yml
    │       ├── snapshot.yml
    │       └── test.yaml
    └── .husky/
        └── pre-commit

================================================
File: README.md
================================================
# RGB++ SDK

This repository offers utilities for Bitcoin and RGB++ asset integration.

### Packages in this repository

- [@rgbpp-sdk/btc](./packages/btc): Bitcoin part of the SDK
- [@rgbpp-sdk/ckb](./packages/ckb): Nervos CKB part of the SDK
- [@rgbpp-sdk/service](./packages/service): Wrapped interfaces of `Bitcoin/RGB++ Assets Service`


## RGB++ Code Examples

- Find code examples at https://github.com/ckb-cell/rgbpp-sdk/tree/develop/examples/rgbpp


## Related CKB Scripts (Contracts)
- [CKB Bitcoin SPV Type Script](https://github.com/ckb-cell/ckb-bitcoin-spv-contracts/tree/master/contracts/ckb-bitcoin-spv-type-lock): A [type script](https://docs-old.nervos.org/docs/basics/glossary#type-script) for [Bitcoin SPV](https://bitcoinwiki.org/wiki/simplified-payment-verification) clients which synchronize [Bitcoin](https://bitcoin.org) state into [CKB](https://github.com/nervosnetwork/ckb)

- **RGB++ scripts/contracts**: [RgbppLockScript](https://github.com/ckb-cell/rgbpp/tree/main/contracts/rgbpp-lock) and [BtcTimeLockScript](https://github.com/ckb-cell/rgbpp/tree/main/contracts/btc-time-lock)
  * design docs: https://github.com/ckb-cell/RGBPlusPlus-design/blob/main/docs/lockscript-design-prd-en.md
  * testnet deployment: https://pudge.explorer.nervos.org/scripts#RGB++
  * mainnet deployment: https://explorer.nervos.org/scripts#RGB++


## RGB++ Asset Workflow Overview

1. **Creation of `rgbpp_ckb_tx_virtual` using [@rgbpp-sdk/ckb](https://github.com/ckb-cell/rgbpp-sdk/tree/develop/packages/ckb)**

  - xUDT

    1. **[BTC → BTC](https://github.com/ckb-cell/rgbpp-sdk/tree/develop/packages/ckb#rgb-xudt-transfer-on-btc)**
    2. **[BTC → CKB](https://github.com/ckb-cell/rgbpp-sdk/tree/develop/packages/ckb#rgb-xudt-leap-from-btc-to-ckb)**
    3. **[CKB → BTC](https://github.com/ckb-cell/rgbpp-sdk/tree/develop/packages/ckb#rgb-xudt-leap-from-ckb-to-btc)** *(isomorphic rgbpp_btc_tx is not required in this workflow)*

  - Spore
  
    1. **[BTC → BTC](https://github.com/ckb-cell/rgbpp-sdk/blob/develop/packages/ckb/README.md#rgb-spore-transfer-on-btc)**
    2. **[BTC → CKB](https://github.com/ckb-cell/rgbpp-sdk/blob/develop/packages/ckb/README.md#rgb-spore-leap-from-btc-to-ckb)**
    3. **[CKB → BTC](https://github.com/ckb-cell/rgbpp-sdk/blob/develop/packages/ckb/README.md#rgb-spore-leap-from-ckb-to-btc)** *(isomorphic rgbpp_btc_tx is not required in this workflow)*

  > [!IMPORTANT]
  > It's recommended to save the `rgbpp_ckb_tx_virtual` locally in case you need it in the future.

2. **Creation of `rgbpp_btc_tx` through [@rgbpp-sdk/btc](https://github.com/ckb-cell/rgbpp-sdk/tree/develop/packages/btc)**
    1. construct isomorphic `rgbpp_btc_tx` based on `rgbpp_ckb_tx_virtual` and rgbpp commitment
    2. sign and broadcast `rgbpp_btc_tx` to obtain `rgbpp_btc_txid`

3. JoyID or dApp sends `rgbpp_btc_txid` and `rgbpp_ckb_tx_virtual` to RGB++ CKB transaction Queue (API Endpoint: `/rgbpp/v1/transaction/ckb-tx`)

4. `RGB++ CKB transaction Queue` will process the following things:
    1. **verify** the received requests
    2. continuously fetch request from the queue through a **cron job**
    3. check whether the **confirmations** of `req.rgbpp_btc_txid` is sufficient
    4. generate the **witnesses for RgbppLocks** in the `rgbpp_ckb_tx_virtual`
    5. add a **paymaster cell** into `rgbpp_ckb_tx_virtual` inputs if the CKB capacity is insufficient
        1. need to **verify the existence of paymaster UTXO** in the rgbpp_btc_tx
           > based on the exchange rates of BTC and CKB, [the paymaster BTC UTXO's value](https://api.rgbpp.io/docs/static/index.html#/RGB%2B%2B/get_rgbpp_v1_paymaster_info) required to subsidize a paymaster CKB cell is approximately: `paymaster_utxo_sats ~= 316 * ${ckb_price} / ${btc_price} * 100000000`
        2. sign the paymaster cell and the entire transaction if needed

    6. **finalize** the `rgbpp_ckb_tx_virtual` to a `rgbpp_ckb_tx`
    7. **broadcast** `rgbpp_ckb_tx` and mark the job as completed upon tx-confirmation

### Notes

- [`Bitcoin/RGB++ Assets Service`](https://github.com/ckb-cell/btc-assets-api) is an open-source project designed to streamline the transaction workflow for Bitcoin and RGB++ Assets. Developers have the option to enhance it by implementing its features by themselves without limitations. 
- For those who prefer to deploy their own `Bitcoin/RGB++ Assets Service`, please follow the instructions at the [Deployment](https://github.com/ckb-cell/btc-assets-api#deployment) section in the btc-assets-api repository.


## FAQ

### How to get an access token of Bitcoin/RGB++ Assets Service?
See [Generate a JSON Web Token (JWT) for Bitcoin/RGB++ Assets Service](./packages/service/README.md#get-an-access-token)

### Where is the error code description for the RgbppLockScript?
See [RGB++ Lock Script Error Codes](https://github.com/nervosnetwork/ckb-script-error-codes/blob/main/by-type-hash/bc6c568a1a0d0a09f6844dc9d74ddb4343c32143ff25f727c59edf4fb72d6936.md)

## License

[ISC](./LICENSE) License


================================================
File: Dockerfile
================================================
FROM node:20-slim AS base

ENV PNPM_HOME="/pnpm"
ENV PATH="$PNPM_HOME:$PATH"
RUN corepack enable
RUN corepack use pnpm@latest

COPY . /app
WORKDIR /app

FROM base AS prod-deps
RUN npm pkg delete scripts.prepare
RUN --mount=type=cache,id=pnpm,target=/pnpm/store pnpm install --prod --frozen-lockfile

FROM base AS build
RUN --mount=type=cache,id=pnpm,target=/pnpm/store pnpm install --frozen-lockfile
RUN pnpm run build

FROM base AS service
COPY --from=prod-deps /app/node_modules /node_modules
COPY --from=build /app/packages /app/packages
COPY --from=build /app/apps/service /app/apps/service

WORKDIR /app/apps/service
RUN pnpm add @nestjs/cli -D

ENV NODE_ENV=production
EXPOSE 3000
CMD [ "pnpm", "start" ]


================================================
File: LICENSE
================================================
ISC License

Copyright (c) 2024 CELL Studio

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.


================================================
File: package.json
================================================
{
  "name": "rgbpp-sdk",
  "private": true,
  "workspaces": [
    "packages/*"
  ],
  "scripts": {
    "prepare": "husky",
    "build": "pnpm run --r --filter \"./{packages,apps,examples,tests}/**\" build",
    "build:packages": "pnpm run --r --filter \"./packages/**\" build",
    "test:packages": "pnpm run --r --filter \"./packages/**\" test",
    "test:service": "pnpm run --r --filter=./apps/service test",
    "dev:service": "pnpm run --r --filter=./apps/service dev",
    "lint": "eslint {packages,apps,examples,tests}/**/*.ts && prettier --check '{packages,apps,examples,tests}/**/*.ts'",
    "lint:fix": "eslint --fix {packages,apps,examples,tests}/**/*.ts",
    "format": "prettier --write '{packages,apps,examples,tests}/**/*.{js,jsx,ts,tsx}'",
    "clean:dependencies": "pnpm clean:sub-dependencies && rimraf node_modules",
    "clean:sub-dependencies": "rimraf packages/**/node_modules apps/**/node_modules",
    "release:packages": "pnpm run build:packages && changeset publish"
  },
  "devDependencies": {
    "@changesets/cli": "^2.27.1",
    "@changesets/get-github-info": "^0.6.0",
    "@changesets/types": "^6.0.0",
    "@types/lodash": "^4.17.0",
    "@typescript-eslint/eslint-plugin": "^7.8.0",
    "@typescript-eslint/parser": "^7.8.0",
    "eslint": "^8.56.0",
    "husky": "^9.1.7",
    "lint-staged": "^15.3.0",
    "prettier": "^3.4.2",
    "tsx": "4.16.3",
    "tsup": "^8.3.5",
    "typescript": "5.4.3",
    "vitest": "2.1.9"
  },
  "lint-staged": {
    "{packages,apps,examples,tests}/**/*.{js,jsx,ts,tsx}": [
      "eslint --fix",
      "prettier --ignore-unknown --write"
    ]
  },
  "packageManager": "pnpm@9.0.0",
  "engines": {
    "node": ">=21.0.0",
    "pnpm": ">=9.0.0"
  }
}


================================================
File: pnpm-lock.yaml
================================================
lockfileVersion: '9.0'

settings:
  autoInstallPeers: true
  excludeLinksFromLockfile: false

importers:

  .:
    devDependencies:
      '@changesets/cli':
        specifier: ^2.27.1
        version: 2.27.7
      '@changesets/get-github-info':
        specifier: ^0.6.0
        version: 0.6.0
      '@changesets/types':
        specifier: ^6.0.0
        version: 6.0.0
      '@types/lodash':
        specifier: ^4.17.0
        version: 4.17.7
      '@typescript-eslint/eslint-plugin':
        specifier: ^7.8.0
        version: 7.16.1(@typescript-eslint/parser@7.16.1(eslint@8.57.0)(typescript@5.4.3))(eslint@8.57.0)(typescript@5.4.3)
      '@typescript-eslint/parser':
        specifier: ^7.8.0
        version: 7.16.1(eslint@8.57.0)(typescript@5.4.3)
      eslint:
        specifier: ^8.56.0
        version: 8.57.0
      husky:
        specifier: ^9.1.7
        version: 9.1.7
      lint-staged:
        specifier: ^15.3.0
        version: 15.3.0
      prettier:
        specifier: ^3.4.2
        version: 3.4.2
      tsup:
        specifier: ^8.3.5
        version: 8.3.5(@swc/core@1.7.11)(postcss@8.5.2)(tsx@4.16.3)(typescript@5.4.3)(yaml@2.6.1)
      tsx:
        specifier: 4.16.3
        version: 4.16.3
      typescript:
        specifier: 5.4.3
        version: 5.4.3
      vitest:
        specifier: 2.1.9
        version: 2.1.9(@types/node@20.14.11)(terser@5.31.3)

  apps/service:
    dependencies:
      '@nestjs/common':
        specifier: ^10.0.0
        version: 10.3.10(reflect-metadata@0.2.2)(rxjs@7.8.1)
      '@nestjs/config':
        specifier: ^3.2.2
        version: 3.2.3(@nestjs/common@10.3.10(reflect-metadata@0.2.2)(rxjs@7.8.1))(rxjs@7.8.1)
      '@nestjs/core':
        specifier: ^10.3.9
        version: 10.3.10(@nestjs/common@10.3.10(reflect-metadata@0.2.2)(rxjs@7.8.1))(reflect-metadata@0.2.2)(rxjs@7.8.1)
      '@nestjs/platform-fastify':
        specifier: ^10.3.9
        version: 10.3.10(@nestjs/common@10.3.10(reflect-metadata@0.2.2)(rxjs@7.8.1))(@nestjs/core@10.3.10(@nestjs/common@10.3.10(reflect-metadata@0.2.2)(rxjs@7.8.1))(reflect-metadata@0.2.2)(rxjs@7.8.1))
      camelcase-keys:
        specifier: ^7.0.2
        version: 7.0.2
      json-rpc-2.0:
        specifier: ^1.7.0
        version: 1.7.0
      lodash:
        specifier: ^4.17.21
        version: 4.17.21
      reflect-metadata:
        specifier: ^0.2.0
        version: 0.2.2
      rgbpp:
        specifier: workspace:*
        version: link:../../packages/rgbpp
      rxjs:
        specifier: ^7.8.1
        version: 7.8.1
      snakecase-keys:
        specifier: ^8.0.1
        version: 8.0.1
      zod:
        specifier: ^3.23.8
        version: 3.23.8
    devDependencies:
      '@nestjs/cli':
        specifier: ^10.0.0
        version: 10.4.2(@swc/core@1.7.11)(esbuild@0.24.2)
      '@nestjs/schematics':
        specifier: ^10.0.0
        version: 10.1.2(chokidar@3.6.0)(typescript@5.5.3)
      '@nestjs/testing':
        specifier: ^10.0.0
        version: 10.3.10(@nestjs/common@10.3.10(reflect-metadata@0.2.2)(rxjs@7.8.1))(@nestjs/core@10.3.10(@nestjs/common@10.3.10(reflect-metadata@0.2.2)(rxjs@7.8.1))(reflect-metadata@0.2.2)(rxjs@7.8.1))
      '@swc/core':
        specifier: ^1.7.11
        version: 1.7.11
      '@types/node':
        specifier: ^20.3.1
        version: 20.14.11
      '@types/supertest':
        specifier: ^6.0.0
        version: 6.0.2
      '@vitest/coverage-v8':
        specifier: ^2.0.5
        version: 2.0.5(vitest@2.1.9(@types/node@20.14.11)(terser@5.31.3))
      source-map-support:
        specifier: ^0.5.21
        version: 0.5.21
      supertest:
        specifier: ^6.3.3
        version: 6.3.4
      ts-loader:
        specifier: ^9.4.3
        version: 9.5.1(typescript@5.5.3)(webpack@5.92.1(@swc/core@1.7.11)(esbuild@0.24.2))
      ts-node:
        specifier: ^10.9.1
        version: 10.9.2(@swc/core@1.7.11)(@types/node@20.14.11)(typescript@5.5.3)
      tsconfig-paths:
        specifier: ^4.2.0
        version: 4.2.0
      type-fest:
        specifier: ^4.24.0
        version: 4.24.0
      typescript:
        specifier: ^5.1.3
        version: 5.5.3
      unplugin-swc:
        specifier: ^1.5.1
        version: 1.5.1(@swc/core@1.7.11)(rollup@4.34.7)

  examples/rgbpp:
    dependencies:
      '@nervosnetwork/ckb-sdk-utils':
        specifier: 0.109.5
        version: 0.109.5
      rgbpp:
        specifier: workspace:*
        version: link:../../packages/rgbpp
    devDependencies:
      '@types/dotenv':
        specifier: ^8.2.0
        version: 8.2.0
      dotenv:
        specifier: ^16.4.5
        version: 16.4.5

  examples/xudt-on-ckb:
    dependencies:
      '@nervosnetwork/ckb-sdk-utils':
        specifier: 0.109.5
        version: 0.109.5
      rgbpp:
        specifier: workspace:*
        version: link:../../packages/rgbpp
    devDependencies:
      '@types/dotenv':
        specifier: ^8.2.0
        version: 8.2.0
      dotenv:
        specifier: ^16.4.5
        version: 16.4.5

  packages/btc:
    dependencies:
      '@bitcoinerlab/secp256k1':
        specifier: ^1.1.1
        version: 1.1.1
      '@ckb-lumos/codec':
        specifier: 0.22.2
        version: 0.22.2
      '@nervosnetwork/ckb-types':
        specifier: 0.109.5
        version: 0.109.5
      '@rgbpp-sdk/ckb':
        specifier: workspace:^
        version: link:../ckb
      '@rgbpp-sdk/service':
        specifier: workspace:^
        version: link:../service
      bip32:
        specifier: ^4.0.0
        version: 4.0.0
      bitcoinjs-lib:
        specifier: ^6.1.5
        version: 6.1.6
      ecpair:
        specifier: ^2.1.0
        version: 2.1.0
      lodash:
        specifier: ^4.17.21
        version: 4.17.21
      p-limit:
        specifier: ^3.1.0
        version: 3.1.0

  packages/ckb:
    dependencies:
      '@ckb-lumos/base':
        specifier: ^0.22.2
        version: 0.22.2
      '@ckb-lumos/codec':
        specifier: ^0.22.2
        version: 0.22.2
      '@exact-realty/multipart-parser':
        specifier: ^1.0.13
        version: 1.0.14
      '@nervosnetwork/ckb-sdk-core':
        specifier: 0.109.5
        version: 0.109.5
      '@nervosnetwork/ckb-sdk-utils':
        specifier: 0.109.5
        version: 0.109.5
      '@nervosnetwork/ckb-types':
        specifier: 0.109.5
        version: 0.109.5
      '@rgbpp-sdk/service':
        specifier: workspace:^
        version: link:../service
      '@spore-sdk/core':
        specifier: ^0.2.0-beta.6
        version: 0.2.0(@ckb-lumos/lumos@0.23.0)(lodash@4.17.21)
      axios:
        specifier: ^1.7.4
        version: 1.7.4
      camelcase-keys:
        specifier: ^7.0.2
        version: 7.0.2
      js-sha256:
        specifier: ^0.11.0
        version: 0.11.0
    devDependencies:
      '@ckb-lumos/molecule':
        specifier: 0.0.0-canary-66bbbfd-20240805132534
        version: 0.0.0-canary-66bbbfd-20240805132534

  packages/rgbpp:
    dependencies:
      '@ckb-lumos/base':
        specifier: ^0.22.2
        version: 0.22.2
      '@ckb-lumos/codec':
        specifier: ^0.22.2
        version: 0.22.2
      '@nervosnetwork/ckb-sdk-utils':
        specifier: 0.109.5
        version: 0.109.5
      '@rgbpp-sdk/btc':
        specifier: workspace:*
        version: link:../btc
      '@rgbpp-sdk/ckb':
        specifier: workspace:*
        version: link:../ckb
      '@rgbpp-sdk/service':
        specifier: workspace:*
        version: link:../service
    devDependencies:
      '@types/node':
        specifier: ^20.3.1
        version: 20.14.11
      lodash:
        specifier: ^4.17.21
        version: 4.17.21
      zod:
        specifier: ^3.23.8
        version: 3.23.8

  packages/service:
    dependencies:
      '@ckb-lumos/base':
        specifier: 0.22.2
        version: 0.22.2
      '@ckb-lumos/codec':
        specifier: 0.22.2
        version: 0.22.2
      '@nervosnetwork/ckb-types':
        specifier: 0.109.5
        version: 0.109.5
      lodash:
        specifier: ^4.17.21
        version: 4.17.21

  tests/rgbpp:
    dependencies:
      '@nervosnetwork/ckb-sdk-utils':
        specifier: 0.109.5
        version: 0.109.5
      rgbpp:
        specifier: workspace:*
        version: link:../../packages/rgbpp
      zx:
        specifier: ^8.0.2
        version: 8.1.4
    devDependencies:
      '@types/dotenv':
        specifier: ^8.2.0
        version: 8.2.0
      dotenv:
        specifier: ^16.4.5
        version: 16.4.5

packages:

  '@ampproject/remapping@2.3.0':
    resolution: {integrity: sha512-30iZtAPgz+LTIYoeivqYo853f02jBYSd5uGnGpkFV0M3xOt9aN73erkgYAmZU43x4VfqcnLxW9Kpg3R5LC4YYw==}
    engines: {node: '>=6.0.0'}

  '@angular-devkit/core@17.3.8':
    resolution: {integrity: sha512-Q8q0voCGudbdCgJ7lXdnyaxKHbNQBARH68zPQV72WT8NWy+Gw/tys870i6L58NWbBaCJEUcIj/kb6KoakSRu+Q==}
    engines: {node: ^18.13.0 || >=20.9.0, npm: ^6.11.0 || ^7.5.6 || >=8.0.0, yarn: '>= 1.13.0'}
    peerDependencies:
      chokidar: ^3.5.2
    peerDependenciesMeta:
      chokidar:
        optional: true

  '@angular-devkit/schematics-cli@17.3.8':
    resolution: {integrity: sha512-TjmiwWJarX7oqvNiRAroQ5/LeKUatxBOCNEuKXO/PV8e7pn/Hr/BqfFm+UcYrQoFdZplmtNAfqmbqgVziKvCpA==}
    engines: {node: ^18.13.0 || >=20.9.0, npm: ^6.11.0 || ^7.5.6 || >=8.0.0, yarn: '>= 1.13.0'}
    hasBin: true

  '@angular-devkit/schematics@17.3.8':
    resolution: {integrity: sha512-QRVEYpIfgkprNHc916JlPuNbLzOgrm9DZalHasnLUz4P6g7pR21olb8YCyM2OTJjombNhya9ZpckcADU5Qyvlg==}
    engines: {node: ^18.13.0 || >=20.9.0, npm: ^6.11.0 || ^7.5.6 || >=8.0.0, yarn: '>= 1.13.0'}

  '@babel/code-frame@7.24.7':
    resolution: {integrity: sha512-BcYH1CVJBO9tvyIZ2jVeXgSIMvGZ2FDRvDdOIVQyuklNKSsx+eppDEBq/g47Ayw+RqNFE+URvOShmf+f/qwAlA==}
    engines: {node: '>=6.9.0'}

  '@babel/helper-string-parser@7.24.8':
    resolution: {integrity: sha512-pO9KhhRcuUyGnJWwyEgnRJTSIZHiT+vMD0kPeD+so0l7mxkMT19g3pjY9GTnHySck/hDzq+dtW/4VgnMkippsQ==}
    engines: {node: '>=6.9.0'}

  '@babel/helper-validator-identifier@7.24.7':
    resolution: {integrity: sha512-rR+PBcQ1SMQDDyF6X0wxtG8QyLCgUB0eRAGguqRLfkCA87l7yAP7ehq8SNj96OOGTO8OBV70KhuFYcIkHXOg0w==}
    engines: {node: '>=6.9.0'}

  '@babel/highlight@7.24.7':
    resolution: {integrity: sha512-EStJpq4OuY8xYfhGVXngigBJRWxftKX9ksiGDnmlY3o7B/V7KIAc9X4oiK87uPJSc/vs5L869bem5fhZa8caZw==}
    engines: {node: '>=6.9.0'}

  '@babel/parser@7.24.8':
    resolution: {integrity: sha512-WzfbgXOkGzZiXXCqk43kKwZjzwx4oulxZi3nq2TYL9mOjQv6kYwul9mz6ID36njuL7Xkp6nJEfok848Zj10j/w==}
    engines: {node: '>=6.0.0'}
    hasBin: true

  '@babel/runtime@7.24.8':
    resolution: {integrity: sha512-5F7SDGs1T72ZczbRwbGO9lQi0NLjQxzl6i4lJxLxfW9U5UluCSyEJeniWvnhl3/euNiqQVbo8zruhsDfid0esA==}
    engines: {node: '>=6.9.0'}

  '@babel/types@7.24.9':
    resolution: {integrity: sha512-xm8XrMKz0IlUdocVbYJe0Z9xEgidU7msskG8BbhnTPK/HZ2z/7FP7ykqPgrUH+C+r414mNfNWam1f2vqOjqjYQ==}
    engines: {node: '>=6.9.0'}

  '@bcoe/v8-coverage@0.2.3':
    resolution: {integrity: sha512-0hYQ8SB4Db5zvZB4axdMHGwEaQjkZzFjQiN9LVYvIFB2nSUHW9tYpxWriPrWDASIxiaXax83REcLxuSdnGPZtw==}

  '@bitcoinerlab/secp256k1@1.1.1':
    resolution: {integrity: sha512-uhjW51WfVLpnHN7+G0saDcM/k9IqcyTbZ+bDgLF3AX8V/a3KXSE9vn7UPBrcdU72tp0J4YPR7BHp2m7MLAZ/1Q==}

  '@changesets/apply-release-plan@7.0.4':
    resolution: {integrity: sha512-HLFwhKWayKinWAul0Vj+76jVx1Pc2v55MGPVjZ924Y/ROeSsBMFutv9heHmCUj48lJyRfOTJG5+ar+29FUky/A==}

  '@changesets/assemble-release-plan@6.0.3':
    resolution: {integrity: sha512-bLNh9/Lgl1VwkjWZTq8JmRqH+hj7/Yzfz0jsQ/zJJ+FTmVqmqPj3szeKOri8O/hEM8JmHW019vh2gTO9iq5Cuw==}

  '@changesets/changelog-git@0.2.0':
    resolution: {integrity: sha512-bHOx97iFI4OClIT35Lok3sJAwM31VbUM++gnMBV16fdbtBhgYu4dxsphBF/0AZZsyAHMrnM0yFcj5gZM1py6uQ==}

  '@changesets/cli@2.27.7':
    resolution: {integrity: sha512-6lr8JltiiXPIjDeYg4iM2MeePP6VN/JkmqBsVA5XRiy01hGS3y629LtSDvKcycj/w/5Eur1rEwby/MjcYS+e2A==}
    hasBin: true

  '@changesets/config@3.0.2':
    resolution: {integrity: sha512-cdEhS4t8woKCX2M8AotcV2BOWnBp09sqICxKapgLHf9m5KdENpWjyrFNMjkLqGJtUys9U+w93OxWT0czorVDfw==}

  '@changesets/errors@0.2.0':
    resolution: {integrity: sha512-6BLOQUscTpZeGljvyQXlWOItQyU71kCdGz7Pi8H8zdw6BI0g3m43iL4xKUVPWtG+qrrL9DTjpdn8eYuCQSRpow==}

  '@changesets/get-dependents-graph@2.1.1':
    resolution: {integrity: sha512-LRFjjvigBSzfnPU2n/AhFsuWR5DK++1x47aq6qZ8dzYsPtS/I5mNhIGAS68IAxh1xjO9BTtz55FwefhANZ+FCA==}

  '@changesets/get-github-info@0.6.0':
    resolution: {integrity: sha512-v/TSnFVXI8vzX9/w3DU2Ol+UlTZcu3m0kXTjTT4KlAdwSvwutcByYwyYn9hwerPWfPkT2JfpoX0KgvCEi8Q/SA==}

  '@changesets/get-release-plan@4.0.3':
    resolution: {integrity: sha512-6PLgvOIwTSdJPTtpdcr3sLtGatT+Jr22+cQwEBJBy6wP0rjB4yJ9lv583J9fVpn1bfQlBkDa8JxbS2g/n9lIyA==}

  '@changesets/get-version-range-type@0.4.0':
    resolution: {integrity: sha512-hwawtob9DryoGTpixy1D3ZXbGgJu1Rhr+ySH2PvTLHvkZuQ7sRT4oQwMh0hbqZH1weAooedEjRsbrWcGLCeyVQ==}

  '@changesets/git@3.0.0':
    resolution: {integrity: sha512-vvhnZDHe2eiBNRFHEgMiGd2CT+164dfYyrJDhwwxTVD/OW0FUD6G7+4DIx1dNwkwjHyzisxGAU96q0sVNBns0w==}

  '@changesets/logger@0.1.0':
    resolution: {integrity: sha512-pBrJm4CQm9VqFVwWnSqKEfsS2ESnwqwH+xR7jETxIErZcfd1u2zBSqrHbRHR7xjhSgep9x2PSKFKY//FAshA3g==}

  '@changesets/parse@0.4.0':
    resolution: {integrity: sha512-TS/9KG2CdGXS27S+QxbZXgr8uPsP4yNJYb4BC2/NeFUj80Rni3TeD2qwWmabymxmrLo7JEsytXH1FbpKTbvivw==}

  '@changesets/pre@2.0.0':
    resolution: {integrity: sha512-HLTNYX/A4jZxc+Sq8D1AMBsv+1qD6rmmJtjsCJa/9MSRybdxh0mjbTvE6JYZQ/ZiQ0mMlDOlGPXTm9KLTU3jyw==}

  '@changesets/read@0.6.0':
    resolution: {integrity: sha512-ZypqX8+/im1Fm98K4YcZtmLKgjs1kDQ5zHpc2U1qdtNBmZZfo/IBiG162RoP0CUF05tvp2y4IspH11PLnPxuuw==}

  '@changesets/should-skip-package@0.1.0':
    resolution: {integrity: sha512-FxG6Mhjw7yFStlSM7Z0Gmg3RiyQ98d/9VpQAZ3Fzr59dCOM9G6ZdYbjiSAt0XtFr9JR5U2tBaJWPjrkGGc618g==}

  '@changesets/types@4.1.0':
    resolution: {integrity: sha512-LDQvVDv5Kb50ny2s25Fhm3d9QSZimsoUGBsUioj6MC3qbMUCuC8GPIvk/M6IvXx3lYhAs0lwWUQLb+VIEUCECw==}

  '@changesets/types@6.0.0':
    resolution: {integrity: sha512-b1UkfNulgKoWfqyHtzKS5fOZYSJO+77adgL7DLRDr+/7jhChN+QcHnbjiQVOz/U+Ts3PGNySq7diAItzDgugfQ==}

  '@changesets/write@0.3.1':
    resolution: {integrity: sha512-SyGtMXzH3qFqlHKcvFY2eX+6b0NGiFcNav8AFsYwy5l8hejOeoeTDemu5Yjmke2V5jpzY+pBvM0vCCQ3gdZpfw==}

  '@ckb-lumos/base@0.22.2':
    resolution: {integrity: sha512-nosUCSa5rTV2IzxbEpqzrvUeQNXB66mgA0h40+QEdnE/gV/s4ke83AScrTAxWkErJy1G/sToIHCc2kWwO95DfQ==}
    engines: {node: '>=12.0.0'}

  '@ckb-lumos/base@0.23.0':
    resolution: {integrity: sha512-8aLFsUyWIK0rT7GQlYFuXyiG5lQ2bLRK2GvUsxv5G7I3nJ1UyxjwvVOdtlsR/cwhzOam3ujwqASqBIayBL6GLA==}
    engines: {node: '>=12.0.0'}

  '@ckb-lumos/bi@0.0.0-canary-66bbbfd-20240805132534':
    resolution: {integrity: sha512-0eEPkaZ7WOXIkHbRx/vD2kynn4b5TRT8Xo3DGFPKDd/9ZQJX07fPvaCRdCV9/fyEZXC4aVv0XskWySKbrWDDLw==}
    engines: {node: '>=12.0.0'}

  '@ckb-lumos/bi@0.22.2':
    resolution: {integrity: sha512-F+dLC/tE+xdtNuGgJxlDqbgX/f8azg1tvIFTR5mu7Vhz08nkFgnA+Z+yC0t/I3fDwwH4p/SlGP/yducrsfVTqw==}
    engines: {node: '>=12.0.0'}

  '@ckb-lumos/bi@0.23.0':
    resolution: {integrity: sha512-KAy+lyVpL+Al4XD+c9tHrA9DSpHkMusyXtTS81aNZi5MyL6F9jrVmFcqLorhfyfl8Fsv2sEjMe5Neo2Y+w/RJQ==}
    engines: {node: '>=12.0.0'}

  '@ckb-lumos/ckb-indexer@0.23.0':
    resolution: {integrity: sha512-yLODLJzvtz4M6W6OJR4iRbBTUGrKReV2dhVePPjbH/HRkRY6f6J6cEM9+qM2I3QABmaCXeAM3hWvnWU9hjalQQ==}
    engines: {node: '>=12.0.0'}

  '@ckb-lumos/codec@0.0.0-canary-66bbbfd-20240805132534':
    resolution: {integrity: sha512-/9RY2SfviZtWkSQbmgNxMHoora0vv6hCFB09n/RXF1jyfmmVNKuhtcbDKAiTl4WwWmxdJd1DhgPP0ARvM7VKfg==}
    engines: {node: '>=12.0.0'}

  '@ckb-lumos/codec@0.22.2':
    resolution: {integrity: sha512-P5SyhT2qkJwCwcHF3yMLInE0z3wWHDkqJNbSM2Q9oyu0+9kjMQfexNia3T+atBl2M7ELFzN5WvttojYr6DrCwQ==}
    engines: {node: '>=12.0.0'}

  '@ckb-lumos/codec@0.23.0':
    resolution: {integrity: sha512-FwYooXnsFDjlHHnlFnCTB1UbBzV72I0VjkRpeauFk5nQ4+/75xl28ywK3J14M+0aHTnYU9msXUTRDAGqC0CaNQ==}
    engines: {node: '>=12.0.0'}

  '@ckb-lumos/common-scripts@0.23.0':
    resolution: {integrity: sha512-Dwic0Al94afdGNu+TGAMmZiU5OVF/zvXbzhCvNmkFS25t8BxPdFjGEc0MlWBI4ZSEoGRrC0O+BOxjzfl5VxSYg==}
    engines: {node: '>=12.0.0'}

  '@ckb-lumos/config-manager@0.23.0':
    resolution: {integrity: sha512-MvNyzGIJTmIpEf5WJB3TkE4icZyZ2HZhFIfJB2SXDRAC84E02jxENPelCnqRbM1rlFHnxjh/5a/oCi5LcXefag==}
    engines: {node: '>=12.0.0'}

  '@ckb-lumos/hd@0.23.0':
    resolution: {integrity: sha512-z7EsR/GeX54hq4ukqwW3nrqLCsYrTWIFAjZLR1Ao8xycqQp0IBjCWZLLjRrZY6krbUQpVOoiKo3NBLpPW36LXg==}
    engines: {node: '>=12.0.0'}

  '@ckb-lumos/helpers@0.23.0':
    resolution: {integrity: sha512-yfD28vSn1BBk8BA+/ivL7pF3rMsx4OPQ+UUJjsQiR1zGdkNR3zhJOecgICeddJGYDTBBDVgwHcuyoekLxQzmGg==}
    engines: {node: '>=12.0.0'}

  '@ckb-lumos/light-client@0.23.0':
    resolution: {integrity: sha512-O+dbfubDjl0iODiQ8Q+RVJLfuXYNCN6c0am8xEv4vvazLwfw1y/vn6fG/pFu9Mc1GahZ58y9o6fkUgs8ujH3Mg==}
    engines: {node: '>=12.0.0'}

  '@ckb-lumos/lumos@0.23.0':
    resolution: {integrity: sha512-ocsmzgTgevVwyQeQkUZrg4PLJCfX48D5MEBNYTMoGh5b1g0f1iEBHcAgw4WBGOKgMJQmGRmWB5P6tPDZ3OZBwQ==}
    engines: {node: '>=12.0.0'}

  '@ckb-lumos/molecule@0.0.0-canary-66bbbfd-20240805132534':
    resolution: {integrity: sha512-YvUQUctRuRWoeiohjq+KNpXQ3FAuJHpiJxlFNbn+WoBX7TlIgIR69B/cRRvoa7gD5QuoA8q5zf9+0l4eYmm1Qw==}
    engines: {node: '>=12.0.0'}
    hasBin: true

  '@ckb-lumos/rpc@0.23.0':
    resolution: {integrity: sha512-NEY1Wb2cNMYdHwcZYtd8XZ3CP6WGPd25hcsudoDAFlAt9vjHsPlNiwSS7tcZCZfg1XiJy3taViVgG8pFemgpbA==}
    engines: {node: '>=12.0.0'}

  '@ckb-lumos/toolkit@0.22.2':
    resolution: {integrity: sha512-HmKz2dGQeaW2XDqkvjJfLv50VQWGKbthg2RDfIxGsZyjveluRROTyuHP1akypy4pqF8TApGLsXci2MaHCRau+w==}
    engines: {node: '>=12.0.0'}

  '@ckb-lumos/toolkit@0.23.0':
    resolution: {integrity: sha512-7LTsUFfoNCBWJLgh+V/QFnemjGw+y4mmLeQvubwYuJqIPIhIpwKUuKRzkvVG8snA8xVQSfjSSQOs5m3mKp66Kg==}
    engines: {node: '>=12.0.0'}

  '@ckb-lumos/transaction-manager@0.23.0':
    resolution: {integrity: sha512-sfwt2g8JlYxr5jRx5r/UZNffTpkwn3sh4dD2THzKmX0S1CsSgww2D1ZD7yruWwSu05ZLKlDPFVKyJ50tNc3LuQ==}
    engines: {node: '>=12.0.0'}

  '@colors/colors@1.5.0':
    resolution: {integrity: sha512-ooWCrlZP11i8GImSjTHYHLkvFDP48nS4+204nGb1RiX/WXYHmJA2III9/e2DWVabCESdW7hBAEzHRqUn9OUVvQ==}
    engines: {node: '>=0.1.90'}

  '@cspotcode/source-map-support@0.8.1':
    resolution: {integrity: sha512-IchNf6dN4tHoMFIn/7OE8LWZ19Y6q/67Bmf6vnGREv8RSbBVb9LPJxEcnwrcwX6ixSvaiGoomAUvu4YSxXrVgw==}
    engines: {node: '>=12'}

  '@esbuild/aix-ppc64@0.21.5':
    resolution: {integrity: sha512-1SDgH6ZSPTlggy1yI6+Dbkiz8xzpHJEVAlF/AM1tHPLsf5STom9rwtjE4hKAF20FfXXNTFqEYXyJNWh1GiZedQ==}
    engines: {node: '>=12'}
    cpu: [ppc64]
    os: [aix]

  '@esbuild/aix-ppc64@0.24.2':
    resolution: {integrity: sha512-thpVCb/rhxE/BnMLQ7GReQLLN8q9qbHmI55F4489/ByVg2aQaQ6kbcLb6FHkocZzQhxc4gx0sCk0tJkKBFzDhA==}
    engines: {node: '>=18'}
    cpu: [ppc64]
    os: [aix]

  '@esbuild/android-arm64@0.21.5':
    resolution: {integrity: sha512-c0uX9VAUBQ7dTDCjq+wdyGLowMdtR/GoC2U5IYk/7D1H1JYC0qseD7+11iMP2mRLN9RcCMRcjC4YMclCzGwS/A==}
    engines: {node: '>=12'}
    cpu: [arm64]
    os: [android]

  '@esbuild/android-arm64@0.24.2':
    resolution: {integrity: sha512-cNLgeqCqV8WxfcTIOeL4OAtSmL8JjcN6m09XIgro1Wi7cF4t/THaWEa7eL5CMoMBdjoHOTh/vwTO/o2TRXIyzg==}
    engines: {node: '>=18'}
    cpu: [arm64]
    os: [android]

  '@esbuild/android-arm@0.21.5':
    resolution: {integrity: sha512-vCPvzSjpPHEi1siZdlvAlsPxXl7WbOVUBBAowWug4rJHb68Ox8KualB+1ocNvT5fjv6wpkX6o/iEpbDrf68zcg==}
    engines: {node: '>=12'}
    cpu: [arm]
    os: [android]

  '@esbuild/android-arm@0.24.2':
    resolution: {integrity: sha512-tmwl4hJkCfNHwFB3nBa8z1Uy3ypZpxqxfTQOcHX+xRByyYgunVbZ9MzUUfb0RxaHIMnbHagwAxuTL+tnNM+1/Q==}
    engines: {node: '>=18'}
    cpu: [arm]
    os: [android]

  '@esbuild/android-x64@0.21.5':
    resolution: {integrity: sha512-D7aPRUUNHRBwHxzxRvp856rjUHRFW1SdQATKXH2hqA0kAZb1hKmi02OpYRacl0TxIGz/ZmXWlbZgjwWYaCakTA==}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [android]

  '@esbuild/android-x64@0.24.2':
    resolution: {integrity: sha512-B6Q0YQDqMx9D7rvIcsXfmJfvUYLoP722bgfBlO5cGvNVb5V/+Y7nhBE3mHV9OpxBf4eAS2S68KZztiPaWq4XYw==}
    engines: {node: '>=18'}
    cpu: [x64]
    os: [android]

  '@esbuild/darwin-arm64@0.21.5':
    resolution: {integrity: sha512-DwqXqZyuk5AiWWf3UfLiRDJ5EDd49zg6O9wclZ7kUMv2WRFr4HKjXp/5t8JZ11QbQfUS6/cRCKGwYhtNAY88kQ==}
    engines: {node: '>=12'}
    cpu: [arm64]
    os: [darwin]

  '@esbuild/darwin-arm64@0.24.2':
    resolution: {integrity: sha512-kj3AnYWc+CekmZnS5IPu9D+HWtUI49hbnyqk0FLEJDbzCIQt7hg7ucF1SQAilhtYpIujfaHr6O0UHlzzSPdOeA==}
    engines: {node: '>=18'}
    cpu: [arm64]
    os: [darwin]

  '@esbuild/darwin-x64@0.21.5':
    resolution: {integrity: sha512-se/JjF8NlmKVG4kNIuyWMV/22ZaerB+qaSi5MdrXtd6R08kvs2qCN4C09miupktDitvh8jRFflwGFBQcxZRjbw==}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [darwin]

  '@esbuild/darwin-x64@0.24.2':
    resolution: {integrity: sha512-WeSrmwwHaPkNR5H3yYfowhZcbriGqooyu3zI/3GGpF8AyUdsrrP0X6KumITGA9WOyiJavnGZUwPGvxvwfWPHIA==}
    engines: {node: '>=18'}
    cpu: [x64]
    os: [darwin]

  '@esbuild/freebsd-arm64@0.21.5':
    resolution: {integrity: sha512-5JcRxxRDUJLX8JXp/wcBCy3pENnCgBR9bN6JsY4OmhfUtIHe3ZW0mawA7+RDAcMLrMIZaf03NlQiX9DGyB8h4g==}
    engines: {node: '>=12'}
    cpu: [arm64]
    os: [freebsd]

  '@esbuild/freebsd-arm64@0.24.2':
    resolution: {integrity: sha512-UN8HXjtJ0k/Mj6a9+5u6+2eZ2ERD7Edt1Q9IZiB5UZAIdPnVKDoG7mdTVGhHJIeEml60JteamR3qhsr1r8gXvg==}
    engines: {node: '>=18'}
    cpu: [arm64]
    os: [freebsd]

  '@esbuild/freebsd-x64@0.21.5':
    resolution: {integrity: sha512-J95kNBj1zkbMXtHVH29bBriQygMXqoVQOQYA+ISs0/2l3T9/kj42ow2mpqerRBxDJnmkUDCaQT/dfNXWX/ZZCQ==}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [freebsd]

  '@esbuild/freebsd-x64@0.24.2':
    resolution: {integrity: sha512-TvW7wE/89PYW+IevEJXZ5sF6gJRDY/14hyIGFXdIucxCsbRmLUcjseQu1SyTko+2idmCw94TgyaEZi9HUSOe3Q==}
    engines: {node: '>=18'}
    cpu: [x64]
    os: [freebsd]

  '@esbuild/linux-arm64@0.21.5':
    resolution: {integrity: sha512-ibKvmyYzKsBeX8d8I7MH/TMfWDXBF3db4qM6sy+7re0YXya+K1cem3on9XgdT2EQGMu4hQyZhan7TeQ8XkGp4Q==}
    engines: {node: '>=12'}
    cpu: [arm64]
    os: [linux]

  '@esbuild/linux-arm64@0.24.2':
    resolution: {integrity: sha512-7HnAD6074BW43YvvUmE/35Id9/NB7BeX5EoNkK9obndmZBUk8xmJJeU7DwmUeN7tkysslb2eSl6CTrYz6oEMQg==}
    engines: {node: '>=18'}
    cpu: [arm64]
    os: [linux]

  '@esbuild/linux-arm@0.21.5':
    resolution: {integrity: sha512-bPb5AHZtbeNGjCKVZ9UGqGwo8EUu4cLq68E95A53KlxAPRmUyYv2D6F0uUI65XisGOL1hBP5mTronbgo+0bFcA==}
    engines: {node: '>=12'}
    cpu: [arm]
    os: [linux]

  '@esbuild/linux-arm@0.24.2':
    resolution: {integrity: sha512-n0WRM/gWIdU29J57hJyUdIsk0WarGd6To0s+Y+LwvlC55wt+GT/OgkwoXCXvIue1i1sSNWblHEig00GBWiJgfA==}
    engines: {node: '>=18'}
    cpu: [arm]
    os: [linux]

  '@esbuild/linux-ia32@0.21.5':
    resolution: {integrity: sha512-YvjXDqLRqPDl2dvRODYmmhz4rPeVKYvppfGYKSNGdyZkA01046pLWyRKKI3ax8fbJoK5QbxblURkwK/MWY18Tg==}
    engines: {node: '>=12'}
    cpu: [ia32]
    os: [linux]

  '@esbuild/linux-ia32@0.24.2':
    resolution: {integrity: sha512-sfv0tGPQhcZOgTKO3oBE9xpHuUqguHvSo4jl+wjnKwFpapx+vUDcawbwPNuBIAYdRAvIDBfZVvXprIj3HA+Ugw==}
    engines: {node: '>=18'}
    cpu: [ia32]
    os: [linux]

  '@esbuild/linux-loong64@0.21.5':
    resolution: {integrity: sha512-uHf1BmMG8qEvzdrzAqg2SIG/02+4/DHB6a9Kbya0XDvwDEKCoC8ZRWI5JJvNdUjtciBGFQ5PuBlpEOXQj+JQSg==}
    engines: {node: '>=12'}
    cpu: [loong64]
    os: [linux]

  '@esbuild/linux-loong64@0.24.2':
    resolution: {integrity: sha512-CN9AZr8kEndGooS35ntToZLTQLHEjtVB5n7dl8ZcTZMonJ7CCfStrYhrzF97eAecqVbVJ7APOEe18RPI4KLhwQ==}
    engines: {node: '>=18'}
    cpu: [loong64]
    os: [linux]

  '@esbuild/linux-mips64el@0.21.5':
    resolution: {integrity: sha512-IajOmO+KJK23bj52dFSNCMsz1QP1DqM6cwLUv3W1QwyxkyIWecfafnI555fvSGqEKwjMXVLokcV5ygHW5b3Jbg==}
    engines: {node: '>=12'}
    cpu: [mips64el]
    os: [linux]

  '@esbuild/linux-mips64el@0.24.2':
    resolution: {integrity: sha512-iMkk7qr/wl3exJATwkISxI7kTcmHKE+BlymIAbHO8xanq/TjHaaVThFF6ipWzPHryoFsesNQJPE/3wFJw4+huw==}
    engines: {node: '>=18'}
    cpu: [mips64el]
    os: [linux]

  '@esbuild/linux-ppc64@0.21.5':
    resolution: {integrity: sha512-1hHV/Z4OEfMwpLO8rp7CvlhBDnjsC3CttJXIhBi+5Aj5r+MBvy4egg7wCbe//hSsT+RvDAG7s81tAvpL2XAE4w==}
    engines: {node: '>=12'}
    cpu: [ppc64]
    os: [linux]

  '@esbuild/linux-ppc64@0.24.2':
    resolution: {integrity: sha512-shsVrgCZ57Vr2L8mm39kO5PPIb+843FStGt7sGGoqiiWYconSxwTiuswC1VJZLCjNiMLAMh34jg4VSEQb+iEbw==}
    engines: {node: '>=18'}
    cpu: [ppc64]
    os: [linux]

  '@esbuild/linux-riscv64@0.21.5':
    resolution: {integrity: sha512-2HdXDMd9GMgTGrPWnJzP2ALSokE/0O5HhTUvWIbD3YdjME8JwvSCnNGBnTThKGEB91OZhzrJ4qIIxk/SBmyDDA==}
    engines: {node: '>=12'}
    cpu: [riscv64]
    os: [linux]

  '@esbuild/linux-riscv64@0.24.2':
    resolution: {integrity: sha512-4eSFWnU9Hhd68fW16GD0TINewo1L6dRrB+oLNNbYyMUAeOD2yCK5KXGK1GH4qD/kT+bTEXjsyTCiJGHPZ3eM9Q==}
    engines: {node: '>=18'}
    cpu: [riscv64]
    os: [linux]

  '@esbuild/linux-s390x@0.21.5':
    resolution: {integrity: sha512-zus5sxzqBJD3eXxwvjN1yQkRepANgxE9lgOW2qLnmr8ikMTphkjgXu1HR01K4FJg8h1kEEDAqDcZQtbrRnB41A==}
    engines: {node: '>=12'}
    cpu: [s390x]
    os: [linux]

  '@esbuild/linux-s390x@0.24.2':
    resolution: {integrity: sha512-S0Bh0A53b0YHL2XEXC20bHLuGMOhFDO6GN4b3YjRLK//Ep3ql3erpNcPlEFed93hsQAjAQDNsvcK+hV90FubSw==}
    engines: {node: '>=18'}
    cpu: [s390x]
    os: [linux]

  '@esbuild/linux-x64@0.21.5':
    resolution: {integrity: sha512-1rYdTpyv03iycF1+BhzrzQJCdOuAOtaqHTWJZCWvijKD2N5Xu0TtVC8/+1faWqcP9iBCWOmjmhoH94dH82BxPQ==}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [linux]

  '@esbuild/linux-x64@0.24.2':
    resolution: {integrity: sha512-8Qi4nQcCTbLnK9WoMjdC9NiTG6/E38RNICU6sUNqK0QFxCYgoARqVqxdFmWkdonVsvGqWhmm7MO0jyTqLqwj0Q==}
    engines: {node: '>=18'}
    cpu: [x64]
    os: [linux]

  '@esbuild/netbsd-arm64@0.24.2':
    resolution: {integrity: sha512-wuLK/VztRRpMt9zyHSazyCVdCXlpHkKm34WUyinD2lzK07FAHTq0KQvZZlXikNWkDGoT6x3TD51jKQ7gMVpopw==}
    engines: {node: '>=18'}
    cpu: [arm64]
    os: [netbsd]

  '@esbuild/netbsd-x64@0.21.5':
    resolution: {integrity: sha512-Woi2MXzXjMULccIwMnLciyZH4nCIMpWQAs049KEeMvOcNADVxo0UBIQPfSmxB3CWKedngg7sWZdLvLczpe0tLg==}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [netbsd]

  '@esbuild/netbsd-x64@0.24.2':
    resolution: {integrity: sha512-VefFaQUc4FMmJuAxmIHgUmfNiLXY438XrL4GDNV1Y1H/RW3qow68xTwjZKfj/+Plp9NANmzbH5R40Meudu8mmw==}
    engines: {node: '>=18'}
    cpu: [x64]
    os: [netbsd]

  '@esbuild/openbsd-arm64@0.24.2':
    resolution: {integrity: sha512-YQbi46SBct6iKnszhSvdluqDmxCJA+Pu280Av9WICNwQmMxV7nLRHZfjQzwbPs3jeWnuAhE9Jy0NrnJ12Oz+0A==}
    engines: {node: '>=18'}
    cpu: [arm64]
    os: [openbsd]

  '@esbuild/openbsd-x64@0.21.5':
    resolution: {integrity: sha512-HLNNw99xsvx12lFBUwoT8EVCsSvRNDVxNpjZ7bPn947b8gJPzeHWyNVhFsaerc0n3TsbOINvRP2byTZ5LKezow==}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [openbsd]

  '@esbuild/openbsd-x64@0.24.2':
    resolution: {integrity: sha512-+iDS6zpNM6EnJyWv0bMGLWSWeXGN/HTaF/LXHXHwejGsVi+ooqDfMCCTerNFxEkM3wYVcExkeGXNqshc9iMaOA==}
    engines: {node: '>=18'}
    cpu: [x64]
    os: [openbsd]

  '@esbuild/sunos-x64@0.21.5':
    resolution: {integrity: sha512-6+gjmFpfy0BHU5Tpptkuh8+uw3mnrvgs+dSPQXQOv3ekbordwnzTVEb4qnIvQcYXq6gzkyTnoZ9dZG+D4garKg==}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [sunos]

  '@esbuild/sunos-x64@0.24.2':
    resolution: {integrity: sha512-hTdsW27jcktEvpwNHJU4ZwWFGkz2zRJUz8pvddmXPtXDzVKTTINmlmga3ZzwcuMpUvLw7JkLy9QLKyGpD2Yxig==}
    engines: {node: '>=18'}
    cpu: [x64]
    os: [sunos]

  '@esbuild/win32-arm64@0.21.5':
    resolution: {integrity: sha512-Z0gOTd75VvXqyq7nsl93zwahcTROgqvuAcYDUr+vOv8uHhNSKROyU961kgtCD1e95IqPKSQKH7tBTslnS3tA8A==}
    engines: {node: '>=12'}
    cpu: [arm64]
    os: [win32]

  '@esbuild/win32-arm64@0.24.2':
    resolution: {integrity: sha512-LihEQ2BBKVFLOC9ZItT9iFprsE9tqjDjnbulhHoFxYQtQfai7qfluVODIYxt1PgdoyQkz23+01rzwNwYfutxUQ==}
    engines: {node: '>=18'}
    cpu: [arm64]
    os: [win32]

  '@esbuild/win32-ia32@0.21.5':
    resolution: {integrity: sha512-SWXFF1CL2RVNMaVs+BBClwtfZSvDgtL//G/smwAc5oVK/UPu2Gu9tIaRgFmYFFKrmg3SyAjSrElf0TiJ1v8fYA==}
    engines: {node: '>=12'}
    cpu: [ia32]
    os: [win32]

  '@esbuild/win32-ia32@0.24.2':
    resolution: {integrity: sha512-q+iGUwfs8tncmFC9pcnD5IvRHAzmbwQ3GPS5/ceCyHdjXubwQWI12MKWSNSMYLJMq23/IUCvJMS76PDqXe1fxA==}
    engines: {node: '>=18'}
    cpu: [ia32]
    os: [win32]

  '@esbuild/win32-x64@0.21.5':
    resolution: {integrity: sha512-tQd/1efJuzPC6rCFwEvLtci/xNFcTZknmXs98FYDfGE4wP9ClFV98nyKrzJKVPMhdDnjzLhdUyMX4PsQAPjwIw==}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [win32]

  '@esbuild/win32-x64@0.24.2':
    resolution: {integrity: sha512-7VTgWzgMGvup6aSqDPLiW5zHaxYJGTO4OokMjIlrCtf+VpEL+cXKtCvg723iguPYI5oaUNdS+/V7OU2gvXVWEg==}
    engines: {node: '>=18'}
    cpu: [x64]
    os: [win32]

  '@eslint-community/eslint-utils@4.4.0':
    resolution: {integrity: sha512-1/sA4dwrzBAyeUoQ6oxahHKmrZvsnLCg4RfxW3ZFGGmQkSNQPFNLV9CUEFQP1x9EYXHTo5p6xdhZM1Ne9p/AfA==}
    engines: {node: ^12.22.0 || ^14.17.0 || >=16.0.0}
    peerDependencies:
      eslint: ^6.0.0 || ^7.0.0 || >=8.0.0

  '@eslint-community/regexpp@4.11.0':
    resolution: {integrity: sha512-G/M/tIiMrTAxEWRfLfQJMmGNX28IxBg4PBz8XqQhqUHLFI6TL2htpIB1iQCj144V5ee/JaKyT9/WZ0MGZWfA7A==}
    engines: {node: ^12.0.0 || ^14.0.0 || >=16.0.0}

  '@eslint/eslintrc@2.1.4':
    resolution: {integrity: sha512-269Z39MS6wVJtsoUl10L60WdkhJVdPG24Q4eZTH3nnF6lpvSShEK3wQjDX9JRWAUPvPh7COouPpU9IrqaZFvtQ==}
    engines: {node: ^12.22.0 || ^14.17.0 || >=16.0.0}

  '@eslint/js@8.57.0':
    resolution: {integrity: sha512-Ys+3g2TaW7gADOJzPt83SJtCDhMjndcDMFVQ/Tj9iA1BfJzFKD9mAUXT3OenpuPHbI6P/myECxRJrofUsDx/5g==}
    engines: {node: ^12.22.0 || ^14.17.0 || >=16.0.0}

  '@exact-realty/multipart-parser@1.0.14':
    resolution: {integrity: sha512-ln1+s1XOvRY9NRof3lpjWJZfSoV5XOWdVgK7sYeE3TAt0brtB+pIPJpSbxaol/490re2rcMEo24VZXeffKm8Aw==}
    engines: {node: '>=16.0.0', npm: '>=8.0.0'}
    deprecated: Package has moved to @apeleghq/multipart-parser

  '@fastify/ajv-compiler@3.6.0':
    resolution: {integrity: sha512-LwdXQJjmMD+GwLOkP7TVC68qa+pSSogeWWmznRJ/coyTcfe9qA05AHFSe1eZFwK6q+xVRpChnvFUkf1iYaSZsQ==}

  '@fastify/cors@9.0.1':
    resolution: {integrity: sha512-YY9Ho3ovI+QHIL2hW+9X4XqQjXLjJqsU+sMV/xFsxZkE8p3GNnYVFpoOxF7SsP5ZL76gwvbo3V9L+FIekBGU4Q==}

  '@fastify/error@3.4.1':
    resolution: {integrity: sha512-wWSvph+29GR783IhmvdwWnN4bUxTD01Vm5Xad4i7i1VuAOItLvbPAb69sb0IQ2N57yprvhNIwAP5B6xfKTmjmQ==}

  '@fastify/fast-json-stringify-compiler@4.3.0':
    resolution: {integrity: sha512-aZAXGYo6m22Fk1zZzEUKBvut/CIIQe/BapEORnxiD5Qr0kPHqqI69NtEMCme74h+at72sPhbkb4ZrLd1W3KRLA==}

  '@fastify/formbody@7.4.0':
    resolution: {integrity: sha512-H3C6h1GN56/SMrZS8N2vCT2cZr7mIHzBHzOBa5OPpjfB/D6FzP9mMpE02ZzrFX0ANeh0BAJdoXKOF2e7IbV+Og==}

  '@fastify/merge-json-schemas@0.1.1':
    resolution: {integrity: sha512-fERDVz7topgNjtXsJTTW1JKLy0rhuLRcquYqNR9rF7OcVpCa2OVW49ZPDIhaRRCaUuvVxI+N416xUoF76HNSXA==}

  '@fastify/middie@8.3.1':
    resolution: {integrity: sha512-qrQ8U3iCdjNum3+omnIvAyz21ifFx+Pp5jYW7PJJ7b9ueKTCPXsH6vEvaZQrjEZvOpTnWte+CswfBODWD0NqYQ==}

  '@humanwhocodes/config-array@0.11.14':
    resolution: {integrity: sha512-3T8LkOmg45BV5FICb15QQMsyUSWrQ8AygVfC7ZG32zOalnqrilm018ZVCw0eapXux8FtA33q8PSRSstjee3jSg==}
    engines: {node: '>=10.10.0'}
    deprecated: Use @eslint/config-array instead

  '@humanwhocodes/module-importer@1.0.1':
    resolution: {integrity: sha512-bxveV4V8v5Yb4ncFTT3rPSgZBOpCkjfK0y4oVVVJwIuDVBRMDXrPyXRL988i5ap9m9bnyEEjWfm5WkBmtffLfA==}
    engines: {node: '>=12.22'}

  '@humanwhocodes/object-schema@2.0.3':
    resolution: {integrity: sha512-93zYdMES/c1D69yZiKDBj0V24vqNzB/koF26KPaagAfd3P/4gUlh3Dys5ogAK+Exi9QyzlD8x/08Zt7wIKcDcA==}
    deprecated: Use @eslint/object-schema instead

  '@isaacs/cliui@8.0.2':
    resolution: {integrity: sha512-O8jcjabXaleOG9DQ0+ARXWZBTfnP4WNAqzuiJK7ll44AmxGKv/J2M4TPjxjY3znBCfvBXFzucm1twdyFybFqEA==}
    engines: {node: '>=12'}

  '@istanbuljs/schema@0.1.3':
    resolution: {integrity: sha512-ZXRY4jNvVgSVQ8DL3LTcakaAtXwTVUxE81hslsyD2AtoXW/wVob10HkOJ1X/pAlcI7D+2YoZKg5do8G/w6RYgA==}
    engines: {node: '>=8'}

  '@jridgewell/gen-mapping@0.3.5':
    resolution: {integrity: sha512-IzL8ZoEDIBRWEzlCcRhOaCupYyN5gdIK+Q6fbFdPDg6HqX6jpkItn7DFIpW9LQzXG6Df9sA7+OKnq0qlz/GaQg==}
    engines: {node: '>=6.0.0'}

  '@jridgewell/resolve-uri@3.1.2':
    resolution: {integrity: sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==}
    engines: {node: '>=6.0.0'}

  '@jridgewell/set-array@1.2.1':
    resolution: {integrity: sha512-R8gLRTZeyp03ymzP/6Lil/28tGeGEzhx1q2k703KGWRAI1VdvPIXdG70VJc2pAMw3NA6JKL5hhFu1sJX0Mnn/A==}
    engines: {node: '>=6.0.0'}

  '@jridgewell/source-map@0.3.6':
    resolution: {integrity: sha512-1ZJTZebgqllO79ue2bm3rIGud/bOe0pP5BjSRCRxxYkEZS8STV7zN84UBbiYu7jy+eCKSnVIUgoWWE/tt+shMQ==}

  '@jridgewell/sourcemap-codec@1.5.0':
    resolution: {integrity: sha512-gv3ZRaISU3fjPAgNsriBRqGWQL6quFx04YMPW/zD8XMLsU32mhCCbfbO6KZFLjvYpCZ8zyDEgqsgf+PwPaM7GQ==}

  '@jridgewell/trace-mapping@0.3.25':
    resolution: {integrity: sha512-vNk6aEwybGtawWmy/PzwnGDOjCkLWSD2wqvjGGAgOAwCGWySYXfYoxt00IJkTF+8Lb57DwOb3Aa0o9CApepiYQ==}

  '@jridgewell/trace-mapping@0.3.9':
    resolution: {integrity: sha512-3Belt6tdc8bPgAtbcmdtNJlirVoTmEb5e2gC94PnkwEW9jI6CAHUeoG85tjWP5WquqfavoMtMwiG4P926ZKKuQ==}

  '@ljharb/through@2.3.13':
    resolution: {integrity: sha512-/gKJun8NNiWGZJkGzI/Ragc53cOdcLNdzjLaIa+GEjguQs0ulsurx8WN0jijdK9yPqDvziX995sMRLyLt1uZMQ==}
    engines: {node: '>= 0.4'}

  '@lukeed/csprng@1.1.0':
    resolution: {integrity: sha512-Z7C/xXCiGWsg0KuKsHTKJxbWhpI3Vs5GwLfOean7MGyVFGqdRgBbAjOCh6u4bbjPc/8MJ2pZmK/0DLdCbivLDA==}
    engines: {node: '>=8'}

  '@manypkg/find-root@1.1.0':
    resolution: {integrity: sha512-mki5uBvhHzO8kYYix/WRy2WX8S3B5wdVSc9D6KcU5lQNglP2yt58/VfLuAK49glRXChosY8ap2oJ1qgma3GUVA==}

  '@manypkg/get-packages@1.1.3':
    resolution: {integrity: sha512-fo+QhuU3qE/2TQMQmbVMqaQ6EWbMhi4ABWP+O4AM1NqPBuy0OrApV5LO6BrrgnhtAHS2NH6RrVk9OL181tTi8A==}

  '@nervosnetwork/ckb-sdk-core@0.109.5':
    resolution: {integrity: sha512-eh3RjJlf8LqIAf03m81YLnuDaTOzs8C2cqXGJT9pdJIwEAaRcmgG6xZr5m9fdOMaeFMvaF4BQyjCeGjTQCFRGA==}

  '@nervosnetwork/ckb-sdk-rpc@0.109.5':
    resolution: {integrity: sha512-rT7iVRtagP3TxWel4zwXo6BAKfne4TBrGTnjmVTfqa/mrMNonVwOyJcFhWNSvq/r8HufL3QlYhngLHVDNomURQ==}

  '@nervosnetwork/ckb-sdk-utils@0.109.5':
    resolution: {integrity: sha512-Tx642hcJWbN8W3KzCIhIo49yzJ8LMqWopQCSBDKuRmwHesO/bvJqYojCVwfrOyROtFOPhgjyiGm5RXBuxm0KpQ==}

  '@nervosnetwork/ckb-types@0.109.5':
    resolution: {integrity: sha512-5jQNjFw76YCd+Ppl+0RvBWzxwvWaKfWC5wjVFFdNAieX7xksCHfZFIeow8je7AF8uVypwe56WlLBlblxw9NBBQ==}

  '@nestjs/cli@10.4.2':
    resolution: {integrity: sha512-fQexIfLHfp6GUgX+CO4fOg+AEwV5ox/LHotQhyZi9wXUQDyIqS0NTTbumr//62EcX35qV4nU0359nYnuEdzG+A==}
    engines: {node: '>= 16.14'}
    hasBin: true
    peerDependencies:
      '@swc/cli': ^0.1.62 || ^0.3.0 || ^0.4.0
      '@swc/core': ^1.3.62
    peerDependenciesMeta:
      '@swc/cli':
        optional: true
      '@swc/core':
        optional: true

  '@nestjs/common@10.3.10':
    resolution: {integrity: sha512-H8k0jZtxk1IdtErGDmxFRy0PfcOAUg41Prrqpx76DQusGGJjsaovs1zjXVD1rZWaVYchfT1uczJ6L4Kio10VNg==}
    peerDependencies:
      class-transformer: '*'
      class-validator: '*'
      reflect-metadata: ^0.1.12 || ^0.2.0
      rxjs: ^7.1.0
    peerDependenciesMeta:
      class-transformer:
        optional: true
      class-validator:
        optional: true

  '@nestjs/config@3.2.3':
    resolution: {integrity: sha512-p6yv/CvoBewJ72mBq4NXgOAi2rSQNWx3a+IMJLVKS2uiwFCOQQuiIatGwq6MRjXV3Jr+B41iUO8FIf4xBrZ4/w==}
    peerDependencies:
      '@nestjs/common': ^8.0.0 || ^9.0.0 || ^10.0.0
      rxjs: ^7.1.0

  '@nestjs/core@10.3.10':
    resolution: {integrity: sha512-ZbQ4jovQyzHtCGCrzK5NdtW1SYO2fHSsgSY1+/9WdruYCUra+JDkWEXgZ4M3Hv480Dl3OXehAmY1wCOojeMyMQ==}
    peerDependencies:
      '@nestjs/common': ^10.0.0
      '@nestjs/microservices': ^10.0.0
      '@nestjs/platform-express': ^10.0.0
      '@nestjs/websockets': ^10.0.0
      reflect-metadata: ^0.1.12 || ^0.2.0
      rxjs: ^7.1.0
    peerDependenciesMeta:
      '@nestjs/microservices':
        optional: true
      '@nestjs/platform-express':
        optional: true
      '@nestjs/websockets':
        optional: true

  '@nestjs/platform-fastify@10.3.10':
    resolution: {integrity: sha512-waNyUl4N/sRDPdEgJyhn+k0lS3ZpaDXRPjJVlDhlwOPGN38hMIGRjs+Gwz4pXqA5CP9PLuptMtHAWkb2m8I/nA==}
    peerDependencies:
      '@fastify/static': ^6.0.0 || ^7.0.0
      '@fastify/view': ^7.0.0 || ^8.0.0
      '@nestjs/common': ^10.0.0
      '@nestjs/core': ^10.0.0
    peerDependenciesMeta:
      '@fastify/static':
        optional: true
      '@fastify/view':
        optional: true

  '@nestjs/schematics@10.1.2':
    resolution: {integrity: sha512-S0bMtZM5U4mAiqkhRyZkXgjmOHBS5P/lp/vEydgMR4F7csOShc3jFeKVs1Eghd9xCFezGKy3SHy7hFT6dpPhWQ==}
    peerDependencies:
      typescript: '>=4.8.2'

  '@nestjs/testing@10.3.10':
    resolution: {integrity: sha512-i3HAtVQJijxNxJq1k39aelyJlyEIBRONys7IipH/4r8W0J+M1V+y5EKDOyi4j1SdNSb/vmNyWpZ2/ewZjl3kRA==}
    peerDependencies:
      '@nestjs/common': ^10.0.0
      '@nestjs/core': ^10.0.0
      '@nestjs/microservices': ^10.0.0
      '@nestjs/platform-express': ^10.0.0
    peerDependenciesMeta:
      '@nestjs/microservices':
        optional: true
      '@nestjs/platform-express':
        optional: true

  '@noble/hashes@1.4.0':
    resolution: {integrity: sha512-V1JJ1WTRUqHHrOSh597hURcMqVKVGL/ea3kv0gSnEdsEZ0/+VyPghM1lMNGc00z7CIQorSvbKpuJkxvuHbvdbg==}
    engines: {node: '>= 16'}

  '@noble/secp256k1@1.7.1':
    resolution: {integrity: sha512-hOUk6AyBFmqVrv7k5WAw/LpszxVbj9gGN4JRkIX52fdFAj1UA61KXmZDvqVEm+pOyec3+fIeZB02LYa/pWOArw==}

  '@nodelib/fs.scandir@2.1.5':
    resolution: {integrity: sha512-vq24Bq3ym5HEQm2NKCr3yXDwjc7vTsEThRDnkp2DK9p1uqLR+DHurm/NOTo0KG7HYHU7eppKZj3MyqYuMBf62g==}
    engines: {node: '>= 8'}

  '@nodelib/fs.stat@2.0.5':
    resolution: {integrity: sha512-RkhPPp2zrqDAQA/2jNhnztcPAlv64XdhIp7a7454A5ovI7Bukxgt7MX7udwAu3zg1DcpPU0rz3VV1SeaqvY4+A==}
    engines: {node: '>= 8'}

  '@nodelib/fs.walk@1.2.8':
    resolution: {integrity: sha512-oGB+UxlgWcgQkgwo8GcEGwemoTFt3FIO9ababBmaGwXIoBKZ+GTy0pP185beGg7Llih/NSHSV2XAs1lnznocSg==}
    engines: {node: '>= 8'}

  '@nuxtjs/opencollective@0.3.2':
    resolution: {integrity: sha512-um0xL3fO7Mf4fDxcqx9KryrB7zgRM5JSlvGN5AGkP6JLM5XEKyjeAiPbNxdXVXQ16isuAhYpvP88NgL2BGd6aA==}
    engines: {node: '>=8.0.0', npm: '>=5.0.0'}
    hasBin: true

  '@pkgjs/parseargs@0.11.0':
    resolution: {integrity: sha512-+1VkjdD0QBLPodGrJUeqarH8VAIvQODIbwh9XpP5Syisf7YoQgsJKPNFoqqLQlu+VQ/tVSshMR6loPMn8U+dPg==}
    engines: {node: '>=14'}

  '@rollup/pluginutils@5.1.0':
    resolution: {integrity: sha512-XTIWOPPcpvyKI6L1NHo0lFlCyznUEyPmPY1mc3KpPVDYulHSTvyeLNVW00QTLIAFNhR3kYnJTQHeGqU4M3n09g==}
    engines: {node: '>=14.0.0'}
    peerDependencies:
      rollup: ^1.20.0||^2.0.0||^3.0.0||^4.0.0
    peerDependenciesMeta:
      rollup:
        optional: true

  '@rollup/rollup-android-arm-eabi@4.30.0':
    resolution: {integrity: sha512-qFcFto9figFLz2g25DxJ1WWL9+c91fTxnGuwhToCl8BaqDsDYMl/kOnBXAyAqkkzAWimYMSWNPWEjt+ADAHuoQ==}
    cpu: [arm]
    os: [android]

  '@rollup/rollup-android-arm-eabi@4.34.7':
    resolution: {integrity: sha512-l6CtzHYo8D2TQ3J7qJNpp3Q1Iye56ssIAtqbM2H8axxCEEwvN7o8Ze9PuIapbxFL3OHrJU2JBX6FIIVnP/rYyw==}
    cpu: [arm]
    os: [android]

  '@rollup/rollup-android-arm64@4.30.0':
    resolution: {integrity: sha512-vqrQdusvVl7dthqNjWCL043qelBK+gv9v3ZiqdxgaJvmZyIAAXMjeGVSqZynKq69T7062T5VrVTuikKSAAVP6A==}
    cpu: [arm64]
    os: [android]

  '@rollup/rollup-android-arm64@4.34.7':
    resolution: {integrity: sha512-KvyJpFUueUnSp53zhAa293QBYqwm94TgYTIfXyOTtidhm5V0LbLCJQRGkQClYiX3FXDQGSvPxOTD/6rPStMMDg==}
    cpu: [arm64]
    os: [android]

  '@rollup/rollup-darwin-arm64@4.30.0':
    resolution: {integrity: sha512-617pd92LhdA9+wpixnzsyhVft3szYiN16aNUMzVkf2N+yAk8UXY226Bfp36LvxYTUt7MO/ycqGFjQgJ0wlMaWQ==}
    cpu: [arm64]
    os: [darwin]

  '@rollup/rollup-darwin-arm64@4.34.7':
    resolution: {integrity: sha512-jq87CjmgL9YIKvs8ybtIC98s/M3HdbqXhllcy9EdLV0yMg1DpxES2gr65nNy7ObNo/vZ/MrOTxt0bE5LinL6mA==}
    cpu: [arm64]
    os: [darwin]

  '@rollup/rollup-darwin-x64@4.30.0':
    resolution: {integrity: sha512-Y3b4oDoaEhCypg8ajPqigKDcpi5ZZovemQl9Edpem0uNv6UUjXv7iySBpGIUTSs2ovWOzYpfw9EbFJXF/fJHWw==}
    cpu: [x64]
    os: [darwin]

  '@rollup/rollup-darwin-x64@4.34.7':
    resolution: {integrity: sha512-rSI/m8OxBjsdnMMg0WEetu/w+LhLAcCDEiL66lmMX4R3oaml3eXz3Dxfvrxs1FbzPbJMaItQiksyMfv1hoIxnA==}
    cpu: [x64]
    os: [darwin]

  '@rollup/rollup-freebsd-arm64@4.30.0':
    resolution: {integrity: sha512-3REQJ4f90sFIBfa0BUokiCdrV/E4uIjhkWe1bMgCkhFXbf4D8YN6C4zwJL881GM818qVYE9BO3dGwjKhpo2ABA==}
    cpu: [arm64]
    os: [freebsd]

  '@rollup/rollup-freebsd-arm64@4.34.7':
    resolution: {integrity: sha512-oIoJRy3ZrdsXpFuWDtzsOOa/E/RbRWXVokpVrNnkS7npz8GEG++E1gYbzhYxhxHbO2om1T26BZjVmdIoyN2WtA==}
    cpu: [arm64]
    os: [freebsd]

  '@rollup/rollup-freebsd-x64@4.30.0':
    resolution: {integrity: sha512-ZtY3Y8icbe3Cc+uQicsXG5L+CRGUfLZjW6j2gn5ikpltt3Whqjfo5mkyZ86UiuHF9Q3ZsaQeW7YswlHnN+lAcg==}
    cpu: [x64]
    os: [freebsd]

  '@rollup/rollup-freebsd-x64@4.34.7':
    resolution: {integrity: sha512-X++QSLm4NZfZ3VXGVwyHdRf58IBbCu9ammgJxuWZYLX0du6kZvdNqPwrjvDfwmi6wFdvfZ/s6K7ia0E5kI7m8Q==}
    cpu: [x64]
    os: [freebsd]

  '@rollup/rollup-linux-arm-gnueabihf@4.30.0':
    resolution: {integrity: sha512-bsPGGzfiHXMhQGuFGpmo2PyTwcrh2otL6ycSZAFTESviUoBOuxF7iBbAL5IJXc/69peXl5rAtbewBFeASZ9O0g==}
    cpu: [arm]
    os: [linux]

  '@rollup/rollup-linux-arm-gnueabihf@4.34.7':
    resolution: {integrity: sha512-Z0TzhrsNqukTz3ISzrvyshQpFnFRfLunYiXxlCRvcrb3nvC5rVKI+ZXPFG/Aa4jhQa1gHgH3A0exHaRRN4VmdQ==}
    cpu: [arm]
    os: [linux]

  '@rollup/rollup-linux-arm-musleabihf@4.30.0':
    resolution: {integrity: sha512-kvyIECEhs2DrrdfQf++maCWJIQ974EI4txlz1nNSBaCdtf7i5Xf1AQCEJWOC5rEBisdaMFFnOWNLYt7KpFqy5A==}
    cpu: [arm]
    os: [linux]

  '@rollup/rollup-linux-arm-musleabihf@4.34.7':
    resolution: {integrity: sha512-nkznpyXekFAbvFBKBy4nNppSgneB1wwG1yx/hujN3wRnhnkrYVugMTCBXED4+Ni6thoWfQuHNYbFjgGH0MBXtw==}
    cpu: [arm]
    os: [linux]

  '@rollup/rollup-linux-arm64-gnu@4.30.0':
    resolution: {integrity: sha512-CFE7zDNrokaotXu+shwIrmWrFxllg79vciH4E/zeK7NitVuWEaXRzS0mFfFvyhZfn8WfVOG/1E9u8/DFEgK7WQ==}
    cpu: [arm64]
    os: [linux]

  '@rollup/rollup-linux-arm64-gnu@4.34.7':
    resolution: {integrity: sha512-KCjlUkcKs6PjOcxolqrXglBDcfCuUCTVlX5BgzgoJHw+1rWH1MCkETLkLe5iLLS9dP5gKC7mp3y6x8c1oGBUtA==}
    cpu: [arm64]
    os: [linux]

  '@rollup/rollup-linux-arm64-musl@4.30.0':
    resolution: {integrity: sha512-MctNTBlvMcIBP0t8lV/NXiUwFg9oK5F79CxLU+a3xgrdJjfBLVIEHSAjQ9+ipofN2GKaMLnFFXLltg1HEEPaGQ==}
    cpu: [arm64]
    os: [linux]

  '@rollup/rollup-linux-arm64-musl@4.34.7':
    resolution: {integrity: sha512-uFLJFz6+utmpbR313TTx+NpPuAXbPz4BhTQzgaP0tozlLnGnQ6rCo6tLwaSa6b7l6gRErjLicXQ1iPiXzYotjw==}
    cpu: [arm64]
    os: [linux]

  '@rollup/rollup-linux-loongarch64-gnu@4.30.0':
    resolution: {integrity: sha512-fBpoYwLEPivL3q368+gwn4qnYnr7GVwM6NnMo8rJ4wb0p/Y5lg88vQRRP077gf+tc25akuqd+1Sxbn9meODhwA==}
    cpu: [loong64]
    os: [linux]

  '@rollup/rollup-linux-loongarch64-gnu@4.34.7':
    resolution: {integrity: sha512-ws8pc68UcJJqCpneDFepnwlsMUFoWvPbWXT/XUrJ7rWUL9vLoIN3GAasgG+nCvq8xrE3pIrd+qLX/jotcLy0Qw==}
    cpu: [loong64]
    os: [linux]

  '@rollup/rollup-linux-powerpc64le-gnu@4.30.0':
    resolution: {integrity: sha512-1hiHPV6dUaqIMXrIjN+vgJqtfkLpqHS1Xsg0oUfUVD98xGp1wX89PIXgDF2DWra1nxAd8dfE0Dk59MyeKaBVAw==}
    cpu: [ppc64]
    os: [linux]

  '@rollup/rollup-linux-powerpc64le-gnu@4.34.7':
    resolution: {integrity: sha512-vrDk9JDa/BFkxcS2PbWpr0C/LiiSLxFbNOBgfbW6P8TBe9PPHx9Wqbvx2xgNi1TOAyQHQJ7RZFqBiEohm79r0w==}
    cpu: [ppc64]
    os: [linux]

  '@rollup/rollup-linux-riscv64-gnu@4.30.0':
    resolution: {integrity: sha512-U0xcC80SMpEbvvLw92emHrNjlS3OXjAM0aVzlWfar6PR0ODWCTQtKeeB+tlAPGfZQXicv1SpWwRz9Hyzq3Jx3g==}
    cpu: [riscv64]
    os: [linux]

  '@rollup/rollup-linux-riscv64-gnu@4.34.7':
    resolution: {integrity: sha512-rB+ejFyjtmSo+g/a4eovDD1lHWHVqizN8P0Hm0RElkINpS0XOdpaXloqM4FBkF9ZWEzg6bezymbpLmeMldfLTw==}
    cpu: [riscv64]
    os: [linux]

  '@rollup/rollup-linux-s390x-gnu@4.30.0':
    resolution: {integrity: sha512-VU/P/IODrNPasgZDLIFJmMiLGez+BN11DQWfTVlViJVabyF3JaeaJkP6teI8760f18BMGCQOW9gOmuzFaI1pUw==}
    cpu: [s390x]
    os: [linux]

  '@rollup/rollup-linux-s390x-gnu@4.34.7':
    resolution: {integrity: sha512-nNXNjo4As6dNqRn7OrsnHzwTgtypfRA3u3AKr0B3sOOo+HkedIbn8ZtFnB+4XyKJojIfqDKmbIzO1QydQ8c+Pw==}
    cpu: [s390x]
    os: [linux]

  '@rollup/rollup-linux-x64-gnu@4.30.0':
    resolution: {integrity: sha512-laQVRvdbKmjXuFA3ZiZj7+U24FcmoPlXEi2OyLfbpY2MW1oxLt9Au8q9eHd0x6Pw/Kw4oe9gwVXWwIf2PVqblg==}
    cpu: [x64]
    os: [linux]

  '@rollup/rollup-linux-x64-gnu@4.34.7':
    resolution: {integrity: sha512-9kPVf9ahnpOMSGlCxXGv980wXD0zRR3wyk8+33/MXQIpQEOpaNe7dEHm5LMfyRZRNt9lMEQuH0jUKj15MkM7QA==}
    cpu: [x64]
    os: [linux]

  '@rollup/rollup-linux-x64-musl@4.30.0':
    resolution: {integrity: sha512-3wzKzduS7jzxqcOvy/ocU/gMR3/QrHEFLge5CD7Si9fyHuoXcidyYZ6jyx8OPYmCcGm3uKTUl+9jUSAY74Ln5A==}
    cpu: [x64]
    os: [linux]

  '@rollup/rollup-linux-x64-musl@4.34.7':
    resolution: {integrity: sha512-7wJPXRWTTPtTFDFezA8sle/1sdgxDjuMoRXEKtx97ViRxGGkVQYovem+Q8Pr/2HxiHp74SSRG+o6R0Yq0shPwQ==}
    cpu: [x64]
    os: [linux]

  '@rollup/rollup-win32-arm64-msvc@4.30.0':
    resolution: {integrity: sha512-jROwnI1+wPyuv696rAFHp5+6RFhXGGwgmgSfzE8e4xfit6oLRg7GyMArVUoM3ChS045OwWr9aTnU+2c1UdBMyw==}
    cpu: [arm64]
    os: [win32]

  '@rollup/rollup-win32-arm64-msvc@4.34.7':
    resolution: {integrity: sha512-MN7aaBC7mAjsiMEZcsJvwNsQVNZShgES/9SzWp1HC9Yjqb5OpexYnRjF7RmE4itbeesHMYYQiAtUAQaSKs2Rfw==}
    cpu: [arm64]
    os: [win32]

  '@rollup/rollup-win32-ia32-msvc@4.30.0':
    resolution: {integrity: sha512-duzweyup5WELhcXx5H1jokpr13i3BV9b48FMiikYAwk/MT1LrMYYk2TzenBd0jj4ivQIt58JWSxc19y4SvLP4g==}
    cpu: [ia32]
    os: [win32]

  '@rollup/rollup-win32-ia32-msvc@4.34.7':
    resolution: {integrity: sha512-aeawEKYswsFu1LhDM9RIgToobquzdtSc4jSVqHV8uApz4FVvhFl/mKh92wc8WpFc6aYCothV/03UjY6y7yLgbg==}
    cpu: [ia32]
    os: [win32]

  '@rollup/rollup-win32-x64-msvc@4.30.0':
    resolution: {integrity: sha512-DYvxS0M07PvgvavMIybCOBYheyrqlui6ZQBHJs6GqduVzHSZ06TPPvlfvnYstjODHQ8UUXFwt5YE+h0jFI8kwg==}
    cpu: [x64]
    os: [win32]

  '@rollup/rollup-win32-x64-msvc@4.34.7':
    resolution: {integrity: sha512-4ZedScpxxIrVO7otcZ8kCX1mZArtH2Wfj3uFCxRJ9NO80gg1XV0U/b2f/MKaGwj2X3QopHfoWiDQ917FRpwY3w==}
    cpu: [x64]
    os: [win32]

  '@scure/base@1.1.7':
    resolution: {integrity: sha512-PPNYBslrLNNUQ/Yad37MHYsNQtK67EhWb6WtSvNLLPo7SdVZgkUjD6Dg+5On7zNwmskf8OX7I7Nx5oN+MIWE0g==}

  '@spore-sdk/core@0.2.0':
    resolution: {integrity: sha512-UBxpY4bQlZtJecBQ9RaUg3aPHWAWYkEbEZUTwmY3jEBeqacOdwTJE7DzI7TaAV8wGydC9JeGBABIgABoScYPeA==}
    peerDependencies:
      '@ckb-lumos/lumos': 0.22.0-next.5
      lodash: ^4.17.21

  '@swc/core-darwin-arm64@1.7.11':
    resolution: {integrity: sha512-HRQv4qIeMBPThZ6Y/4yYW52rGsS6yrpusvuxLGyoFo45Y0y12/V2yXkOIA/0HIQyrqoUAxn1k4zQXpPaPNCmnw==}
    engines: {node: '>=10'}
    cpu: [arm64]
    os: [darwin]

  '@swc/core-darwin-x64@1.7.11':
    resolution: {integrity: sha512-vtMQj0F3oYwDu5yhO7SKDRg1XekRSi6/TbzHAbBXv+dBhlGGvcZZynT1H90EVFTv+7w7Sh+lOFvRv5Z4ZTcxow==}
    engines: {node: '>=10'}
    cpu: [x64]
    os: [darwin]

  '@swc/core-linux-arm-gnueabihf@1.7.11':
    resolution: {integrity: sha512-mHtzWKxhtyreI4CSxs+3+ENv8t/Qo35WFoYG66qHEgJz/Z2Lh6jv1E+MYgHdYwnpQHgHbdvAco7HsBu/Dt6xXw==}
    engines: {node: '>=10'}
    cpu: [arm]
    os: [linux]

  '@swc/core-linux-arm64-gnu@1.7.11':
    resolution: {integrity: sha512-FRwe/x0GfXSQjGP2lIk+NO0pUFS/lI/RorCLBPiK808EVE9JTbh9DKCc/4Bbb4jgScAjNkrFCUVObQYl3YKmpA==}
    engines: {node: '>=10'}
    cpu: [arm64]
    os: [linux]

  '@swc/core-linux-arm64-musl@1.7.11':
    resolution: {integrity: sha512-GY/rs0+GUq14Gbnza90KOrQd/9yHd5qQMii5jcSWcUCT5A8QTa8kiicsM2NxZeTJ69xlKmT7sLod5l99lki/2A==}
    engines: {node: '>=10'}
    cpu: [arm64]
    os: [linux]

  '@swc/core-linux-x64-gnu@1.7.11':
    resolution: {integrity: sha512-QDkGRwSPmp2RBOlSs503IUXlWYlny8DyznTT0QuK0ML2RpDFlXWU94K/EZhS0RBEUkMY/W51OacM8P8aS/dkCg==}
    engines: {node: '>=10'}
    cpu: [x64]
    os: [linux]

  '@swc/core-linux-x64-musl@1.7.11':
    resolution: {integrity: sha512-SBEfKrXy6zQ6ksnyxw1FaCftrIH4fLfA81xNnKb7x/6iblv7Ko6H0aK3P5C86jyqF/82+ONl9C7ImGkUFQADig==}
    engines: {node: '>=10'}
    cpu: [x64]
    os: [linux]

  '@swc/core-win32-arm64-msvc@1.7.11':
    resolution: {integrity: sha512-a2Y4xxEsLLYHJN7sMnw9+YQJDi3M1BxEr9hklfopPuGGnYLFNnx5CypH1l9ReijEfWjIAHNi7pq3m023lzW1Hg==}
    engines: {node: '>=10'}
    cpu: [arm64]
    os: [win32]

  '@swc/core-win32-ia32-msvc@1.7.11':
    resolution: {integrity: sha512-ZbZFMwZO+j8ulhegJ7EhJ/QVZPoQ5qc30ylJQSxizizTJaen71Q7/13lXWc6ksuCKvg6dUKrp/TPgoxOOtSrFA==}
    engines: {node: '>=10'}
    cpu: [ia32]
    os: [win32]

  '@swc/core-win32-x64-msvc@1.7.11':
    resolution: {integrity: sha512-IUohZedSJyDu/ReEBG/mqX6uG29uA7zZ9z6dIAF+p6eFxjXmh9MuHryyM+H8ebUyoq/Ad3rL+rUCksnuYNnI0w==}
    engines: {node: '>=10'}
    cpu: [x64]
    os: [win32]

  '@swc/core@1.7.11':
    resolution: {integrity: sha512-AB+qc45UrJrDfbhPKcUXk+9z/NmFfYYwJT6G7/iur0fCse9kXjx45gi40+u/O2zgarG/30/zV6E3ps8fUvjh7g==}
    engines: {node: '>=10'}
    peerDependencies:
      '@swc/helpers': '*'
    peerDependenciesMeta:
      '@swc/helpers':
        optional: true

  '@swc/counter@0.1.3':
    resolution: {integrity: sha512-e2BR4lsJkkRlKZ/qCHPw9ZaSxc0MVUd7gtbtaB7aMvHeJVYe8sOB8DBZkP2DtISHGSku9sCK6T6cnY0CtXrOCQ==}

  '@swc/types@0.1.12':
    resolution: {integrity: sha512-wBJA+SdtkbFhHjTMYH+dEH1y4VpfGdAc2Kw/LK09i9bXd/K6j6PkDcFCEzb6iVfZMkPRrl/q0e3toqTAJdkIVA==}

  '@tsconfig/node10@1.0.11':
    resolution: {integrity: sha512-DcRjDCujK/kCk/cUe8Xz8ZSpm8mS3mNNpta+jGCA6USEDfktlNvm1+IuZ9eTcDbNk41BHwpHHeW+N1lKCz4zOw==}

  '@tsconfig/node12@1.0.11':
    resolution: {integrity: sha512-cqefuRsh12pWyGsIoBKJA9luFu3mRxCA+ORZvA4ktLSzIuCUtWVxGIuXigEwO5/ywWFMZ2QEGKWvkZG1zDMTag==}

  '@tsconfig/node14@1.0.3':
    resolution: {integrity: sha512-ysT8mhdixWK6Hw3i1V2AeRqZ5WfXg1G43mqoYlM2nc6388Fq5jcXyr5mRsqViLx/GJYdoL0bfXD8nmF+Zn/Iow==}

  '@tsconfig/node16@1.0.4':
    resolution: {integrity: sha512-vxhUy4J8lyeyinH7Azl1pdd43GJhZH/tP2weN8TntQblOY+A0XbT8DJk1/oCPuOOyg/Ja757rG0CgHcWC8OfMA==}

  '@types/blake2b@2.1.3':
    resolution: {integrity: sha512-MFCdX0MNxFBP/xEILO5Td0kv6nI7+Q2iRWZbTL/yzH2/eDVZS5Wd1LHdsmXClvsCyzqaZfHFzZaN6BUeUCfSDA==}

  '@types/cookiejar@2.1.5':
    resolution: {integrity: sha512-he+DHOWReW0nghN24E1WUqM0efK4kI9oTqDm6XmK8ZPe2djZ90BSNdGnIyCLzCPw7/pogPlGbzI2wHGGmi4O/Q==}

  '@types/deep-freeze-strict@1.1.2':
    resolution: {integrity: sha512-VvMETBojHvhX4f+ocYTySQlXMZfxKV3Jyb7iCWlWaC+exbedkv6Iv2bZZqI736qXjVguH6IH7bzwMBMfTT+zuQ==}

  '@types/dotenv@8.2.0':
    resolution: {integrity: sha512-ylSC9GhfRH7m1EUXBXofhgx4lUWmFeQDINW5oLuS+gxWdfUeW4zJdeVTYVkexEW+e2VUvlZR2kGnGGipAWR7kw==}
    deprecated: This is a stub types definition. dotenv provides its own type definitions, so you do not need this installed.

  '@types/eslint-scope@3.7.7':
    resolution: {integrity: sha512-MzMFlSLBqNF2gcHWO0G1vP/YQyfvrxZ0bF+u7mzUdZ1/xK4A4sru+nraZz5i3iEIk1l1uyicaDVTB4QbbEkAYg==}

  '@types/eslint@8.56.10':
    resolution: {integrity: sha512-Shavhk87gCtY2fhXDctcfS3e6FdxWkCx1iUZ9eEUbh7rTqlZT0/IzOkCOVt0fCjcFuZ9FPYfuezTBImfHCDBGQ==}

  '@types/estree@1.0.5':
    resolution: {integrity: sha512-/kYRxGDLWzHOB7q+wtSUQlFrtcdUccpfy+X+9iMBpHK8QLLhx2wIPYuS5DYtR9Wa/YlZAbIovy7qVdB1Aq6Lyw==}

  '@types/estree@1.0.6':
    resolution: {integrity: sha512-AYnb1nQyY49te+VRAVgmzfcgjYS91mY5P0TKUDCLEM+gNnA+3T6rWITXRLYCpahpqSQbN5cE+gHpnPyXjHWxcw==}

  '@types/fs-extra@11.0.4':
    resolution: {integrity: sha512-yTbItCNreRooED33qjunPthRcSjERP1r4MqCZc7wv0u2sUkzTFp45tgUfS5+r7FrZPdmCCNflLhVSP/o+SemsQ==}

  '@types/json-schema@7.0.15':
    resolution: {integrity: sha512-5+fP8P8MFNC+AyZCDxrB2pkZFPGzqQWUzpSeuuVLvm8VMcorNYavBqoFcxK8bQz4Qsbn4oUEEem4wDLfcysGHA==}

  '@types/jsonfile@6.1.4':
    resolution: {integrity: sha512-D5qGUYwjvnNNextdU59/+fI+spnwtTFmyQP0h+PfIOSkNfpU6AOICUOkm4i0OnSk+NyjdPJrxCDro0sJsWlRpQ==}

  '@types/lodash.isequal@4.5.8':
    resolution: {integrity: sha512-uput6pg4E/tj2LGxCZo9+y27JNyB2OZuuI/T5F+ylVDYuqICLG2/ktjxx0v6GvVntAf8TvEzeQLcV0ffRirXuA==}

  '@types/lodash@4.17.7':
    resolution: {integrity: sha512-8wTvZawATi/lsmNu10/j2hk1KEP0IvjubqPE3cu1Xz7xfXXt5oCq3SNUz4fMIP4XGF9Ky+Ue2tBA3hcS7LSBlA==}

  '@types/methods@1.1.4':
    resolution: {integrity: sha512-ymXWVrDiCxTBE3+RIrrP533E70eA+9qu7zdWoHuOmGujkYtzf4HQF96b8nwHLqhuf4ykX61IGRIB38CC6/sImQ==}

  '@types/moo@0.5.9':
    resolution: {integrity: sha512-ZsFVecFi66jGQ6L41TonEaBhsIVeVftTz6iQKWTctzacHhzYHWvv9S0IyAJi4BhN7vb9qCQ3+kpStP2vbZqmDg==}

  '@types/nearley@2.11.5':
    resolution: {integrity: sha512-dM7TrN0bVxGGXTYGx4YhGear8ysLO5SOuouAWM9oltjQ3m9oYa13qi8Z1DJp5zxVMPukvQdsrnZmgzpeuTSEQA==}

  '@types/node@12.20.55':
    resolution: {integrity: sha512-J8xLz7q2OFulZ2cyGTLE1TbbZcjpno7FaN6zdJNrgAdrJ+DZzh/uFR6YrTb4C+nXakvud8Q4+rbhoIWlYQbUFQ==}

  '@types/node@20.14.11':
    resolution: {integrity: sha512-kprQpL8MMeszbz6ojB5/tU8PLN4kesnN8Gjzw349rDlNgsSzg90lAVj3llK99Dh7JON+t9AuscPPFW6mPbTnSA==}

  '@types/semver@7.5.8':
    resolution: {integrity: sha512-I8EUhyrgfLrcTkzV3TSsGyl1tSuPrEDzr0yd5m90UgNxQkyDXULk3b6MlQqTCpZpNtWe1K0hzclnZkTcLBe2UQ==}

  '@types/superagent@8.1.7':
    resolution: {integrity: sha512-NmIsd0Yj4DDhftfWvvAku482PZum4DBW7U51OvS8gvOkDDY0WT1jsVyDV3hK+vplrsYw8oDwi9QxOM7U68iwww==}

  '@types/supertest@6.0.2':
    resolution: {integrity: sha512-137ypx2lk/wTQbW6An6safu9hXmajAifU/s7szAHLN/FeIm5w7yR0Wkl9fdJMRSHwOn4HLAI0DaB2TOORuhPDg==}

  '@typescript-eslint/eslint-plugin@7.16.1':
    resolution: {integrity: sha512-SxdPak/5bO0EnGktV05+Hq8oatjAYVY3Zh2bye9pGZy6+jwyR3LG3YKkV4YatlsgqXP28BTeVm9pqwJM96vf2A==}
    engines: {node: ^18.18.0 || >=20.0.0}
    peerDependencies:
      '@typescript-eslint/parser': ^7.0.0
      eslint: ^8.56.0
      typescript: '*'
    peerDependenciesMeta:
      typescript:
        optional: true

  '@typescript-eslint/parser@7.16.1':
    resolution: {integrity: sha512-u+1Qx86jfGQ5i4JjK33/FnawZRpsLxRnKzGE6EABZ40KxVT/vWsiZFEBBHjFOljmmV3MBYOHEKi0Jm9hbAOClA==}
    engines: {node: ^18.18.0 || >=20.0.0}
    peerDependencies:
      eslint: ^8.56.0
      typescript: '*'
    peerDependenciesMeta:
      typescript:
        optional: true

  '@typescript-eslint/scope-manager@7.16.1':
    resolution: {integrity: sha512-nYpyv6ALte18gbMz323RM+vpFpTjfNdyakbf3nsLvF43uF9KeNC289SUEW3QLZ1xPtyINJ1dIsZOuWuSRIWygw==}
    engines: {node: ^18.18.0 || >=20.0.0}

  '@typescript-eslint/type-utils@7.16.1':
    resolution: {integrity: sha512-rbu/H2MWXN4SkjIIyWcmYBjlp55VT+1G3duFOIukTNFxr9PI35pLc2ydwAfejCEitCv4uztA07q0QWanOHC7dA==}
    engines: {node: ^18.18.0 || >=20.0.0}
    peerDependencies:
      eslint: ^8.56.0
      typescript: '*'
    peerDependenciesMeta:
      typescript:
        optional: true

  '@typescript-eslint/types@7.16.1':
    resolution: {integrity: sha512-AQn9XqCzUXd4bAVEsAXM/Izk11Wx2u4H3BAfQVhSfzfDOm/wAON9nP7J5rpkCxts7E5TELmN845xTUCQrD1xIQ==}
    engines: {node: ^18.18.0 || >=20.0.0}

  '@typescript-eslint/typescript-estree@7.16.1':
    resolution: {integrity: sha512-0vFPk8tMjj6apaAZ1HlwM8w7jbghC8jc1aRNJG5vN8Ym5miyhTQGMqU++kuBFDNKe9NcPeZ6x0zfSzV8xC1UlQ==}
    engines: {node: ^18.18.0 || >=20.0.0}
    peerDependencies:
      typescript: '*'
    peerDependenciesMeta:
      typescript:
        optional: true

  '@typescript-eslint/utils@7.16.1':
    resolution: {integrity: sha512-WrFM8nzCowV0he0RlkotGDujx78xudsxnGMBHI88l5J8wEhED6yBwaSLP99ygfrzAjsQvcYQ94quDwI0d7E1fA==}
    engines: {node: ^18.18.0 || >=20.0.0}
    peerDependencies:
      eslint: ^8.56.0

  '@typescript-eslint/visitor-keys@7.16.1':
    resolution: {integrity: sha512-Qlzzx4sE4u3FsHTPQAAQFJFNOuqtuY0LFrZHwQ8IHK705XxBiWOFkfKRWu6niB7hwfgnwIpO4jTC75ozW1PHWg==}
    engines: {node: ^18.18.0 || >=20.0.0}

  '@ungap/structured-clone@1.2.0':
    resolution: {integrity: sha512-zuVdFrMJiuCDQUMCzQaD6KL28MjnqqN8XnAqiEq9PNm/hCPTSGfrXCOfwj1ow4LFb/tNymJPwsNbVePc1xFqrQ==}

  '@vitest/coverage-v8@2.0.5':
    resolution: {integrity: sha512-qeFcySCg5FLO2bHHSa0tAZAOnAUbp4L6/A5JDuj9+bt53JREl8hpLjLHEWF0e/gWc8INVpJaqA7+Ene2rclpZg==}
    peerDependencies:
      vitest: 2.0.5

  '@vitest/expect@2.1.9':
    resolution: {integrity: sha512-UJCIkTBenHeKT1TTlKMJWy1laZewsRIzYighyYiJKZreqtdxSos/S1t+ktRMQWu2CKqaarrkeszJx1cgC5tGZw==}

  '@vitest/mocker@2.1.9':
    resolution: {integrity: sha512-tVL6uJgoUdi6icpxmdrn5YNo3g3Dxv+IHJBr0GXHaEdTcw3F+cPKnsXFhli6nO+f/6SDKPHEK1UN+k+TQv0Ehg==}
    peerDependencies:
      msw: ^2.4.9
      vite: ^5.0.0
    peerDependenciesMeta:
      msw:
        optional: true
      vite:
        optional: true

  '@vitest/pretty-format@2.1.9':
    resolution: {integrity: sha512-KhRIdGV2U9HOUzxfiHmY8IFHTdqtOhIzCpd8WRdJiE7D/HUcZVD0EgQCVjm+Q9gkUXWgBvMmTtZgIG48wq7sOQ==}

  '@vitest/runner@2.1.9':
    resolution: {integrity: sha512-ZXSSqTFIrzduD63btIfEyOmNcBmQvgOVsPNPe0jYtESiXkhd8u2erDLnMxmGrDCwHCCHE7hxwRDCT3pt0esT4g==}

  '@vitest/snapshot@2.1.9':
    resolution: {integrity: sha512-oBO82rEjsxLNJincVhLhaxxZdEtV0EFHMK5Kmx5sJ6H9L183dHECjiefOAdnqpIgT5eZwT04PoggUnW88vOBNQ==}

  '@vitest/spy@2.1.9':
    resolution: {integrity: sha512-E1B35FwzXXTs9FHNK6bDszs7mtydNi5MIfUWpceJ8Xbfb1gBMscAnwLbEu+B44ed6W3XjL9/ehLPHR1fkf1KLQ==}

  '@vitest/utils@2.1.9':
    resolution: {integrity: sha512-v0psaMSkNJ3A2NMrUEHFRzJtDPFn+/VWZ5WxImB21T9fjucJRmS7xCS3ppEnARb9y11OAzaD+P2Ps+b+BGX5iQ==}

  '@webassemblyjs/ast@1.12.1':
    resolution: {integrity: sha512-EKfMUOPRRUTy5UII4qJDGPpqfwjOmZ5jeGFwid9mnoqIFK+e0vqoi1qH56JpmZSzEL53jKnNzScdmftJyG5xWg==}

  '@webassemblyjs/floating-point-hex-parser@1.11.6':
    resolution: {integrity: sha512-ejAj9hfRJ2XMsNHk/v6Fu2dGS+i4UaXBXGemOfQ/JfQ6mdQg/WXtwleQRLLS4OvfDhv8rYnVwH27YJLMyYsxhw==}

  '@webassemblyjs/helper-api-error@1.11.6':
    resolution: {integrity: sha512-o0YkoP4pVu4rN8aTJgAyj9hC2Sv5UlkzCHhxqWj8butaLvnpdc2jOwh4ewE6CX0txSfLn/UYaV/pheS2Txg//Q==}

  '@webassemblyjs/helper-buffer@1.12.1':
    resolution: {integrity: sha512-nzJwQw99DNDKr9BVCOZcLuJJUlqkJh+kVzVl6Fmq/tI5ZtEyWT1KZMyOXltXLZJmDtvLCDgwsyrkohEtopTXCw==}

  '@webassemblyjs/helper-numbers@1.11.6':
    resolution: {integrity: sha512-vUIhZ8LZoIWHBohiEObxVm6hwP034jwmc9kuq5GdHZH0wiLVLIPcMCdpJzG4C11cHoQ25TFIQj9kaVADVX7N3g==}

  '@webassemblyjs/helper-wasm-bytecode@1.11.6':
    resolution: {integrity: sha512-sFFHKwcmBprO9e7Icf0+gddyWYDViL8bpPjJJl0WHxCdETktXdmtWLGVzoHbqUcY4Be1LkNfwTmXOJUFZYSJdA==}

  '@webassemblyjs/helper-wasm-section@1.12.1':
    resolution: {integrity: sha512-Jif4vfB6FJlUlSbgEMHUyk1j234GTNG9dBJ4XJdOySoj518Xj0oGsNi59cUQF4RRMS9ouBUxDDdyBVfPTypa5g==}

  '@webassemblyjs/ieee754@1.11.6':
    resolution: {integrity: sha512-LM4p2csPNvbij6U1f19v6WR56QZ8JcHg3QIJTlSwzFcmx6WSORicYj6I63f9yU1kEUtrpG+kjkiIAkevHpDXrg==}

  '@webassemblyjs/leb128@1.11.6':
    resolution: {integrity: sha512-m7a0FhE67DQXgouf1tbN5XQcdWoNgaAuoULHIfGFIEVKA6tu/edls6XnIlkmS6FrXAquJRPni3ZZKjw6FSPjPQ==}

  '@webassemblyjs/utf8@1.11.6':
    resolution: {integrity: sha512-vtXf2wTQ3+up9Zsg8sa2yWiQpzSsMyXj0qViVP6xKGCUT8p8YJ6HqI7l5eCnWx1T/FYdsv07HQs2wTFbbof/RA==}

  '@webassemblyjs/wasm-edit@1.12.1':
    resolution: {integrity: sha512-1DuwbVvADvS5mGnXbE+c9NfA8QRcZ6iKquqjjmR10k6o+zzsRVesil54DKexiowcFCPdr/Q0qaMgB01+SQ1u6g==}

  '@webassemblyjs/wasm-gen@1.12.1':
    resolution: {integrity: sha512-TDq4Ojh9fcohAw6OIMXqiIcTq5KUXTGRkVxbSo1hQnSy6lAM5GSdfwWeSxpAo0YzgsgF182E/U0mDNhuA0tW7w==}

  '@webassemblyjs/wasm-opt@1.12.1':
    resolution: {integrity: sha512-Jg99j/2gG2iaz3hijw857AVYekZe2SAskcqlWIZXjji5WStnOpVoat3gQfT/Q5tb2djnCjBtMocY/Su1GfxPBg==}

  '@webassemblyjs/wasm-parser@1.12.1':
    resolution: {integrity: sha512-xikIi7c2FHXysxXe3COrVUPSheuBtpcfhbpFj4gmu7KRLYOzANztwUU0IbsqvMqzuNK2+glRGWCEqZo1WCLyAQ==}

  '@webassemblyjs/wast-printer@1.12.1':
    resolution: {integrity: sha512-+X4WAlOisVWQMikjbcvY2e0rwPsKQ9F688lksZhBcPycBBuii3O7m8FACbDMWDojpAqvjIncrG8J0XHKyQfVeA==}

  '@xtuc/ieee754@1.2.0':
    resolution: {integrity: sha512-DX8nKgqcGwsc0eJSqYt5lwP4DH5FlHnmuWWBRy7X0NcaGR0ZtuyeESgMwTYVEtxmsNGY+qit4QYT/MIYTOTPeA==}

  '@xtuc/long@4.2.2':
    resolution: {integrity: sha512-NuHqBY1PB/D8xU6s/thBgOAiAP7HOYDQ32+BFZILJ8ivkUkAHQnWfn6WhL79Owj1qmUnoN/YPhktdIoucipkAQ==}

  abort-controller@3.0.0:
    resolution: {integrity: sha512-h8lQ8tacZYnR3vNQTgibj+tODHI5/+l06Au2Pcriv/Gmet0eaj4TwWH41sO9wnHDiQsEj19q0drzdWdeAHtweg==}
    engines: {node: '>=6.5'}

  abstract-logging@2.0.1:
    resolution: {integrity: sha512-2BjRTZxTPvheOvGbBslFSYOUkr+SjPtOnrLP33f+VIWLzezQpZcqVg7ja3L4dBXmzzgwT+a029jRx5PCi3JuiA==}

  acorn-import-attributes@1.9.5:
    resolution: {integrity: sha512-n02Vykv5uA3eHGM/Z2dQrcD56kL8TyDb2p1+0P83PClMnC/nc+anbQRhIOWnSq4Ke/KvDPrY3C9hDtC/A3eHnQ==}
    peerDependencies:
      acorn: ^8

  acorn-jsx@5.3.2:
    resolution: {integrity: sha512-rq9s+JNhf0IChjtDXxllJ7g41oZk5SlXtp0LHwyA5cejwn7vKmKp4pPri6YEePv2PU65sAsegbXtIinmDFDXgQ==}
    peerDependencies:
      acorn: ^6.0.0 || ^7.0.0 || ^8.0.0

  acorn-walk@8.3.3:
    resolution: {integrity: sha512-MxXdReSRhGO7VlFe1bRG/oI7/mdLV9B9JJT0N8vZOhF7gFRR5l3M8W9G8JxmKV+JC5mGqJ0QvqfSOLsCPa4nUw==}
    engines: {node: '>=0.4.0'}

  acorn@8.12.1:
    resolution: {integrity: sha512-tcpGyI9zbizT9JbV6oYE477V6mTlXvvi0T0G3SNIYE2apm/G5huBa1+K89VGeovbg+jycCrfhl3ADxErOuO6Jg==}
    engines: {node: '>=0.4.0'}
    hasBin: true

  ajv-formats@2.1.1:
    resolution: {integrity: sha512-Wx0Kx52hxE7C18hkMEggYlEifqWZtYaRgouJor+WMdPnQyEK13vgEWyVNup7SoeeoLMsr4kf5h6dOW11I15MUA==}
    peerDependencies:
      ajv: ^8.0.0
    peerDependenciesMeta:
      ajv:
        optional: true

  ajv-formats@3.0.1:
    resolution: {integrity: sha512-8iUql50EUR+uUcdRQ3HDqa6EVyo3docL8g5WJ3FNcWmu62IbkGUue/pEyLBW8VGKKucTPgqeks4fIU1DA4yowQ==}
    peerDependencies:
      ajv: ^8.0.0
    peerDependenciesMeta:
      ajv:
        optional: true

  ajv-keywords@3.5.2:
    resolution: {integrity: sha512-5p6WTN0DdTGVQk6VjcEju19IgaHudalcfabD7yhDGeA6bcQnmL+CpveLJq/3hvfwd1aof6L386Ougkx6RfyMIQ==}
    peerDependencies:
      ajv: ^6.9.1

  ajv@6.12.6:
    resolution: {integrity: sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==}

  ajv@8.12.0:
    resolution: {integrity: sha512-sRu1kpcO9yLtYxBKvqfTeh9KzZEwO3STyX1HT+4CaDzC6HpTGYhIhPIzj9XuKU7KYDwnaeh5hcOwjy1QuJzBPA==}

  ajv@8.17.1:
    resolution: {integrity: sha512-B/gBuNg5SiMTrPkC+A2+cW0RszwxYmn6VYxB/inlBStS5nx6xHIt/ehKRhIMhqusl7a8LjQoZnjCs5vhwxOQ1g==}

  ansi-colors@4.1.3:
    resolution: {integrity: sha512-/6w/C21Pm1A7aZitlI5Ni/2J6FFQN8i1Cvz3kHABAAbw93v/NlvKdVOqz7CCWz/3iv/JplRSEEZ83XION15ovw==}
    engines: {node: '>=6'}

  ansi-escapes@4.3.2:
    resolution: {integrity: sha512-gKXj5ALrKWQLsYG9jlTRmR/xKluxHV+Z9QEwNIgCfM1/uwPMCuzVVnh5mwTd+OuBZcwSIMbqssNWRm1lE51QaQ==}
    engines: {node: '>=8'}

  ansi-escapes@7.0.0:
    resolution: {integrity: sha512-GdYO7a61mR0fOlAsvC9/rIHf7L96sBc6dEWzeOu+KAea5bZyQRPIpojrVoI4AXGJS/ycu/fBTdLrUkA4ODrvjw==}
    engines: {node: '>=18'}

  ansi-regex@5.0.1:
    resolution: {integrity: sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==}
    engines: {node: '>=8'}

  ansi-regex@6.0.1:
    resolution: {integrity: sha512-n5M855fKb2SsfMIiFFoVrABHJC8QtHwVx+mHWP3QcEqBHYienj5dHSgjbxtC0WEZXYt4wcD6zrQElDPhFuZgfA==}
    engines: {node: '>=12'}

  ansi-styles@3.2.1:
    resolution: {integrity: sha512-VT0ZI6kZRdTh8YyJw3SMbYm/u+NqfsAxEpWO0Pf9sq8/e94WxxOpPKx9FR1FlyCtOVDNOQ+8ntlqFxiRc+r5qA==}
    engines: {node: '>=4'}

  ansi-styles@4.3.0:
    resolution: {integrity: sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==}
    engines: {node: '>=8'}

  ansi-styles@6.2.1:
    resolution: {integrity: sha512-bN798gFfQX+viw3R7yrGWRqnrN2oRkEkUjjl4JNn4E8GxxbjtG3FbrEIIY3l8/hrwUwIeCZvi4QuOTP4MErVug==}
    engines: {node: '>=12'}

  any-promise@1.3.0:
    resolution: {integrity: sha512-7UvmKalWRt1wgjL1RrGxoSJW/0QZFIegpeGvZG9kjp8vrRu55XTHbwnqq2GpXm9uLbcuhxm3IqX9OB4MZR1b2A==}

  anymatch@3.1.3:
    resolution: {integrity: sha512-KMReFUr0B4t+D+OBkjR3KYqvocp2XaSzO55UcB6mgQMd3KbcE+mWTyvVV7D/zsdEbNnV6acZUutkiHQXvTr1Rw==}
    engines: {node: '>= 8'}

  arg@4.1.3:
    resolution: {integrity: sha512-58S9QDqG0Xx27YwPSt9fJxivjYl432YCwfDMfZ+71RAqUrZef7LrKQZ3LHLOwCS4FLNBplP533Zx895SeOCHvA==}

  argparse@1.0.10:
    resolution: {integrity: sha512-o5Roy6tNG4SL/FOkCAN6RzjiakZS25RLYFrcMttJqbdd8BWrnA+fGz57iN5Pb06pvBGvl5gQ0B48dJlslXvoTg==}

  argparse@2.0.1:
    resolution: {integrity: sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==}

  array-timsort@1.0.3:
    resolution: {integrity: sha512-/+3GRL7dDAGEfM6TseQk/U+mi18TU2Ms9I3UlLdUMhz2hbvGNTKdj9xniwXfUqgYhHxRx0+8UnKkvlNwVU+cWQ==}

  array-union@2.1.0:
    resolution: {integrity: sha512-HGyxoOTYUyCM6stUe6EJgnd4EoewAI7zMdfqO+kGjnlZmBDz/cR5pf8r/cR4Wq60sL/p0IkcjUEEPwS3GFrIyw==}
    engines: {node: '>=8'}

  asap@2.0.6:
    resolution: {integrity: sha512-BSHWgDSAiKs50o2Re8ppvp3seVHXSRM44cdSsT9FfNEUUZLOGWVCsiWaRPWM1Znn+mqZ1OfVZ3z3DWEzSp7hRA==}

  assertion-error@2.0.1:
    resolution: {integrity: sha512-Izi8RQcffqCeNVgFigKli1ssklIbpHnCYc6AknXGYoB6grJqyeby7jv12JUQgmTAnIDnbck1uxksT4dzN3PWBA==}
    engines: {node: '>=12'}

  asynckit@0.4.0:
    resolution: {integrity: sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q==}

  atomic-sleep@1.0.0:
    resolution: {integrity: sha512-kNOjDqAh7px0XWNI+4QbzoiR/nTkHAWNud2uvnJquD1/x5a7EQZMJT0AczqK0Qn67oY/TTQ1LbUKajZpp3I9tQ==}
    engines: {node: '>=8.0.0'}

  avvio@8.3.2:
    resolution: {integrity: sha512-st8e519GWHa/azv8S87mcJvZs4WsgTBjOw/Ih1CP6u+8SZvcOeAYNG6JbsIrAUUJJ7JfmrnOkR8ipDS+u9SIRQ==}

  axios@1.7.4:
    resolution: {integrity: sha512-DukmaFRnY6AzAALSH4J2M3k6PkaC+MfaAGdEERRWcC9q3/TWQwLpHR8ZRLKTdQ3aBDL64EdluRDjJqKw+BPZEw==}

  b4a@1.6.6:
    resolution: {integrity: sha512-5Tk1HLk6b6ctmjIkAcU/Ujv/1WqiDl0F0JdRCR80VsOcUlHcu7pWeWRlOqQLHfDEsVx9YH/aif5AG4ehoCtTmg==}

  balanced-match@1.0.2:
    resolution: {integrity: sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==}

  base-x@3.0.10:
    resolution: {integrity: sha512-7d0s06rR9rYaIWHkpfLIFICM/tkSVdoPC9qYAQRpxn9DdKNWNsKC0uk++akckyLq16Tx2WIinnZ6WRriAt6njQ==}

  base-x@4.0.0:
    resolution: {integrity: sha512-FuwxlW4H5kh37X/oW59pwTzzTKRzfrrQwhmyspRM7swOEZcHtDZSCt45U6oKgtuFE+WYPblePMVIPR4RZrh/hw==}

  base64-js@1.5.1:
    resolution: {integrity: sha512-AKpaYlHn8t4SVbOHCy+b5+KKgvR4vrsD8vbvrbiQJps7fKDTkjkDry6ji0rUJjC0kzbNePLwzxq8iypo41qeWA==}

  bech32@2.0.0:
    resolution: {integrity: sha512-LcknSilhIGatDAsY1ak2I8VtGaHNhgMSYVxFrGLXv+xLHytaKZKcaUJJUE7qmBr7h33o5YQwP55pMI0xmkpJwg==}

  better-path-resolve@1.0.0:
    resolution: {integrity: sha512-pbnl5XzGBdrFU/wT4jqmJVPn2B6UHPBOhzMQkY/SPUPB6QtUXtmBHBIwCbXJol93mOpGMnQyP/+BB19q04xj7g==}
    engines: {node: '>=4'}

  binary-extensions@2.3.0:
    resolution: {integrity: sha512-Ceh+7ox5qe7LJuLHoY0feh3pHuUDHAcRUeyL2VYghZwfpkNIy/+8Ocg0a3UuSoYzavmylwuLWQOf3hl0jjMMIw==}
    engines: {node: '>=8'}

  bip174@2.1.1:
    resolution: {integrity: sha512-mdFV5+/v0XyNYXjBS6CQPLo9ekCx4gtKZFnJm5PMto7Fs9hTTDpkkzOB7/FtluRI6JbUUAu+snTYfJRgHLZbZQ==}
    engines: {node: '>=8.0.0'}

  bip32@4.0.0:
    resolution: {integrity: sha512-aOGy88DDlVUhspIXJN+dVEtclhIsfAUppD43V0j40cPTld3pv/0X/MlrZSZ6jowIaQQzFwP8M6rFU2z2mVYjDQ==}
    engines: {node: '>=6.0.0'}

  bitcoinjs-lib@6.1.6:
    resolution: {integrity: sha512-Fk8+Vc+e2rMoDU5gXkW9tD+313rhkm5h6N9HfZxXvYU9LedttVvmXKTgd9k5rsQJjkSfsv6XRM8uhJv94SrvcA==}
    engines: {node: '>=8.0.0'}

  bl@4.1.0:
    resolution: {integrity: sha512-1W07cM9gS6DcLperZfFSj+bWLtaPGSOHWhPiGzXmvVJbRLdG82sH/Kn8EtW1VqWVA54AKf2h5k5BbnIbwF3h6w==}

  blake2b-wasm@2.4.0:
    resolution: {integrity: sha512-S1kwmW2ZhZFFFOghcx73+ZajEfKBqhP82JMssxtLVMxlaPea1p9uoLiUZ5WYyHn0KddwbLc+0vh4wR0KBNoT5w==}

  blake2b@2.1.4:
    resolution: {integrity: sha512-AyBuuJNI64gIvwx13qiICz6H6hpmjvYS5DGkG6jbXMOT8Z3WUJ3V1X0FlhIoT1b/5JtHE3ki+xjtMvu1nn+t9A==}

  bn.js@4.12.0:
    resolution: {integrity: sha512-c98Bf3tPniI+scsdk237ku1Dc3ujXQTSgyiPUDEOe7tRkhrqridvh8klBv0HCEso1OLOYcHuCv/cS6DNxKH+ZA==}

  bn.js@5.2.1:
    resolution: {integrity: sha512-eXRvHzWyYPBuB4NBy0cmYQjGitUrtqwbvlzP3G6VFnNRbsZQIxQ10PbKKHt8gZ/HW/D/747aDl+QkDqg3KQLMQ==}

  brace-expansion@1.1.11:
    resolution: {integrity: sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==}

  brace-expansion@2.0.1:
    resolution: {integrity: sha512-XnAIvQ8eM+kC6aULx6wuQiwVsnzsi9d3WxzV3FpWTGA19F621kwdbsAcFKXgKUHZWsy+mY6iL1sHTxWEFCytDA==}

  braces@3.0.3:
    resolution: {integrity: sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==}
    engines: {node: '>=8'}

  brorand@1.1.0:
    resolution: {integrity: sha512-cKV8tMCEpQs4hK/ik71d6LrPOnpkpGBR0wzxqr68g2m/LB2GxVYQroAjMJZRVM1Y4BCjCKc3vAamxSzOY2RP+w==}

  browserslist@4.23.2:
    resolution: {integrity: sha512-qkqSyistMYdxAcw+CzbZwlBy8AGmS/eEWs+sEV5TnLRGDOL+C5M2EnH6tlZyg0YoAxGJAFKh61En9BR941GnHA==}
    engines: {node: ^6 || ^7 || ^8 || ^9 || ^10 || ^11 || ^12 || >=13.7}
    hasBin: true

  bs58@4.0.1:
    resolution: {integrity: sha512-Ok3Wdf5vOIlBrgCvTq96gBkJw+JUEzdBgyaza5HLtPm7yTHkjRy8+JzNyHF7BHa0bNWOQIp3m5YF0nnFcOIKLw==}

  bs58@5.0.0:
    resolution: {integrity: sha512-r+ihvQJvahgYT50JD05dyJNKlmmSlMoOGwn1lCcEzanPglg7TxYjioQUYehQ9mAR/+hOSd2jRc/Z2y5UxBymvQ==}

  bs58check@2.1.2:
    resolution: {integrity: sha512-0TS1jicxdU09dwJMNZtVAfzPi6Q6QeN0pM1Fkzrjn+XYHvzMKPU3pHVpva+769iNVSfIYWf7LJ6WR+BuuMf8cA==}

  bs58check@3.0.1:
    resolution: {integrity: sha512-hjuuJvoWEybo7Hn/0xOrczQKKEKD63WguEjlhLExYs2wUBcebDC1jDNK17eEAD2lYfw82d5ASC1d7K3SWszjaQ==}

  buffer-from@1.1.2:
    resolution: {integrity: sha512-E+XQCRwSbaaiChtv6k6Dwgc+bx+Bs6vuKJHHl5kox/BaKbhiXzqQOwK4cO22yElGp2OCmjwVhT3HmxgyPGnJfQ==}

  buffer@5.7.1:
    resolution: {integrity: sha512-EHcyIPBQ4BSGlvjB16k5KgAJ27CIsHY/2JBmCRReo48y9rQ3MaUzWX3KVlBa4U7MyX02HdVj0K7C3WaB3ju7FQ==}

  buffer@6.0.3:
    resolution: {integrity: sha512-FTiCpNxtwiZZHEZbcbTIcZjERVICn9yq/pDFkTl95/AxzD1naBctN7YO68riM/gLSDY7sdrMby8hofADYuuqOA==}

  bundle-require@5.0.0:
    resolution: {integrity: sha512-GuziW3fSSmopcx4KRymQEJVbZUfqlCqcq7dvs6TYwKRZiegK/2buMxQTPs6MGlNv50wms1699qYO54R8XfRX4w==}
    engines: {node: ^12.20.0 || ^14.13.1 || >=16.0.0}
    peerDependencies:
      esbuild: '>=0.18'

  cac@6.7.14:
    resolution: {integrity: sha512-b6Ilus+c3RrdDk+JhLKUAQfzzgLEPy6wcXqS7f/xe1EETvsDP6GORG7SFuOs6cID5YkqchW/LXZbX5bc8j7ZcQ==}
    engines: {node: '>=8'}

  call-bind-apply-helpers@1.0.2:
    resolution: {integrity: sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==}
    engines: {node: '>= 0.4'}

  call-bind@1.0.7:
    resolution: {integrity: sha512-GHTSNSYICQ7scH7sZ+M2rFopRoLh8t2bLSW6BbgrtLsahOIB5iyAVJf9GjWK3cYTDaMj4XdBpM1cA6pIS0Kv2w==}
    engines: {node: '>= 0.4'}

  callsites@3.1.0:
    resolution: {integrity: sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==}
    engines: {node: '>=6'}

  camelcase-keys@7.0.2:
    resolution: {integrity: sha512-Rjs1H+A9R+Ig+4E/9oyB66UC5Mj9Xq3N//vcLf2WzgdTi/3gUu3Z9KoqmlrEG4VuuLK8wJHofxzdQXz/knhiYg==}
    engines: {node: '>=12'}

  camelcase@6.3.0:
    resolution: {integrity: sha512-Gmy6FhYlCY7uOElZUSbxo2UCDH8owEk996gkbrpsgGtrJLM3J7jGxl9Ic7Qwwj4ivOE5AWZWRMecDdF7hqGjFA==}
    engines: {node: '>=10'}

  caniuse-lite@1.0.30001643:
    resolution: {integrity: sha512-ERgWGNleEilSrHM6iUz/zJNSQTP8Mr21wDWpdgvRwcTXGAq6jMtOUPP4dqFPTdKqZ2wKTdtB+uucZ3MRpAUSmg==}

  chai@5.1.2:
    resolution: {integrity: sha512-aGtmf24DW6MLHHG5gCx4zaI3uBq3KRtxeVs0DjFH6Z0rDNbsvTxFASFvdj79pxjxZ8/5u3PIiN3IwEIQkiiuPw==}
    engines: {node: '>=12'}

  chalk@2.4.2:
    resolution: {integrity: sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==}
    engines: {node: '>=4'}

  chalk@4.1.2:
    resolution: {integrity: sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==}
    engines: {node: '>=10'}

  chalk@5.3.0:
    resolution: {integrity: sha512-dLitG79d+GV1Nb/VYcCDFivJeK1hiukt9QjRNVOsUtTy1rR1YJsmpGGTZ3qJos+uw7WmWF4wUwBd9jxjocFC2w==}
    engines: {node: ^12.17.0 || ^14.13 || >=16.0.0}

  chalk@5.4.1:
    resolution: {integrity: sha512-zgVZuo2WcZgfUEmsn6eO3kINexW8RAE4maiQ8QNs8CtpPCSyMiYsULR3HQYkm3w8FIA3SberyMJMSldGsW+U3w==}
    engines: {node: ^12.17.0 || ^14.13 || >=16.0.0}

  chardet@0.7.0:
    resolution: {integrity: sha512-mT8iDcrh03qDGRRmoA2hmBJnxpllMR+0/0qlzjqZES6NdiWDcZkCNAk4rPFZ9Q85r27unkiNNg8ZOiwZXBHwcA==}

  check-error@2.1.1:
    resolution: {integrity: sha512-OAlb+T7V4Op9OwdkjmguYRqncdlx5JiofwOAUkmTF+jNdHwzTaTs4sRAGpzLF3oOz5xAyDGrPgeIDFQmDOTiJw==}
    engines: {node: '>= 16'}

  chokidar@3.6.0:
    resolution: {integrity: sha512-7VT13fmjotKpGipCW9JEQAusEPE+Ei8nl6/g4FBAmIm0GOOLMua9NDDo/DWp0ZAxCr3cPq5ZpBqmPAQgDda2Pw==}
    engines: {node: '>= 8.10.0'}

  chokidar@4.0.3:
    resolution: {integrity: sha512-Qgzu8kfBvo+cA4962jnP1KkS6Dop5NS6g7R5LFYJr4b8Ub94PPQXUksCw9PvXoeXPRRddRNC5C1JQUR2SMGtnA==}
    engines: {node: '>= 14.16.0'}

  chrome-trace-event@1.0.4:
    resolution: {integrity: sha512-rNjApaLzuwaOTjCiT8lSDdGN1APCiqkChLMJxJPWLunPAt5fy8xgU9/jNOchV84wfIxrA0lRQB7oCT8jrn/wrQ==}
    engines: {node: '>=6.0'}

  ci-info@3.9.0:
    resolution: {integrity: sha512-NIxF55hv4nSqQswkAeiOi1r83xy8JldOFDTWiug55KBu9Jnblncd2U6ViHmYgHf01TPZS77NJBhBMKdWj9HQMQ==}
    engines: {node: '>=8'}

  cipher-base@1.0.4:
    resolution: {integrity: sha512-Kkht5ye6ZGmwv40uUDZztayT2ThLQGfnj/T71N/XzeZeo3nf8foyW7zGTsPYkEya3m5f3cAypH+qe7YOrM1U2Q==}

  cli-cursor@3.1.0:
    resolution: {integrity: sha512-I/zHAwsKf9FqGoXM4WWRACob9+SNukZTd94DWF57E4toouRulbCxcUh6RKUEOQlYTHJnzkPMySvPNaaSLNfLZw==}
    engines: {node: '>=8'}

  cli-cursor@5.0.0:
    resolution: {integrity: sha512-aCj4O5wKyszjMmDT4tZj93kxyydN/K5zPWSCe6/0AV/AA1pqe5ZBIw0a2ZfPQV7lL5/yb5HsUreJ6UFAF1tEQw==}
    engines: {node: '>=18'}

  cli-spinners@2.9.2:
    resolution: {integrity: sha512-ywqV+5MmyL4E7ybXgKys4DugZbX0FC6LnwrhjuykIjnK9k8OQacQ7axGKnjDXWNhns0xot3bZI5h55H8yo9cJg==}
    engines: {node: '>=6'}

  cli-table3@0.6.5:
    resolution: {integrity: sha512-+W/5efTR7y5HRD7gACw9yQjqMVvEMLBHmboM/kPWam+H+Hmyrgjh6YncVKK122YZkXrLudzTuAukUw9FnMf7IQ==}
    engines: {node: 10.* || >= 12.*}

  cli-truncate@4.0.0:
    resolution: {integrity: sha512-nPdaFdQ0h/GEigbPClz11D0v/ZJEwxmeVZGeMo3Z5StPtUTkA9o1lD6QwoirYiSDzbcwn2XcjwmCp68W1IS4TA==}
    engines: {node: '>=18'}

  cli-width@3.0.0:
    resolution: {integrity: sha512-FxqpkPPwu1HjuN93Omfm4h8uIanXofW0RxVEW3k5RKx+mJJYSthzNhp32Kzxxy3YAEZ/Dc/EWN1vZRY0+kOhbw==}
    engines: {node: '>= 10'}

  cli-width@4.1.0:
    resolution: {integrity: sha512-ouuZd4/dm2Sw5Gmqy6bGyNNNe1qt9RpmxveLSO7KcgsTnU7RXfsw+/bukWGo1abgBiMAic068rclZsO4IWmmxQ==}
    engines: {node: '>= 12'}

  clone@1.0.4:
    resolution: {integrity: sha512-JQHZ2QMW6l3aH/j6xCqQThY/9OH4D/9ls34cgkUBiEeocRTU04tHfKPBsUK1PqZCUQM7GiA0IIXJSuXHI64Kbg==}
    engines: {node: '>=0.8'}

  color-convert@1.9.3:
    resolution: {integrity: sha512-QfAUtd+vFdAtFQcC8CCyYt1fYWxSqAiK2cSD6zDB8N3cpsEBAvRxp9zOGg6G/SHHJYAT88/az/IuDGALsNVbGg==}

  color-convert@2.0.1:
    resolution: {integrity: sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==}
    engines: {node: '>=7.0.0'}

  color-name@1.1.3:
    resolution: {integrity: sha512-72fSenhMw2HZMTVHeCA9KCmpEIbzWiQsjN+BHcBbS9vr1mtt+vJjPdksIBNUmKAW8TFUDPJK5SUU3QhE9NEXDw==}

  color-name@1.1.4:
    resolution: {integrity: sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==}

  colorette@2.0.20:
    resolution: {integrity: sha512-IfEDxwoWIjkeXL1eXcDiow4UbKjhLdq6/EuSVR9GMN7KVH3r9gQ83e73hsz1Nd1T3ijd5xv1wcWRYO+D6kCI2w==}

  combined-stream@1.0.8:
    resolution: {integrity: sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==}
    engines: {node: '>= 0.8'}

  commander@12.1.0:
    resolution: {integrity: sha512-Vw8qHK3bZM9y/P10u3Vib8o/DdkvA2OtPtZvD871QKjy74Wj1WSKFILMPRPSdUSx5RFK1arlJzEtA4PkFgnbuA==}
    engines: {node: '>=18'}

  commander@2.20.3:
    resolution: {integrity: sha512-GpVkmM8vF2vQUkj2LvZmD35JxeJOLCwJ9cUkugyk2nuhbv3+mJvpLYYt+0+USMxE+oj+ey/lJEnhZw75x/OMcQ==}

  commander@4.1.1:
    resolution: {integrity: sha512-NOKm8xhkzAjzFx8B2v5OAHT+u5pRQc2UCa2Vq9jYL/31o2wi9mxBA7LIFs3sV5VSC49z6pEhfbMULvShKj26WA==}
    engines: {node: '>= 6'}

  comment-json@4.2.3:
    resolution: {integrity: sha512-SsxdiOf064DWoZLH799Ata6u7iV658A11PlWtZATDlXPpKGJnbJZ5Z24ybixAi+LUUqJ/GKowAejtC5GFUG7Tw==}
    engines: {node: '>= 6'}

  component-emitter@1.3.1:
    resolution: {integrity: sha512-T0+barUSQRTUQASh8bx02dl+DhF54GtIDY13Y3m9oWTklKbb3Wv974meRpeZ3lp1JpLVECWWNHC4vaG2XHXouQ==}

  concat-map@0.0.1:
    resolution: {integrity: sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==}

  consola@2.15.3:
    resolution: {integrity: sha512-9vAdYbHj6x2fLKC4+oPH0kFzY/orMZyG2Aj+kNylHxKGJ/Ed4dpNyAQYwJOdqO4zdM7XpVHmyejQDcQHrnuXbw==}

  consola@3.2.3:
    resolution: {integrity: sha512-I5qxpzLv+sJhTVEoLYNcTW+bThDCPsit0vLNKShZx6rLtpilNpmmeTPaeqJb9ZE9dV3DGaeby6Vuhrw38WjeyQ==}
    engines: {node: ^14.18.0 || >=16.10.0}

  cookie@0.6.0:
    resolution: {integrity: sha512-U71cyTamuh1CRNCfpGY6to28lxvNwPG4Guz/EVjgf3Jmzv0vlDp1atT9eS5dDjMYHucpHbWns6Lwf3BKz6svdw==}
    engines: {node: '>= 0.6'}

  cookiejar@2.1.4:
    resolution: {integrity: sha512-LDx6oHrK+PhzLKJU9j5S7/Y3jM/mUHvD/DeI1WQmJn652iPC5Y4TBzC9l+5OMOXlyTTA+SmVUPm0HQUwpD5Jqw==}

  core-util-is@1.0.3:
    resolution: {integrity: sha512-ZQBvi1DcpJ4GDqanjucZ2Hj3wEO5pZDS89BWbkcrvdxksJorwUDDZamX9ldFkp9aw2lmBDLgkObEA4DWNJ9FYQ==}

  cosmiconfig@8.3.6:
    resolution: {integrity: sha512-kcZ6+W5QzcJ3P1Mt+83OUv/oHFqZHIx8DuxG6eZ5RGMERoLqp4BuGjhHLYGK+Kf5XVkQvqBSmAy/nGWN3qDgEA==}
    engines: {node: '>=14'}
    peerDependencies:
      typescript: '>=4.9.5'
    peerDependenciesMeta:
      typescript:
        optional: true

  create-hash@1.2.0:
    resolution: {integrity: sha512-z00bCGNHDG8mHAkP7CtT1qVu+bFQUPjYq/4Iv3C3kWjTFV10zIjfSoeqXo9Asws8gwSHDGj/hl2u4OGIjapeCg==}

  create-require@1.1.1:
    resolution: {integrity: sha512-dcKFX3jn0MpIaXjisoRvexIJVEKzaq7z2rZKxf+MSr9TkdmHmsU4m2lcLojrj/FHl8mk5VxMmYA+ftRkP/3oKQ==}

  cross-fetch@3.2.0:
    resolution: {integrity: sha512-Q+xVJLoGOeIMXZmbUK4HYk+69cQH6LudR0Vu/pRm2YlU/hDV9CiS0gKUMaWY5f2NeUH9C1nV3bsTlCo0FsTV1Q==}

  cross-spawn@5.1.0:
    resolution: {integrity: sha512-pTgQJ5KC0d2hcY8eyL1IzlBPYjTkyH72XRZPnLyKus2mBfNjQs3klqbJU2VILqZryAZUt9JOb3h/mWMy23/f5A==}

  cross-spawn@7.0.3:
    resolution: {integrity: sha512-iRDPJKUPVEND7dHPO8rkbOnPpyDygcDFtWjpeWNCgy8WP2rXcxXL8TskReQl6OrB2G7+UJrags1q15Fudc7G6w==}
    engines: {node: '>= 8'}

  dataloader@1.4.0:
    resolution: {integrity: sha512-68s5jYdlvasItOJnCuI2Q9s4q98g0pCyL3HrcKJu8KNugUl8ahgmZYg38ysLTgQjjXX3H8CJLkAvWrclWfcalw==}

  debug@4.3.5:
    resolution: {integrity: sha512-pt0bNEmneDIvdL1Xsd9oDQ/wrQRkXDT4AUWlNZNPKvW5x/jyO9VFXkJUP07vQ2upmw5PlaITaPKc31jK13V+jg==}
    engines: {node: '>=6.0'}
    peerDependencies:
      supports-color: '*'
    peerDependenciesMeta:
      supports-color:
        optional: true

  debug@4.4.0:
    resolution: {integrity: sha512-6WTZ/IxCY/T6BALoZHaE4ctp9xm+Z5kY/pzYaCHRFeyVhojxlrm+46y68HA6hr0TcwEssoxNiDEUJQjfPZ/RYA==}
    engines: {node: '>=6.0'}
    peerDependencies:
      supports-color: '*'
    peerDependenciesMeta:
      supports-color:
        optional: true

  deep-eql@5.0.2:
    resolution: {integrity: sha512-h5k/5U50IJJFpzfL6nO9jaaumfjO/f2NjK/oYB2Djzm4p9L+3T9qWpZqZ2hAbLPuuYq9wrU08WQyBTL5GbPk5Q==}
    engines: {node: '>=6'}

  deep-freeze-strict@1.1.1:
    resolution: {integrity: sha512-QemROZMM2IvhAcCFvahdX2Vbm4S/txeq5rFYU9fh4mQP79WTMW5c/HkQ2ICl1zuzcDZdPZ6zarDxQeQMsVYoNA==}

  deep-is@0.1.4:
    resolution: {integrity: sha512-oIPzksmTg4/MriiaYGO+okXDT7ztn/w3Eptv/+gSIdMdKsJo0u4CfYNFJPy+4SKMuCqGw2wxnA+URMg3t8a/bQ==}

  deepmerge@4.3.1:
    resolution: {integrity: sha512-3sUqbMEc77XqpdNO7FRyRog+eW3ph+GYCbj+rK+uYyRMuwsVy0rMiVtPn+QJlKFvWP/1PYpapqYn0Me2knFn+A==}
    engines: {node: '>=0.10.0'}

  defaults@1.0.4:
    resolution: {integrity: sha512-eFuaLoy/Rxalv2kr+lqMlUnrDWV+3j4pljOIJgLIhI058IQfWJ7vXhyEIHu+HtC738klGALYxOKDO0bQP3tg8A==}

  define-data-property@1.1.4:
    resolution: {integrity: sha512-rBMvIzlpA8v6E+SJZoo++HAYqsLrkg7MSfIinMPFhmkorw7X+dOXVJQs+QT69zGkzMyfDnIMN2Wid1+NbL3T+A==}
    engines: {node: '>= 0.4'}

  delayed-stream@1.0.0:
    resolution: {integrity: sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ==}
    engines: {node: '>=0.4.0'}

  detect-indent@6.1.0:
    resolution: {integrity: sha512-reYkTUJAZb9gUuZ2RvVCNhVHdg62RHnJ7WJl8ftMi4diZ6NWlciOzQN88pUhSELEwflJht4oQDv0F0BMlwaYtA==}
    engines: {node: '>=8'}

  dezalgo@1.0.4:
    resolution: {integrity: sha512-rXSP0bf+5n0Qonsb+SVVfNfIsimO4HEtmnIpPHY8Q1UCzKlQrDMfdobr8nJOOsRgWCyMRqeSBQzmWUMq7zvVig==}

  diff@4.0.2:
    resolution: {integrity: sha512-58lmxKSA4BNyLz+HHMUzlOEpg09FV+ev6ZMe3vJihgdxzgcwZ8VoEEPmALCZG9LmqfVoNMMKpttIYTVG6uDY7A==}
    engines: {node: '>=0.3.1'}

  dir-glob@3.0.1:
    resolution: {integrity: sha512-WkrWp9GR4KXfKGYzOLmTuGVi1UWFfws377n9cc55/tb6DuqyF6pcQ5AbiHEshaDpY9v6oaSr2XCDidGmMwdzIA==}
    engines: {node: '>=8'}

  discontinuous-range@1.0.0:
    resolution: {integrity: sha512-c68LpLbO+7kP/b1Hr1qs8/BJ09F5khZGTxqxZuhzxpmwJKOgRFHJWIb9/KmqnqHhLdO55aOxFH/EGBvUQbL/RQ==}

  doctrine@3.0.0:
    resolution: {integrity: sha512-yS+Q5i3hBf7GBkd4KG8a7eBNNWNGLTaEwwYWUijIYM7zrlYDM0BFXHjjPWlWZ1Rg7UaddZeIDmi9jF3HmqiQ2w==}
    engines: {node: '>=6.0.0'}

  dot-case@3.0.4:
    resolution: {integrity: sha512-Kv5nKlh6yRrdrGvxeJ2e5y2eRUpkUosIW4A2AS38zwSz27zu7ufDwQPi5Jhs3XAlGNetl3bmnGhQsMtkKJnj3w==}

  dotenv-expand@10.0.0:
    resolution: {integrity: sha512-GopVGCpVS1UKH75VKHGuQFqS1Gusej0z4FyQkPdwjil2gNIv+LNsqBlboOzpJFZKVT95GkCyWJbBSdFEFUWI2A==}
    engines: {node: '>=12'}

  dotenv@16.4.5:
    resolution: {integrity: sha512-ZmdL2rui+eB2YwhsWzjInR8LldtZHGDoQ1ugH85ppHKwpUHL7j7rN0Ti9NCnGiQbhaZ11FpR+7ao1dNsmduNUg==}
    engines: {node: '>=12'}

  dunder-proto@1.0.1:
    resolution: {integrity: sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==}
    engines: {node: '>= 0.4'}

  eastasianwidth@0.2.0:
    resolution: {integrity: sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==}

  ecpair@2.1.0:
    resolution: {integrity: sha512-cL/mh3MtJutFOvFc27GPZE2pWL3a3k4YvzUWEOvilnfZVlH3Jwgx/7d6tlD7/75tNk8TG2m+7Kgtz0SI1tWcqw==}
    engines: {node: '>=8.0.0'}

  electron-to-chromium@1.4.832:
    resolution: {integrity: sha512-cTen3SB0H2SGU7x467NRe1eVcQgcuS6jckKfWJHia2eo0cHIGOqHoAxevIYZD4eRHcWjkvFzo93bi3vJ9W+1lA==}

  elliptic@6.6.1:
    resolution: {integrity: sha512-RaddvvMatK2LJHqFJ+YA4WysVN5Ita9E35botqIYspQ4TkRAlCicdzKOjlyv/1Za5RyTNn7di//eEV0uTAfe3g==}

  emoji-regex@10.3.0:
    resolution: {integrity: sha512-QpLs9D9v9kArv4lfDEgg1X/gN5XLnf/A6l9cs8SPZLRZR3ZkY9+kwIQTxm+fsSej5UMYGE8fdoaZVIBlqG0XTw==}

  emoji-regex@8.0.0:
    resolution: {integrity: sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==}

  emoji-regex@9.2.2:
    resolution: {integrity: sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==}

  enhanced-resolve@5.17.0:
    resolution: {integrity: sha512-dwDPwZL0dmye8Txp2gzFmA6sxALaSvdRDjPH0viLcKrtlOL3tw62nWWweVD1SdILDTJrbrL6tdWVN58Wo6U3eA==}
    engines: {node: '>=10.13.0'}

  enquirer@2.4.1:
    resolution: {integrity: sha512-rRqJg/6gd538VHvR3PSrdRBb/1Vy2YfzHqzvbhGIQpDRKIa4FgV/54b5Q1xYSxOOwKvjXweS26E0Q+nAMwp2pQ==}
    engines: {node: '>=8.6'}

  environment@1.1.0:
    resolution: {integrity: sha512-xUtoPkMggbz0MPyPiIWr1Kp4aeWJjDZ6SMvURhimjdZgsRuDplF5/s9hcgGhyXMhs+6vpnuoiZ2kFiu3FMnS8Q==}
    engines: {node: '>=18'}

  error-ex@1.3.2:
    resolution: {integrity: sha512-7dFHNmqeFSEt2ZBsCriorKnn3Z2pj+fd9kmI6QoWw4//DL+icEBfc0U7qJCisqrTsKTjw4fNFy2pW9OqStD84g==}

  es-define-property@1.0.0:
    resolution: {integrity: sha512-jxayLKShrEqqzJ0eumQbVhTYQM27CfT1T35+gCgDFoL82JLsXqTJ76zv6A0YLOgEnLUMvLzsDsGIrl8NFpT2gQ==}
    engines: {node: '>= 0.4'}

  es-define-property@1.0.1:
    resolution: {integrity: sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==}
    engines: {node: '>= 0.4'}

  es-errors@1.3.0:
    resolution: {integrity: sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==}
    engines: {node: '>= 0.4'}

  es-module-lexer@1.5.4:
    resolution: {integrity: sha512-MVNK56NiMrOwitFB7cqDwq0CQutbw+0BvLshJSse0MUNU+y1FC3bUS/AQg7oUng+/wKrrki7JfmwtVHkVfPLlw==}

  es-module-lexer@1.6.0:
    resolution: {integrity: sha512-qqnD1yMU6tk/jnaMosogGySTZP8YtUgAffA9nMN+E/rjxcfRQ6IEk7IiozUjgxKoFHBGjTLnrHB/YC45r/59EQ==}

  es-object-atoms@1.1.1:
    resolution: {integrity: sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==}
    engines: {node: '>= 0.4'}

  es-set-tostringtag@2.1.0:
    resolution: {integrity: sha512-j6vWzfrGVfyXxge+O0x5sh6cvxAog0a/4Rdd2K36zCMV5eJ+/+tOAngRO8cODMNWbVRdVlmGZQL2YS3yR8bIUA==}
    engines: {node: '>= 0.4'}

  esbuild@0.21.5:
    resolution: {integrity: sha512-mg3OPMV4hXywwpoDxu3Qda5xCKQi+vCTZq8S9J/EpkhB2HzKXq4SNFZE3+NK93JYxc8VMSep+lOUSC/RVKaBqw==}
    engines: {node: '>=12'}
    hasBin: true

  esbuild@0.24.2:
    resolution: {integrity: sha512-+9egpBW8I3CD5XPe0n6BfT5fxLzxrlDzqydF3aviG+9ni1lDC/OvMHcxqEFV0+LANZG5R1bFMWfUrjVsdwxJvA==}
    engines: {node: '>=18'}
    hasBin: true

  escalade@3.1.2:
    resolution: {integrity: sha512-ErCHMCae19vR8vQGe50xIsVomy19rg6gFu3+r3jkEO46suLMWBksvVyoGgQV+jOfl84ZSOSlmv6Gxa89PmTGmA==}
    engines: {node: '>=6'}

  escape-string-regexp@1.0.5:
    resolution: {integrity: sha512-vbRorB5FUQWvla16U8R/qgaFIya2qGzwDrNmCZuYKrbdSUMG6I1ZCGQRefkRVhuOkIGVne7BQ35DSfo1qvJqFg==}
    engines: {node: '>=0.8.0'}

  escape-string-regexp@4.0.0:
    resolution: {integrity: sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==}
    engines: {node: '>=10'}

  eslint-scope@5.1.1:
    resolution: {integrity: sha512-2NxwbF/hZ0KpepYN0cNbo+FN6XoK7GaHlQhgx/hIZl6Va0bF45RQOOwhLIy8lQDbuCiadSLCBnH2CFYquit5bw==}
    engines: {node: '>=8.0.0'}

  eslint-scope@7.2.2:
    resolution: {integrity: sha512-dOt21O7lTMhDM+X9mB4GX+DZrZtCUJPL/wlcTqxyrx5IvO0IYtILdtrQGQp+8n5S0gwSVmOf9NQrjMOgfQZlIg==}
    engines: {node: ^12.22.0 || ^14.17.0 || >=16.0.0}

  eslint-visitor-keys@3.4.3:
    resolution: {integrity: sha512-wpc+LXeiyiisxPlEkUzU6svyS1frIO3Mgxj1fdy7Pm8Ygzguax2N3Fa/D/ag1WqbOprdI+uY6wMUl8/a2G+iag==}
    engines: {node: ^12.22.0 || ^14.17.0 || >=16.0.0}

  eslint@8.57.0:
    resolution: {integrity: sha512-dZ6+mexnaTIbSBZWgou51U6OmzIhYM2VcNdtiTtI7qPNZm35Akpr0f6vtw3w1Kmn5PYo+tZVfh13WrhpS6oLqQ==}
    engines: {node: ^12.22.0 || ^14.17.0 || >=16.0.0}
    deprecated: This version is no longer supported. Please see https://eslint.org/version-support for other options.
    hasBin: true

  espree@9.6.1:
    resolution: {integrity: sha512-oruZaFkjorTpF32kDSI5/75ViwGeZginGGy2NoOSg3Q9bnwlnmDm4HLnkl0RE3n+njDXR037aY1+x58Z/zFdwQ==}
    engines: {node: ^12.22.0 || ^14.17.0 || >=16.0.0}

  esprima@4.0.1:
    resolution: {integrity: sha512-eGuFFw7Upda+g4p+QHvnW0RyTX/SVeJBDM/gCtMARO0cLuT2HcEKnTPvhjV6aGeqrCB/sbNop0Kszm0jsaWU4A==}
    engines: {node: '>=4'}
    hasBin: true

  esquery@1.6.0:
    resolution: {integrity: sha512-ca9pw9fomFcKPvFLXhBKUK90ZvGibiGOvRJNbjljY7s7uq/5YO4BOzcYtJqExdx99rF6aAcnRxHmcUHcz6sQsg==}
    engines: {node: '>=0.10'}

  esrecurse@4.3.0:
    resolution: {integrity: sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==}
    engines: {node: '>=4.0'}

  estraverse@4.3.0:
    resolution: {integrity: sha512-39nnKffWz8xN1BU/2c79n9nB9HDzo0niYUqx6xyqUnyoAnQyyWpOTdZEeiCch8BBu515t4wp9ZmgVfVhn9EBpw==}
    engines: {node: '>=4.0'}

  estraverse@5.3.0:
    resolution: {integrity: sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==}
    engines: {node: '>=4.0'}

  estree-walker@2.0.2:
    resolution: {integrity: sha512-Rfkk/Mp/DL7JVje3u18FxFujQlTNR2q6QfMSMB7AvCBx91NGj/ba3kCfza0f6dVDbw7YlRf/nDrn7pQrCCyQ/w==}

  estree-walker@3.0.3:
    resolution: {integrity: sha512-7RUKfXgSMMkzt6ZuXmqapOurLGPPfgj6l9uRZ7lRGolvk0y2yocc35LdcxKC5PQZdn2DMqioAQ2NoWcrTKmm6g==}

  esutils@2.0.3:
    resolution: {integrity: sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==}
    engines: {node: '>=0.10.0'}

  event-target-shim@5.0.1:
    resolution: {integrity: sha512-i/2XbnSz/uxRCU6+NdVJgKWDTM427+MqYbkQzD321DuCQJUqOuJKIA0IM2+W2xtYHdKOmZ4dR6fExsd4SXL+WQ==}
    engines: {node: '>=6'}

  eventemitter3@5.0.1:
    resolution: {integrity: sha512-GWkBvjiSZK87ELrYOSESUYeVIc9mvLLf/nXalMOS5dYrgZq9o5OVkbZAVM06CVxYsCwH9BDZFPlQTlPA1j4ahA==}

  events@3.3.0:
    resolution: {integrity: sha512-mQw+2fkQbALzQ7V0MY0IqdnXNOeTtP4r0lN9z7AAawCXgqea7bDii20AYrIBrFd/Hx0M2Ocz6S111CaFkUcb0Q==}
    engines: {node: '>=0.8.x'}

  execa@8.0.1:
    resolution: {integrity: sha512-VyhnebXciFV2DESc+p6B+y0LjSm0krU4OgJN44qFAhBY0TJ+1V61tYD2+wHusZ6F9n5K+vl8k0sTy7PEfV4qpg==}
    engines: {node: '>=16.17'}

  expect-type@1.1.0:
    resolution: {integrity: sha512-bFi65yM+xZgk+u/KRIpekdSYkTB5W1pEf0Lt8Q8Msh7b+eQ7LXVtIB1Bkm4fvclDEL1b2CZkMhv2mOeF8tMdkA==}
    engines: {node: '>=12.0.0'}

  extendable-error@0.1.7:
    resolution: {integrity: sha512-UOiS2in6/Q0FK0R0q6UY9vYpQ21mr/Qn1KOnte7vsACuNJf514WvCCUHSRCPcgjPT2bAhNIJdlE6bVap1GKmeg==}

  external-editor@3.1.0:
    resolution: {integrity: sha512-hMQ4CX1p1izmuLYyZqLMO/qGNw10wSv9QDCPfzXfyFrOaCSSoRfqE1Kf1s5an66J5JZC62NewG+mK49jOCtQew==}
    engines: {node: '>=4'}

  fast-content-type-parse@1.1.0:
    resolution: {integrity: sha512-fBHHqSTFLVnR61C+gltJuE5GkVQMV0S2nqUO8TJ+5Z3qAKG8vAx4FKai1s5jq/inV1+sREynIWSuQ6HgoSXpDQ==}

  fast-decode-uri-component@1.0.1:
    resolution: {integrity: sha512-WKgKWg5eUxvRZGwW8FvfbaH7AXSh2cL+3j5fMGzUMCxWBJ3dV3a7Wz8y2f/uQ0e3B6WmodD3oS54jTQ9HVTIIg==}

  fast-deep-equal@3.1.3:
    resolution: {integrity: sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==}

  fast-glob@3.3.2:
    resolution: {integrity: sha512-oX2ruAFQwf/Orj8m737Y5adxDQO0LAB7/S5MnxCdTNDd4p6BsyIVsv9JQsATbTSq8KHRpLwIHbVlUNatxd+1Ow==}
    engines: {node: '>=8.6.0'}

  fast-json-stable-stringify@2.1.0:
    resolution: {integrity: sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==}

  fast-json-stringify@5.16.1:
    resolution: {integrity: sha512-KAdnLvy1yu/XrRtP+LJnxbBGrhN+xXu+gt3EUvZhYGKCr3lFHq/7UFJHHFgmJKoqlh6B40bZLEv7w46B0mqn1g==}

  fast-levenshtein@2.0.6:
    resolution: {integrity: sha512-DCXu6Ifhqcks7TZKY3Hxp3y6qphY5SJZmrWMDrKcERSOXWQdMhU9Ig/PYrzyw/ul9jOIyh0N4M0tbC5hodg8dw==}

  fast-querystring@1.1.2:
    resolution: {integrity: sha512-g6KuKWmFXc0fID8WWH0jit4g0AGBoJhCkJMb1RmbsSEUNvQ+ZC8D6CUZ+GtF8nMzSPXnhiePyyqqipzNNEnHjg==}

  fast-redact@3.5.0:
    resolution: {integrity: sha512-dwsoQlS7h9hMeYUq1W++23NDcBLV4KqONnITDV9DjfS3q1SgDGVrBdvvTLUotWtPSD7asWDV9/CmsZPy8Hf70A==}
    engines: {node: '>=6'}

  fast-safe-stringify@2.1.1:
    resolution: {integrity: sha512-W+KJc2dmILlPplD/H4K9l9LcAHAfPtP6BY84uVLXQ6Evcz9Lcg33Y2z1IVblT6xdY54PXYVHEv+0Wpq8Io6zkA==}

  fast-uri@2.4.0:
    resolution: {integrity: sha512-ypuAmmMKInk5q7XcepxlnUWDLWv4GFtaJqAzWKqn62IpQ3pejtr5dTVbt3vwqVaMKmkNR55sTT+CqUKIaT21BA==}

  fast-uri@3.0.1:
    resolution: {integrity: sha512-MWipKbbYiYI0UC7cl8m/i/IWTqfC8YXsqjzybjddLsFjStroQzsHXkc73JutMvBiXmOvapk+axIl79ig5t55Bw==}

  fastify-plugin@4.5.1:
    resolution: {integrity: sha512-stRHYGeuqpEZTL1Ef0Ovr2ltazUT9g844X5z/zEBFLG8RYlpDiOCIG+ATvYEp+/zmc7sN29mcIMp8gvYplYPIQ==}

  fastify@4.28.0:
    resolution: {integrity: sha512-HhW7UHW07YlqH5qpS0af8d2Gl/o98DhJ8ZDQWHRNDnzeOhZvtreWsX8xanjGgXmkYerGbo8ax/n40Dpwqkot8Q==}

  fastq@1.17.1:
    resolution: {integrity: sha512-sRVD3lWVIXWg6By68ZN7vho9a1pQcN/WBFaAAsDDFzlJjvoGx0P8z7V1t72grFJfJhu3YPZBuu25f7Kaw2jN1w==}

  fdir@6.4.2:
    resolution: {integrity: sha512-KnhMXsKSPZlAhp7+IjUkRZKPb4fUyccpDrdFXbi4QL1qkmFh9kVY09Yox+n4MaOb3lHZ1Tv829C3oaaXoMYPDQ==}
    peerDependencies:
      picomatch: ^3 || ^4
    peerDependenciesMeta:
      picomatch:
        optional: true

  figures@3.2.0:
    resolution: {integrity: sha512-yaduQFRKLXYOGgEn6AZau90j3ggSOyiqXU0F9JZfeXYhNa+Jk4X+s45A2zg5jns87GAFa34BBm2kXw4XpNcbdg==}
    engines: {node: '>=8'}

  file-entry-cache@6.0.1:
    resolution: {integrity: sha512-7Gps/XWymbLk2QLYK4NzpMOrYjMhdIxXuIvy2QBsLE6ljuodKvdkWs/cpyJJ3CVIVpH0Oi1Hvg1ovbMzLdFBBg==}
    engines: {node: ^10.12.0 || >=12.0.0}

  fill-range@7.1.1:
    resolution: {integrity: sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==}
    engines: {node: '>=8'}

  find-my-way@8.2.0:
    resolution: {integrity: sha512-HdWXgFYc6b1BJcOBDBwjqWuHJj1WYiqrxSh25qtU4DabpMFdj/gSunNBQb83t+8Zt67D7CXEzJWTkxaShMTMOA==}
    engines: {node: '>=14'}

  find-up@4.1.0:
    resolution: {integrity: sha512-PpOwAdQ/YlXQ2vj8a3h8IipDuYRi3wceVQQGYWxNINccq40Anw7BlsEXCMbt1Zt+OLA6Fq9suIpIWD0OsnISlw==}
    engines: {node: '>=8'}

  find-up@5.0.0:
    resolution: {integrity: sha512-78/PXT1wlLLDgTzDs7sjq9hzz0vXD+zn+7wypEe4fXQxCmdmqfGsEPQxmiCSQI3ajFV91bVSsvNtrJRiW6nGng==}
    engines: {node: '>=10'}

  find-yarn-workspace-root2@1.2.16:
    resolution: {integrity: sha512-hr6hb1w8ePMpPVUK39S4RlwJzi+xPLuVuG8XlwXU3KD5Yn3qgBWVfy3AzNlDhWvE1EORCE65/Qm26rFQt3VLVA==}

  flat-cache@3.2.0:
    resolution: {integrity: sha512-CYcENa+FtcUKLmhhqyctpclsq7QF38pKjZHsGNiSQF5r4FtoKDWabFDl3hzaEQMvT1LHEysw5twgLvpYYb4vbw==}
    engines: {node: ^10.12.0 || >=12.0.0}

  flatted@3.3.1:
    resolution: {integrity: sha512-X8cqMLLie7KsNUDSdzeN8FYK9rEt4Dt67OsG/DNGnYTSDBG4uFAJFBnUeiV+zCVAvwFy56IjM9sH51jVaEhNxw==}

  follow-redirects@1.15.9:
    resolution: {integrity: sha512-gew4GsXizNgdoRyqmyfMHyAmXsZDk6mHkSxZFCzW9gwlbtOW44CDtYavM+y+72qD/Vq2l550kMF52DT8fOLJqQ==}
    engines: {node: '>=4.0'}
    peerDependencies:
      debug: '*'
    peerDependenciesMeta:
      debug:
        optional: true

  foreground-child@3.2.1:
    resolution: {integrity: sha512-PXUUyLqrR2XCWICfv6ukppP96sdFwWbNEnfEMt7jNsISjMsvaLNinAHNDYyvkyU+SZG2BTSbT5NjG+vZslfGTA==}
    engines: {node: '>=14'}

  fork-ts-checker-webpack-plugin@9.0.2:
    resolution: {integrity: sha512-Uochze2R8peoN1XqlSi/rGUkDQpRogtLFocP9+PGu68zk1BDAKXfdeCdyVZpgTk8V8WFVQXdEz426VKjXLO1Gg==}
    engines: {node: '>=12.13.0', yarn: '>=1.0.0'}
    peerDependencies:
      typescript: '>3.6.0'
      webpack: ^5.11.0

  form-data@4.0.0:
    resolution: {integrity: sha512-ETEklSGi5t0QMZuiXoA/Q6vcnxcLQP5vdugSpuAyi6SVGi2clPPp+xgEhuMaHC+zGgn31Kd235W35f7Hykkaww==}
    engines: {node: '>= 6'}

  form-data@4.0.2:
    resolution: {integrity: sha512-hGfm/slu0ZabnNt4oaRZ6uREyfCj6P4fT/n6A1rGV+Z0VdGXjfOhVUpkn6qVQONHGIFwmveGXyDs75+nr6FM8w==}
    engines: {node: '>= 6'}

  formidable@2.1.2:
    resolution: {integrity: sha512-CM3GuJ57US06mlpQ47YcunuUZ9jpm8Vx+P2CGt2j7HpgkKZO/DJYQ0Bobim8G6PFQmK5lOqOOdUXboU+h73A4g==}

  forwarded@0.2.0:
    resolution: {integrity: sha512-buRG0fpBtRHSTCOASe6hD258tEubFoRLb4ZNA6NxMVHNw2gOcwHo9wyablzMzOA5z9xA9L1KNjk/Nt6MT9aYow==}
    engines: {node: '>= 0.6'}

  fs-extra@10.1.0:
    resolution: {integrity: sha512-oRXApq54ETRj4eMiFzGnHWGy+zo5raudjuxN0b8H7s/RU2oW0Wvsx9O0ACRN/kRq9E8Vu/ReskGB5o3ji+FzHQ==}
    engines: {node: '>=12'}

  fs-extra@7.0.1:
    resolution: {integrity: sha512-YJDaCJZEnBmcbw13fvdAM9AwNOJwOzrE4pqMqBq5nFiEqXUqHwlK4B+3pUw6JNvfSPtX05xFHtYy/1ni01eGCw==}
    engines: {node: '>=6 <7 || >=8'}

  fs-extra@8.1.0:
    resolution: {integrity: sha512-yhlQgA6mnOJUKOsRUFsgJdQCvkKhcz8tlZG5HBQfReYZy46OwLcY+Zia0mtdHsOo9y/hP+CxMN0TU9QxoOtG4g==}
    engines: {node: '>=6 <7 || >=8'}

  fs-monkey@1.0.6:
    resolution: {integrity: sha512-b1FMfwetIKymC0eioW7mTywihSQE4oLzQn1dB6rZB5fx/3NpNEdAWeCSMB+60/AeT0TCXsxzAlcYVEFCTAksWg==}

  fs.realpath@1.0.0:
    resolution: {integrity: sha512-OO0pH2lK6a0hZnAdau5ItzHPI6pUlvI7jMVnxUQRtw4owF2wk8lOSabtGDCTP4Ggrg2MbGnWO9X8K1t4+fGMDw==}

  fsevents@2.3.3:
    resolution: {integrity: sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==}
    engines: {node: ^8.16.0 || ^10.6.0 || >=11.0.0}
    os: [darwin]

  function-bind@1.1.2:
    resolution: {integrity: sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==}

  get-east-asian-width@1.2.0:
    resolution: {integrity: sha512-2nk+7SIVb14QrgXFHcm84tD4bKQz0RxPuMT8Ag5KPOq7J5fEmAg0UbXdTOSHqNuHSU28k55qnceesxXRZGzKWA==}
    engines: {node: '>=18'}

  get-intrinsic@1.2.4:
    resolution: {integrity: sha512-5uYhsJH8VJBTv7oslg4BznJYhDoRI6waYCxMmCdnTrcCrHA/fCFKoTFz2JKKE0HdDFUF7/oQuhzumXJK7paBRQ==}
    engines: {node: '>= 0.4'}

  get-intrinsic@1.2.7:
    resolution: {integrity: sha512-VW6Pxhsrk0KAOqs3WEd0klDiF/+V7gQOpAvY1jVU/LHmaD/kQO4523aiJuikX/QAKYiW6x8Jh+RJej1almdtCA==}
    engines: {node: '>= 0.4'}

  get-proto@1.0.1:
    resolution: {integrity: sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==}
    engines: {node: '>= 0.4'}

  get-stream@8.0.1:
    resolution: {integrity: sha512-VaUJspBffn/LMCJVoMvSAdmscJyS1auj5Zulnn5UoYcY531UWmdwhRWkcGKnGU93m5HSXP9LP2usOryrBtQowA==}
    engines: {node: '>=16'}

  get-tsconfig@4.7.6:
    resolution: {integrity: sha512-ZAqrLlu18NbDdRaHq+AKXzAmqIUPswPWKUchfytdAjiRFnCe5ojG2bstg6mRiZabkKfCoL/e98pbBELIV/YCeA==}

  glob-parent@5.1.2:
    resolution: {integrity: sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==}
    engines: {node: '>= 6'}

  glob-parent@6.0.2:
    resolution: {integrity: sha512-XxwI8EOhVQgWp6iDL+3b0r86f4d6AX6zSU55HfB4ydCEuXLXc5FcYeOu+nnGftS4TEju/11rt4KJPTMgbfmv4A==}
    engines: {node: '>=10.13.0'}

  glob-to-regexp@0.4.1:
    resolution: {integrity: sha512-lkX1HJXwyMcprw/5YUZc2s7DrpAiHB21/V+E1rHUrVNokkvB6bqMzT0VfV6/86ZNabt1k14YOIaT7nDvOX3Iiw==}

  glob@10.4.2:
    resolution: {integrity: sha512-GwMlUF6PkPo3Gk21UxkCohOv0PLcIXVtKyLlpEI28R/cO/4eNOdmLk3CMW1wROV/WR/EsZOWAfBbBOqYvs88/w==}
    engines: {node: '>=16 || 14 >=14.18'}
    hasBin: true

  glob@10.4.5:
    resolution: {integrity: sha512-7Bv8RF0k6xjo7d4A/PxYLbUCfb6c+Vpd2/mB2yRDlew7Jb5hEXiCD9ibfO7wpk8i4sevK6DFny9h7EYbM3/sHg==}
    hasBin: true

  glob@7.2.3:
    resolution: {integrity: sha512-nFR0zLpU2YCaRxwoCJvL6UvCH2JFyFVIvwTLsIf21AuHlMskA1hhTdk+LlYJtOlYt9v6dvszD2BGRqBL+iQK9Q==}
    deprecated: Glob versions prior to v9 are no longer supported

  globals@13.24.0:
    resolution: {integrity: sha512-AhO5QUcj8llrbG09iWhPU2B204J1xnPeL8kQmVorSsy+Sjj1sk8gIyh6cUocGmH4L0UuhAJy+hJMRA4mgA4mFQ==}
    engines: {node: '>=8'}

  globby@11.1.0:
    resolution: {integrity: sha512-jhIXaOzy1sb8IyocaruWSn1TjmnBVs8Ayhcy83rmxNJ8q2uWKCAj3CnJY+KpGSXCueAPc0i05kVvVKtP1t9S3g==}
    engines: {node: '>=10'}

  gopd@1.2.0:
    resolution: {integrity: sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==}
    engines: {node: '>= 0.4'}

  graceful-fs@4.2.11:
    resolution: {integrity: sha512-RbJ5/jmFcNNCcDV5o9eTnBLJ/HszWV0P73bc+Ff4nS/rJj+YaS6IGyiOL0VoBYX+l1Wrl3k63h/KrH+nhJ0XvQ==}

  graphemer@1.4.0:
    resolution: {integrity: sha512-EtKwoO6kxCL9WO5xipiHTZlSzBm7WLT627TqC/uVRd0HKmq8NXyebnNYxDoBi7wt8eTWrUrKXCOVaFq9x1kgag==}

  has-flag@3.0.0:
    resolution: {integrity: sha512-sKJf1+ceQBr4SMkvQnBDNDtf4TXpVhVGateu0t918bl30FnbE2m4vNLX+VWe/dpjlb+HugGYzW7uQXH98HPEYw==}
    engines: {node: '>=4'}

  has-flag@4.0.0:
    resolution: {integrity: sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==}
    engines: {node: '>=8'}

  has-own-prop@2.0.0:
    resolution: {integrity: sha512-Pq0h+hvsVm6dDEa8x82GnLSYHOzNDt7f0ddFa3FqcQlgzEiptPqL+XrOJNavjOzSYiYWIrgeVYYgGlLmnxwilQ==}
    engines: {node: '>=8'}

  has-property-descriptors@1.0.2:
    resolution: {integrity: sha512-55JNKuIW+vq4Ke1BjOTjM2YctQIvCT7GFzHwmfZPGo5wnrgkid0YQtnAleFSqumZm4az3n2BS+erby5ipJdgrg==}

  has-proto@1.0.3:
    resolution: {integrity: sha512-SJ1amZAJUiZS+PhsVLf5tGydlaVB8EdFpaSO4gmiUKUOxk8qzn5AIy4ZeJUmh22znIdk/uMAUT2pl3FxzVUH+Q==}
    engines: {node: '>= 0.4'}

  has-symbols@1.0.3:
    resolution: {integrity: sha512-l3LCuF6MgDNwTDKkdYGEihYjt5pRPbEg46rtlmnSPlUbgmB8LOIrKJbYYFBSbnPaJexMKtiPO8hmeRjRz2Td+A==}
    engines: {node: '>= 0.4'}

  has-symbols@1.1.0:
    resolution: {integrity: sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==}
    engines: {node: '>= 0.4'}

  has-tostringtag@1.0.2:
    resolution: {integrity: sha512-NqADB8VjPFLM2V0VvHUewwwsw0ZWBaIdgo+ieHtK3hasLz4qeCRjYcqfB6AQrBggRKppKF8L52/VqdVsO47Dlw==}
    engines: {node: '>= 0.4'}

  hash-base@3.1.0:
    resolution: {integrity: sha512-1nmYp/rhMDiE7AYkDw+lLwlAzz0AntGIe51F3RfFfEqyQ3feY2eI/NcwC6umIQVOASPMsWJLJScWKSSvzL9IVA==}
    engines: {node: '>=4'}

  hash.js@1.1.7:
    resolution: {integrity: sha512-taOaskGt4z4SOANNseOviYDvjEJinIkRgmp7LbKP2YTTmVxWBl87s/uzK9r+44BclBSp2X7K1hqeNfz9JbBeXA==}

  hasown@2.0.2:
    resolution: {integrity: sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==}
    engines: {node: '>= 0.4'}

  hexoid@1.0.0:
    resolution: {integrity: sha512-QFLV0taWQOZtvIRIAdBChesmogZrtuXvVWsFHZTk2SU+anspqZ2vMnoLg7IE1+Uk16N19APic1BuF8bC8c2m5g==}
    engines: {node: '>=8'}

  hmac-drbg@1.0.1:
    resolution: {integrity: sha512-Tti3gMqLdZfhOQY1Mzf/AanLiqh1WTiJgEj26ZuYQ9fbkLomzGchCws4FyrSd4VkpBfiNhaE1On+lOz894jvXg==}

  html-escaper@2.0.2:
    resolution: {integrity: sha512-H2iMtd0I4Mt5eYiapRdIDjp+XzelXQ0tFE4JS7YFwFevXXMmOp9myNrUvCg0D6ws8iqkRPBfKHgbwig1SmlLfg==}

  human-id@1.0.2:
    resolution: {integrity: sha512-UNopramDEhHJD+VR+ehk8rOslwSfByxPIZyJRfV739NDhN5LF1fa1MqnzKm2lGTQRjNrjK19Q5fhkgIfjlVUKw==}

  human-signals@5.0.0:
    resolution: {integrity: sha512-AXcZb6vzzrFAUE61HnN4mpLqd/cSIwNQjtNWR0euPm6y0iqx3G4gOXaIDdtdDwZmhwe82LA6+zinmW4UBWVePQ==}
    engines: {node: '>=16.17.0'}

  husky@9.1.7:
    resolution: {integrity: sha512-5gs5ytaNjBrh5Ow3zrvdUUY+0VxIuWVL4i9irt6friV+BqdCfmV11CQTWMiBYWHbXhco+J1kHfTOUkePhCDvMA==}
    engines: {node: '>=18'}
    hasBin: true

  iconv-lite@0.4.24:
    resolution: {integrity: sha512-v3MXnZAcvnywkTUEZomIActle7RXXeedOR31wwl7VlyoXO4Qi9arvSenNQWne1TcRwhCL1HwLI21bEqdpj8/rA==}
    engines: {node: '>=0.10.0'}

  ieee754@1.2.1:
    resolution: {integrity: sha512-dcyqhDvX1C46lXZcVqCpK+FtMRQVdIMN6/Df5js2zouUsqG7I6sFxitIC+7KYK29KdXOLHdu9zL4sFnoVQnqaA==}

  ignore@5.3.1:
    resolution: {integrity: sha512-5Fytz/IraMjqpwfd34ke28PTVMjZjJG2MPn5t7OE4eUCUNf8BAa7b5WUS9/Qvr6mwOQS7Mk6vdsMno5he+T8Xw==}
    engines: {node: '>= 4'}

  immutable@4.3.7:
    resolution: {integrity: sha512-1hqclzwYwjRDFLjcFxOM5AYkkG0rpFPpr1RLPMEuGczoS7YA8gLhy8SWXYRAA/XwfEHpfo3cw5JGioS32fnMRw==}

  import-fresh@3.3.0:
    resolution: {integrity: sha512-veYYhQa+D1QBKznvhUHxb8faxlrwUnxseDAbAp457E0wLNio2bOSKnjYDhMj+YiAq61xrMGhQk9iXVk5FzgQMw==}
    engines: {node: '>=6'}

  imurmurhash@0.1.4:
    resolution: {integrity: sha512-JmXMZ6wuvDmLiHEml9ykzqO6lwFbof0GG4IkcGaENdCRDDmMVnny7s5HsIgHCbaq0w2MyPhDqkhTUgS2LU2PHA==}
    engines: {node: '>=0.8.19'}

  inflight@1.0.6:
    resolution: {integrity: sha512-k92I/b08q4wvFscXCLvqfsHCrjrF7yiXsQuIVvVE7N82W3+aqpzuUdBbfhWcy/FZR3/4IgflMgKLOsvPDrGCJA==}
    deprecated: This module is not supported, and leaks memory. Do not use it. Check out lru-cache if you want a good and tested way to coalesce async requests by a key value, which is much more comprehensive and powerful.

  inherits@2.0.4:
    resolution: {integrity: sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==}

  inquirer@8.2.6:
    resolution: {integrity: sha512-M1WuAmb7pn9zdFRtQYk26ZBoY043Sse0wVDdk4Bppr+JOXyQYybdtvK+l9wUibhtjdjvtoiNy8tk+EgsYIUqKg==}
    engines: {node: '>=12.0.0'}

  inquirer@9.2.15:
    resolution: {integrity: sha512-vI2w4zl/mDluHt9YEQ/543VTCwPKWiHzKtm9dM2V0NdFcqEexDAjUHzO1oA60HRNaVifGXXM1tRRNluLVHa0Kg==}
    engines: {node: '>=18'}

  ipaddr.js@1.9.1:
    resolution: {integrity: sha512-0KI/607xoxSToH7GjN1FfSbLoU0+btTicjsQSWQlh/hZykN8KpmMf7uYwPW3R+akZ6R/w18ZlXSHBYXiYUPO3g==}
    engines: {node: '>= 0.10'}

  is-arrayish@0.2.1:
    resolution: {integrity: sha512-zz06S8t0ozoDXMG+ube26zeCTNXcKIPJZJi8hBrF4idCLms4CG9QtK7qBl1boi5ODzFpjswb5JPmHCbMpjaYzg==}

  is-binary-path@2.1.0:
    resolution: {integrity: sha512-ZMERYes6pDydyuGidse7OsHxtbI7WVeUEozgR/g7rd0xUimYNlvZRE/K2MgZTjWy725IfelLeVcEM97mmtRGXw==}
    engines: {node: '>=8'}

  is-extglob@2.1.1:
    resolution: {integrity: sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==}
    engines: {node: '>=0.10.0'}

  is-fullwidth-code-point@3.0.0:
    resolution: {integrity: sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==}
    engines: {node: '>=8'}

  is-fullwidth-code-point@4.0.0:
    resolution: {integrity: sha512-O4L094N2/dZ7xqVdrXhh9r1KODPJpFms8B5sGdJLPy664AgvXsreZUyCQQNItZRDlYug4xStLjNp/sz3HvBowQ==}
    engines: {node: '>=12'}

  is-fullwidth-code-point@5.0.0:
    resolution: {integrity: sha512-OVa3u9kkBbw7b8Xw5F9P+D/T9X+Z4+JruYVNapTjPYZYUznQ5YfWeFkOj606XYYW8yugTfC8Pj0hYqvi4ryAhA==}
    engines: {node: '>=18'}

  is-glob@4.0.3:
    resolution: {integrity: sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==}
    engines: {node: '>=0.10.0'}

  is-interactive@1.0.0:
    resolution: {integrity: sha512-2HvIEKRoqS62guEC+qBjpvRubdX910WCMuJTZ+I9yvqKU2/12eSL549HMwtabb4oupdj2sMP50k+XJfB/8JE6w==}
    engines: {node: '>=8'}

  is-number@7.0.0:
    resolution: {integrity: sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==}
    engines: {node: '>=0.12.0'}

  is-path-inside@3.0.3:
    resolution: {integrity: sha512-Fd4gABb+ycGAmKou8eMftCupSir5lRxqf4aD/vd0cD2qc4HL07OjCeuHMr8Ro4CoMaeCKDB0/ECBOVWjTwUvPQ==}
    engines: {node: '>=8'}

  is-stream@3.0.0:
    resolution: {integrity: sha512-LnQR4bZ9IADDRSkvpqMGvt/tEJWclzklNgSw48V5EAaAeDd6qGvN8ei6k5p0tvxSR171VmGyHuTiAOfxAbr8kA==}
    engines: {node: ^12.20.0 || ^14.13.1 || >=16.0.0}

  is-subdir@1.2.0:
    resolution: {integrity: sha512-2AT6j+gXe/1ueqbW6fLZJiIw3F8iXGJtt0yDrZaBhAZEG1raiTxKWU+IPqMCzQAXOUCKdA4UDMgacKH25XG2Cw==}
    engines: {node: '>=4'}

  is-unicode-supported@0.1.0:
    resolution: {integrity: sha512-knxG2q4UC3u8stRGyAVJCOdxFmv5DZiRcdlIaAQXAbSfJya+OhopNotLQrstBhququ4ZpuKbDc/8S6mgXgPFPw==}
    engines: {node: '>=10'}

  is-windows@1.0.2:
    resolution: {integrity: sha512-eXK1UInq2bPmjyX6e3VHIzMLobc4J94i4AWn+Hpq3OU5KkrRC96OAcR3PRJ/pGu6m8TRnBHP9dkXQVsT/COVIA==}
    engines: {node: '>=0.10.0'}

  isarray@1.0.0:
    resolution: {integrity: sha512-VLghIWNM6ELQzo7zwmcg0NmTVyWKYjvIeM83yjp0wRDTmUnrM678fQbcKBo6n2CJEF0szoG//ytg+TKla89ALQ==}

  isexe@2.0.0:
    resolution: {integrity: sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==}

  isobject@2.1.0:
    resolution: {integrity: sha512-+OUdGJlgjOBZDfxnDjYYG6zp487z0JGNQq3cYQYg5f5hKR+syHMsaztzGeml/4kGG55CSpKSpWTY+jYGgsHLgA==}
    engines: {node: '>=0.10.0'}

  istanbul-lib-coverage@3.2.2:
    resolution: {integrity: sha512-O8dpsF+r0WV/8MNRKfnmrtCWhuKjxrq2w+jpzBL5UZKTi2LeVWnWOmWRxFlesJONmc+wLAGvKQZEOanko0LFTg==}
    engines: {node: '>=8'}

  istanbul-lib-report@3.0.1:
    resolution: {integrity: sha512-GCfE1mtsHGOELCU8e/Z7YWzpmybrx/+dSTfLrvY8qRmaY6zXTKWn6WQIjaAFw069icm6GVMNkgu0NzI4iPZUNw==}
    engines: {node: '>=10'}

  istanbul-lib-source-maps@5.0.6:
    resolution: {integrity: sha512-yg2d+Em4KizZC5niWhQaIomgf5WlL4vOOjZ5xGCmF8SnPE/mDWWXgvRExdcpCgh9lLRRa1/fSYp2ymmbJ1pI+A==}
    engines: {node: '>=10'}

  istanbul-reports@3.1.7:
    resolution: {integrity: sha512-BewmUXImeuRk2YY0PVbxgKAysvhRPUQE0h5QRM++nVWyubKGV0l8qQ5op8+B2DOmwSe63Jivj0BjkPQVf8fP5g==}
    engines: {node: '>=8'}

  iterare@1.2.1:
    resolution: {integrity: sha512-RKYVTCjAnRthyJes037NX/IiqeidgN1xc3j1RjFfECFp28A1GVwK9nA+i0rJPaHqSZwygLzRnFlzUuHFoWWy+Q==}
    engines: {node: '>=6'}

  jackspeak@3.4.3:
    resolution: {integrity: sha512-OGlZQpz2yfahA/Rd1Y8Cd9SIEsqvXkLVoSw/cgwhnhFMDbsQFeZYoJJ7bIZBS9BcamUW96asq/npPWugM+RQBw==}

  jest-worker@27.5.1:
    resolution: {integrity: sha512-7vuh85V5cdDofPyxn58nrPjBktZo0u9x1g8WtjQol+jZDaE+fhN+cIvTj11GndBnMnyfrUOG1sZQxCdjKh+DKg==}
    engines: {node: '>= 10.13.0'}

  joycon@3.1.1:
    resolution: {integrity: sha512-34wB/Y7MW7bzjKRjUKTa46I2Z7eV62Rkhva+KkopW7Qvv/OSWBqvkSY7vusOPrNuZcUG3tApvdVgNB8POj3SPw==}
    engines: {node: '>=10'}

  js-sha256@0.11.0:
    resolution: {integrity: sha512-6xNlKayMZvds9h1Y1VWc0fQHQ82BxTXizWPEtEeGvmOUYpBRy4gbWroHLpzowe6xiQhHpelCQiE7HEdznyBL9Q==}

  js-tokens@4.0.0:
    resolution: {integrity: sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==}

  js-xxhash@1.0.4:
    resolution: {integrity: sha512-S/6Oo7ruxx5k8m4qlMnbpwQdJjRsvvfcIhIk1dA9c5y5GNhYHKYKu9krEK3QgBax6CxJuf4gRL2opgLkdzWIKg==}
    engines: {node: '>=8.0.0'}

  js-yaml@3.14.1:
    resolution: {integrity: sha512-okMH7OXXJ7YrN9Ok3/SXrnu4iX9yOk+25nqX4imS2npuvTYDmo/QEZoqwZkYaIDk3jVvBOTOIEgEhaLOynBS9g==}
    hasBin: true

  js-yaml@4.1.0:
    resolution: {integrity: sha512-wpxZs9NoxZaJESJGIZTyDEaYpl0FKSA+FB9aJiyemKhMwkxQg63h4T1KJgUGHpTqPDNRcmmYLugrRjJlBtWvRA==}
    hasBin: true

  jsbi@3.1.3:
    resolution: {integrity: sha512-nBJqA0C6Qns+ZxurbEoIR56wyjiUszpNy70FHvxO5ervMoCbZVE3z3kxr5nKGhlxr/9MhKTSUBs7cAwwuf3g9w==}

  jsbi@4.3.0:
    resolution: {integrity: sha512-SnZNcinB4RIcnEyZqFPdGPVgrg2AcnykiBy0sHVJQKHYeaLUvi3Exj+iaPpLnFVkDPZIV4U0yvgC9/R4uEAZ9g==}

  json-buffer@3.0.1:
    resolution: {integrity: sha512-4bV5BfR2mqfQTJm+V5tPPdf+ZpuhiIvTuAB5g8kcrXOZpTT/QwwVRWBywX1ozr6lEuPdbHxwaJlm9G6mI2sfSQ==}

  json-parse-even-better-errors@2.3.1:
    resolution: {integrity: sha512-xyFwyhro/JEof6Ghe2iz2NcXoj2sloNsWr/XsERDK/oiPCfaNhl5ONfp+jQdAZRQQ0IJWNzH9zIZF7li91kh2w==}

  json-rpc-2.0@1.7.0:
    resolution: {integrity: sha512-asnLgC1qD5ytP+fvBP8uL0rvj+l8P6iYICbzZ8dVxCpESffVjzA7KkYkbKCIbavs7cllwH1ZUaNtJwphdeRqpg==}

  json-schema-ref-resolver@1.0.1:
    resolution: {integrity: sha512-EJAj1pgHc1hxF6vo2Z3s69fMjO1INq6eGHXZ8Z6wCQeldCuwxGK9Sxf4/cScGn3FZubCVUehfWtcDM/PLteCQw==}

  json-schema-traverse@0.4.1:
    resolution: {integrity: sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==}

  json-schema-traverse@1.0.0:
    resolution: {integrity: sha512-NM8/P9n3XjXhIZn1lLhkFaACTOURQXjWhV4BA/RnOv8xvgqtqpAX9IO4mRQxSx1Rlo4tqzeqb0sOlruaOy3dug==}

  json-stable-stringify-without-jsonify@1.0.1:
    resolution: {integrity: sha512-Bdboy+l7tA3OGW6FjyFHWkP5LuByj1Tk33Ljyq0axyzdk9//JSi2u3fP1QSmd1KNwq6VOKYGlAu87CisVir6Pw==}

  json5@2.2.3:
    resolution: {integrity: sha512-XmOWe7eyHYH14cLdVPoyg+GOH3rYX++KpzrylJwSW98t3Nk+U8XOl8FWKOgwtzdb8lXGf6zYwDUzeHMWfxasyg==}
    engines: {node: '>=6'}
    hasBin: true

  jsonc-parser@3.2.1:
    resolution: {integrity: sha512-AilxAyFOAcK5wA1+LeaySVBrHsGQvUFCDWXKpZjzaL0PqW+xfBOttn8GNtWKFWqneyMZj41MWF9Kl6iPWLwgOA==}

  jsonc-parser@3.3.1:
    resolution: {integrity: sha512-HUgH65KyejrUFPvHFPbqOY0rsFip3Bo5wb4ngvdi1EpCYWUQDC5V+Y7mZws+DLkr4M//zQJoanu1SP+87Dv1oQ==}

  jsonfile@4.0.0:
    resolution: {integrity: sha512-m6F1R3z8jjlf2imQHS2Qez5sjKWQzbuuhuJ/FKYFRZvPE3PuHcSMVZzfsLhGVOkfd20obL5SWEBew5ShlquNxg==}

  jsonfile@6.1.0:
    resolution: {integrity: sha512-5dgndWOriYSm5cnYaJNhalLNDKOqFwyDB/rr1E9ZsGciGvKPs8R2xYGCacuf3z6K1YKDz182fd+fY3cn3pMqXQ==}

  keyv@4.5.4:
    resolution: {integrity: sha512-oxVHkHR/EJf2CNXnWxRLW6mg7JyCCUcG0DtEGmL2ctUo1PNTin1PUil+r/+4r5MpVgC/fn1kjsx7mjSujKqIpw==}

  levn@0.4.1:
    resolution: {integrity: sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==}
    engines: {node: '>= 0.8.0'}

  light-my-request@5.13.0:
    resolution: {integrity: sha512-9IjUN9ZyCS9pTG+KqTDEQo68Sui2lHsYBrfMyVUTTZ3XhH8PMZq7xO94Kr+eP9dhi/kcKsx4N41p2IXEBil1pQ==}

  lilconfig@3.1.2:
    resolution: {integrity: sha512-eop+wDAvpItUys0FWkHIKeC9ybYrTGbU41U5K7+bttZZeohvnY7M9dZ5kB21GNWiFT2q1OoPTvncPCgSOVO5ow==}
    engines: {node: '>=14'}

  lilconfig@3.1.3:
    resolution: {integrity: sha512-/vlFKAoH5Cgt3Ie+JLhRbwOsCQePABiU3tJ1egGvyQ+33R/vcwM2Zl2QR/LzjsBeItPt3oSVXapn+m4nQDvpzw==}
    engines: {node: '>=14'}

  lines-and-columns@1.2.4:
    resolution: {integrity: sha512-7ylylesZQ/PV29jhEDl3Ufjo6ZX7gCqJr5F7PKrqc93v7fzSymt1BpwEU8nAUXs8qzzvqhbjhK5QZg6Mt/HkBg==}

  lint-staged@15.3.0:
    resolution: {integrity: sha512-vHFahytLoF2enJklgtOtCtIjZrKD/LoxlaUusd5nh7dWv/dkKQJY74ndFSzxCdv7g0ueGg1ORgTSt4Y9LPZn9A==}
    engines: {node: '>=18.12.0'}
    hasBin: true

  listr2@8.2.5:
    resolution: {integrity: sha512-iyAZCeyD+c1gPyE9qpFu8af0Y+MRtmKOncdGoA2S5EY8iFq99dmmvkNnHiWo+pj0s7yH7l3KPIgee77tKpXPWQ==}
    engines: {node: '>=18.0.0'}

  load-tsconfig@0.2.5:
    resolution: {integrity: sha512-IXO6OCs9yg8tMKzfPZ1YmheJbZCiEsnBdcB03l0OcfK9prKnJb96siuHCr5Fl37/yo9DnKU+TLpxzTUspw9shg==}
    engines: {node: ^12.20.0 || ^14.13.1 || >=16.0.0}

  load-yaml-file@0.2.0:
    resolution: {integrity: sha512-OfCBkGEw4nN6JLtgRidPX6QxjBQGQf72q3si2uvqyFEMbycSFFHwAZeXx6cJgFM9wmLrf9zBwCP3Ivqa+LLZPw==}
    engines: {node: '>=6'}

  loader-runner@4.3.0:
    resolution: {integrity: sha512-3R/1M+yS3j5ou80Me59j7F9IMs4PXs3VqRrm0TU3AbKPxlmpoY1TNscJV/oGJXo8qCatFGTfDbY6W6ipGOYXfg==}
    engines: {node: '>=6.11.5'}

  locate-path@5.0.0:
    resolution: {integrity: sha512-t7hw9pI+WvuwNJXwk5zVHpyhIqzg2qTlklJOf0mVxGSbe3Fp2VieZcduNYjaLDoy6p9uGpQEGWG87WpMKlNq8g==}
    engines: {node: '>=8'}

  locate-path@6.0.0:
    resolution: {integrity: sha512-iPZK6eYjbxRu3uB4/WZ3EsEIMJFMqAoopl3R+zuq0UjcAm/MO6KCweDgPfP3elTztoKP3KtnVHxTn2NHBSDVUw==}
    engines: {node: '>=10'}

  lodash.isequal@4.5.0:
    resolution: {integrity: sha512-pDo3lu8Jhfjqls6GkMgpahsF9kCyayhgykjyLMNFTKWrpVdAQtYyB4muAMWozBB4ig/dtWAmsMxLEI8wuz+DYQ==}
    deprecated: This package is deprecated. Use require('node:util').isDeepStrictEqual instead.

  lodash.merge@4.6.2:
    resolution: {integrity: sha512-0KpjqXRVvrYyCsX1swR/XTK0va6VQkQM6MNo7PqW77ByjAhoARA8EfrP1N4+KlKj8YS0ZUCtRT/YUuhyYDujIQ==}

  lodash.sortby@4.7.0:
    resolution: {integrity: sha512-HDWXG8isMntAyRF5vZ7xKuEvOhT4AhlRt/3czTSjvGUxjYCBVRQY48ViDHyfYz9VIoBkW4TMGQNapx+l3RUwdA==}

  lodash.startcase@4.4.0:
    resolution: {integrity: sha512-+WKqsK294HMSc2jEbNgpHpd0JfIBhp7rEV4aqXWqFr6AlXov+SlcgB1Fv01y2kGe3Gc8nMW7VA0SrGuSkRfIEg==}

  lodash@4.17.21:
    resolution: {integrity: sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==}

  log-symbols@4.1.0:
    resolution: {integrity: sha512-8XPvpAA8uyhfteu8pIvQxpJZ7SYYdpUivZpGy6sFsBuKRY/7rQGavedeB8aK+Zkyq6upMFVL/9AW6vOYzfRyLg==}
    engines: {node: '>=10'}

  log-update@6.1.0:
    resolution: {integrity: sha512-9ie8ItPR6tjY5uYJh8K/Zrv/RMZ5VOlOWvtZdEHYSTFKZfIBPQa9tOAEeAWhd+AnIneLJ22w5fjOYtoutpWq5w==}
    engines: {node: '>=18'}

  loupe@3.1.3:
    resolution: {integrity: sha512-kkIp7XSkP78ZxJEsSxW3712C6teJVoeHHwgo9zJ380de7IYyJ2ISlxojcH2pC5OFLewESmnRi/+XCDIEEVyoug==}

  lower-case@2.0.2:
    resolution: {integrity: sha512-7fm3l3NAF9WfN6W3JOmf5drwpVqX78JtoGJ3A6W0a6ZnldM41w2fV5D490psKFTpMds8TJse/eHLFFsNHHjHgg==}

  lru-cache@10.4.3:
    resolution: {integrity: sha512-JNAzZcXrCt42VGLuYz0zfAzDfAvJWW6AfYlDBQyDV5DClI2m5sAmK+OIO7s59XfsRsWHp02jAJrRadPRGTt6SQ==}

  lru-cache@4.1.5:
    resolution: {integrity: sha512-sWZlbEP2OsHNkXrMl5GYk/jKk70MBng6UU4YI/qGDYbgf6YbP4EvmqISbXCoJiRKs+1bSpFHVgQxvJ17F2li5g==}

  magic-string@0.30.10:
    resolution: {integrity: sha512-iIRwTIf0QKV3UAnYK4PU8uiEc4SRh5jX0mwpIwETPpHdhVM4f53RSwS/vXvN1JhGX+Cs7B8qIq3d6AH49O5fAQ==}

  magic-string@0.30.17:
    resolution: {integrity: sha512-sNPKHvyjVf7gyjwS4xGTaW/mCnF8wnjtifKBEhxfZ7E/S8tQ0rssrwGNn6q8JH/ohItJfSQp9mBtQYuTlH5QnA==}

  magic-string@0.30.8:
    resolution: {integrity: sha512-ISQTe55T2ao7XtlAStud6qwYPZjE4GK1S/BeVPus4jrq6JuOnQ00YKQC581RWhR122W7msZV263KzVeLoqidyQ==}
    engines: {node: '>=12'}

  magicast@0.3.4:
    resolution: {integrity: sha512-TyDF/Pn36bBji9rWKHlZe+PZb6Mx5V8IHCSxk7X4aljM4e/vyDvZZYwHewdVaqiA0nb3ghfHU/6AUpDxWoER2Q==}

  make-dir@4.0.0:
    resolution: {integrity: sha512-hXdUTZYIVOt1Ex//jAQi+wTZZpUpwBj/0QsOzqegb3rGMMeJiSEu5xLHnYfBrRV4RH2+OCSOO95Is/7x1WJ4bw==}
    engines: {node: '>=10'}

  make-error@1.3.6:
    resolution: {integrity: sha512-s8UhlNe7vPKomQhC1qFelMokr/Sc3AgNbso3n74mVPA5LTZwkB9NlXf4XPamLxJE8h0gh73rM94xvwRT2CVInw==}

  map-obj@4.3.0:
    resolution: {integrity: sha512-hdN1wVrZbb29eBGiGjJbeP8JbKjq1urkHJ/LIP/NY48MZ1QVXUsQBV1G1zvYFHn1XE06cwjBsOI2K3Ulnj1YXQ==}
    engines: {node: '>=8'}

  math-intrinsics@1.1.0:
    resolution: {integrity: sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==}
    engines: {node: '>= 0.4'}

  md5.js@1.3.5:
    resolution: {integrity: sha512-xitP+WxNPcTTOgnTJcrhM0xvdPepipPSf3I8EIpGKeFLjt3PlJLIDG3u8EX53ZIubkb+5U2+3rELYpEhHhzdkg==}

  memfs@3.5.3:
    resolution: {integrity: sha512-UERzLsxzllchadvbPs5aolHh65ISpKpM+ccLbOJ8/vvpBKmAWf+la7dXFy7Mr0ySHbdHrFv5kGFCUHHe6GFEmw==}
    engines: {node: '>= 4.0.0'}

  merge-stream@2.0.0:
    resolution: {integrity: sha512-abv/qOcuPfk3URPfDzmZU1LKmuw8kT+0nIHvKrKgFrwifol/doWcdA4ZqsWQ8ENrFKkd67Mfpo/LovbIUsbt3w==}

  merge2@1.4.1:
    resolution: {integrity: sha512-8q7VEgMJW4J8tcfVPy8g09NcQwZdbwFEqhe/WZkoIzjn/3TGDwtOCYtXGxA3O8tPzpczCCDgv+P2P5y00ZJOOg==}
    engines: {node: '>= 8'}

  methods@1.1.2:
    resolution: {integrity: sha512-iclAHeNqNm68zFtnZ0e+1L2yUIdvzNoauKU4WBA3VvH/vPFieF7qfRlwUZU+DA9P9bPXIS90ulxoUoCH23sV2w==}
    engines: {node: '>= 0.6'}

  micromatch@4.0.7:
    resolution: {integrity: sha512-LPP/3KorzCwBxfeUuZmaR6bG2kdeHSbe0P2tY3FLRU4vYrjYz5hI4QZwV0njUx3jeuKe67YukQ1LSPZBKDqO/Q==}
    engines: {node: '>=8.6'}

  micromatch@4.0.8:
    resolution: {integrity: sha512-PXwfBhYu0hBCPw8Dn0E+WDYb7af3dSLVWKi3HGv84IdF4TyFoC0ysxFd0Goxw7nSv4T/PzEJQxsYsEiFCKo2BA==}
    engines: {node: '>=8.6'}

  mime-db@1.52.0:
    resolution: {integrity: sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==}
    engines: {node: '>= 0.6'}

  mime-types@2.1.35:
    resolution: {integrity: sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==}
    engines: {node: '>= 0.6'}

  mime@2.6.0:
    resolution: {integrity: sha512-USPkMeET31rOMiarsBNIHZKLGgvKc/LrjofAnBlOttf5ajRvqiRA8QsenbcooctK6d6Ts6aqZXBA+XbkKthiQg==}
    engines: {node: '>=4.0.0'}
    hasBin: true

  mimic-fn@2.1.0:
    resolution: {integrity: sha512-OqbOk5oEQeAZ8WXWydlu9HJjz9WVdEIvamMCcXmuqUYjTknH/sqsWvhQ3vgwKFRR1HpjvNBKQ37nbJgYzGqGcg==}
    engines: {node: '>=6'}

  mimic-fn@4.0.0:
    resolution: {integrity: sha512-vqiC06CuhBTUdZH+RYl8sFrL096vA45Ok5ISO6sE/Mr1jRbGH4Csnhi8f3wKVl7x8mO4Au7Ir9D3Oyv1VYMFJw==}
    engines: {node: '>=12'}

  mimic-function@5.0.1:
    resolution: {integrity: sha512-VP79XUPxV2CigYP3jWwAUFSku2aKqBH7uTAapFWCBqutsbmDo96KY5o8uh6U+/YSIn5OxJnXp73beVkpqMIGhA==}
    engines: {node: '>=18'}

  minimalistic-assert@1.0.1:
    resolution: {integrity: sha512-UtJcAD4yEaGtjPezWuO9wC4nwUnVH/8/Im3yEHQP4b67cXlD/Qr9hdITCU1xDbSEXg2XKNaP8jsReV7vQd00/A==}

  minimalistic-crypto-utils@1.0.1:
    resolution: {integrity: sha512-JIYlbt6g8i5jKfJ3xz7rF0LXmv2TkDxBLUkiBeZ7bAx4GnnNMr8xFpGnOxn6GhTEHx3SjRrZEoU+j04prX1ktg==}

  minimatch@3.1.2:
    resolution: {integrity: sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==}

  minimatch@9.0.5:
    resolution: {integrity: sha512-G6T0ZX48xgozx7587koeX9Ys2NYy6Gmv//P89sEte9V9whIapMNF4idKxnW2QtCcLiTWlb/wfCabAtAFWhhBow==}
    engines: {node: '>=16 || 14 >=14.17'}

  minimist@1.2.8:
    resolution: {integrity: sha512-2yyAR8qBkN3YuheJanUpWC5U3bb5osDywNB8RzDVlDwDHbocAJveqqj1u8+SVD7jkWT4yvsHCpWqqWqAxb0zCA==}

  minipass@7.1.2:
    resolution: {integrity: sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw==}
    engines: {node: '>=16 || 14 >=14.17'}

  mnemonist@0.39.6:
    resolution: {integrity: sha512-A/0v5Z59y63US00cRSLiloEIw3t5G+MiKz4BhX21FI+YBJXBOGW0ohFxTxO08dsOYlzxo87T7vGfZKYp2bcAWA==}

  moo@0.5.2:
    resolution: {integrity: sha512-iSAJLHYKnX41mKcJKjqvnAN9sf0LMDTXDEvFv+ffuRR9a1MIuXLjMNL6EsnDHSkKLTWNqQQ5uo61P4EbU4NU+Q==}

  mri@1.2.0:
    resolution: {integrity: sha512-tzzskb3bG8LvYGFF/mDTpq3jpI6Q9wc3LEmBaghu+DdCssd1FakN7Bc0hVNmEyGq1bq3RgfkCb3cmQLpNPOroA==}
    engines: {node: '>=4'}

  ms@2.1.2:
    resolution: {integrity: sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w==}

  ms@2.1.3:
    resolution: {integrity: sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==}

  mute-stream@0.0.8:
    resolution: {integrity: sha512-nnbWWOkoWyUsTjKrhgD0dcz22mdkSnpYqbEjIm2nhwhuxlSkpywJmBo8h0ZqJdkp73mb90SssHkN4rsRaBAfAA==}

  mute-stream@1.0.0:
    resolution: {integrity: sha512-avsJQhyd+680gKXyG/sQc0nXaC6rBkPOfyHYcFb9+hdkqQkR9bdnkJ0AMZhke0oesPqIO+mFFJ+IdBc7mst4IA==}
    engines: {node: ^14.17.0 || ^16.13.0 || >=18.0.0}

  mz@2.7.0:
    resolution: {integrity: sha512-z81GNO7nnYMEhrGh9LeymoE4+Yr0Wn5McHIZMK5cfQCl+NDX08sCZgUc9/6MHni9IWuFLm1Z3HTCXu2z9fN62Q==}

  nanoassert@2.0.0:
    resolution: {integrity: sha512-7vO7n28+aYO4J+8w96AzhmU8G+Y/xpPDJz/se19ICsqj/momRbb9mh9ZUtkoJ5X3nTnPdhEJyc0qnM6yAsHBaA==}

  nanoid@3.3.8:
    resolution: {integrity: sha512-WNLf5Sd8oZxOm+TzppcYk8gVOgP+l58xNy58D0nbUnOxOWRWvlcCV4kUF7ltmI6PsrLl/BgKEyS4mqsGChFN0w==}
    engines: {node: ^10 || ^12 || ^13.7 || ^14 || >=15.0.1}
    hasBin: true

  natural-compare@1.4.0:
    resolution: {integrity: sha512-OWND8ei3VtNC9h7V60qff3SVobHr996CTwgxubgyQYEpg290h9J0buyECNNJexkFm5sOajh5G116RYA1c8ZMSw==}

  nearley@2.20.1:
    resolution: {integrity: sha512-+Mc8UaAebFzgV+KpI5n7DasuuQCHA89dmwm7JXw3TV43ukfNQ9DnBH3Mdb2g/I4Fdxc26pwimBWvjIw0UAILSQ==}
    hasBin: true

  neo-async@2.6.2:
    resolution: {integrity: sha512-Yd3UES5mWCSqR+qNT93S3UoYUkqAZ9lLg8a7g9rimsWmYGK8cVToA4/sF3RrshdyV3sAGMXVUmpMYOw+dLpOuw==}

  no-case@3.0.4:
    resolution: {integrity: sha512-fgAN3jGAh+RoxUGZHTSOLJIqUc2wmoBwGR4tbpNAKmmovFoWq0OdRkb0VkldReO2a2iBT/OEulG9XSUc10r3zg==}

  node-abort-controller@3.1.1:
    resolution: {integrity: sha512-AGK2yQKIjRuqnc6VkX2Xj5d+QW8xZ87pa1UK6yA6ouUyuxfHuMP6umE5QK7UmTeOAymo+Zx1Fxiuw9rVx8taHQ==}

  node-emoji@1.11.0:
    resolution: {integrity: sha512-wo2DpQkQp7Sjm2A0cq+sN7EHKO6Sl0ctXeBdFZrL9T9+UywORbufTcTZxom8YqpLQt/FqNMUkOpkZrJVYSKD3A==}

  node-fetch@2.7.0:
    resolution: {integrity: sha512-c4FRfUm/dbcWZ7U+1Wq0AwCyFL+3nt2bEw05wfxSz+DWpWsitgmSgYmy2dQdWyKC1694ELPqMs/YzUSNozLt8A==}
    engines: {node: 4.x || >=6.0.0}
    peerDependencies:
      encoding: ^0.1.0
    peerDependenciesMeta:
      encoding:
        optional: true

  node-releases@2.0.18:
    resolution: {integrity: sha512-d9VeXT4SJ7ZeOqGX6R5EM022wpL+eWPooLI+5UpWn2jCT1aosUQEhQP214x33Wkwx3JQMvIm+tIoVOdodFS40g==}

  normalize-path@3.0.0:
    resolution: {integrity: sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA==}
    engines: {node: '>=0.10.0'}

  npm-run-path@5.3.0:
    resolution: {integrity: sha512-ppwTtiJZq0O/ai0z7yfudtBpWIoxM8yE6nHi1X47eFR2EWORqfbu6CnPlNsjeN683eT0qG6H/Pyf9fCcvjnnnQ==}
    engines: {node: ^12.20.0 || ^14.13.1 || >=16.0.0}

  object-assign@4.1.1:
    resolution: {integrity: sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==}
    engines: {node: '>=0.10.0'}

  object-inspect@1.13.2:
    resolution: {integrity: sha512-IRZSRuzJiynemAXPYtPe5BoI/RESNYR7TYm50MC5Mqbd3Jmw5y790sErYw3V6SryFJD64b74qQQs9wn5Bg/k3g==}
    engines: {node: '>= 0.4'}

  obliterator@2.0.4:
    resolution: {integrity: sha512-lgHwxlxV1qIg1Eap7LgIeoBWIMFibOjbrYPIPJZcI1mmGAI2m3lNYpK12Y+GBdPQ0U1hRwSord7GIaawz962qQ==}

  on-exit-leak-free@2.1.2:
    resolution: {integrity: sha512-0eJJY6hXLGf1udHwfNftBqH+g73EU4B504nZeKpz1sYRKafAghwxEJunB2O7rDZkL4PGfsMVnTXZ2EjibbqcsA==}
    engines: {node: '>=14.0.0'}

  once@1.4.0:
    resolution: {integrity: sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==}

  onetime@5.1.2:
    resolution: {integrity: sha512-kbpaSSGJTWdAY5KPVeMOKXSrPtr8C8C7wodJbcsd51jRnmD+GZu8Y0VoU6Dm5Z4vWr0Ig/1NKuWRKf7j5aaYSg==}
    engines: {node: '>=6'}

  onetime@6.0.0:
    resolution: {integrity: sha512-1FlR+gjXK7X+AsAHso35MnyN5KqGwJRi/31ft6x0M194ht7S+rWAvd7PHss9xSKMzE0asv1pyIHaJYq+BbacAQ==}
    engines: {node: '>=12'}

  onetime@7.0.0:
    resolution: {integrity: sha512-VXJjc87FScF88uafS3JllDgvAm+c/Slfz06lorj2uAY34rlUu0Nt+v8wreiImcrgAjjIHp1rXpTDlLOGw29WwQ==}
    engines: {node: '>=18'}

  optionator@0.9.4:
    resolution: {integrity: sha512-6IpQ7mKUxRcZNLIObR0hz7lxsapSSIYNZJwXPGeF0mTVqGKFIXj1DQcMoT22S3ROcLyY/rz0PWaWZ9ayWmad9g==}
    engines: {node: '>= 0.8.0'}

  ora@5.4.1:
    resolution: {integrity: sha512-5b6Y85tPxZZ7QytO+BQzysW31HJku27cRIlkbAXaNx+BdcVi+LlRFmVXzeF6a7JCwJpyw5c4b+YSVImQIrBpuQ==}
    engines: {node: '>=10'}

  os-tmpdir@1.0.2:
    resolution: {integrity: sha512-D2FR03Vir7FIu45XBY20mTb+/ZSWB00sjU9jdQXt83gDrI4Ztz5Fs7/yy74g2N5SVQY4xY1qDr4rNddwYRVX0g==}
    engines: {node: '>=0.10.0'}

  outdent@0.5.0:
    resolution: {integrity: sha512-/jHxFIzoMXdqPzTaCpFzAAWhpkSjZPF4Vsn6jAfNpmbH/ymsmd7Qc6VE9BGn0L6YMj6uwpQLxCECpus4ukKS9Q==}

  p-filter@2.1.0:
    resolution: {integrity: sha512-ZBxxZ5sL2HghephhpGAQdoskxplTwr7ICaehZwLIlfL6acuVgZPm8yBNuRAFBGEqtD/hmUeq9eqLg2ys9Xr/yw==}
    engines: {node: '>=8'}

  p-limit@2.3.0:
    resolution: {integrity: sha512-//88mFWSJx8lxCzwdAABTJL2MyWB12+eIY7MDL2SqLmAkeKU9qxRvWuSyTjm3FUmpBEMuFfckAIqEaVGUDxb6w==}
    engines: {node: '>=6'}

  p-limit@3.1.0:
    resolution: {integrity: sha512-TYOanM3wGwNGsZN2cVTYPArw454xnXj5qmWF1bEoAc4+cU/ol7GVh7odevjp1FNHduHc3KZMcFduxU5Xc6uJRQ==}
    engines: {node: '>=10'}

  p-locate@4.1.0:
    resolution: {integrity: sha512-R79ZZ/0wAxKGu3oYMlz8jy/kbhsNrS7SKZ7PxEHBgJ5+F2mtFW2fK2cOtBh1cHYkQsbzFV7I+EoRKe6Yt0oK7A==}
    engines: {node: '>=8'}

  p-locate@5.0.0:
    resolution: {integrity: sha512-LaNjtRWUBY++zB5nE/NwcaoMylSPk+S+ZHNB1TzdbMJMny6dynpAGt7X/tl/QYq3TIeE6nxHppbo2LGymrG5Pw==}
    engines: {node: '>=10'}

  p-map@2.1.0:
    resolution: {integrity: sha512-y3b8Kpd8OAN444hxfBbFfj1FY/RjtTd8tzYwhUqNYXx0fXx2iX4maP4Qr6qhIKbQXI02wTLAda4fYUbDagTUFw==}
    engines: {node: '>=6'}

  p-try@2.2.0:
    resolution: {integrity: sha512-R4nPAVTAU0B9D35/Gk3uJf/7XYbQcyohSKdvAxIRSNghFl4e71hVoGnBNQz9cWaXxO2I10KTC+3jMdvvoKw6dQ==}
    engines: {node: '>=6'}

  package-json-from-dist@1.0.0:
    resolution: {integrity: sha512-dATvCeZN/8wQsGywez1mzHtTlP22H8OEfPrVMLNr4/eGa+ijtLn/6M5f0dY8UKNrC2O9UCU6SSoG3qRKnt7STw==}

  parent-module@1.0.1:
    resolution: {integrity: sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==}
    engines: {node: '>=6'}

  parse-json@5.2.0:
    resolution: {integrity: sha512-ayCKvm/phCGxOkYRSCM82iDwct8/EonSEgCSxWxD7ve6jHggsFl4fZVQBPRNgQoKiuV/odhFrGzQXZwbifC8Rg==}
    engines: {node: '>=8'}

  path-exists@4.0.0:
    resolution: {integrity: sha512-ak9Qy5Q7jYb2Wwcey5Fpvg2KoAc/ZIhLSLOSBmRmygPsGwkVVt0fZa0qrtMz+m6tJTAHfZQ8FnmB4MG4LWy7/w==}
    engines: {node: '>=8'}

  path-is-absolute@1.0.1:
    resolution: {integrity: sha512-AVbw3UJ2e9bq64vSaS9Am0fje1Pa8pbGqTTsmXfaIiMpnr5DlDhfJOuLj9Sf95ZPVDAUerDfEk88MPmPe7UCQg==}
    engines: {node: '>=0.10.0'}

  path-key@3.1.1:
    resolution: {integrity: sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==}
    engines: {node: '>=8'}

  path-key@4.0.0:
    resolution: {integrity: sha512-haREypq7xkM7ErfgIyA0z+Bj4AGKlMSdlQE2jvJo6huWD1EdkKYV+G/T4nq0YEF2vgTT8kqMFKo1uHn950r4SQ==}
    engines: {node: '>=12'}

  path-scurry@1.11.1:
    resolution: {integrity: sha512-Xa4Nw17FS9ApQFJ9umLiJS4orGjm7ZzwUrwamcGQuHSzDyth9boKDaycYdDcZDuqYATXw4HFXgaqWTctW/v1HA==}
    engines: {node: '>=16 || 14 >=14.18'}

  path-to-regexp@3.2.0:
    resolution: {integrity: sha512-jczvQbCUS7XmS7o+y1aEO9OBVFeZBQ1MDSEqmO7xSoPgOPoowY/SxLpZ6Vh97/8qHZOteiCKb7gkG9gA2ZUxJA==}

  path-to-regexp@6.2.2:
    resolution: {integrity: sha512-GQX3SSMokngb36+whdpRXE+3f9V8UzyAorlYvOGx87ufGHehNTn5lCxrKtLyZ4Yl/wEKnNnr98ZzOwwDZV5ogw==}

  path-type@4.0.0:
    resolution: {integrity: sha512-gDKb8aZMDeD/tZWs9P6+q0J9Mwkdl6xMV8TjnGP3qJVJ06bdMgkbBlLU8IdfOsIsFz2BW1rNVT3XuNEl8zPAvw==}
    engines: {node: '>=8'}

  pathe@1.1.2:
    resolution: {integrity: sha512-whLdWMYL2TwI08hn8/ZqAbrVemu0LNaNNJZX73O6qaIdCTfXutsLhMkjdENX0qhsQ9uIimo4/aQOmXkoon2nDQ==}

  pathval@2.0.0:
    resolution: {integrity: sha512-vE7JKRyES09KiunauX7nd2Q9/L7lhok4smP9RZTDeD4MVs72Dp2qNFVz39Nz5a0FVEW0BJR6C0DYrq6unoziZA==}
    engines: {node: '>= 14.16'}

  picocolors@1.0.1:
    resolution: {integrity: sha512-anP1Z8qwhkbmu7MFP5iTt+wQKXgwzf7zTyGlcdzabySa9vd0Xt392U0rVmz9poOaBj0uHJKyyo9/upk0HrEQew==}

  picocolors@1.1.1:
    resolution: {integrity: sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==}

  picomatch@2.3.1:
    resolution: {integrity: sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==}
    engines: {node: '>=8.6'}

  picomatch@4.0.1:
    resolution: {integrity: sha512-xUXwsxNjwTQ8K3GnT4pCJm+xq3RUPQbmkYJTP5aFIfNIvbcc/4MUxgBaaRSZJ6yGJZiGSyYlM6MzwTsRk8SYCg==}
    engines: {node: '>=12'}

  picomatch@4.0.2:
    resolution: {integrity: sha512-M7BAV6Rlcy5u+m6oPhAPFgJTzAioX/6B0DxyvDlo9l8+T3nLKbrczg2WLUyzd45L8RqfUMyGPzekbMvX2Ldkwg==}
    engines: {node: '>=12'}

  pidtree@0.6.0:
    resolution: {integrity: sha512-eG2dWTVw5bzqGRztnHExczNxt5VGsE6OwTeCG3fdUf9KBsZzO3R5OIIIzWR+iZA0NtZ+RDVdaoE2dK1cn6jH4g==}
    engines: {node: '>=0.10'}
    hasBin: true

  pify@4.0.1:
    resolution: {integrity: sha512-uB80kBFb/tfd68bVleG9T5GGsGPjJrLAUpR5PZIrhBnIaRTQRjqdJSsIKkOP6OAIFbj7GOrcudc5pNjZ+geV2g==}
    engines: {node: '>=6'}

  pino-abstract-transport@1.2.0:
    resolution: {integrity: sha512-Guhh8EZfPCfH+PMXAb6rKOjGQEoy0xlAIn+irODG5kgfYV+BQ0rGYYWTIel3P5mmyXqkYkPmdIkywsn6QKUR1Q==}

  pino-std-serializers@7.0.0:
    resolution: {integrity: sha512-e906FRY0+tV27iq4juKzSYPbUj2do2X2JX4EzSca1631EB2QJQUqGbDuERal7LCtOpxl6x3+nvo9NPZcmjkiFA==}

  pino@9.3.1:
    resolution: {integrity: sha512-afSfrq/hUiW/MFmQcLEwV9Zh8Ry6MrMTOyBU53o/fc0gEl+1OZ/Fks/xQCM2nOC0C/OfDtQMnT2d8c3kpcfSzA==}
    hasBin: true

  pirates@4.0.6:
    resolution: {integrity: sha512-saLsH7WeYYPiD25LDuLRRY/i+6HaPYr6G1OUlN39otzkSTxKnubR9RTxS3/Kk50s1g2JTgFwWQDQyplC5/SHZg==}
    engines: {node: '>= 6'}

  pkg-dir@4.2.0:
    resolution: {integrity: sha512-HRDzbaKjC+AOWVXxAU/x54COGeIv9eb+6CkDSQoNTt4XyWoIJvuPsXizxu/Fr23EiekbtZwmh1IcIG/l/a10GQ==}
    engines: {node: '>=8'}

  pluralize@8.0.0:
    resolution: {integrity: sha512-Nc3IT5yHzflTfbjgqWcCPpo7DaKy4FnpB0l/zCAW0Tc7jxAiuqSxHasntB3D7887LSrA93kDJ9IXovxJYxyLCA==}
    engines: {node: '>=4'}

  postcss-load-config@6.0.1:
    resolution: {integrity: sha512-oPtTM4oerL+UXmx+93ytZVN82RrlY/wPUV8IeDxFrzIjXOLF1pN+EmKPLbubvKHT2HC20xXsCAH2Z+CKV6Oz/g==}
    engines: {node: '>= 18'}
    peerDependencies:
      jiti: '>=1.21.0'
      postcss: '>=8.0.9'
      tsx: ^4.8.1
      yaml: ^2.4.2
    peerDependenciesMeta:
      jiti:
        optional: true
      postcss:
        optional: true
      tsx:
        optional: true
      yaml:
        optional: true

  postcss@8.5.2:
    resolution: {integrity: sha512-MjOadfU3Ys9KYoX0AdkBlFEF1Vx37uCCeN4ZHnmwm9FfpbsGWMZeBLMmmpY+6Ocqod7mkdZ0DT31OlbsFrLlkA==}
    engines: {node: ^10 || ^12 || >=14}

  preferred-pm@3.1.4:
    resolution: {integrity: sha512-lEHd+yEm22jXdCphDrkvIJQU66EuLojPPtvZkpKIkiD+l0DMThF/niqZKJSoU8Vl7iuvtmzyMhir9LdVy5WMnA==}
    engines: {node: '>=10'}

  prelude-ls@1.2.1:
    resolution: {integrity: sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==}
    engines: {node: '>= 0.8.0'}

  prettier@2.8.8:
    resolution: {integrity: sha512-tdN8qQGvNjw4CHbY+XXk0JgCXn9QiF21a55rBe5LJAU+kDyC4WQn4+awm2Xfk2lQMk5fKup9XgzTZtGkjBdP9Q==}
    engines: {node: '>=10.13.0'}
    hasBin: true

  prettier@3.4.2:
    resolution: {integrity: sha512-e9MewbtFo+Fevyuxn/4rrcDAaq0IYxPGLvObpQjiZBMAzB9IGmzlnG9RZy3FFas+eBMu2vA0CszMeduow5dIuQ==}
    engines: {node: '>=14'}
    hasBin: true

  process-warning@3.0.0:
    resolution: {integrity: sha512-mqn0kFRl0EoqhnL0GQ0veqFHyIN1yig9RHh/InzORTUiZHFRAur+aMtRkELNwGs9aNwKS6tg/An4NYBPGwvtzQ==}

  process@0.11.10:
    resolution: {integrity: sha512-cdGef/drWFoydD1JsMzuFf8100nZl+GT+yacc2bEced5f9Rjk4z+WtFUTBu9PhOi9j/jfmBPu0mMEY4wIdAF8A==}
    engines: {node: '>= 0.6.0'}

  proxy-addr@2.0.7:
    resolution: {integrity: sha512-llQsMLSUDUPT44jdrU/O37qlnifitDP+ZwrmmZcoSKyLKvtZxpyV0n2/bD/N4tBAAZ/gJEdZU7KMraoK1+XYAg==}
    engines: {node: '>= 0.10'}

  proxy-from-env@1.1.0:
    resolution: {integrity: sha512-D+zkORCbA9f1tdWRK0RaCR3GPv50cMxcrz4X8k5LTSUD1Dkw47mKJEZQNunItRTkWwgtaUSo1RVFRIG9ZXiFYg==}

  pseudomap@1.0.2:
    resolution: {integrity: sha512-b/YwNhb8lk1Zz2+bXXpS/LK9OisiZZ1SNsSLxN1x2OXVEhW2Ckr/7mWE5vrC1ZTiJlD9g19jWszTmJsB+oEpFQ==}

  punycode@2.3.1:
    resolution: {integrity: sha512-vYt7UD1U9Wg6138shLtLOvdAu+8DsC/ilFtEVHcH+wydcSpNE20AfSOduf6MkRFahL5FY7X1oU7nKVZFtfq8Fg==}
    engines: {node: '>=6'}

  qs@6.12.3:
    resolution: {integrity: sha512-AWJm14H1vVaO/iNZ4/hO+HyaTehuy9nRqVdkTqlJt0HWvBiBIEXFmb4C0DGeYo3Xes9rrEW+TxHsaigCbN5ICQ==}
    engines: {node: '>=0.6'}

  queue-microtask@1.2.3:
    resolution: {integrity: sha512-NuaNSa6flKT5JaSYQzJok04JzTL1CA6aGhv5rfLW3PgqA+M2ChpZQnAC8h8i4ZFkBS8X5RqkDBHA7r4hej3K9A==}

  quick-format-unescaped@4.0.4:
    resolution: {integrity: sha512-tYC1Q1hgyRuHgloV/YXs2w15unPVh8qfu/qCTfhTYamaw7fyhumKa2yGpdSo87vY32rIclj+4fWYQXUMs9EHvg==}

  quick-lru@5.1.1:
    resolution: {integrity: sha512-WuyALRjWPDGtt/wzJiadO5AXY+8hZ80hVpe6MyivgraREW751X3SbhRvG3eLKOYN+8VEvqLcf3wdnt44Z4S4SA==}
    engines: {node: '>=10'}

  railroad-diagrams@1.0.0:
    resolution: {integrity: sha512-cz93DjNeLY0idrCNOH6PviZGRN9GJhsdm9hpn1YCS879fj4W+x5IFJhhkRZcwVgMmFF7R82UA/7Oh+R8lLZg6A==}

  randexp@0.4.6:
    resolution: {integrity: sha512-80WNmd9DA0tmZrw9qQa62GPPWfuXJknrmVmLcxvq4uZBdYqb1wYoKTmnlGUchvVWe0XiLupYkBoXVOxz3C8DYQ==}
    engines: {node: '>=0.12'}

  randombytes@2.1.0:
    resolution: {integrity: sha512-vYl3iOX+4CKUWuxGi9Ukhie6fsqXqS9FE2Zaic4tNFD2N2QQaXOMFbuKK4QmDHC0JO6B1Zp41J0LpT0oR68amQ==}

  read-yaml-file@1.1.0:
    resolution: {integrity: sha512-VIMnQi/Z4HT2Fxuwg5KrY174U1VdUIASQVWXXyqtNRtxSr9IYkn1rsI6Tb6HsrHCmB7gVpNwX6JxPTHcH6IoTA==}
    engines: {node: '>=6'}

  readable-stream@3.6.2:
    resolution: {integrity: sha512-9u/sniCrY3D5WdsERHzHE4G2YCXqoG5FTHUiCC4SIbr6XcLZBY05ya9EKjYek9O5xOAwjGq+1JdGBAS7Q9ScoA==}
    engines: {node: '>= 6'}

  readable-stream@4.5.2:
    resolution: {integrity: sha512-yjavECdqeZ3GLXNgRXgeQEdz9fvDDkNKyHnbHRFtOr7/LcfgBcmct7t/ET+HaCTqfh06OzoAxrkN/IfjJBVe+g==}
    engines: {node: ^12.22.0 || ^14.17.0 || >=16.0.0}

  readdirp@3.6.0:
    resolution: {integrity: sha512-hOS089on8RduqdbhvQ5Z37A0ESjsqz6qnRcffsMU3495FuTdqSm+7bhJ29JvIOsBDEEnan5DPu9t3To9VRlMzA==}
    engines: {node: '>=8.10.0'}

  readdirp@4.0.2:
    resolution: {integrity: sha512-yDMz9g+VaZkqBYS/ozoBJwaBhTbZo3UNYQHNRw1D3UFQB8oHB4uS/tAODO+ZLjGWmUbKnIlOWO+aaIiAxrUWHA==}
    engines: {node: '>= 14.16.0'}

  real-require@0.2.0:
    resolution: {integrity: sha512-57frrGM/OCTLqLOAh0mhVA9VBMHd+9U7Zb2THMGdBUoZVOtGbJzjxsYGDJ3A9AYYCP4hn6y1TVbaOfzWtm5GFg==}
    engines: {node: '>= 12.13.0'}

  reflect-metadata@0.2.2:
    resolution: {integrity: sha512-urBwgfrvVP/eAyXx4hluJivBKzuEbSQs9rKWCrCkbSxNv8mxPcUZKeuoF3Uy4mJl3Lwprp6yy5/39VWigZ4K6Q==}

  regenerator-runtime@0.14.1:
    resolution: {integrity: sha512-dYnhHh0nJoMfnkZs6GmmhFknAGRrLznOu5nc9ML+EJxGvrx6H7teuevqVqCuPcPK//3eDrrjQhehXVx9cnkGdw==}

  relative@3.0.2:
    resolution: {integrity: sha512-Q5W2qeYtY9GbiR8z1yHNZ1DGhyjb4AnLEjt8iE6XfcC1QIu+FAtj3HQaO0wH28H1mX6cqNLvAqWhP402dxJGyA==}
    engines: {node: '>= 0.8.0'}

  repeat-string@1.6.1:
    resolution: {integrity: sha512-PV0dzCYDNfRi1jCDbJzpW7jNNDRuCOG/jI5ctQcGKt/clZD+YcPS3yIlWuTJMmESC8aevCFmWJy5wjAFgNqN6w==}
    engines: {node: '>=0.10'}

  require-from-string@2.0.2:
    resolution: {integrity: sha512-Xf0nWe6RseziFMu+Ap9biiUbmplq6S9/p+7w7YXP/JBHhrUDDUhwa+vANyubuqfZWTveU//DYVGsDG7RKL/vEw==}
    engines: {node: '>=0.10.0'}

  resolve-from@4.0.0:
    resolution: {integrity: sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==}
    engines: {node: '>=4'}

  resolve-from@5.0.0:
    resolution: {integrity: sha512-qYg9KP24dD5qka9J47d0aVky0N+b4fTU89LN9iDnjB5waksiC49rvMB0PrUJQGoTmH50XPiqOvAjDfaijGxYZw==}
    engines: {node: '>=8'}

  resolve-pkg-maps@1.0.0:
    resolution: {integrity: sha512-seS2Tj26TBVOC2NIc2rOe2y2ZO7efxITtLZcGSOnHHNOQ7CkiUBfw0Iw2ck6xkIhPwLhKNLS8BO+hEpngQlqzw==}

  restore-cursor@3.1.0:
    resolution: {integrity: sha512-l+sSefzHpj5qimhFSE5a8nufZYAM3sBSVMAPtYkmC+4EH2anSGaEMXSD0izRQbu9nfyQ9y5JrVmp7E8oZrUjvA==}
    engines: {node: '>=8'}

  restore-cursor@5.1.0:
    resolution: {integrity: sha512-oMA2dcrw6u0YfxJQXm342bFKX/E4sG9rbTzO9ptUcR/e8A33cHuvStiYOwH7fszkZlZ1z/ta9AAoPk2F4qIOHA==}
    engines: {node: '>=18'}

  ret@0.1.15:
    resolution: {integrity: sha512-TTlYpa+OL+vMMNG24xSlQGEJ3B/RzEfUlLct7b5G/ytav+wPrplCpVMFuwzXbkecJrb6IYo1iFb0S9v37754mg==}
    engines: {node: '>=0.12'}

  ret@0.4.3:
    resolution: {integrity: sha512-0f4Memo5QP7WQyUEAYUO3esD/XjOc3Zjjg5CPsAq1p8sIu0XPeMbHJemKA0BO7tV0X7+A0FoEpbmHXWxPyD3wQ==}
    engines: {node: '>=10'}

  reusify@1.0.4:
    resolution: {integrity: sha512-U9nH88a3fc/ekCF1l0/UP1IosiuIjyTh7hBvXVMHYgVcfGvt897Xguj2UOLDeI5BG2m7/uwyaLVT6fbtCwTyzw==}
    engines: {iojs: '>=1.0.0', node: '>=0.10.0'}

  rfdc@1.4.1:
    resolution: {integrity: sha512-q1b3N5QkRUWUl7iyylaaj3kOpIT0N2i9MqIEQXP73GVsN9cw3fdx8X63cEmWhJGi2PPCF23Ijp7ktmd39rawIA==}

  rimraf@3.0.2:
    resolution: {integrity: sha512-JZkJMZkAGFFPP2YqXZXPbMlMBgsxzE8ILs4lMIX/2o0L9UBw9O/Y3o6wFw/i9YLapcUJWwqbi3kdxIPdC62TIA==}
    deprecated: Rimraf versions prior to v4 are no longer supported
    hasBin: true

  ripemd160@2.0.2:
    resolution: {integrity: sha512-ii4iagi25WusVoiC4B4lq7pbXfAp3D9v5CwfkY33vffw2+pkDjY1D8GaN7spsxvCSx8dkPqOZCEZyfxcmJG2IA==}

  rollup@4.30.0:
    resolution: {integrity: sha512-sDnr1pcjTgUT69qBksNF1N1anwfbyYG6TBQ22b03bII8EdiUQ7J0TlozVaTMjT/eEJAO49e1ndV7t+UZfL1+vA==}
    engines: {node: '>=18.0.0', npm: '>=8.0.0'}
    hasBin: true

  rollup@4.34.7:
    resolution: {integrity: sha512-8qhyN0oZ4x0H6wmBgfKxJtxM7qS98YJ0k0kNh5ECVtuchIJ7z9IVVvzpmtQyT10PXKMtBxYr1wQ5Apg8RS8kXQ==}
    engines: {node: '>=18.0.0', npm: '>=8.0.0'}
    hasBin: true

  run-async@2.4.1:
    resolution: {integrity: sha512-tvVnVv01b8c1RrA6Ep7JkStj85Guv/YrMcwqYQnwjsAS2cTmmPGBBjAjpCW7RrSodNSoE2/qg9O4bceNvUuDgQ==}
    engines: {node: '>=0.12.0'}

  run-async@3.0.0:
    resolution: {integrity: sha512-540WwVDOMxA6dN6We19EcT9sc3hkXPw5mzRNGM3FkdN/vtE9NFvj5lFAPNwUDmJjXidm3v7TC1cTE7t17Ulm1Q==}
    engines: {node: '>=0.12.0'}

  run-parallel@1.2.0:
    resolution: {integrity: sha512-5l4VyZR86LZ/lDxZTR6jqL8AFE2S0IFLMP26AbjsLVADxHdhB/c0GUsH+y39UfCi3dzz8OlQuPmnaJOMoDHQBA==}

  rxjs@7.8.1:
    resolution: {integrity: sha512-AA3TVj+0A2iuIoQkWEK/tqFjBq2j+6PO6Y0zJcvzLAFhEFIO3HL0vls9hWLncZbAAbK0mar7oZ4V079I/qPMxg==}

  safe-buffer@5.2.1:
    resolution: {integrity: sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==}

  safe-regex2@3.1.0:
    resolution: {integrity: sha512-RAAZAGbap2kBfbVhvmnTFv73NWLMvDGOITFYTZBAaY8eR+Ir4ef7Up/e7amo+y1+AH+3PtLkrt9mvcTsG9LXug==}

  safe-stable-stringify@2.4.3:
    resolution: {integrity: sha512-e2bDA2WJT0wxseVd4lsDP4+3ONX6HpMXQa1ZhFQ7SU+GjvORCmShbCMltrtIDfkYhVHrOcPtj+KhmDBdPdZD1g==}
    engines: {node: '>=10'}

  safer-buffer@2.1.2:
    resolution: {integrity: sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg==}

  schema-utils@3.3.0:
    resolution: {integrity: sha512-pN/yOAvcC+5rQ5nERGuwrjLlYvLTbCibnZ1I7B1LaiAz9BRBlE9GMgE/eqV30P7aJQUf7Ddimy/RsbYO/GrVGg==}
    engines: {node: '>= 10.13.0'}

  scrypt-js@3.0.1:
    resolution: {integrity: sha512-cdwTTnqPu0Hyvf5in5asVdZocVDTNRmR7XEcJuIzMjJeSHybHl7vpB66AzwTaIg6CLSbtjcxc8fqcySfnTkccA==}

  secure-json-parse@2.7.0:
    resolution: {integrity: sha512-6aU+Rwsezw7VR8/nyvKTx8QpWH9FrcYiXXlqC4z5d5XQBDRqtbfsRjnwGyqbi3gddNtWHuEk9OANUotL26qKUw==}

  semver@7.6.3:
    resolution: {integrity: sha512-oVekP1cKtI+CTDvHWYFUcMtsK/00wmAEfyqKfNdARm8u1wNVhSgaX7A8d4UuIlUI5e84iEwOhs7ZPYRmzU9U6A==}
    engines: {node: '>=10'}
    hasBin: true

  serialize-javascript@6.0.2:
    resolution: {integrity: sha512-Saa1xPByTTq2gdeFZYLLo+RFE35NHZkAbqZeWNd3BpzppeVisAqpDjcp8dyf6uIvEqJRd46jemmyA4iFIeVk8g==}

  set-cookie-parser@2.6.0:
    resolution: {integrity: sha512-RVnVQxTXuerk653XfuliOxBP81Sf0+qfQE73LIYKcyMYHG94AuH0kgrQpRDuTZnSmjpysHmzxJXKNfa6PjFhyQ==}

  set-function-length@1.2.2:
    resolution: {integrity: sha512-pgRc4hJ4/sNjWCSS9AmnS40x3bNMDTknHgL5UaMBTMyJnU90EgWh1Rz+MC9eFu4BuN/UwZjKQuY/1v3rM7HMfg==}
    engines: {node: '>= 0.4'}

  sha.js@2.4.11:
    resolution: {integrity: sha512-QMEp5B7cftE7APOjk5Y6xgrbWu+WkLVQwk8JNjZ8nKRciZaByEW6MubieAiToS7+dwvrjGhH8jRXz3MVd0AYqQ==}
    hasBin: true

  sha3@2.1.4:
    resolution: {integrity: sha512-S8cNxbyb0UGUM2VhRD4Poe5N58gJnJsLJ5vC7FYWGUmGhcsj4++WaIOBFVDxlG0W3To6xBuiRh+i0Qp2oNCOtg==}

  shebang-command@1.2.0:
    resolution: {integrity: sha512-EV3L1+UQWGor21OmnvojK36mhg+TyIKDh3iFBKBohr5xeXIhNBcx8oWdgkTEEQ+BEFFYdLRuqMfd5L84N1V5Vg==}
    engines: {node: '>=0.10.0'}

  shebang-command@2.0.0:
    resolution: {integrity: sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==}
    engines: {node: '>=8'}

  shebang-regex@1.0.0:
    resolution: {integrity: sha512-wpoSFAxys6b2a2wHZ1XpDSgD7N9iVjg29Ph9uV/uaP9Ex/KXlkTZTeddxDPSYQpgvzKLGJke2UU0AzoGCjNIvQ==}
    engines: {node: '>=0.10.0'}

  shebang-regex@3.0.0:
    resolution: {integrity: sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==}
    engines: {node: '>=8'}

  side-channel@1.0.6:
    resolution: {integrity: sha512-fDW/EZ6Q9RiO8eFG8Hj+7u/oW+XrPTIChwCOM2+th2A6OblDtYYIpve9m+KvI9Z4C9qSEXlaGR6bTEYHReuglA==}
    engines: {node: '>= 0.4'}

  siginfo@2.0.0:
    resolution: {integrity: sha512-ybx0WO1/8bSBLEWXZvEd7gMW3Sn3JFlW3TvX1nREbDLRNQNaeNN8WK0meBwPdAaOI7TtRRRJn/Es1zhrrCHu7g==}

  signal-exit@3.0.7:
    resolution: {integrity: sha512-wnD2ZE+l+SPC/uoS0vXeE9L1+0wuaMqKlfz9AMUo38JsyLSBWSFcHR1Rri62LZc12vLr1gb3jl7iwQhgwpAbGQ==}

  signal-exit@4.1.0:
    resolution: {integrity: sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==}
    engines: {node: '>=14'}

  slash@3.0.0:
    resolution: {integrity: sha512-g9Q1haeby36OSStwb4ntCGGGaKsaVSjQ68fBxoQcutl5fS1vuY18H3wSt3jFyFtrkx+Kz0V1G85A4MyAdDMi2Q==}
    engines: {node: '>=8'}

  slice-ansi@5.0.0:
    resolution: {integrity: sha512-FC+lgizVPfie0kkhqUScwRu1O/lF6NOgJmlCgK+/LYxDCTk8sGelYaHDhFcDN+Sn3Cv+3VSa4Byeo+IMCzpMgQ==}
    engines: {node: '>=12'}

  slice-ansi@7.1.0:
    resolution: {integrity: sha512-bSiSngZ/jWeX93BqeIAbImyTbEihizcwNjFoRUIY/T1wWQsfsm2Vw1agPKylXvQTU7iASGdHhyqRlqQzfz+Htg==}
    engines: {node: '>=18'}

  snake-case@3.0.4:
    resolution: {integrity: sha512-LAOh4z89bGQvl9pFfNF8V146i7o7/CqFPbqzYgP+yYzDIDeS9HaNFtXABamRW+AQzEVODcvE79ljJ+8a9YSdMg==}

  snakecase-keys@8.0.1:
    resolution: {integrity: sha512-Sj51kE1zC7zh6TDlNNz0/Jn1n5HiHdoQErxO8jLtnyrkJW/M5PrI7x05uDgY3BO7OUQYKCvmeMurW6BPUdwEOw==}
    engines: {node: '>=18'}

  sonic-boom@4.0.1:
    resolution: {integrity: sha512-hTSD/6JMLyT4r9zeof6UtuBDpjJ9sO08/nmS5djaA9eozT9oOlNdpXSnzcgj4FTqpk3nkLrs61l4gip9r1HCrQ==}

  source-map-js@1.2.0:
    resolution: {integrity: sha512-itJW8lvSA0TXEphiRoawsCksnlf8SyvmFzIhltqAHluXd88pkCd+cXJVHTDwdCr0IzwptSm035IHQktUu1QUMg==}
    engines: {node: '>=0.10.0'}

  source-map-js@1.2.1:
    resolution: {integrity: sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==}
    engines: {node: '>=0.10.0'}

  source-map-support@0.5.21:
    resolution: {integrity: sha512-uBHU3L3czsIyYXKX88fdrGovxdSCoTGDRZ6SYXtSRxLZUzHg5P/66Ht6uoUlHu9EZod+inXhKo3qQgwXUT/y1w==}

  source-map@0.6.1:
    resolution: {integrity: sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==}
    engines: {node: '>=0.10.0'}

  source-map@0.7.4:
    resolution: {integrity: sha512-l3BikUxvPOcn5E74dZiq5BGsTb5yEwhaTSzccU6t4sDOH8NWJCstKO5QT2CvtFoK6F0saL7p9xHAqHOlCPJygA==}
    engines: {node: '>= 8'}

  source-map@0.8.0-beta.0:
    resolution: {integrity: sha512-2ymg6oRBpebeZi9UUNsgQ89bhx01TcTkmNTGnNO88imTmbSgy4nfujrgVEFKWpMTEGA11EDkTt7mqObTPdigIA==}
    engines: {node: '>= 8'}

  spawndamnit@2.0.0:
    resolution: {integrity: sha512-j4JKEcncSjFlqIwU5L/rp2N5SIPsdxaRsIv678+TZxZ0SRDJTm8JrxJMjE/XuiEZNEir3S8l0Fa3Ke339WI4qA==}

  split2@4.2.0:
    resolution: {integrity: sha512-UcjcJOWknrNkF6PLX83qcHM6KHgVKNkV62Y8a5uYDVv9ydGQVwAHMKqHdJje1VTWpljG0WYpCDhrCdAOYH4TWg==}
    engines: {node: '>= 10.x'}

  sprintf-js@1.0.3:
    resolution: {integrity: sha512-D9cPgkvLlV3t3IzL0D0YLvGA9Ahk4PcvVwUbN0dSGr1aP0Nrt4AEnTUbuGvquEC0mA64Gqt1fzirlRs5ibXx8g==}

  stackback@0.0.2:
    resolution: {integrity: sha512-1XMJE5fQo1jGH6Y/7ebnwPOBEkIEnT4QF32d5R1+VXdXveM0IBMJt8zfaxX1P3QhVwrYe+576+jkANtSS2mBbw==}

  std-env@3.7.0:
    resolution: {integrity: sha512-JPbdCEQLj1w5GilpiHAx3qJvFndqybBysA3qUOnznweH4QbNYUsW/ea8QzSrnh0vNsezMMw5bcVool8lM0gwzg==}

  std-env@3.8.0:
    resolution: {integrity: sha512-Bc3YwwCB+OzldMxOXJIIvC6cPRWr/LxOp48CdQTOkPyk/t4JWWJbrilwBd7RJzKV8QW7tJkcgAmeuLLJugl5/w==}

  string-argv@0.3.2:
    resolution: {integrity: sha512-aqD2Q0144Z+/RqG52NeHEkZauTAUWJO8c6yTftGJKO3Tja5tUgIfmIl6kExvhtxSDP7fXB6DvzkfMpCd/F3G+Q==}
    engines: {node: '>=0.6.19'}

  string-width@4.2.3:
    resolution: {integrity: sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==}
    engines: {node: '>=8'}

  string-width@5.1.2:
    resolution: {integrity: sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==}
    engines: {node: '>=12'}

  string-width@7.2.0:
    resolution: {integrity: sha512-tsaTIkKW9b4N+AEj+SVA+WhJzV7/zMhcSu78mLKWSk7cXMOSHsBKFWUs0fWwq8QyK3MgJBQRX6Gbi4kYbdvGkQ==}
    engines: {node: '>=18'}

  string_decoder@1.3.0:
    resolution: {integrity: sha512-hkRX8U1WjJFd8LsDJ2yQ/wWWxaopEsABU1XfkM8A+j0+85JAGppt16cr1Whg6KIbb4okU6Mql6BOj+uup/wKeA==}

  strip-ansi@6.0.1:
    resolution: {integrity: sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==}
    engines: {node: '>=8'}

  strip-ansi@7.1.0:
    resolution: {integrity: sha512-iq6eVVI64nQQTRYq2KtEg2d2uU7LElhTJwsH4YzIHZshxlgZms/wIc4VoDQTlG/IvVIrBKG06CrZnp0qv7hkcQ==}
    engines: {node: '>=12'}

  strip-bom@3.0.0:
    resolution: {integrity: sha512-vavAMRXOgBVNF6nyEEmL3DBK19iRpDcoIwW+swQ+CbGiu7lju6t+JklA1MHweoWtadgt4ISVUsXLyDq34ddcwA==}
    engines: {node: '>=4'}

  strip-final-newline@3.0.0:
    resolution: {integrity: sha512-dOESqjYr96iWYylGObzd39EuNTa5VJxyvVAEm5Jnh7KGo75V43Hk1odPQkNDyXNmUR6k+gEiDVXnjB8HJ3crXw==}
    engines: {node: '>=12'}

  strip-json-comments@3.1.1:
    resolution: {integrity: sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==}
    engines: {node: '>=8'}

  sucrase@3.35.0:
    resolution: {integrity: sha512-8EbVDiu9iN/nESwxeSxDKe0dunta1GOlHufmSSXxMD2z2/tMZpDMpvXQGsc+ajGo8y2uYUmixaSRUc/QPoQ0GA==}
    engines: {node: '>=16 || 14 >=14.17'}
    hasBin: true

  superagent@8.1.2:
    resolution: {integrity: sha512-6WTxW1EB6yCxV5VFOIPQruWGHqc3yI7hEmZK6h+pyk69Lk/Ut7rLUY6W/ONF2MjBuGjvmMiIpsrVJ2vjrHlslA==}
    engines: {node: '>=6.4.0 <13 || >=14'}
    deprecated: Please upgrade to v9.0.0+ as we have fixed a public vulnerability with formidable dependency. Note that v9.0.0+ requires Node.js v14.18.0+. See https://github.com/ladjs/superagent/pull/1800 for insight. This project is supported and maintained by the team at Forward Email @ https://forwardemail.net

  supertest@6.3.4:
    resolution: {integrity: sha512-erY3HFDG0dPnhw4U+udPfrzXa4xhSG+n4rxfRuZWCUvjFWwKl+OxWf/7zk50s84/fAAs7vf5QAb9uRa0cCykxw==}
    engines: {node: '>=6.4.0'}

  supports-color@5.5.0:
    resolution: {integrity: sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==}
    engines: {node: '>=4'}

  supports-color@7.2.0:
    resolution: {integrity: sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==}
    engines: {node: '>=8'}

  supports-color@8.1.1:
    resolution: {integrity: sha512-MpUEN2OodtUzxvKQl72cUF7RQ5EiHsGvSsVG0ia9c5RbWGL2CI4C7EpPS8UTBIplnlzZiNuV56w+FuNxy3ty2Q==}
    engines: {node: '>=10'}

  symbol-observable@4.0.0:
    resolution: {integrity: sha512-b19dMThMV4HVFynSAM1++gBHAbk2Tc/osgLIBZMKsyqh34jb2e8Os7T6ZW/Bt3pJFdBTd2JwAnAAEQV7rSNvcQ==}
    engines: {node: '>=0.10'}

  tapable@2.2.1:
    resolution: {integrity: sha512-GNzQvQTOIP6RyTfE2Qxb8ZVlNmw0n88vp1szwWRimP02mnTsx3Wtn5qRdqY9w2XduFNUgvOwhNnQsjwCp+kqaQ==}
    engines: {node: '>=6'}

  term-size@2.2.1:
    resolution: {integrity: sha512-wK0Ri4fOGjv/XPy8SBHZChl8CM7uMc5VML7SqiQ0zG7+J5Vr+RMQDoHa2CNT6KHUnTGIXH34UDMkPzAUyapBZg==}
    engines: {node: '>=8'}

  terser-webpack-plugin@5.3.10:
    resolution: {integrity: sha512-BKFPWlPDndPs+NGGCr1U59t0XScL5317Y0UReNrHaw9/FwhPENlq6bfgs+4yPfyP51vqC1bQ4rp1EfXW5ZSH9w==}
    engines: {node: '>= 10.13.0'}
    peerDependencies:
      '@swc/core': '*'
      esbuild: '*'
      uglify-js: '*'
      webpack: ^5.1.0
    peerDependenciesMeta:
      '@swc/core':
        optional: true
      esbuild:
        optional: true
      uglify-js:
        optional: true

  terser@5.31.3:
    resolution: {integrity: sha512-pAfYn3NIZLyZpa83ZKigvj6Rn9c/vd5KfYGX7cN1mnzqgDcxWvrU5ZtAfIKhEXz9nRecw4z3LXkjaq96/qZqAA==}
    engines: {node: '>=10'}
    hasBin: true

  test-exclude@7.0.1:
    resolution: {integrity: sha512-pFYqmTw68LXVjeWJMST4+borgQP2AyMNbg1BpZh9LbyhUeNkeaPF9gzfPGUAnSMV3qPYdWUwDIjjCLiSDOl7vg==}
    engines: {node: '>=18'}

  text-table@0.2.0:
    resolution: {integrity: sha512-N+8UisAXDGk8PFXP4HAzVR9nbfmVJ3zYLAWiTIoqC5v5isinhr+r5uaO8+7r3BMfuNIufIsA7RdpVgacC2cSpw==}

  thenify-all@1.6.0:
    resolution: {integrity: sha512-RNxQH/qI8/t3thXJDwcstUO4zeqo64+Uy/+sNVRBx4Xn2OX+OZ9oP+iJnNFqplFra2ZUVeKCSa2oVWi3T4uVmA==}
    engines: {node: '>=0.8'}

  thenify@3.3.1:
    resolution: {integrity: sha512-RVZSIV5IG10Hk3enotrhvz0T9em6cyHBLkH/YAZuKqd8hRkKhSfCGIcP2KUY0EPxndzANBmNllzWPwak+bheSw==}

  thread-stream@3.1.0:
    resolution: {integrity: sha512-OqyPZ9u96VohAyMfJykzmivOrY2wfMSf3C5TtFJVgN+Hm6aj+voFhlK+kZEIv2FBh1X6Xp3DlnCOfEQ3B2J86A==}

  through@2.3.8:
    resolution: {integrity: sha512-w89qg7PI8wAdvX60bMDP+bFoD5Dvhm9oLheFp5O4a2QF0cSBGsBX4qZmadPMvVqlLJBBci+WqGGOAPvcDeNSVg==}

  tinybench@2.9.0:
    resolution: {integrity: sha512-0+DUvqWMValLmha6lr4kD8iAMK1HzV0/aKnCtWb9v9641TnP/MFb7Pc2bxoxQjTXAErryXVgUOfv2YqNllqGeg==}

  tinyexec@0.3.2:
    resolution: {integrity: sha512-KQQR9yN7R5+OSwaK0XQoj22pwHoTlgYqmUscPYoknOoWCWfj/5/ABTMRi69FrKU5ffPVh5QcFikpWJI/P1ocHA==}

  tinyglobby@0.2.10:
    resolution: {integrity: sha512-Zc+8eJlFMvgatPZTl6A9L/yht8QqdmUNtURHaKZLmKBE12hNPSrqNkUp2cs3M/UKmNVVAMFQYSjYIVHDjW5zew==}
    engines: {node: '>=12.0.0'}

  tinypool@1.0.2:
    resolution: {integrity: sha512-al6n+QEANGFOMf/dmUMsuS5/r9B06uwlyNjZZql/zv8J7ybHCgoihBNORZCY2mzUuAnomQa2JdhyHKzZxPCrFA==}
    engines: {node: ^18.0.0 || >=20.0.0}

  tinyrainbow@1.2.0:
    resolution: {integrity: sha512-weEDEq7Z5eTHPDh4xjX789+fHfF+P8boiFB+0vbWzpbnbsEr/GRaohi/uMKxg8RZMXnl1ItAi/IUHWMsjDV7kQ==}
    engines: {node: '>=14.0.0'}

  tinyspy@3.0.2:
    resolution: {integrity: sha512-n1cw8k1k0x4pgA2+9XrOkFydTerNcJ1zWCO5Nn9scWHTD+5tp8dghT2x1uduQePZTZgd3Tupf+x9BxJjeJi77Q==}
    engines: {node: '>=14.0.0'}

  tmp@0.0.33:
    resolution: {integrity: sha512-jRCJlojKnZ3addtTOjdIqoRuPEKBvNXcGYqzO6zWZX8KfKEpnGY5jfggJQ3EjKuu8D4bJRr0y+cYJFmYbImXGw==}
    engines: {node: '>=0.6.0'}

  to-fast-properties@2.0.0:
    resolution: {integrity: sha512-/OaKK0xYrs3DmxRYqL/yDc+FxFUVYhDlXMhRmv3z915w2HF1tnN1omB354j8VUGO/hbRzyD6Y3sA7v7GS/ceog==}
    engines: {node: '>=4'}

  to-regex-range@5.0.1:
    resolution: {integrity: sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==}
    engines: {node: '>=8.0'}

  toad-cache@3.7.0:
    resolution: {integrity: sha512-/m8M+2BJUpoJdgAHoG+baCwBT+tf2VraSfkBgl0Y00qIWt41DJ8R5B8nsEw0I58YwF5IZH6z24/2TobDKnqSWw==}
    engines: {node: '>=12'}

  tr46@0.0.3:
    resolution: {integrity: sha512-N3WMsuqV66lT30CrXNbEjx4GEwlow3v6rr4mCcv6prnfwhS01rkgyFdjPNBYd9br7LpXV1+Emh01fHnq2Gdgrw==}

  tr46@1.0.1:
    resolution: {integrity: sha512-dTpowEjclQ7Kgx5SdBkqRzVhERQXov8/l9Ft9dVM9fmg0W0KQSVaXX9T4i6twCPNtYiZM53lpSSUAwJbFPOHxA==}

  tree-kill@1.2.2:
    resolution: {integrity: sha512-L0Orpi8qGpRG//Nd+H90vFB+3iHnue1zSSGmNOOCh1GLJ7rUKVwV2HvijphGQS2UmhUZewS9VgvxYIdgr+fG1A==}
    hasBin: true

  ts-api-utils@1.3.0:
    resolution: {integrity: sha512-UQMIo7pb8WRomKR1/+MFVLTroIvDVtMX3K6OUir8ynLyzB8Jeriont2bTAtmNPa1ekAgN7YPDyf6V+ygrdU+eQ==}
    engines: {node: '>=16'}
    peerDependencies:
      typescript: '>=4.2.0'

  ts-interface-checker@0.1.13:
    resolution: {integrity: sha512-Y/arvbn+rrz3JCKl9C4kVNfTfSm2/mEp5FSz5EsZSANGPSlQrpRI5M4PKF+mJnE52jOO90PnPSc3Ur3bTQw0gA==}

  ts-loader@9.5.1:
    resolution: {integrity: sha512-rNH3sK9kGZcH9dYzC7CewQm4NtxJTjSEVRJ2DyBZR7f8/wcta+iV44UPCXc5+nzDzivKtlzV6c9P4e+oFhDLYg==}
    engines: {node: '>=12.0.0'}
    peerDependencies:
      typescript: '*'
      webpack: ^5.0.0

  ts-node@10.9.2:
    resolution: {integrity: sha512-f0FFpIdcHgn8zcPSbf1dRevwt047YMnaiJM3u2w2RewrB+fob/zePZcrOyQoLMMO7aBIddLcQIEK5dYjkLnGrQ==}
    hasBin: true
    peerDependencies:
      '@swc/core': '>=1.2.50'
      '@swc/wasm': '>=1.2.50'
      '@types/node': '*'
      typescript: '>=2.7'
    peerDependenciesMeta:
      '@swc/core':
        optional: true
      '@swc/wasm':
        optional: true

  tsconfig-paths-webpack-plugin@4.1.0:
    resolution: {integrity: sha512-xWFISjviPydmtmgeUAuXp4N1fky+VCtfhOkDUFIv5ea7p4wuTomI4QTrXvFBX2S4jZsmyTSrStQl+E+4w+RzxA==}
    engines: {node: '>=10.13.0'}

  tsconfig-paths@4.2.0:
    resolution: {integrity: sha512-NoZ4roiN7LnbKn9QqE1amc9DJfzvZXxF4xDavcOWt1BPkdx+m+0gJuPM+S0vCe7zTJMYUP0R8pO2XMr+Y8oLIg==}
    engines: {node: '>=6'}

  tslib@2.3.1:
    resolution: {integrity: sha512-77EbyPPpMz+FRFRuAFlWMtmgUWGe9UOG2Z25NqCwiIjRhOf5iKGuzSe5P2w1laq+FkRy4p+PCuVkJSGkzTEKVw==}

  tslib@2.6.3:
    resolution: {integrity: sha512-xNvxJEOUiWPGhUuUdQgAJPKOOJfGnIyKySOc09XkKsgdUV/3E2zvwZYdejjmRgPCgcym1juLH3226yA7sEFJKQ==}

  tsup@8.3.5:
    resolution: {integrity: sha512-Tunf6r6m6tnZsG9GYWndg0z8dEV7fD733VBFzFJ5Vcm1FtlXB8xBD/rtrBi2a3YKEV7hHtxiZtW5EAVADoe1pA==}
    engines: {node: '>=18'}
    hasBin: true
    peerDependencies:
      '@microsoft/api-extractor': ^7.36.0
      '@swc/core': ^1
      postcss: ^8.4.12
      typescript: '>=4.5.0'
    peerDependenciesMeta:
      '@microsoft/api-extractor':
        optional: true
      '@swc/core':
        optional: true
      postcss:
        optional: true
      typescript:
        optional: true

  tsx@4.16.3:
    resolution: {integrity: sha512-MP8AEUxVnboD2rCC6kDLxnpDBNWN9k3BSVU/0/nNxgm70bPBnfn+yCKcnOsIVPQwdkbKYoFOlKjjWZWJ2XCXUg==}
    engines: {node: '>=18.0.0'}
    hasBin: true

  type-check@0.4.0:
    resolution: {integrity: sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==}
    engines: {node: '>= 0.8.0'}

  type-fest@0.20.2:
    resolution: {integrity: sha512-Ne+eE4r0/iWnpAxD852z3A+N0Bt5RN//NjJwRd2VFHEmrywxf5vsZlh4R6lixl6B+wz/8d+maTSAkN1FIkI3LQ==}
    engines: {node: '>=10'}

  type-fest@0.21.3:
    resolution: {integrity: sha512-t0rzBq87m3fVcduHDUFhKmyyX+9eo6WQjZvf51Ea/M0Q7+T374Jp1aUiyUl0GKxp8M/OETVHSDvmkyPgvX+X2w==}
    engines: {node: '>=10'}

  type-fest@1.4.0:
    resolution: {integrity: sha512-yGSza74xk0UG8k+pLh5oeoYirvIiWo5t0/o3zHHAO2tRDiZcxWP7fywNlXhqb6/r6sWvwi+RsyQMWhVLe4BVuA==}
    engines: {node: '>=10'}

  type-fest@4.24.0:
    resolution: {integrity: sha512-spAaHzc6qre0TlZQQ2aA/nGMe+2Z/wyGk5Z+Ru2VUfdNwT6kWO6TjevOlpebsATEG1EIQ2sOiDszud3lO5mt/Q==}
    engines: {node: '>=16'}

  typeforce@1.18.0:
    resolution: {integrity: sha512-7uc1O8h1M1g0rArakJdf0uLRSSgFcYexrVoKo+bzJd32gd4gDy2L/Z+8/FjPnU9ydY3pEnVPtr9FyscYY60K1g==}

  typescript@5.3.3:
    resolution: {integrity: sha512-pXWcraxM0uxAS+tN0AG/BF2TyqmHO014Z070UsJ+pFvYuRSq8KH8DmWpnbXe0pEPDHXZV3FcAbJkijJ5oNEnWw==}
    engines: {node: '>=14.17'}
    hasBin: true

  typescript@5.4.3:
    resolution: {integrity: sha512-KrPd3PKaCLr78MalgiwJnA25Nm8HAmdwN3mYUYZgG/wizIo9EainNVQI9/yDavtVFRN2h3k8uf3GLHuhDMgEHg==}
    engines: {node: '>=14.17'}
    hasBin: true

  typescript@5.5.3:
    resolution: {integrity: sha512-/hreyEujaB0w76zKo6717l3L0o/qEUtRgdvUBvlkhoWeOVMjMuHNHk0BRBzikzuGDqNmPQbg5ifMEqsHLiIUcQ==}
    engines: {node: '>=14.17'}
    hasBin: true

  uid@2.0.2:
    resolution: {integrity: sha512-u3xV3X7uzvi5b1MncmZo3i2Aw222Zk1keqLA1YkHldREkAhAqi65wuPfe7lHx8H/Wzy+8CE7S7uS3jekIM5s8g==}
    engines: {node: '>=8'}

  undici-types@5.26.5:
    resolution: {integrity: sha512-JlCMO+ehdEIKqlFxk6IfVoAUVmgz7cU7zD/h9XZ0qzeosSHmUJVOzSQvvYSYWXkFXC+IfLKSIffhv0sVZup6pA==}

  universalify@0.1.2:
    resolution: {integrity: sha512-rBJeI5CXAlmy1pV+617WB9J63U6XcazHHF2f2dbJix4XzpUF0RS3Zbj0FGIOCAva5P/d/GBOYaACQ1w+0azUkg==}
    engines: {node: '>= 4.0.0'}

  universalify@2.0.1:
    resolution: {integrity: sha512-gptHNQghINnc/vTGIk0SOFGFNXw7JVrlRUtConJRlvaw6DuX0wO5Jeko9sWrMBhh+PsYAZ7oXAiOnf/UKogyiw==}
    engines: {node: '>= 10.0.0'}

  unplugin-swc@1.5.1:
    resolution: {integrity: sha512-/ZLrPNjChhGx3Z95pxJ4tQgfI6rWqukgYHKflrNB4zAV1izOQuDhkTn55JWeivpBxDCoK7M/TStb2aS/14PS/g==}
    peerDependencies:
      '@swc/core': ^1.2.108

  unplugin@1.12.1:
    resolution: {integrity: sha512-aXEH9c5qi3uYZHo0niUtxDlT9ylG/luMW/dZslSCkbtC31wCyFkmM0kyoBBh+Grhn7CL+/kvKLfN61/EdxPxMQ==}
    engines: {node: '>=14.0.0'}

  update-browserslist-db@1.1.0:
    resolution: {integrity: sha512-EdRAaAyk2cUE1wOf2DkEhzxqOQvFOoRJFNS6NeyJ01Gp2beMRpBAINjM2iDXE3KCuKhwnvHIQCJm6ThL2Z+HzQ==}
    hasBin: true
    peerDependencies:
      browserslist: '>= 4.21.0'

  uri-js@4.4.1:
    resolution: {integrity: sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==}

  util-deprecate@1.0.2:
    resolution: {integrity: sha512-EPD5q1uXyFxJpCrLnCc1nHnq3gOa6DZBocAIiI2TaSCA7VCJ1UJDMagCzIkXNsUYfD1daK//LTEQ8xiIbrHtcw==}

  uuid@8.3.2:
    resolution: {integrity: sha512-+NYs2QeMWy+GWFOEm9xnn6HCDp0l7QBD7ml8zLUmJ+93Q5NF0NocErnwkTkXVFNiX3/fpC6afS8Dhb/gz7R7eg==}
    hasBin: true

  v8-compile-cache-lib@3.0.1:
    resolution: {integrity: sha512-wa7YjyUGfNZngI/vtK0UHAN+lgDCxBPCylVXGp0zu59Fz5aiGtNXaq3DhIov063MorB+VfufLh3JlF2KdTK3xg==}

  varuint-bitcoin@1.1.2:
    resolution: {integrity: sha512-4EVb+w4rx+YfVM32HQX42AbbT7/1f5zwAYhIujKXKk8NQK+JfRVl3pqT3hjNn/L+RstigmGGKVwHA/P0wgITZw==}

  vite-node@2.1.9:
    resolution: {integrity: sha512-AM9aQ/IPrW/6ENLQg3AGY4K1N2TGZdR5e4gu/MmmR2xR3Ll1+dib+nook92g4TV3PXVyeyxdWwtaCAiUL0hMxA==}
    engines: {node: ^18.0.0 || >=20.0.0}
    hasBin: true

  vite@5.4.14:
    resolution: {integrity: sha512-EK5cY7Q1D8JNhSaPKVK4pwBFvaTmZxEnoKXLG/U9gmdDcihQGNzFlgIvaxezFR4glP1LsuiedwMBqCXH3wZccA==}
    engines: {node: ^18.0.0 || >=20.0.0}
    hasBin: true
    peerDependencies:
      '@types/node': ^18.0.0 || >=20.0.0
      less: '*'
      lightningcss: ^1.21.0
      sass: '*'
      sass-embedded: '*'
      stylus: '*'
      sugarss: '*'
      terser: ^5.4.0
    peerDependenciesMeta:
      '@types/node':
        optional: true
      less:
        optional: true
      lightningcss:
        optional: true
      sass:
        optional: true
      sass-embedded:
        optional: true
      stylus:
        optional: true
      sugarss:
        optional: true
      terser:
        optional: true

  vitest@2.1.9:
    resolution: {integrity: sha512-MSmPM9REYqDGBI8439mA4mWhV5sKmDlBKWIYbA3lRb2PTHACE0mgKwA8yQ2xq9vxDTuk4iPrECBAEW2aoFXY0Q==}
    engines: {node: ^18.0.0 || >=20.0.0}
    hasBin: true
    peerDependencies:
      '@edge-runtime/vm': '*'
      '@types/node': ^18.0.0 || >=20.0.0
      '@vitest/browser': 2.1.9
      '@vitest/ui': 2.1.9
      happy-dom: '*'
      jsdom: '*'
    peerDependenciesMeta:
      '@edge-runtime/vm':
        optional: true
      '@types/node':
        optional: true
      '@vitest/browser':
        optional: true
      '@vitest/ui':
        optional: true
      happy-dom:
        optional: true
      jsdom:
        optional: true

  watchpack@2.4.1:
    resolution: {integrity: sha512-8wrBCMtVhqcXP2Sup1ctSkga6uc2Bx0IIvKyT7yTFier5AXHooSI+QyQQAtTb7+E0IUCCKyTFmXqdqgum2XWGg==}
    engines: {node: '>=10.13.0'}

  wcwidth@1.0.1:
    resolution: {integrity: sha512-XHPEwS0q6TaxcvG85+8EYkbiCux2XtWG2mkc47Ng2A77BQu9+DqIOJldST4HgPkuea7dvKSj5VgX3P1d4rW8Tg==}

  webidl-conversions@3.0.1:
    resolution: {integrity: sha512-2JAn3z8AR6rjK8Sm8orRC0h/bcl/DqL7tRPdGZ4I1CjdF+EaMLmYxBHyXuKL849eucPFhvBoxMsflfOb8kxaeQ==}

  webidl-conversions@4.0.2:
    resolution: {integrity: sha512-YQ+BmxuTgd6UXZW3+ICGfyqRyHXVlD5GtQr5+qjiNW7bF0cqrzX500HVXPBOvgXb5YnzDd+h0zqyv61KUD7+Sg==}

  webpack-node-externals@3.0.0:
    resolution: {integrity: sha512-LnL6Z3GGDPht/AigwRh2dvL9PQPFQ8skEpVrWZXLWBYmqcaojHNN0onvHzie6rq7EWKrrBfPYqNEzTJgiwEQDQ==}
    engines: {node: '>=6'}

  webpack-sources@3.2.3:
    resolution: {integrity: sha512-/DyMEOrDgLKKIG0fmvtz+4dUX/3Ghozwgm6iPp8KRhvn+eQf9+Q7GWxVNMk3+uCPWfdXYC4ExGBckIXdFEfH1w==}
    engines: {node: '>=10.13.0'}

  webpack-virtual-modules@0.6.2:
    resolution: {integrity: sha512-66/V2i5hQanC51vBQKPH4aI8NMAcBW59FVBs+rC7eGHupMyfn34q7rZIE+ETlJ+XTevqfUhVVBgSUNSW2flEUQ==}

  webpack@5.92.1:
    resolution: {integrity: sha512-JECQ7IwJb+7fgUFBlrJzbyu3GEuNBcdqr1LD7IbSzwkSmIevTm8PF+wej3Oxuz/JFBUZ6O1o43zsPkwm1C4TmA==}
    engines: {node: '>=10.13.0'}
    hasBin: true
    peerDependencies:
      webpack-cli: '*'
    peerDependenciesMeta:
      webpack-cli:
        optional: true

  whatwg-url@5.0.0:
    resolution: {integrity: sha512-saE57nupxk6v3HY35+jzBwYa0rKSy0XR8JSxZPwgLr7ys0IBzhGviA1/TUGJLmSVqs8pb9AnvICXEuOHLprYTw==}

  whatwg-url@7.1.0:
    resolution: {integrity: sha512-WUu7Rg1DroM7oQvGWfOiAK21n74Gg+T4elXEQYkOhtyLeWiJFoOGLXPKI/9gzIie9CtwVLm8wtw6YJdKyxSjeg==}

  which-pm@2.2.0:
    resolution: {integrity: sha512-MOiaDbA5ZZgUjkeMWM5EkJp4loW5ZRoa5bc3/aeMox/PJelMhE6t7S/mLuiY43DBupyxH+S0U1bTui9kWUlmsw==}
    engines: {node: '>=8.15'}

  which@1.3.1:
    resolution: {integrity: sha512-HxJdYWq1MTIQbJ3nw0cqssHoTNU267KlrDuGZ1WYlxDStUtKUhOaJmh112/TZmHxxUfuJqPXSOm7tDyas0OSIQ==}
    hasBin: true

  which@2.0.2:
    resolution: {integrity: sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==}
    engines: {node: '>= 8'}
    hasBin: true

  why-is-node-running@2.3.0:
    resolution: {integrity: sha512-hUrmaWBdVDcxvYqnyh09zunKzROWjbZTiNy8dBEjkS7ehEDQibXJ7XvlmtbwuTclUiIyN+CyXQD4Vmko8fNm8w==}
    engines: {node: '>=8'}
    hasBin: true

  wif@2.0.6:
    resolution: {integrity: sha512-HIanZn1zmduSF+BQhkE+YXIbEiH0xPr1012QbFEGB0xsKqJii0/SqJjyn8dFv6y36kOznMgMB+LGcbZTJ1xACQ==}

  word-wrap@1.2.5:
    resolution: {integrity: sha512-BN22B5eaMMI9UMtjrGd5g5eCYPpCPDUy0FJXbYsaT5zYxjFOckS53SQDE3pWkVoWpHXVb3BrYcEN4Twa55B5cA==}
    engines: {node: '>=0.10.0'}

  wrap-ansi@6.2.0:
    resolution: {integrity: sha512-r6lPcBGxZXlIcymEu7InxDMhdW0KDxpLgoFLcguasxCaJ/SOIZwINatK9KY/tf+ZrlywOKU0UDj3ATXUBfxJXA==}
    engines: {node: '>=8'}

  wrap-ansi@7.0.0:
    resolution: {integrity: sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==}
    engines: {node: '>=10'}

  wrap-ansi@8.1.0:
    resolution: {integrity: sha512-si7QWI6zUMq56bESFvagtmzMdGOtoxfR+Sez11Mobfc7tm+VkUckk9bW2UeffTGVUbOksxmSw0AA2gs8g71NCQ==}
    engines: {node: '>=12'}

  wrap-ansi@9.0.0:
    resolution: {integrity: sha512-G8ura3S+3Z2G+mkgNRq8dqaFZAuxfsxpBB8OCTGRTCtp+l/v9nbFNmCUP1BZMts3G1142MsZfn6eeUKrr4PD1Q==}
    engines: {node: '>=18'}

  wrappy@1.0.2:
    resolution: {integrity: sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==}

  yallist@2.1.2:
    resolution: {integrity: sha512-ncTzHV7NvsQZkYe1DW7cbDLm0YpzHmZF5r/iyP3ZnQtMiJ+pjzisCiMNI+Sj+xQF5pXhSHxSB3uDbsBTzY/c2A==}

  yaml@2.6.1:
    resolution: {integrity: sha512-7r0XPzioN/Q9kXBro/XPnA6kznR73DHq+GXh5ON7ZozRO6aMjbmiBuKste2wslTFkC5d1dw0GooOCepZXJ2SAg==}
    engines: {node: '>= 14'}
    hasBin: true

  yargs-parser@21.1.1:
    resolution: {integrity: sha512-tVpsJW7DdjecAiFpbIB1e3qxIQsE6NoPc5/eTdrbbIC4h0LVsWhnoa3g+m2HclBIujHzsxZ4VJVA+GUuc2/LBw==}
    engines: {node: '>=12'}

  yn@3.1.1:
    resolution: {integrity: sha512-Ux4ygGWsu2c7isFWe8Yu1YluJmqVhxqK2cLXNQA5AcC3QfbGNpM7fu0Y8b/z16pXLnFxZYvWhd3fhBY9DLmC6Q==}
    engines: {node: '>=6'}

  yocto-queue@0.1.0:
    resolution: {integrity: sha512-rVksvsnNCdJ/ohGc6xgPwyN8eheCxsiLM8mxuE/t/mOVqJewPuO1miLpTHQiRgTKCLexL4MeAFVagts7HmNZ2Q==}
    engines: {node: '>=10'}

  zod@3.23.8:
    resolution: {integrity: sha512-XBx9AXhXktjUqnepgTiE5flcKIYWi/rme0Eaj+5Y0lftuGBq+jyRu/md4WnuxqgP1ubdpNCsYEYPxrzVHD8d6g==}

  zx@8.1.4:
    resolution: {integrity: sha512-QFDYYpnzdpRiJ3dL2102Cw26FpXpWshW4QLTGxiYfIcwdAqg084jRCkK/kuP/NOSkxOjydRwNFG81qzA5r1a6w==}
    engines: {node: '>= 12.17.0'}
    hasBin: true

snapshots:

  '@ampproject/remapping@2.3.0':
    dependencies:
      '@jridgewell/gen-mapping': 0.3.5
      '@jridgewell/trace-mapping': 0.3.25

  '@angular-devkit/core@17.3.8(chokidar@3.6.0)':
    dependencies:
      ajv: 8.12.0
      ajv-formats: 2.1.1(ajv@8.12.0)
      jsonc-parser: 3.2.1
      picomatch: 4.0.1
      rxjs: 7.8.1
      source-map: 0.7.4
    optionalDependencies:
      chokidar: 3.6.0

  '@angular-devkit/schematics-cli@17.3.8(chokidar@3.6.0)':
    dependencies:
      '@angular-devkit/core': 17.3.8(chokidar@3.6.0)
      '@angular-devkit/schematics': 17.3.8(chokidar@3.6.0)
      ansi-colors: 4.1.3
      inquirer: 9.2.15
      symbol-observable: 4.0.0
      yargs-parser: 21.1.1
    transitivePeerDependencies:
      - chokidar

  '@angular-devkit/schematics@17.3.8(chokidar@3.6.0)':
    dependencies:
      '@angular-devkit/core': 17.3.8(chokidar@3.6.0)
      jsonc-parser: 3.2.1
      magic-string: 0.30.8
      ora: 5.4.1
      rxjs: 7.8.1
    transitivePeerDependencies:
      - chokidar

  '@babel/code-frame@7.24.7':
    dependencies:
      '@babel/highlight': 7.24.7
      picocolors: 1.0.1

  '@babel/helper-string-parser@7.24.8': {}

  '@babel/helper-validator-identifier@7.24.7': {}

  '@babel/highlight@7.24.7':
    dependencies:
      '@babel/helper-validator-identifier': 7.24.7
      chalk: 2.4.2
      js-tokens: 4.0.0
      picocolors: 1.0.1

  '@babel/parser@7.24.8':
    dependencies:
      '@babel/types': 7.24.9

  '@babel/runtime@7.24.8':
    dependencies:
      regenerator-runtime: 0.14.1

  '@babel/types@7.24.9':
    dependencies:
      '@babel/helper-string-parser': 7.24.8
      '@babel/helper-validator-identifier': 7.24.7
      to-fast-properties: 2.0.0

  '@bcoe/v8-coverage@0.2.3': {}

  '@bitcoinerlab/secp256k1@1.1.1':
    dependencies:
      '@noble/hashes': 1.4.0
      '@noble/secp256k1': 1.7.1

  '@changesets/apply-release-plan@7.0.4':
    dependencies:
      '@babel/runtime': 7.24.8
      '@changesets/config': 3.0.2
      '@changesets/get-version-range-type': 0.4.0
      '@changesets/git': 3.0.0
      '@changesets/should-skip-package': 0.1.0
      '@changesets/types': 6.0.0
      '@manypkg/get-packages': 1.1.3
      detect-indent: 6.1.0
      fs-extra: 7.0.1
      lodash.startcase: 4.4.0
      outdent: 0.5.0
      prettier: 2.8.8
      resolve-from: 5.0.0
      semver: 7.6.3

  '@changesets/assemble-release-plan@6.0.3':
    dependencies:
      '@babel/runtime': 7.24.8
      '@changesets/errors': 0.2.0
      '@changesets/get-dependents-graph': 2.1.1
      '@changesets/should-skip-package': 0.1.0
      '@changesets/types': 6.0.0
      '@manypkg/get-packages': 1.1.3
      semver: 7.6.3

  '@changesets/changelog-git@0.2.0':
    dependencies:
      '@changesets/types': 6.0.0

  '@changesets/cli@2.27.7':
    dependencies:
      '@babel/runtime': 7.24.8
      '@changesets/apply-release-plan': 7.0.4
      '@changesets/assemble-release-plan': 6.0.3
      '@changesets/changelog-git': 0.2.0
      '@changesets/config': 3.0.2
      '@changesets/errors': 0.2.0
      '@changesets/get-dependents-graph': 2.1.1
      '@changesets/get-release-plan': 4.0.3
      '@changesets/git': 3.0.0
      '@changesets/logger': 0.1.0
      '@changesets/pre': 2.0.0
      '@changesets/read': 0.6.0
      '@changesets/should-skip-package': 0.1.0
      '@changesets/types': 6.0.0
      '@changesets/write': 0.3.1
      '@manypkg/get-packages': 1.1.3
      '@types/semver': 7.5.8
      ansi-colors: 4.1.3
      chalk: 2.4.2
      ci-info: 3.9.0
      enquirer: 2.4.1
      external-editor: 3.1.0
      fs-extra: 7.0.1
      human-id: 1.0.2
      mri: 1.2.0
      outdent: 0.5.0
      p-limit: 2.3.0
      preferred-pm: 3.1.4
      resolve-from: 5.0.0
      semver: 7.6.3
      spawndamnit: 2.0.0
      term-size: 2.2.1

  '@changesets/config@3.0.2':
    dependencies:
      '@changesets/errors': 0.2.0
      '@changesets/get-dependents-graph': 2.1.1
      '@changesets/logger': 0.1.0
      '@changesets/types': 6.0.0
      '@manypkg/get-packages': 1.1.3
      fs-extra: 7.0.1
      micromatch: 4.0.7

  '@changesets/errors@0.2.0':
    dependencies:
      extendable-error: 0.1.7

  '@changesets/get-dependents-graph@2.1.1':
    dependencies:
      '@changesets/types': 6.0.0
      '@manypkg/get-packages': 1.1.3
      chalk: 2.4.2
      fs-extra: 7.0.1
      semver: 7.6.3

  '@changesets/get-github-info@0.6.0':
    dependencies:
      dataloader: 1.4.0
      node-fetch: 2.7.0
    transitivePeerDependencies:
      - encoding

  '@changesets/get-release-plan@4.0.3':
    dependencies:
      '@babel/runtime': 7.24.8
      '@changesets/assemble-release-plan': 6.0.3
      '@changesets/config': 3.0.2
      '@changesets/pre': 2.0.0
      '@changesets/read': 0.6.0
      '@changesets/types': 6.0.0
      '@manypkg/get-packages': 1.1.3

  '@changesets/get-version-range-type@0.4.0': {}

  '@changesets/git@3.0.0':
    dependencies:
      '@babel/runtime': 7.24.8
      '@changesets/errors': 0.2.0
      '@changesets/types': 6.0.0
      '@manypkg/get-packages': 1.1.3
      is-subdir: 1.2.0
      micromatch: 4.0.7
      spawndamnit: 2.0.0

  '@changesets/logger@0.1.0':
    dependencies:
      chalk: 2.4.2

  '@changesets/parse@0.4.0':
    dependencies:
      '@changesets/types': 6.0.0
      js-yaml: 3.14.1

  '@changesets/pre@2.0.0':
    dependencies:
      '@babel/runtime': 7.24.8
      '@changesets/errors': 0.2.0
      '@changesets/types': 6.0.0
      '@manypkg/get-packages': 1.1.3
      fs-extra: 7.0.1

  '@changesets/read@0.6.0':
    dependencies:
      '@babel/runtime': 7.24.8
      '@changesets/git': 3.0.0
      '@changesets/logger': 0.1.0
      '@changesets/parse': 0.4.0
      '@changesets/types': 6.0.0
      chalk: 2.4.2
      fs-extra: 7.0.1
      p-filter: 2.1.0

  '@changesets/should-skip-package@0.1.0':
    dependencies:
      '@babel/runtime': 7.24.8
      '@changesets/types': 6.0.0
      '@manypkg/get-packages': 1.1.3

  '@changesets/types@4.1.0': {}

  '@changesets/types@6.0.0': {}

  '@changesets/write@0.3.1':
    dependencies:
      '@babel/runtime': 7.24.8
      '@changesets/types': 6.0.0
      fs-extra: 7.0.1
      human-id: 1.0.2
      prettier: 2.8.8

  '@ckb-lumos/base@0.22.2':
    dependencies:
      '@ckb-lumos/bi': 0.22.2
      '@ckb-lumos/codec': 0.22.2
      '@ckb-lumos/toolkit': 0.22.2
      '@types/blake2b': 2.1.3
      '@types/lodash.isequal': 4.5.8
      blake2b: 2.1.4
      js-xxhash: 1.0.4
      lodash.isequal: 4.5.0

  '@ckb-lumos/base@0.23.0':
    dependencies:
      '@ckb-lumos/bi': 0.23.0
      '@ckb-lumos/codec': 0.23.0
      '@ckb-lumos/toolkit': 0.23.0
      '@types/blake2b': 2.1.3
      '@types/lodash.isequal': 4.5.8
      blake2b: 2.1.4
      js-xxhash: 1.0.4
      lodash.isequal: 4.5.0

  '@ckb-lumos/bi@0.0.0-canary-66bbbfd-20240805132534':
    dependencies:
      jsbi: 4.3.0

  '@ckb-lumos/bi@0.22.2':
    dependencies:
      jsbi: 4.3.0

  '@ckb-lumos/bi@0.23.0':
    dependencies:
      jsbi: 4.3.0

  '@ckb-lumos/ckb-indexer@0.23.0':
    dependencies:
      '@ckb-lumos/base': 0.23.0
      '@ckb-lumos/bi': 0.23.0
      '@ckb-lumos/codec': 0.23.0
      '@ckb-lumos/rpc': 0.23.0
      '@ckb-lumos/toolkit': 0.23.0
      cross-fetch: 3.2.0
      events: 3.3.0
    transitivePeerDependencies:
      - encoding

  '@ckb-lumos/codec@0.0.0-canary-66bbbfd-20240805132534':
    dependencies:
      '@ckb-lumos/bi': 0.0.0-canary-66bbbfd-20240805132534

  '@ckb-lumos/codec@0.22.2':
    dependencies:
      '@ckb-lumos/bi': 0.22.2

  '@ckb-lumos/codec@0.23.0':
    dependencies:
      '@ckb-lumos/bi': 0.23.0

  '@ckb-lumos/common-scripts@0.23.0':
    dependencies:
      '@ckb-lumos/base': 0.23.0
      '@ckb-lumos/bi': 0.23.0
      '@ckb-lumos/codec': 0.23.0
      '@ckb-lumos/config-manager': 0.23.0
      '@ckb-lumos/helpers': 0.23.0
      '@ckb-lumos/rpc': 0.23.0
      '@ckb-lumos/toolkit': 0.23.0
      bech32: 2.0.0
      bs58: 5.0.0
      immutable: 4.3.7
    transitivePeerDependencies:
      - encoding

  '@ckb-lumos/config-manager@0.23.0':
    dependencies:
      '@ckb-lumos/base': 0.23.0
      '@ckb-lumos/bi': 0.23.0
      '@ckb-lumos/codec': 0.23.0
      '@ckb-lumos/rpc': 0.23.0
      '@types/deep-freeze-strict': 1.1.2
      deep-freeze-strict: 1.1.1
    transitivePeerDependencies:
      - encoding

  '@ckb-lumos/hd@0.23.0':
    dependencies:
      '@ckb-lumos/base': 0.23.0
      '@ckb-lumos/bi': 0.23.0
      bn.js: 5.2.1
      elliptic: 6.6.1
      scrypt-js: 3.0.1
      sha3: 2.1.4
      uuid: 8.3.2

  '@ckb-lumos/helpers@0.23.0':
    dependencies:
      '@ckb-lumos/base': 0.23.0
      '@ckb-lumos/bi': 0.23.0
      '@ckb-lumos/codec': 0.23.0
      '@ckb-lumos/config-manager': 0.23.0
      '@ckb-lumos/toolkit': 0.23.0
      bech32: 2.0.0
      immutable: 4.3.7
    transitivePeerDependencies:
      - encoding

  '@ckb-lumos/light-client@0.23.0':
    dependencies:
      '@ckb-lumos/base': 0.23.0
      '@ckb-lumos/ckb-indexer': 0.23.0
      '@ckb-lumos/rpc': 0.23.0
      cross-fetch: 3.2.0
      events: 3.3.0
    transitivePeerDependencies:
      - encoding

  '@ckb-lumos/lumos@0.23.0':
    dependencies:
      '@ckb-lumos/base': 0.23.0
      '@ckb-lumos/bi': 0.23.0
      '@ckb-lumos/ckb-indexer': 0.23.0
      '@ckb-lumos/codec': 0.23.0
      '@ckb-lumos/common-scripts': 0.23.0
      '@ckb-lumos/config-manager': 0.23.0
      '@ckb-lumos/hd': 0.23.0
      '@ckb-lumos/helpers': 0.23.0
      '@ckb-lumos/light-client': 0.23.0
      '@ckb-lumos/rpc': 0.23.0
      '@ckb-lumos/toolkit': 0.23.0
      '@ckb-lumos/transaction-manager': 0.23.0
    transitivePeerDependencies:
      - encoding

  '@ckb-lumos/molecule@0.0.0-canary-66bbbfd-20240805132534':
    dependencies:
      '@ckb-lumos/bi': 0.0.0-canary-66bbbfd-20240805132534
      '@ckb-lumos/codec': 0.0.0-canary-66bbbfd-20240805132534
      '@types/moo': 0.5.9
      '@types/nearley': 2.11.5
      glob: 10.4.5
      minimist: 1.2.8
      moo: 0.5.2
      nearley: 2.20.1
      relative: 3.0.2

  '@ckb-lumos/rpc@0.23.0':
    dependencies:
      '@ckb-lumos/base': 0.23.0
      '@ckb-lumos/bi': 0.23.0
      abort-controller: 3.0.0
      cross-fetch: 3.2.0
    transitivePeerDependencies:
      - encoding

  '@ckb-lumos/toolkit@0.22.2':
    dependencies:
      '@ckb-lumos/bi': 0.22.2

  '@ckb-lumos/toolkit@0.23.0':
    dependencies:
      '@ckb-lumos/bi': 0.23.0

  '@ckb-lumos/transaction-manager@0.23.0':
    dependencies:
      '@ckb-lumos/base': 0.23.0
      '@ckb-lumos/ckb-indexer': 0.23.0
      '@ckb-lumos/codec': 0.23.0
      '@ckb-lumos/rpc': 0.23.0
      '@ckb-lumos/toolkit': 0.23.0
      immutable: 4.3.7
    transitivePeerDependencies:
      - encoding

  '@colors/colors@1.5.0':
    optional: true

  '@cspotcode/source-map-support@0.8.1':
    dependencies:
      '@jridgewell/trace-mapping': 0.3.9

  '@esbuild/aix-ppc64@0.21.5':
    optional: true

  '@esbuild/aix-ppc64@0.24.2':
    optional: true

  '@esbuild/android-arm64@0.21.5':
    optional: true

  '@esbuild/android-arm64@0.24.2':
    optional: true

  '@esbuild/android-arm@0.21.5':
    optional: true

  '@esbuild/android-arm@0.24.2':
    optional: true

  '@esbuild/android-x64@0.21.5':
    optional: true

  '@esbuild/android-x64@0.24.2':
    optional: true

  '@esbuild/darwin-arm64@0.21.5':
    optional: true

  '@esbuild/darwin-arm64@0.24.2':
    optional: true

  '@esbuild/darwin-x64@0.21.5':
    optional: true

  '@esbuild/darwin-x64@0.24.2':
    optional: true

  '@esbuild/freebsd-arm64@0.21.5':
    optional: true

  '@esbuild/freebsd-arm64@0.24.2':
    optional: true

  '@esbuild/freebsd-x64@0.21.5':
    optional: true

  '@esbuild/freebsd-x64@0.24.2':
    optional: true

  '@esbuild/linux-arm64@0.21.5':
    optional: true

  '@esbuild/linux-arm64@0.24.2':
    optional: true

  '@esbuild/linux-arm@0.21.5':
    optional: true

  '@esbuild/linux-arm@0.24.2':
    optional: true

  '@esbuild/linux-ia32@0.21.5':
    optional: true

  '@esbuild/linux-ia32@0.24.2':
    optional: true

  '@esbuild/linux-loong64@0.21.5':
    optional: true

  '@esbuild/linux-loong64@0.24.2':
    optional: true

  '@esbuild/linux-mips64el@0.21.5':
    optional: true

  '@esbuild/linux-mips64el@0.24.2':
    optional: true

  '@esbuild/linux-ppc64@0.21.5':
    optional: true

  '@esbuild/linux-ppc64@0.24.2':
    optional: true

  '@esbuild/linux-riscv64@0.21.5':
    optional: true

  '@esbuild/linux-riscv64@0.24.2':
    optional: true

  '@esbuild/linux-s390x@0.21.5':
    optional: true

  '@esbuild/linux-s390x@0.24.2':
    optional: true

  '@esbuild/linux-x64@0.21.5':
    optional: true

  '@esbuild/linux-x64@0.24.2':
    optional: true

  '@esbuild/netbsd-arm64@0.24.2':
    optional: true

  '@esbuild/netbsd-x64@0.21.5':
    optional: true

  '@esbuild/netbsd-x64@0.24.2':
    optional: true

  '@esbuild/openbsd-arm64@0.24.2':
    optional: true

  '@esbuild/openbsd-x64@0.21.5':
    optional: true

  '@esbuild/openbsd-x64@0.24.2':
    optional: true

  '@esbuild/sunos-x64@0.21.5':
    optional: true

  '@esbuild/sunos-x64@0.24.2':
    optional: true

  '@esbuild/win32-arm64@0.21.5':
    optional: true

  '@esbuild/win32-arm64@0.24.2':
    optional: true

  '@esbuild/win32-ia32@0.21.5':
    optional: true

  '@esbuild/win32-ia32@0.24.2':
    optional: true

  '@esbuild/win32-x64@0.21.5':
    optional: true

  '@esbuild/win32-x64@0.24.2':
    optional: true

  '@eslint-community/eslint-utils@4.4.0(eslint@8.57.0)':
    dependencies:
      eslint: 8.57.0
      eslint-visitor-keys: 3.4.3

  '@eslint-community/regexpp@4.11.0': {}

  '@eslint/eslintrc@2.1.4':
    dependencies:
      ajv: 6.12.6
      debug: 4.3.5
      espree: 9.6.1
      globals: 13.24.0
      ignore: 5.3.1
      import-fresh: 3.3.0
      js-yaml: 4.1.0
      minimatch: 3.1.2
      strip-json-comments: 3.1.1
    transitivePeerDependencies:
      - supports-color

  '@eslint/js@8.57.0': {}

  '@exact-realty/multipart-parser@1.0.14': {}

  '@fastify/ajv-compiler@3.6.0':
    dependencies:
      ajv: 8.17.1
      ajv-formats: 2.1.1(ajv@8.17.1)
      fast-uri: 2.4.0

  '@fastify/cors@9.0.1':
    dependencies:
      fastify-plugin: 4.5.1
      mnemonist: 0.39.6

  '@fastify/error@3.4.1': {}

  '@fastify/fast-json-stringify-compiler@4.3.0':
    dependencies:
      fast-json-stringify: 5.16.1

  '@fastify/formbody@7.4.0':
    dependencies:
      fast-querystring: 1.1.2
      fastify-plugin: 4.5.1

  '@fastify/merge-json-schemas@0.1.1':
    dependencies:
      fast-deep-equal: 3.1.3

  '@fastify/middie@8.3.1':
    dependencies:
      '@fastify/error': 3.4.1
      fastify-plugin: 4.5.1
      path-to-regexp: 6.2.2
      reusify: 1.0.4

  '@humanwhocodes/config-array@0.11.14':
    dependencies:
      '@humanwhocodes/object-schema': 2.0.3
      debug: 4.3.5
      minimatch: 3.1.2
    transitivePeerDependencies:
      - supports-color

  '@humanwhocodes/module-importer@1.0.1': {}

  '@humanwhocodes/object-schema@2.0.3': {}

  '@isaacs/cliui@8.0.2':
    dependencies:
      string-width: 5.1.2
      string-width-cjs: string-width@4.2.3
      strip-ansi: 7.1.0
      strip-ansi-cjs: strip-ansi@6.0.1
      wrap-ansi: 8.1.0
      wrap-ansi-cjs: wrap-ansi@7.0.0

  '@istanbuljs/schema@0.1.3': {}

  '@jridgewell/gen-mapping@0.3.5':
    dependencies:
      '@jridgewell/set-array': 1.2.1
      '@jridgewell/sourcemap-codec': 1.5.0
      '@jridgewell/trace-mapping': 0.3.25

  '@jridgewell/resolve-uri@3.1.2': {}

  '@jridgewell/set-array@1.2.1': {}

  '@jridgewell/source-map@0.3.6':
    dependencies:
      '@jridgewell/gen-mapping': 0.3.5
      '@jridgewell/trace-mapping': 0.3.25

  '@jridgewell/sourcemap-codec@1.5.0': {}

  '@jridgewell/trace-mapping@0.3.25':
    dependencies:
      '@jridgewell/resolve-uri': 3.1.2
      '@jridgewell/sourcemap-codec': 1.5.0

  '@jridgewell/trace-mapping@0.3.9':
    dependencies:
      '@jridgewell/resolve-uri': 3.1.2
      '@jridgewell/sourcemap-codec': 1.5.0

  '@ljharb/through@2.3.13':
    dependencies:
      call-bind: 1.0.7

  '@lukeed/csprng@1.1.0': {}

  '@manypkg/find-root@1.1.0':
    dependencies:
      '@babel/runtime': 7.24.8
      '@types/node': 12.20.55
      find-up: 4.1.0
      fs-extra: 8.1.0

  '@manypkg/get-packages@1.1.3':
    dependencies:
      '@babel/runtime': 7.24.8
      '@changesets/types': 4.1.0
      '@manypkg/find-root': 1.1.0
      fs-extra: 8.1.0
      globby: 11.1.0
      read-yaml-file: 1.1.0

  '@nervosnetwork/ckb-sdk-core@0.109.5':
    dependencies:
      '@nervosnetwork/ckb-sdk-rpc': 0.109.5
      '@nervosnetwork/ckb-sdk-utils': 0.109.5
      '@nervosnetwork/ckb-types': 0.109.5
      tslib: 2.3.1
    transitivePeerDependencies:
      - debug

  '@nervosnetwork/ckb-sdk-rpc@0.109.5':
    dependencies:
      '@nervosnetwork/ckb-sdk-utils': 0.109.5
      axios: 1.7.4
      tslib: 2.3.1
    transitivePeerDependencies:
      - debug

  '@nervosnetwork/ckb-sdk-utils@0.109.5':
    dependencies:
      '@nervosnetwork/ckb-types': 0.109.5
      bech32: 2.0.0
      elliptic: 6.6.1
      jsbi: 3.1.3
      tslib: 2.3.1

  '@nervosnetwork/ckb-types@0.109.5': {}

  '@nestjs/cli@10.4.2(@swc/core@1.7.11)(esbuild@0.24.2)':
    dependencies:
      '@angular-devkit/core': 17.3.8(chokidar@3.6.0)
      '@angular-devkit/schematics': 17.3.8(chokidar@3.6.0)
      '@angular-devkit/schematics-cli': 17.3.8(chokidar@3.6.0)
      '@nestjs/schematics': 10.1.2(chokidar@3.6.0)(typescript@5.3.3)
      chalk: 4.1.2
      chokidar: 3.6.0
      cli-table3: 0.6.5
      commander: 4.1.1
      fork-ts-checker-webpack-plugin: 9.0.2(typescript@5.3.3)(webpack@5.92.1(@swc/core@1.7.11)(esbuild@0.24.2))
      glob: 10.4.2
      inquirer: 8.2.6
      node-emoji: 1.11.0
      ora: 5.4.1
      tree-kill: 1.2.2
      tsconfig-paths: 4.2.0
      tsconfig-paths-webpack-plugin: 4.1.0
      typescript: 5.3.3
      webpack: 5.92.1(@swc/core@1.7.11)(esbuild@0.24.2)
      webpack-node-externals: 3.0.0
    optionalDependencies:
      '@swc/core': 1.7.11
    transitivePeerDependencies:
      - esbuild
      - uglify-js
      - webpack-cli

  '@nestjs/common@10.3.10(reflect-metadata@0.2.2)(rxjs@7.8.1)':
    dependencies:
      iterare: 1.2.1
      reflect-metadata: 0.2.2
      rxjs: 7.8.1
      tslib: 2.6.3
      uid: 2.0.2

  '@nestjs/config@3.2.3(@nestjs/common@10.3.10(reflect-metadata@0.2.2)(rxjs@7.8.1))(rxjs@7.8.1)':
    dependencies:
      '@nestjs/common': 10.3.10(reflect-metadata@0.2.2)(rxjs@7.8.1)
      dotenv: 16.4.5
      dotenv-expand: 10.0.0
      lodash: 4.17.21
      rxjs: 7.8.1

  '@nestjs/core@10.3.10(@nestjs/common@10.3.10(reflect-metadata@0.2.2)(rxjs@7.8.1))(reflect-metadata@0.2.2)(rxjs@7.8.1)':
    dependencies:
      '@nestjs/common': 10.3.10(reflect-metadata@0.2.2)(rxjs@7.8.1)
      '@nuxtjs/opencollective': 0.3.2
      fast-safe-stringify: 2.1.1
      iterare: 1.2.1
      path-to-regexp: 3.2.0
      reflect-metadata: 0.2.2
      rxjs: 7.8.1
      tslib: 2.6.3
      uid: 2.0.2
    transitivePeerDependencies:
      - encoding

  '@nestjs/platform-fastify@10.3.10(@nestjs/common@10.3.10(reflect-metadata@0.2.2)(rxjs@7.8.1))(@nestjs/core@10.3.10(@nestjs/common@10.3.10(reflect-metadata@0.2.2)(rxjs@7.8.1))(reflect-metadata@0.2.2)(rxjs@7.8.1))':
    dependencies:
      '@fastify/cors': 9.0.1
      '@fastify/formbody': 7.4.0
      '@fastify/middie': 8.3.1
      '@nestjs/common': 10.3.10(reflect-metadata@0.2.2)(rxjs@7.8.1)
      '@nestjs/core': 10.3.10(@nestjs/common@10.3.10(reflect-metadata@0.2.2)(rxjs@7.8.1))(reflect-metadata@0.2.2)(rxjs@7.8.1)
      fastify: 4.28.0
      light-my-request: 5.13.0
      path-to-regexp: 3.2.0
      tslib: 2.6.3

  '@nestjs/schematics@10.1.2(chokidar@3.6.0)(typescript@5.3.3)':
    dependencies:
      '@angular-devkit/core': 17.3.8(chokidar@3.6.0)
      '@angular-devkit/schematics': 17.3.8(chokidar@3.6.0)
      comment-json: 4.2.3
      jsonc-parser: 3.3.1
      pluralize: 8.0.0
      typescript: 5.3.3
    transitivePeerDependencies:
      - chokidar

  '@nestjs/schematics@10.1.2(chokidar@3.6.0)(typescript@5.5.3)':
    dependencies:
      '@angular-devkit/core': 17.3.8(chokidar@3.6.0)
      '@angular-devkit/schematics': 17.3.8(chokidar@3.6.0)
      comment-json: 4.2.3
      jsonc-parser: 3.3.1
      pluralize: 8.0.0
      typescript: 5.5.3
    transitivePeerDependencies:
      - chokidar

  '@nestjs/testing@10.3.10(@nestjs/common@10.3.10(reflect-metadata@0.2.2)(rxjs@7.8.1))(@nestjs/core@10.3.10(@nestjs/common@10.3.10(reflect-metadata@0.2.2)(rxjs@7.8.1))(reflect-metadata@0.2.2)(rxjs@7.8.1))':
    dependencies:
      '@nestjs/common': 10.3.10(reflect-metadata@0.2.2)(rxjs@7.8.1)
      '@nestjs/core': 10.3.10(@nestjs/common@10.3.10(reflect-metadata@0.2.2)(rxjs@7.8.1))(reflect-metadata@0.2.2)(rxjs@7.8.1)
      tslib: 2.6.3

  '@noble/hashes@1.4.0': {}

  '@noble/secp256k1@1.7.1': {}

  '@nodelib/fs.scandir@2.1.5':
    dependencies:
      '@nodelib/fs.stat': 2.0.5
      run-parallel: 1.2.0

  '@nodelib/fs.stat@2.0.5': {}

  '@nodelib/fs.walk@1.2.8':
    dependencies:
      '@nodelib/fs.scandir': 2.1.5
      fastq: 1.17.1

  '@nuxtjs/opencollective@0.3.2':
    dependencies:
      chalk: 4.1.2
      consola: 2.15.3
      node-fetch: 2.7.0
    transitivePeerDependencies:
      - encoding

  '@pkgjs/parseargs@0.11.0':
    optional: true

  '@rollup/pluginutils@5.1.0(rollup@4.34.7)':
    dependencies:
      '@types/estree': 1.0.5
      estree-walker: 2.0.2
      picomatch: 2.3.1
    optionalDependencies:
      rollup: 4.34.7

  '@rollup/rollup-android-arm-eabi@4.30.0':
    optional: true

  '@rollup/rollup-android-arm-eabi@4.34.7':
    optional: true

  '@rollup/rollup-android-arm64@4.30.0':
    optional: true

  '@rollup/rollup-android-arm64@4.34.7':
    optional: true

  '@rollup/rollup-darwin-arm64@4.30.0':
    optional: true

  '@rollup/rollup-darwin-arm64@4.34.7':
    optional: true

  '@rollup/rollup-darwin-x64@4.30.0':
    optional: true

  '@rollup/rollup-darwin-x64@4.34.7':
    optional: true

  '@rollup/rollup-freebsd-arm64@4.30.0':
    optional: true

  '@rollup/rollup-freebsd-arm64@4.34.7':
    optional: true

  '@rollup/rollup-freebsd-x64@4.30.0':
    optional: true

  '@rollup/rollup-freebsd-x64@4.34.7':
    optional: true

  '@rollup/rollup-linux-arm-gnueabihf@4.30.0':
    optional: true

  '@rollup/rollup-linux-arm-gnueabihf@4.34.7':
    optional: true

  '@rollup/rollup-linux-arm-musleabihf@4.30.0':
    optional: true

  '@rollup/rollup-linux-arm-musleabihf@4.34.7':
    optional: true

  '@rollup/rollup-linux-arm64-gnu@4.30.0':
    optional: true

  '@rollup/rollup-linux-arm64-gnu@4.34.7':
    optional: true

  '@rollup/rollup-linux-arm64-musl@4.30.0':
    optional: true

  '@rollup/rollup-linux-arm64-musl@4.34.7':
    optional: true

  '@rollup/rollup-linux-loongarch64-gnu@4.30.0':
    optional: true

  '@rollup/rollup-linux-loongarch64-gnu@4.34.7':
    optional: true

  '@rollup/rollup-linux-powerpc64le-gnu@4.30.0':
    optional: true

  '@rollup/rollup-linux-powerpc64le-gnu@4.34.7':
    optional: true

  '@rollup/rollup-linux-riscv64-gnu@4.30.0':
    optional: true

  '@rollup/rollup-linux-riscv64-gnu@4.34.7':
    optional: true

  '@rollup/rollup-linux-s390x-gnu@4.30.0':
    optional: true

  '@rollup/rollup-linux-s390x-gnu@4.34.7':
    optional: true

  '@rollup/rollup-linux-x64-gnu@4.30.0':
    optional: true

  '@rollup/rollup-linux-x64-gnu@4.34.7':
    optional: true

  '@rollup/rollup-linux-x64-musl@4.30.0':
    optional: true

  '@rollup/rollup-linux-x64-musl@4.34.7':
    optional: true

  '@rollup/rollup-win32-arm64-msvc@4.30.0':
    optional: true

  '@rollup/rollup-win32-arm64-msvc@4.34.7':
    optional: true

  '@rollup/rollup-win32-ia32-msvc@4.30.0':
    optional: true

  '@rollup/rollup-win32-ia32-msvc@4.34.7':
    optional: true

  '@rollup/rollup-win32-x64-msvc@4.30.0':
    optional: true

  '@rollup/rollup-win32-x64-msvc@4.34.7':
    optional: true

  '@scure/base@1.1.7': {}

  '@spore-sdk/core@0.2.0(@ckb-lumos/lumos@0.23.0)(lodash@4.17.21)':
    dependencies:
      '@ckb-lumos/lumos': 0.23.0
      lodash: 4.17.21

  '@swc/core-darwin-arm64@1.7.11':
    optional: true

  '@swc/core-darwin-x64@1.7.11':
    optional: true

  '@swc/core-linux-arm-gnueabihf@1.7.11':
    optional: true

  '@swc/core-linux-arm64-gnu@1.7.11':
    optional: true

  '@swc/core-linux-arm64-musl@1.7.11':
    optional: true

  '@swc/core-linux-x64-gnu@1.7.11':
    optional: true

  '@swc/core-linux-x64-musl@1.7.11':
    optional: true

  '@swc/core-win32-arm64-msvc@1.7.11':
    optional: true

  '@swc/core-win32-ia32-msvc@1.7.11':
    optional: true

  '@swc/core-win32-x64-msvc@1.7.11':
    optional: true

  '@swc/core@1.7.11':
    dependencies:
      '@swc/counter': 0.1.3
      '@swc/types': 0.1.12
    optionalDependencies:
      '@swc/core-darwin-arm64': 1.7.11
      '@swc/core-darwin-x64': 1.7.11
      '@swc/core-linux-arm-gnueabihf': 1.7.11
      '@swc/core-linux-arm64-gnu': 1.7.11
      '@swc/core-linux-arm64-musl': 1.7.11
      '@swc/core-linux-x64-gnu': 1.7.11
      '@swc/core-linux-x64-musl': 1.7.11
      '@swc/core-win32-arm64-msvc': 1.7.11
      '@swc/core-win32-ia32-msvc': 1.7.11
      '@swc/core-win32-x64-msvc': 1.7.11

  '@swc/counter@0.1.3': {}

  '@swc/types@0.1.12':
    dependencies:
      '@swc/counter': 0.1.3

  '@tsconfig/node10@1.0.11': {}

  '@tsconfig/node12@1.0.11': {}

  '@tsconfig/node14@1.0.3': {}

  '@tsconfig/node16@1.0.4': {}

  '@types/blake2b@2.1.3': {}

  '@types/cookiejar@2.1.5': {}

  '@types/deep-freeze-strict@1.1.2': {}

  '@types/dotenv@8.2.0':
    dependencies:
      dotenv: 16.4.5

  '@types/eslint-scope@3.7.7':
    dependencies:
      '@types/eslint': 8.56.10
      '@types/estree': 1.0.5

  '@types/eslint@8.56.10':
    dependencies:
      '@types/estree': 1.0.5
      '@types/json-schema': 7.0.15

  '@types/estree@1.0.5': {}

  '@types/estree@1.0.6': {}

  '@types/fs-extra@11.0.4':
    dependencies:
      '@types/jsonfile': 6.1.4
      '@types/node': 20.14.11
    optional: true

  '@types/json-schema@7.0.15': {}

  '@types/jsonfile@6.1.4':
    dependencies:
      '@types/node': 20.14.11
    optional: true

  '@types/lodash.isequal@4.5.8':
    dependencies:
      '@types/lodash': 4.17.7

  '@types/lodash@4.17.7': {}

  '@types/methods@1.1.4': {}

  '@types/moo@0.5.9': {}

  '@types/nearley@2.11.5': {}

  '@types/node@12.20.55': {}

  '@types/node@20.14.11':
    dependencies:
      undici-types: 5.26.5

  '@types/semver@7.5.8': {}

  '@types/superagent@8.1.7':
    dependencies:
      '@types/cookiejar': 2.1.5
      '@types/methods': 1.1.4
      '@types/node': 20.14.11

  '@types/supertest@6.0.2':
    dependencies:
      '@types/methods': 1.1.4
      '@types/superagent': 8.1.7

  '@typescript-eslint/eslint-plugin@7.16.1(@typescript-eslint/parser@7.16.1(eslint@8.57.0)(typescript@5.4.3))(eslint@8.57.0)(typescript@5.4.3)':
    dependencies:
      '@eslint-community/regexpp': 4.11.0
      '@typescript-eslint/parser': 7.16.1(eslint@8.57.0)(typescript@5.4.3)
      '@typescript-eslint/scope-manager': 7.16.1
      '@typescript-eslint/type-utils': 7.16.1(eslint@8.57.0)(typescript@5.4.3)
      '@typescript-eslint/utils': 7.16.1(eslint@8.57.0)(typescript@5.4.3)
      '@typescript-eslint/visitor-keys': 7.16.1
      eslint: 8.57.0
      graphemer: 1.4.0
      ignore: 5.3.1
      natural-compare: 1.4.0
      ts-api-utils: 1.3.0(typescript@5.4.3)
    optionalDependencies:
      typescript: 5.4.3
    transitivePeerDependencies:
      - supports-color

  '@typescript-eslint/parser@7.16.1(eslint@8.57.0)(typescript@5.4.3)':
    dependencies:
      '@typescript-eslint/scope-manager': 7.16.1
      '@typescript-eslint/types': 7.16.1
      '@typescript-eslint/typescript-estree': 7.16.1(typescript@5.4.3)
      '@typescript-eslint/visitor-keys': 7.16.1
      debug: 4.3.5
      eslint: 8.57.0
    optionalDependencies:
      typescript: 5.4.3
    transitivePeerDependencies:
      - supports-color

  '@typescript-eslint/scope-manager@7.16.1':
    dependencies:
      '@typescript-eslint/types': 7.16.1
      '@typescript-eslint/visitor-keys': 7.16.1

  '@typescript-eslint/type-utils@7.16.1(eslint@8.57.0)(typescript@5.4.3)':
    dependencies:
      '@typescript-eslint/typescript-estree': 7.16.1(typescript@5.4.3)
      '@typescript-eslint/utils': 7.16.1(eslint@8.57.0)(typescript@5.4.3)
      debug: 4.4.0
      eslint: 8.57.0
      ts-api-utils: 1.3.0(typescript@5.4.3)
    optionalDependencies:
      typescript: 5.4.3
    transitivePeerDependencies:
      - supports-color

  '@typescript-eslint/types@7.16.1': {}

  '@typescript-eslint/typescript-estree@7.16.1(typescript@5.4.3)':
    dependencies:
      '@typescript-eslint/types': 7.16.1
      '@typescript-eslint/visitor-keys': 7.16.1
      debug: 4.3.5
      globby: 11.1.0
      is-glob: 4.0.3
      minimatch: 9.0.5
      semver: 7.6.3
      ts-api-utils: 1.3.0(typescript@5.4.3)
    optionalDependencies:
      typescript: 5.4.3
    transitivePeerDependencies:
      - supports-color

  '@typescript-eslint/utils@7.16.1(eslint@8.57.0)(typescript@5.4.3)':
    dependencies:
      '@eslint-community/eslint-utils': 4.4.0(eslint@8.57.0)
      '@typescript-eslint/scope-manager': 7.16.1
      '@typescript-eslint/types': 7.16.1
      '@typescript-eslint/typescript-estree': 7.16.1(typescript@5.4.3)
      eslint: 8.57.0
    transitivePeerDependencies:
      - supports-color
      - typescript

  '@typescript-eslint/visitor-keys@7.16.1':
    dependencies:
      '@typescript-eslint/types': 7.16.1
      eslint-visitor-keys: 3.4.3

  '@ungap/structured-clone@1.2.0': {}

  '@vitest/coverage-v8@2.0.5(vitest@2.1.9(@types/node@20.14.11)(terser@5.31.3))':
    dependencies:
      '@ampproject/remapping': 2.3.0
      '@bcoe/v8-coverage': 0.2.3
      debug: 4.3.5
      istanbul-lib-coverage: 3.2.2
      istanbul-lib-report: 3.0.1
      istanbul-lib-source-maps: 5.0.6
      istanbul-reports: 3.1.7
      magic-string: 0.30.10
      magicast: 0.3.4
      std-env: 3.7.0
      test-exclude: 7.0.1
      tinyrainbow: 1.2.0
      vitest: 2.1.9(@types/node@20.14.11)(terser@5.31.3)
    transitivePeerDependencies:
      - supports-color

  '@vitest/expect@2.1.9':
    dependencies:
      '@vitest/spy': 2.1.9
      '@vitest/utils': 2.1.9
      chai: 5.1.2
      tinyrainbow: 1.2.0

  '@vitest/mocker@2.1.9(vite@5.4.14(@types/node@20.14.11)(terser@5.31.3))':
    dependencies:
      '@vitest/spy': 2.1.9
      estree-walker: 3.0.3
      magic-string: 0.30.17
    optionalDependencies:
      vite: 5.4.14(@types/node@20.14.11)(terser@5.31.3)

  '@vitest/pretty-format@2.1.9':
    dependencies:
      tinyrainbow: 1.2.0

  '@vitest/runner@2.1.9':
    dependencies:
      '@vitest/utils': 2.1.9
      pathe: 1.1.2

  '@vitest/snapshot@2.1.9':
    dependencies:
      '@vitest/pretty-format': 2.1.9
      magic-string: 0.30.17
      pathe: 1.1.2

  '@vitest/spy@2.1.9':
    dependencies:
      tinyspy: 3.0.2

  '@vitest/utils@2.1.9':
    dependencies:
      '@vitest/pretty-format': 2.1.9
      loupe: 3.1.3
      tinyrainbow: 1.2.0

  '@webassemblyjs/ast@1.12.1':
    dependencies:
      '@webassemblyjs/helper-numbers': 1.11.6
      '@webassemblyjs/helper-wasm-bytecode': 1.11.6

  '@webassemblyjs/floating-point-hex-parser@1.11.6': {}

  '@webassemblyjs/helper-api-error@1.11.6': {}

  '@webassemblyjs/helper-buffer@1.12.1': {}

  '@webassemblyjs/helper-numbers@1.11.6':
    dependencies:
      '@webassemblyjs/floating-point-hex-parser': 1.11.6
      '@webassemblyjs/helper-api-error': 1.11.6
      '@xtuc/long': 4.2.2

  '@webassemblyjs/helper-wasm-bytecode@1.11.6': {}

  '@webassemblyjs/helper-wasm-section@1.12.1':
    dependencies:
      '@webassemblyjs/ast': 1.12.1
      '@webassemblyjs/helper-buffer': 1.12.1
      '@webassemblyjs/helper-wasm-bytecode': 1.11.6
      '@webassemblyjs/wasm-gen': 1.12.1

  '@webassemblyjs/ieee754@1.11.6':
    dependencies:
      '@xtuc/ieee754': 1.2.0

  '@webassemblyjs/leb128@1.11.6':
    dependencies:
      '@xtuc/long': 4.2.2

  '@webassemblyjs/utf8@1.11.6': {}

  '@webassemblyjs/wasm-edit@1.12.1':
    dependencies:
      '@webassemblyjs/ast': 1.12.1
      '@webassemblyjs/helper-buffer': 1.12.1
      '@webassemblyjs/helper-wasm-bytecode': 1.11.6
      '@webassemblyjs/helper-wasm-section': 1.12.1
      '@webassemblyjs/wasm-gen': 1.12.1
      '@webassemblyjs/wasm-opt': 1.12.1
      '@webassemblyjs/wasm-parser': 1.12.1
      '@webassemblyjs/wast-printer': 1.12.1

  '@webassemblyjs/wasm-gen@1.12.1':
    dependencies:
      '@webassemblyjs/ast': 1.12.1
      '@webassemblyjs/helper-wasm-bytecode': 1.11.6
      '@webassemblyjs/ieee754': 1.11.6
      '@webassemblyjs/leb128': 1.11.6
      '@webassemblyjs/utf8': 1.11.6

  '@webassemblyjs/wasm-opt@1.12.1':
    dependencies:
      '@webassemblyjs/ast': 1.12.1
      '@webassemblyjs/helper-buffer': 1.12.1
      '@webassemblyjs/wasm-gen': 1.12.1
      '@webassemblyjs/wasm-parser': 1.12.1

  '@webassemblyjs/wasm-parser@1.12.1':
    dependencies:
      '@webassemblyjs/ast': 1.12.1
      '@webassemblyjs/helper-api-error': 1.11.6
      '@webassemblyjs/helper-wasm-bytecode': 1.11.6
      '@webassemblyjs/ieee754': 1.11.6
      '@webassemblyjs/leb128': 1.11.6
      '@webassemblyjs/utf8': 1.11.6

  '@webassemblyjs/wast-printer@1.12.1':
    dependencies:
      '@webassemblyjs/ast': 1.12.1
      '@xtuc/long': 4.2.2

  '@xtuc/ieee754@1.2.0': {}

  '@xtuc/long@4.2.2': {}

  abort-controller@3.0.0:
    dependencies:
      event-target-shim: 5.0.1

  abstract-logging@2.0.1: {}

  acorn-import-attributes@1.9.5(acorn@8.12.1):
    dependencies:
      acorn: 8.12.1

  acorn-jsx@5.3.2(acorn@8.12.1):
    dependencies:
      acorn: 8.12.1

  acorn-walk@8.3.3:
    dependencies:
      acorn: 8.12.1

  acorn@8.12.1: {}

  ajv-formats@2.1.1(ajv@8.12.0):
    optionalDependencies:
      ajv: 8.12.0

  ajv-formats@2.1.1(ajv@8.17.1):
    optionalDependencies:
      ajv: 8.17.1

  ajv-formats@3.0.1(ajv@8.17.1):
    optionalDependencies:
      ajv: 8.17.1

  ajv-keywords@3.5.2(ajv@6.12.6):
    dependencies:
      ajv: 6.12.6

  ajv@6.12.6:
    dependencies:
      fast-deep-equal: 3.1.3
      fast-json-stable-stringify: 2.1.0
      json-schema-traverse: 0.4.1
      uri-js: 4.4.1

  ajv@8.12.0:
    dependencies:
      fast-deep-equal: 3.1.3
      json-schema-traverse: 1.0.0
      require-from-string: 2.0.2
      uri-js: 4.4.1

  ajv@8.17.1:
    dependencies:
      fast-deep-equal: 3.1.3
      fast-uri: 3.0.1
      json-schema-traverse: 1.0.0
      require-from-string: 2.0.2

  ansi-colors@4.1.3: {}

  ansi-escapes@4.3.2:
    dependencies:
      type-fest: 0.21.3

  ansi-escapes@7.0.0:
    dependencies:
      environment: 1.1.0

  ansi-regex@5.0.1: {}

  ansi-regex@6.0.1: {}

  ansi-styles@3.2.1:
    dependencies:
      color-convert: 1.9.3

  ansi-styles@4.3.0:
    dependencies:
      color-convert: 2.0.1

  ansi-styles@6.2.1: {}

  any-promise@1.3.0: {}

  anymatch@3.1.3:
    dependencies:
      normalize-path: 3.0.0
      picomatch: 2.3.1

  arg@4.1.3: {}

  argparse@1.0.10:
    dependencies:
      sprintf-js: 1.0.3

  argparse@2.0.1: {}

  array-timsort@1.0.3: {}

  array-union@2.1.0: {}

  asap@2.0.6: {}

  assertion-error@2.0.1: {}

  asynckit@0.4.0: {}

  atomic-sleep@1.0.0: {}

  avvio@8.3.2:
    dependencies:
      '@fastify/error': 3.4.1
      fastq: 1.17.1

  axios@1.7.4:
    dependencies:
      follow-redirects: 1.15.9
      form-data: 4.0.2
      proxy-from-env: 1.1.0
    transitivePeerDependencies:
      - debug

  b4a@1.6.6: {}

  balanced-match@1.0.2: {}

  base-x@3.0.10:
    dependencies:
      safe-buffer: 5.2.1

  base-x@4.0.0: {}

  base64-js@1.5.1: {}

  bech32@2.0.0: {}

  better-path-resolve@1.0.0:
    dependencies:
      is-windows: 1.0.2

  binary-extensions@2.3.0: {}

  bip174@2.1.1: {}

  bip32@4.0.0:
    dependencies:
      '@noble/hashes': 1.4.0
      '@scure/base': 1.1.7
      typeforce: 1.18.0
      wif: 2.0.6

  bitcoinjs-lib@6.1.6:
    dependencies:
      '@noble/hashes': 1.4.0
      bech32: 2.0.0
      bip174: 2.1.1
      bs58check: 3.0.1
      typeforce: 1.18.0
      varuint-bitcoin: 1.1.2

  bl@4.1.0:
    dependencies:
      buffer: 5.7.1
      inherits: 2.0.4
      readable-stream: 3.6.2

  blake2b-wasm@2.4.0:
    dependencies:
      b4a: 1.6.6
      nanoassert: 2.0.0

  blake2b@2.1.4:
    dependencies:
      blake2b-wasm: 2.4.0
      nanoassert: 2.0.0

  bn.js@4.12.0: {}

  bn.js@5.2.1: {}

  brace-expansion@1.1.11:
    dependencies:
      balanced-match: 1.0.2
      concat-map: 0.0.1

  brace-expansion@2.0.1:
    dependencies:
      balanced-match: 1.0.2

  braces@3.0.3:
    dependencies:
      fill-range: 7.1.1

  brorand@1.1.0: {}

  browserslist@4.23.2:
    dependencies:
      caniuse-lite: 1.0.30001643
      electron-to-chromium: 1.4.832
      node-releases: 2.0.18
      update-browserslist-db: 1.1.0(browserslist@4.23.2)

  bs58@4.0.1:
    dependencies:
      base-x: 3.0.10

  bs58@5.0.0:
    dependencies:
      base-x: 4.0.0

  bs58check@2.1.2:
    dependencies:
      bs58: 4.0.1
      create-hash: 1.2.0
      safe-buffer: 5.2.1

  bs58check@3.0.1:
    dependencies:
      '@noble/hashes': 1.4.0
      bs58: 5.0.0

  buffer-from@1.1.2: {}

  buffer@5.7.1:
    dependencies:
      base64-js: 1.5.1
      ieee754: 1.2.1

  buffer@6.0.3:
    dependencies:
      base64-js: 1.5.1
      ieee754: 1.2.1

  bundle-require@5.0.0(esbuild@0.24.2):
    dependencies:
      esbuild: 0.24.2
      load-tsconfig: 0.2.5

  cac@6.7.14: {}

  call-bind-apply-helpers@1.0.2:
    dependencies:
      es-errors: 1.3.0
      function-bind: 1.1.2

  call-bind@1.0.7:
    dependencies:
      es-define-property: 1.0.0
      es-errors: 1.3.0
      function-bind: 1.1.2
      get-intrinsic: 1.2.7
      set-function-length: 1.2.2

  callsites@3.1.0: {}

  camelcase-keys@7.0.2:
    dependencies:
      camelcase: 6.3.0
      map-obj: 4.3.0
      quick-lru: 5.1.1
      type-fest: 1.4.0

  camelcase@6.3.0: {}

  caniuse-lite@1.0.30001643: {}

  chai@5.1.2:
    dependencies:
      assertion-error: 2.0.1
      check-error: 2.1.1
      deep-eql: 5.0.2
      loupe: 3.1.3
      pathval: 2.0.0

  chalk@2.4.2:
    dependencies:
      ansi-styles: 3.2.1
      escape-string-regexp: 1.0.5
      supports-color: 5.5.0

  chalk@4.1.2:
    dependencies:
      ansi-styles: 4.3.0
      supports-color: 7.2.0

  chalk@5.3.0: {}

  chalk@5.4.1: {}

  chardet@0.7.0: {}

  check-error@2.1.1: {}

  chokidar@3.6.0:
    dependencies:
      anymatch: 3.1.3
      braces: 3.0.3
      glob-parent: 5.1.2
      is-binary-path: 2.1.0
      is-glob: 4.0.3
      normalize-path: 3.0.0
      readdirp: 3.6.0
    optionalDependencies:
      fsevents: 2.3.3

  chokidar@4.0.3:
    dependencies:
      readdirp: 4.0.2

  chrome-trace-event@1.0.4: {}

  ci-info@3.9.0: {}

  cipher-base@1.0.4:
    dependencies:
      inherits: 2.0.4
      safe-buffer: 5.2.1

  cli-cursor@3.1.0:
    dependencies:
      restore-cursor: 3.1.0

  cli-cursor@5.0.0:
    dependencies:
      restore-cursor: 5.1.0

  cli-spinners@2.9.2: {}

  cli-table3@0.6.5:
    dependencies:
      string-width: 4.2.3
    optionalDependencies:
      '@colors/colors': 1.5.0

  cli-truncate@4.0.0:
    dependencies:
      slice-ansi: 5.0.0
      string-width: 7.2.0

  cli-width@3.0.0: {}

  cli-width@4.1.0: {}

  clone@1.0.4: {}

  color-convert@1.9.3:
    dependencies:
      color-name: 1.1.3

  color-convert@2.0.1:
    dependencies:
      color-name: 1.1.4

  color-name@1.1.3: {}

  color-name@1.1.4: {}

  colorette@2.0.20: {}

  combined-stream@1.0.8:
    dependencies:
      delayed-stream: 1.0.0

  commander@12.1.0: {}

  commander@2.20.3: {}

  commander@4.1.1: {}

  comment-json@4.2.3:
    dependencies:
      array-timsort: 1.0.3
      core-util-is: 1.0.3
      esprima: 4.0.1
      has-own-prop: 2.0.0
      repeat-string: 1.6.1

  component-emitter@1.3.1: {}

  concat-map@0.0.1: {}

  consola@2.15.3: {}

  consola@3.2.3: {}

  cookie@0.6.0: {}

  cookiejar@2.1.4: {}

  core-util-is@1.0.3: {}

  cosmiconfig@8.3.6(typescript@5.3.3):
    dependencies:
      import-fresh: 3.3.0
      js-yaml: 4.1.0
      parse-json: 5.2.0
      path-type: 4.0.0
    optionalDependencies:
      typescript: 5.3.3

  create-hash@1.2.0:
    dependencies:
      cipher-base: 1.0.4
      inherits: 2.0.4
      md5.js: 1.3.5
      ripemd160: 2.0.2
      sha.js: 2.4.11

  create-require@1.1.1: {}

  cross-fetch@3.2.0:
    dependencies:
      node-fetch: 2.7.0
    transitivePeerDependencies:
      - encoding

  cross-spawn@5.1.0:
    dependencies:
      lru-cache: 4.1.5
      shebang-command: 1.2.0
      which: 1.3.1

  cross-spawn@7.0.3:
    dependencies:
      path-key: 3.1.1
      shebang-command: 2.0.0
      which: 2.0.2

  dataloader@1.4.0: {}

  debug@4.3.5:
    dependencies:
      ms: 2.1.2

  debug@4.4.0:
    dependencies:
      ms: 2.1.3

  deep-eql@5.0.2: {}

  deep-freeze-strict@1.1.1: {}

  deep-is@0.1.4: {}

  deepmerge@4.3.1: {}

  defaults@1.0.4:
    dependencies:
      clone: 1.0.4

  define-data-property@1.1.4:
    dependencies:
      es-define-property: 1.0.1
      es-errors: 1.3.0
      gopd: 1.2.0

  delayed-stream@1.0.0: {}

  detect-indent@6.1.0: {}

  dezalgo@1.0.4:
    dependencies:
      asap: 2.0.6
      wrappy: 1.0.2

  diff@4.0.2: {}

  dir-glob@3.0.1:
    dependencies:
      path-type: 4.0.0

  discontinuous-range@1.0.0: {}

  doctrine@3.0.0:
    dependencies:
      esutils: 2.0.3

  dot-case@3.0.4:
    dependencies:
      no-case: 3.0.4
      tslib: 2.6.3

  dotenv-expand@10.0.0: {}

  dotenv@16.4.5: {}

  dunder-proto@1.0.1:
    dependencies:
      call-bind-apply-helpers: 1.0.2
      es-errors: 1.3.0
      gopd: 1.2.0

  eastasianwidth@0.2.0: {}

  ecpair@2.1.0:
    dependencies:
      randombytes: 2.1.0
      typeforce: 1.18.0
      wif: 2.0.6

  electron-to-chromium@1.4.832: {}

  elliptic@6.6.1:
    dependencies:
      bn.js: 4.12.0
      brorand: 1.1.0
      hash.js: 1.1.7
      hmac-drbg: 1.0.1
      inherits: 2.0.4
      minimalistic-assert: 1.0.1
      minimalistic-crypto-utils: 1.0.1

  emoji-regex@10.3.0: {}

  emoji-regex@8.0.0: {}

  emoji-regex@9.2.2: {}

  enhanced-resolve@5.17.0:
    dependencies:
      graceful-fs: 4.2.11
      tapable: 2.2.1

  enquirer@2.4.1:
    dependencies:
      ansi-colors: 4.1.3
      strip-ansi: 6.0.1

  environment@1.1.0: {}

  error-ex@1.3.2:
    dependencies:
      is-arrayish: 0.2.1

  es-define-property@1.0.0:
    dependencies:
      get-intrinsic: 1.2.7

  es-define-property@1.0.1: {}

  es-errors@1.3.0: {}

  es-module-lexer@1.5.4: {}

  es-module-lexer@1.6.0: {}

  es-object-atoms@1.1.1:
    dependencies:
      es-errors: 1.3.0

  es-set-tostringtag@2.1.0:
    dependencies:
      es-errors: 1.3.0
      get-intrinsic: 1.2.7
      has-tostringtag: 1.0.2
      hasown: 2.0.2

  esbuild@0.21.5:
    optionalDependencies:
      '@esbuild/aix-ppc64': 0.21.5
      '@esbuild/android-arm': 0.21.5
      '@esbuild/android-arm64': 0.21.5
      '@esbuild/android-x64': 0.21.5
      '@esbuild/darwin-arm64': 0.21.5
      '@esbuild/darwin-x64': 0.21.5
      '@esbuild/freebsd-arm64': 0.21.5
      '@esbuild/freebsd-x64': 0.21.5
      '@esbuild/linux-arm': 0.21.5
      '@esbuild/linux-arm64': 0.21.5
      '@esbuild/linux-ia32': 0.21.5
      '@esbuild/linux-loong64': 0.21.5
      '@esbuild/linux-mips64el': 0.21.5
      '@esbuild/linux-ppc64': 0.21.5
      '@esbuild/linux-riscv64': 0.21.5
      '@esbuild/linux-s390x': 0.21.5
      '@esbuild/linux-x64': 0.21.5
      '@esbuild/netbsd-x64': 0.21.5
      '@esbuild/openbsd-x64': 0.21.5
      '@esbuild/sunos-x64': 0.21.5
      '@esbuild/win32-arm64': 0.21.5
      '@esbuild/win32-ia32': 0.21.5
      '@esbuild/win32-x64': 0.21.5

  esbuild@0.24.2:
    optionalDependencies:
      '@esbuild/aix-ppc64': 0.24.2
      '@esbuild/android-arm': 0.24.2
      '@esbuild/android-arm64': 0.24.2
      '@esbuild/android-x64': 0.24.2
      '@esbuild/darwin-arm64': 0.24.2
      '@esbuild/darwin-x64': 0.24.2
      '@esbuild/freebsd-arm64': 0.24.2
      '@esbuild/freebsd-x64': 0.24.2
      '@esbuild/linux-arm': 0.24.2
      '@esbuild/linux-arm64': 0.24.2
      '@esbuild/linux-ia32': 0.24.2
      '@esbuild/linux-loong64': 0.24.2
      '@esbuild/linux-mips64el': 0.24.2
      '@esbuild/linux-ppc64': 0.24.2
      '@esbuild/linux-riscv64': 0.24.2
      '@esbuild/linux-s390x': 0.24.2
      '@esbuild/linux-x64': 0.24.2
      '@esbuild/netbsd-arm64': 0.24.2
      '@esbuild/netbsd-x64': 0.24.2
      '@esbuild/openbsd-arm64': 0.24.2
      '@esbuild/openbsd-x64': 0.24.2
      '@esbuild/sunos-x64': 0.24.2
      '@esbuild/win32-arm64': 0.24.2
      '@esbuild/win32-ia32': 0.24.2
      '@esbuild/win32-x64': 0.24.2

  escalade@3.1.2: {}

  escape-string-regexp@1.0.5: {}

  escape-string-regexp@4.0.0: {}

  eslint-scope@5.1.1:
    dependencies:
      esrecurse: 4.3.0
      estraverse: 4.3.0

  eslint-scope@7.2.2:
    dependencies:
      esrecurse: 4.3.0
      estraverse: 5.3.0

  eslint-visitor-keys@3.4.3: {}

  eslint@8.57.0:
    dependencies:
      '@eslint-community/eslint-utils': 4.4.0(eslint@8.57.0)
      '@eslint-community/regexpp': 4.11.0
      '@eslint/eslintrc': 2.1.4
      '@eslint/js': 8.57.0
      '@humanwhocodes/config-array': 0.11.14
      '@humanwhocodes/module-importer': 1.0.1
      '@nodelib/fs.walk': 1.2.8
      '@ungap/structured-clone': 1.2.0
      ajv: 6.12.6
      chalk: 4.1.2
      cross-spawn: 7.0.3
      debug: 4.3.5
      doctrine: 3.0.0
      escape-string-regexp: 4.0.0
      eslint-scope: 7.2.2
      eslint-visitor-keys: 3.4.3
      espree: 9.6.1
      esquery: 1.6.0
      esutils: 2.0.3
      fast-deep-equal: 3.1.3
      file-entry-cache: 6.0.1
      find-up: 5.0.0
      glob-parent: 6.0.2
      globals: 13.24.0
      graphemer: 1.4.0
      ignore: 5.3.1
      imurmurhash: 0.1.4
      is-glob: 4.0.3
      is-path-inside: 3.0.3
      js-yaml: 4.1.0
      json-stable-stringify-without-jsonify: 1.0.1
      levn: 0.4.1
      lodash.merge: 4.6.2
      minimatch: 3.1.2
      natural-compare: 1.4.0
      optionator: 0.9.4
      strip-ansi: 6.0.1
      text-table: 0.2.0
    transitivePeerDependencies:
      - supports-color

  espree@9.6.1:
    dependencies:
      acorn: 8.12.1
      acorn-jsx: 5.3.2(acorn@8.12.1)
      eslint-visitor-keys: 3.4.3

  esprima@4.0.1: {}

  esquery@1.6.0:
    dependencies:
      estraverse: 5.3.0

  esrecurse@4.3.0:
    dependencies:
      estraverse: 5.3.0

  estraverse@4.3.0: {}

  estraverse@5.3.0: {}

  estree-walker@2.0.2: {}

  estree-walker@3.0.3:
    dependencies:
      '@types/estree': 1.0.6

  esutils@2.0.3: {}

  event-target-shim@5.0.1: {}

  eventemitter3@5.0.1: {}

  events@3.3.0: {}

  execa@8.0.1:
    dependencies:
      cross-spawn: 7.0.3
      get-stream: 8.0.1
      human-signals: 5.0.0
      is-stream: 3.0.0
      merge-stream: 2.0.0
      npm-run-path: 5.3.0
      onetime: 6.0.0
      signal-exit: 4.1.0
      strip-final-newline: 3.0.0

  expect-type@1.1.0: {}

  extendable-error@0.1.7: {}

  external-editor@3.1.0:
    dependencies:
      chardet: 0.7.0
      iconv-lite: 0.4.24
      tmp: 0.0.33

  fast-content-type-parse@1.1.0: {}

  fast-decode-uri-component@1.0.1: {}

  fast-deep-equal@3.1.3: {}

  fast-glob@3.3.2:
    dependencies:
      '@nodelib/fs.stat': 2.0.5
      '@nodelib/fs.walk': 1.2.8
      glob-parent: 5.1.2
      merge2: 1.4.1
      micromatch: 4.0.7

  fast-json-stable-stringify@2.1.0: {}

  fast-json-stringify@5.16.1:
    dependencies:
      '@fastify/merge-json-schemas': 0.1.1
      ajv: 8.17.1
      ajv-formats: 3.0.1(ajv@8.17.1)
      fast-deep-equal: 3.1.3
      fast-uri: 2.4.0
      json-schema-ref-resolver: 1.0.1
      rfdc: 1.4.1

  fast-levenshtein@2.0.6: {}

  fast-querystring@1.1.2:
    dependencies:
      fast-decode-uri-component: 1.0.1

  fast-redact@3.5.0: {}

  fast-safe-stringify@2.1.1: {}

  fast-uri@2.4.0: {}

  fast-uri@3.0.1: {}

  fastify-plugin@4.5.1: {}

  fastify@4.28.0:
    dependencies:
      '@fastify/ajv-compiler': 3.6.0
      '@fastify/error': 3.4.1
      '@fastify/fast-json-stringify-compiler': 4.3.0
      abstract-logging: 2.0.1
      avvio: 8.3.2
      fast-content-type-parse: 1.1.0
      fast-json-stringify: 5.16.1
      find-my-way: 8.2.0
      light-my-request: 5.13.0
      pino: 9.3.1
      process-warning: 3.0.0
      proxy-addr: 2.0.7
      rfdc: 1.4.1
      secure-json-parse: 2.7.0
      semver: 7.6.3
      toad-cache: 3.7.0

  fastq@1.17.1:
    dependencies:
      reusify: 1.0.4

  fdir@6.4.2(picomatch@4.0.2):
    optionalDependencies:
      picomatch: 4.0.2

  figures@3.2.0:
    dependencies:
      escape-string-regexp: 1.0.5

  file-entry-cache@6.0.1:
    dependencies:
      flat-cache: 3.2.0

  fill-range@7.1.1:
    dependencies:
      to-regex-range: 5.0.1

  find-my-way@8.2.0:
    dependencies:
      fast-deep-equal: 3.1.3
      fast-querystring: 1.1.2
      safe-regex2: 3.1.0

  find-up@4.1.0:
    dependencies:
      locate-path: 5.0.0
      path-exists: 4.0.0

  find-up@5.0.0:
    dependencies:
      locate-path: 6.0.0
      path-exists: 4.0.0

  find-yarn-workspace-root2@1.2.16:
    dependencies:
      micromatch: 4.0.7
      pkg-dir: 4.2.0

  flat-cache@3.2.0:
    dependencies:
      flatted: 3.3.1
      keyv: 4.5.4
      rimraf: 3.0.2

  flatted@3.3.1: {}

  follow-redirects@1.15.9: {}

  foreground-child@3.2.1:
    dependencies:
      cross-spawn: 7.0.3
      signal-exit: 4.1.0

  fork-ts-checker-webpack-plugin@9.0.2(typescript@5.3.3)(webpack@5.92.1(@swc/core@1.7.11)(esbuild@0.24.2)):
    dependencies:
      '@babel/code-frame': 7.24.7
      chalk: 4.1.2
      chokidar: 3.6.0
      cosmiconfig: 8.3.6(typescript@5.3.3)
      deepmerge: 4.3.1
      fs-extra: 10.1.0
      memfs: 3.5.3
      minimatch: 3.1.2
      node-abort-controller: 3.1.1
      schema-utils: 3.3.0
      semver: 7.6.3
      tapable: 2.2.1
      typescript: 5.3.3
      webpack: 5.92.1(@swc/core@1.7.11)(esbuild@0.24.2)

  form-data@4.0.0:
    dependencies:
      asynckit: 0.4.0
      combined-stream: 1.0.8
      mime-types: 2.1.35

  form-data@4.0.2:
    dependencies:
      asynckit: 0.4.0
      combined-stream: 1.0.8
      es-set-tostringtag: 2.1.0
      mime-types: 2.1.35

  formidable@2.1.2:
    dependencies:
      dezalgo: 1.0.4
      hexoid: 1.0.0
      once: 1.4.0
      qs: 6.12.3

  forwarded@0.2.0: {}

  fs-extra@10.1.0:
    dependencies:
      graceful-fs: 4.2.11
      jsonfile: 6.1.0
      universalify: 2.0.1

  fs-extra@7.0.1:
    dependencies:
      graceful-fs: 4.2.11
      jsonfile: 4.0.0
      universalify: 0.1.2

  fs-extra@8.1.0:
    dependencies:
      graceful-fs: 4.2.11
      jsonfile: 4.0.0
      universalify: 0.1.2

  fs-monkey@1.0.6: {}

  fs.realpath@1.0.0: {}

  fsevents@2.3.3:
    optional: true

  function-bind@1.1.2: {}

  get-east-asian-width@1.2.0: {}

  get-intrinsic@1.2.4:
    dependencies:
      es-errors: 1.3.0
      function-bind: 1.1.2
      has-proto: 1.0.3
      has-symbols: 1.0.3
      hasown: 2.0.2

  get-intrinsic@1.2.7:
    dependencies:
      call-bind-apply-helpers: 1.0.2
      es-define-property: 1.0.1
      es-errors: 1.3.0
      es-object-atoms: 1.1.1
      function-bind: 1.1.2
      get-proto: 1.0.1
      gopd: 1.2.0
      has-symbols: 1.1.0
      hasown: 2.0.2
      math-intrinsics: 1.1.0

  get-proto@1.0.1:
    dependencies:
      dunder-proto: 1.0.1
      es-object-atoms: 1.1.1

  get-stream@8.0.1: {}

  get-tsconfig@4.7.6:
    dependencies:
      resolve-pkg-maps: 1.0.0

  glob-parent@5.1.2:
    dependencies:
      is-glob: 4.0.3

  glob-parent@6.0.2:
    dependencies:
      is-glob: 4.0.3

  glob-to-regexp@0.4.1: {}

  glob@10.4.2:
    dependencies:
      foreground-child: 3.2.1
      jackspeak: 3.4.3
      minimatch: 9.0.5
      minipass: 7.1.2
      package-json-from-dist: 1.0.0
      path-scurry: 1.11.1

  glob@10.4.5:
    dependencies:
      foreground-child: 3.2.1
      jackspeak: 3.4.3
      minimatch: 9.0.5
      minipass: 7.1.2
      package-json-from-dist: 1.0.0
      path-scurry: 1.11.1

  glob@7.2.3:
    dependencies:
      fs.realpath: 1.0.0
      inflight: 1.0.6
      inherits: 2.0.4
      minimatch: 3.1.2
      once: 1.4.0
      path-is-absolute: 1.0.1

  globals@13.24.0:
    dependencies:
      type-fest: 0.20.2

  globby@11.1.0:
    dependencies:
      array-union: 2.1.0
      dir-glob: 3.0.1
      fast-glob: 3.3.2
      ignore: 5.3.1
      merge2: 1.4.1
      slash: 3.0.0

  gopd@1.2.0: {}

  graceful-fs@4.2.11: {}

  graphemer@1.4.0: {}

  has-flag@3.0.0: {}

  has-flag@4.0.0: {}

  has-own-prop@2.0.0: {}

  has-property-descriptors@1.0.2:
    dependencies:
      es-define-property: 1.0.1

  has-proto@1.0.3: {}

  has-symbols@1.0.3: {}

  has-symbols@1.1.0: {}

  has-tostringtag@1.0.2:
    dependencies:
      has-symbols: 1.1.0

  hash-base@3.1.0:
    dependencies:
      inherits: 2.0.4
      readable-stream: 3.6.2
      safe-buffer: 5.2.1

  hash.js@1.1.7:
    dependencies:
      inherits: 2.0.4
      minimalistic-assert: 1.0.1

  hasown@2.0.2:
    dependencies:
      function-bind: 1.1.2

  hexoid@1.0.0: {}

  hmac-drbg@1.0.1:
    dependencies:
      hash.js: 1.1.7
      minimalistic-assert: 1.0.1
      minimalistic-crypto-utils: 1.0.1

  html-escaper@2.0.2: {}

  human-id@1.0.2: {}

  human-signals@5.0.0: {}

  husky@9.1.7: {}

  iconv-lite@0.4.24:
    dependencies:
      safer-buffer: 2.1.2

  ieee754@1.2.1: {}

  ignore@5.3.1: {}

  immutable@4.3.7: {}

  import-fresh@3.3.0:
    dependencies:
      parent-module: 1.0.1
      resolve-from: 4.0.0

  imurmurhash@0.1.4: {}

  inflight@1.0.6:
    dependencies:
      once: 1.4.0
      wrappy: 1.0.2

  inherits@2.0.4: {}

  inquirer@8.2.6:
    dependencies:
      ansi-escapes: 4.3.2
      chalk: 4.1.2
      cli-cursor: 3.1.0
      cli-width: 3.0.0
      external-editor: 3.1.0
      figures: 3.2.0
      lodash: 4.17.21
      mute-stream: 0.0.8
      ora: 5.4.1
      run-async: 2.4.1
      rxjs: 7.8.1
      string-width: 4.2.3
      strip-ansi: 6.0.1
      through: 2.3.8
      wrap-ansi: 6.2.0

  inquirer@9.2.15:
    dependencies:
      '@ljharb/through': 2.3.13
      ansi-escapes: 4.3.2
      chalk: 5.3.0
      cli-cursor: 3.1.0
      cli-width: 4.1.0
      external-editor: 3.1.0
      figures: 3.2.0
      lodash: 4.17.21
      mute-stream: 1.0.0
      ora: 5.4.1
      run-async: 3.0.0
      rxjs: 7.8.1
      string-width: 4.2.3
      strip-ansi: 6.0.1
      wrap-ansi: 6.2.0

  ipaddr.js@1.9.1: {}

  is-arrayish@0.2.1: {}

  is-binary-path@2.1.0:
    dependencies:
      binary-extensions: 2.3.0

  is-extglob@2.1.1: {}

  is-fullwidth-code-point@3.0.0: {}

  is-fullwidth-code-point@4.0.0: {}

  is-fullwidth-code-point@5.0.0:
    dependencies:
      get-east-asian-width: 1.2.0

  is-glob@4.0.3:
    dependencies:
      is-extglob: 2.1.1

  is-interactive@1.0.0: {}

  is-number@7.0.0: {}

  is-path-inside@3.0.3: {}

  is-stream@3.0.0: {}

  is-subdir@1.2.0:
    dependencies:
      better-path-resolve: 1.0.0

  is-unicode-supported@0.1.0: {}

  is-windows@1.0.2: {}

  isarray@1.0.0: {}

  isexe@2.0.0: {}

  isobject@2.1.0:
    dependencies:
      isarray: 1.0.0

  istanbul-lib-coverage@3.2.2: {}

  istanbul-lib-report@3.0.1:
    dependencies:
      istanbul-lib-coverage: 3.2.2
      make-dir: 4.0.0
      supports-color: 7.2.0

  istanbul-lib-source-maps@5.0.6:
    dependencies:
      '@jridgewell/trace-mapping': 0.3.25
      debug: 4.3.5
      istanbul-lib-coverage: 3.2.2
    transitivePeerDependencies:
      - supports-color

  istanbul-reports@3.1.7:
    dependencies:
      html-escaper: 2.0.2
      istanbul-lib-report: 3.0.1

  iterare@1.2.1: {}

  jackspeak@3.4.3:
    dependencies:
      '@isaacs/cliui': 8.0.2
    optionalDependencies:
      '@pkgjs/parseargs': 0.11.0

  jest-worker@27.5.1:
    dependencies:
      '@types/node': 20.14.11
      merge-stream: 2.0.0
      supports-color: 8.1.1

  joycon@3.1.1: {}

  js-sha256@0.11.0: {}

  js-tokens@4.0.0: {}

  js-xxhash@1.0.4: {}

  js-yaml@3.14.1:
    dependencies:
      argparse: 1.0.10
      esprima: 4.0.1

  js-yaml@4.1.0:
    dependencies:
      argparse: 2.0.1

  jsbi@3.1.3: {}

  jsbi@4.3.0: {}

  json-buffer@3.0.1: {}

  json-parse-even-better-errors@2.3.1: {}

  json-rpc-2.0@1.7.0: {}

  json-schema-ref-resolver@1.0.1:
    dependencies:
      fast-deep-equal: 3.1.3

  json-schema-traverse@0.4.1: {}

  json-schema-traverse@1.0.0: {}

  json-stable-stringify-without-jsonify@1.0.1: {}

  json5@2.2.3: {}

  jsonc-parser@3.2.1: {}

  jsonc-parser@3.3.1: {}

  jsonfile@4.0.0:
    optionalDependencies:
      graceful-fs: 4.2.11

  jsonfile@6.1.0:
    dependencies:
      universalify: 2.0.1
    optionalDependencies:
      graceful-fs: 4.2.11

  keyv@4.5.4:
    dependencies:
      json-buffer: 3.0.1

  levn@0.4.1:
    dependencies:
      prelude-ls: 1.2.1
      type-check: 0.4.0

  light-my-request@5.13.0:
    dependencies:
      cookie: 0.6.0
      process-warning: 3.0.0
      set-cookie-parser: 2.6.0

  lilconfig@3.1.2: {}

  lilconfig@3.1.3: {}

  lines-and-columns@1.2.4: {}

  lint-staged@15.3.0:
    dependencies:
      chalk: 5.4.1
      commander: 12.1.0
      debug: 4.4.0
      execa: 8.0.1
      lilconfig: 3.1.3
      listr2: 8.2.5
      micromatch: 4.0.8
      pidtree: 0.6.0
      string-argv: 0.3.2
      yaml: 2.6.1
    transitivePeerDependencies:
      - supports-color

  listr2@8.2.5:
    dependencies:
      cli-truncate: 4.0.0
      colorette: 2.0.20
      eventemitter3: 5.0.1
      log-update: 6.1.0
      rfdc: 1.4.1
      wrap-ansi: 9.0.0

  load-tsconfig@0.2.5: {}

  load-yaml-file@0.2.0:
    dependencies:
      graceful-fs: 4.2.11
      js-yaml: 3.14.1
      pify: 4.0.1
      strip-bom: 3.0.0

  loader-runner@4.3.0: {}

  locate-path@5.0.0:
    dependencies:
      p-locate: 4.1.0

  locate-path@6.0.0:
    dependencies:
      p-locate: 5.0.0

  lodash.isequal@4.5.0: {}

  lodash.merge@4.6.2: {}

  lodash.sortby@4.7.0: {}

  lodash.startcase@4.4.0: {}

  lodash@4.17.21: {}

  log-symbols@4.1.0:
    dependencies:
      chalk: 4.1.2
      is-unicode-supported: 0.1.0

  log-update@6.1.0:
    dependencies:
      ansi-escapes: 7.0.0
      cli-cursor: 5.0.0
      slice-ansi: 7.1.0
      strip-ansi: 7.1.0
      wrap-ansi: 9.0.0

  loupe@3.1.3: {}

  lower-case@2.0.2:
    dependencies:
      tslib: 2.6.3

  lru-cache@10.4.3: {}

  lru-cache@4.1.5:
    dependencies:
      pseudomap: 1.0.2
      yallist: 2.1.2

  magic-string@0.30.10:
    dependencies:
      '@jridgewell/sourcemap-codec': 1.5.0

  magic-string@0.30.17:
    dependencies:
      '@jridgewell/sourcemap-codec': 1.5.0

  magic-string@0.30.8:
    dependencies:
      '@jridgewell/sourcemap-codec': 1.5.0

  magicast@0.3.4:
    dependencies:
      '@babel/parser': 7.24.8
      '@babel/types': 7.24.9
      source-map-js: 1.2.0

  make-dir@4.0.0:
    dependencies:
      semver: 7.6.3

  make-error@1.3.6: {}

  map-obj@4.3.0: {}

  math-intrinsics@1.1.0: {}

  md5.js@1.3.5:
    dependencies:
      hash-base: 3.1.0
      inherits: 2.0.4
      safe-buffer: 5.2.1

  memfs@3.5.3:
    dependencies:
      fs-monkey: 1.0.6

  merge-stream@2.0.0: {}

  merge2@1.4.1: {}

  methods@1.1.2: {}

  micromatch@4.0.7:
    dependencies:
      braces: 3.0.3
      picomatch: 2.3.1

  micromatch@4.0.8:
    dependencies:
      braces: 3.0.3
      picomatch: 2.3.1

  mime-db@1.52.0: {}

  mime-types@2.1.35:
    dependencies:
      mime-db: 1.52.0

  mime@2.6.0: {}

  mimic-fn@2.1.0: {}

  mimic-fn@4.0.0: {}

  mimic-function@5.0.1: {}

  minimalistic-assert@1.0.1: {}

  minimalistic-crypto-utils@1.0.1: {}

  minimatch@3.1.2:
    dependencies:
      brace-expansion: 1.1.11

  minimatch@9.0.5:
    dependencies:
      brace-expansion: 2.0.1

  minimist@1.2.8: {}

  minipass@7.1.2: {}

  mnemonist@0.39.6:
    dependencies:
      obliterator: 2.0.4

  moo@0.5.2: {}

  mri@1.2.0: {}

  ms@2.1.2: {}

  ms@2.1.3: {}

  mute-stream@0.0.8: {}

  mute-stream@1.0.0: {}

  mz@2.7.0:
    dependencies:
      any-promise: 1.3.0
      object-assign: 4.1.1
      thenify-all: 1.6.0

  nanoassert@2.0.0: {}

  nanoid@3.3.8: {}

  natural-compare@1.4.0: {}

  nearley@2.20.1:
    dependencies:
      commander: 2.20.3
      moo: 0.5.2
      railroad-diagrams: 1.0.0
      randexp: 0.4.6

  neo-async@2.6.2: {}

  no-case@3.0.4:
    dependencies:
      lower-case: 2.0.2
      tslib: 2.6.3

  node-abort-controller@3.1.1: {}

  node-emoji@1.11.0:
    dependencies:
      lodash: 4.17.21

  node-fetch@2.7.0:
    dependencies:
      whatwg-url: 5.0.0

  node-releases@2.0.18: {}

  normalize-path@3.0.0: {}

  npm-run-path@5.3.0:
    dependencies:
      path-key: 4.0.0

  object-assign@4.1.1: {}

  object-inspect@1.13.2: {}

  obliterator@2.0.4: {}

  on-exit-leak-free@2.1.2: {}

  once@1.4.0:
    dependencies:
      wrappy: 1.0.2

  onetime@5.1.2:
    dependencies:
      mimic-fn: 2.1.0

  onetime@6.0.0:
    dependencies:
      mimic-fn: 4.0.0

  onetime@7.0.0:
    dependencies:
      mimic-function: 5.0.1

  optionator@0.9.4:
    dependencies:
      deep-is: 0.1.4
      fast-levenshtein: 2.0.6
      levn: 0.4.1
      prelude-ls: 1.2.1
      type-check: 0.4.0
      word-wrap: 1.2.5

  ora@5.4.1:
    dependencies:
      bl: 4.1.0
      chalk: 4.1.2
      cli-cursor: 3.1.0
      cli-spinners: 2.9.2
      is-interactive: 1.0.0
      is-unicode-supported: 0.1.0
      log-symbols: 4.1.0
      strip-ansi: 6.0.1
      wcwidth: 1.0.1

  os-tmpdir@1.0.2: {}

  outdent@0.5.0: {}

  p-filter@2.1.0:
    dependencies:
      p-map: 2.1.0

  p-limit@2.3.0:
    dependencies:
      p-try: 2.2.0

  p-limit@3.1.0:
    dependencies:
      yocto-queue: 0.1.0

  p-locate@4.1.0:
    dependencies:
      p-limit: 2.3.0

  p-locate@5.0.0:
    dependencies:
      p-limit: 3.1.0

  p-map@2.1.0: {}

  p-try@2.2.0: {}

  package-json-from-dist@1.0.0: {}

  parent-module@1.0.1:
    dependencies:
      callsites: 3.1.0

  parse-json@5.2.0:
    dependencies:
      '@babel/code-frame': 7.24.7
      error-ex: 1.3.2
      json-parse-even-better-errors: 2.3.1
      lines-and-columns: 1.2.4

  path-exists@4.0.0: {}

  path-is-absolute@1.0.1: {}

  path-key@3.1.1: {}

  path-key@4.0.0: {}

  path-scurry@1.11.1:
    dependencies:
      lru-cache: 10.4.3
      minipass: 7.1.2

  path-to-regexp@3.2.0: {}

  path-to-regexp@6.2.2: {}

  path-type@4.0.0: {}

  pathe@1.1.2: {}

  pathval@2.0.0: {}

  picocolors@1.0.1: {}

  picocolors@1.1.1: {}

  picomatch@2.3.1: {}

  picomatch@4.0.1: {}

  picomatch@4.0.2: {}

  pidtree@0.6.0: {}

  pify@4.0.1: {}

  pino-abstract-transport@1.2.0:
    dependencies:
      readable-stream: 4.5.2
      split2: 4.2.0

  pino-std-serializers@7.0.0: {}

  pino@9.3.1:
    dependencies:
      atomic-sleep: 1.0.0
      fast-redact: 3.5.0
      on-exit-leak-free: 2.1.2
      pino-abstract-transport: 1.2.0
      pino-std-serializers: 7.0.0
      process-warning: 3.0.0
      quick-format-unescaped: 4.0.4
      real-require: 0.2.0
      safe-stable-stringify: 2.4.3
      sonic-boom: 4.0.1
      thread-stream: 3.1.0

  pirates@4.0.6: {}

  pkg-dir@4.2.0:
    dependencies:
      find-up: 4.1.0

  pluralize@8.0.0: {}

  postcss-load-config@6.0.1(postcss@8.5.2)(tsx@4.16.3)(yaml@2.6.1):
    dependencies:
      lilconfig: 3.1.2
    optionalDependencies:
      postcss: 8.5.2
      tsx: 4.16.3
      yaml: 2.6.1

  postcss@8.5.2:
    dependencies:
      nanoid: 3.3.8
      picocolors: 1.1.1
      source-map-js: 1.2.1

  preferred-pm@3.1.4:
    dependencies:
      find-up: 5.0.0
      find-yarn-workspace-root2: 1.2.16
      path-exists: 4.0.0
      which-pm: 2.2.0

  prelude-ls@1.2.1: {}

  prettier@2.8.8: {}

  prettier@3.4.2: {}

  process-warning@3.0.0: {}

  process@0.11.10: {}

  proxy-addr@2.0.7:
    dependencies:
      forwarded: 0.2.0
      ipaddr.js: 1.9.1

  proxy-from-env@1.1.0: {}

  pseudomap@1.0.2: {}

  punycode@2.3.1: {}

  qs@6.12.3:
    dependencies:
      side-channel: 1.0.6

  queue-microtask@1.2.3: {}

  quick-format-unescaped@4.0.4: {}

  quick-lru@5.1.1: {}

  railroad-diagrams@1.0.0: {}

  randexp@0.4.6:
    dependencies:
      discontinuous-range: 1.0.0
      ret: 0.1.15

  randombytes@2.1.0:
    dependencies:
      safe-buffer: 5.2.1

  read-yaml-file@1.1.0:
    dependencies:
      graceful-fs: 4.2.11
      js-yaml: 3.14.1
      pify: 4.0.1
      strip-bom: 3.0.0

  readable-stream@3.6.2:
    dependencies:
      inherits: 2.0.4
      string_decoder: 1.3.0
      util-deprecate: 1.0.2

  readable-stream@4.5.2:
    dependencies:
      abort-controller: 3.0.0
      buffer: 6.0.3
      events: 3.3.0
      process: 0.11.10
      string_decoder: 1.3.0

  readdirp@3.6.0:
    dependencies:
      picomatch: 2.3.1

  readdirp@4.0.2: {}

  real-require@0.2.0: {}

  reflect-metadata@0.2.2: {}

  regenerator-runtime@0.14.1: {}

  relative@3.0.2:
    dependencies:
      isobject: 2.1.0

  repeat-string@1.6.1: {}

  require-from-string@2.0.2: {}

  resolve-from@4.0.0: {}

  resolve-from@5.0.0: {}

  resolve-pkg-maps@1.0.0: {}

  restore-cursor@3.1.0:
    dependencies:
      onetime: 5.1.2
      signal-exit: 3.0.7

  restore-cursor@5.1.0:
    dependencies:
      onetime: 7.0.0
      signal-exit: 4.1.0

  ret@0.1.15: {}

  ret@0.4.3: {}

  reusify@1.0.4: {}

  rfdc@1.4.1: {}

  rimraf@3.0.2:
    dependencies:
      glob: 7.2.3

  ripemd160@2.0.2:
    dependencies:
      hash-base: 3.1.0
      inherits: 2.0.4

  rollup@4.30.0:
    dependencies:
      '@types/estree': 1.0.6
    optionalDependencies:
      '@rollup/rollup-android-arm-eabi': 4.30.0
      '@rollup/rollup-android-arm64': 4.30.0
      '@rollup/rollup-darwin-arm64': 4.30.0
      '@rollup/rollup-darwin-x64': 4.30.0
      '@rollup/rollup-freebsd-arm64': 4.30.0
      '@rollup/rollup-freebsd-x64': 4.30.0
      '@rollup/rollup-linux-arm-gnueabihf': 4.30.0
      '@rollup/rollup-linux-arm-musleabihf': 4.30.0
      '@rollup/rollup-linux-arm64-gnu': 4.30.0
      '@rollup/rollup-linux-arm64-musl': 4.30.0
      '@rollup/rollup-linux-loongarch64-gnu': 4.30.0
      '@rollup/rollup-linux-powerpc64le-gnu': 4.30.0
      '@rollup/rollup-linux-riscv64-gnu': 4.30.0
      '@rollup/rollup-linux-s390x-gnu': 4.30.0
      '@rollup/rollup-linux-x64-gnu': 4.30.0
      '@rollup/rollup-linux-x64-musl': 4.30.0
      '@rollup/rollup-win32-arm64-msvc': 4.30.0
      '@rollup/rollup-win32-ia32-msvc': 4.30.0
      '@rollup/rollup-win32-x64-msvc': 4.30.0
      fsevents: 2.3.3

  rollup@4.34.7:
    dependencies:
      '@types/estree': 1.0.6
    optionalDependencies:
      '@rollup/rollup-android-arm-eabi': 4.34.7
      '@rollup/rollup-android-arm64': 4.34.7
      '@rollup/rollup-darwin-arm64': 4.34.7
      '@rollup/rollup-darwin-x64': 4.34.7
      '@rollup/rollup-freebsd-arm64': 4.34.7
      '@rollup/rollup-freebsd-x64': 4.34.7
      '@rollup/rollup-linux-arm-gnueabihf': 4.34.7
      '@rollup/rollup-linux-arm-musleabihf': 4.34.7
      '@rollup/rollup-linux-arm64-gnu': 4.34.7
      '@rollup/rollup-linux-arm64-musl': 4.34.7
      '@rollup/rollup-linux-loongarch64-gnu': 4.34.7
      '@rollup/rollup-linux-powerpc64le-gnu': 4.34.7
      '@rollup/rollup-linux-riscv64-gnu': 4.34.7
      '@rollup/rollup-linux-s390x-gnu': 4.34.7
      '@rollup/rollup-linux-x64-gnu': 4.34.7
      '@rollup/rollup-linux-x64-musl': 4.34.7
      '@rollup/rollup-win32-arm64-msvc': 4.34.7
      '@rollup/rollup-win32-ia32-msvc': 4.34.7
      '@rollup/rollup-win32-x64-msvc': 4.34.7
      fsevents: 2.3.3

  run-async@2.4.1: {}

  run-async@3.0.0: {}

  run-parallel@1.2.0:
    dependencies:
      queue-microtask: 1.2.3

  rxjs@7.8.1:
    dependencies:
      tslib: 2.6.3

  safe-buffer@5.2.1: {}

  safe-regex2@3.1.0:
    dependencies:
      ret: 0.4.3

  safe-stable-stringify@2.4.3: {}

  safer-buffer@2.1.2: {}

  schema-utils@3.3.0:
    dependencies:
      '@types/json-schema': 7.0.15
      ajv: 6.12.6
      ajv-keywords: 3.5.2(ajv@6.12.6)

  scrypt-js@3.0.1: {}

  secure-json-parse@2.7.0: {}

  semver@7.6.3: {}

  serialize-javascript@6.0.2:
    dependencies:
      randombytes: 2.1.0

  set-cookie-parser@2.6.0: {}

  set-function-length@1.2.2:
    dependencies:
      define-data-property: 1.1.4
      es-errors: 1.3.0
      function-bind: 1.1.2
      get-intrinsic: 1.2.7
      gopd: 1.2.0
      has-property-descriptors: 1.0.2

  sha.js@2.4.11:
    dependencies:
      inherits: 2.0.4
      safe-buffer: 5.2.1

  sha3@2.1.4:
    dependencies:
      buffer: 6.0.3

  shebang-command@1.2.0:
    dependencies:
      shebang-regex: 1.0.0

  shebang-command@2.0.0:
    dependencies:
      shebang-regex: 3.0.0

  shebang-regex@1.0.0: {}

  shebang-regex@3.0.0: {}

  side-channel@1.0.6:
    dependencies:
      call-bind: 1.0.7
      es-errors: 1.3.0
      get-intrinsic: 1.2.4
      object-inspect: 1.13.2

  siginfo@2.0.0: {}

  signal-exit@3.0.7: {}

  signal-exit@4.1.0: {}

  slash@3.0.0: {}

  slice-ansi@5.0.0:
    dependencies:
      ansi-styles: 6.2.1
      is-fullwidth-code-point: 4.0.0

  slice-ansi@7.1.0:
    dependencies:
      ansi-styles: 6.2.1
      is-fullwidth-code-point: 5.0.0

  snake-case@3.0.4:
    dependencies:
      dot-case: 3.0.4
      tslib: 2.6.3

  snakecase-keys@8.0.1:
    dependencies:
      map-obj: 4.3.0
      snake-case: 3.0.4
      type-fest: 4.24.0

  sonic-boom@4.0.1:
    dependencies:
      atomic-sleep: 1.0.0

  source-map-js@1.2.0: {}

  source-map-js@1.2.1: {}

  source-map-support@0.5.21:
    dependencies:
      buffer-from: 1.1.2
      source-map: 0.6.1

  source-map@0.6.1: {}

  source-map@0.7.4: {}

  source-map@0.8.0-beta.0:
    dependencies:
      whatwg-url: 7.1.0

  spawndamnit@2.0.0:
    dependencies:
      cross-spawn: 5.1.0
      signal-exit: 3.0.7

  split2@4.2.0: {}

  sprintf-js@1.0.3: {}

  stackback@0.0.2: {}

  std-env@3.7.0: {}

  std-env@3.8.0: {}

  string-argv@0.3.2: {}

  string-width@4.2.3:
    dependencies:
      emoji-regex: 8.0.0
      is-fullwidth-code-point: 3.0.0
      strip-ansi: 6.0.1

  string-width@5.1.2:
    dependencies:
      eastasianwidth: 0.2.0
      emoji-regex: 9.2.2
      strip-ansi: 7.1.0

  string-width@7.2.0:
    dependencies:
      emoji-regex: 10.3.0
      get-east-asian-width: 1.2.0
      strip-ansi: 7.1.0

  string_decoder@1.3.0:
    dependencies:
      safe-buffer: 5.2.1

  strip-ansi@6.0.1:
    dependencies:
      ansi-regex: 5.0.1

  strip-ansi@7.1.0:
    dependencies:
      ansi-regex: 6.0.1

  strip-bom@3.0.0: {}

  strip-final-newline@3.0.0: {}

  strip-json-comments@3.1.1: {}

  sucrase@3.35.0:
    dependencies:
      '@jridgewell/gen-mapping': 0.3.5
      commander: 4.1.1
      glob: 10.4.5
      lines-and-columns: 1.2.4
      mz: 2.7.0
      pirates: 4.0.6
      ts-interface-checker: 0.1.13

  superagent@8.1.2:
    dependencies:
      component-emitter: 1.3.1
      cookiejar: 2.1.4
      debug: 4.3.5
      fast-safe-stringify: 2.1.1
      form-data: 4.0.0
      formidable: 2.1.2
      methods: 1.1.2
      mime: 2.6.0
      qs: 6.12.3
      semver: 7.6.3
    transitivePeerDependencies:
      - supports-color

  supertest@6.3.4:
    dependencies:
      methods: 1.1.2
      superagent: 8.1.2
    transitivePeerDependencies:
      - supports-color

  supports-color@5.5.0:
    dependencies:
      has-flag: 3.0.0

  supports-color@7.2.0:
    dependencies:
      has-flag: 4.0.0

  supports-color@8.1.1:
    dependencies:
      has-flag: 4.0.0

  symbol-observable@4.0.0: {}

  tapable@2.2.1: {}

  term-size@2.2.1: {}

  terser-webpack-plugin@5.3.10(@swc/core@1.7.11)(esbuild@0.24.2)(webpack@5.92.1(@swc/core@1.7.11)(esbuild@0.24.2)):
    dependencies:
      '@jridgewell/trace-mapping': 0.3.25
      jest-worker: 27.5.1
      schema-utils: 3.3.0
      serialize-javascript: 6.0.2
      terser: 5.31.3
      webpack: 5.92.1(@swc/core@1.7.11)(esbuild@0.24.2)
    optionalDependencies:
      '@swc/core': 1.7.11
      esbuild: 0.24.2

  terser@5.31.3:
    dependencies:
      '@jridgewell/source-map': 0.3.6
      acorn: 8.12.1
      commander: 2.20.3
      source-map-support: 0.5.21

  test-exclude@7.0.1:
    dependencies:
      '@istanbuljs/schema': 0.1.3
      glob: 10.4.5
      minimatch: 9.0.5

  text-table@0.2.0: {}

  thenify-all@1.6.0:
    dependencies:
      thenify: 3.3.1

  thenify@3.3.1:
    dependencies:
      any-promise: 1.3.0

  thread-stream@3.1.0:
    dependencies:
      real-require: 0.2.0

  through@2.3.8: {}

  tinybench@2.9.0: {}

  tinyexec@0.3.2: {}

  tinyglobby@0.2.10:
    dependencies:
      fdir: 6.4.2(picomatch@4.0.2)
      picomatch: 4.0.2

  tinypool@1.0.2: {}

  tinyrainbow@1.2.0: {}

  tinyspy@3.0.2: {}

  tmp@0.0.33:
    dependencies:
      os-tmpdir: 1.0.2

  to-fast-properties@2.0.0: {}

  to-regex-range@5.0.1:
    dependencies:
      is-number: 7.0.0

  toad-cache@3.7.0: {}

  tr46@0.0.3: {}

  tr46@1.0.1:
    dependencies:
      punycode: 2.3.1

  tree-kill@1.2.2: {}

  ts-api-utils@1.3.0(typescript@5.4.3):
    dependencies:
      typescript: 5.4.3

  ts-interface-checker@0.1.13: {}

  ts-loader@9.5.1(typescript@5.5.3)(webpack@5.92.1(@swc/core@1.7.11)(esbuild@0.24.2)):
    dependencies:
      chalk: 4.1.2
      enhanced-resolve: 5.17.0
      micromatch: 4.0.7
      semver: 7.6.3
      source-map: 0.7.4
      typescript: 5.5.3
      webpack: 5.92.1(@swc/core@1.7.11)(esbuild@0.24.2)

  ts-node@10.9.2(@swc/core@1.7.11)(@types/node@20.14.11)(typescript@5.5.3):
    dependencies:
      '@cspotcode/source-map-support': 0.8.1
      '@tsconfig/node10': 1.0.11
      '@tsconfig/node12': 1.0.11
      '@tsconfig/node14': 1.0.3
      '@tsconfig/node16': 1.0.4
      '@types/node': 20.14.11
      acorn: 8.12.1
      acorn-walk: 8.3.3
      arg: 4.1.3
      create-require: 1.1.1
      diff: 4.0.2
      make-error: 1.3.6
      typescript: 5.5.3
      v8-compile-cache-lib: 3.0.1
      yn: 3.1.1
    optionalDependencies:
      '@swc/core': 1.7.11

  tsconfig-paths-webpack-plugin@4.1.0:
    dependencies:
      chalk: 4.1.2
      enhanced-resolve: 5.17.0
      tsconfig-paths: 4.2.0

  tsconfig-paths@4.2.0:
    dependencies:
      json5: 2.2.3
      minimist: 1.2.8
      strip-bom: 3.0.0

  tslib@2.3.1: {}

  tslib@2.6.3: {}

  tsup@8.3.5(@swc/core@1.7.11)(postcss@8.5.2)(tsx@4.16.3)(typescript@5.4.3)(yaml@2.6.1):
    dependencies:
      bundle-require: 5.0.0(esbuild@0.24.2)
      cac: 6.7.14
      chokidar: 4.0.3
      consola: 3.2.3
      debug: 4.4.0
      esbuild: 0.24.2
      joycon: 3.1.1
      picocolors: 1.1.1
      postcss-load-config: 6.0.1(postcss@8.5.2)(tsx@4.16.3)(yaml@2.6.1)
      resolve-from: 5.0.0
      rollup: 4.30.0
      source-map: 0.8.0-beta.0
      sucrase: 3.35.0
      tinyexec: 0.3.2
      tinyglobby: 0.2.10
      tree-kill: 1.2.2
    optionalDependencies:
      '@swc/core': 1.7.11
      postcss: 8.5.2
      typescript: 5.4.3
    transitivePeerDependencies:
      - jiti
      - supports-color
      - tsx
      - yaml

  tsx@4.16.3:
    dependencies:
      esbuild: 0.21.5
      get-tsconfig: 4.7.6
    optionalDependencies:
      fsevents: 2.3.3

  type-check@0.4.0:
    dependencies:
      prelude-ls: 1.2.1

  type-fest@0.20.2: {}

  type-fest@0.21.3: {}

  type-fest@1.4.0: {}

  type-fest@4.24.0: {}

  typeforce@1.18.0: {}

  typescript@5.3.3: {}

  typescript@5.4.3: {}

  typescript@5.5.3: {}

  uid@2.0.2:
    dependencies:
      '@lukeed/csprng': 1.1.0

  undici-types@5.26.5: {}

  universalify@0.1.2: {}

  universalify@2.0.1: {}

  unplugin-swc@1.5.1(@swc/core@1.7.11)(rollup@4.34.7):
    dependencies:
      '@rollup/pluginutils': 5.1.0(rollup@4.34.7)
      '@swc/core': 1.7.11
      load-tsconfig: 0.2.5
      unplugin: 1.12.1
    transitivePeerDependencies:
      - rollup

  unplugin@1.12.1:
    dependencies:
      acorn: 8.12.1
      chokidar: 3.6.0
      webpack-sources: 3.2.3
      webpack-virtual-modules: 0.6.2

  update-browserslist-db@1.1.0(browserslist@4.23.2):
    dependencies:
      browserslist: 4.23.2
      escalade: 3.1.2
      picocolors: 1.0.1

  uri-js@4.4.1:
    dependencies:
      punycode: 2.3.1

  util-deprecate@1.0.2: {}

  uuid@8.3.2: {}

  v8-compile-cache-lib@3.0.1: {}

  varuint-bitcoin@1.1.2:
    dependencies:
      safe-buffer: 5.2.1

  vite-node@2.1.9(@types/node@20.14.11)(terser@5.31.3):
    dependencies:
      cac: 6.7.14
      debug: 4.4.0
      es-module-lexer: 1.6.0
      pathe: 1.1.2
      vite: 5.4.14(@types/node@20.14.11)(terser@5.31.3)
    transitivePeerDependencies:
      - '@types/node'
      - less
      - lightningcss
      - sass
      - sass-embedded
      - stylus
      - sugarss
      - supports-color
      - terser

  vite@5.4.14(@types/node@20.14.11)(terser@5.31.3):
    dependencies:
      esbuild: 0.21.5
      postcss: 8.5.2
      rollup: 4.34.7
    optionalDependencies:
      '@types/node': 20.14.11
      fsevents: 2.3.3
      terser: 5.31.3

  vitest@2.1.9(@types/node@20.14.11)(terser@5.31.3):
    dependencies:
      '@vitest/expect': 2.1.9
      '@vitest/mocker': 2.1.9(vite@5.4.14(@types/node@20.14.11)(terser@5.31.3))
      '@vitest/pretty-format': 2.1.9
      '@vitest/runner': 2.1.9
      '@vitest/snapshot': 2.1.9
      '@vitest/spy': 2.1.9
      '@vitest/utils': 2.1.9
      chai: 5.1.2
      debug: 4.4.0
      expect-type: 1.1.0
      magic-string: 0.30.17
      pathe: 1.1.2
      std-env: 3.8.0
      tinybench: 2.9.0
      tinyexec: 0.3.2
      tinypool: 1.0.2
      tinyrainbow: 1.2.0
      vite: 5.4.14(@types/node@20.14.11)(terser@5.31.3)
      vite-node: 2.1.9(@types/node@20.14.11)(terser@5.31.3)
      why-is-node-running: 2.3.0
    optionalDependencies:
      '@types/node': 20.14.11
    transitivePeerDependencies:
      - less
      - lightningcss
      - msw
      - sass
      - sass-embedded
      - stylus
      - sugarss
      - supports-color
      - terser

  watchpack@2.4.1:
    dependencies:
      glob-to-regexp: 0.4.1
      graceful-fs: 4.2.11

  wcwidth@1.0.1:
    dependencies:
      defaults: 1.0.4

  webidl-conversions@3.0.1: {}

  webidl-conversions@4.0.2: {}

  webpack-node-externals@3.0.0: {}

  webpack-sources@3.2.3: {}

  webpack-virtual-modules@0.6.2: {}

  webpack@5.92.1(@swc/core@1.7.11)(esbuild@0.24.2):
    dependencies:
      '@types/eslint-scope': 3.7.7
      '@types/estree': 1.0.5
      '@webassemblyjs/ast': 1.12.1
      '@webassemblyjs/wasm-edit': 1.12.1
      '@webassemblyjs/wasm-parser': 1.12.1
      acorn: 8.12.1
      acorn-import-attributes: 1.9.5(acorn@8.12.1)
      browserslist: 4.23.2
      chrome-trace-event: 1.0.4
      enhanced-resolve: 5.17.0
      es-module-lexer: 1.5.4
      eslint-scope: 5.1.1
      events: 3.3.0
      glob-to-regexp: 0.4.1
      graceful-fs: 4.2.11
      json-parse-even-better-errors: 2.3.1
      loader-runner: 4.3.0
      mime-types: 2.1.35
      neo-async: 2.6.2
      schema-utils: 3.3.0
      tapable: 2.2.1
      terser-webpack-plugin: 5.3.10(@swc/core@1.7.11)(esbuild@0.24.2)(webpack@5.92.1(@swc/core@1.7.11)(esbuild@0.24.2))
      watchpack: 2.4.1
      webpack-sources: 3.2.3
    transitivePeerDependencies:
      - '@swc/core'
      - esbuild
      - uglify-js

  whatwg-url@5.0.0:
    dependencies:
      tr46: 0.0.3
      webidl-conversions: 3.0.1

  whatwg-url@7.1.0:
    dependencies:
      lodash.sortby: 4.7.0
      tr46: 1.0.1
      webidl-conversions: 4.0.2

  which-pm@2.2.0:
    dependencies:
      load-yaml-file: 0.2.0
      path-exists: 4.0.0

  which@1.3.1:
    dependencies:
      isexe: 2.0.0

  which@2.0.2:
    dependencies:
      isexe: 2.0.0

  why-is-node-running@2.3.0:
    dependencies:
      siginfo: 2.0.0
      stackback: 0.0.2

  wif@2.0.6:
    dependencies:
      bs58check: 2.1.2

  word-wrap@1.2.5: {}

  wrap-ansi@6.2.0:
    dependencies:
      ansi-styles: 4.3.0
      string-width: 4.2.3
      strip-ansi: 6.0.1

  wrap-ansi@7.0.0:
    dependencies:
      ansi-styles: 4.3.0
      string-width: 4.2.3
      strip-ansi: 6.0.1

  wrap-ansi@8.1.0:
    dependencies:
      ansi-styles: 6.2.1
      string-width: 5.1.2
      strip-ansi: 7.1.0

  wrap-ansi@9.0.0:
    dependencies:
      ansi-styles: 6.2.1
      string-width: 7.2.0
      strip-ansi: 7.1.0

  wrappy@1.0.2: {}

  yallist@2.1.2: {}

  yaml@2.6.1: {}

  yargs-parser@21.1.1: {}

  yn@3.1.1: {}

  yocto-queue@0.1.0: {}

  zod@3.23.8: {}

  zx@8.1.4:
    optionalDependencies:
      '@types/fs-extra': 11.0.4
      '@types/node': 20.14.11


================================================
File: pnpm-workspace.yaml
================================================
packages:
  - "packages/*"
  - "apps/*"
  - "examples/*"
  - "tests/*"


================================================
File: vitest.config.mts
================================================
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    watch: false,
    reporters: ['verbose'],
  },
});


================================================
File: vitest.workspace.mts
================================================
export default [
  'packages/*',
  'apps/*',
];


================================================
File: .dockerignore
================================================
node_modules
.git
.gitignore
*.md
tests
examples
dist


================================================
File: .eslintrc.json
================================================
{
  "env": {
    "browser": true,
    "es2021": true
  },
  "ignorePatterns": ["dist/"],
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended"
  ],
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "ecmaVersion": "latest",
    "sourceType": "module"
  },
  "plugins": [
    "@typescript-eslint"
  ],
  "rules": {
  }
}


================================================
File: .prettierignore
================================================
# editors
**/.git
**/.idea
**/.vscode

# dependencies
**/node_modules
**/.pnp.js
**/.pnp

# testing
**/coverage

# production
**/dist
**/build
**/tsconfig.tsbuildinfo

# misc
**/.DS_Store
**/.env.local
**/.env.development.local
**/.env.test.local
**/.env.production.local

**/npm-debug.log*
**/yarn-debug.log*
**/yarn-error.log*

# moleculec
**/*.mol

# generated typing
**/.next
**/next-env.d.ts
**/auto-imports.d.ts
**/vite-imports.d.ts


================================================
File: .prettierrc
================================================
{
  "semi": true,
  "tabWidth": 2,
  "useTabs": false,
  "singleQuote": true,
  "jsxSingleQuote": false,
  "trailingComma": "all",
  "endOfLine": "lf",
  "printWidth": 120
}


================================================
File: apps/service/README.md
================================================
# RGB++ SDK Service

A RPC service for Wrapping essential RGB++ Assets Operations(**only support RGB++ Transfer on BTC now**) with [rgbpp-sdk](https://github.com/ckb-cell/rgbpp-sdk) for other programming languages to quickly manage RGB++ Assets.

## Quick Start

### Clone rgbpp-sdk repository

```shell
$ git clone https://github.com/ckb-cell/rgbpp-sdk.git
$ pnpm install
$ cd apps/service
```

### Update Environment Variables

Copy the `.env.example` file to `.env`:

```shell
$ cp .env.example .env
```

Update the configuration values:

```yml
# The network includes testnet and mainnet, the default value is testnet
NETWORK=testnet  # or mainnet

# The Bitcoin Testnet type includs Testnet3 and Signet, the default value is Signet
# Testnet3: https://mempool.space/testnet
# Signet: https://mempool.space/signet
BTC_TESTNET_TYPE=Signet

# CKB node url which should match NETWORK
CKB_RPC_URL=https://testnet.ckb.dev

# The BTC assets api url which should match NETWORK and BTC_TESTNET_TYPE
# The BTC Testnet Service url is: https://api.testnet.rgbpp.io
# The BTC Signet Service url is: https://api.signet.rgbpp.io
BTC_SERVICE_URL=hhttps://api.signet.rgbpp.io

# The BTC assets api token which should match NETWORK and BTC_TESTNET_TYPE
# To get an access token, please refer to https://github.com/ckb-cell/rgbpp-sdk/tree/develop/packages/service#get-an-access-token
BTC_SERVICE_TOKEN=

# The BTC assets api origin which should match `BTC_SERVICE_TOKEN`
# JWT Debugger: https://jwt.io
BTC_SERVICE_ORIGIN=https://btc-test.app
```

### Run RGB++ SDK Service

```shell
# Debug environment
$ pnpm start:dev

# Production environment
$ pnpm start:prod
```

## Deploy and Manage RGB++ SDK Service

### 1. Use a process manager like PM2

- Install PM2

```shell
$ npm install -g pm2
```

- Start RGB++ SDK Service with PM2

```
$ pm2 start dist/src/main.js --name rgbpp-sdk-service
```

### 2. Use Docker

- Copy the `.env.example` file to `.env` and Update the configuration values

- Use the provided `docker-compose.yml` file to run the service:

```bash
$ docker-compose up
```

### 3. Deploy to Vercel

[![Deploy with Vercel](https://vercel.com/button)](https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fckb-cell%2Frgbpp-sdk%2Ftree%2Fmain%2Fapps%2Fservice&env=NETWORK,CKB_RPC_URL,BTC_SERVICE_URL,BTC_SERVICE_TOKEN,BTC_SERVICE_ORIGIN&project-name=rgbpp-sdk-service&repository-name=rgbpp-sdk)


================================================
File: apps/service/docker-compose.yml
================================================
version: '3.8'

services:
  rgbpp-sdk-service:
    build:
      context: ../..
      target: service
    # image: ghcr.io/ckb-cell/rgbpp-sdk-service:develop
    ports:
      - '3000:3000'
    env_file:
      - .env



================================================
File: apps/service/nest-cli.json
================================================
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}


================================================
File: apps/service/package.json
================================================
{
  "name": "rgbpp-sdk-service",
  "version": "0.0.1",
  "private": true,
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\"",
    "dev": "pnpm run start:dev",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/src/main",
    "lint": "eslint \"src/**/*.ts\" --fix",
    "test": "vitest",
    "test:watch": "vitest --watch",
    "test:cov": "vitest run --coverage",
    "test:debug": "vitest --inspect-brk --inspect --logHeapUsage --threads=false"
  },
  "dependencies": {
    "@nestjs/common": "^10.0.0",
    "@nestjs/config": "^3.2.2",
    "@nestjs/core": "^10.3.9",
    "@nestjs/platform-fastify": "^10.3.9",
    "camelcase-keys": "^7.0.2",
    "json-rpc-2.0": "^1.7.0",
    "lodash": "^4.17.21",
    "reflect-metadata": "^0.2.0",
    "rgbpp": "workspace:*",
    "rxjs": "^7.8.1",
    "snakecase-keys": "^8.0.1",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@nestjs/cli": "^10.0.0",
    "@nestjs/schematics": "^10.0.0",
    "@nestjs/testing": "^10.0.0",
    "@swc/core": "^1.7.11",
    "@types/node": "^20.3.1",
    "@types/supertest": "^6.0.0",
    "@vitest/coverage-v8": "^2.0.5",
    "source-map-support": "^0.5.21",
    "supertest": "^6.3.3",
    "ts-loader": "^9.4.3",
    "ts-node": "^10.9.1",
    "tsconfig-paths": "^4.2.0",
    "type-fest": "^4.24.0",
    "typescript": "^5.1.3",
    "unplugin-swc": "^1.5.1"
  }
}


================================================
File: apps/service/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}


================================================
File: apps/service/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "NodeNext",
    "declaration": true,
    "resolveJsonModule": true,
    "removeComments": true,
    "moduleResolution": "NodeNext",
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": false,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "forceConsistentCasingInFileNames": false,
    "noFallthroughCasesInSwitch": false
  },
  "exclude": ["dist"]
}


================================================
File: apps/service/vitest.project.mts
================================================
import swc from 'unplugin-swc';
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    root: './',
  },
  plugins: [
    // This is required to build the test files with SWC
    swc.vite({
      // Explicitly set the module type to avoid inheriting this value from a `.swcrc` config file
      module: { type: 'es6' },
    }),
  ],
});


================================================
File: apps/service/.env.example
================================================
# The network includes testnet and mainnet, the default value is testnet
NETWORK=testnet

# The Bitcoin Testnet type including Testnet3 and Signet, default value is Signet
# Testnet3: https://mempool.space/testnet
# Signet: https://mempool.space/signet
BTC_TESTNET_TYPE=Signet

# CKB node url which should match NETWORK
CKB_RPC_URL=https://testnet.ckb.dev

# The BTC assets api url which should match NETWORK
# The BTC Testnet Service url is: https://api.testnet.rgbpp.io
# The BTC Signet Service url is: https://api.signet.rgbpp.io
BTC_SERVICE_URL=https://api.signet.rgbpp.io

# The BTC assets api token which should match NETWORK and BTC_TESTNET_TYPE
# To get an access token, please refer to https://github.com/ckb-cell/rgbpp-sdk/tree/develop/packages/service#get-an-access-token
BTC_SERVICE_TOKEN=

# The BTC assets api origin which should match `BTC_SERVICE_TOKEN`
# JWT Debugger: https://jwt.io
BTC_SERVICE_ORIGIN=https://btc-test.app


================================================
File: apps/service/.gitignore
================================================
# compiled output
/dist
/node_modules
/build

# Logs
logs
*.log
npm-debug.log*
pnpm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# temp directory
.temp
.tmp

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json


================================================
File: apps/service/src/app.module.ts
================================================
import { Global, Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { BtcAssetsApi } from 'rgbpp/service';
import { BTCTestnetType, Collector } from 'rgbpp/ckb';
import JsonRpcModule from './json-rpc/json-rpc.module';
import { RgbppModule } from './rgbpp/rgbpp.module';
import { AppService } from './app.service';
import { envSchema } from './env';

@Global()
@Module({
  imports: [
    ConfigModule.forRoot({
      validate: envSchema.parse,
      envFilePath: ['.env', '.env.local'],
    }),
    JsonRpcModule.forRoot({
      path: '/json-rpc',
    }),
    RgbppModule,
  ],
  providers: [
    AppService,
    {
      provide: 'IS_MAINNET',
      useFactory: (configService: ConfigService): boolean => configService.get('NETWORK') === 'mainnet',
      inject: [ConfigService],
    },
    {
      provide: 'BTC_TESTNET_TYPE',
      useFactory: (configService: ConfigService): BTCTestnetType => configService.get('BTC_TESTNET_TYPE'),
      inject: [ConfigService],
    },
    {
      provide: 'CKB_COLLECTOR',
      useFactory: (configService: ConfigService) => {
        const ckbRpcUrl = configService.get('CKB_RPC_URL');
        return new Collector({
          ckbIndexerUrl: ckbRpcUrl,
          ckbNodeUrl: ckbRpcUrl,
        });
      },
      inject: [ConfigService],
    },
    {
      provide: 'BTC_ASSETS_API',
      useFactory: (configService: ConfigService) => {
        const url = configService.get('BTC_SERVICE_URL');
        const token = configService.get('BTC_SERVICE_TOKEN');
        const origin = configService.get('BTC_SERVICE_ORIGIN');
        return BtcAssetsApi.fromToken(url, token, origin);
      },
      inject: [ConfigService],
    },
  ],
  exports: ['IS_MAINNET', 'CKB_COLLECTOR', 'BTC_ASSETS_API', 'BTC_TESTNET_TYPE'],
})
export class AppModule {}


================================================
File: apps/service/src/app.service.ts
================================================
import { RpcHandler, RpcMethodHandler } from './json-rpc/json-rpc.decorators.js';
import pkg from '../package.json';

@RpcHandler()
export class AppService {
  @RpcMethodHandler({ name: 'get_version' })
  public getAppVersion(): string {
    return pkg.version;
  }
}


================================================
File: apps/service/src/env.ts
================================================
import z from 'zod';

export const envSchema = z.object({
  NETWORK: z.enum(['mainnet', 'testnet']).default('testnet'),
  CKB_RPC_URL: z.string().default('https://testnet.ckb.dev'),

  BTC_SERVICE_URL: z.string(),
  BTC_SERVICE_TOKEN: z.string(),
  BTC_SERVICE_ORIGIN: z.string(),
  BTC_TESTNET_TYPE: z.string().default('Testnet3'),
});


================================================
File: apps/service/src/main.ts
================================================
import { Logger } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import { FastifyAdapter, NestFastifyApplication } from '@nestjs/platform-fastify';
import { AppModule } from './app.module';

async function bootstrap() {
  const logger = new Logger('AppBootstrap');
  const app = await NestFactory.create<NestFastifyApplication>(AppModule, new FastifyAdapter(), {
    cors: true,
  });
  await app.listen(3000, '0.0.0.0');
  logger.log('Application is running on: http://0.0.0.0:3000');
}
bootstrap();


================================================
File: apps/service/src/json-rpc/json-rpc.decorators.ts
================================================
import { applyDecorators, Injectable, InjectableOptions, SetMetadata } from '@nestjs/common';

export const JsonRpcMetadataKey = '__json-rpc@metadata__';
export interface JsonRpcMetadata {
  name?: string;
}

export const JsonRpcMethodMetadataKey = '__json-rpc-method@metadata__';
export interface JsonRpcMethodMetadata {
  name?: string;
}

export const RpcHandler = (data?: JsonRpcMetadata & InjectableOptions) => {
  const { name, scope } = data ?? {};
  return applyDecorators(SetMetadata(JsonRpcMetadataKey, name ? { name } : {}), Injectable({ scope }));
};

export const RpcMethodHandler = (data?: JsonRpcMethodMetadata) => {
  return applyDecorators(SetMetadata(JsonRpcMethodMetadataKey, data ?? {}));
};


================================================
File: apps/service/src/json-rpc/json-rpc.module.ts
================================================
import { Inject, Logger, Module, OnModuleInit } from '@nestjs/common';
import { JsonRpcServer } from './json-rpc.server';

export const JSON_RPC_OPTIONS = '__JSON_RPC_OPTIONS__';

export interface JsonRpcConfig {
  path: string;
}

@Module({})
export class JsonRpcModule implements OnModuleInit {
  private logger = new Logger(JsonRpcModule.name);

  constructor(
    @Inject(JSON_RPC_OPTIONS) private config: JsonRpcConfig,
    private jsonRpcServer: JsonRpcServer,
  ) {}

  public static forRoot(config: JsonRpcConfig) {
    return {
      module: JsonRpcModule,
      providers: [
        {
          provide: JSON_RPC_OPTIONS,
          useValue: config,
        },
        JsonRpcServer,
      ],
    };
  }

  public async onModuleInit() {
    await this.jsonRpcServer.resolve();
    this.jsonRpcServer.run(this.config);
    this.logger.log(`JSON-RPC server is running on ${this.config.path}`);
  }
}

export default JsonRpcModule;


================================================
File: apps/service/src/json-rpc/json-rpc.server.ts
================================================
import { Injectable, Logger } from '@nestjs/common';
import { HttpAdapterHost, ModuleRef, ModulesContainer } from '@nestjs/core';
import { JSONRPCServer, SimpleJSONRPCMethod } from 'json-rpc-2.0';
import { InstanceWrapper } from '@nestjs/core/injector/instance-wrapper';
import { JsonRpcMetadataKey, JsonRpcMethodMetadataKey } from './json-rpc.decorators';
import { JsonRpcConfig } from './json-rpc.module';

class JsonRpcServerError extends Error {
  constructor(message: string) {
    super(message);
  }
}

@Injectable()
export class JsonRpcServer {
  private server: JSONRPCServer;
  private logger = new Logger(JsonRpcServer.name);

  constructor(
    private httpAdapterHost: HttpAdapterHost,
    private modulesContainer: ModulesContainer,
    private moduleRef: ModuleRef,
  ) {
    this.server = new JSONRPCServer();
  }

  private getRegisteredHandlers() {
    const modules = [...this.modulesContainer.values()];
    const wrappers = modules.reduce(
      (providers, module) => providers.concat([...module.providers.values()]),
      [] as InstanceWrapper<unknown>[],
    );

    const rpcHandlers = new Map<string, SimpleJSONRPCMethod<unknown>>();
    wrappers.forEach((wrapper) => {
      const { instance } = wrapper;
      if (!instance) {
        return;
      }
      const metadata = Reflect.getMetadata(JsonRpcMetadataKey, instance.constructor);
      if (!metadata) {
        return;
      }

      const properties = Object.getOwnPropertyNames(Object.getPrototypeOf(instance));
      properties.forEach((methodName) => {
        const methodMetadata = Reflect.getMetadata(JsonRpcMethodMetadataKey, instance[methodName]);
        if (!methodMetadata) {
          return;
        }
        const name = metadata.name
          ? `${metadata.name}.${methodMetadata.name ?? methodName}`
          : (methodMetadata.name ?? methodName);
        const handler = (params: unknown) => {
          const instanceRef = this.moduleRef.get(instance.constructor, { strict: false });
          return instanceRef[methodName](params);
        };
        if (rpcHandlers.has(name)) {
          throw new JsonRpcServerError(`Duplicate JSON-RPC method: ${name}`);
        }
        rpcHandlers.set(name, handler);
      });
    });
    return rpcHandlers;
  }

  public async resolve() {
    const handlers = this.getRegisteredHandlers();
    handlers.forEach((handler, name) => {
      this.logger.log(`Registering JSON-RPC method: ${name}`);
      this.server.addMethod(name, handler);
    });
  }

  public async run(config: JsonRpcConfig) {
    this.httpAdapterHost.httpAdapter.post(config.path, async (req, res) => {
      this.logger.debug(`Received JSON-RPC request: ${JSON.stringify(req.body)}`);
      const jsonRpcResponse = await this.server.receive(req.body);
      this.httpAdapterHost.httpAdapter.setHeader(res, 'Content-Type', 'application/json');
      this.httpAdapterHost.httpAdapter.reply(res, jsonRpcResponse);
    });
  }
}


================================================
File: apps/service/src/rgbpp/rgbpp.module.ts
================================================
import { Module } from '@nestjs/common';
import { RgbppService } from './rgbpp.service';

@Module({
  imports: [],
  providers: [RgbppService],
})
export class RgbppModule {}


================================================
File: apps/service/src/rgbpp/rgbpp.service.ts
================================================
import { Inject } from '@nestjs/common';
import { DataSource, NetworkType } from 'rgbpp/btc';
import { BtcAssetsApi, RgbppApiTransactionState } from 'rgbpp/service';
import { BTCTestnetType, Collector, Hex, append0x } from 'rgbpp/ckb';
import {
  buildRgbppTransferTx,
  buildRgbppTransferAllTxs,
  sendRgbppTxGroups,
  RgbppTxGroup,
  SentRgbppTxGroup,
} from 'rgbpp';
import { RpcHandler, RpcMethodHandler } from '../json-rpc/json-rpc.decorators.js';
import { toSnakeCase, toCamelCase, SnakeCased } from '../utils/case.js';
import {
  RgbppTransferReq,
  RgbppCkbBtcTransaction,
  RgbppCkbTxBtcTxId,
  RgbppStateReq,
  RgbppCkbTxHashReq,
  BtcTxSendReq,
  RgbppTransferAllReq,
  RgbppTransferAllResp,
} from './types.js';

@RpcHandler()
export class RgbppService {
  private readonly btcDataSource: DataSource;

  constructor(
    @Inject('IS_MAINNET') private isMainnet: boolean,
    @Inject('CKB_COLLECTOR') private ckbCollector: Collector,
    @Inject('BTC_ASSETS_API') private btcAssetsApi: BtcAssetsApi,
    @Inject('BTC_TESTNET_TYPE') private btcTestnetType: BTCTestnetType,
  ) {
    const networkType = isMainnet ? NetworkType.MAINNET : NetworkType.TESTNET;
    this.btcDataSource = new DataSource(btcAssetsApi, networkType);
  }

  @RpcMethodHandler({ name: 'generate_rgbpp_transfer_tx' })
  public async generateRgbppTransferTx(request: [RgbppTransferReq]): Promise<SnakeCased<RgbppCkbBtcTransaction>> {
    const params = toCamelCase(request[0]);
    const result = await buildRgbppTransferTx({
      ckb: {
        collector: this.ckbCollector,
        xudtTypeArgs: params.xudtTypeArgs,
        rgbppLockArgsList: params.rgbppLockArgsList,
        transferAmount: BigInt(params.transferAmount),
      },
      btc: {
        fromAddress: params.fromBtcAddress,
        toAddress: params.toBtcAddress,
        dataSource: this.btcDataSource,
        testnetType: this.btcTestnetType,
      },
      isMainnet: this.isMainnet,
    });

    return toSnakeCase<RgbppCkbBtcTransaction>({
      ckbVirtualTxResult: JSON.stringify(result.ckbVirtualTxResult),
      btcPsbtHex: result.btcPsbtHex,
    });
  }

  @RpcMethodHandler({ name: 'generate_rgbpp_transfer_all_txs' })
  public async generateRgbppTransferAllTxs(
    request: [RgbppTransferAllReq],
  ): Promise<SnakeCased<RgbppTransferAllResp>[]> {
    const params = toCamelCase(request[0]);
    const { transactions } = await buildRgbppTransferAllTxs({
      ckb: {
        collector: this.ckbCollector,
        xudtTypeArgs: params.ckb.xudtTypeArgs,
        feeRate: params.ckb.feeRate ? BigInt(append0x(params.ckb.feeRate)) : undefined,
      },
      btc: {
        assetAddresses: params.btc.assetAddresses,
        fromAddress: params.btc.fromAddress,
        toAddress: params.btc.toAddress,
        fromPubkey: params.btc.fromPubkey,
        pubkeyMap: params.btc.pubkeyMap,
        feeRate: params.btc.feeRate,
        dataSource: this.btcDataSource,
        testnetType: this.btcTestnetType,
      },
      isMainnet: this.isMainnet,
    });

    return transactions.map(({ ckb, btc }) =>
      toSnakeCase<RgbppTransferAllResp>({
        ckbVirtualTxResult: JSON.stringify(ckb.virtualTxResult),
        btcPsbtHex: btc.psbtHex,
        btcFeeRate: btc.feeRate,
        btcFee: btc.fee,
      }),
    );
  }

  @RpcMethodHandler({ name: 'report_rgbpp_ckb_tx_btc_txid' })
  public async reportRgbppCkbTxBtcTxId(request: [RgbppCkbTxBtcTxId]): Promise<SnakeCased<RgbppApiTransactionState>> {
    const { ckbVirtualTxResult, btcTxId } = toCamelCase(request[0]);
    const response = await this.btcAssetsApi.sendRgbppCkbTransaction({
      btc_txid: btcTxId,
      ckb_virtual_result: ckbVirtualTxResult,
    });
    return toSnakeCase<RgbppApiTransactionState>(response);
  }

  @RpcMethodHandler({ name: 'get_rgbpp_tx_state' })
  public async getRgbppTxState(request: [RgbppStateReq]): Promise<SnakeCased<RgbppApiTransactionState>> {
    const {
      btcTxId,
      params: { withData },
    } = toCamelCase(request[0]);
    const response = await this.btcAssetsApi.getRgbppTransactionState(btcTxId, { with_data: withData });
    return toSnakeCase<RgbppApiTransactionState>(response);
  }

  @RpcMethodHandler({ name: 'get_rgbpp_ckb_tx_hash' })
  public async getRgbppCkbTxHash(request: [RgbppCkbTxHashReq]): Promise<Hex> {
    const { btcTxId } = toCamelCase(request[0]);
    const { txhash: txHash } = await this.btcAssetsApi.getRgbppTransactionHash(btcTxId);
    return txHash;
  }

  @RpcMethodHandler({ name: 'send_btc_transaction' })
  public async sendBtcTransaction(request: [BtcTxSendReq]): Promise<Hex> {
    const { txHex } = toCamelCase(request[0]);
    const { txid } = await this.btcAssetsApi.sendBtcTransaction(txHex);
    return txid;
  }

  @RpcMethodHandler({ name: 'send_rgbpp_group_txs' })
  public async sendRgbppGroupTxs(request: [RgbppTxGroup[]]): Promise<SnakeCased<SentRgbppTxGroup>[]> {
    const txGroups = toCamelCase(request[0]);
    const sentGroups = await sendRgbppTxGroups({ txGroups, btcService: this.btcAssetsApi });
    const result = sentGroups.map((group) => toSnakeCase<SentRgbppTxGroup>(group));
    return result;
  }
}


================================================
File: apps/service/src/rgbpp/types.ts
================================================
import { AddressToPubkeyMap } from 'rgbpp/btc';
import { Hex } from 'rgbpp/ckb';

export interface RgbppTransferReq {
  // The transferred RGB++ xUDT type script args
  xudtTypeArgs: Hex;
  // The rgbpp assets cell lock script args array whose data structure is: out_index | btc_tx_id
  rgbppLockArgsList: string[];
  // The xUDT amount to be transferred
  transferAmount: Hex;
  // The sender BTC address
  fromBtcAddress: string;
  // The receiver BTC address
  toBtcAddress: string;
}

export interface RgbppCkbBtcTransaction {
  // The JSON string for the `BtcTransferVirtualTxResult`
  ckbVirtualTxResult: string;
  // The BTC PSBT hex string which can be used to construct Bitcoin PSBT
  btcPsbtHex: Hex;
}

export interface RgbppCkbTxBtcTxId {
  // The JSON string for the `BtcTransferVirtualTxResult`
  ckbVirtualTxResult: string;
  // The BTC transaction id of the RGB++ operations
  btcTxId: Hex;
}

export interface RgbppStateReq {
  btcTxId: Hex;
  params?: {
    withData?: boolean;
  };
}

export interface RgbppCkbTxHashReq {
  btcTxId: Hex;
}

export interface BtcTxSendReq {
  txHex: Hex;
}

export interface RgbppTransferAllReq {
  ckb: {
    // The transferred RGB++ xUDT type script args
    xudtTypeArgs: Hex;
    // The CKB transaction fee rate in hex format, default value is 0x44c (1100)
    feeRate?: Hex;
  };
  btc: {
    // The list of BTC addresses to provide RGB++ xUDT assets
    // All available amounts of the target asset (specified by ckb.xudtTypeArgs) will be included in the transfers
    // However, if more than 40 cells are bound to the same UTXO, the amounts within those 40 cells are excluded
    assetAddresses: string[];
    // The BTC address for paying all the transaction costs, but not provide any RGB++ assets
    fromAddress: string;
    // The BTC address for receiving all the RGB++ assets
    toAddress: string;
    // The public key of sender BTC address, must fill if the fromAddress is a P2TR address
    fromPubkey?: string;
    // The map helps find the corresponding public key of a BTC address,
    // note that you must specify a pubkey for each P2TR address in assetAddresses/fromAddress
    pubkeyMap?: AddressToPubkeyMap;
    // The BTC address to return change satoshi, default value is fromAddress
    changeAddress?: string;
    // The fee rate of the BTC transactions, will use the fastest fee rate if not specified
    feeRate?: number;
  };
}

export interface RgbppTransferAllResp {
  ckbVirtualTxResult: string;
  btcPsbtHex: string;
  btcFeeRate: number;
  btcFee: number;
}


================================================
File: apps/service/src/utils/case.ts
================================================
import type { SnakeCasedPropertiesDeep, CamelCasedPropertiesDeep } from 'type-fest';
import snakeCaseKeys from 'snakecase-keys';
import camelCaseKeys from 'camelcase-keys';

export type SnakeCased<T> = SnakeCasedPropertiesDeep<T>;
export type CamelCased<T> = CamelCasedPropertiesDeep<T>;

// This regex is used to exclude hex strings from being converted to snake_case or camelCase
// Because hex strings in object keys should be kept as is
const excludeHexRegex = /^0x.+/g;

export function toSnakeCase<T extends object>(obj: T, options?: snakeCaseKeys.Options): SnakeCased<T> {
  return snakeCaseKeys(obj as Record<string, unknown>, {
    exclude: [excludeHexRegex],
    deep: true,
    ...options,
  }) as SnakeCased<T>;
}

export function toCamelCase<T>(obj: T, options?: camelCaseKeys.Options): CamelCased<T> {
  return camelCaseKeys(obj as Record<string, unknown>, {
    exclude: [excludeHexRegex],
    deep: true,
    ...options,
  }) as CamelCased<T>;
}


================================================
File: apps/service/src/utils/json.ts
================================================
import isPlainObject from 'lodash/isPlainObject';

export function ensureSafeJson<Input extends object, Output = Input>(json: Input): Output {
  if (!isPlainObject(json) && !Array.isArray(json)) {
    return json as unknown as Output;
  }

  const obj = Array.isArray(json) ? [] : {};
  for (const key of Object.keys(json)) {
    const value = json[key];
    if (isPlainObject(value) || Array.isArray(value)) {
      obj[key] = ensureSafeJson(value);
    } else {
      // XXX: Convert BigInt to hex string for JSON.stringify() compatibility
      if (typeof value === 'bigint') {
        obj[key] = `0x${value.toString(16)}`;
      } else {
        obj[key] = value;
      }
    }
  }

  return obj as unknown as Output;
}


================================================
File: apps/service/tests/Utils.test.ts
================================================
import { describe, it, expect } from 'vitest';
import { ensureSafeJson } from '../src/utils/json';
import { toSnakeCase, toCamelCase } from '../src/utils/case';

describe('Utils', () => {
  it('toSnakeCase()', () => {
    expect(
      toSnakeCase({
        misterA: 1,
        MisterB: 2,
        mister_C: 3,
        '0x06c1c265d475e69bac3b42f8deca5ac982efabfa640eff96a0f5d15345583e6e': 4,
      }),
    ).toStrictEqual({
      mister_a: 1,
      mister_b: 2,
      mister_c: 3,
      '0x06c1c265d475e69bac3b42f8deca5ac982efabfa640eff96a0f5d15345583e6e': 4,
    });
    expect(
      toSnakeCase([
        {
          misterA: 1,
          MisterB: 2,
          mister_C: 3,
          '0x06c1c265d475e69bac3b42f8deca5ac982efabfa640eff96a0f5d15345583e6e': 4,
        },
      ]),
    ).toStrictEqual([
      {
        mister_a: 1,
        mister_b: 2,
        mister_c: 3,
        '0x06c1c265d475e69bac3b42f8deca5ac982efabfa640eff96a0f5d15345583e6e': 4,
      },
    ]);
  });
  it('toCamelCase()', () => {
    expect(
      toCamelCase({
        misterA: 1,
        mister_b: 2,
        MisterC: 3,
        '0x06c1c265d475e69bac3b42f8deca5ac982efabfa640eff96a0f5d15345583e6e': 4,
      }),
    ).toStrictEqual({
      misterA: 1,
      misterB: 2,
      misterC: 3,
      '0x06c1c265d475e69bac3b42f8deca5ac982efabfa640eff96a0f5d15345583e6e': 4,
    });
    expect(
      toCamelCase([
        {
          misterA: 1,
          mister_b: 2,
          MisterC: 3,
          '0x06c1c265d475e69bac3b42f8deca5ac982efabfa640eff96a0f5d15345583e6e': 4,
        },
      ]),
    ).toStrictEqual([
      {
        misterA: 1,
        misterB: 2,
        misterC: 3,
        '0x06c1c265d475e69bac3b42f8deca5ac982efabfa640eff96a0f5d15345583e6e': 4,
      },
    ]);
  });
  it('ensureSafeJson()', () => {
    expect(
      ensureSafeJson({
        number: 1,
        boolean: true,
        string: 'string',
        object: {
          number: 1,
          bigint1: BigInt('0x64'),
        },
        array: [
          {
            number: 1,
            bigint1: BigInt('0x64'),
          },
        ],
        bigint1: BigInt(100),
        bigint2: BigInt('100'),
        bigint3: BigInt('0x64'),
      }),
    ).toStrictEqual({
      number: 1,
      boolean: true,
      string: 'string',
      object: {
        number: 1,
        bigint1: '0x64',
      },
      array: [
        {
          number: 1,
          bigint1: '0x64',
        },
      ],
      bigint1: '0x64',
      bigint2: '0x64',
      bigint3: '0x64',
    });
  });
});


================================================
File: examples/rgbpp/README.md
================================================
# RGB++ Examples

- xUDT directory: The examples for RGB++ UDT issuance, transfer, transferAll and leap
- Spore directory: The examples for RGB++ Spore creation, transfer and leap
- compatible-xudt directory: The examples for RGB++ compatible UDT issuance, transfer, transferAll and leap  
  - If you want to get the latest compatible xUDT list, `CompatibleXUDTRegistry.refreshCache` should be called first

> [!TIP]
> All the parameters of the examples should be repalced with your own, including BTC private key, CKB private key, BTC Service origin, BTC Service token, BTC UTXO, xUDT type args, Spore type args, etc. 

> Please confirm whether the parameters are correct according to the code comments

## How to Start

### Install dependencies and build packages

```
pnpm install && pnpm build:packages
```
### Update .env

Copy the `.env.example` file to `.env`:

```shell
cd examples/rgbpp && cp .env.example .env
```

Update the configuration values:

```yaml
# True for CKB and BTC Mainnet and false for CKB and BTC Testnet, the default value is false
IS_MAINNET=false

# CKB Variables

# The CKB secp256k1 private key whose format is 32bytes hex string with 0x prefix
CKB_SECP256K1_PRIVATE_KEY=0x-private-key

# CKB node url which should match IS_MAINNET
CKB_NODE_URL=https://testnet.ckb.dev/rpc

# CKB indexer url which should match IS_MAINNET
CKB_INDEXER_URL=https://testnet.ckb.dev/indexer

# BTC Variables

# The Bitcoin Testnet type including Testnet3 and Signet, default value is Signet
# Testnet3: https://mempool.space/testnet
# Signet: https://mempool.space/signet
BTC_TESTNET_TYPE=Signet

# The BTC private key whose format is 32bytes hex string without 0x prefix
BTC_PRIVATE_KEY=private-key

# The BTC address type to use, available options: P2WPKH or P2TR
# The Native Segwit P2WPKH address will be generated with the BTC private key as default
# Read more about P2WPKH in BIP141: https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#p2wpkh
BTC_ADDRESS_TYPE=P2WPKH

# The BTC assets api url which should match IS_MAINNET and BTC_TESTNET_TYPE
# The BTC Testnet Service url is: https://api.testnet.rgbpp.io
# The BTC Signet Service url is: https://api.signet.rgbpp.io
VITE_BTC_SERVICE_URL=https://api.signet.rgbpp.io

# The BTC assets api token which should match IS_MAINNET and BTC_TESTNET_TYPE
# To get an access token, please refer to https://github.com/ckb-cell/rgbpp-sdk/tree/develop/packages/service#get-an-access-token
VITE_BTC_SERVICE_TOKEN=

# The BTC assets api origin which should match IS_MAINNET and BTC_TESTNET_TYPE
VITE_BTC_SERVICE_ORIGIN=https://btc-test.app
```

## RGB++ xUDT Examples

### RGB++ xUDT Launch on BTC

#### 1. Prepare Launch

> [!TIP]
> Please make sure the CKB private key in the .env is correct.

```shell
# Create a CKB empty rgbpp lock cell to launch RGB++ xUDT assets later
npx tsx xudt/launch/1-prepare-launch.ts
```
#### 2. Launch RGB++ xUDT on BTC

> [!TIP]
> Please make sure the `1-prepare-launch.ts` has been run and the corresponding CKB transaction has been committed.

```shell
npx tsx xudt/launch/2-launch-rgbpp.ts
```

When the command is executed successfully, the **RGB++ Asset type script args** will appear in the output log

#### 3. Distribute RGB++ xUDT on BTC

> [!TIP]
> Please make sure the `2-launch-rgbpp.ts` has been run and the corresponding BTC and CKB transactions have been committed.
> The **RGB++ Asset type script args** in the above should be set to the `xudtTypeArgs`.

```shell
npx tsx xudt/launch/3-distribute-rgbpp.ts
```

### RGB++ xUDT Transfer and Leap

#### 1. Leap xUDT from CKB to BTC

```shell
npx tsx xudt/1-ckb-leap-btc.ts 
```

#### 2. Transfer RGB++ xUDT on BTC with Queue Service

```shell
npx tsx xudt/2-btc-transfer.ts 
```

#### 3. Transfer all RGB++ xUDT on BTC using a queue service

```shell
npx tsx xudt/btc-transfer-all/1-btc-transfer-all.ts 
```

#### 4. Leap RGB++ xUDT from BTC to CKB with Queue Service

```shell
npx tsx xudt/3-btc-leap-ckb.ts 
```

#### 5. Unlock xUDT BTC time cells on CKB

A cron job in RGB++ Queue service will construct a transaction unlocking the mature BTC time cells to the their `target_ckb_address`.

However, you can still manually unlock the spore BTC time cell through the following command

Warning: Wait at least 6 BTC confirmation blocks to unlock the BTC time cells after 3-btc-leap-ckb.ts

```shell
npx tsx xudt/4-unlock-btc-time.ts 
```

## RGB++ Spore Examples

### RGB++ Spores Launch on BTC

#### 1. Create RGB++ Cluster Cell

> [!TIP]
> Please make sure all the variables in the .env are correct.
> The BTC UTXO of `1-prepare-cluster.ts` and `2-create-cluster.ts` should be same.

```shell
# Create a CKB empty rgbpp lock cell to create cluster later
npx tsx spore/launch/1-prepare-cluster.ts

# Create a cluster cell with rgbpp lock
npx tsx spore/launch/2-create-cluster.ts
```

When the commands are executed successfully, the **clusterId** and **cluster rgbpp lock args** will appear in the output log

#### 2. Create RGB++ Spores with Cluster on BTC

> [!TIP]
> Please make sure the `2-create-cluster.ts` has been run and the corresponding BTC and CKB transactions have been committed.
> The **clusterId** in the above should be set to the `clusterId` and the **cluster rgbpp lock args** should be set to the `clusterRgbppLockArgs`.

```shell
npx tsx spore/launch/3-create-spores.ts
```

### Transfer and Leap Spore

#### 1. Transfer RGB++ Spore on BTC with Queue Service

```shell
npx tsx spore/4-transfer-spore.ts
```

#### 2. Leap RGB++ Spore from BTC to CKB

```shell
npx tsx spore/5-leap-spore-to-ckb.ts
```

#### 3. Unlock Spore BTC time cells on CKB

A cron job in RGB++ Queue service will construct a transaction unlocking the mature BTC time cells to the their `target_ckb_address`.

However, you can still manually unlock the spore BTC time cell through the following command

**Warning: Wait at least 6 BTC confirmation blocks to unlock the BTC time cells after 5-leap-spore-to-ckb.ts**

```shell
npx tsx spore/6-unlock-btc-time-cell.ts
```

#### 4. Leap Spore from CKB to BTC

```shell
npx tsx spore/7-leap-spore-to-btc.ts
```

## FAQ

If you have any questions, please refer to the FAQ first.

See [RGBPP FAQ](https://github.com/ckb-cell/rgbpp-sdk/wiki/RGBPP--FAQ)


## What you must know about BTC transaction id

**The BTC transaction id(hash) displayed on BTC explorer is different from the BTC transaction id(hash) in RGB++ lock args. They are in reverse byte order.**

We follow the following two rules： 

- Whenever you're working with transaction/block hashes **internally** (e.g. inside raw bitcoin data), you use the **natural** byte order.
- Whenever you're **displaying or searching** for transaction/block hashes, you use the **reverse** byte order.

For detailed rules, please refer to [Byte Order](https://learnmeabitcoin.com/technical/general/byte-order/)

For example, the BTC transaction id(hash) of the RGB++ lock args like this: 

```
4abc778213bc4da692f93745c2b07410ef2bfaee70417784d4ee8969fb258001
```

But when you're searching for this transaction in [Bitcoin Core](https://bitcoin.org/en/bitcoin-core/) or on a block explorer, you'll see this byte order:

```
018025fb6989eed484774170eefa2bef1074b0c24537f992a64dbc138277bc4a
```


================================================
File: examples/rgbpp/env.ts
================================================
import dotenv from 'dotenv';
import {
  blake160,
  bytesToHex,
  privateKeyToPublicKey,
  scriptToAddress,
  systemScripts,
} from '@nervosnetwork/ckb-sdk-utils';
import { NetworkType, AddressType, DataSource } from 'rgbpp/btc';
import { BtcAssetsApi, OfflineBtcAssetsDataSource, OfflineBtcUtxo, BtcApiUtxo, SpvProofEntry } from 'rgbpp/service';
import {
  BTCTestnetType,
  Collector,
  Hex,
  OfflineCollector,
  remove0x,
  unpackRgbppLockArgs,
  fetchCellDepsJson,
} from 'rgbpp/ckb';
import { createBtcAccount } from './shared/btc-account';

dotenv.config({ path: __dirname + '/.env' });

/**
 * Network
 */

export const isMainnet = process.env.IS_MAINNET === 'true';

/**
 * CKB
 */

export const collector = new Collector({
  ckbNodeUrl: process.env.CKB_NODE_URL!,
  ckbIndexerUrl: process.env.CKB_INDEXER_URL!,
});
export const CKB_PRIVATE_KEY = process.env.CKB_SECP256K1_PRIVATE_KEY!;
const secp256k1Lock: CKBComponents.Script = {
  ...systemScripts.SECP256K1_BLAKE160,
  args: bytesToHex(blake160(privateKeyToPublicKey(CKB_PRIVATE_KEY))),
};
export const ckbAddress = scriptToAddress(secp256k1Lock, isMainnet);

/**
 * BTC
 */

export const BTC_PRIVATE_KEY = process.env.BTC_PRIVATE_KEY!;
export const BTC_TESTNET_TYPE = process.env.BTC_TESTNET_TYPE! as BTCTestnetType;
export const BTC_SERVICE_URL = process.env.VITE_BTC_SERVICE_URL!;
export const BTC_SERVICE_TOKEN = process.env.VITE_BTC_SERVICE_TOKEN!;
export const BTC_SERVICE_ORIGIN = process.env.VITE_BTC_SERVICE_ORIGIN!;

// Read more about the available address types:
// - P2WPKH: https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#p2wpkh
// - P2TR: https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki
const addressType = process.env.BTC_ADDRESS_TYPE === 'P2TR' ? AddressType.P2TR : AddressType.P2WPKH;
export const networkType = isMainnet ? NetworkType.MAINNET : NetworkType.TESTNET;
export const btcAccount = createBtcAccount(BTC_PRIVATE_KEY, addressType, networkType);

export const btcService = BtcAssetsApi.fromToken(BTC_SERVICE_URL, BTC_SERVICE_TOKEN, BTC_SERVICE_ORIGIN);
export const btcDataSource = new DataSource(btcService, networkType);

// offline data source
export const initOfflineCkbCollector = async (
  queries: {
    lock?: CKBComponents.Script;
    type?: CKBComponents.Script;
    isDataMustBeEmpty?: boolean;
    outputCapacityRange?: Hex[];
    withEmptyType?: boolean;
  }[],
) => {
  const cells = (
    await Promise.all(
      queries.map(async (query) => {
        let cells = await collector.getCells(query);
        if (!cells || cells.length === 0) {
          throw new Error(`No cells found for query ${JSON.stringify(query)}`);
        }
        if (query.withEmptyType) {
          cells = cells.filter((cell) => !cell.output.type);
        }
        if (cells.length === 0) {
          throw new Error(`No cells found for query ${JSON.stringify(query)} with type ${query.type}`);
        }
        return cells;
      }),
    )
  ).flat();

  return {
    cells,
    collector: new OfflineCollector(cells),
  };
};

export const initOfflineBtcDataSource = async (
  rgbppLockArgsList: string[],
  address: string,
  spvProofs: SpvProofEntry[] = [],
) => {
  const btcTxIds = rgbppLockArgsList.map((rgbppLockArgs) => remove0x(unpackRgbppLockArgs(rgbppLockArgs).btcTxId));
  const btcTxs = await Promise.all(
    btcTxIds.map(async (btcTxId) => {
      const tx = await btcService.getBtcTransaction(btcTxId);
      if (!tx) {
        throw new Error(`BTC tx ${btcTxId} not found`);
      }
      return tx;
    }),
  );

  const utxoMap = new Map<string, OfflineBtcUtxo>();
  const keyOf = (utxo: BtcApiUtxo) => `${utxo.txid}:${utxo.vout}`;
  (await btcService.getBtcUtxos(address)).forEach((utxo) => {
    utxoMap.set(keyOf(utxo), {
      ...utxo,
      address,
      nonRgbpp: false,
    });
  });
  (
    await btcService.getBtcUtxos(address, {
      only_non_rgbpp_utxos: true,
    })
  ).forEach((utxo) => {
    utxoMap.set(keyOf(utxo), {
      ...utxo,
      address,
      nonRgbpp: true,
    });
  });

  return new DataSource(
    new OfflineBtcAssetsDataSource({ txs: btcTxs, utxos: Array.from(utxoMap.values()), rgbppSpvProofs: spvProofs }),
    networkType,
  );
};

let vendorCellDeps: Awaited<ReturnType<typeof fetchCellDepsJson>>;
(async () => {
  vendorCellDeps = await fetchCellDepsJson();
  if (!vendorCellDeps) {
    throw new Error('Failed to fetch vendor cell deps');
  }
})();
export { vendorCellDeps };


================================================
File: examples/rgbpp/package.json
================================================
{
  "name": "rgbpp-examples",
  "version": "0.1.0",
  "description": "Examples used for RGBPP assets issuance, transfer, and leaping between BTC and CKB",
  "private": true,
  "type": "commonjs",
  "scripts": {
    "format": "prettier --write '**/*.{js,ts}'",
    "lint": "tsc && eslint . && prettier --check '**/*.{js,ts}'",
    "lint:fix": "tsc && eslint --fix --ext .js,.ts . && prettier --write '**/*.{js,ts}'"
  },
  "dependencies": {
    "@nervosnetwork/ckb-sdk-utils": "0.109.5",
    "rgbpp": "workspace:*"
  },
  "devDependencies": {
    "dotenv": "^16.4.5",
    "@types/dotenv": "^8.2.0"
  }
}


================================================
File: examples/rgbpp/tsconfig.json
================================================
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "compilerOptions": {
    "target": "ES2015",
    "lib": ["esnext"],
    "module": "ES2015",
    "composite": false,
    "resolveJsonModule": true,
    "strictNullChecks": true,
    "noEmit": true,
    "declaration": true,
    "declarationMap": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "inlineSources": false,
    "isolatedModules": true,
    "moduleResolution": "Bundler",
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "preserveWatchOutput": true,
    "skipLibCheck": true,
    "strict": true
  },
  "include": ["spore", "xudt", "shared"],
  "exclude": ["node_modules"]
}


================================================
File: examples/rgbpp/.env.example
================================================
# True for CKB and BTC Mainnet and false for CKB and BTC Testnet, the default value is false
IS_MAINNET=false

# CKB Variables

# The CKB secp256k1 private key whose format is 32bytes hex string with 0x prefix
CKB_SECP256K1_PRIVATE_KEY=0x-private-key

# CKB node url which should match IS_MAINNET
CKB_NODE_URL=https://testnet.ckb.dev/rpc

# CKB indexer url which should match IS_MAINNET
CKB_INDEXER_URL=https://testnet.ckb.dev/indexer


# BTC Variables

# The Bitcoin Testnet type including Testnet3 and Signet, default value is Signet
# Testnet3: https://mempool.space/testnet
# Signet: https://mempool.space/signet
BTC_TESTNET_TYPE=Signet

# The BTC private key whose format is 32bytes hex string without 0x prefix
BTC_PRIVATE_KEY=private-key

# The BTC address type to use, available options: P2WPKH or P2TR
# The Native Segwit P2WPKH address will be generated with the BTC private key as default
# Read more about P2WPKH in BIP141: https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#p2wpkh
BTC_ADDRESS_TYPE=P2WPKH

# The BTC assets api url which should match IS_MAINNET and BTC_TESTNET_TYPE
# The BTC Testnet Service url is: https://api.testnet.rgbpp.io
# The BTC Signet Service url is: https://api.signet.rgbpp.io
VITE_BTC_SERVICE_URL=https://api.signet.rgbpp.io

# The BTC assets api token which should match IS_MAINNET and BTC_TESTNET_TYPE
# To get an access token, please refer to https://github.com/ckb-cell/rgbpp-sdk/tree/develop/packages/service#get-an-access-token
VITE_BTC_SERVICE_TOKEN=

# The BTC assets api origin which should match IS_MAINNET and BTC_TESTNET_TYPE
VITE_BTC_SERVICE_ORIGIN=https://btc-test.app



================================================
File: examples/rgbpp/shared/btc-account.ts
================================================
import {
  addressToScriptPublicKeyHex,
  networkTypeToNetwork,
  remove0x,
  toXOnly,
  transactionToHex,
  tweakSigner,
} from 'rgbpp/btc';
import { AddressType, NetworkType, bitcoin, ECPair } from 'rgbpp/btc';
import { BtcAssetsApi } from 'rgbpp/service';

export interface BtcAccount {
  from: string;
  fromPubkey?: string;
  keyPair: bitcoin.Signer;
  payment: bitcoin.Payment;
  addressType: AddressType;
  networkType: NetworkType;
}

export function createBtcAccount(privateKey: string, addressType: AddressType, networkType: NetworkType): BtcAccount {
  const network = networkTypeToNetwork(networkType);

  const key = Buffer.from(remove0x(privateKey), 'hex');
  const keyPair = ECPair.fromPrivateKey(key, { network });

  if (addressType === AddressType.P2WPKH) {
    const p2wpkh = bitcoin.payments.p2wpkh({
      pubkey: keyPair.publicKey,
      network,
    });
    return {
      from: p2wpkh.address!,
      payment: p2wpkh,
      keyPair,
      addressType,
      networkType,
    };
  } else if (addressType === AddressType.P2TR) {
    const p2tr = bitcoin.payments.p2tr({
      internalPubkey: toXOnly(keyPair.publicKey),
      network,
    });
    return {
      from: p2tr.address!,
      fromPubkey: keyPair.publicKey.toString('hex'),
      payment: p2tr,
      keyPair,
      addressType,
      networkType,
    };
  } else {
    throw new Error('Unsupported address type, only support P2WPKH and P2TR');
  }
}

export function signPsbt(psbt: bitcoin.Psbt, account: BtcAccount): bitcoin.Psbt {
  const accountScript = addressToScriptPublicKeyHex(account.from, account.networkType);
  const tweakedSigner = tweakSigner(account.keyPair, {
    network: account.payment.network,
  });

  psbt.data.inputs.forEach((input, index) => {
    if (input.witnessUtxo) {
      const script = input.witnessUtxo.script.toString('hex');
      if (script === accountScript && account.addressType === AddressType.P2WPKH) {
        psbt.signInput(index, account.keyPair);
      }
      if (script === accountScript && account.addressType === AddressType.P2TR) {
        psbt.signInput(index, tweakedSigner);
      }
    }
  });

  return psbt;
}

export async function signAndSendPsbt(
  psbt: bitcoin.Psbt,
  account: BtcAccount,
  service: BtcAssetsApi,
): Promise<{
  txId: string;
  txHex: string;
  rawTxHex: string;
}> {
  signPsbt(psbt, account);
  psbt.finalizeAllInputs();

  const tx = psbt.extractTransaction(true);
  const txHex = tx.toHex();

  const { txid } = await service.sendBtcTransaction(txHex);

  return {
    txHex,
    txId: txid,
    // Exclude witness from the BTC_TX for unlocking RGBPP assets
    rawTxHex: transactionToHex(tx, false),
  };
}


================================================
File: examples/rgbpp/shared/utils.ts
================================================
import * as fs from 'fs';
import * as path from 'path';
import {
  BaseCkbVirtualTxResult,
  SporeVirtualTxResult,
  SporeCreateVirtualTxResult,
  SporeTransferVirtualTxResult,
  RgbppLaunchVirtualTxResult,
} from 'rgbpp/ckb';

/**
 * Save ckbVirtualTxResult to a log file
 * @param ckbVirtualTxResult - The ckbVirtualTxResult to save
 * @param exampleName - Example name used to distinguish different log files
 */

export type CkbVirtualTxResultType =
  | BaseCkbVirtualTxResult
  | RgbppLaunchVirtualTxResult
  | SporeVirtualTxResult
  | SporeCreateVirtualTxResult
  | SporeTransferVirtualTxResult;

export const saveCkbVirtualTxResult = (ckbVirtualTxResult: CkbVirtualTxResultType, exampleName: string) => {
  try {
    // Define log file path
    const logDir = path.resolve(__dirname, '../logs');
    const timestamp = new Date().toISOString().replace(/:/g, '-'); // Replace colons with hyphens
    const logFilePath = path.join(logDir, `${exampleName}-${timestamp}-ckbVirtualTxResult.log`);

    // Ensure the log directory exists
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir);
    }

    // Validate and save ckbVirtualTxResult to log file
    if (typeof ckbVirtualTxResult === 'object' && ckbVirtualTxResult !== null) {
      fs.writeFileSync(logFilePath, JSON.stringify(ckbVirtualTxResult, null, 2));
      console.info(`Saved ckbVirtualTxResult to ${logFilePath}`);
    } else {
      console.error('Invalid ckbVirtualTxResult format');
    }

    // Remind developers to save the transaction result
    console.info(
      `Important: It's recommended to save the rgbpp_ckb_tx_virtual locally before the isomorphic transactions are finalized.`,
    );
  } catch (error) {
    console.error('Failed to save ckbVirtualTxResult:', error);
  }
};


================================================
File: examples/rgbpp/spore/4-transfer-spore.ts
================================================
import { buildRgbppLockArgs } from 'rgbpp/ckb';
import { genTransferSporeCkbVirtualTx, sendRgbppUtxos } from 'rgbpp';
import { getSporeTypeScript, Hex } from 'rgbpp/ckb';
import { serializeScript } from '@nervosnetwork/ckb-sdk-utils';
import { isMainnet, collector, btcDataSource, btcService, btcAccount, BTC_TESTNET_TYPE } from '../env';
import { saveCkbVirtualTxResult } from '../shared/utils';
import { signAndSendPsbt } from '../shared/btc-account';

interface SporeTransferParams {
  sporeRgbppLockArgs: Hex;
  toBtcAddress: string;
  sporeTypeArgs: Hex;
}

const transferSpore = async ({ sporeRgbppLockArgs, toBtcAddress, sporeTypeArgs }: SporeTransferParams) => {
  const sporeTypeBytes = serializeScript({
    ...getSporeTypeScript(isMainnet),
    args: sporeTypeArgs,
  });

  const ckbVirtualTxResult = await genTransferSporeCkbVirtualTx({
    collector,
    sporeRgbppLockArgs,
    sporeTypeBytes,
    isMainnet,
    btcTestnetType: BTC_TESTNET_TYPE,
  });

  // Save ckbVirtualTxResult
  saveCkbVirtualTxResult(ckbVirtualTxResult, '4-transfer-spore');

  const { commitment, ckbRawTx, needPaymasterCell } = ckbVirtualTxResult;

  // Send BTC tx
  const psbt = await sendRgbppUtxos({
    ckbVirtualTx: ckbRawTx,
    commitment,
    tos: [toBtcAddress],
    needPaymaster: needPaymasterCell,
    ckbCollector: collector,
    from: btcAccount.from,
    fromPubkey: btcAccount.fromPubkey,
    source: btcDataSource,
    feeRate: 30,
  });

  const { txId: btcTxId } = await signAndSendPsbt(psbt, btcAccount, btcService);
  console.log('BTC TxId: ', btcTxId);

  await btcService.sendRgbppCkbTransaction({ btc_txid: btcTxId, ckb_virtual_result: ckbVirtualTxResult });

  try {
    const interval = setInterval(async () => {
      const { state, failedReason } = await btcService.getRgbppTransactionState(btcTxId);
      console.log('state', state);
      if (state === 'completed' || state === 'failed') {
        clearInterval(interval);
        if (state === 'completed') {
          const { txhash: txHash } = await btcService.getRgbppTransactionHash(btcTxId);
          console.info(`Rgbpp spore has been transferred on BTC and the related CKB tx hash is ${txHash}`);
        } else {
          console.warn(`Rgbpp CKB transaction failed and the reason is ${failedReason} `);
        }
      }
    }, 30 * 1000);
  } catch (error) {
    console.error(error);
  }
};

// Please use your real BTC UTXO information on the BTC Testnet
// BTC Testnet3: https://mempool.space/testnet
// BTC Signet: https://mempool.space/signet

// rgbppLockArgs: outIndexU32 + btcTxId
transferSpore({
  sporeRgbppLockArgs: buildRgbppLockArgs(2, 'd5868dbde4be5e49876b496449df10150c356843afb6f94b08f8d81f394bb350'),
  toBtcAddress: 'tb1qhp9fh9qsfeyh0yhewgu27ndqhs5qlrqwau28m7',
  // Please use your own RGB++ spore asset's sporeTypeArgs
  sporeTypeArgs: '0x42898ea77062256f46e8f1b861d526ae47810ecc51ab50477945d5fa90452706',
});


================================================
File: examples/rgbpp/spore/5-leap-spore-to-ckb.ts
================================================
import { buildRgbppLockArgs } from 'rgbpp/ckb';
import { genLeapSporeFromBtcToCkbVirtualTx, sendRgbppUtxos } from 'rgbpp';
import { getSporeTypeScript, Hex } from 'rgbpp/ckb';
import { serializeScript } from '@nervosnetwork/ckb-sdk-utils';
import { isMainnet, collector, btcDataSource, btcService, btcAccount, BTC_TESTNET_TYPE } from '../env';
import { saveCkbVirtualTxResult } from '../shared/utils';
import { signAndSendPsbt } from '../shared/btc-account';

interface SporeLeapParams {
  sporeRgbppLockArgs: Hex;
  toCkbAddress: string;
  sporeTypeArgs: Hex;
}

const leapSporeFromBtcToCkb = async ({ sporeRgbppLockArgs, toCkbAddress, sporeTypeArgs }: SporeLeapParams) => {
  const sporeTypeBytes = serializeScript({
    ...getSporeTypeScript(isMainnet),
    args: sporeTypeArgs,
  });

  const ckbVirtualTxResult = await genLeapSporeFromBtcToCkbVirtualTx({
    collector,
    sporeRgbppLockArgs,
    sporeTypeBytes,
    toCkbAddress,
    isMainnet,
    btcTestnetType: BTC_TESTNET_TYPE,
  });

  // Save ckbVirtualTxResult
  saveCkbVirtualTxResult(ckbVirtualTxResult, '5-leap-spore-to-ckb');

  const { commitment, ckbRawTx, needPaymasterCell } = ckbVirtualTxResult;

  // Send BTC tx
  const psbt = await sendRgbppUtxos({
    ckbVirtualTx: ckbRawTx,
    commitment,
    tos: [btcAccount.from],
    needPaymaster: needPaymasterCell,
    ckbCollector: collector,
    from: btcAccount.from,
    fromPubkey: btcAccount.fromPubkey,
    source: btcDataSource,
    feeRate: 30,
  });

  const { txId: btcTxId } = await signAndSendPsbt(psbt, btcAccount, btcService);
  console.log('BTC TxId: ', btcTxId);

  await btcService.sendRgbppCkbTransaction({ btc_txid: btcTxId, ckb_virtual_result: ckbVirtualTxResult });

  try {
    const interval = setInterval(async () => {
      const { state, failedReason } = await btcService.getRgbppTransactionState(btcTxId);
      console.log('state', state);
      if (state === 'completed' || state === 'failed') {
        clearInterval(interval);
        if (state === 'completed') {
          const { txhash: txHash } = await btcService.getRgbppTransactionHash(btcTxId);
          console.info(`Rgbpp spore has been leaped from BTC to CKB and the related CKB tx hash is ${txHash}`);
        } else {
          console.warn(`Rgbpp CKB transaction failed and the reason is ${failedReason} `);
        }
      }
    }, 30 * 1000);
  } catch (error) {
    console.error(error);
  }
};

// Please use your real BTC UTXO information on the BTC Testnet
// BTC Testnet3: https://mempool.space/testnet
// BTC Signet: https://mempool.space/signet

// rgbppLockArgs: outIndexU32 + btcTxId
leapSporeFromBtcToCkb({
  sporeRgbppLockArgs: buildRgbppLockArgs(3, 'd8a31796fbd42c546f6b22014b9b82b16586ce1df81b0e7ca9a552cdc492a0af'),
  toCkbAddress: 'ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsq0e4xk4rmg5jdkn8aams492a7jlg73ue0gc0ddfj',
  // Please use your own RGB++ spore asset's sporeTypeArgs
  sporeTypeArgs: '0x42898ea77062256f46e8f1b861d526ae47810ecc51ab50477945d5fa90452706',
});


================================================
File: examples/rgbpp/spore/6-unlock-btc-time-cell.ts
================================================
import { buildSporeBtcTimeCellsSpentTx, signBtcTimeCellSpentTx } from 'rgbpp';
import { BTC_TESTNET_TYPE, CKB_PRIVATE_KEY, btcService, ckbAddress, collector, isMainnet } from '../env';
import { sendCkbTx, getBtcTimeLockScript } from 'rgbpp/ckb';

// Warning: Wait at least 6 BTC confirmation blocks to spend the BTC time cells after 5-leap-spore-to-ckb.ts
const unlockSporeBtcTimeCell = async ({ btcTimeCellArgs }: { btcTimeCellArgs: string }) => {
  const btcTimeCells = await collector.getCells({
    lock: {
      ...getBtcTimeLockScript(isMainnet, BTC_TESTNET_TYPE),
      args: btcTimeCellArgs,
    },
    isDataMustBeEmpty: false,
  });

  if (!btcTimeCells || btcTimeCells.length === 0) {
    throw new Error('No btc time cells found');
  }

  const ckbRawTx: CKBComponents.RawTransaction = await buildSporeBtcTimeCellsSpentTx({
    btcTimeCells,
    btcAssetsApi: btcService,
    isMainnet,
    btcTestnetType: BTC_TESTNET_TYPE,
  });

  const signedTx = await signBtcTimeCellSpentTx({
    secp256k1PrivateKey: CKB_PRIVATE_KEY,
    collector,
    masterCkbAddress: ckbAddress,
    ckbRawTx,
    isMainnet,
  });

  const txHash = await sendCkbTx({ collector, signedTx });
  console.info(`Spore BTC time cell has been unlocked and tx hash is ${txHash}`);
};

// The btcTimeCellArgs is from the outputs[0].lock.args(BTC Time lock args) of the 5-leap-spore-to-ckb.ts CKB transaction
unlockSporeBtcTimeCell({
  btcTimeCellArgs:
    '0x7d00000010000000590000005d000000490000001000000030000000310000009bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce80114000000f9a9ad51ed14936d33f7bb854aaefa5f47a3ccbd060000002997fa043e977cb0a9bcc75ec308ad1323331c5295caf8fc721b0a2761bef305',
});


================================================
File: examples/rgbpp/spore/7-leap-spore-to-btc.ts
================================================
import { serializeScript } from '@nervosnetwork/ckb-sdk-utils';
import { genLeapSporeFromCkbToBtcRawTx } from 'rgbpp';
import { isMainnet, collector, ckbAddress, CKB_PRIVATE_KEY, BTC_TESTNET_TYPE } from '../env';
import { buildRgbppLockArgs, getSecp256k1CellDep, getSporeTypeScript } from 'rgbpp/ckb';

const leapSporeFromCkbToBtc = async ({
  outIndex,
  btcTxId,
  sporeTypeArgs,
}: {
  outIndex: number;
  btcTxId: string;
  sporeTypeArgs: string;
}) => {
  const toRgbppLockArgs = buildRgbppLockArgs(outIndex, btcTxId);

  const sporeType: CKBComponents.Script = {
    ...getSporeTypeScript(isMainnet),
    args: sporeTypeArgs,
  };

  const ckbRawTx = await genLeapSporeFromCkbToBtcRawTx({
    collector,
    fromCkbAddress: ckbAddress,
    toRgbppLockArgs,
    sporeTypeBytes: serializeScript(sporeType),
    isMainnet,
    btcTestnetType: BTC_TESTNET_TYPE,
  });

  const emptyWitness = { lock: '', inputType: '', outputType: '' };
  const unsignedTx: CKBComponents.RawTransactionToSign = {
    ...ckbRawTx,
    cellDeps: [...ckbRawTx.cellDeps, getSecp256k1CellDep(isMainnet)],
    witnesses: [emptyWitness, ...ckbRawTx.witnesses.slice(1)],
  };

  const signedTx = collector.getCkb().signTransaction(CKB_PRIVATE_KEY)(unsignedTx);

  const txHash = await collector.getCkb().rpc.sendTransaction(signedTx, 'passthrough');
  console.info(`RGB++ Spore has been jumped from CKB to BTC and tx hash is ${txHash}`);
};

// Please use your real BTC UTXO information on the BTC Testnet
// BTC Testnet3: https://mempool.space/testnet
// BTC Signet: https://mempool.space/signet
leapSporeFromCkbToBtc({
  outIndex: 1,
  btcTxId: '448897515cf07b4ca0cd38af9806399ede55775b4c760b274ed2322121ed185f',
  // Please use your own RGB++ spore asset's sporeTypeArgs
  sporeTypeArgs: '0x42898ea77062256f46e8f1b861d526ae47810ecc51ab50477945d5fa90452706',
});


================================================
File: examples/rgbpp/spore/launch/0-cluster-info.ts
================================================
import { RawClusterData } from 'rgbpp/ckb';

export const CLUSTER_DATA: RawClusterData = {
  name: 'Cluster name',
  description: 'Description of the cluster',
};


================================================
File: examples/rgbpp/spore/launch/1-prepare-cluster.ts
================================================
import { addressToScript, getTransactionSize } from '@nervosnetwork/ckb-sdk-utils';
import {
  MAX_FEE,
  NoLiveCellError,
  SECP256K1_WITNESS_LOCK_SIZE,
  append0x,
  buildRgbppLockArgs,
  calculateRgbppClusterCellCapacity,
  calculateTransactionFee,
  genRgbppLockScript,
  getSecp256k1CellDep,
} from 'rgbpp/ckb';
import { ckbAddress, isMainnet, collector, CKB_PRIVATE_KEY, BTC_TESTNET_TYPE } from '../../env';
import { CLUSTER_DATA } from './0-cluster-info';

const prepareClusterCell = async ({ outIndex, btcTxId }: { outIndex: number; btcTxId: string }) => {
  const masterLock = addressToScript(ckbAddress);
  console.log('ckb address: ', ckbAddress);

  // The capacity required to launch cells is determined by the token info cell capacity, and transaction fee.
  const clusterCellCapacity = calculateRgbppClusterCellCapacity(CLUSTER_DATA);

  let emptyCells = await collector.getCells({
    lock: masterLock,
  });
  if (!emptyCells || emptyCells.length === 0) {
    throw new NoLiveCellError('The address has no empty cells');
  }
  emptyCells = emptyCells.filter((cell) => !cell.output.type);

  const txFee = MAX_FEE;
  const { inputs, sumInputsCapacity } = collector.collectInputs(emptyCells, clusterCellCapacity, txFee);

  const outputs: CKBComponents.CellOutput[] = [
    {
      lock: genRgbppLockScript(buildRgbppLockArgs(outIndex, btcTxId), isMainnet, BTC_TESTNET_TYPE),
      capacity: append0x(clusterCellCapacity.toString(16)),
    },
  ];
  let changeCapacity = sumInputsCapacity - clusterCellCapacity;
  outputs.push({
    lock: masterLock,
    capacity: append0x(changeCapacity.toString(16)),
  });
  const outputsData = ['0x', '0x'];

  const emptyWitness = { lock: '', inputType: '', outputType: '' };
  const witnesses = inputs.map((_, index) => (index === 0 ? emptyWitness : '0x'));

  const cellDeps = [getSecp256k1CellDep(isMainnet)];

  const unsignedTx = {
    version: '0x0',
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses,
  };

  const txSize = getTransactionSize(unsignedTx) + SECP256K1_WITNESS_LOCK_SIZE;
  const estimatedTxFee = calculateTransactionFee(txSize);
  changeCapacity -= estimatedTxFee;
  unsignedTx.outputs[unsignedTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));

  const signedTx = collector.getCkb().signTransaction(CKB_PRIVATE_KEY)(unsignedTx);
  const txHash = await collector.getCkb().rpc.sendTransaction(signedTx, 'passthrough');

  console.info(`Cluster cell has been prepared and the tx hash ${txHash}`);
};

// Please use your real BTC UTXO information on the BTC Testnet
prepareClusterCell({
  outIndex: 3,
  btcTxId: 'aee4e8e3aa95e9e9ab1f0520714031d92d3263262099dcc7f7d64e62fa2fcb44',
});


================================================
File: examples/rgbpp/spore/launch/2-create-cluster.ts
================================================
import { BtcAssetsApiError, genCreateClusterCkbVirtualTx, sendRgbppUtxos } from 'rgbpp';
import { isMainnet, collector, btcAccount, btcDataSource, btcService, BTC_TESTNET_TYPE } from '../../env';
import { CLUSTER_DATA } from './0-cluster-info';
import {
  appendCkbTxWitnesses,
  buildRgbppLockArgs,
  generateClusterCreateCoBuild,
  sendCkbTx,
  updateCkbTxWithRealBtcTxId,
} from 'rgbpp/ckb';
import { saveCkbVirtualTxResult } from '../../shared/utils';
import { signAndSendPsbt } from '../../shared/btc-account';

// Warning: Before runing this file, please run 1-prepare-cluster.ts
const createCluster = async ({ ownerRgbppLockArgs }: { ownerRgbppLockArgs: string }) => {
  const ckbVirtualTxResult = await genCreateClusterCkbVirtualTx({
    collector,
    rgbppLockArgs: ownerRgbppLockArgs,
    clusterData: CLUSTER_DATA,
    isMainnet,
    ckbFeeRate: BigInt(2000),
    btcTestnetType: BTC_TESTNET_TYPE,
  });

  // Save ckbVirtualTxResult
  saveCkbVirtualTxResult(ckbVirtualTxResult, '2-create-cluster');

  const { commitment, ckbRawTx, clusterId, needPaymasterCell } = ckbVirtualTxResult;

  console.log('clusterId: ', clusterId);

  // Send BTC tx
  const psbt = await sendRgbppUtxos({
    ckbVirtualTx: ckbRawTx,
    commitment,
    tos: [btcAccount.from],
    needPaymaster: needPaymasterCell,
    ckbCollector: collector,
    from: btcAccount.from,
    fromPubkey: btcAccount.fromPubkey,
    source: btcDataSource,
    feeRate: 30,
  });

  const { txId: btcTxId, rawTxHex: btcTxBytes } = await signAndSendPsbt(psbt, btcAccount, btcService);
  console.log('BTC TxId: ', btcTxId);

  const interval = setInterval(async () => {
    try {
      console.log('Waiting for BTC tx and proof to be ready');
      const rgbppApiSpvProof = await btcService.getRgbppSpvProof(btcTxId, 0);
      clearInterval(interval);
      // Update CKB transaction with the real BTC txId
      const newCkbRawTx = updateCkbTxWithRealBtcTxId({ ckbRawTx, btcTxId, isMainnet });

      console.log('The cluster rgbpp lock args: ', newCkbRawTx.outputs[0].lock.args);
      console.log('The cluster rgbpp lock args -- btc tx id: ', btcTxId);
      console.log('The cluster rgbpp lock args -- btc tx out index: 1');

      const ckbTx = await appendCkbTxWitnesses({
        ckbRawTx: newCkbRawTx,
        btcTxBytes,
        rgbppApiSpvProof,
      });
      // Replace cobuild witness with the final rgbpp lock script
      ckbTx.witnesses[ckbTx.witnesses.length - 1] = generateClusterCreateCoBuild(
        ckbTx.outputs[0],
        ckbTx.outputsData[0],
      );

      console.log(JSON.stringify(ckbTx));

      const txHash = await sendCkbTx({ collector, signedTx: ckbTx });
      console.info(`RGB++ Cluster has been created and tx hash is ${txHash}`);
    } catch (error) {
      if (!(error instanceof BtcAssetsApiError)) {
        console.error(error);
      }
    }
  }, 30 * 1000);
};

// Please use your real BTC UTXO information on the BTC Testnet which should be same as the 1-prepare-cluster.ts
// BTC Testnet3: https://mempool.space/testnet
// BTC Signet: https://mempool.space/signet

// rgbppLockArgs: outIndexU32 + btcTxId
createCluster({
  ownerRgbppLockArgs: buildRgbppLockArgs(3, 'aee4e8e3aa95e9e9ab1f0520714031d92d3263262099dcc7f7d64e62fa2fcb44'),
});


================================================
File: examples/rgbpp/spore/launch/3-create-spores.ts
================================================
import { BtcAssetsApiError, genCreateSporeCkbVirtualTx, sendRgbppUtxos } from 'rgbpp';
import {
  isMainnet,
  collector,
  btcDataSource,
  btcService,
  CKB_PRIVATE_KEY,
  ckbAddress,
  btcAccount,
  BTC_TESTNET_TYPE,
} from '../../env';
import {
  Hex,
  appendCkbTxWitnesses,
  appendIssuerCellToSporesCreate,
  buildRgbppLockArgs,
  generateSporeCreateCoBuild,
  sendCkbTx,
  updateCkbTxWithRealBtcTxId,
  RawSporeData,
  remove0x,
  SporeCreateVirtualTxResult,
} from 'rgbpp/ckb';
import { utf8ToBuffer } from 'rgbpp/btc';
import { saveCkbVirtualTxResult } from '../../shared/utils';
import { signAndSendPsbt } from '../../shared/btc-account';
import { serializeRawTransaction } from '@nervosnetwork/ckb-sdk-utils';

const RECOMMENDED_MAX_CKB_TX_SIZE = 60 * 1024;

interface SporeCreateParams {
  clusterRgbppLockArgs: Hex;
  receivers: {
    toBtcAddress: string;
    sporeData: RawSporeData;
  }[];
}

const estimateCkbTxSize = (ckbVirtualTxResult: SporeCreateVirtualTxResult) => {
  const { ckbRawTx, clusterCell } = ckbVirtualTxResult;
  const rawTxSize = remove0x(serializeRawTransaction(ckbRawTx)).length / 2;

  const coBuild = generateSporeCreateCoBuild({
    // The first output is cluster cell and the rest of the outputs are spore cells
    sporeOutputs: ckbRawTx.outputs.slice(1),
    sporeOutputsData: ckbRawTx.outputsData.slice(1),
    clusterCell,
    clusterOutputCell: ckbRawTx.outputs[0],
  });
  const coBuildSize = remove0x(coBuild).length / 2;
  return rawTxSize + coBuildSize;
};

// Warning: Before running this file for the first time, please run 2-prepare-cluster.ts
const createSpores = async ({ clusterRgbppLockArgs, receivers }: SporeCreateParams) => {
  const ckbVirtualTxResult = await genCreateSporeCkbVirtualTx({
    collector,
    sporeDataList: receivers.map((receiver) => receiver.sporeData),
    clusterRgbppLockArgs,
    isMainnet,
    ckbFeeRate: BigInt(2000),
    btcTestnetType: BTC_TESTNET_TYPE,
  });

  const ckbTxSize = estimateCkbTxSize(ckbVirtualTxResult);
  if (ckbTxSize > RECOMMENDED_MAX_CKB_TX_SIZE) {
    throw new Error(
      `The estimated size(${ckbTxSize} bytes) of the CKB transaction is too large, which may cause the transaction to fail to be properly submitted to the blockchain. It is strongly recommended to reduce the number of Spore receivers to reduce the size of the CKB transaction to below 60K bytes.`,
    );
  }

  // Save ckbVirtualTxResult
  saveCkbVirtualTxResult(ckbVirtualTxResult, '3-create-spores');

  const { commitment, ckbRawTx, sumInputsCapacity, clusterCell, needPaymasterCell } = ckbVirtualTxResult;

  // Send BTC tx
  // The first btc address is the owner of the cluster cell and the rest btc addresses are spore receivers
  const btcTos = [btcAccount.from, ...receivers.map((receiver) => receiver.toBtcAddress)];
  const psbt = await sendRgbppUtxos({
    ckbVirtualTx: ckbRawTx,
    commitment,
    tos: btcTos,
    needPaymaster: needPaymasterCell,
    ckbCollector: collector,
    from: btcAccount.from,
    fromPubkey: btcAccount.fromPubkey,
    source: btcDataSource,
    feeRate: 120,
  });

  const { txId: btcTxId, rawTxHex: btcTxBytes } = await signAndSendPsbt(psbt, btcAccount, btcService);
  console.log('BTC TxId: ', btcTxId);

  const interval = setInterval(async () => {
    try {
      console.log('Waiting for BTC tx and proof to be ready');
      const rgbppApiSpvProof = await btcService.getRgbppSpvProof(btcTxId, 0);
      clearInterval(interval);
      // Update CKB transaction with the real BTC txId
      const newCkbRawTx = updateCkbTxWithRealBtcTxId({ ckbRawTx, btcTxId, isMainnet });
      console.log('The new cluster rgbpp lock args: ', newCkbRawTx.outputs[0].lock.args);
      console.log('The new cluster rgbpp lock args -- btc tx id: ', btcTxId);
      console.log('The new cluster rgbpp lock args -- btc tx out index: 1');

      const ckbTx = await appendCkbTxWitnesses({
        ckbRawTx: newCkbRawTx,
        btcTxBytes,
        rgbppApiSpvProof,
      });

      // The outputs[1..] are spore cells from which you can find spore type scripts,
      // and the spore type scripts will be used to transfer and leap spores
      console.log('Spore type scripts: ', JSON.stringify(ckbTx.outputs.slice(1).map((output) => output.type)));

      // Replace cobuild witness with the final rgbpp lock script
      ckbTx.witnesses[ckbTx.witnesses.length - 1] = generateSporeCreateCoBuild({
        // The first output is cluster cell and the rest of the outputs are spore cells
        sporeOutputs: ckbTx.outputs.slice(1),
        sporeOutputsData: ckbTx.outputsData.slice(1),
        clusterCell,
        clusterOutputCell: ckbTx.outputs[0],
      });

      // console.log('ckbTx: ', JSON.stringify(ckbTx));

      const signedTx = await appendIssuerCellToSporesCreate({
        secp256k1PrivateKey: CKB_PRIVATE_KEY,
        issuerAddress: ckbAddress,
        ckbRawTx: ckbTx,
        collector,
        sumInputsCapacity,
        isMainnet,
      });

      const txHash = await sendCkbTx({ collector, signedTx });
      console.info(`RGB++ Spore has been created and tx hash is ${txHash}`);
    } catch (error) {
      if (!(error instanceof BtcAssetsApiError)) {
        console.error(error);
      }
    }
  }, 30 * 1000);
};

// Please use your real BTC UTXO information on the BTC Testnet
// BTC Testnet3: https://mempool.space/testnet
// BTC Signet: https://mempool.space/signet

// rgbppLockArgs: outIndexU32 + btcTxId
createSpores({
  // The cluster cell will be spent and the new cluster cell will be created in each spore creation tx,
  // so the cluster rgbpp lock args should be updated after each spore creation tx is completed.
  // The first cluster rgbpp lock args is from 2-create-cluster.ts and the new cluster rgbpp lock args can be found from the log in the line 71 of this file
  clusterRgbppLockArgs: buildRgbppLockArgs(1, '96bccaadd3c8f59b2411e3d64ae4c1743532415f953fc4f9741a5fd7a0a34483'),
  receivers: [
    {
      toBtcAddress: 'tb1qhp9fh9qsfeyh0yhewgu27ndqhs5qlrqwau28m7',
      sporeData: {
        contentType: 'text/plain',
        content: utf8ToBuffer('First Spore'),
        // The cluster id is from 2-create-cluster.ts
        clusterId: '0xbc5168a4f90116fada921e185d4b018e784dc0f6266e539a3c092321c932700a',
      },
    },
    {
      toBtcAddress: 'tb1qhp9fh9qsfeyh0yhewgu27ndqhs5qlrqwau28m7',
      sporeData: {
        contentType: 'text/plain',
        content: utf8ToBuffer('Second Spore'),
        // The cluster id is from 2-create-cluster.ts
        clusterId: '0xbc5168a4f90116fada921e185d4b018e784dc0f6266e539a3c092321c932700a',
      },
    },
  ],
});


================================================
File: examples/rgbpp/spore/local/4-transfer-spore.ts
================================================
import {
  buildRgbppLockArgs,
  appendCkbTxWitnesses,
  updateCkbTxWithRealBtcTxId,
  sendCkbTx,
  getSporeTypeScript,
  Hex,
  generateSporeTransferCoBuild,
  genTransferSporeCkbVirtualTx,
} from 'rgbpp/ckb';
import { sendRgbppUtxos } from 'rgbpp/btc';
import { BtcAssetsApiError } from 'rgbpp';
import { serializeScript } from '@nervosnetwork/ckb-sdk-utils';
import { isMainnet, collector, btcDataSource, btcService, btcAccount, BTC_TESTNET_TYPE } from '../../env';
import { saveCkbVirtualTxResult } from '../../shared/utils';
import { signAndSendPsbt } from '../../shared/btc-account';

interface SporeTransferParams {
  sporeRgbppLockArgs: Hex;
  toBtcAddress: string;
  sporeTypeArgs: Hex;
}

// Warning: It is not recommended for developers to use local examples unless you understand the entire process of RGB++ transactions.
const transferSpore = async ({ sporeRgbppLockArgs, toBtcAddress, sporeTypeArgs }: SporeTransferParams) => {
  // The spore type script is from 3-create-spore.ts, you can find it from the ckb tx spore output cells
  const sporeTypeBytes = serializeScript({
    ...getSporeTypeScript(isMainnet),
    args: sporeTypeArgs,
  });

  const ckbVirtualTxResult = await genTransferSporeCkbVirtualTx({
    collector,
    sporeRgbppLockArgs,
    sporeTypeBytes,
    isMainnet,
    ckbFeeRate: BigInt(5000),
    btcTestnetType: BTC_TESTNET_TYPE,
  });

  // Save ckbVirtualTxResult
  saveCkbVirtualTxResult(ckbVirtualTxResult, '4-transfer-spore-local');

  const { commitment, ckbRawTx, sporeCell, needPaymasterCell } = ckbVirtualTxResult;

  // console.log(JSON.stringify(ckbRawTx))

  // Send BTC tx
  const psbt = await sendRgbppUtxos({
    ckbVirtualTx: ckbRawTx,
    commitment,
    tos: [toBtcAddress],
    needPaymaster: needPaymasterCell,
    ckbCollector: collector,
    from: btcAccount.from,
    fromPubkey: btcAccount.fromPubkey,
    source: btcDataSource,
    feeRate: 30,
  });

  const { txId: btcTxId, rawTxHex: btcTxBytes } = await signAndSendPsbt(psbt, btcAccount, btcService);
  console.log('BTC TxId: ', btcTxId);

  const interval = setInterval(async () => {
    try {
      console.log('Waiting for BTC tx and proof to be ready');
      const rgbppApiSpvProof = await btcService.getRgbppSpvProof(btcTxId, 0);
      clearInterval(interval);
      // Update CKB transaction with the real BTC txId
      const newCkbRawTx = updateCkbTxWithRealBtcTxId({ ckbRawTx, btcTxId, isMainnet });

      const ckbTx = await appendCkbTxWitnesses({
        ckbRawTx: newCkbRawTx,
        btcTxBytes,
        rgbppApiSpvProof,
      });

      // Replace cobuild witness with the final rgbpp lock script
      ckbTx.witnesses[ckbTx.witnesses.length - 1] = generateSporeTransferCoBuild([sporeCell], ckbTx.outputs);

      // console.log('ckbTx: ', JSON.stringify(ckbTx));

      const txHash = await sendCkbTx({ collector, signedTx: ckbTx });
      console.info(`RGB++ Spore has been transferred and tx hash is ${txHash}`);
    } catch (error) {
      if (!(error instanceof BtcAssetsApiError)) {
        console.error(error);
      }
    }
  }, 30 * 1000);
};

// Please use your real BTC UTXO information on the BTC Testnet
// BTC Testnet3: https://mempool.space/testnet
// BTC Signet: https://mempool.space/signet

// rgbppLockArgs: outIndexU32 + btcTxId
transferSpore({
  // The spore rgbpp lock args is from 3-create-spore.ts
  sporeRgbppLockArgs: buildRgbppLockArgs(1, 'f203c8c13eacdbd126f85d286a963c85f233f8145363b1d997c4d552afb990e1'),
  toBtcAddress: 'tb1qhp9fh9qsfeyh0yhewgu27ndqhs5qlrqwau28m7',
  // Please use your own RGB++ spore asset's sporeTypeArgs
  sporeTypeArgs: '0x42898ea77062256f46e8f1b861d526ae47810ecc51ab50477945d5fa90452706',
});


================================================
File: examples/rgbpp/spore/local/5-leap-spore-to-ckb.ts
================================================
import {
  buildRgbppLockArgs,
  appendCkbTxWitnesses,
  updateCkbTxWithRealBtcTxId,
  sendCkbTx,
  getSporeTypeScript,
  Hex,
  generateSporeTransferCoBuild,
  genLeapSporeFromBtcToCkbVirtualTx,
} from 'rgbpp/ckb';
import { sendRgbppUtxos } from 'rgbpp/btc';
import { serializeScript } from '@nervosnetwork/ckb-sdk-utils';
import { isMainnet, collector, btcDataSource, btcService, btcAccount, BTC_TESTNET_TYPE } from '../../env';
import { BtcAssetsApiError } from 'rgbpp';
import { saveCkbVirtualTxResult } from '../../shared/utils';
import { signAndSendPsbt } from '../../shared/btc-account';

interface SporeLeapParams {
  sporeRgbppLockArgs: Hex;
  toCkbAddress: string;
  sporeTypeArgs: Hex;
}

// Warning: It is not recommended for developers to use local examples unless you understand the entire process of RGB++ transactions.
const leapSpore = async ({ sporeRgbppLockArgs, toCkbAddress, sporeTypeArgs }: SporeLeapParams) => {
  // The spore type script is from 3-create-spore.ts, you can find it from the ckb tx spore output cells
  const sporeTypeBytes = serializeScript({
    ...getSporeTypeScript(isMainnet),
    args: sporeTypeArgs,
  });

  const ckbVirtualTxResult = await genLeapSporeFromBtcToCkbVirtualTx({
    collector,
    sporeRgbppLockArgs,
    sporeTypeBytes,
    toCkbAddress,
    isMainnet,
    btcTestnetType: BTC_TESTNET_TYPE,
  });

  // Save ckbVirtualTxResult
  saveCkbVirtualTxResult(ckbVirtualTxResult, '5-leap-spore-to-ckb-local');

  const { commitment, ckbRawTx, sporeCell, needPaymasterCell } = ckbVirtualTxResult;

  // console.log(JSON.stringify(ckbRawTx))

  // Send BTC tx
  const psbt = await sendRgbppUtxos({
    ckbVirtualTx: ckbRawTx,
    commitment,
    tos: [btcAccount.from],
    needPaymaster: needPaymasterCell,
    ckbCollector: collector,
    from: btcAccount.from,
    fromPubkey: btcAccount.fromPubkey,
    source: btcDataSource,
    feeRate: 120,
  });

  const { txId: btcTxId, rawTxHex: btcTxBytes } = await signAndSendPsbt(psbt, btcAccount, btcService);
  console.log('BTC TxId: ', btcTxId);

  const interval = setInterval(async () => {
    try {
      console.log('Waiting for BTC tx and proof to be ready');
      const rgbppApiSpvProof = await btcService.getRgbppSpvProof(btcTxId, 0);
      clearInterval(interval);
      // Update CKB transaction with the real BTC txId
      const newCkbRawTx = updateCkbTxWithRealBtcTxId({ ckbRawTx, btcTxId, isMainnet });

      const ckbTx = await appendCkbTxWitnesses({
        ckbRawTx: newCkbRawTx,
        btcTxBytes,
        rgbppApiSpvProof,
      });

      // Replace cobuild witness with the final rgbpp lock script
      ckbTx.witnesses[ckbTx.witnesses.length - 1] = generateSporeTransferCoBuild([sporeCell], ckbTx.outputs);

      // console.log('ckbTx: ', JSON.stringify(ckbTx));

      const txHash = await sendCkbTx({ collector, signedTx: ckbTx });
      console.info(`RGB++ Spore has been leaped from BTC to CKB and tx hash is ${txHash}`);
    } catch (error) {
      if (!(error instanceof BtcAssetsApiError)) {
        console.error(error);
      }
    }
  }, 30 * 1000);
};

// Please use your real BTC UTXO information on the BTC Testnet
// BTC Testnet3: https://mempool.space/testnet
// BTC Signet: https://mempool.space/signet

// rgbppLockArgs: outIndexU32 + btcTxId
leapSpore({
  // The spore rgbpp lock args is from 3-create-spore.ts
  sporeRgbppLockArgs: buildRgbppLockArgs(3, 'd8a31796fbd42c546f6b22014b9b82b16586ce1df81b0e7ca9a552cdc492a0af'),
  toCkbAddress: 'ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsq0e4xk4rmg5jdkn8aams492a7jlg73ue0gc0ddfj',
  // Please use your own RGB++ spore asset's sporeTypeArgs
  sporeTypeArgs: '0x42898ea77062256f46e8f1b861d526ae47810ecc51ab50477945d5fa90452706',
});


================================================
File: examples/rgbpp/xudt/1-ckb-leap-btc.ts
================================================
import { serializeScript } from '@nervosnetwork/ckb-sdk-utils';
import { genCkbJumpBtcVirtualTx } from 'rgbpp';
import { getSecp256k1CellDep, buildRgbppLockArgs, getXudtTypeScript } from 'rgbpp/ckb';
import { CKB_PRIVATE_KEY, isMainnet, collector, ckbAddress, BTC_TESTNET_TYPE } from '../env';

interface LeapToBtcParams {
  outIndex: number;
  btcTxId: string;
  xudtTypeArgs: string;
  transferAmount: bigint;
}

const leapFromCkbToBtc = async ({ outIndex, btcTxId, xudtTypeArgs, transferAmount }: LeapToBtcParams) => {
  const toRgbppLockArgs = buildRgbppLockArgs(outIndex, btcTxId);

  // Warning: Please replace with your real xUDT type script here
  const xudtType: CKBComponents.Script = {
    ...getXudtTypeScript(isMainnet),
    args: xudtTypeArgs,
  };

  const ckbRawTx = await genCkbJumpBtcVirtualTx({
    collector,
    fromCkbAddress: ckbAddress,
    toRgbppLockArgs,
    xudtTypeBytes: serializeScript(xudtType),
    transferAmount,
    btcTestnetType: BTC_TESTNET_TYPE,
  });

  const emptyWitness = { lock: '', inputType: '', outputType: '' };
  const unsignedTx: CKBComponents.RawTransactionToSign = {
    ...ckbRawTx,
    cellDeps: [...ckbRawTx.cellDeps, getSecp256k1CellDep(isMainnet)],
    witnesses: [emptyWitness, ...ckbRawTx.witnesses.slice(1)],
  };

  const signedTx = collector.getCkb().signTransaction(CKB_PRIVATE_KEY)(unsignedTx);

  const txHash = await collector.getCkb().rpc.sendTransaction(signedTx, 'passthrough');
  console.info(`Rgbpp asset has been jumped from CKB to BTC and CKB tx hash is ${txHash}`);
};

// Please use your real BTC UTXO information on the BTC Testnet
// BTC Testnet3: https://mempool.space/testnet
// BTC Signet: https://mempool.space/signet
leapFromCkbToBtc({
  outIndex: 1,
  btcTxId: '3f6db9a387587006cb2fa8c6352bc728984bf39cb010789dffe574f27775a6ac',
  // Please use your own RGB++ xudt asset's xudtTypeArgs
  xudtTypeArgs: '0x562e4e8a2f64a3e9c24beb4b7dd002d0ad3b842d0cc77924328e36ad114e3ebe',
  transferAmount: BigInt(800_0000_0000),
});


================================================
File: examples/rgbpp/xudt/2-btc-transfer.ts
================================================
import { buildRgbppLockArgs } from 'rgbpp/ckb';
import { buildRgbppTransferTx } from 'rgbpp';
import { isMainnet, collector, btcService, btcAccount, btcDataSource, BTC_TESTNET_TYPE } from '../env';
import { saveCkbVirtualTxResult } from '../shared/utils';
import { signAndSendPsbt } from '../shared/btc-account';
import { bitcoin } from 'rgbpp/btc';

interface RgbppTransferParams {
  rgbppLockArgsList: string[];
  toBtcAddress: string;
  xudtTypeArgs: string;
  transferAmount: bigint;
}

const transfer = async ({ rgbppLockArgsList, toBtcAddress, xudtTypeArgs, transferAmount }: RgbppTransferParams) => {
  const { ckbVirtualTxResult, btcPsbtHex } = await buildRgbppTransferTx({
    ckb: {
      collector,
      xudtTypeArgs,
      rgbppLockArgsList,
      transferAmount,
    },
    btc: {
      fromAddress: btcAccount.from,
      toAddress: toBtcAddress,
      fromPubkey: btcAccount.fromPubkey,
      dataSource: btcDataSource,
      testnetType: BTC_TESTNET_TYPE,
    },
    isMainnet,
  });

  // Save ckbVirtualTxResult
  saveCkbVirtualTxResult(ckbVirtualTxResult, '2-btc-transfer');

  // Send BTC tx
  const psbt = bitcoin.Psbt.fromHex(btcPsbtHex);
  const { txId: btcTxId } = await signAndSendPsbt(psbt, btcAccount, btcService);
  console.log(`BTC ${BTC_TESTNET_TYPE} TxId: ${btcTxId}`);

  await btcService.sendRgbppCkbTransaction({ btc_txid: btcTxId, ckb_virtual_result: ckbVirtualTxResult });

  try {
    const interval = setInterval(async () => {
      const { state, failedReason } = await btcService.getRgbppTransactionState(btcTxId);
      console.log('state', state);
      if (state === 'completed' || state === 'failed') {
        clearInterval(interval);
        if (state === 'completed') {
          const { txhash: txHash } = await btcService.getRgbppTransactionHash(btcTxId);
          console.info(`Rgbpp asset has been transferred on BTC and the related CKB tx hash is ${txHash}`);
        } else {
          console.warn(`Rgbpp CKB transaction failed and the reason is ${failedReason} `);
        }
      }
    }, 30 * 1000);
  } catch (error) {
    console.error(error);
  }
};

// Please use your real BTC UTXO information on the BTC Testnet
// BTC Testnet3: https://mempool.space/testnet
// BTC Signet: https://mempool.space/signet

// rgbppLockArgs: outIndexU32 + btcTxId
transfer({
  rgbppLockArgsList: [buildRgbppLockArgs(1, '5ddd7b60ba93e01d9781be50eaa5c1aa634f799fc9c47bf59d1566eacf47b1e8')],
  toBtcAddress: 'tb1qvt7p9g6mw70sealdewtfp0sekquxuru6j3gwmt',
  // Please use your own RGB++ xudt asset's xudtTypeArgs
  xudtTypeArgs: '0x562e4e8a2f64a3e9c24beb4b7dd002d0ad3b842d0cc77924328e36ad114e3ebe',
  transferAmount: BigInt(800_0000_0000),
});


================================================
File: examples/rgbpp/xudt/3-btc-leap-ckb.ts
================================================
import { buildRgbppLockArgs, getXudtTypeScript } from 'rgbpp/ckb';
import { serializeScript } from '@nervosnetwork/ckb-sdk-utils';
import { genBtcJumpCkbVirtualTx, sendRgbppUtxos } from 'rgbpp';
import { isMainnet, collector, btcService, btcDataSource, btcAccount, BTC_TESTNET_TYPE } from '../env';
import { saveCkbVirtualTxResult } from '../shared/utils';
import { signAndSendPsbt } from '../shared/btc-account';

interface LeapToCkbParams {
  rgbppLockArgsList: string[];
  toCkbAddress: string;
  xudtTypeArgs: string;
  transferAmount: bigint;
}

const leapFromBtcToCKB = async ({ rgbppLockArgsList, toCkbAddress, xudtTypeArgs, transferAmount }: LeapToCkbParams) => {
  const xudtType: CKBComponents.Script = {
    ...getXudtTypeScript(isMainnet),
    args: xudtTypeArgs,
  };

  const ckbVirtualTxResult = await genBtcJumpCkbVirtualTx({
    collector,
    rgbppLockArgsList,
    xudtTypeBytes: serializeScript(xudtType),
    transferAmount,
    toCkbAddress,
    isMainnet,
    btcTestnetType: BTC_TESTNET_TYPE,
    // btcConfirmationBlocks: 20,   // default value is 6
  });

  // Save ckbVirtualTxResult
  saveCkbVirtualTxResult(ckbVirtualTxResult, '3-btc-leap-ckb');

  const { commitment, ckbRawTx } = ckbVirtualTxResult;

  // Send BTC tx
  const psbt = await sendRgbppUtxos({
    ckbVirtualTx: ckbRawTx,
    commitment,
    tos: [btcAccount.from],
    ckbCollector: collector,
    from: btcAccount.from,
    fromPubkey: btcAccount.fromPubkey,
    source: btcDataSource,
  });

  const { txId: btcTxId } = await signAndSendPsbt(psbt, btcAccount, btcService);
  console.log(`BTC ${BTC_TESTNET_TYPE} TxId: ${btcTxId}`);

  await btcService.sendRgbppCkbTransaction({ btc_txid: btcTxId, ckb_virtual_result: ckbVirtualTxResult });

  try {
    const interval = setInterval(async () => {
      const { state, failedReason } = await btcService.getRgbppTransactionState(btcTxId);
      console.log('state', state);
      if (state === 'completed' || state === 'failed') {
        clearInterval(interval);
        if (state === 'completed') {
          const { txhash: txHash } = await btcService.getRgbppTransactionHash(btcTxId);
          console.info(`Rgbpp asset has been jumped from BTC to CKB and the related CKB tx hash is ${txHash}`);
        } else {
          console.warn(`Rgbpp CKB transaction failed and the reason is ${failedReason} `);
        }
      }
    }, 30 * 1000);
  } catch (error) {
    console.error(error);
  }
};

// Please use your real BTC UTXO information on the BTC Testnet
// BTC Testnet3: https://mempool.space/testnet
// BTC Signet: https://mempool.space/signet

// rgbppLockArgs: outIndexU32 + btcTxId
leapFromBtcToCKB({
  rgbppLockArgsList: [buildRgbppLockArgs(1, '52148de63ddd4dcd8ba1d2e105d43c62adf6ccd7e7098c24616640cd5e485c03')],
  toCkbAddress: 'ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsq0e4xk4rmg5jdkn8aams492a7jlg73ue0gc0ddfj',
  // Please use your own RGB++ xudt asset's xudtTypeArgs
  xudtTypeArgs: '0x562e4e8a2f64a3e9c24beb4b7dd002d0ad3b842d0cc77924328e36ad114e3ebe',
  transferAmount: BigInt(800_0000_0000),
});


================================================
File: examples/rgbpp/xudt/4-unlock-btc-time-cell.ts
================================================
import { buildBtcTimeCellsSpentTx, signBtcTimeCellSpentTx } from 'rgbpp';
import { sendCkbTx, getBtcTimeLockScript } from 'rgbpp/ckb';
import { BTC_TESTNET_TYPE, CKB_PRIVATE_KEY, btcService, ckbAddress, collector, isMainnet } from '../env';

// Warning: Wait at least 6 BTC confirmation blocks to spend the BTC time cells after 3-btc-leap-ckb.ts
const unlockBtcTimeCell = async ({ btcTimeCellArgs }: { btcTimeCellArgs: string }) => {
  const btcTimeCells = await collector.getCells({
    lock: {
      ...getBtcTimeLockScript(isMainnet, BTC_TESTNET_TYPE),
      args: btcTimeCellArgs,
    },
    isDataMustBeEmpty: false,
  });

  if (!btcTimeCells || btcTimeCells.length === 0) {
    throw new Error('No btc time cell found');
  }

  const ckbRawTx: CKBComponents.RawTransaction = await buildBtcTimeCellsSpentTx({
    btcTimeCells,
    btcAssetsApi: btcService,
    isMainnet,
    btcTestnetType: BTC_TESTNET_TYPE,
  });

  const signedTx = await signBtcTimeCellSpentTx({
    secp256k1PrivateKey: CKB_PRIVATE_KEY,
    collector,
    masterCkbAddress: ckbAddress,
    ckbRawTx,
    isMainnet,
  });

  const txHash = await sendCkbTx({ collector, signedTx });
  console.info(`BTC time cell has been spent and CKB tx hash is ${txHash}`);
};

// The btcTimeCellArgs is from the outputs[0].lock.args(BTC Time lock args) of the 3-btc-leap-ckb.ts CKB transaction
unlockBtcTimeCell({
  btcTimeCellArgs:
    '0x7d00000010000000590000005d000000490000001000000030000000310000009bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce80114000000f9a9ad51ed14936d33f7bb854aaefa5f47a3ccbd880d0100ffc34d3d23f86df84a23a3b2cf72b45c8a309fec417ab196bee8e7a74483e05f',
});


================================================
File: examples/rgbpp/xudt/btc-transfer-all/1-btc-transfer-all.ts
================================================
import { bitcoin } from 'rgbpp/btc';
import { buildRgbppTransferAllTxs, sendRgbppTxGroups } from 'rgbpp';
import { btcDataSource, isMainnet, collector, btcAccount } from '../../env';
import { signPsbt } from '../../shared/btc-account';
import { saveCkbVirtualTxResult } from '../../shared/utils';

interface TestParams {
  xudtTypeArgs: string;
  fromAddress: string;
  toAddress: string;
}

const rgbppTransferAllTxs = async ({ xudtTypeArgs, fromAddress, toAddress }: TestParams) => {
  const result = await buildRgbppTransferAllTxs({
    ckb: {
      xudtTypeArgs,
      collector,
    },
    btc: {
      assetAddresses: [fromAddress],
      fromAddress: fromAddress,
      toAddress: toAddress,
      dataSource: btcDataSource,
      feeRate: 5,
    },
    isMainnet,
  });

  console.log('result.transactions.length', result.transactions.length);
  console.log('result.summary.included.assets', result.summary.included.xudtAssets);
  console.log('result.summary.excluded.assets', result.summary.excluded.xudtAssets);

  const signedGroups = await Promise.all(
    result.transactions.map(async (group) => {
      const psbt = bitcoin.Psbt.fromHex(group.btc.psbtHex);

      // Sign transactions
      signPsbt(psbt, btcAccount);

      psbt.finalizeAllInputs();

      return {
        ckbVirtualTxResult: JSON.stringify(group.ckb.virtualTxResult),
        btcTxHex: psbt.extractTransaction().toHex(),
      };
    }),
  );

  const signedGroupsData = JSON.parse(JSON.stringify(signedGroups, null, 2));

  // Save signedGroupsData
  saveCkbVirtualTxResult(signedGroupsData, '1-btc-transfer-all');

  console.log('signedGroups', signedGroupsData);

  // Send transactions
  const sentGroups = await sendRgbppTxGroups({
    txGroups: signedGroups,
    btcService: btcDataSource.service,
  });
  console.log('sentGroups', JSON.stringify(sentGroups, null, 2));
};

rgbppTransferAllTxs({
  // Please use your own RGB++ xudt asset's xudtTypeArgs
  xudtTypeArgs: '0xdec25e81ad1d5b909926265b0cdf404e270250b9885d436852b942d56d06be38',
  fromAddress: btcAccount.from,
  toAddress: 'tb1qdnvvnyhc5wegxgh0udwaej04n8w08ahrr0w4q9',
}).catch(console.error);


================================================
File: examples/rgbpp/xudt/compatible-xudt/1-ckb-leap-btc.ts
================================================
import { serializeScript } from '@nervosnetwork/ckb-sdk-utils';
import { genCkbJumpBtcVirtualTx } from 'rgbpp';
import { getSecp256k1CellDep, buildRgbppLockArgs, CompatibleXUDTRegistry } from 'rgbpp/ckb';
import { CKB_PRIVATE_KEY, isMainnet, collector, ckbAddress, BTC_TESTNET_TYPE } from '../../env';

interface LeapToBtcParams {
  outIndex: number;
  btcTxId: string;
  transferAmount: bigint;
  compatibleXudtTypeScript: CKBComponents.Script;
}

const leapRusdFromCkbToBtc = async ({
  outIndex,
  btcTxId,
  transferAmount,
  compatibleXudtTypeScript,
}: LeapToBtcParams) => {
  const toRgbppLockArgs = buildRgbppLockArgs(outIndex, btcTxId);

  // Refresh the cache by fetching the latest compatible xUDT list from the specified URL.
  // The default URL is:
  // https://raw.githubusercontent.com/utxostack/typeid-contract-cell-deps/main/compatible-udt.json
  // You can set your own trusted URL to fetch the compatible xUDT list.
  // await CompatibleXUDTRegistry.refreshCache("https://your-own-trusted-compatible-xudt-url");
  await CompatibleXUDTRegistry.refreshCache();

  const ckbRawTx = await genCkbJumpBtcVirtualTx({
    collector,
    fromCkbAddress: ckbAddress,
    toRgbppLockArgs,
    xudtTypeBytes: serializeScript(compatibleXudtTypeScript),
    transferAmount,
    btcTestnetType: BTC_TESTNET_TYPE,
  });

  const emptyWitness = { lock: '', inputType: '', outputType: '' };
  const unsignedTx: CKBComponents.RawTransactionToSign = {
    ...ckbRawTx,
    cellDeps: [...ckbRawTx.cellDeps, getSecp256k1CellDep(isMainnet)],
    witnesses: [emptyWitness, ...ckbRawTx.witnesses.slice(1)],
  };

  const signedTx = collector.getCkb().signTransaction(CKB_PRIVATE_KEY)(unsignedTx);

  const txHash = await collector.getCkb().rpc.sendTransaction(signedTx, 'passthrough');
  console.info(`Rgbpp compatible xUDT asset has been leaped from CKB to BTC and CKB tx hash is ${txHash}`);
};

// Please use your real BTC UTXO information on the BTC Testnet
// BTC Testnet3: https://mempool.space/testnet
// BTC Signet: https://mempool.space/signet
leapRusdFromCkbToBtc({
  outIndex: 4,
  btcTxId: '44de1b4e3ddaa95cc85cc8b1c60f3e439d343002f0c60980fb4c70841ee0c75e',
  // Please use your own RGB++ compatible xUDT asset's type script
  compatibleXudtTypeScript: {
    codeHash: '0x1142755a044bf2ee358cba9f2da187ce928c91cd4dc8692ded0337efa677d21a',
    hashType: 'type',
    args: '0x878fcc6f1f08d48e87bb1c3b3d5083f23f8a39c5d5c764f253b55b998526439b',
  },
  transferAmount: BigInt(1000_0000),
});


================================================
File: examples/rgbpp/xudt/compatible-xudt/2-btc-transfer.ts
================================================
import { buildRgbppLockArgs, CompatibleXUDTRegistry } from 'rgbpp/ckb';
import { buildRgbppTransferTx } from 'rgbpp';
import { isMainnet, collector, btcService, btcAccount, btcDataSource, BTC_TESTNET_TYPE } from '../../env';
import { saveCkbVirtualTxResult } from '../../shared/utils';
import { signAndSendPsbt } from '../../shared/btc-account';
import { bitcoin } from 'rgbpp/btc';

interface RgbppTransferParams {
  rgbppLockArgsList: string[];
  toBtcAddress: string;
  transferAmount: bigint;
  compatibleXudtTypeScript: CKBComponents.Script;
}

const transferRusdOnBtc = async ({
  rgbppLockArgsList,
  toBtcAddress,
  compatibleXudtTypeScript,
  transferAmount,
}: RgbppTransferParams) => {
  // Refresh the cache by fetching the latest compatible xUDT list from the specified URL.
  // The default URL is:
  // https://raw.githubusercontent.com/utxostack/typeid-contract-cell-deps/main/compatible-udt.json
  // You can set your own trusted URL to fetch the compatible xUDT list.
  // await CompatibleXUDTRegistry.refreshCache("https://your-own-trusted-compatible-xudt-url");
  await CompatibleXUDTRegistry.refreshCache();

  const { ckbVirtualTxResult, btcPsbtHex } = await buildRgbppTransferTx({
    ckb: {
      collector,
      xudtTypeArgs: compatibleXudtTypeScript.args,
      rgbppLockArgsList,
      transferAmount,
      compatibleXudtTypeScript,
    },
    btc: {
      fromAddress: btcAccount.from,
      toAddress: toBtcAddress,
      fromPubkey: btcAccount.fromPubkey,
      dataSource: btcDataSource,
      testnetType: BTC_TESTNET_TYPE,
    },
    isMainnet,
  });

  // Save ckbVirtualTxResult
  saveCkbVirtualTxResult(ckbVirtualTxResult, '2-btc-transfer');

  // Send BTC tx
  const psbt = bitcoin.Psbt.fromHex(btcPsbtHex);
  const { txId: btcTxId } = await signAndSendPsbt(psbt, btcAccount, btcService);
  console.log(`BTC ${BTC_TESTNET_TYPE} TxId: ${btcTxId}`);

  await btcService.sendRgbppCkbTransaction({ btc_txid: btcTxId, ckb_virtual_result: ckbVirtualTxResult });

  try {
    const interval = setInterval(async () => {
      const { state, failedReason } = await btcService.getRgbppTransactionState(btcTxId);
      console.log('state', state);
      if (state === 'completed' || state === 'failed') {
        clearInterval(interval);
        if (state === 'completed') {
          const { txhash: txHash } = await btcService.getRgbppTransactionHash(btcTxId);
          console.info(
            `Rgbpp compatible xUDT asset has been transferred on BTC and the related CKB tx hash is ${txHash}`,
          );
        } else {
          console.warn(`Rgbpp CKB transaction failed and the reason is ${failedReason} `);
        }
      }
    }, 30 * 1000);
  } catch (error) {
    console.error(error);
  }
};

// Please use your real BTC UTXO information on the BTC Testnet
// BTC Testnet3: https://mempool.space/testnet
// BTC Signet: https://mempool.space/signet

// rgbppLockArgs: outIndexU32 + btcTxId
transferRusdOnBtc({
  rgbppLockArgsList: [buildRgbppLockArgs(4, '44de1b4e3ddaa95cc85cc8b1c60f3e439d343002f0c60980fb4c70841ee0c75e')],
  toBtcAddress: 'tb1qvt7p9g6mw70sealdewtfp0sekquxuru6j3gwmt',
  // Please use your own RGB++ compatible xudt asset's type script
  compatibleXudtTypeScript: {
    codeHash: '0x1142755a044bf2ee358cba9f2da187ce928c91cd4dc8692ded0337efa677d21a',
    hashType: 'type',
    args: '0x878fcc6f1f08d48e87bb1c3b3d5083f23f8a39c5d5c764f253b55b998526439b',
  },
  transferAmount: BigInt(100_0000),
});


================================================
File: examples/rgbpp/xudt/compatible-xudt/3-btc-leap-ckb.ts
================================================
import { buildRgbppLockArgs, CompatibleXUDTRegistry } from 'rgbpp/ckb';
import { serializeScript } from '@nervosnetwork/ckb-sdk-utils';
import { genBtcJumpCkbVirtualTx, sendRgbppUtxos } from 'rgbpp';
import { isMainnet, collector, btcService, btcDataSource, btcAccount, BTC_TESTNET_TYPE } from '../../env';
import { saveCkbVirtualTxResult } from '../../shared/utils';
import { signAndSendPsbt } from '../../shared/btc-account';

interface LeapToCkbParams {
  rgbppLockArgsList: string[];
  toCkbAddress: string;
  transferAmount: bigint;
  compatibleXudtTypeScript: CKBComponents.Script;
}

const leapRusdFromBtcToCKB = async ({
  rgbppLockArgsList,
  toCkbAddress,
  compatibleXudtTypeScript,
  transferAmount,
}: LeapToCkbParams) => {
  // Refresh the cache by fetching the latest compatible xUDT list from the specified URL.
  // The default URL is:
  // https://raw.githubusercontent.com/utxostack/typeid-contract-cell-deps/main/compatible-udt.json
  // You can set your own trusted URL to fetch the compatible xUDT list.
  // await CompatibleXUDTRegistry.refreshCache("https://your-own-trusted-compatible-xudt-url");
  await CompatibleXUDTRegistry.refreshCache();

  const ckbVirtualTxResult = await genBtcJumpCkbVirtualTx({
    collector,
    rgbppLockArgsList,
    xudtTypeBytes: serializeScript(compatibleXudtTypeScript),
    transferAmount,
    toCkbAddress,
    isMainnet,
    btcTestnetType: BTC_TESTNET_TYPE,
    // btcConfirmationBlocks: 20,   // default value is 6
  });

  // Save ckbVirtualTxResult
  saveCkbVirtualTxResult(ckbVirtualTxResult, '3-btc-leap-ckb');

  const { commitment, ckbRawTx } = ckbVirtualTxResult;

  // Send BTC tx
  const psbt = await sendRgbppUtxos({
    ckbVirtualTx: ckbRawTx,
    commitment,
    tos: [btcAccount.from],
    ckbCollector: collector,
    from: btcAccount.from,
    fromPubkey: btcAccount.fromPubkey,
    source: btcDataSource,
  });

  const { txId: btcTxId } = await signAndSendPsbt(psbt, btcAccount, btcService);
  console.log(`BTC ${BTC_TESTNET_TYPE} TxId: ${btcTxId}`);

  await btcService.sendRgbppCkbTransaction({ btc_txid: btcTxId, ckb_virtual_result: ckbVirtualTxResult });

  try {
    const interval = setInterval(async () => {
      const { state, failedReason } = await btcService.getRgbppTransactionState(btcTxId);
      console.log('state', state);
      if (state === 'completed' || state === 'failed') {
        clearInterval(interval);
        if (state === 'completed') {
          const { txhash: txHash } = await btcService.getRgbppTransactionHash(btcTxId);
          console.info(
            `Rgbpp compatible xUDT asset has been leaped from BTC to CKB and the related CKB tx hash is ${txHash}`,
          );
        } else {
          console.warn(`Rgbpp CKB transaction failed and the reason is ${failedReason} `);
        }
      }
    }, 30 * 1000);
  } catch (error) {
    console.error(error);
  }
};

// Please use your real BTC UTXO information on the BTC Testnet
// BTC Testnet3: https://mempool.space/testnet
// BTC Signet: https://mempool.space/signet

// rgbppLockArgs: outIndexU32 + btcTxId
leapRusdFromBtcToCKB({
  rgbppLockArgsList: [buildRgbppLockArgs(1, '58ebbdec0dfd464280658e36fadc11c41945de2c4b5b59463dad6e045a7e5faf')],
  toCkbAddress: 'ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsq0e4xk4rmg5jdkn8aams492a7jlg73ue0gc0ddfj',
  // Please use your own RGB++ compatible xudt asset's type script
  compatibleXudtTypeScript: {
    codeHash: '0x1142755a044bf2ee358cba9f2da187ce928c91cd4dc8692ded0337efa677d21a',
    hashType: 'type',
    args: '0x878fcc6f1f08d48e87bb1c3b3d5083f23f8a39c5d5c764f253b55b998526439b',
  },
  transferAmount: BigInt(100_0000),
});


================================================
File: examples/rgbpp/xudt/compatible-xudt/4-unlock-btc-time-cell.ts
================================================
import { buildBtcTimeCellsSpentTx, signBtcTimeCellSpentTx } from 'rgbpp';
import { sendCkbTx, getBtcTimeLockScript } from 'rgbpp/ckb';
import { BTC_TESTNET_TYPE, CKB_PRIVATE_KEY, btcService, ckbAddress, collector, isMainnet } from '../../env';

// Warning: Wait at least 6 BTC confirmation blocks to spend the BTC time cells after 3-btc-leap-ckb.ts
const unlockRusdBtcTimeCell = async ({ btcTimeCellArgs }: { btcTimeCellArgs: string }) => {
  const btcTimeCells = await collector.getCells({
    lock: {
      ...getBtcTimeLockScript(isMainnet, BTC_TESTNET_TYPE),
      args: btcTimeCellArgs,
    },
    isDataMustBeEmpty: false,
  });

  if (!btcTimeCells || btcTimeCells.length === 0) {
    throw new Error('No btc time cell found');
  }

  const ckbRawTx: CKBComponents.RawTransaction = await buildBtcTimeCellsSpentTx({
    btcTimeCells,
    btcAssetsApi: btcService,
    isMainnet,
    btcTestnetType: BTC_TESTNET_TYPE,
  });

  const signedTx = await signBtcTimeCellSpentTx({
    secp256k1PrivateKey: CKB_PRIVATE_KEY,
    collector,
    masterCkbAddress: ckbAddress,
    ckbRawTx,
    isMainnet,
  });

  const txHash = await sendCkbTx({ collector, signedTx });
  console.info(`BTC time cell has been spent and CKB tx hash is ${txHash}`);
};

// The btcTimeCellArgs is from the outputs[0].lock.args(BTC Time lock args) of the 3-btc-leap-ckb.ts CKB transaction
unlockRusdBtcTimeCell({
  btcTimeCellArgs:
    '0x7d00000010000000590000005d000000490000001000000030000000310000009bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce80114000000f9a9ad51ed14936d33f7bb854aaefa5f47a3ccbd0600000038036f35121682517b5f79732fc6a182e0050cfe1ad4cce0a1314c229a1ba364',
});


================================================
File: examples/rgbpp/xudt/compatible-xudt/assets-api.ts
================================================
import { serializeScript } from '@nervosnetwork/ckb-sdk-utils';
import { btcService } from '../../env';

(async () => {
  // const assets = await btcService.getRgbppAssetsByBtcAddress('tb1qvt7p9g6mw70sealdewtfp0sekquxuru6j3gwmt', {
  //   type_script: serializeScript({
  //     codeHash: '0x1142755a044bf2ee358cba9f2da187ce928c91cd4dc8692ded0337efa677d21a',
  //     hashType: 'type',
  //     args: '0x878fcc6f1f08d48e87bb1c3b3d5083f23f8a39c5d5c764f253b55b998526439b',
  //   }),
  // });
  // console.log('RUSD Assets: ', JSON.stringify(assets));

  // const activities = await btcService.getRgbppActivityByBtcAddress('tb1qvt7p9g6mw70sealdewtfp0sekquxuru6j3gwmt', {
  //   type_script: serializeScript({
  //     codeHash: '0x1142755a044bf2ee358cba9f2da187ce928c91cd4dc8692ded0337efa677d21a',
  //     hashType: 'type',
  //     args: '0x878fcc6f1f08d48e87bb1c3b3d5083f23f8a39c5d5c764f253b55b998526439b',
  //   }),
  // });
  // console.log('RUSD Activities: ', JSON.stringify(activities));

  //  const balance = await btcService.getRgbppBalanceByBtcAddress('tb1qvt7p9g6mw70sealdewtfp0sekquxuru6j3gwmt', {
  //    type_script: serializeScript({
  //      codeHash: '0x1142755a044bf2ee358cba9f2da187ce928c91cd4dc8692ded0337efa677d21a',
  //      hashType: 'type',
  //      args: '0x878fcc6f1f08d48e87bb1c3b3d5083f23f8a39c5d5c764f253b55b998526439b',
  //    }),
  //    no_cache: true,
  //  });
  //  console.log('RUSD balance from btc-assets-api: ', JSON.stringify(balance));

  // const info = await btcService.getRgbppAssetInfoByTypeScript(
  //   serializeScript({
  //     codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
  //     hashType: 'type',
  //     args: '0x661cfbe2124b3e79e50e505c406be5b2dcf9da15d8654b749ec536fa4c2eaaae',
  //   }),
  // );
  // console.log('Standard xUDT info: ', JSON.stringify(info));

  const rusdInfo = await btcService.getRgbppAssetInfoByTypeScript(
    serializeScript({
      codeHash: '0xcc9dc33ef234e14bc788c43a4848556a5fb16401a04662fc55db9bb201987037',
      hashType: 'type',
      args: '0x71fd1985b2971a9903e4d8ed0d59e6710166985217ca0681437883837b86162f',
    }),
  );
  console.log('RUSD xUDT info: ', JSON.stringify(rusdInfo));

  // const utxoAirdropInfo = await btcService.getRgbppAssetInfoByTypeScript(
  //   serializeScript({
  //     codeHash: '0xf5da9003e31fa9301a3915fe304de9bdb80524b5f0d8fc325fb699317998ee7a',
  //     hashType: 'type',
  //     args: '0xa63d308c04b4c075eb1d7d5cac891cf20276e3ddb2ec855fc981c88d8134dbe2',
  //   }),
  // );
  // console.log('UTXO Airdrop xUDT info: ', JSON.stringify(utxoAirdropInfo));
})();


================================================
File: examples/rgbpp/xudt/launch/0-rgbpp-token-info.ts
================================================
import { RgbppTokenInfo } from 'rgbpp/ckb';

export const RGBPP_TOKEN_INFO: RgbppTokenInfo = {
  decimal: 8,
  name: 'RGBPP Test Token',
  symbol: 'RTT',
};


================================================
File: examples/rgbpp/xudt/launch/1-prepare-launch.ts
================================================
import { addressToScript, getTransactionSize } from '@nervosnetwork/ckb-sdk-utils';
import {
  MAX_FEE,
  NoLiveCellError,
  RgbppTokenInfo,
  SECP256K1_WITNESS_LOCK_SIZE,
  append0x,
  buildRgbppLockArgs,
  calculateRgbppCellCapacity,
  calculateRgbppTokenInfoCellCapacity,
  calculateTransactionFee,
  genRgbppLockScript,
  getSecp256k1CellDep,
} from 'rgbpp/ckb';
import { RGBPP_TOKEN_INFO } from './0-rgbpp-token-info';
import { BTC_TESTNET_TYPE, CKB_PRIVATE_KEY, ckbAddress, collector, isMainnet } from '../../env';

const prepareLaunchCell = async ({
  outIndex,
  btcTxId,
  rgbppTokenInfo,
}: {
  outIndex: number;
  btcTxId: string;
  rgbppTokenInfo: RgbppTokenInfo;
}) => {
  const masterLock = addressToScript(ckbAddress);
  console.log('ckb address: ', ckbAddress);

  // The capacity required to launch cells is determined by the token info cell capacity, and transaction fee.
  const launchCellCapacity =
    calculateRgbppCellCapacity() + calculateRgbppTokenInfoCellCapacity(rgbppTokenInfo, isMainnet);

  let emptyCells = await collector.getCells({
    lock: masterLock,
  });
  if (!emptyCells || emptyCells.length === 0) {
    throw new NoLiveCellError('The address has no empty cells');
  }
  emptyCells = emptyCells.filter((cell) => !cell.output.type);

  const txFee = MAX_FEE;
  const { inputs, sumInputsCapacity } = collector.collectInputs(emptyCells, launchCellCapacity, txFee);

  const outputs: CKBComponents.CellOutput[] = [
    {
      lock: genRgbppLockScript(buildRgbppLockArgs(outIndex, btcTxId), isMainnet, BTC_TESTNET_TYPE),
      capacity: append0x(launchCellCapacity.toString(16)),
    },
  ];
  let changeCapacity = sumInputsCapacity - launchCellCapacity;
  outputs.push({
    lock: masterLock,
    capacity: append0x(changeCapacity.toString(16)),
  });
  const outputsData = ['0x', '0x'];

  const emptyWitness = { lock: '', inputType: '', outputType: '' };
  const witnesses = inputs.map((_, index) => (index === 0 ? emptyWitness : '0x'));

  const cellDeps = [getSecp256k1CellDep(isMainnet)];

  const unsignedTx = {
    version: '0x0',
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses,
  };

  const txSize = getTransactionSize(unsignedTx) + SECP256K1_WITNESS_LOCK_SIZE;
  const estimatedTxFee = calculateTransactionFee(txSize);
  changeCapacity -= estimatedTxFee;
  unsignedTx.outputs[unsignedTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));

  const signedTx = collector.getCkb().signTransaction(CKB_PRIVATE_KEY)(unsignedTx);
  const txHash = await collector.getCkb().rpc.sendTransaction(signedTx, 'passthrough');

  console.info(`Launch cell has been created and the CKB tx hash ${txHash}`);
};

// Please use your real BTC UTXO information on the BTC Testnet
// BTC Testnet3: https://mempool.space/testnet
// BTC Signet: https://mempool.space/signet
prepareLaunchCell({
  outIndex: 1,
  btcTxId: 'c1f7fe5d4898194ed8ee5a38597cd28c7981e32e0e6aeb770f3f1b87df21434c',
  rgbppTokenInfo: RGBPP_TOKEN_INFO,
});


================================================
File: examples/rgbpp/xudt/launch/2-launch-rgbpp.ts
================================================
import { genRgbppLaunchCkbVirtualTx, sendRgbppUtxos, BtcAssetsApiError } from 'rgbpp';
import {
  buildRgbppLockArgs,
  RgbppTokenInfo,
  appendCkbTxWitnesses,
  updateCkbTxWithRealBtcTxId,
  sendCkbTx,
} from 'rgbpp/ckb';
import { RGBPP_TOKEN_INFO } from './0-rgbpp-token-info';
import { BTC_TESTNET_TYPE, btcAccount, btcDataSource, btcService, collector, isMainnet } from '../../env';
import { saveCkbVirtualTxResult } from '../../shared/utils';
import { signAndSendPsbt } from '../../shared/btc-account';

interface Params {
  ownerRgbppLockArgs: string;
  launchAmount: bigint;
  rgbppTokenInfo: RgbppTokenInfo;
}

// Warning: Before runing this file, please run 2-prepare-launch.ts
const launchRgppAsset = async ({ ownerRgbppLockArgs, launchAmount, rgbppTokenInfo }: Params) => {
  const ckbVirtualTxResult = await genRgbppLaunchCkbVirtualTx({
    collector,
    ownerRgbppLockArgs,
    rgbppTokenInfo,
    launchAmount,
    isMainnet,
    btcTestnetType: BTC_TESTNET_TYPE,
  });

  // Save ckbVirtualTxResult
  saveCkbVirtualTxResult(ckbVirtualTxResult, '2-launch-rgbpp');

  const { commitment, ckbRawTx, needPaymasterCell } = ckbVirtualTxResult;

  console.log('RGB++ Asset type script args: ', ckbRawTx.outputs[0].type?.args);

  // Send BTC tx
  const psbt = await sendRgbppUtxos({
    ckbVirtualTx: ckbRawTx,
    commitment,
    tos: [btcAccount.from],
    needPaymaster: needPaymasterCell,
    ckbCollector: collector,
    from: btcAccount.from,
    fromPubkey: btcAccount.fromPubkey,
    source: btcDataSource,
  });

  const { txId: btcTxId, rawTxHex: btcTxBytes } = await signAndSendPsbt(psbt, btcAccount, btcService);
  console.log(`BTC ${BTC_TESTNET_TYPE} TxId: ${btcTxId}`);

  const interval = setInterval(async () => {
    try {
      console.log('Waiting for BTC tx and proof to be ready');
      const rgbppApiSpvProof = await btcService.getRgbppSpvProof(btcTxId, 0);
      clearInterval(interval);
      // Update CKB transaction with the real BTC txId
      const newCkbRawTx = updateCkbTxWithRealBtcTxId({ ckbRawTx, btcTxId, isMainnet });
      const ckbTx = await appendCkbTxWitnesses({
        ckbRawTx: newCkbRawTx,
        btcTxBytes,
        rgbppApiSpvProof,
      });

      const txHash = await sendCkbTx({ collector, signedTx: ckbTx });
      console.info(`RGB++ Asset has been launched and CKB tx hash is ${txHash}`);
    } catch (error) {
      if (!(error instanceof BtcAssetsApiError)) {
        console.error(error);
      }
    }
  }, 30 * 1000);
};

// Please use your real BTC UTXO information on the BTC Testnet which should be same as the 1-prepare-launch.ts
// BTC Testnet3: https://mempool.space/testnet
// BTC Signet: https://mempool.space/signet

// rgbppLockArgs: outIndexU32 + btcTxId
launchRgppAsset({
  ownerRgbppLockArgs: buildRgbppLockArgs(1, 'c1f7fe5d4898194ed8ee5a38597cd28c7981e32e0e6aeb770f3f1b87df21434c'),
  rgbppTokenInfo: RGBPP_TOKEN_INFO,
  // The total issuance amount of RGBPP Token, the decimal is determined by RGBPP Token info
  launchAmount: BigInt(2100_0000) * BigInt(10 ** RGBPP_TOKEN_INFO.decimal),
});


================================================
File: examples/rgbpp/xudt/launch/3-distribute-rgbpp.ts
================================================
import { serializeScript } from '@nervosnetwork/ckb-sdk-utils';
import { BtcAssetsApiError, genBtcBatchTransferCkbVirtualTx, sendRgbppUtxos } from 'rgbpp';
import { RGBPP_TOKEN_INFO } from './0-rgbpp-token-info';
import {
  isMainnet,
  collector,
  btcDataSource,
  btcService,
  CKB_PRIVATE_KEY,
  ckbAddress,
  btcAccount,
  BTC_TESTNET_TYPE,
} from '../../env';
import {
  RgbppBtcAddressReceiver,
  appendCkbTxWitnesses,
  appendIssuerCellToBtcBatchTransfer,
  buildRgbppLockArgs,
  getXudtTypeScript,
  sendCkbTx,
  updateCkbTxWithRealBtcTxId,
} from 'rgbpp/ckb';
import { saveCkbVirtualTxResult } from '../../shared/utils';
import { signAndSendPsbt } from '../../shared/btc-account';

interface Params {
  rgbppLockArgsList: string[];
  receivers: RgbppBtcAddressReceiver[];
  xudtTypeArgs: string;
}

// Warning: Before runing this file for the first time, please run 2-launch-rgbpp.ts
const distributeRgbppAssetOnBtc = async ({ rgbppLockArgsList, receivers, xudtTypeArgs }: Params) => {
  // Warning: Please replace with your real xUDT type script here
  const xudtType: CKBComponents.Script = {
    ...getXudtTypeScript(isMainnet),
    // The xUDT type script args is generated by 2-launch-rgbpp.ts, and it can be found from the log
    args: xudtTypeArgs,
  };

  const ckbVirtualTxResult = await genBtcBatchTransferCkbVirtualTx({
    collector,
    rgbppLockArgsList,
    xudtTypeBytes: serializeScript(xudtType),
    rgbppReceivers: receivers,
    isMainnet,
    btcTestnetType: BTC_TESTNET_TYPE,
  });

  // Save ckbVirtualTxResult
  saveCkbVirtualTxResult(ckbVirtualTxResult, '3-distribute-rgbpp');

  const { commitment, ckbRawTx, sumInputsCapacity, rgbppChangeOutIndex, needPaymasterCell } = ckbVirtualTxResult;

  // The first output utxo is OP_RETURN
  // Rgbpp change utxo position depends on the number of distributions, if 50 addresses are distributed, then the change utxo position is 51
  console.log('RGB++ asset change utxo out index: ', rgbppChangeOutIndex);

  // Send BTC tx
  const psbt = await sendRgbppUtxos({
    ckbVirtualTx: ckbRawTx,
    commitment,
    tos: receivers.map((receiver) => receiver.toBtcAddress),
    needPaymaster: needPaymasterCell,
    ckbCollector: collector,
    from: btcAccount.from,
    fromPubkey: btcAccount.fromPubkey,
    source: btcDataSource,
  });

  const { txId: btcTxId, rawTxHex: btcTxBytes } = await signAndSendPsbt(psbt, btcAccount, btcService);
  console.log(`BTC ${BTC_TESTNET_TYPE} TxId: ${btcTxId}`);

  const interval = setInterval(async () => {
    try {
      console.log('Waiting for BTC tx and proof to be ready');
      const rgbppApiSpvProof = await btcService.getRgbppSpvProof(btcTxId, 0);
      clearInterval(interval);
      // Update CKB transaction with the real BTC txId
      const newCkbRawTx = updateCkbTxWithRealBtcTxId({ ckbRawTx, btcTxId, isMainnet });
      const ckbTx = await appendCkbTxWitnesses({
        ckbRawTx: newCkbRawTx,
        btcTxBytes,
        rgbppApiSpvProof,
      });

      const signedTx = await appendIssuerCellToBtcBatchTransfer({
        secp256k1PrivateKey: CKB_PRIVATE_KEY,
        issuerAddress: ckbAddress,
        ckbRawTx: ckbTx,
        collector,
        sumInputsCapacity,
        isMainnet,
      });

      const txHash = await sendCkbTx({ collector, signedTx });
      console.info(`RGB++ Asset has been distributed and CKB tx hash is ${txHash}`);
    } catch (error) {
      if (!(error instanceof BtcAssetsApiError)) {
        console.error(error);
      }
    }
  }, 20 * 1000);
};

// Please use your real BTC UTXO information on the BTC Testnet
// BTC Testnet3: https://mempool.space/testnet
// BTC Signet: https://mempool.space/signet

// rgbppLockArgs: outIndexU32 + btcTxId
distributeRgbppAssetOnBtc({
  // Warning: If rgbpp assets are distributed continuously, then the position of the current rgbpp asset utxo depends on the position of the previous change utxo distributed
  rgbppLockArgsList: [buildRgbppLockArgs(1, '5ab72e296c7e4f93302f5b1827c59860a95b94958942c65977bf25fcd7364bf3')],
  // The xudtTypeArgs comes from the logs "RGB++ Asset type script args" of 2-launch-rgbpp.ts
  xudtTypeArgs: '0x157339c6b1ad2156bc9aa3f901abb07253f198160fb484226127ccafedd690c8',
  receivers: [
    {
      toBtcAddress: 'tb1qhp9fh9qsfeyh0yhewgu27ndqhs5qlrqwau28m7',
      transferAmount: BigInt(1000) * BigInt(10 ** RGBPP_TOKEN_INFO.decimal),
    },
  ],
});


================================================
File: examples/rgbpp/xudt/local/2-btc-transfer.ts
================================================
import { BtcAssetsApiError, buildRgbppTransferTx } from 'rgbpp';
import { appendCkbTxWitnesses, buildRgbppLockArgs, sendCkbTx, updateCkbTxWithRealBtcTxId } from 'rgbpp/ckb';
import { isMainnet, collector, btcDataSource, btcService, btcAccount, BTC_TESTNET_TYPE } from '../../env';
import { bitcoin } from 'rgbpp/btc';
import { saveCkbVirtualTxResult } from '../../shared/utils';
import { signAndSendPsbt } from '../../shared/btc-account';

interface RgbppTransferParams {
  rgbppLockArgsList: string[];
  toBtcAddress: string;
  xudtTypeArgs: string;
  transferAmount: bigint;
}

// Warning: It is not recommended for developers to use local examples unless you understand the entire process of RGB++ transactions.
const transfer = async ({ rgbppLockArgsList, toBtcAddress, xudtTypeArgs, transferAmount }: RgbppTransferParams) => {
  const { ckbVirtualTxResult, btcPsbtHex } = await buildRgbppTransferTx({
    ckb: {
      collector,
      xudtTypeArgs,
      rgbppLockArgsList,
      transferAmount,
    },
    btc: {
      fromAddress: btcAccount.from,
      toAddress: toBtcAddress,
      fromPubkey: btcAccount.fromPubkey,
      dataSource: btcDataSource,
      testnetType: BTC_TESTNET_TYPE,
    },
    isMainnet,
  });

  // Save ckbVirtualTxResult
  saveCkbVirtualTxResult(ckbVirtualTxResult, '2-btc-transfer-local');

  const { ckbRawTx } = ckbVirtualTxResult;

  // Send BTC tx
  const psbt = bitcoin.Psbt.fromHex(btcPsbtHex);
  const { txId: btcTxId, rawTxHex: btcTxBytes } = await signAndSendPsbt(psbt, btcAccount, btcService);
  console.log(`BTC ${BTC_TESTNET_TYPE} TxId: ${btcTxId}`);

  // Wait for BTC tx and proof to be ready, and then send isomorphic CKB transactions
  const interval = setInterval(async () => {
    try {
      console.log(`Waiting for BTC tx and proof to be ready`);
      const rgbppApiSpvProof = await btcService.getRgbppSpvProof(btcTxId, 0);
      clearInterval(interval);
      // Update CKB transaction with the real BTC txId
      const newCkbRawTx = updateCkbTxWithRealBtcTxId({ ckbRawTx, btcTxId, isMainnet });
      const ckbTx = await appendCkbTxWitnesses({
        ckbRawTx: newCkbRawTx,
        btcTxBytes,
        rgbppApiSpvProof,
      });

      const txHash = await sendCkbTx({ collector, signedTx: ckbTx });
      console.info(`RGB++ Asset has been transferred on BTC and the CKB tx hash is ${txHash}`);
    } catch (error) {
      if (!(error instanceof BtcAssetsApiError)) {
        console.error(error);
      }
    }
  }, 30 * 1000);
};

// Please use your real BTC UTXO information on the BTC Signet Testnet
// BTC Testnet3: https://mempool.space/testnet
// BTC Signet: https://mempool.space/signet

// rgbppLockArgs: outIndexU32 + btcTxId
transfer({
  rgbppLockArgsList: [buildRgbppLockArgs(2, '57212668f2738aa07a51861a2f8cd7a083aab05b01ede8b79dff948c0041f808')],
  toBtcAddress: 'tb1qhp9fh9qsfeyh0yhewgu27ndqhs5qlrqwau28m7',
  // Please use your own RGB++ asset's xudtTypeArgs
  xudtTypeArgs: '0x562e4e8a2f64a3e9c24beb4b7dd002d0ad3b842d0cc77924328e36ad114e3ebe',
  transferAmount: BigInt(800_0000_0000),
});


================================================
File: examples/rgbpp/xudt/local/3-btc-leap-ckb.ts
================================================
import { serializeScript } from '@nervosnetwork/ckb-sdk-utils';
import { genBtcJumpCkbVirtualTx, sendRgbppUtxos, BtcAssetsApiError } from 'rgbpp';
import {
  appendCkbTxWitnesses,
  buildRgbppLockArgs,
  sendCkbTx,
  getXudtTypeScript,
  updateCkbTxWithRealBtcTxId,
} from 'rgbpp/ckb';
import { isMainnet, collector, btcDataSource, btcService, btcAccount, BTC_TESTNET_TYPE } from '../../env';
import { saveCkbVirtualTxResult } from '../../shared/utils';
import { signAndSendPsbt } from '../../shared/btc-account';

interface LeapToCkbParams {
  rgbppLockArgsList: string[];
  toCkbAddress: string;
  xudtTypeArgs: string;
  transferAmount: bigint;
}

// Warning: It is not recommended for developers to use local examples unless you understand the entire process of RGB++ transactions.
const leapFromBtcToCkb = async ({ rgbppLockArgsList, toCkbAddress, xudtTypeArgs, transferAmount }: LeapToCkbParams) => {
  const xudtType: CKBComponents.Script = {
    ...getXudtTypeScript(isMainnet),
    args: xudtTypeArgs,
  };

  const ckbVirtualTxResult = await genBtcJumpCkbVirtualTx({
    collector,
    rgbppLockArgsList,
    xudtTypeBytes: serializeScript(xudtType),
    transferAmount,
    toCkbAddress,
    isMainnet,
    btcTestnetType: BTC_TESTNET_TYPE,
  });

  // Save ckbVirtualTxResult
  saveCkbVirtualTxResult(ckbVirtualTxResult, '3-btc-leap-ckb-local');

  const { commitment, ckbRawTx } = ckbVirtualTxResult;

  console.log('ckbRawTx', JSON.stringify(ckbRawTx));

  // Send BTC tx
  const psbt = await sendRgbppUtxos({
    ckbVirtualTx: ckbRawTx,
    commitment,
    tos: [btcAccount.from],
    ckbCollector: collector,
    from: btcAccount.from,
    fromPubkey: btcAccount.fromPubkey,
    source: btcDataSource,
  });

  const { txId: btcTxId, rawTxHex: btcTxBytes } = await signAndSendPsbt(psbt, btcAccount, btcService);
  console.log(`BTC ${BTC_TESTNET_TYPE} TxId: ${btcTxId}`);

  // Wait for BTC tx and proof to be ready, and then send isomorphic CKB transactions
  const interval = setInterval(async () => {
    try {
      console.log('Waiting for BTC tx and proof to be ready');
      const rgbppApiSpvProof = await btcService.getRgbppSpvProof(btcTxId, 0);
      clearInterval(interval);
      // Update CKB transaction with the real BTC txId
      const newCkbRawTx = updateCkbTxWithRealBtcTxId({ ckbRawTx, btcTxId, isMainnet });
      const ckbTx = await appendCkbTxWitnesses({
        ckbRawTx: newCkbRawTx,
        btcTxBytes,
        rgbppApiSpvProof,
      });

      console.log(JSON.stringify(ckbTx));

      const txHash = await sendCkbTx({ collector, signedTx: ckbTx });
      console.info(`RGB++ Asset has been leaped from BTC to CKB and the CKB tx hash is ${txHash}`);
    } catch (error) {
      if (!(error instanceof BtcAssetsApiError)) {
        console.error(error);
      }
    }
  }, 30 * 1000);
};

// Please use your real BTC UTXO information on the BTC Testnet
// BTC Testnet3: https://mempool.space/testnet
// BTC Signet: https://mempool.space/signet

// rgbppLockArgs: outIndexU32 + btcTxId
leapFromBtcToCkb({
  rgbppLockArgsList: [buildRgbppLockArgs(1, '3f6db9a387587006cb2fa8c6352bc728984bf39cb010789dffe574f27775a6ac')],
  toCkbAddress: 'ckt1qrfrwcdnvssswdwpn3s9v8fp87emat306ctjwsm3nmlkjg8qyza2cqgqq9kxr7vy7yknezj0vj0xptx6thk6pwyr0sxamv6q',
  // Please use your own RGB++ xudt asset's xudtTypeArgs
  xudtTypeArgs: '0x562e4e8a2f64a3e9c24beb4b7dd002d0ad3b842d0cc77924328e36ad114e3ebe',
  transferAmount: BigInt(800_0000_0000),
});


================================================
File: examples/rgbpp/xudt/offline/0-rgbpp-token-info.ts
================================================
import { RgbppTokenInfo } from 'rgbpp/ckb';

export const RGBPP_TOKEN_INFO: RgbppTokenInfo = {
  decimal: 8,
  name: 'OK RGBPP Test Token',
  symbol: 'OKRTT',
};


================================================
File: examples/rgbpp/xudt/offline/1-prepare-launch.ts
================================================
import { addressToScript, getTransactionSize } from '@nervosnetwork/ckb-sdk-utils';
import {
  MAX_FEE,
  RgbppTokenInfo,
  SECP256K1_WITNESS_LOCK_SIZE,
  append0x,
  buildRgbppLockArgs,
  calculateRgbppCellCapacity,
  calculateRgbppTokenInfoCellCapacity,
  calculateTransactionFee,
  genRgbppLockScript,
  getSecp256k1CellDep,
  signCkbTransaction,
} from 'rgbpp/ckb';
import { RGBPP_TOKEN_INFO } from './0-rgbpp-token-info';
import {
  BTC_TESTNET_TYPE,
  CKB_PRIVATE_KEY,
  ckbAddress,
  collector,
  initOfflineCkbCollector,
  isMainnet,
} from '../../env';

const prepareLaunchCell = async ({
  outIndex,
  btcTxId,
  rgbppTokenInfo,
}: {
  outIndex: number;
  btcTxId: string;
  rgbppTokenInfo: RgbppTokenInfo;
}) => {
  const masterLock = addressToScript(ckbAddress);
  console.log('ckb address: ', ckbAddress);

  // The capacity required to launch cells is determined by the token info cell capacity, and transaction fee.
  const launchCellCapacity =
    calculateRgbppCellCapacity() + calculateRgbppTokenInfoCellCapacity(rgbppTokenInfo, isMainnet);

  const { collector: offlineCollector, cells: emptyCells } = await initOfflineCkbCollector([{ lock: masterLock }]);

  const txFee = MAX_FEE;
  const { inputs, sumInputsCapacity } = offlineCollector.collectInputs(emptyCells, launchCellCapacity, txFee);

  const outputs: CKBComponents.CellOutput[] = [
    {
      lock: genRgbppLockScript(buildRgbppLockArgs(outIndex, btcTxId), isMainnet, BTC_TESTNET_TYPE),
      capacity: append0x(launchCellCapacity.toString(16)),
    },
  ];
  let changeCapacity = sumInputsCapacity - launchCellCapacity;
  outputs.push({
    lock: masterLock,
    capacity: append0x(changeCapacity.toString(16)),
  });
  const outputsData = ['0x', '0x'];

  const emptyWitness = { lock: '', inputType: '', outputType: '' };
  const witnesses = inputs.map((_, index) => (index === 0 ? emptyWitness : '0x'));

  const cellDeps = [getSecp256k1CellDep(isMainnet)];

  const unsignedTx = {
    version: '0x0',
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses,
  };

  const txSize = getTransactionSize(unsignedTx) + SECP256K1_WITNESS_LOCK_SIZE;
  const estimatedTxFee = calculateTransactionFee(txSize);
  changeCapacity -= estimatedTxFee;
  unsignedTx.outputs[unsignedTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));

  const signedTx = signCkbTransaction(CKB_PRIVATE_KEY, unsignedTx);
  const txHash = await collector.getCkb().rpc.sendTransaction(signedTx, 'passthrough');

  console.info(`Launch cell has been created and the CKB tx hash ${txHash}`);
};

prepareLaunchCell({
  outIndex: 3,
  btcTxId: 'd6cbc8c4418cb1c4cab200c60e653ee886fd67d1c839197b1ac73a88a6360473',
  rgbppTokenInfo: RGBPP_TOKEN_INFO,
});

/* 
npx tsx examples/rgbpp/xudt/offline/1-prepare-launch.ts
*/


================================================
File: examples/rgbpp/xudt/offline/2-launch-rgbpp.ts
================================================
import { genRgbppLaunchCkbVirtualTx, sendRgbppUtxos, BtcAssetsApiError } from 'rgbpp';
import {
  buildRgbppLockArgs,
  RgbppTokenInfo,
  appendCkbTxWitnesses,
  updateCkbTxWithRealBtcTxId,
  sendCkbTx,
  genRgbppLockScript,
} from 'rgbpp/ckb';
import { RGBPP_TOKEN_INFO } from './0-rgbpp-token-info';
import {
  BTC_TESTNET_TYPE,
  btcAccount,
  btcService,
  collector,
  initOfflineBtcDataSource,
  initOfflineCkbCollector,
  isMainnet,
  vendorCellDeps,
} from '../../env';
import { saveCkbVirtualTxResult } from '../../shared/utils';
import { signAndSendPsbt } from '../../shared/btc-account';

interface Params {
  ownerRgbppLockArgs: string;
  launchAmount: bigint;
  rgbppTokenInfo: RgbppTokenInfo;
}

const launchRgppAsset = async ({ ownerRgbppLockArgs, launchAmount, rgbppTokenInfo }: Params) => {
  const { collector: offlineCollector } = await initOfflineCkbCollector([
    { lock: genRgbppLockScript(ownerRgbppLockArgs, isMainnet, BTC_TESTNET_TYPE) },
  ]);

  const ckbVirtualTxResult = await genRgbppLaunchCkbVirtualTx({
    collector: offlineCollector,
    ownerRgbppLockArgs,
    rgbppTokenInfo,
    launchAmount,
    isMainnet,
    btcTestnetType: BTC_TESTNET_TYPE,
    vendorCellDeps,
  });

  // Save ckbVirtualTxResult
  saveCkbVirtualTxResult(ckbVirtualTxResult, '2-launch-rgbpp-offline');

  const { commitment, ckbRawTx } = ckbVirtualTxResult;

  console.log('RGB++ Asset type script args: ', ckbRawTx.outputs[0].type?.args);

  const btcOfflineDataSource = await initOfflineBtcDataSource([ownerRgbppLockArgs], btcAccount.from);

  // Send BTC tx
  const psbt = await sendRgbppUtxos({
    ckbVirtualTx: ckbRawTx,
    commitment,
    tos: [btcAccount.from],
    needPaymaster: false,
    ckbCollector: offlineCollector,
    from: btcAccount.from,
    fromPubkey: btcAccount.fromPubkey,
    source: btcOfflineDataSource,
    feeRate: 256,
  });

  const { txId: btcTxId, rawTxHex: btcTxBytes } = await signAndSendPsbt(psbt, btcAccount, btcService);
  console.log(`BTC ${BTC_TESTNET_TYPE} TxId: ${btcTxId}`);

  const interval = setInterval(async () => {
    try {
      console.log('Waiting for BTC tx and proof to be ready');
      const rgbppApiSpvProof = await btcService.getRgbppSpvProof(btcTxId, 0);
      clearInterval(interval);
      // Update CKB transaction with the real BTC txId
      const newCkbRawTx = updateCkbTxWithRealBtcTxId({ ckbRawTx, btcTxId, isMainnet });
      const ckbTx = await appendCkbTxWitnesses({
        ckbRawTx: newCkbRawTx,
        btcTxBytes,
        rgbppApiSpvProof,
      });

      const txHash = await sendCkbTx({ collector, signedTx: ckbTx });
      console.info(`RGB++ Asset has been launched and CKB tx hash is ${txHash}`);
    } catch (error) {
      if (!(error instanceof BtcAssetsApiError)) {
        console.error(error);
      }
    }
  }, 30 * 1000);
};

// Please use your real BTC UTXO information on the BTC Testnet which should be same as the 1-prepare-launch.ts
// BTC Testnet3: https://mempool.space/testnet
// BTC Signet: https://mempool.space/signet

// rgbppLockArgs: outIndexU32 + btcTxId
launchRgppAsset({
  ownerRgbppLockArgs: buildRgbppLockArgs(3, 'd6cbc8c4418cb1c4cab200c60e653ee886fd67d1c839197b1ac73a88a6360473'),
  rgbppTokenInfo: RGBPP_TOKEN_INFO,
  // The total issuance amount of RGBPP Token, the decimal is determined by RGBPP Token info
  launchAmount: BigInt(2100_0000) * BigInt(10 ** RGBPP_TOKEN_INFO.decimal),
});

/* 
npx tsx examples/rgbpp/xudt/offline/2-launch-rgbpp.ts
*/


================================================
File: examples/rgbpp/xudt/offline/3-distribute-rgbpp.ts
================================================
import { addressToScript, serializeScript } from '@nervosnetwork/ckb-sdk-utils';
import { BtcAssetsApiError, genBtcBatchTransferCkbVirtualTx, sendRgbppUtxos } from 'rgbpp';
import { RGBPP_TOKEN_INFO } from './0-rgbpp-token-info';
import {
  isMainnet,
  collector,
  btcService,
  CKB_PRIVATE_KEY,
  ckbAddress,
  btcAccount,
  BTC_TESTNET_TYPE,
  initOfflineCkbCollector,
  initOfflineBtcDataSource,
  vendorCellDeps,
} from '../../env';
import {
  RgbppBtcAddressReceiver,
  appendCkbTxWitnesses,
  buildRgbppLockArgs,
  getXudtTypeScript,
  sendCkbTx,
  updateCkbTxWithRealBtcTxId,
  genRgbppLockScript,
  appendIssuerCellToBtcBatchTransferToSign,
  addressToScriptHash,
  signCkbTransaction,
} from 'rgbpp/ckb';
import { saveCkbVirtualTxResult } from '../../shared/utils';
import { signAndSendPsbt } from '../../shared/btc-account';

interface Params {
  rgbppLockArgsList: string[];
  receivers: RgbppBtcAddressReceiver[];
  xudtTypeArgs: string;
}

// Warning: Before runing this file for the first time, please run 2-launch-rgbpp.ts
const distributeRgbppAssetOnBtc = async ({ rgbppLockArgsList, receivers, xudtTypeArgs }: Params) => {
  // Warning: Please replace with your real xUDT type script here
  const xudtType: CKBComponents.Script = {
    ...getXudtTypeScript(isMainnet),
    // The xUDT type script args is generated by 2-launch-rgbpp.ts, and it can be found from the log
    args: xudtTypeArgs,
  };

  const rgbppLocks = rgbppLockArgsList.map((args) => genRgbppLockScript(args, isMainnet, BTC_TESTNET_TYPE));
  const { collector: offlineCollector } = await initOfflineCkbCollector([
    ...rgbppLocks.map((lock) => ({ lock, type: xudtType })),
    { lock: addressToScript(ckbAddress) },
  ]);

  const ckbVirtualTxResult = await genBtcBatchTransferCkbVirtualTx({
    collector: offlineCollector,
    rgbppLockArgsList,
    xudtTypeBytes: serializeScript(xudtType),
    rgbppReceivers: receivers,
    isMainnet,
    btcTestnetType: BTC_TESTNET_TYPE,
    vendorCellDeps,
  });

  // Save ckbVirtualTxResult
  saveCkbVirtualTxResult(ckbVirtualTxResult, '3-distribute-rgbpp-offline');

  const { commitment, ckbRawTx, sumInputsCapacity, rgbppChangeOutIndex } = ckbVirtualTxResult;

  // The first output utxo is OP_RETURN
  // Rgbpp change utxo position depends on the number of distributions, if 50 addresses are distributed, then the change utxo position is 51
  console.log('RGB++ asset change utxo out index: ', rgbppChangeOutIndex);

  const btcOfflineDataSource = await initOfflineBtcDataSource(rgbppLockArgsList, btcAccount.from);

  // Send BTC tx
  const psbt = await sendRgbppUtxos({
    ckbVirtualTx: ckbRawTx,
    commitment,
    tos: receivers.map((receiver) => receiver.toBtcAddress),
    needPaymaster: false,
    ckbCollector: offlineCollector,
    from: btcAccount.from,
    fromPubkey: btcAccount.fromPubkey,
    source: btcOfflineDataSource,
    feeRate: 256,
  });

  const { txId: btcTxId, rawTxHex: btcTxBytes } = await signAndSendPsbt(psbt, btcAccount, btcService);
  console.log(`BTC ${BTC_TESTNET_TYPE} TxId: ${btcTxId}`);

  const interval = setInterval(async () => {
    try {
      console.log('Waiting for BTC tx and proof to be ready');
      const rgbppApiSpvProof = await btcService.getRgbppSpvProof(btcTxId, 0);
      clearInterval(interval);
      // Update CKB transaction with the real BTC txId
      const newCkbRawTx = updateCkbTxWithRealBtcTxId({ ckbRawTx, btcTxId, isMainnet });
      const ckbTx = await appendCkbTxWitnesses({
        ckbRawTx: newCkbRawTx,
        btcTxBytes,
        rgbppApiSpvProof,
      });

      const { ckbRawTx: unsignedTx, inputCells } = await appendIssuerCellToBtcBatchTransferToSign({
        issuerAddress: ckbAddress,
        ckbRawTx: ckbTx,
        collector: offlineCollector,
        sumInputsCapacity,
        isMainnet,
      });

      const keyMap = new Map<string, string>();
      keyMap.set(addressToScriptHash(ckbAddress), CKB_PRIVATE_KEY);
      const signedTx = signCkbTransaction(keyMap, unsignedTx, inputCells, true);

      const txHash = await sendCkbTx({ collector, signedTx });
      console.info(`RGB++ Asset has been distributed and CKB tx hash is ${txHash}`);
    } catch (error) {
      if (!(error instanceof BtcAssetsApiError)) {
        console.error(error);
      }
    }
  }, 20 * 1000);
};

// Please use your real BTC UTXO information on the BTC Testnet
// BTC Testnet3: https://mempool.space/testnet
// BTC Signet: https://mempool.space/signet

// rgbppLockArgs: outIndexU32 + btcTxId
distributeRgbppAssetOnBtc({
  // Warning: If rgbpp assets are distributed continuously, then the position of the current rgbpp asset utxo depends on the position of the previous change utxo distributed
  rgbppLockArgsList: [buildRgbppLockArgs(1, '65e0574dfdbed4809736f3ec5a73aa191f147873d083ddb9978aecb969dd1900')],
  // The xudtTypeArgs comes from the logs "RGB++ Asset type script args" of 2-launch-rgbpp.ts
  xudtTypeArgs: '0xe402314a4b31223afe00a9c69c0b872863b990219525e1547ec05d9d88434b24',
  receivers: [
    {
      toBtcAddress: 'tb1qeq27se73d0e6zkh53e3xrj90vqzv8g7ja3nm85',
      transferAmount: BigInt(1000) * BigInt(10 ** RGBPP_TOKEN_INFO.decimal),
    },
    {
      toBtcAddress: 'tb1q4vkt8486w7syqyvz3a4la0f3re5vvj9zw4henw',
      transferAmount: BigInt(2000) * BigInt(10 ** RGBPP_TOKEN_INFO.decimal),
    },
    {
      toBtcAddress: 'tb1qp742mjfxzttnvs0cdttfrvmqqtkgljm5d4e86n',
      transferAmount: BigInt(3000) * BigInt(10 ** RGBPP_TOKEN_INFO.decimal),
    },
    {
      toBtcAddress: 'tb1qyyhdxmhc059rksfh9jjlkqgvs4w6mdl0z3zqj3',
      transferAmount: BigInt(4000) * BigInt(10 ** RGBPP_TOKEN_INFO.decimal),
    },
  ],
});

/* 
npx tsx examples/rgbpp/xudt/offline/3-distribute-rgbpp.ts
*/


================================================
File: examples/rgbpp/xudt/offline/4-btc-leap-ckb.ts
================================================
import {
  buildRgbppLockArgs,
  getXudtTypeScript,
  genRgbppLockScript,
  appendIssuerCellToBtcBatchTransferToSign,
  signCkbTransaction,
  addressToScriptHash,
  appendCkbTxWitnesses,
  updateCkbTxWithRealBtcTxId,
  sendCkbTx,
} from 'rgbpp/ckb';
import { addressToScript, serializeScript } from '@nervosnetwork/ckb-sdk-utils';
import { genBtcJumpCkbVirtualTx, sendRgbppUtxos, BtcAssetsApiError } from 'rgbpp';
import {
  isMainnet,
  collector,
  btcService,
  btcAccount,
  BTC_TESTNET_TYPE,
  CKB_PRIVATE_KEY,
  ckbAddress,
  initOfflineCkbCollector,
  vendorCellDeps,
  initOfflineBtcDataSource,
} from '../../env';
import { saveCkbVirtualTxResult } from '../../shared/utils';
import { signAndSendPsbt } from '../../shared/btc-account';

interface LeapToCkbParams {
  rgbppLockArgsList: string[];
  toCkbAddress: string;
  xudtTypeArgs: string;
  transferAmount: bigint;
}

const leapFromBtcToCKB = async ({ rgbppLockArgsList, toCkbAddress, xudtTypeArgs, transferAmount }: LeapToCkbParams) => {
  const xudtType: CKBComponents.Script = {
    ...getXudtTypeScript(isMainnet),
    args: xudtTypeArgs,
  };

  const rgbppLocks = rgbppLockArgsList.map((args) => genRgbppLockScript(args, isMainnet, BTC_TESTNET_TYPE));
  const { collector: offlineCollector } = await initOfflineCkbCollector([
    ...rgbppLocks.map((lock) => ({ lock, type: xudtType })),
    { lock: addressToScript(ckbAddress) },
  ]);

  const ckbVirtualTxResult = await genBtcJumpCkbVirtualTx({
    collector: offlineCollector,
    rgbppLockArgsList,
    xudtTypeBytes: serializeScript(xudtType),
    transferAmount,
    toCkbAddress,
    isMainnet,
    btcTestnetType: BTC_TESTNET_TYPE,
    vendorCellDeps,
  });

  // Save ckbVirtualTxResult
  saveCkbVirtualTxResult(ckbVirtualTxResult, '4-btc-leap-ckb-offline');

  const { commitment, ckbRawTx, sumInputsCapacity } = ckbVirtualTxResult;

  const btcOfflineDataSource = await initOfflineBtcDataSource(rgbppLockArgsList, btcAccount.from);

  // Send BTC tx
  const psbt = await sendRgbppUtxos({
    ckbVirtualTx: ckbRawTx,
    commitment,
    tos: [btcAccount.from],
    ckbCollector: offlineCollector,
    from: btcAccount.from,
    fromPubkey: btcAccount.fromPubkey,
    source: btcOfflineDataSource,
    needPaymaster: false,
    feeRate: 256,
  });

  const { txId: btcTxId, rawTxHex: btcTxBytes } = await signAndSendPsbt(psbt, btcAccount, btcService);
  console.log(`BTC ${BTC_TESTNET_TYPE} TxId: ${btcTxId}`);

  const interval = setInterval(async () => {
    try {
      console.log('Waiting for BTC tx and proof to be ready');
      const rgbppApiSpvProof = await btcService.getRgbppSpvProof(btcTxId, 0);
      clearInterval(interval);
      // Update CKB transaction with the real BTC txId
      const newCkbRawTx = updateCkbTxWithRealBtcTxId({ ckbRawTx, btcTxId, isMainnet });
      const ckbTx = await appendCkbTxWitnesses({
        ckbRawTx: newCkbRawTx,
        btcTxBytes,
        rgbppApiSpvProof,
      });

      const { ckbRawTx: unsignedTx, inputCells } = await appendIssuerCellToBtcBatchTransferToSign({
        issuerAddress: ckbAddress,
        ckbRawTx: ckbTx,
        collector: offlineCollector,
        sumInputsCapacity,
        isMainnet,
      });

      const keyMap = new Map<string, string>();
      keyMap.set(addressToScriptHash(ckbAddress), CKB_PRIVATE_KEY);
      const signedTx = signCkbTransaction(keyMap, unsignedTx, inputCells, true);

      const txHash = await sendCkbTx({ collector, signedTx });
      console.info(`Rgbpp asset has been jumped from BTC to CKB and the related CKB tx hash is ${txHash}`);
    } catch (error) {
      if (!(error instanceof BtcAssetsApiError)) {
        console.error(error);
      }
    }
  }, 20 * 1000);
};

// Please use your real BTC UTXO information on the BTC Testnet
// BTC Testnet3: https://mempool.space/testnet
// BTC Signet: https://mempool.space/signet

// rgbppLockArgs: outIndexU32 + btcTxId
leapFromBtcToCKB({
  rgbppLockArgsList: [buildRgbppLockArgs(1, 'dfb3be075b831ce7605ab3f56b7dda39ba7438e015ded3332db1f54cfac161de')],
  toCkbAddress: 'ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsqfpu7pwavwf3yang8khrsklumayj6nyxhqpmh7fq',
  // Please use your own RGB++ xudt asset's xudtTypeArgs
  xudtTypeArgs: '0xe402314a4b31223afe00a9c69c0b872863b990219525e1547ec05d9d88434b24',
  transferAmount: BigInt(100_0000_0000),
});

/* 
npx tsx examples/rgbpp/xudt/offline/4-btc-leap-ckb.ts
*/


================================================
File: examples/rgbpp/xudt/offline/5-unlock-btc-time-cell.ts
================================================
import { buildBtcTimeCellsSpentTx } from 'rgbpp';
import {
  sendCkbTx,
  getBtcTimeLockScript,
  btcTxIdAndAfterFromBtcTimeLockArgs,
  prepareBtcTimeCellSpentUnsignedTx,
  addressToScriptHash,
  signCkbTransaction,
} from 'rgbpp/ckb';
import { BTC_TESTNET_TYPE, CKB_PRIVATE_KEY, btcService, ckbAddress, collector, isMainnet } from '../../env';
import { OfflineBtcAssetsDataSource, SpvProofEntry } from 'rgbpp/service';

const unlockBtcTimeCell = async ({ btcTimeCellArgs }: { btcTimeCellArgs: string }) => {
  const btcTimeCells = await collector.getCells({
    lock: {
      ...getBtcTimeLockScript(isMainnet, BTC_TESTNET_TYPE),
      args: btcTimeCellArgs,
    },
    isDataMustBeEmpty: false,
  });
  if (!btcTimeCells || btcTimeCells.length === 0) {
    throw new Error('No btc time cell found');
  }

  const spvProofs: SpvProofEntry[] = [];
  for (const btcTimeCell of btcTimeCells) {
    const { btcTxId, after } = btcTxIdAndAfterFromBtcTimeLockArgs(btcTimeCell.output.lock.args);
    spvProofs.push({
      txid: btcTxId,
      confirmations: after,
      proof: await btcService.getRgbppSpvProof(btcTxId, after),
    });
  }

  const offlineBtcAssetsDataSource = new OfflineBtcAssetsDataSource({
    txs: [],
    utxos: [],
    rgbppSpvProofs: spvProofs,
  });

  const ckbRawTx: CKBComponents.RawTransaction = await buildBtcTimeCellsSpentTx({
    btcTimeCells,
    btcAssetsApi: offlineBtcAssetsDataSource,
    isMainnet,
    btcTestnetType: BTC_TESTNET_TYPE,
  });

  const { ckbRawTx: unsignedTx, inputCells } = await prepareBtcTimeCellSpentUnsignedTx({
    collector,
    masterCkbAddress: ckbAddress,
    ckbRawTx,
    isMainnet,
  });

  const keyMap = new Map<string, string>();
  keyMap.set(addressToScriptHash(ckbAddress), CKB_PRIVATE_KEY);
  const signedTx = signCkbTransaction(keyMap, unsignedTx, inputCells, true);

  const txHash = await sendCkbTx({ collector, signedTx });
  console.info(`BTC time cell has been spent and CKB tx hash is ${txHash}`);
};

// The btcTimeCellArgs is from the outputs[0].lock.args(BTC Time lock args) of the 3-btc-leap-ckb.ts CKB transaction
unlockBtcTimeCell({
  btcTimeCellArgs:
    '0x7d00000010000000590000005d000000490000001000000030000000310000009bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8011400000021e782eeb1c9893b341ed71c2dfe6fa496a6435c06000000f2aa85670171e5727da232e041e194508b0beced672e731f638ff84abf8d5ff8',
});

/* 
npx tsx examples/rgbpp/xudt/offline/5-unlock-btc-time-cell.ts
*/


================================================
File: examples/rgbpp/xudt/offline/6-ckb-leap-btc.ts
================================================
import { addressToScript, serializeScript } from '@nervosnetwork/ckb-sdk-utils';
import { genCkbJumpBtcVirtualTx } from 'rgbpp';
import { getSecp256k1CellDep, buildRgbppLockArgs, getXudtTypeScript, signCkbTransaction } from 'rgbpp/ckb';
import {
  CKB_PRIVATE_KEY,
  isMainnet,
  collector,
  ckbAddress,
  BTC_TESTNET_TYPE,
  initOfflineCkbCollector,
  vendorCellDeps,
} from '../../env';

interface LeapToBtcParams {
  outIndex: number;
  btcTxId: string;
  xudtTypeArgs: string;
  transferAmount: bigint;
}

const leapFromCkbToBtc = async ({ outIndex, btcTxId, xudtTypeArgs, transferAmount }: LeapToBtcParams) => {
  const toRgbppLockArgs = buildRgbppLockArgs(outIndex, btcTxId);

  // Warning: Please replace with your real xUDT type script here
  const xudtType: CKBComponents.Script = {
    ...getXudtTypeScript(isMainnet),
    args: xudtTypeArgs,
  };

  const { collector: offlineCollector } = await initOfflineCkbCollector([
    { lock: addressToScript(ckbAddress), type: xudtType },
    { lock: addressToScript(ckbAddress) },
  ]);

  const ckbRawTx = await genCkbJumpBtcVirtualTx({
    collector: offlineCollector,
    fromCkbAddress: ckbAddress,
    toRgbppLockArgs,
    xudtTypeBytes: serializeScript(xudtType),
    transferAmount,
    btcTestnetType: BTC_TESTNET_TYPE,
    vendorCellDeps,
  });

  const emptyWitness = { lock: '', inputType: '', outputType: '' };
  const unsignedTx: CKBComponents.RawTransactionToSign = {
    ...ckbRawTx,
    cellDeps: [...ckbRawTx.cellDeps, getSecp256k1CellDep(isMainnet)],
    witnesses: [emptyWitness, ...ckbRawTx.witnesses.slice(1)],
  };

  const signedTx = signCkbTransaction(CKB_PRIVATE_KEY, unsignedTx);
  const txHash = await collector.getCkb().rpc.sendTransaction(signedTx, 'passthrough');
  console.info(`Rgbpp asset has been jumped from CKB to BTC and CKB tx hash is ${txHash}`);
};

// Please use your real BTC UTXO information on the BTC Testnet
// BTC Testnet3: https://mempool.space/testnet
// BTC Signet: https://mempool.space/signet
leapFromCkbToBtc({
  outIndex: 0,
  btcTxId: 'c1db31abe6bab345b5d5ab4a19c8f34c8cfe23efa4ec6bfa7b05c8e7b4f965b8',
  // Please use your own RGB++ xudt asset's xudtTypeArgs
  xudtTypeArgs: '0xe402314a4b31223afe00a9c69c0b872863b990219525e1547ec05d9d88434b24',
  transferAmount: BigInt(10_0000_0000),
});

/* 
npx tsx examples/rgbpp/xudt/offline/6-ckb-leap-btc.ts
*/


================================================
File: examples/rgbpp/xudt/offline/compatible-xudt/1-ckb-leap-btc.ts
================================================
import { addressToScript, serializeScript } from '@nervosnetwork/ckb-sdk-utils';
import { genCkbJumpBtcVirtualTx } from 'rgbpp';
import { getSecp256k1CellDep, buildRgbppLockArgs, signCkbTransaction } from 'rgbpp/ckb';
import {
  CKB_PRIVATE_KEY,
  isMainnet,
  collector,
  ckbAddress,
  BTC_TESTNET_TYPE,
  initOfflineCkbCollector,
  vendorCellDeps,
} from '../../../env';

interface LeapToBtcParams {
  outIndex: number;
  btcTxId: string;
  transferAmount: bigint;
  compatibleXudtTypeScript: CKBComponents.Script;
}

const leapRusdFromCkbToBtc = async ({
  outIndex,
  btcTxId,
  transferAmount,
  compatibleXudtTypeScript,
}: LeapToBtcParams) => {
  const toRgbppLockArgs = buildRgbppLockArgs(outIndex, btcTxId);

  const { collector: offlineCollector } = await initOfflineCkbCollector([
    { lock: addressToScript(ckbAddress), type: compatibleXudtTypeScript },
    { lock: addressToScript(ckbAddress) },
  ]);

  const ckbRawTx = await genCkbJumpBtcVirtualTx({
    collector: offlineCollector,
    fromCkbAddress: ckbAddress,
    toRgbppLockArgs,
    xudtTypeBytes: serializeScript(compatibleXudtTypeScript),
    transferAmount,
    btcTestnetType: BTC_TESTNET_TYPE,
    vendorCellDeps,
  });

  const emptyWitness = { lock: '', inputType: '', outputType: '' };
  const unsignedTx: CKBComponents.RawTransactionToSign = {
    ...ckbRawTx,
    cellDeps: [...ckbRawTx.cellDeps, getSecp256k1CellDep(isMainnet)],
    witnesses: [emptyWitness, ...ckbRawTx.witnesses.slice(1)],
  };

  const signedTx = signCkbTransaction(CKB_PRIVATE_KEY, unsignedTx);
  const txHash = await collector.getCkb().rpc.sendTransaction(signedTx, 'passthrough');
  console.info(`Rgbpp compatible xUDT asset has been leaped from CKB to BTC and CKB tx hash is ${txHash}`);
};

// Please use your real BTC UTXO information on the BTC Testnet
// BTC Testnet3: https://mempool.space/testnet
// BTC Signet: https://mempool.space/signet
leapRusdFromCkbToBtc({
  outIndex: 2,
  btcTxId: '4239d2f9fe566513b0604e4dfe10f3b85b6bebe25096cf426559a89c87c68d1a',
  compatibleXudtTypeScript: {
    codeHash: '0x1142755a044bf2ee358cba9f2da187ce928c91cd4dc8692ded0337efa677d21a',
    hashType: 'type',
    args: '0x878fcc6f1f08d48e87bb1c3b3d5083f23f8a39c5d5c764f253b55b998526439b',
  },
  transferAmount: BigInt(200_0000),
});

/* 
npx tsx examples/rgbpp/xudt/offline/compatible-xudt/1-ckb-leap-btc.ts
*/


================================================
File: examples/rgbpp/xudt/offline/compatible-xudt/2-btc-transfer.ts
================================================
import { addressToScript, serializeScript } from '@nervosnetwork/ckb-sdk-utils';
import { BtcAssetsApiError, genBtcTransferCkbVirtualTx, sendRgbppUtxos } from 'rgbpp';

import {
  isMainnet,
  collector,
  btcService,
  CKB_PRIVATE_KEY,
  ckbAddress,
  btcAccount,
  BTC_TESTNET_TYPE,
  initOfflineCkbCollector,
  initOfflineBtcDataSource,
  vendorCellDeps,
} from '../../../env';
import {
  appendCkbTxWitnesses,
  buildRgbppLockArgs,
  sendCkbTx,
  updateCkbTxWithRealBtcTxId,
  genRgbppLockScript,
  appendIssuerCellToBtcBatchTransferToSign,
  addressToScriptHash,
  signCkbTransaction,
} from 'rgbpp/ckb';
import { saveCkbVirtualTxResult } from '../../../shared/utils';
import { signAndSendPsbt } from '../../../shared/btc-account';

interface RgbppTransferParams {
  rgbppLockArgsList: string[];
  toBtcAddress: string;
  transferAmount: bigint;
  compatibleXudtTypeScript: CKBComponents.Script;
}

const transferRusdOnBtc = async ({
  rgbppLockArgsList,
  toBtcAddress,
  compatibleXudtTypeScript,
  transferAmount,
}: RgbppTransferParams) => {
  const rgbppLocks = rgbppLockArgsList.map((args) => genRgbppLockScript(args, isMainnet, BTC_TESTNET_TYPE));
  const { collector: offlineCollector } = await initOfflineCkbCollector([
    ...rgbppLocks.map((lock) => ({ lock, type: compatibleXudtTypeScript })),
    { lock: addressToScript(ckbAddress) },
  ]);

  const ckbVirtualTxResult = await genBtcTransferCkbVirtualTx({
    collector: offlineCollector,
    rgbppLockArgsList,
    xudtTypeBytes: serializeScript(compatibleXudtTypeScript),
    transferAmount,
    isMainnet,
    btcTestnetType: BTC_TESTNET_TYPE,
    vendorCellDeps,
  });

  // Save ckbVirtualTxResult
  saveCkbVirtualTxResult(ckbVirtualTxResult, '2-compatible-xudt-btc-transfer-offline');

  const { commitment, ckbRawTx, sumInputsCapacity } = ckbVirtualTxResult;

  const btcOfflineDataSource = await initOfflineBtcDataSource(rgbppLockArgsList, btcAccount.from);

  // Send BTC tx
  const psbt = await sendRgbppUtxos({
    ckbVirtualTx: ckbRawTx,
    commitment,
    tos: [toBtcAddress],
    needPaymaster: false,
    ckbCollector: offlineCollector,
    from: btcAccount.from,
    fromPubkey: btcAccount.fromPubkey,
    source: btcOfflineDataSource,
    feeRate: 128,
  });

  const { txId: btcTxId, rawTxHex: btcTxBytes } = await signAndSendPsbt(psbt, btcAccount, btcService);
  console.log(`BTC ${BTC_TESTNET_TYPE} TxId: ${btcTxId}`);
  console.log('BTC tx bytes: ', btcTxBytes);

  const interval = setInterval(async () => {
    try {
      console.log('Waiting for BTC tx and proof to be ready');
      const rgbppApiSpvProof = await btcService.getRgbppSpvProof(btcTxId, 0);
      clearInterval(interval);
      // Update CKB transaction with the real BTC txId
      const newCkbRawTx = updateCkbTxWithRealBtcTxId({ ckbRawTx, btcTxId, isMainnet });
      const ckbTx = await appendCkbTxWitnesses({
        ckbRawTx: newCkbRawTx,
        btcTxBytes,
        rgbppApiSpvProof,
      });

      const { ckbRawTx: unsignedTx, inputCells } = await appendIssuerCellToBtcBatchTransferToSign({
        issuerAddress: ckbAddress,
        ckbRawTx: ckbTx,
        collector: offlineCollector,
        sumInputsCapacity,
        isMainnet,
      });

      const keyMap = new Map<string, string>();
      keyMap.set(addressToScriptHash(ckbAddress), CKB_PRIVATE_KEY);
      const signedTx = signCkbTransaction(keyMap, unsignedTx, inputCells, true);

      const txHash = await sendCkbTx({ collector, signedTx });
      console.info(`Rgbpp compatible xUDT asset has been transferred on BTC and the related CKB tx hash is ${txHash}`);
    } catch (error) {
      if (!(error instanceof BtcAssetsApiError)) {
        console.error(error);
      }
    }
  }, 20 * 1000);
};

// Please use your real BTC UTXO information on the BTC Testnet
// BTC Testnet3: https://mempool.space/testnet
// BTC Signet: https://mempool.space/signet

// rgbppLockArgs: outIndexU32 + btcTxId
transferRusdOnBtc({
  rgbppLockArgsList: [buildRgbppLockArgs(2, '4239d2f9fe566513b0604e4dfe10f3b85b6bebe25096cf426559a89c87c68d1a')],
  toBtcAddress: 'tb1qe68sv5pr5vdj2daw2v96pwvw5m9ca4ew35ewp5',
  // Please use your own RGB++ compatible xudt asset's type script
  compatibleXudtTypeScript: {
    codeHash: '0x1142755a044bf2ee358cba9f2da187ce928c91cd4dc8692ded0337efa677d21a',
    hashType: 'type',
    args: '0x878fcc6f1f08d48e87bb1c3b3d5083f23f8a39c5d5c764f253b55b998526439b',
  },
  transferAmount: BigInt(100_0000),
});

/* 
npx tsx examples/rgbpp/xudt/offline/compatible-xudt/2-btc-transfer.ts
*/


================================================
File: examples/rgbpp/xudt/offline/compatible-xudt/3-btc-leap-ckb.ts
================================================
import {
  buildRgbppLockArgs,
  genRgbppLockScript,
  appendIssuerCellToBtcBatchTransferToSign,
  signCkbTransaction,
  addressToScriptHash,
  appendCkbTxWitnesses,
  updateCkbTxWithRealBtcTxId,
  sendCkbTx,
} from 'rgbpp/ckb';
import { addressToScript, serializeScript } from '@nervosnetwork/ckb-sdk-utils';
import { genBtcJumpCkbVirtualTx, sendRgbppUtxos, BtcAssetsApiError } from 'rgbpp';
import {
  isMainnet,
  collector,
  btcService,
  btcAccount,
  BTC_TESTNET_TYPE,
  CKB_PRIVATE_KEY,
  ckbAddress,
  initOfflineCkbCollector,
  vendorCellDeps,
  initOfflineBtcDataSource,
} from '../../../env';
import { saveCkbVirtualTxResult } from '../../../shared/utils';
import { signAndSendPsbt } from '../../../shared/btc-account';

interface LeapToCkbParams {
  rgbppLockArgsList: string[];
  toCkbAddress: string;
  transferAmount: bigint;
  compatibleXudtTypeScript: CKBComponents.Script;
}

const leapRusdFromBtcToCKB = async ({
  rgbppLockArgsList,
  toCkbAddress,
  compatibleXudtTypeScript,
  transferAmount,
}: LeapToCkbParams) => {
  const rgbppLocks = rgbppLockArgsList.map((args) => genRgbppLockScript(args, isMainnet, BTC_TESTNET_TYPE));
  const { collector: offlineCollector } = await initOfflineCkbCollector([
    ...rgbppLocks.map((lock) => ({ lock, type: compatibleXudtTypeScript })),
    { lock: addressToScript(ckbAddress) },
  ]);

  const ckbVirtualTxResult = await genBtcJumpCkbVirtualTx({
    collector: offlineCollector,
    rgbppLockArgsList,
    xudtTypeBytes: serializeScript(compatibleXudtTypeScript),
    transferAmount,
    toCkbAddress,
    isMainnet,
    btcTestnetType: BTC_TESTNET_TYPE,
    vendorCellDeps,
  });

  // Save ckbVirtualTxResult
  saveCkbVirtualTxResult(ckbVirtualTxResult, '3-compatible-xudt-btc-leap-ckb-offline');

  const { commitment, ckbRawTx, sumInputsCapacity } = ckbVirtualTxResult;

  const btcOfflineDataSource = await initOfflineBtcDataSource(rgbppLockArgsList, btcAccount.from);

  // Send BTC tx
  const psbt = await sendRgbppUtxos({
    ckbVirtualTx: ckbRawTx,
    commitment,
    tos: [btcAccount.from],
    ckbCollector: offlineCollector,
    from: btcAccount.from,
    fromPubkey: btcAccount.fromPubkey,
    source: btcOfflineDataSource,
    needPaymaster: false,
    feeRate: 128,
  });

  const { txId: btcTxId, rawTxHex: btcTxBytes } = await signAndSendPsbt(psbt, btcAccount, btcService);
  console.log(`BTC ${BTC_TESTNET_TYPE} TxId: ${btcTxId}`);
  console.log('BTC tx bytes: ', btcTxBytes);

  const interval = setInterval(async () => {
    try {
      console.log('Waiting for BTC tx and proof to be ready');
      const rgbppApiSpvProof = await btcService.getRgbppSpvProof(btcTxId, 0);
      clearInterval(interval);
      // Update CKB transaction with the real BTC txId
      const newCkbRawTx = updateCkbTxWithRealBtcTxId({ ckbRawTx, btcTxId, isMainnet });
      const ckbTx = await appendCkbTxWitnesses({
        ckbRawTx: newCkbRawTx,
        btcTxBytes,
        rgbppApiSpvProof,
      });

      const { ckbRawTx: unsignedTx, inputCells } = await appendIssuerCellToBtcBatchTransferToSign({
        issuerAddress: ckbAddress,
        ckbRawTx: ckbTx,
        collector: offlineCollector,
        sumInputsCapacity,
        isMainnet,
      });

      const keyMap = new Map<string, string>();
      keyMap.set(addressToScriptHash(ckbAddress), CKB_PRIVATE_KEY);
      const signedTx = signCkbTransaction(keyMap, unsignedTx, inputCells, true);

      const txHash = await sendCkbTx({ collector, signedTx });
      console.info(
        `Rgbpp compatible xUDT asset has been leaped from BTC to CKB and the related CKB tx hash is ${txHash}`,
      );
    } catch (error) {
      if (!(error instanceof BtcAssetsApiError)) {
        console.error(error);
      }
    }
  }, 20 * 1000);
};

// Please use your real BTC UTXO information on the BTC Testnet
// BTC Testnet3: https://mempool.space/testnet
// BTC Signet: https://mempool.space/signet

// rgbppLockArgs: outIndexU32 + btcTxId
leapRusdFromBtcToCKB({
  rgbppLockArgsList: [buildRgbppLockArgs(2, 'daec93a97c8b7f6fdd33696f814f0292be966dc4ea4853400d3cada816c70f5d')],
  toCkbAddress: 'ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsqfpu7pwavwf3yang8khrsklumayj6nyxhqpmh7fq',
  // Please use your own RGB++ compatible xudt asset's type script
  compatibleXudtTypeScript: {
    codeHash: '0x1142755a044bf2ee358cba9f2da187ce928c91cd4dc8692ded0337efa677d21a',
    hashType: 'type',
    args: '0x878fcc6f1f08d48e87bb1c3b3d5083f23f8a39c5d5c764f253b55b998526439b',
  },
  transferAmount: BigInt(10_0000),
});

/* 
npx tsx examples/rgbpp/xudt/offline/compatible-xudt/3-btc-leap-ckb.ts
*/


================================================
File: examples/rgbpp/xudt/offline/compatible-xudt/4-unlock-btc-time-cell.ts
================================================
import { BtcAssetsApiError, buildBtcTimeCellsSpentTx } from 'rgbpp';
import {
  sendCkbTx,
  getBtcTimeLockScript,
  btcTxIdAndAfterFromBtcTimeLockArgs,
  prepareBtcTimeCellSpentUnsignedTx,
  addressToScriptHash,
  signCkbTransaction,
} from 'rgbpp/ckb';
import { BTC_TESTNET_TYPE, CKB_PRIVATE_KEY, btcService, ckbAddress, collector, isMainnet } from '../../../env';
import { OfflineBtcAssetsDataSource, SpvProofEntry } from 'rgbpp/service';

const unlockRusdBtcTimeCell = async ({ btcTimeCellArgs }: { btcTimeCellArgs: string }) => {
  const btcTimeCells = await collector.getCells({
    lock: {
      ...getBtcTimeLockScript(isMainnet, BTC_TESTNET_TYPE),
      args: btcTimeCellArgs,
    },
    isDataMustBeEmpty: false,
  });
  if (!btcTimeCells || btcTimeCells.length === 0) {
    throw new Error('No btc time cell found');
  }

  const spvProofs: SpvProofEntry[] = await Promise.all(
    btcTimeCells.map(async (btcTimeCell) => {
      const { btcTxId, after } = btcTxIdAndAfterFromBtcTimeLockArgs(btcTimeCell.output.lock.args);
      let proof = null;
      let attempts = 0;

      // eslint-disable-next-line no-constant-condition
      while (true) {
        try {
          console.log(`Attempt ${attempts + 1}: Waiting for SPV proof for txId ${btcTxId}...`);
          proof = await btcService.getRgbppSpvProof(btcTxId, after);
          if (proof) {
            break;
          }
        } catch (error) {
          if (!(error instanceof BtcAssetsApiError)) {
            console.error(error);
            throw error;
          }
          console.log('BtcAssetsApiError', error.message);
        }
        await new Promise((resolve) => setTimeout(resolve, 10 * 1000));
        attempts++;
      }

      return {
        txid: btcTxId,
        confirmations: after,
        proof,
      };
    }),
  );

  const offlineBtcAssetsDataSource = new OfflineBtcAssetsDataSource({
    txs: [],
    utxos: [],
    rgbppSpvProofs: spvProofs,
  });

  const ckbRawTx: CKBComponents.RawTransaction = await buildBtcTimeCellsSpentTx({
    btcTimeCells,
    btcAssetsApi: offlineBtcAssetsDataSource,
    isMainnet,
    btcTestnetType: BTC_TESTNET_TYPE,
  });

  const { ckbRawTx: unsignedTx, inputCells } = await prepareBtcTimeCellSpentUnsignedTx({
    collector,
    masterCkbAddress: ckbAddress,
    ckbRawTx,
    isMainnet,
  });

  const keyMap = new Map<string, string>();
  keyMap.set(addressToScriptHash(ckbAddress), CKB_PRIVATE_KEY);
  const signedTx = signCkbTransaction(keyMap, unsignedTx, inputCells, true);

  const txHash = await sendCkbTx({ collector, signedTx });
  console.info(`BTC time cell has been spent and CKB tx hash is ${txHash}`);
};

// The btcTimeCellArgs is from the outputs[0].lock.args(BTC Time lock args) of the 3-btc-leap-ckb.ts CKB transaction
unlockRusdBtcTimeCell({
  btcTimeCellArgs:
    '0x7d00000010000000590000005d000000490000001000000030000000310000009bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8011400000021e782eeb1c9893b341ed71c2dfe6fa496a6435c0600000086c0f54823abebbd966c5110cbdbc72cc6f6b32b81b4254b9f49788a090bcfab',
});

/* 
npx tsx examples/rgbpp/xudt/offline/compatible-xudt/4-unlock-btc-time-cell.ts
*/


================================================
File: examples/xudt-on-ckb/README.md
================================================
# xUDT on CKB Examples

The examples for xUDT issuance, mint and transfer on CKB

## How to Start

Copy the `.env.example` file to `.env`:

```shell
cd examples/xudt && cp .env.example .env
```

Update the configuration values:

```yaml
# True for CKB Mainnet and false for CKB Testnet, the default value is false
IS_MAINNET=false

# The CKB secp256k1 private key whose format is 32bytes hex string with 0x prefix
CKB_SECP256K1_PRIVATE_KEY=0x-private-key

# CKB node url which should match IS_MAINNET
CKB_NODE_URL=https://testnet.ckb.dev/rpc

# CKB indexer url which should match IS_MAINNET
CKB_INDEXER_URL=https://testnet.ckb.dev/indexer

```

### Issue xUDT on CKB

```shell
npx tsx 1-issue-xudt.ts 
```

### Mint/Transfer xUDT on CKB

You can use this command to mint or transfer xUDT assets

```shell
npx tsx 2-transfer-xudt.ts 
```


================================================
File: examples/xudt-on-ckb/1-issue-xudt.ts
================================================
import { addressToScript, getTransactionSize, scriptToHash } from '@nervosnetwork/ckb-sdk-utils';
import {
  getSecp256k1CellDep,
  RgbppTokenInfo,
  NoLiveCellError,
  calculateUdtCellCapacity,
  MAX_FEE,
  MIN_CAPACITY,
  getXudtTypeScript,
  append0x,
  getUniqueTypeScript,
  u128ToLe,
  encodeRgbppTokenInfo,
  SECP256K1_WITNESS_LOCK_SIZE,
  calculateTransactionFee,
  generateUniqueTypeArgs,
  calculateXudtTokenInfoCellCapacity,
  fetchTypeIdCellDeps,
} from 'rgbpp/ckb';
import { CKB_PRIVATE_KEY, ckbAddress, collector, isMainnet } from './env';

/**
 * issueXudt can be used to issue xUDT assets with unique cell as token info cell.
 * @param xudtTotalAmount The xudtTotalAmount specifies the total amount of asset issuance
 * @param tokenInfo The xUDT token info which includes decimal, name and symbol
 */
const issueXudt = async ({ xudtTotalAmount, tokenInfo }: { xudtTotalAmount: bigint; tokenInfo: RgbppTokenInfo }) => {
  const issueLock = addressToScript(ckbAddress);

  let emptyCells = await collector.getCells({
    lock: issueLock,
  });
  if (!emptyCells || emptyCells.length === 0) {
    throw new NoLiveCellError('The address has no empty cells');
  }
  emptyCells = emptyCells.filter((cell) => !cell.output.type);

  const xudtCapacity = calculateUdtCellCapacity(issueLock);
  const xudtInfoCapacity = calculateXudtTokenInfoCellCapacity(tokenInfo, issueLock);

  const txFee = MAX_FEE;
  const { inputs, sumInputsCapacity } = collector.collectInputs(emptyCells, xudtCapacity + xudtInfoCapacity, txFee, {
    minCapacity: MIN_CAPACITY,
  });

  const xudtType: CKBComponents.Script = {
    ...getXudtTypeScript(isMainnet),
    args: append0x(scriptToHash(issueLock)),
  };

  console.log('xUDT type script', xudtType);

  let changeCapacity = sumInputsCapacity - xudtCapacity - xudtInfoCapacity;
  const outputs: CKBComponents.CellOutput[] = [
    {
      lock: issueLock,
      type: xudtType,
      capacity: append0x(xudtCapacity.toString(16)),
    },
    {
      lock: issueLock,
      type: {
        ...getUniqueTypeScript(isMainnet),
        args: generateUniqueTypeArgs(inputs[0], 1),
      },
      capacity: append0x(xudtInfoCapacity.toString(16)),
    },
    {
      lock: issueLock,
      capacity: append0x(changeCapacity.toString(16)),
    },
  ];
  const totalAmount = xudtTotalAmount * BigInt(10 ** tokenInfo.decimal);
  const outputsData = [append0x(u128ToLe(totalAmount)), encodeRgbppTokenInfo(tokenInfo), '0x'];

  const emptyWitness = { lock: '', inputType: '', outputType: '' };
  const witnesses = inputs.map((_, index) => (index === 0 ? emptyWitness : '0x'));

  const cellDeps = [
    getSecp256k1CellDep(isMainnet),
    ...(await fetchTypeIdCellDeps(isMainnet, { xudt: true, unique: true })),
  ];

  const unsignedTx = {
    version: '0x0',
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses,
  };

  if (txFee === MAX_FEE) {
    const txSize = getTransactionSize(unsignedTx) + SECP256K1_WITNESS_LOCK_SIZE;
    const estimatedTxFee = calculateTransactionFee(txSize);
    changeCapacity -= estimatedTxFee;
    unsignedTx.outputs[unsignedTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));
  }

  const signedTx = collector.getCkb().signTransaction(CKB_PRIVATE_KEY)(unsignedTx);
  const txHash = await collector.getCkb().rpc.sendTransaction(signedTx, 'passthrough');

  console.info(`xUDT asset on CKB has been issued and tx hash is ${txHash}`);
};

const XUDT_TOKEN_INFO: RgbppTokenInfo = {
  decimal: 8,
  name: 'XUDT Test Token',
  symbol: 'XTT',
};

issueXudt({ xudtTotalAmount: BigInt(2100_0000), tokenInfo: XUDT_TOKEN_INFO });


================================================
File: examples/xudt-on-ckb/2-transfer-xudt.ts
================================================
import { addressToScript, getTransactionSize } from '@nervosnetwork/ckb-sdk-utils';
import {
  getSecp256k1CellDep,
  RgbppTokenInfo,
  NoLiveCellError,
  calculateUdtCellCapacity,
  MAX_FEE,
  MIN_CAPACITY,
  append0x,
  u128ToLe,
  SECP256K1_WITNESS_LOCK_SIZE,
  calculateTransactionFee,
  NoXudtLiveCellError,
  fetchTypeIdCellDeps,
  getXudtTypeScript,
} from 'rgbpp/ckb';
import { CKB_PRIVATE_KEY, ckbAddress, collector, isMainnet } from './env';

interface XudtTransferParams {
  xudtType: CKBComponents.Script;
  receivers: {
    toAddress: string;
    transferAmount: bigint;
  }[];
}

/**
 * transferXudt can be used to mint xUDT assets or transfer xUDT assets.
 * @param xudtType The xUDT type script that comes from 1-issue-xudt
 * @param receivers The receiver includes toAddress and transferAmount
 */
const transferXudt = async ({ xudtType, receivers }: XudtTransferParams) => {
  const fromLock = addressToScript(ckbAddress);

  const xudtCells = await collector.getCells({
    lock: fromLock,
    type: xudtType,
  });
  if (!xudtCells || xudtCells.length === 0) {
    throw new NoXudtLiveCellError('The address has no xudt cells');
  }
  const sumTransferAmount = receivers
    .map((receiver) => receiver.transferAmount)
    .reduce((prev, current) => prev + current, BigInt(0));

  let sumXudtOutputCapacity = receivers
    .map(({ toAddress }) => calculateUdtCellCapacity(addressToScript(toAddress)))
    .reduce((prev, current) => prev + current, BigInt(0));

  const {
    inputs: udtInputs,
    sumInputsCapacity: sumXudtInputsCapacity,
    sumAmount,
  } = collector.collectUdtInputs({
    liveCells: xudtCells,
    needAmount: sumTransferAmount,
  });
  let actualInputsCapacity = sumXudtInputsCapacity;
  let inputs = udtInputs;

  const outputs: CKBComponents.CellOutput[] = receivers.map(({ toAddress }) => ({
    lock: addressToScript(toAddress),
    type: xudtType,
    capacity: append0x(calculateUdtCellCapacity(addressToScript(toAddress)).toString(16)),
  }));
  const outputsData = receivers.map(({ transferAmount }) => append0x(u128ToLe(transferAmount)));

  if (sumAmount > sumTransferAmount) {
    const xudtChangeCapacity = calculateUdtCellCapacity(fromLock);
    outputs.push({
      lock: fromLock,
      type: xudtType,
      capacity: append0x(xudtChangeCapacity.toString(16)),
    });
    outputsData.push(append0x(u128ToLe(sumAmount - sumTransferAmount)));
    sumXudtOutputCapacity += xudtChangeCapacity;
  }

  const txFee = MAX_FEE;
  if (sumXudtInputsCapacity <= sumXudtOutputCapacity) {
    let emptyCells = await collector.getCells({
      lock: fromLock,
    });
    if (!emptyCells || emptyCells.length === 0) {
      throw new NoLiveCellError('The address has no empty cells');
    }
    emptyCells = emptyCells.filter((cell) => !cell.output.type);
    const needCapacity = sumXudtOutputCapacity - sumXudtInputsCapacity;
    const { inputs: emptyInputs, sumInputsCapacity: sumEmptyCapacity } = collector.collectInputs(
      emptyCells,
      needCapacity,
      txFee,
      { minCapacity: MIN_CAPACITY },
    );
    inputs = [...inputs, ...emptyInputs];
    actualInputsCapacity += sumEmptyCapacity;
  }

  let changeCapacity = actualInputsCapacity - sumXudtOutputCapacity;
  outputs.push({
    lock: fromLock,
    capacity: append0x(changeCapacity.toString(16)),
  });
  outputsData.push('0x');

  const emptyWitness = { lock: '', inputType: '', outputType: '' };
  const witnesses = inputs.map((_, index) => (index === 0 ? emptyWitness : '0x'));

  const cellDeps = [getSecp256k1CellDep(isMainnet), ...(await fetchTypeIdCellDeps(isMainnet, { xudt: true }))];

  const unsignedTx = {
    version: '0x0',
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses,
  };

  if (txFee === MAX_FEE) {
    const txSize = getTransactionSize(unsignedTx) + SECP256K1_WITNESS_LOCK_SIZE;
    const estimatedTxFee = calculateTransactionFee(txSize);
    changeCapacity -= estimatedTxFee;
    unsignedTx.outputs[unsignedTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));
  }

  const signedTx = collector.getCkb().signTransaction(CKB_PRIVATE_KEY)(unsignedTx);
  const txHash = await collector.getCkb().rpc.sendTransaction(signedTx, 'passthrough');

  console.info(`xUDT asset has been minted or transferred and tx hash is ${txHash}`);
};

const XUDT_TOKEN_INFO: RgbppTokenInfo = {
  decimal: 8,
  name: 'XUDT Test Token',
  symbol: 'XTT',
};

transferXudt({
  // The xudtType comes from 1-issue-xudt
  xudtType: {
    ...getXudtTypeScript(isMainnet),
    args: '0x562e4e8a2f64a3e9c24beb4b7dd002d0ad3b842d0cc77924328e36ad114e3ebe',
  },
  receivers: [
    {
      toAddress: 'ckt1qrfrwcdnvssswdwpn3s9v8fp87emat306ctjwsm3nmlkjg8qyza2cqgqq92pncevj8c3nwz7f3mlx2fwqn6l44y73yr5swl5',
      transferAmount: BigInt(1000) * BigInt(10 ** XUDT_TOKEN_INFO.decimal),
    },
    {
      toAddress: 'ckt1qyqpyw8j7tlu3v44am8d54066zrzk4vz5lvqat8fpf',
      transferAmount: BigInt(2000) * BigInt(10 ** XUDT_TOKEN_INFO.decimal),
    },
  ],
});


================================================
File: examples/xudt-on-ckb/3-generate-btc-time-cell.ts
================================================
import { addressToScript, getTransactionSize } from '@nervosnetwork/ckb-sdk-utils';
import {
  getSecp256k1CellDep,
  NoLiveCellError,
  calculateUdtCellCapacity,
  MAX_FEE,
  MIN_CAPACITY,
  append0x,
  u128ToLe,
  SECP256K1_WITNESS_LOCK_SIZE,
  calculateTransactionFee,
  NoXudtLiveCellError,
  fetchTypeIdCellDeps,
  calculateRgbppCellCapacity,
  getBtcTimeLockScript,
  genBtcTimeLockArgs,
  getXudtTypeScript,
} from 'rgbpp/ckb';
import { CKB_PRIVATE_KEY, ckbAddress, collector, isMainnet } from './env';

interface BtcTimeCellParams {
  xudtType: CKBComponents.Script;
  toCkbAddress: string;
  xudtAmount: bigint;
  btcTxId: string;
  after: number;
}

/**
 * Generate btc time cell with custom btc txid, after and target lock script
 * @param xudtType The xUDT type script that comes from 1-issue-xudt or 2-transfer-xudt
 * BTC time lock args:
 * table BTCTimeLock {
    to_lock_script: Script,
    after: Uint32,
    btc_txid: Byte32,
  }
 */
const generateBtcTimeCell = async ({ xudtType, toCkbAddress, xudtAmount, btcTxId, after }: BtcTimeCellParams) => {
  const fromLock = addressToScript(ckbAddress);

  const xudtCells = await collector.getCells({
    lock: fromLock,
    type: xudtType,
  });
  if (!xudtCells || xudtCells.length === 0) {
    throw new NoXudtLiveCellError('The address has no xudt cells');
  }

  const btcTimeOutputCapacity = calculateRgbppCellCapacity(xudtType);
  let sumXudtOutputCapacity = btcTimeOutputCapacity;

  const {
    inputs: udtInputs,
    sumInputsCapacity: sumXudtInputsCapacity,
    sumAmount,
  } = collector.collectUdtInputs({
    liveCells: xudtCells,
    needAmount: xudtAmount,
  });
  let actualInputsCapacity = sumXudtInputsCapacity;
  let inputs = udtInputs;

  const outputs: CKBComponents.CellOutput[] = [
    {
      lock: {
        ...getBtcTimeLockScript(isMainnet),
        args: genBtcTimeLockArgs(addressToScript(toCkbAddress), btcTxId, after),
      },
      type: xudtType,
      capacity: append0x(btcTimeOutputCapacity.toString(16)),
    },
  ];
  const outputsData = [append0x(u128ToLe(xudtAmount))];

  if (sumAmount > xudtAmount) {
    const xudtChangeCapacity = calculateUdtCellCapacity(fromLock);
    outputs.push({
      lock: fromLock,
      type: xudtType,
      capacity: append0x(xudtChangeCapacity.toString(16)),
    });
    outputsData.push(append0x(u128ToLe(sumAmount - xudtAmount)));
    sumXudtOutputCapacity += xudtChangeCapacity;
  }

  const txFee = MAX_FEE;
  if (sumXudtInputsCapacity <= sumXudtOutputCapacity) {
    let emptyCells = await collector.getCells({
      lock: fromLock,
    });
    if (!emptyCells || emptyCells.length === 0) {
      throw new NoLiveCellError('The address has no empty cells');
    }
    emptyCells = emptyCells.filter((cell) => !cell.output.type);
    const needCapacity = sumXudtOutputCapacity - sumXudtInputsCapacity;
    const { inputs: emptyInputs, sumInputsCapacity: sumEmptyCapacity } = collector.collectInputs(
      emptyCells,
      needCapacity,
      txFee,
      { minCapacity: MIN_CAPACITY },
    );
    inputs = [...inputs, ...emptyInputs];
    actualInputsCapacity += sumEmptyCapacity;
  }

  let changeCapacity = actualInputsCapacity - sumXudtOutputCapacity;
  outputs.push({
    lock: fromLock,
    capacity: append0x(changeCapacity.toString(16)),
  });
  outputsData.push('0x');

  const emptyWitness = { lock: '', inputType: '', outputType: '' };
  const witnesses = inputs.map((_, index) => (index === 0 ? emptyWitness : '0x'));

  const cellDeps = [getSecp256k1CellDep(isMainnet), ...(await fetchTypeIdCellDeps(isMainnet, { xudt: true }))];

  const unsignedTx = {
    version: '0x0',
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses,
  };

  if (txFee === MAX_FEE) {
    const txSize = getTransactionSize(unsignedTx) + SECP256K1_WITNESS_LOCK_SIZE;
    const estimatedTxFee = calculateTransactionFee(txSize);
    changeCapacity -= estimatedTxFee;
    unsignedTx.outputs[unsignedTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));
  }

  const signedTx = collector.getCkb().signTransaction(CKB_PRIVATE_KEY)(unsignedTx);
  const txHash = await collector.getCkb().rpc.sendTransaction(signedTx, 'passthrough');

  console.info(`xUDT asset has been transferred to BTC time lock and CKB tx hash is ${txHash}`);
};

generateBtcTimeCell({
  xudtType: {
    ...getXudtTypeScript(isMainnet),
    args: '0x562e4e8a2f64a3e9c24beb4b7dd002d0ad3b842d0cc77924328e36ad114e3ebe',
  },
  toCkbAddress: 'ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsq0e4xk4rmg5jdkn8aams492a7jlg73ue0gc0ddfj',
  xudtAmount: BigInt(1000) * BigInt(10 ** 8),
  btcTxId: '5fe08344a7e7e8be96b17a41ec9f308a5cb472cfb2a3234af86df8233d4dc3ff',
  after: 69000,
});


================================================
File: examples/xudt-on-ckb/env.ts
================================================
import {
  blake160,
  bytesToHex,
  privateKeyToPublicKey,
  scriptToAddress,
  systemScripts,
} from '@nervosnetwork/ckb-sdk-utils';
import { Collector } from 'rgbpp/ckb';
import dotenv from 'dotenv';

dotenv.config({ path: __dirname + '/.env' });

export const isMainnet = process.env.IS_MAINNET === 'true' ? true : false;

export const collector = new Collector({
  ckbNodeUrl: process.env.CKB_NODE_URL!,
  ckbIndexerUrl: process.env.CKB_INDEXER_URL!,
});
export const CKB_PRIVATE_KEY = process.env.CKB_SECP256K1_PRIVATE_KEY!;
const secp256k1Lock: CKBComponents.Script = {
  ...systemScripts.SECP256K1_BLAKE160,
  args: bytesToHex(blake160(privateKeyToPublicKey(CKB_PRIVATE_KEY))),
};
export const ckbAddress = scriptToAddress(secp256k1Lock, isMainnet);


================================================
File: examples/xudt-on-ckb/package.json
================================================
{
  "name": "xudt-on-ckb-examples",
  "version": "0.1.0",
  "description": "Examples used for xUDT on CKB assets issuance and transfer",
  "private": true,
  "type": "commonjs",
  "scripts": {
    "format": "prettier --write '**/*.ts'",
    "lint": "tsc && eslint . && prettier --check '**/*.ts'",
    "lint:fix": "tsc && eslint --fix --ext .ts . && prettier --write '**/*.ts'"
  },
  "dependencies": {
    "@nervosnetwork/ckb-sdk-utils": "0.109.5",
    "rgbpp": "workspace:*"
  },
  "devDependencies": {
    "dotenv": "^16.4.5",
    "@types/dotenv": "^8.2.0"
  }
}


================================================
File: examples/xudt-on-ckb/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2015",
    "lib": ["dom", "esnext"],
    "module": "ES2015",
    "composite": false,
    "resolveJsonModule": true,
    "strictNullChecks": true,
    "noEmit": true,
    "declaration": true,
    "declarationMap": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "inlineSources": false,
    "isolatedModules": true,
    "moduleResolution": "Bundler",
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "preserveWatchOutput": true,
    "skipLibCheck": true,
    "strict": true
  },
  "exclude": ["node_modules"]
}

================================================
File: examples/xudt-on-ckb/.env.example
================================================
# True for CKB Mainnet and false for CKB Testnet, the default value is false
IS_MAINNET=false

# The CKB secp256k1 private key whose format is 32bytes hex string with 0x prefix
CKB_SECP256K1_PRIVATE_KEY=0x-private-key

# CKB node url which should match IS_MAINNET
CKB_NODE_URL=https://testnet.ckb.dev/rpc

# CKB indexer url which should match IS_MAINNET
CKB_INDEXER_URL=https://testnet.ckb.dev/indexer


================================================
File: packages/btc/README.md
================================================
# @rgbpp-sdk/btc

## About

This is the BTC part of the rgbpp-sdk for BTC/RGBPP transaction construction.

This lib is based on the foundation of the [unisat wallet-sdk](https://github.com/unisat-wallet/wallet-sdk) ([license](https://github.com/unisat-wallet/wallet-sdk/blob/master/LICENSE)). We've simplified the logic of transaction construction and fee collection process to adapt to the specific needs of RGBPP. You can refer to the unisat wallet-sdk repo for more difference.

## Installation

```bash
# Install via npm:
$ npm i @rgbpp-sdk/btc
# Install via yarn:
$ yarn add @rgbpp-sdk/btc
# Install via pnpm:
$ pnpm add @rgbpp-sdk/btc
```

## Transactions

### Transfer BTC from a `P2WPKH` address

```typescript
import { sendBtc, DataSource, NetworkType } from '@rgbpp-sdk/btc';
import { BtcAssetsApi } from '@rgbpp-sdk/service';

const service = BtcAssetsApi.fromToken('btc_assets_api_url', 'your_token');
const source = new DataSource(service, NetworkType.TESTNET);

const psbt = await sendBtc({
  from: account.address, // your P2WPKH address
  tos: [
    {
      address: 'to_address', // destination btc address
      value: 1000, // transfer satoshi amount
    },
  ],
  onlyConfirmedUtxos: false, // optional, default to false, only confirmed utxos are allowed in the transaction
  feeRate: 1, // optional, default to 1 on the testnet, and it is a floating number on the mainnet
  source,
});

// Sign & finalize inputs
psbt.signAllInputs(account.keyPair);
psbt.finalizeAllInputs();

// Broadcast transaction
const tx = psbt.extractTransaction();
const res = await service.sendTransaction(tx.toHex());
console.log('txid:', res.txid);
```

### Transfer BTC from a `P2TR` address

```typescript
import { sendBtc, DataSource, NetworkType } from '@rgbpp-sdk/btc';
import { BtcAssetsApi } from '@rgbpp-sdk/service';

const service = BtcAssetsApi.fromToken('btc_assets_api_url', 'your_token');
const source = new DataSource(service, NetworkType.TESTNET);

const psbt = await sendBtc({
  from: account.address, // your P2TR address
  fromPubkey: account.publicKey, // your public key, this is required for P2TR
  tos: [
    {
      address: 'to_address', // destination btc address
      value: 1000, // transfer satoshi amount
    },
  ],
  onlyConfirmedUtxos: false, // optional, default to false, only confirmed utxos are allowed in the transaction
  feeRate: 1, // optional, default to 1 on the testnet, and it is a floating number on the mainnet
  source,
});

// Create a tweaked signer
const tweakedSigner = tweakSigner(account.keyPair, {
  network,
});

// Sign & finalize inputs
psbt.signAllInputs(tweakedSigner);
psbt.finalizeAllInputs();

// Broadcast transaction
const tx = psbt.extractTransaction();
const res = await service.sendTransaction(tx.toHex());
console.log('txid:', res.txid);
```

### Create an `OP_RETURN` output

```typescript
import { sendBtc, DataSource, NetworkType } from '@rgbpp-sdk/btc';
import { BtcAssetsApi } from '@rgbpp-sdk/service';

const service = BtcAssetsApi.fromToken('btc_assets_api_url', 'your_token');
const source = new DataSource(service, NetworkType.TESTNET);

// Create a PSBT
const psbt = await sendBtc({
  from: account.address, // your address
  tos: [
    {
      data: Buffer.from('0x' + '00'.repeat(32), 'hex'), // any data <= 80 bytes
      value: 0, // normally the value is 0
    },
  ],
  changeAddress: account.address, // optional, where to return the change
  onlyConfirmedUtxos: false, // optional, default to false, only confirmed utxos are allowed in the transaction
  feeRate: 1, // optional, default to 1 on the testnet, and it is a floating number on the mainnet
  source,
});

// Sign & finalize inputs
psbt.signAllInputs(account.keyPair);
psbt.finalizeAllInputs();

// Broadcast transaction
const tx = psbt.extractTransaction();
const res = await service.sendTransaction(tx.toHex());
console.log('txid:', res.txid);
```

### Transfer with predefined inputs/outputs

```typescript
import { sendUtxos, DataSource, NetworkType } from '@rgbpp-sdk/btc';
import { BtcAssetsApi } from '@rgbpp-sdk/service';

const service = BtcAssetsApi.fromToken('btc_assets_api_url', 'your_token');
const source = new DataSource(service, NetworkType.TESTNET);

const psbt = await sendUtxos({
  inputs: [
    {
      txid: 'txid',
      vout: 1,
      value: 546,
      address: 'btc_address',
      addressType: AddressType.P2WPKH,
      scriptPk: 'script_publickey_hex',
    },
  ],
  outputs: [
    {
      data: Buffer.from('commentment_hex', 'hex'), // RGBPP commitment
      value: 0,
      fixed: true, // mark as fixed, so the output.value will not be changed
    },
    {
      address: 'to_address',
      value: 546,
      fixed: true,
      minUtxoSatoshi: 546, // customize the dust limit of the output
    },
  ],
  from: account.address, // provide fee to the transaction
  fromPubkey: account.publicKey, // optional, required if "from" is a P2TR address
  changeAddress: account.address, // optional, an address to return change, default to "from"
  onlyConfirmedUtxos: false, // optional, default to false, only confirmed utxos are allowed in the transaction
  feeRate: 1, // optional, default to 1 on the testnet, and it is a floating number on the mainnet
  source,
});

// Sign & finalize inputs
psbt.signAllInputs(account.keyPair);
psbt.finalizeAllInputs();

// Broadcast transaction
const tx = psbt.extractTransaction();
const res = await service.sendTransaction(tx.toHex());
console.log('txid:', res.txid);
```

### Construct a isomorphic RGBPP transaction

```typescript
import { sendRgbppUtxos, networkTypeToConfig, DataSource, Collector, NetworkType } from '@rgbpp-sdk/btc';
import { BtcAssetsApi } from '@rgbpp-sdk/service';

const networkType = NetworkType.TESTNET;
const config = networkTypeToConfig(networkType);

const service = BtcAssetsApi.fromToken('btc_assets_api_url', 'your_token');
const source = new DataSource(service, networkType);

const ckbVirtualTx: RawTransaction = {
  // ...
  inputs: [
    /* RgbppLock cells, and an optional paymaster cell */
  ],
  outputs: [
    /* RgbppLock/RgbppTimeLock cells, and an optional change cell */
  ],
} as any;
const ckbCollector = new Collector({
  ckbNodeUrl: 'ckb_node_url',
  ckbIndexerUrl: 'ckb_indexer_url',
});

const psbt = await sendRgbppUtxos({
  ckbVirtualTx, // a CKB virtual tx containing "L1 -> L1" or "L1 -> L2" action
  paymaster: {
    // if paymaster cell was included in the ckbVirtualTx, pay to paymaster
    address: 'paymaster_btc_address',
    value: 10000,
  },
  commitment: 'rgbpp_tx_commitment',
  tos: [
    // the address of the generating outputs, optional, default is "from"
    'transfer_rgbpp_to_btc_address',
  ],

  source,
  ckbCollector,
  from: accounts.address,
  fromPubkey: account.publicKey, // if "from" is a P2TR address, "fromPubkey" is required
  changeAddress: 'address_to_return_change', // optional, where should the change satoshi be returned to
  minUtxoSatoshi: config.btcUtxoDustLimit, // optional, default to 1000 on the testnet, 1,0000 on the mainnet
  rgbppMinUtxoSatoshi: config.rgbppUtxoDustLimit, // optional, default to 546 on both testnet/mainnet
  onlyConfirmedUtxos: false, // optional, default to false, only confirmed utxos are allowed in the transaction
  feeRate: 1, // optional, default to 1 on the testnet, and it is a floating number on the mainnet
});
```

### Construct a Full-RBF transaction

```typescript
import { sendRbf, networkTypeToConfig, DataSource, Collector, NetworkType } from '@rgbpp-sdk/btc';
import { BtcAssetsApi } from '@rgbpp-sdk/service';

const networkType = NetworkType.TESTNET;
const config = networkTypeToConfig(networkType);

const service = BtcAssetsApi.fromToken('btc_assets_api_url', 'your_token');
const source = new DataSource(service, networkType);

const psbt = await sendRbf({
  txHex: 'your_original_transaction_hex',
  from: account.address,
  feeRate: 40, // the feeRate should be greater than the feeRate of the original transaction
  changeIndex: 1, // optional, return change to outputs[changeIndex], will create a new output if not specified
  changeAddress: 'address_to_return_change', // optional, where should the change satoshi be returned to
  requireValidOutputsValue: false, // optional, default to false, require each output's value to be >= minUtxoSatoshi
  requireGreaterFeeAndRate: true, // optional, default to true, require the fee rate&amount to be greater than the original transction
  source,
});
```

## Errors

### Visit context of the TxBuildError

When you catch a `TxBuildError` error after calling the BTC Builder APIs (`sendBtc`, `sendUtxos`, etc), you can access the `e.context` object for error tracing, where it should contain a `tx` property that is a `TxBuilder` object:

```typescript
try {
  await sendBtc({ ... });
} catch (e) {
  if (e instanceof TxBuildError) {
    console.log(e.context.tx); // TxBuilder object for error tracing
  }
}
```

## Types

### Transaction

#### sendBtc / createSendBtcBuilder / SendBtcProps

```typescript
declare function sendBtc(props: SendBtcProps): Promise<bitcoin.Psbt>;
```

```typescript
declare function createSendBtcBuilder(props: SendBtcProps): Promise<{
  builder: TxBuilder;
  fee: number;
  feeRate: number;
  changeIndex: number;
}>;
```

```typescript
interface SendBtcProps {
  from: string;
  tos: InitOutput[];
  source: DataSource;
  feeRate?: number;
  fromPubkey?: string;
  changeAddress?: string;
  minUtxoSatoshi?: number;
  onlyConfirmedUtxos?: boolean;
}
```

#### sendUtxos / createSendUtxosBuilder / SendUtxosProps

```typescript
declare function sendUtxos(props: SendUtxosProps): Promise<bitcoin.Psbt>;
```

```typescript
declare function createSendUtxosBuilder(props: SendUtxosProps): Promise<{
  builder: TxBuilder;
  fee: number;
  feeRate: number;
  changeIndex: number;
}>;
```

```typescript
interface SendUtxosProps {
  inputs: Utxo[];
  outputs: InitOutput[];
  source: DataSource;
  from: string;
  feeRate?: number;
  fromPubkey?: string;
  changeAddress?: string;
  minUtxoSatoshi?: number;
  onlyConfirmedUtxos?: boolean;
  excludeUtxos?: BaseOutput[];

  // EXPERIMENTAL: the below props are unstable and can be altered at any time
  skipInputsValidation?: boolean;
  pubkeyMap?: AddressToPubkeyMap;
}
```

#### sendRgbppUtxos / createSendRgbppUtxosBuilder / SendRgbppUtxosProps

```typescript
declare function sendRgbppUtxos(props: SendRgbppUtxosProps): Promise<bitcoin.Psbt>;
```

```typescript
declare function createSendRgbppUtxosBuilder(props: SendRgbppUtxosProps): Promise<{
  builder: TxBuilder;
  fee: number;
  feeRate: number;
  changeIndex: number;
}>;
```

```typescript
interface SendRgbppUtxosProps {
  ckbVirtualTx: RawTransaction;
  commitment: Hash;
  tos?: string[];
  paymaster?: TxAddressOutput;

  ckbNodeUrl: string;
  rgbppLockCodeHash: Hash;
  rgbppTimeLockCodeHash: Hash;
  rgbppMinUtxoSatoshi?: number;

  source: DataSource;
  from: string;
  feeRate?: number;
  fromPubkey?: string;
  changeAddress?: string;
  minUtxoSatoshi?: number;
  onlyConfirmedUtxos?: boolean;
  excludeUtxos?: BaseOutput[];

  // EXPERIMENTAL: the below props are experimental and can be altered at any time
  pubkeyMap?: AddressToPubkeyMap;
}
```

#### sendRbf / createSendRbfBuilder / SendRbfProps

```typescript
declare function sendRbf(props: SendRbfProps): Promise<bitcoin.Psbt>;
```

```typescript
declare function createSendRbfBuilder(props: SendRbfProps): Promise<{
  builder: TxBuilder;
  fee: number;
  feeRate: number;
  changeIndex: number;
}>;
```

```typescript
interface SendRbfProps {
  from: string;
  txHex: string;
  source: DataSource;
  feeRate?: number;
  fromPubkey?: string;
  changeIndex?: number;
  changeAddress?: string;
  minUtxoSatoshi?: number;
  onlyConfirmedUtxos?: boolean;
  requireValidOutputsValue?: boolean;
  requireGreaterFeeAndRate?: boolean;

  // EXPERIMENTAL: the below props are experimental and can be altered at any time
  pubkeyMap?: AddressToPubkeyMap;
}
```

#### InitOutput

```typescript
type InitOutput = TxAddressOutput | TxDataOutput | TxScriptOutput;
```

#### TxAddressOutput / TxDataOutput / TxScriptOutput

```typescript
interface TxAddressOutput extends TxBaseOutput {
  address: string;
}
```

```typescript
interface TxDataOutput extends TxBaseOutput {
  data: Buffer | string;
}
```

```typescript
interface TxScriptOutput extends TxBaseOutput {
  script: Buffer;
}
```

#### TxBaseOutput

```typescript
interface TxBaseOutput {
  value: number;
  fixed?: boolean;
  protected?: boolean;
  minUtxoSatoshi?: number;
}
```

#### DataSource

```typescript
interface DataSource {
  constructor(service: BtcAssetsApi, networkType: NetworkType): void;
  getUtxo(hex: string, number: number, requireConfirmed?: boolean): Promise<Utxo | undefined>;
  getOutput(hex: string, number: number, requireConfirmed?: boolean): Promise<Output | Utxo | undefined>;
  getUtxos(address: string, params?: BtcAssetsApiUtxoParams): Promise<Utxo[]>;
  collectSatoshi(props: {
    address: string;
    targetAmount: number;
    minUtxoSatoshi?: number;
    allowInsufficient?: boolean;
    onlyNonRgbppUtxos?: boolean;
    onlyConfirmedUtxos?: boolean;
    noAssetsApiCache?: boolean;
    internalCacheKey?: string;
    excludeUtxos?: BaseOutput[];
  }): Promise<{
    utxos: Utxo[];
    satoshi: number;
    exceedSatoshi: number;
  }>;
}
```

#### FeesRecommended

```typescript
interface FeesRecommended {
  fastestFee: number;
  halfHourFee: number;
  hourFee: number;
  minimumFee: number;
}
```

### Basic

#### BaseOutput / Output / Utxo

```typescript
interface BaseOutput {
  txid: string;
  vout: number;
}
```

```typescript
interface Output extends BaseOutput {
  value: number;
  scriptPk: string;
}
```

```typescript
interface Utxo extends Output {
  addressType: AddressType;
  address: string;
  pubkey?: string;
}
```

#### AddressType

```typescript
enum AddressType {
  P2PKH,
  P2WPKH,
  P2TR,
  P2SH_P2WPKH,
  P2WSH,
  P2SH,
  UNKNOWN,
}
```

#### NetworkType

```typescript
enum NetworkType {
  MAINNET,
  TESTNET,
  REGTEST,
}
```

#### AddressToPubkeyMap

```typescript
type AddressToPubkeyMap = Record<string, string>;
```


================================================
File: packages/btc/CHANGELOG.md
================================================
# @rgbpp-sdk/btc

## 0.7.0

### Minor Changes

- [#293](https://github.com/utxostack/rgbpp-sdk/pull/293): Add offline btc data source & ckb collector ([@fghdotio](https://github.com/fghdotio))

### Patch Changes

- [#305](https://github.com/ckb-cell/rgbpp-sdk/pull/305): Upgrade ckb-sdk-js version ([@duanyytop](https://github.com/duanyytop))

## 0.6.0

### Minor Changes

- [#281](https://github.com/ckb-cell/rgbpp-sdk/pull/281): Upgrade ckb-sdk-js to fix esm and commonjs issues ([@duanyytop](https://github.com/duanyytop))

- [#246](https://github.com/ckb-cell/rgbpp-sdk/pull/246): Export ESM packages ([@duanyytop](https://github.com/duanyytop))

- [#272](https://github.com/ckb-cell/rgbpp-sdk/pull/272): Report TxBuilder as extra context in the TxBuildError when the BTC Builder APIs fail ([@ShookLyngs](https://github.com/ShookLyngs))

- [#270](https://github.com/ckb-cell/rgbpp-sdk/pull/270): Support for batch transferring of RGBPP XUDT assets ([@ShookLyngs](https://github.com/ShookLyngs))

  - Add `buildRgbppTransferAllTxs()` API in the rgbpp lib for generating one or more BTC/CKB transaction groups for transferring the entire amount of a specific type of RGBPP XUDT asset from one or more BTC addresses to a recipient
  - Add `sendRgbppTxGroups()` API in the rgbpp lib for sending BTC/CKB transaction groups to the `BtcAssetsApi`
  - Add `unpackRgbppLockArgs()` API in the ckb lib for unpacking the lock script args of an RGBPP Cell
  - Add `encodeCellId()` and `decodeCellId()` APIs in the ckb lib for handling the ID of a CKB Cell
  - Add `encodeUtxoId()` and `decodeUtxoId()` APIs in the btc lib for handling the ID of a BTC UTXO

### Patch Changes

- Updated dependencies [[`82d37ab`](https://github.com/ckb-cell/rgbpp-sdk/commit/82d37ab56fc2c2c1dd0437f44966380bae6c9b42), [`a2722c5`](https://github.com/ckb-cell/rgbpp-sdk/commit/a2722c535efa04c9a9a8147228c82957fe33143d), [`a31a376`](https://github.com/ckb-cell/rgbpp-sdk/commit/a31a3761056754fb6624ff571736cf18ccbdcd98), [`ec2a38e`](https://github.com/ckb-cell/rgbpp-sdk/commit/ec2a38ec5858380b2ca34de596d1eb98d1db4611)]:
  - @rgbpp-sdk/ckb@0.6.0
  - @rgbpp-sdk/service@0.6.0

## v0.5.0

### Minor Changes

- [#261](https://github.com/ckb-cell/rgbpp-sdk/pull/261): Batch fetch CKB RGB++ live cells to construct BTC transaction ([@duanyytop](https://github.com/duanyytop))

  - Batch fetch CKB RGB++ live cells to construct BTC transaction
  - Remove useless fields for RGB++ lock args list

### Patch Changes

- Updated dependencies [[`9afc2a9`](https://github.com/ckb-cell/rgbpp-sdk/commit/9afc2a911e6a4ba8a200755b01159b5b149e4010), [`8f99429`](https://github.com/ckb-cell/rgbpp-sdk/commit/8f99429de45899e5169771e87e73603318a49ae8), [`475b3c3`](https://github.com/ckb-cell/rgbpp-sdk/commit/475b3c35ab1a25ba3aae28123f2820460101c889)]:
  - @rgbpp-sdk/service@0.5.0
  - @rgbpp-sdk/ckb@0.5.0

## v0.4.0

### Minor Changes

- [#228](https://github.com/ckb-cell/rgbpp-sdk/pull/228): Support including multi-origin UTXOs in the same transaction ([@ShookLyngs](https://github.com/ShookLyngs))

  - Add `pubkeyMap` option in the sendUtxos(), sendRgbppUtxos() and sendRbf() API
  - Rename `inputsPubkey` option to `pubkeyMap` in the sendRbf() API
  - Delete `onlyProvableUtxos` option from the sendRgbppUtxos() API

- [#150](https://github.com/ckb-cell/rgbpp-sdk/pull/150): Support Full-RBF feature with the sendRbf() and createSendRbfBuilder() API ([@ShookLyngs](https://github.com/ShookLyngs))

  - Add `excludeUtxos`, `skipInputsValidation` options in the `sendUtxos()` API to support the RBF feature
  - Add `onlyProvableUtxos` option in the `sendRgbppUtxos()` API for future update supports
  - Add `changeIndex` in the return type of the BTC Builder APIs

### Patch Changes

- Updated dependencies [[`e5f41fd`](https://github.com/ckb-cell/rgbpp-sdk/commit/e5f41fd2b275182d2ab3fdf17e3b8853025fd2b9), [`6e840c1`](https://github.com/ckb-cell/rgbpp-sdk/commit/6e840c196fbece06430c559aebbdadaf7fb6e632)]:
  - @rgbpp-sdk/service@0.4.0
  - @rgbpp-sdk/ckb@0.4.0

## v0.3.0

### Minor Changes

- [#200](https://github.com/ckb-cell/rgbpp-sdk/pull/200): Add p-limit and batch queries in the sendRgbppUtxos() and TxBuilder.validateInputs() to improve construction time ([@ShookLyngs](https://github.com/ShookLyngs))

- [#208](https://github.com/ckb-cell/rgbpp-sdk/pull/208): Adapt btc-assets-api#154, adding new props and return values to the /balance and /unspent APIs ([@ShookLyngs](https://github.com/ShookLyngs))

- Add `available_satoshi` and `total_satoshi` to the BtcAssetsApi.getBtcBalance() API
- Add `only_non_rgbpp_utxos` to the props of the BtcAssetsApi.getBtcUtxos() API
- Remove `service.getRgbppAssetsByBtcUtxo()` lines from the DataCollector.collectSatoshi()
- Remove `hasRgbppAssets` related variables/function from the DataCache

- [#199](https://github.com/ckb-cell/rgbpp-sdk/pull/199): Add "needPaymaster" option to the sendRgbppUtxos() API to allow manually specifying whether a paymaster output is required ([@ShookLyngs](https://github.com/ShookLyngs))

### Patch Changes

- Updated dependencies [[`d2d963c`](https://github.com/ckb-cell/rgbpp-sdk/commit/d2d963c8f40d0316491df5bdccca4eba7a33977c), [`4c77e69`](https://github.com/ckb-cell/rgbpp-sdk/commit/4c77e69cadc8ce3d24f631c1348dcd7141fb1099), [`4f05b1b`](https://github.com/ckb-cell/rgbpp-sdk/commit/4f05b1bba898b7acb58bdf20ae275164ad94523b)]:
  - @rgbpp-sdk/ckb@0.3.0
  - @rgbpp-sdk/service@0.3.0

## v0.2.0

### Minor Changes

- [#184](https://github.com/ckb-cell/rgbpp-sdk/pull/184): Support query data caching internally in TxBuilder/DataSource, preventing query from the BtcAssetsApi too often when paying fee ([@ShookLyngs](https://github.com/ShookLyngs))

- [#165](https://github.com/ckb-cell/rgbpp-sdk/pull/165): Replace all "void 0" to "undefined" in the btc/service lib ([@ShookLyngs](https://github.com/ShookLyngs))

### Patch Changes

- [#166](https://github.com/ckb-cell/rgbpp-sdk/pull/166): Fix the message of INSUFFICIENT_UTXO error when collection failed ([@ShookLyngs](https://github.com/ShookLyngs))

- Updated dependencies [[`5e0e817`](https://github.com/ckb-cell/rgbpp-sdk/commit/5e0e8175a4c195e6491a37abedc755728c91cbed), [`a9b9796`](https://github.com/ckb-cell/rgbpp-sdk/commit/a9b9796f5ef8d27a9ad94d09a832bb9a7fe56c8e), [`9f9daa9`](https://github.com/ckb-cell/rgbpp-sdk/commit/9f9daa91486ca0cc1015713bd2648aa606da8717), [`299b404`](https://github.com/ckb-cell/rgbpp-sdk/commit/299b404217036feab409956d8888bfdc8fa820f4), [`e59322e`](https://github.com/ckb-cell/rgbpp-sdk/commit/e59322e7c6b9aff682bc1c8517337e3611dc122d), [`64c4312`](https://github.com/ckb-cell/rgbpp-sdk/commit/64c4312768885cb965285d41de99d023a4517ed3), [`1d58dd5`](https://github.com/ckb-cell/rgbpp-sdk/commit/1d58dd531947f4078667bb7294d2b3bb9351ead9), [`8cfc06e`](https://github.com/ckb-cell/rgbpp-sdk/commit/8cfc06e449c213868f103d9757f79f24521da280), [`4fcf4fa`](https://github.com/ckb-cell/rgbpp-sdk/commit/4fcf4fa6c0b20cf2fa957664a320f66601991817)]:
  - @rgbpp-sdk/ckb@0.2.0
  - @rgbpp-sdk/service@0.2.0

## v0.1.0

- Release @rgbpp-sdk/btc for RGBPP BTC-side transaction construction, providing APIs to send BTC or send RGBPP UTXO. Read the docs for more information: https://github.com/ckb-cell/rgbpp-sdk/tree/develop/packages/btc


================================================
File: packages/btc/package.json
================================================
{
  "name": "@rgbpp-sdk/btc",
  "version": "0.6.0",
  "scripts": {
    "test": "vitest",
    "build": "tsup",
    "lint": "tsc && eslint '{src,tests}/**/*.{js,ts}' && prettier --check '{src,tests}/**/*.{js,ts}'",
    "lint:fix": "tsc && eslint --fix '{src,tests}/**/*.{js,ts}' && prettier --write '{src,tests}/**/*.{js,ts}'"
  },
  "sideEffects": false,
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "import": {
        "types": "./dist/index.d.mts",
        "default": "./dist/index.mjs"
      },
      "require": {
        "types": "./dist/index.d.js",
        "default": "./dist/index.js"
      }
    },
    "./package.json": "./package.json"
  },
  "files": [
    "src",
    "dist"
  ],
  "dependencies": {
    "@bitcoinerlab/secp256k1": "^1.1.1",
    "@ckb-lumos/codec": "0.22.2",
    "@nervosnetwork/ckb-types": "0.109.5",
    "@rgbpp-sdk/ckb": "workspace:^",
    "@rgbpp-sdk/service": "workspace:^",
    "bip32": "^4.0.0",
    "bitcoinjs-lib": "^6.1.5",
    "ecpair": "^2.1.0",
    "lodash": "^4.17.21",
    "p-limit": "^3.1.0"
  },
  "publishConfig": {
    "access": "public"
  }
}


================================================
File: packages/btc/tsconfig.json
================================================
{
  "compilerOptions": {
    "moduleResolution": "Bundler",
    "module": "ESNext",
    "target": "ESNext",
    "lib": ["ESNext", "DOM"],
    "strict": true,
    "noEmit": true,
    "allowJs": true,
    "sourceMap": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "strictNullChecks": true,
    "resolveJsonModule": true,
    "isolatedModules": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist"]
}


================================================
File: packages/btc/tsup.config.ts
================================================
import { defineConfig } from 'tsup';

export default defineConfig({
  name: '@rgbpp-sdk/btc',
  dts: true,
  clean: true,
  sourcemap: true,
  format: ['esm', 'cjs'],
  entry: ['src/index.ts'],
});


================================================
File: packages/btc/.env.example
================================================
VITE_BTC_SERVICE_URL=    # URL of the service
VITE_BTC_SERVICE_TOKEN=  # JWT token to access the service
VITE_BTC_SERVICE_ORIGIN= # URL representing your token's domain


================================================
File: packages/btc/src/address.ts
================================================
import { bitcoin } from './bitcoin';
import { NetworkType } from './preset/types';
import { networkTypeToNetwork } from './preset/network';
import { ErrorCodes, TxBuildError } from './error';
import { remove0x, toXOnly } from './utils';

export enum AddressType {
  P2PKH,
  P2WPKH,
  P2TR,
  P2SH_P2WPKH,
  P2WSH,
  P2SH,
  UNKNOWN,
}

/**
 * Type: Record<Address, Pubkey>
 *
 * The map of address and pubkey, usually for recognizing the P2TR inputs in the transaction.
 */
export type AddressToPubkeyMap = Record<string, string>;

/**
 * Check weather the address is supported as a from address.
 * Currently, only P2WPKH and P2TR addresses are supported.
 */
export function isSupportedFromAddress(address: string) {
  const { addressType } = decodeAddress(address);
  return addressType === AddressType.P2WPKH || addressType === AddressType.P2TR;
}

/**
 * Convert public key to bitcoin payment object.
 */
export function publicKeyToPayment(publicKey: string, addressType: AddressType, networkType: NetworkType) {
  if (!publicKey) {
    return undefined;
  }

  const network = networkTypeToNetwork(networkType);
  const pubkey = Buffer.from(remove0x(publicKey), 'hex');

  if (addressType === AddressType.P2PKH) {
    return bitcoin.payments.p2pkh({
      pubkey,
      network,
    });
  }
  if (addressType === AddressType.P2WPKH) {
    return bitcoin.payments.p2wpkh({
      pubkey,
      network,
    });
  }
  if (addressType === AddressType.P2TR) {
    return bitcoin.payments.p2tr({
      internalPubkey: toXOnly(pubkey),
      network,
    });
  }
  if (addressType === AddressType.P2SH_P2WPKH) {
    const data = bitcoin.payments.p2wpkh({
      pubkey,
      network,
    });
    return bitcoin.payments.p2sh({
      pubkey,
      network,
      redeem: data,
    });
  }

  return undefined;
}

/**
 * Convert public key to bitcoin address.
 */
export function publicKeyToAddress(publicKey: string, addressType: AddressType, networkType: NetworkType) {
  const payment = publicKeyToPayment(publicKey, addressType, networkType);
  if (payment && payment.address) {
    return payment.address;
  } else {
    throw new TxBuildError(ErrorCodes.UNSUPPORTED_ADDRESS_TYPE);
  }
}

/**
 * Convert bitcoin address to scriptPk.
 */
export function addressToScriptPublicKey(address: string, networkType: NetworkType): Buffer {
  const network = networkTypeToNetwork(networkType);
  return bitcoin.address.toOutputScript(address, network);
}

/**
 * Convert bitcoin address to scriptPk in hex.
 */
export function addressToScriptPublicKeyHex(address: string, networkType: NetworkType): string {
  const scriptPk = addressToScriptPublicKey(address, networkType);
  return scriptPk.toString('hex');
}

/**
 * Check if the address is valid.
 */
export function isValidAddress(address: string, networkType: NetworkType) {
  try {
    bitcoin.address.toOutputScript(address, networkTypeToNetwork(networkType));
    return true;
  } catch {
    return false;
  }
}

/**
 * Get AddressType of an address.
 */
export function getAddressType(address: string): AddressType {
  return decodeAddress(address).addressType;
}

export function decodeAddress(address: string): {
  networkType: NetworkType;
  addressType: AddressType;
  dust: number;
} {
  const mainnet = bitcoin.networks.bitcoin;
  const testnet = bitcoin.networks.testnet;
  const regtest = bitcoin.networks.regtest;
  let decodeBase58: bitcoin.address.Base58CheckResult;
  let decodeBech32: bitcoin.address.Bech32Result;
  let networkType: NetworkType | undefined;
  let addressType: AddressType | undefined;
  if (address.startsWith('bc1') || address.startsWith('tb1') || address.startsWith('bcrt1')) {
    try {
      decodeBech32 = bitcoin.address.fromBech32(address);
      if (decodeBech32.prefix === mainnet.bech32) {
        networkType = NetworkType.MAINNET;
      } else if (decodeBech32.prefix === testnet.bech32) {
        networkType = NetworkType.TESTNET;
      } else if (decodeBech32.prefix === regtest.bech32) {
        networkType = NetworkType.REGTEST;
      }
      if (decodeBech32.version === 0) {
        if (decodeBech32.data.length === 20) {
          addressType = AddressType.P2WPKH;
        } else if (decodeBech32.data.length === 32) {
          addressType = AddressType.P2WSH;
        }
      } else if (decodeBech32.version === 1) {
        if (decodeBech32.data.length === 32) {
          addressType = AddressType.P2TR;
        }
      }
      if (networkType !== undefined && addressType !== undefined) {
        return {
          networkType,
          addressType,
          dust: getAddressTypeDust(addressType),
        };
      }
    } catch (e) {
      // Do nothing (no need to throw here)
    }
  } else {
    try {
      decodeBase58 = bitcoin.address.fromBase58Check(address);
      if (decodeBase58.version === mainnet.pubKeyHash) {
        networkType = NetworkType.MAINNET;
        addressType = AddressType.P2PKH;
      } else if (decodeBase58.version === testnet.pubKeyHash) {
        networkType = NetworkType.TESTNET;
        addressType = AddressType.P2PKH;
      } else if (decodeBase58.version === regtest.pubKeyHash) {
        // do not work
        networkType = NetworkType.REGTEST;
        addressType = AddressType.P2PKH;
      } else if (decodeBase58.version === mainnet.scriptHash) {
        networkType = NetworkType.MAINNET;
        addressType = AddressType.P2SH_P2WPKH;
      } else if (decodeBase58.version === testnet.scriptHash) {
        networkType = NetworkType.TESTNET;
        addressType = AddressType.P2SH_P2WPKH;
      } else if (decodeBase58.version === regtest.scriptHash) {
        // do not work
        networkType = NetworkType.REGTEST;
        addressType = AddressType.P2SH_P2WPKH;
      }

      if (networkType !== undefined && addressType !== undefined) {
        return {
          networkType,
          addressType,
          dust: getAddressTypeDust(addressType),
        };
      }
    } catch (e) {
      // Do nothing (no need to throw here)
    }
  }

  return {
    addressType: AddressType.UNKNOWN,
    networkType: NetworkType.MAINNET,
    dust: 546,
  };
}

function getAddressTypeDust(addressType: AddressType) {
  if (addressType === AddressType.P2WPKH) {
    return 294;
  } else if (addressType === AddressType.P2TR) {
    return 330;
  } else {
    return 546;
  }
}

/**
 * Add address/pubkey pair to a Record<address, pubkey> map
 */
export function addAddressToPubkeyMap(
  pubkeyMap: AddressToPubkeyMap,
  address: string,
  pubkey?: string,
): Record<string, string> {
  const newMap = { ...pubkeyMap };
  if (pubkey) {
    newMap[address] = pubkey;
  }
  return newMap;
}


================================================
File: packages/btc/src/bitcoin.ts
================================================
import ecc from '@bitcoinerlab/secp256k1';
import * as bitcoin from 'bitcoinjs-lib';
import { ECPairFactory, ECPairInterface } from 'ecpair';
import { isTaprootInput } from 'bitcoinjs-lib/src/psbt/bip371.js';
import { isP2TR, isP2WPKH, isP2PKH } from 'bitcoinjs-lib/src/psbt/psbtutils.js';

bitcoin.initEccLib(ecc);

const ECPair = ECPairFactory(ecc);

export type { ECPairInterface };
export { ecc, ECPair, bitcoin, isP2TR, isP2PKH, isP2WPKH, isTaprootInput };


================================================
File: packages/btc/src/error.ts
================================================
import { TxBuilder } from './transaction/build';

export enum ErrorCodes {
  UNKNOWN,

  MISSING_PUBKEY = 20,
  CANNOT_FIND_UTXO,
  UNCONFIRMED_UTXO,
  INSUFFICIENT_UTXO,
  REFERENCED_UNPROVABLE_UTXO,
  UNSPENDABLE_OUTPUT,
  DUPLICATED_UTXO,
  DUST_OUTPUT,
  UNSUPPORTED_OUTPUT,
  INVALID_CHANGE_OUTPUT,
  UNSUPPORTED_NETWORK_TYPE,
  UNSUPPORTED_ADDRESS_TYPE,
  UNSUPPORTED_OP_RETURN_SCRIPT,
  INVALID_FEE_RATE,
  PAYMASTER_MISMATCH,
  INVALID_UTXO_ID,

  CKB_CANNOT_FIND_OUTPOINT = 40,
  CKB_INVALID_CELL_LOCK,
  CKB_INVALID_INPUTS,
  CKB_INVALID_OUTPUTS,
  CKB_UNMATCHED_COMMITMENT,

  MEMPOOL_API_RESPONSE_ERROR = 60,
}

export const ErrorMessages = {
  [ErrorCodes.UNKNOWN]: 'Unknown error',

  [ErrorCodes.MISSING_PUBKEY]:
    'Missing a pubkey that pairs with the address, it is required for the P2TR UTXO included in the transaction',
  [ErrorCodes.CANNOT_FIND_UTXO]: 'Cannot find the UTXO, it may not exist or is not live',
  [ErrorCodes.UNCONFIRMED_UTXO]: 'Unconfirmed UTXO',
  [ErrorCodes.INSUFFICIENT_UTXO]: 'Insufficient UTXO to construct the transaction',
  [ErrorCodes.REFERENCED_UNPROVABLE_UTXO]: 'Cannot reference a UTXO that does not belongs to "from"',
  [ErrorCodes.DUPLICATED_UTXO]: 'Cannot reference the same UTXO twice',
  [ErrorCodes.UNSPENDABLE_OUTPUT]: 'Target output is not an UTXO',
  [ErrorCodes.DUST_OUTPUT]: 'Output defined value is below the dust limit',
  [ErrorCodes.UNSUPPORTED_OUTPUT]: 'Unsupported output format',
  [ErrorCodes.INVALID_CHANGE_OUTPUT]: 'Invalid change output',
  [ErrorCodes.UNSUPPORTED_NETWORK_TYPE]: 'Unsupported network type',
  [ErrorCodes.UNSUPPORTED_ADDRESS_TYPE]: 'Unsupported address type',
  [ErrorCodes.UNSUPPORTED_OP_RETURN_SCRIPT]: 'Unsupported OP_RETURN script format',
  [ErrorCodes.INVALID_FEE_RATE]: 'Invalid fee rate provided or recommended',
  [ErrorCodes.PAYMASTER_MISMATCH]: 'Paymaster mismatched',
  [ErrorCodes.INVALID_UTXO_ID]: 'Invalid UtxoId',

  [ErrorCodes.CKB_CANNOT_FIND_OUTPOINT]: 'Cannot find CKB cell by OutPoint, it may not exist or is not live',
  [ErrorCodes.CKB_INVALID_CELL_LOCK]: 'Invalid CKB cell lock, it should be RgbppLock, RgbppTimeLock or null',
  [ErrorCodes.CKB_INVALID_INPUTS]: 'Invalid input(s) found in the CKB VirtualTx',
  [ErrorCodes.CKB_INVALID_OUTPUTS]: 'Invalid output(s) found in the CKB VirtualTx',
  [ErrorCodes.CKB_UNMATCHED_COMMITMENT]: 'Invalid commitment found in the CKB VirtualTx',

  [ErrorCodes.MEMPOOL_API_RESPONSE_ERROR]: 'Mempool.space API returned an error',
};

export interface TxBuildErrorContext {
  tx?: TxBuilder;
}

export class TxBuildError extends Error {
  public code = ErrorCodes.UNKNOWN;
  public context?: TxBuildErrorContext;

  constructor(code: ErrorCodes, message = ErrorMessages[code] || 'Unknown error', context?: TxBuildErrorContext) {
    super(message);
    this.code = code;
    this.context = context;
    Object.setPrototypeOf(this, TxBuildError.prototype);
  }

  static withComment(code: ErrorCodes, comment?: string, context?: TxBuildErrorContext): TxBuildError {
    const message: string | undefined = ErrorMessages[code];
    return new TxBuildError(code, comment ? `${message}: ${comment}` : message, context);
  }

  setContext(context: TxBuildErrorContext) {
    this.context = context;
  }
}


================================================
File: packages/btc/src/index.ts
================================================
export * from './preset/types';
export * from './preset/config';
export * from './preset/network';

export * from './utils';
export * from './error';
export * from './bitcoin';
export * from './address';
export * from './script';

export * from './query/source';

export * from './transaction/build';
export * from './transaction/embed';
export * from './transaction/utxo';
export * from './transaction/fee';

export * from './api/sendBtc';
export * from './api/sendRbf';
export * from './api/sendUtxos';
export * from './api/sendRgbppUtxos';


================================================
File: packages/btc/src/script.ts
================================================
import { isP2TR, isP2WPKH } from './bitcoin';

export function isP2wpkhScript(script: Buffer | string): boolean {
  const buffer = typeof script === 'string' ? Buffer.from(script, 'hex') : script;
  return isP2WPKH(buffer);
}

export function isP2trScript(script: Buffer | string): boolean {
  const buffer = typeof script === 'string' ? Buffer.from(script, 'hex') : script;
  return isP2TR(buffer);
}


================================================
File: packages/btc/src/utils.ts
================================================
import limitPromiseConcurrency from 'p-limit';
import { bitcoin, ecc, ECPair } from './bitcoin';
import { bytes } from '@ckb-lumos/codec';
import { BaseOutput } from './transaction/utxo';
import { ErrorCodes, TxBuildError } from './error';

interface TweakableSigner extends bitcoin.Signer {
  privateKey?: Buffer;
}

const textEncoder = new TextEncoder();

export function toXOnly(pubKey: Buffer): Buffer {
  return pubKey.length === 32 ? pubKey : pubKey.subarray(1, 33);
}

function tapTweakHash(publicKey: Buffer, hash: Buffer | undefined): Buffer {
  return bitcoin.crypto.taggedHash('TapTweak', Buffer.concat(hash ? [publicKey, hash] : [publicKey]));
}

export function tweakSigner<T extends TweakableSigner>(
  signer: T,
  options?: {
    network?: bitcoin.Network;
    tweakHash?: Buffer;
  },
): bitcoin.Signer {
  if (!signer.privateKey) {
    throw new Error('Private key is required for tweaking signer!');
  }

  let privateKey: Uint8Array = signer.privateKey;
  if (signer.publicKey[0] === 3) {
    privateKey = ecc.privateNegate(privateKey);
  }

  const tweakedPrivateKey = ecc.privateAdd(privateKey, tapTweakHash(toXOnly(signer.publicKey), options?.tweakHash));
  if (!tweakedPrivateKey) {
    throw new Error('Invalid tweaked private key!');
  }

  return ECPair.fromPrivateKey(Buffer.from(tweakedPrivateKey), {
    network: options?.network,
  });
}

/**
 * Remove '0x' prefix from a hex string.
 * @example
 * remove0x('0x1234') // => '1234'
 * remove0x('1234') // => '1234'
 */
export function remove0x(hex: string): string {
  return hex.startsWith('0x') ? hex.slice(2) : hex;
}

/**
 * Convert UTF-8 raw text to buffer (binary bytes).
 * @example
 * utf8ToBuffer('0x1234') // => Uint8Array(2) [ 18, 52 ]
 * utf8ToBuffer('1234') // => Uint8Array(4) [ 49, 50, 51, 52 ]
 * utf8ToBuffer('hello') // => Uint8Array(5) [ 104, 101, 108, 108, 111 ]
 */
export function utf8ToBuffer(text: string): Uint8Array {
  const result = text.trim();
  if (result.startsWith('0x')) {
    return bytes.bytify(result);
  }

  return textEncoder.encode(result);
}

/**
 * Convert a bitcoin.Transaction to hex string.
 * Note if using for RGBPP proof, shouldn't set the "withWitness" param to "true".
 */
export function transactionToHex(tx: bitcoin.Transaction, withWitness?: boolean): string {
  const buffer: Buffer = tx['__toBuffer'](undefined, undefined, withWitness ?? false);
  return buffer.toString('hex');
}

/**
 * Encode a UTXO's txid and vout to a string ID of "{txid}:{vout}".
 */
export function encodeUtxoId(txid: string, vout: number): string {
  if (!txid || remove0x(txid).length !== 64) {
    throw TxBuildError.withComment(ErrorCodes.INVALID_UTXO_ID, `txid=${txid}`);
  }
  if (vout < 0 || vout > 0xffffffff) {
    throw TxBuildError.withComment(ErrorCodes.INVALID_UTXO_ID, `vout=${vout}`);
  }

  return `${remove0x(txid)}:${vout}`;
}

/**
 * Decode a string ID of "{txid}:{vout}" format to a BaseOutput object.
 */
export function decodeUtxoId(utxoId: string): BaseOutput {
  const parts = utxoId.split(':');
  const txid = parts[0];
  const vout = parts[1] ? parseInt(parts[1]) : undefined;
  if (
    !txid ||
    txid.startsWith('0x') ||
    txid.length !== 64 ||
    typeof vout !== 'number' ||
    isNaN(vout) ||
    vout < 0 ||
    vout > 0xffffffff
  ) {
    throw TxBuildError.withComment(ErrorCodes.INVALID_UTXO_ID, utxoId);
  }

  return {
    txid,
    vout,
  };
}

/**
 * Limits the batch size of promises when querying with Promise.all().
 * @example
 * await Promise.all([
 *   limitPromiseBatchSize(() => asyncDoSomething()),
 *   limitPromiseBatchSize(() => asyncDoSomething()),
 *   limitPromiseBatchSize(() => asyncDoSomething()),
 *   ...
 * ]);
 */
export const limitPromiseBatchSize = limitPromiseConcurrency(10);


================================================
File: packages/btc/src/api/sendBtc.ts
================================================
import { bitcoin } from '../bitcoin';
import { DataSource } from '../query/source';
import { InitOutput, TxBuilder } from '../transaction/build';
import { createSendUtxosBuilder } from './sendUtxos';

export interface SendBtcProps {
  from: string;
  tos: InitOutput[];
  source: DataSource;
  feeRate?: number;
  fromPubkey?: string;
  changeAddress?: string;
  minUtxoSatoshi?: number;
  onlyConfirmedUtxos?: boolean;
}

export async function createSendBtcBuilder(props: SendBtcProps): Promise<{
  builder: TxBuilder;
  fee: number;
  feeRate: number;
  changeIndex: number;
}> {
  // By default, all outputs in the sendBtc() API are fixed
  const outputs = props.tos.map((to) => ({
    fixed: true,
    ...to,
  }));

  return await createSendUtxosBuilder({
    inputs: [],
    outputs: outputs,
    from: props.from,
    source: props.source,
    feeRate: props.feeRate,
    fromPubkey: props.fromPubkey,
    changeAddress: props.changeAddress,
    minUtxoSatoshi: props.minUtxoSatoshi,
    onlyConfirmedUtxos: props.onlyConfirmedUtxos,
  });
}

export async function sendBtc(props: SendBtcProps): Promise<bitcoin.Psbt> {
  const { builder } = await createSendBtcBuilder(props);
  return builder.toPsbt();
}


================================================
File: packages/btc/src/api/sendRbf.ts
================================================
import { BaseOutput, Utxo } from '../transaction/utxo';
import { DataSource } from '../query/source';
import { AddressToPubkeyMap } from '../address';
import { ErrorCodes, TxBuildError } from '../error';
import { InitOutput, TxBuilder } from '../transaction/build';
import { isOpReturnScriptPubkey } from '../transaction/embed';
import { networkTypeToNetwork } from '../preset/network';
import { networkTypeToConfig } from '../preset/config';
import { createSendUtxosBuilder } from './sendUtxos';
import { bitcoin } from '../bitcoin';

export interface SendRbfProps {
  from: string;
  txHex: string;
  source: DataSource;
  feeRate?: number;
  fromPubkey?: string;
  changeIndex?: number;
  changeAddress?: string;
  minUtxoSatoshi?: number;
  onlyConfirmedUtxos?: boolean;
  requireValidOutputsValue?: boolean;
  requireGreaterFeeAndRate?: boolean;

  // EXPERIMENTAL: the below props are unstable and can be altered at any time
  pubkeyMap?: AddressToPubkeyMap;
}

export async function createSendRbfBuilder(props: SendRbfProps): Promise<{
  builder: TxBuilder;
  fee: number;
  feeRate: number;
  changeIndex: number;
}> {
  const previousTx = bitcoin.Transaction.fromHex(props.txHex);
  const network = networkTypeToNetwork(props.source.networkType);

  // Rebuild inputs
  const inputs: Utxo[] = [];
  for (const input of previousTx.ins) {
    const hash = Buffer.from(input.hash).reverse().toString('hex');
    const utxo = await props.source.getUtxo(hash, input.index);
    if (!utxo) {
      throw TxBuildError.withComment(ErrorCodes.CANNOT_FIND_UTXO, `hash: ${hash}, index: ${input.index}`);
    }
    inputs.push(utxo);
  }

  // Rebuild outputs
  const requireValidOutputsValue = props.requireValidOutputsValue ?? false;
  const outputs: InitOutput[] = previousTx.outs.map((output) => {
    if (isOpReturnScriptPubkey(output.script)) {
      return {
        script: output.script,
        value: output.value,
        fixed: true,
      };
    } else {
      return {
        minUtxoSatoshi: requireValidOutputsValue ? undefined : output.value,
        address: bitcoin.address.fromOutputScript(output.script, network),
        value: output.value,
        fixed: true,
      };
    }
  });

  // Set change output if specified
  let changeAddress: string | undefined = props.changeAddress;
  if (props.changeIndex !== undefined) {
    const changeOutput = outputs[props.changeIndex];
    if (!changeOutput) {
      throw TxBuildError.withComment(ErrorCodes.INVALID_CHANGE_OUTPUT, `outputs[${props.changeIndex}] is not found`);
    }
    const isReturnableOutput = changeOutput && 'address' in changeOutput;
    if (!isReturnableOutput) {
      throw TxBuildError.withComment(
        ErrorCodes.INVALID_CHANGE_OUTPUT,
        `outputs[${props.changeIndex}] is not a returnable output for change`,
      );
    }
    const changeOutputAddress = changeOutput.address;
    if (changeOutputAddress && changeAddress && changeAddress !== changeOutputAddress) {
      throw TxBuildError.withComment(
        ErrorCodes.INVALID_CHANGE_OUTPUT,
        `The address of outputs[${props.changeIndex}] does not match the specified changeAddress, expected: ${changeAddress}, actual: ${changeOutputAddress}`,
      );
    }
    if (changeOutputAddress && !changeAddress) {
      changeAddress = changeOutputAddress;
    }
    const isLastOutput = outputs.length === props.changeIndex + 1;
    if (isLastOutput) {
      outputs.pop();
    } else {
      const config = networkTypeToConfig(props.source.networkType);
      const minUtxoSatoshi = props.minUtxoSatoshi ?? config.btcUtxoDustLimit;
      changeOutput.minUtxoSatoshi = minUtxoSatoshi;
      changeOutput.value = minUtxoSatoshi;
      changeOutput.protected = true;
      changeOutput.fixed = false;
    }
  }

  // Fee rate
  const requireGreaterFeeAndRate = props.requireGreaterFeeAndRate ?? true;
  let feeRate: number | undefined = props.feeRate;
  if (requireGreaterFeeAndRate && !feeRate) {
    const feeRates = await props.source.getBtcRecommendedFeeRates();
    feeRate = feeRates.fastestFee;
  }

  // The RBF transaction should offer a higher fee rate
  const previousInsValue = inputs.reduce((sum, input) => sum + input.value, 0);
  const previousOutsValue = previousTx.outs.reduce((sum, output) => sum + output.value, 0);
  const previousFee = previousInsValue - previousOutsValue;
  const previousFeeRate = Math.floor(previousFee / previousTx.virtualSize());
  if (requireGreaterFeeAndRate && feeRate !== undefined && feeRate <= previousFeeRate) {
    throw TxBuildError.withComment(
      ErrorCodes.INVALID_FEE_RATE,
      `RBF should offer a higher fee rate, previous: ${previousFeeRate}, current: ${feeRate}`,
    );
  }

  // Exclude all outputs of the previous transaction during the collection
  // TODO: also exclude all outputs of the previous transaction's children transactions
  const previousTxId = previousTx.getId();
  const excludeUtxos: BaseOutput[] = previousTx.outs.map((_, index) => ({
    txid: previousTxId,
    vout: index,
  }));

  // Build RBF transaction
  const res = await createSendUtxosBuilder({
    inputs,
    outputs,
    excludeUtxos,
    changeAddress,
    from: props.from,
    source: props.source,
    feeRate: props.feeRate,
    pubkeyMap: props.pubkeyMap,
    fromPubkey: props.fromPubkey,
    minUtxoSatoshi: props.minUtxoSatoshi,
    onlyConfirmedUtxos: props.onlyConfirmedUtxos ?? true,
    skipInputsValidation: true,
  });

  // The RBF transaction should offer a higher fee amount
  if (requireGreaterFeeAndRate && res.fee <= previousFee) {
    throw TxBuildError.withComment(
      ErrorCodes.INVALID_FEE_RATE,
      `RBF should offer a higher fee amount, previous: ${previousFee}, current: ${res.fee}`,
    );
  }

  return res;
}

export async function sendRbf(props: SendRbfProps): Promise<bitcoin.Psbt> {
  const { builder } = await createSendRbfBuilder(props);
  return builder.toPsbt();
}


================================================
File: packages/btc/src/api/sendRgbppUtxos.ts
================================================
import {
  Collector,
  isRgbppLockCell,
  isBtcTimeLockCell,
  calculateCommitment,
  unpackRgbppLockArgs,
  checkCkbTxInputsCapacitySufficient,
} from '@rgbpp-sdk/ckb';
import { bitcoin } from '../bitcoin';
import { BaseOutput, Utxo } from '../transaction/utxo';
import { AddressToPubkeyMap } from '../address';
import { DataSource } from '../query/source';
import { NetworkType } from '../preset/types';
import { ErrorCodes, TxBuildError } from '../error';
import { InitOutput, TxAddressOutput, TxBuilder } from '../transaction/build';
import { networkTypeToConfig } from '../preset/config';
import { createSendUtxosBuilder } from './sendUtxos';
import { limitPromiseBatchSize } from '../utils';

export interface SendRgbppUtxosProps {
  ckbVirtualTx: CKBComponents.RawTransaction;
  commitment: string;
  tos?: string[];
  paymaster?: TxAddressOutput;
  needPaymaster?: boolean;

  ckbCollector: Collector;
  rgbppMinUtxoSatoshi?: number;

  source: DataSource;
  from: string;
  feeRate?: number;
  fromPubkey?: string;
  changeAddress?: string;
  minUtxoSatoshi?: number;
  onlyConfirmedUtxos?: boolean;
  excludeUtxos?: BaseOutput[];

  // EXPERIMENTAL: the below props are unstable and can be altered at any time
  pubkeyMap?: AddressToPubkeyMap;
}

/**
 * @deprecated Use createSendRgbppUtxosBuilder() API instead.
 */
export const sendRgbppUtxosBuilder = createSendRgbppUtxosBuilder;

export async function createSendRgbppUtxosBuilder(props: SendRgbppUtxosProps): Promise<{
  builder: TxBuilder;
  fee: number;
  feeRate: number;
  changeIndex: number;
}> {
  const btcInputs: Utxo[] = [];
  const btcOutputs: InitOutput[] = [];
  let lastCkbTypeOutputIndex = -1;

  const ckbVirtualTx = props.ckbVirtualTx;
  const config = networkTypeToConfig(props.source.networkType);
  const isCkbMainnet = props.source.networkType === NetworkType.MAINNET;

  const rgbppLockArgsList = (
    await props.ckbCollector.getLiveCells(ckbVirtualTx.inputs.map((input) => input.previousOutput!))
  ).map((cell) =>
    isRgbppLockCell(cell.output, isCkbMainnet) ? unpackRgbppLockArgs(cell.output.lock.args) : undefined,
  );

  // Batch querying UTXO from BtcAssetsApi
  const btcUtxos = await Promise.all(
    rgbppLockArgsList.map((rgbppLockArgs) => {
      if (rgbppLockArgs) {
        return limitPromiseBatchSize(() =>
          props.source.getUtxo(rgbppLockArgs.btcTxId, rgbppLockArgs.outIndex, props.onlyConfirmedUtxos),
        );
      }
      return undefined;
    }),
  );

  // Handle and check inputs
  for (let i = 0; i < ckbVirtualTx.inputs.length; i++) {
    const rgbppLockArgs = rgbppLockArgsList[i];

    // Add to inputs if all the following conditions are met:
    // 1. input.lock.args can be unpacked to RgbppLockArgs
    // 2. utxo can be found via the DataSource.getUtxo() API
    // 3. utxo is not duplicated in the inputs
    if (rgbppLockArgs) {
      const utxo = btcUtxos[i];
      if (!utxo) {
        throw TxBuildError.withComment(
          ErrorCodes.CANNOT_FIND_UTXO,
          `hash: ${rgbppLockArgs.btcTxId}, index: ${rgbppLockArgs.outIndex}`,
        );
      }

      const foundInInputs = btcInputs.some((v) => v.txid === utxo.txid && v.vout === utxo.vout);
      if (!foundInInputs) {
        btcInputs.push(utxo);
      }
    }
  }

  // The inputs.length should be >= 1
  if (btcInputs.length < 1) {
    throw new TxBuildError(ErrorCodes.CKB_INVALID_INPUTS);
  }

  // Handle and check outputs
  for (let i = 0; i < ckbVirtualTx.outputs.length; i++) {
    const ckbOutput = ckbVirtualTx.outputs[i];
    const isRgbppLock = isRgbppLockCell(ckbOutput, isCkbMainnet);
    const isBtcTimeLock = isBtcTimeLockCell(ckbOutput, isCkbMainnet);

    // If output.type !== null, then the output.lock must be RgbppLock or RgbppTimeLock
    if (ckbOutput.type) {
      if (!isRgbppLock && !isBtcTimeLock) {
        throw new TxBuildError(ErrorCodes.CKB_INVALID_CELL_LOCK);
      }

      // If output.type !== null，update lastTypeInput
      lastCkbTypeOutputIndex = i;
    }

    // If output.lock == RgbppLock, generate a corresponding output in outputs
    if (isRgbppLock) {
      const toBtcAddress = props.tos?.[i];
      const minUtxoSatoshi = props.rgbppMinUtxoSatoshi ?? config.rgbppUtxoDustLimit;
      btcOutputs.push({
        fixed: true,
        address: toBtcAddress ?? props.from,
        value: minUtxoSatoshi,
        minUtxoSatoshi,
      });
    }
  }

  // By rules, the length of type outputs should be >= 1
  // The "lastTypeOutputIndex" is -1 by default so if (index < 0) it's invalid
  if (lastCkbTypeOutputIndex < 0) {
    throw new TxBuildError(ErrorCodes.CKB_INVALID_OUTPUTS);
  }

  // Verify the provided commitment
  const calculatedCommitment = calculateCommitment({
    inputs: ckbVirtualTx.inputs,
    outputs: ckbVirtualTx.outputs.slice(0, lastCkbTypeOutputIndex + 1),
    outputsData: ckbVirtualTx.outputsData.slice(0, lastCkbTypeOutputIndex + 1),
  });
  if (props.commitment !== calculatedCommitment) {
    throw new TxBuildError(ErrorCodes.CKB_UNMATCHED_COMMITMENT);
  }

  const mergedBtcOutputs = await getMergedBtcOutputs(btcOutputs, props);

  return await createSendUtxosBuilder({
    inputs: btcInputs,
    outputs: mergedBtcOutputs,
    from: props.from,
    source: props.source,
    feeRate: props.feeRate,
    fromPubkey: props.fromPubkey,
    changeAddress: props.changeAddress,
    minUtxoSatoshi: props.minUtxoSatoshi,
    onlyConfirmedUtxos: props.onlyConfirmedUtxos,
    excludeUtxos: props.excludeUtxos,
    pubkeyMap: props.pubkeyMap,
  });
}

async function getMergedBtcOutputs(btcOutputs: InitOutput[], props: SendRgbppUtxosProps): Promise<InitOutput[]> {
  const merged: InitOutput[] = [];

  // Add commitment to the beginning of outputs
  merged.push({
    data: props.commitment,
    fixed: true,
    value: 0,
  });

  // Add outputs
  merged.push(...btcOutputs);

  // Check paymaster info
  const defaultPaymaster = await props.source.getPaymasterOutput();
  const isPaymasterUnmatched =
    defaultPaymaster?.address !== props.paymaster?.address || defaultPaymaster?.value !== props.paymaster?.value;
  if (defaultPaymaster && props.paymaster && isPaymasterUnmatched) {
    throw TxBuildError.withComment(
      ErrorCodes.PAYMASTER_MISMATCH,
      `expected: ${defaultPaymaster}, actual: ${props.paymaster}`,
    );
  }

  // Add paymaster output, only if paymaster address exists and needed
  const paymaster = defaultPaymaster ?? props.paymaster;
  const isNeedPaymasterOutput = await (async () => {
    if (props.needPaymaster !== undefined) {
      return props.needPaymaster;
    }
    const isInputsSufficient = await checkCkbTxInputsCapacitySufficient(props.ckbVirtualTx, props.ckbCollector);
    return !isInputsSufficient;
  })();
  if (paymaster && isNeedPaymasterOutput) {
    merged.push({
      ...paymaster,
      fixed: true,
    });
  }

  return merged;
}

export async function sendRgbppUtxos(props: SendRgbppUtxosProps): Promise<bitcoin.Psbt> {
  const { builder } = await createSendRgbppUtxosBuilder(props);
  return builder.toPsbt();
}


================================================
File: packages/btc/src/api/sendUtxos.ts
================================================
import { bitcoin } from '../bitcoin';
import { DataSource } from '../query/source';
import { TxBuilder, InitOutput } from '../transaction/build';
import { BaseOutput, Utxo, prepareUtxoInputs } from '../transaction/utxo';
import { AddressToPubkeyMap, addAddressToPubkeyMap } from '../address';
import { TxBuildError } from '../error';

export interface SendUtxosProps {
  inputs: Utxo[];
  outputs: InitOutput[];
  source: DataSource;
  from: string;
  feeRate?: number;
  fromPubkey?: string;
  changeAddress?: string;
  minUtxoSatoshi?: number;
  onlyConfirmedUtxos?: boolean;
  excludeUtxos?: BaseOutput[];

  // EXPERIMENTAL: the below props are unstable and can be altered at any time
  skipInputsValidation?: boolean;
  pubkeyMap?: AddressToPubkeyMap;
}

export async function createSendUtxosBuilder(props: SendUtxosProps): Promise<{
  builder: TxBuilder;
  fee: number;
  feeRate: number;
  changeIndex: number;
}> {
  const tx = new TxBuilder({
    source: props.source,
    feeRate: props.feeRate,
    minUtxoSatoshi: props.minUtxoSatoshi,
    onlyConfirmedUtxos: props.onlyConfirmedUtxos,
  });

  try {
    // Prepare the UTXO inputs:
    // 1. Fill pubkey for each P2TR UTXO, and throw if the corresponding pubkey is not found
    // 2. Throw if unconfirmed UTXOs are found (if onlyConfirmedUtxos == true && skipInputsValidation == false)
    const pubkeyMap = addAddressToPubkeyMap(props.pubkeyMap ?? {}, props.from, props.fromPubkey);
    const inputs = await prepareUtxoInputs({
      utxos: props.inputs,
      source: props.source,
      requireConfirmed: props.onlyConfirmedUtxos && !props.skipInputsValidation,
      requirePubkey: true,
      pubkeyMap,
    });

    tx.addInputs(inputs);
    tx.addOutputs(props.outputs);

    const paid = await tx.payFee({
      address: props.from,
      publicKey: pubkeyMap[props.from],
      changeAddress: props.changeAddress,
      excludeUtxos: props.excludeUtxos,
    });

    return {
      builder: tx,
      fee: paid.fee,
      feeRate: paid.feeRate,
      changeIndex: paid.changeIndex,
    };
  } catch (e) {
    // When caught TxBuildError, add TxBuilder as the context
    if (e instanceof TxBuildError) {
      e.setContext({ tx });
    }

    throw e;
  }
}

export async function sendUtxos(props: SendUtxosProps): Promise<bitcoin.Psbt> {
  const { builder } = await createSendUtxosBuilder(props);
  return builder.toPsbt();
}


================================================
File: packages/btc/src/preset/config.ts
================================================
import cloneDeep from 'lodash/cloneDeep.js';
import { bitcoin } from '../bitcoin';
import { ErrorCodes, TxBuildError } from '../error';
import { NetworkType, RgbppBtcConfig } from './types';

const defaultConfigs: Record<'testnet' | 'mainnet', RgbppBtcConfig> = {
  testnet: {
    feeRate: 1,
    btcUtxoDustLimit: 1000,
    rgbppUtxoDustLimit: 546,
    network: bitcoin.networks.testnet,
    networkType: NetworkType.TESTNET,
  },
  mainnet: {
    feeRate: 20,
    btcUtxoDustLimit: 10000,
    rgbppUtxoDustLimit: 546,
    network: bitcoin.networks.bitcoin,
    networkType: NetworkType.MAINNET,
  },
};

/**
 * Get RgbppBtcConfig by a network type.
 * If the network type is "REGTEST", it throws an unsupported network error.
 */
export function networkTypeToConfig(networkType: NetworkType): RgbppBtcConfig {
  if (networkType === NetworkType.TESTNET) {
    return cloneDeep(defaultConfigs.testnet);
  }
  if (networkType === NetworkType.MAINNET) {
    return cloneDeep(defaultConfigs.mainnet);
  }

  throw new TxBuildError(ErrorCodes.UNSUPPORTED_NETWORK_TYPE);
}

/**
 * Get RgbppBtcConfig by a bitcoinjs-lib network object.
 * If the network is not recognized, it throws an unsupported network error.
 */
export function networkToConfig(network: bitcoin.Network): RgbppBtcConfig {
  if (network.bech32 == bitcoin.networks.bitcoin.bech32) {
    return cloneDeep(defaultConfigs.mainnet);
  }
  if (network.bech32 == bitcoin.networks.testnet.bech32) {
    return cloneDeep(defaultConfigs.testnet);
  }

  throw new TxBuildError(ErrorCodes.UNSUPPORTED_NETWORK_TYPE);
}


================================================
File: packages/btc/src/preset/network.ts
================================================
import { bitcoin } from '../bitcoin';
import { NetworkType } from './types';
import { networkToConfig, networkTypeToConfig } from './config';

/**
 * Convert network type to bitcoinjs-lib network.
 */
export function networkTypeToNetwork(networkType: NetworkType): bitcoin.Network {
  const config = networkTypeToConfig(networkType);
  return config.network;
}

/**
 * Convert bitcoinjs-lib network to network type.
 */
export function networkToNetworkType(network: bitcoin.Network): NetworkType {
  const config = networkToConfig(network);
  return config.networkType;
}


================================================
File: packages/btc/src/preset/types.ts
================================================
import { bitcoin } from '../bitcoin';

export enum NetworkType {
  MAINNET,
  TESTNET,
  REGTEST, // deprecated
}

export interface RgbppBtcConfig {
  /**
   * The minimum fee rate that can be declared in a BTC transaction, in satoshi per byte.
   * Note this value can be different in different networks.
   */
  feeRate: number;
  /**
   * The minimum satoshi amount that can be declared in a BTC_UTXO.
   * BTC_UTXOs with satoshi below this constant are considered dust and will not be collected/created.
   * Officially, this constant should be 1,0000, but currently we are using 1,000 for testing purposes.
   */
  btcUtxoDustLimit: number;
  /**
   * The minimum satoshi amount that can be declared in a RGBPP_UTXO.
   * RGBPP_UTXOs with satoshi below this constant are considered dust and will not be created.
   */
  rgbppUtxoDustLimit: number;
  /**
   * The bitcoin-js lib predefined network object.
   * It contains crucial data to define what network we're working on.
   */
  network: bitcoin.Network;
  /**
   * The network type on RgbppBtc.
   * Note the "REGTEST" network is a deprecated network type, so you shouldn't use it.
   */
  networkType: NetworkType;
}


================================================
File: packages/btc/src/query/cache.ts
================================================
import { Utxo } from '../transaction/utxo';

export class DataCache {
  private utxos: Map<string, Utxo[]>; // Map<Key, Utxo[]>

  constructor() {
    this.utxos = new Map();
  }

  setUtxos(key: string, utxos: Utxo[]) {
    this.utxos.set(key, utxos);
  }
  getUtxos(key: string): Utxo[] | undefined {
    return this.utxos.get(key);
  }
  cleanUtxos(key: string) {
    if (this.utxos.has(key)) {
      this.utxos.delete(key);
    }
  }
  async optionalCacheUtxos(props: { key?: string; getter: () => Promise<Utxo[]> | Utxo[] }): Promise<Utxo[]> {
    if (props.key && this.utxos.has(props.key)) {
      return this.getUtxos(props.key) as Utxo[];
    }

    const utxos = await props.getter();
    if (props.key) {
      this.setUtxos(props.key, utxos);
    }

    return utxos;
  }
}


================================================
File: packages/btc/src/query/source.ts
================================================
import {
  BtcApiUtxoParams,
  BtcAssetsApi,
  BtcAssetsApiError,
  ErrorCodes as ServiceErrorCodes,
  OfflineBtcAssetsDataSourceError,
  BtcApiRecommendedFeeRates,
} from '@rgbpp-sdk/service';
import { BaseOutput, Output, Utxo } from '../transaction/utxo';
import { NetworkType } from '../preset/types';
import { ErrorCodes, TxBuildError } from '../error';
import { TxAddressOutput } from '../transaction/build';
import { isOpReturnScriptPubkey } from '../transaction/embed';
import { addressToScriptPublicKeyHex, getAddressType } from '../address';
import { remove0x } from '../utils';
import { DataCache } from './cache';

export class DataSource {
  public cache: DataCache;
  public service: BtcAssetsApi;
  public networkType: NetworkType;

  constructor(service: BtcAssetsApi, networkType: NetworkType) {
    this.service = service;
    this.networkType = networkType;
    this.cache = new DataCache();
  }

  // Query a UTXO from the service.
  // Will throw error if the target output is unspendable.
  // When set "confirmed = true", will throw error if the output is unconfirmed.
  async getUtxo(hash: string, index: number, requireConfirmed?: boolean): Promise<Utxo | undefined> {
    const output = await this.getOutput(hash, index, requireConfirmed);
    if (output && !('address' in output)) {
      throw TxBuildError.withComment(ErrorCodes.UNSPENDABLE_OUTPUT, `hash: ${hash}, index: ${index}`);
    }

    return output;
  }

  // Query an output from the service.
  // Both unspent or unspendable output can be queried from the API.
  // When set "confirmed = true", will throw error if the output is unconfirmed.
  async getOutput(hash: string, index: number, requireConfirmed?: boolean): Promise<Output | Utxo | undefined> {
    const txId = remove0x(hash);
    const tx = await this.service.getBtcTransaction(txId);
    if (!tx) {
      return undefined;
    }
    if (requireConfirmed && !tx.status.confirmed) {
      throw TxBuildError.withComment(ErrorCodes.UNCONFIRMED_UTXO, `hash: ${hash}, index: ${index}`);
    }
    const vout = tx.vout[index];
    if (!vout) {
      return undefined;
    }

    const scriptBuffer = Buffer.from(vout.scriptpubkey, 'hex');
    if (isOpReturnScriptPubkey(scriptBuffer)) {
      return {
        txid: txId,
        vout: index,
        value: vout.value,
        scriptPk: vout.scriptpubkey,
      } as Output;
    }

    return {
      txid: txId,
      vout: index,
      value: vout.value,
      scriptPk: vout.scriptpubkey,
      address: vout.scriptpubkey_address,
      addressType: getAddressType(vout.scriptpubkey_address),
    } as Utxo;
  }

  async isTransactionConfirmed(hash: string): Promise<boolean> {
    const tx = await this.service.getBtcTransaction(remove0x(hash));
    return tx.status.confirmed;
  }

  async getUtxos(address: string, params?: BtcApiUtxoParams): Promise<Utxo[]> {
    const utxos = await this.service.getBtcUtxos(address, params);

    const scriptPk = addressToScriptPublicKeyHex(address, this.networkType);
    return utxos
      .sort((a, b) => {
        const aBlockHeight = a.status.block_height;
        const bBlockHeight = b.status.block_height;
        if (aBlockHeight !== bBlockHeight) {
          return aBlockHeight - bBlockHeight;
        }
        return a.vout - b.vout;
      })
      .map((row): Utxo => {
        return {
          address,
          scriptPk,
          txid: row.txid,
          vout: row.vout,
          value: row.value,
          addressType: getAddressType(address),
        };
      });
  }

  async collectSatoshi(props: {
    address: string;
    targetAmount: number;
    minUtxoSatoshi?: number;
    allowInsufficient?: boolean;
    onlyNonRgbppUtxos?: boolean;
    onlyConfirmedUtxos?: boolean;
    noAssetsApiCache?: boolean;
    internalCacheKey?: string;
    excludeUtxos?: BaseOutput[];
  }): Promise<{
    utxos: Utxo[];
    satoshi: number;
    exceedSatoshi: number;
  }> {
    const allowInsufficient = props.allowInsufficient ?? false;
    const excludeUtxos = props.excludeUtxos ?? [];

    const utxos = await this.cache.optionalCacheUtxos({
      key: props.internalCacheKey,
      getter: () =>
        this.getUtxos(props.address, {
          only_non_rgbpp_utxos: props.onlyNonRgbppUtxos,
          only_confirmed: props.onlyConfirmedUtxos,
          min_satoshi: props.minUtxoSatoshi,
          no_cache: props.noAssetsApiCache,
        }),
    });

    const collected = [];
    let collectedAmount = 0;
    for (const utxo of utxos) {
      if (collectedAmount >= props.targetAmount) {
        break;
      }
      if (excludeUtxos.length > 0) {
        const excluded = excludeUtxos.find((exclude) => {
          return exclude.txid === utxo.txid && exclude.vout === utxo.vout;
        });
        if (excluded) {
          continue;
        }
      }
      collected.push(utxo);
      collectedAmount += utxo.value;
    }

    if (!allowInsufficient && collectedAmount < props.targetAmount) {
      throw TxBuildError.withComment(
        ErrorCodes.INSUFFICIENT_UTXO,
        `expected: ${props.targetAmount}, actual: ${collectedAmount}`,
      );
    }

    return {
      utxos: collected,
      satoshi: collectedAmount,
      exceedSatoshi: collectedAmount - props.targetAmount,
    };
  }

  async getPaymasterOutput(): Promise<TxAddressOutput | undefined> {
    try {
      const paymasterInfo = await this.service.getRgbppPaymasterInfo();
      return {
        address: paymasterInfo.btc_address,
        value: paymasterInfo.fee,
      };
    } catch (err) {
      if (err instanceof BtcAssetsApiError && err.code === ServiceErrorCodes.ASSETS_API_RESOURCE_NOT_FOUND) {
        return undefined;
      } else if (
        err instanceof OfflineBtcAssetsDataSourceError &&
        err.code === ServiceErrorCodes.OFFLINE_DATA_SOURCE_METHOD_NOT_AVAILABLE
      ) {
        return undefined;
      }
      throw err;
    }
  }

  async getBtcRecommendedFeeRates(): Promise<BtcApiRecommendedFeeRates> {
    return this.service.getBtcRecommendedFeeRates();
  }
}


================================================
File: packages/btc/src/transaction/build.ts
================================================
import cloneDeep from 'lodash/cloneDeep.js';
import { bitcoin } from '../bitcoin';
import { DataSource } from '../query/source';
import { ErrorCodes, TxBuildError } from '../error';
import { NetworkType, RgbppBtcConfig } from '../preset/types';
import { isSupportedFromAddress } from '../address';
import { dataToOpReturnScriptPubkey, isOpReturnScriptPubkey } from './embed';
import { networkTypeToConfig } from '../preset/config';
import { BaseOutput, Utxo, utxoToInput } from './utxo';
import { limitPromiseBatchSize } from '../utils';
import { FeeEstimator } from './fee';

export interface TxInput {
  data: {
    hash: string;
    index: number;
    witnessUtxo: { value: number; script: Buffer };
    tapInternalKey?: Buffer;
  };
  utxo: Utxo;
}

export type TxOutput = TxAddressOutput | TxScriptOutput;
export interface TxBaseOutput {
  value: number;
  fixed?: boolean;
  protected?: boolean;
  minUtxoSatoshi?: number;
}
export interface TxAddressOutput extends TxBaseOutput {
  address: string;
}
export interface TxScriptOutput extends TxBaseOutput {
  script: Buffer;
}

export type InitOutput = TxAddressOutput | TxDataOutput | TxScriptOutput;
export interface TxDataOutput extends TxBaseOutput {
  data: Buffer | string;
}

export class TxBuilder {
  inputs: TxInput[] = [];
  outputs: TxOutput[] = [];

  source: DataSource;
  config: RgbppBtcConfig;
  networkType: NetworkType;
  onlyNonRgbppUtxos: boolean;
  onlyConfirmedUtxos: boolean;
  minUtxoSatoshi: number;
  feeRate?: number;

  constructor(props: {
    source: DataSource;
    onlyNonRgbppUtxos?: boolean;
    onlyConfirmedUtxos?: boolean;
    minUtxoSatoshi?: number;
    feeRate?: number;
  }) {
    this.source = props.source;
    this.networkType = this.source.networkType;
    this.config = networkTypeToConfig(this.networkType);
    this.onlyNonRgbppUtxos = props.onlyNonRgbppUtxos ?? true;
    this.onlyConfirmedUtxos = props.onlyConfirmedUtxos ?? false;
    this.minUtxoSatoshi = props.minUtxoSatoshi ?? this.config.btcUtxoDustLimit;
    this.feeRate = props.feeRate;
  }

  hasInput(hash: string, index: number): boolean {
    return this.inputs.some((input) => input.data.hash === hash && input.data.index === index);
  }

  addInput(utxo: Utxo) {
    if (this.hasInput(utxo.txid, utxo.vout)) {
      throw TxBuildError.withComment(ErrorCodes.DUPLICATED_UTXO, `hash: ${utxo.txid}, index: ${utxo.vout}`);
    }

    utxo = cloneDeep(utxo);
    this.inputs.push(utxoToInput(utxo));
  }

  addInputs(utxos: Utxo[]) {
    utxos.forEach((utxo) => {
      this.addInput(utxo);
    });
  }

  async validateInputs() {
    await Promise.all(
      this.inputs.map(async (input) => {
        return limitPromiseBatchSize(async () => {
          const transactionConfirmed = await this.source.isTransactionConfirmed(input.data.hash);
          if (!transactionConfirmed) {
            throw TxBuildError.withComment(
              ErrorCodes.UNCONFIRMED_UTXO,
              `hash: ${input.data.hash}, index: ${input.data.index}`,
            );
          }
        });
      }),
    );
  }

  addOutput(output: InitOutput) {
    let result: TxOutput | undefined;

    if ('data' in output) {
      result = {
        script: dataToOpReturnScriptPubkey(output.data),
        value: output.value,
        fixed: output.fixed,
        protected: output.protected,
        minUtxoSatoshi: output.minUtxoSatoshi,
      };
    }
    if ('address' in output || 'script' in output) {
      result = cloneDeep(output);
    }
    if (!result) {
      throw new TxBuildError(ErrorCodes.UNSUPPORTED_OUTPUT);
    }

    const minUtxoSatoshi = result.minUtxoSatoshi ?? this.minUtxoSatoshi;
    const isOpReturnOutput = 'script' in result && isOpReturnScriptPubkey(result.script);
    if (!isOpReturnOutput && result.value < minUtxoSatoshi) {
      throw TxBuildError.withComment(ErrorCodes.DUST_OUTPUT, `expected ${minUtxoSatoshi}, but defined ${result.value}`);
    }

    this.outputs.push(result);
  }

  addOutputs(outputs: InitOutput[]) {
    outputs.forEach((output) => {
      this.addOutput(output);
    });
  }

  async payFee(props: {
    address: string;
    publicKey?: string;
    changeAddress?: string;
    deductFromOutputs?: boolean;
    excludeUtxos?: BaseOutput[];
    feeRate?: number;
  }): Promise<{
    fee: number;
    feeRate: number;
    changeIndex: number;
  }> {
    const { address, publicKey, feeRate, changeAddress, deductFromOutputs, excludeUtxos } = props;
    const originalInputs = cloneDeep(this.inputs);
    const originalOutputs = cloneDeep(this.outputs);

    // Create a cache key to enable the internal caching, prevent querying the Utxo[] too often
    // TODO: consider provide an option to disable the cache
    const internalCacheKey = `${Date.now()}`;

    // Fill a default recommended fee rate if props.feeRate is not provided
    let defaultFeeRate: number | undefined;
    if (!feeRate && !this.feeRate) {
      const feeRates = await this.source.getBtcRecommendedFeeRates();
      defaultFeeRate = feeRates.fastestFee;
    }

    // Use props.feeRate if it's specified
    const currentFeeRate = feeRate ?? this.feeRate ?? defaultFeeRate!;

    let currentFee = 0;
    let previousFee = 0;
    let isLoopedOnce = false;
    let isFeeExpected = false;
    let currentChangeIndex = -1;
    while (!isFeeExpected) {
      if (isLoopedOnce) {
        previousFee = currentFee;
        this.inputs = cloneDeep(originalInputs);
        this.outputs = cloneDeep(originalOutputs);
      }

      const { needCollect, needReturn, inputsTotal } = this.summary();
      const safeToProcess = inputsTotal > 0 || previousFee > 0;
      const returnAmount = needReturn - previousFee;
      if (safeToProcess && returnAmount > 0) {
        // If sum(inputs) - sum(outputs) > fee, return (change - fee) to a non-fixed output or to a new output.
        // Note when returning change to a new output, another satoshi collection may be needed.
        const { changeIndex } = await this.injectChange({
          address: changeAddress ?? address,
          amount: returnAmount,
          fromAddress: address,
          fromPublicKey: publicKey,
          internalCacheKey,
          excludeUtxos,
        });

        currentChangeIndex = changeIndex;
      } else {
        // If the inputs have insufficient satoshi, a satoshi collection is required.
        // For protection, at least collect 1 satoshi if the inputs are empty or the fee hasn't been calculated.
        const protectionAmount = safeToProcess ? 0 : 1;
        const targetAmount = needCollect - needReturn + previousFee + protectionAmount;
        const { changeIndex } = await this.injectSatoshi({
          address,
          publicKey,
          targetAmount,
          changeAddress,
          deductFromOutputs,
          internalCacheKey,
          excludeUtxos,
        });

        currentChangeIndex = changeIndex;
      }

      // Calculate network fee
      currentFee = await this.calculateFee(currentFeeRate);

      // If (fee = previousFee ±1), the fee is considered acceptable/expected.
      isFeeExpected = [-1, 0, 1].includes(currentFee - previousFee);
      if (!isLoopedOnce) {
        isLoopedOnce = true;
      }
    }

    // Clear cache for the Utxo[] list
    this.source.cache.cleanUtxos(internalCacheKey);

    return {
      fee: currentFee,
      feeRate: currentFeeRate,
      changeIndex: currentChangeIndex,
    };
  }

  async injectSatoshi(props: {
    address: string;
    publicKey?: string;
    targetAmount: number;
    changeAddress?: string;
    injectCollected?: boolean;
    deductFromOutputs?: boolean;
    internalCacheKey?: string;
    excludeUtxos?: BaseOutput[];
  }): Promise<{
    collected: number;
    changeIndex: number;
    changeAmount: number;
  }> {
    if (!isSupportedFromAddress(props.address)) {
      throw TxBuildError.withComment(ErrorCodes.UNSUPPORTED_ADDRESS_TYPE, props.address);
    }

    const targetAmount = props.targetAmount;
    const excludeUtxos = props.excludeUtxos ?? [];
    const injectCollected = props.injectCollected ?? false;
    const deductFromOutputs = props.deductFromOutputs ?? true;

    let collected = 0;
    let changeAmount = 0;

    /**
     * Collect from the "from" address via DataSource.
     * Will update the value of inputs/collected/changeAmount.
     *
     * The API has two layers of data caching:
     * - noAssetsApiCache: BtcAssetsApi cache, can be disabled if the set to true
     * - internalCacheKey: Internal cache, enabled if the key is provided
     */
    const _collect = async (_targetAmount: number) => {
      const { utxos, satoshi } = await this.source.collectSatoshi({
        address: props.address,
        targetAmount: _targetAmount,
        allowInsufficient: true,
        noAssetsApiCache: true,
        internalCacheKey: props.internalCacheKey,
        minUtxoSatoshi: this.minUtxoSatoshi,
        onlyNonRgbppUtxos: this.onlyNonRgbppUtxos,
        onlyConfirmedUtxos: this.onlyConfirmedUtxos,
        excludeUtxos: [...this.inputs.map((v) => v.utxo), ...excludeUtxos],
      });
      utxos.forEach((utxo) => {
        this.addInput({
          ...utxo,
          pubkey: props.publicKey,
        });
      });

      collected += satoshi;
      _updateChangeAmount();
    };
    /**
     * Update changeAmount depends on injectedCollected:
     * - true: If targetAmount=1000, collected=2000, changeAmount=2000+1000=3000
     * - false: If targetAmount=1000, collected=2000, changeAmount=2000-1000=1000
     */
    const _updateChangeAmount = () => {
      if (injectCollected) {
        changeAmount = collected + targetAmount;
      } else {
        changeAmount = collected - targetAmount;
      }
    };

    // 1. Collect from the non-fixed outputs
    if (deductFromOutputs) {
      for (let i = 0; i < this.outputs.length; i++) {
        const output = this.outputs[i];
        if (output.fixed) {
          continue;
        }
        if (collected >= targetAmount) {
          break;
        }

        const minUtxoSatoshi = output.minUtxoSatoshi ?? this.minUtxoSatoshi;
        const freeAmount = output.value - minUtxoSatoshi;
        const remain = targetAmount - collected;
        if (output.protected) {
          // If output.protected=true:
          // - Only deduct free satoshi from the output
          // - Won't destroy the output, at least keep (output.value = minUtxoSatoshi)
          const collectAmount = Math.min(freeAmount, remain);
          output.value -= collectAmount;
          collected += collectAmount;
        } else {
          // If output.protected=false:
          // - If (target collect amount > output.value), deduct all output.value
          // - Destroy the output if all value is deducted
          const collectAmount = output.value > remain ? Math.min(freeAmount, remain) : output.value;
          output.value -= collectAmount;
          collected += collectAmount;

          if (output.value === 0) {
            this.outputs.splice(i, 1);
            i--;
          }
        }
      }
    }

    // 2. Collect from the "from" address
    if (collected < targetAmount) {
      await _collect(targetAmount - collected);
    }

    // 3. Collect from "from" one more time if:
    // - Need to create an output to return change (changeAmount > 0)
    // - The change is insufficient for a non-dust output (changeAmount < minUtxoSatoshi)
    const changeAddress = props.changeAddress ?? props.address;
    const changeToOutputs = !this.canInjectChangeToOutputs(changeAddress);
    const needChangeOutput = !changeToOutputs && changeAmount > 0 && changeAmount < this.minUtxoSatoshi;
    const changeOutputNeedAmount = needChangeOutput ? this.minUtxoSatoshi - changeAmount : 0;
    if (changeOutputNeedAmount > 0) {
      await _collect(changeOutputNeedAmount);
    }

    // 4. If not collected enough satoshi, throw an error
    const insufficientBalance = collected < targetAmount;
    if (insufficientBalance) {
      const recommendedDeposit = targetAmount - collected + this.minUtxoSatoshi;
      throw TxBuildError.withComment(
        ErrorCodes.INSUFFICIENT_UTXO,
        `expected: ${targetAmount}, actual: ${collected}. You may wanna deposit more satoshi to prevent the error, for example: ${recommendedDeposit}`,
      );
    }
    const insufficientForChange = !changeToOutputs && changeAmount > 0 && changeAmount < this.minUtxoSatoshi;
    if (insufficientForChange) {
      const shiftedExpectAmount = collected + changeOutputNeedAmount;
      throw TxBuildError.withComment(
        ErrorCodes.INSUFFICIENT_UTXO,
        `expected: ${shiftedExpectAmount}, actual: ${collected}`,
      );
    }

    // 5. Return change:
    // - If changeAmount=0, no need to create a change output, and the changeIndex=-1
    // - If changeAmount>0, return change to an output or create a change output
    let changeIndex: number = -1;
    if (changeAmount > 0) {
      const injectedChanged = await this.injectChange({
        amount: changeAmount,
        address: changeAddress,
        fromAddress: props.address,
        fromPublicKey: props.publicKey,
      });

      changeIndex = injectedChanged.changeIndex;
    }

    return {
      collected,
      changeIndex,
      changeAmount,
    };
  }

  async injectChange(props: {
    amount: number;
    address: string;
    fromAddress: string;
    fromPublicKey?: string;
    internalCacheKey?: string;
    excludeUtxos?: BaseOutput[];
  }): Promise<{
    changeIndex: number;
  }> {
    const { address, fromAddress, fromPublicKey, amount, excludeUtxos, internalCacheKey } = props;

    // If any (output.fixed != true) is found in the outputs (search in ASC order),
    // return the change value to the first matched output.
    for (let i = 0; i < this.outputs.length; i++) {
      const output = this.outputs[i];
      if (output.fixed) {
        continue;
      }
      if (!('address' in output) || output.address !== address) {
        continue;
      }

      output.value += amount;
      return {
        changeIndex: i,
      };
    }

    let changeIndex: number = -1;
    if (amount < this.minUtxoSatoshi) {
      // If the change is not enough to create a non-dust output, try collect more.
      // - injectCollected=true, expect to put all (collected + amount) of satoshi as change
      // - deductFromOutputs=false, do not collect satoshi from the outputs
      // An example:
      // 1. Expected to return change of 500 satoshi, amount=500
      // 2. Collected 2000 satoshi from the "fromAddress", collected=2000
      // 3. Create a change output and return (collected + amount), output.value=2000+500=2500
      const injected = await this.injectSatoshi({
        address: fromAddress,
        publicKey: fromPublicKey,
        targetAmount: amount,
        changeAddress: address,
        injectCollected: true,
        deductFromOutputs: false,
        internalCacheKey,
        excludeUtxos,
      });
      if (injected.collected < amount) {
        throw TxBuildError.withComment(
          ErrorCodes.INSUFFICIENT_UTXO,
          `expected: ${amount}, actual: ${injected.collected}`,
        );
      }

      changeIndex = injected.changeIndex;
    } else {
      this.addOutput({
        address: address,
        value: amount,
      });

      changeIndex = this.outputs.length - 1;
    }

    return {
      changeIndex,
    };
  }

  canInjectChangeToOutputs(changeAddress: string): boolean {
    return this.outputs.some((output) => {
      return !output.fixed && (!('address' in output) || output.address === changeAddress);
    });
  }

  async calculateFee(feeRate?: number): Promise<number> {
    if (!feeRate && !this.feeRate) {
      throw TxBuildError.withComment(ErrorCodes.INVALID_FEE_RATE, `${feeRate ?? this.feeRate}`);
    }

    const currentFeeRate = feeRate ?? this.feeRate!;

    const psbt = await this.createEstimatedPsbt();
    const tx = psbt.extractTransaction(true);

    const inputs = tx.ins.length;
    const weightWithWitness = tx.byteLength(true);
    const weightWithoutWitness = tx.byteLength(false);

    const weight = weightWithoutWitness * 3 + weightWithWitness + inputs;
    const virtualSize = Math.ceil(weight / 4);
    return Math.ceil(virtualSize * currentFeeRate);
  }

  async createEstimatedPsbt(): Promise<bitcoin.Psbt> {
    const estimator = FeeEstimator.fromRandom(this.networkType);

    const tx = this.clone();
    tx.inputs = tx.inputs.map((input) => {
      const replacedUtxo = estimator.replaceUtxo(input.utxo);
      return utxoToInput(replacedUtxo);
    });

    const psbt = tx.toPsbt();
    await estimator.signPsbt(psbt);
    return psbt;
  }

  summary() {
    const inputsTotal = this.inputs.reduce((acc, input) => acc + input.utxo.value, 0);
    const outputsTotal = this.outputs.reduce((acc, output) => acc + output.value, 0);

    const inputsRemaining = inputsTotal - outputsTotal;
    const outputsRemaining = outputsTotal - inputsTotal;

    return {
      inputsTotal,
      outputsTotal,
      inputsRemaining,
      outputsRemaining,
      needReturn: inputsRemaining > 0 ? inputsRemaining : 0,
      needCollect: outputsRemaining > 0 ? outputsRemaining : 0,
    };
  }

  clone(): TxBuilder {
    const tx = new TxBuilder({
      source: this.source,
      feeRate: this.feeRate,
      minUtxoSatoshi: this.minUtxoSatoshi,
    });

    tx.inputs = cloneDeep(this.inputs);
    tx.outputs = cloneDeep(this.outputs);

    return tx;
  }

  toPsbt(): bitcoin.Psbt {
    const network = this.config.network;
    const psbt = new bitcoin.Psbt({ network });
    this.inputs.forEach((input) => {
      psbt.data.addInput(input.data);
    });
    this.outputs.forEach((output) => {
      psbt.addOutput(output);
    });
    return psbt;
  }
}


================================================
File: packages/btc/src/transaction/embed.ts
================================================
import { remove0x } from '../utils';
import { bitcoin } from '../bitcoin';
import { ErrorCodes, TxBuildError } from '../error';

/**
 * Convert data to OP_RETURN script pubkey.
 * The data size should be ranged in 1 to 80 bytes.
 *
 * @example
 * const data = Buffer.from('01020304', 'hex');
 * const scriptPk = dataToOpReturnScriptPubkey(data); // <Buffer 6a 04 01 02 03 04>
 * const scriptPkHex = scriptPk.toString('hex'); // 6a0401020304
 */
export function dataToOpReturnScriptPubkey(data: Buffer | string): Buffer {
  if (typeof data === 'string') {
    data = Buffer.from(remove0x(data), 'hex');
  }

  const payment = bitcoin.payments.embed({ data: [data] });
  return payment.output!;
}

/**
 * Get data from a OP_RETURN script pubkey.
 *
 * @example
 * const scriptPk = Buffer.from('6a0401020304', 'hex');
 * const data = opReturnScriptPubKeyToData(scriptPk); // <Buffer 01 02 03 04>
 * const hex = data.toString('hex'); // 01020304
 */
export function opReturnScriptPubKeyToData(script: Buffer): Buffer {
  if (!isOpReturnScriptPubkey(script)) {
    throw TxBuildError.withComment(ErrorCodes.UNSUPPORTED_OP_RETURN_SCRIPT, script.toString('hex'));
  }

  const res = bitcoin.script.decompile(script)!;
  return res[1] as Buffer;
}

/**
 * Check if a script pubkey is an OP_RETURN script.
 *
 * A valid OP_RETURN script should have the following structure:
 * - <OP_RETURN code> <size: n> <data of n bytes>
 * - <OP_RETURN code> <OP_PUSHDATA1> <size: n> <data of n bytes>
 *
 * @example
 * // <OP_RETURN> <size: 0x04> <data: 01020304>
 * isOpReturnScriptPubkey(Buffer.from('6a0401020304', 'hex')); // true
 * // <OP_RETURN> <OP_PUSHDATA1> <size: 0x0f> <data: 746573742d636f6d6d69746d656e74>
 * isOpReturnScriptPubkey(Buffer.from('6a4c0f746573742d636f6d6d69746d656e74', 'hex')); // true
 * // <OP_RETURN> <OP_PUSHDATA1>
 * isOpReturnScriptPubkey(Buffer.from('6a4c', 'hex')); // false
 * // <OP_RETURN> <size: 0x01>
 * isOpReturnScriptPubkey(Buffer.from('6a01', 'hex')); // false
 * // <OP_DUP> ... (not an OP_RETURN script)
 * isOpReturnScriptPubkey(Buffer.from('76a914a802fc56c704ce87c42d7c92eb75e7896bdc41e788ac', 'hex')); // false
 */
export function isOpReturnScriptPubkey(script: Buffer): boolean {
  const scripts = bitcoin.script.decompile(script);
  if (!scripts || scripts.length !== 2) {
    return false;
  }

  const [op, data] = scripts!;
  // OP_RETURN opcode is 0x6a in hex or 106 in integer
  if (op !== bitcoin.opcodes.OP_RETURN) {
    return false;
  }
  // Standard OP_RETURN data size is up to 80 bytes
  if (!(data instanceof Buffer) || data.byteLength < 1 || data.byteLength > 80) {
    return false;
  }

  // No false condition matched, it's an OP_RETURN script
  return true;
}


================================================
File: packages/btc/src/transaction/fee.ts
================================================
import { AddressType } from '../address';
import { NetworkType } from '../preset/types';
import { toXOnly, tweakSigner } from '../utils';
import { networkTypeToNetwork } from '../preset/network';
import { isP2trScript, isP2wpkhScript } from '../script';
import { ECPairInterface, bitcoin, ECPair, isTaprootInput } from '../bitcoin';
import { Utxo } from './utxo';

interface FeeEstimateAccount {
  payment: bitcoin.Payment;
  addressType: AddressType;
  address: string;
  scriptPubkey: string;
  tapInternalKey?: Buffer;
}

export class FeeEstimator {
  public networkType: NetworkType;
  public network: bitcoin.Network;

  private readonly keyPair: ECPairInterface;
  public readonly pubkey: string;
  public accounts: {
    p2wpkh: FeeEstimateAccount;
    p2tr: FeeEstimateAccount;
  };

  constructor(wif: string, networkType: NetworkType) {
    const network = networkTypeToNetwork(networkType);
    this.networkType = networkType;
    this.network = network;

    const keyPair = ECPair.fromWIF(wif, network);
    this.pubkey = keyPair.publicKey.toString('hex');
    this.keyPair = keyPair;

    const p2wpkh = bitcoin.payments.p2wpkh({
      pubkey: keyPair.publicKey,
      network,
    });
    const p2tr = bitcoin.payments.p2tr({
      internalPubkey: toXOnly(keyPair.publicKey),
      network,
    });
    this.accounts = {
      p2wpkh: {
        payment: p2wpkh,
        address: p2wpkh.address!,
        addressType: AddressType.P2WPKH,
        scriptPubkey: p2wpkh.output!.toString('hex'),
      },
      p2tr: {
        payment: p2tr,
        address: p2tr.address!,
        addressType: AddressType.P2TR,
        tapInternalKey: toXOnly(keyPair.publicKey),
        scriptPubkey: p2tr.output!.toString('hex'),
      },
    };
  }

  static fromRandom(networkType: NetworkType) {
    const network = networkTypeToNetwork(networkType);
    const keyPair = ECPair.makeRandom({ network });
    return new FeeEstimator(keyPair.toWIF(), networkType);
  }

  replaceUtxo(utxo: Utxo): Utxo {
    if (utxo.addressType === AddressType.P2WPKH || isP2wpkhScript(utxo.scriptPk)) {
      utxo.scriptPk = this.accounts.p2wpkh.scriptPubkey;
      utxo.pubkey = this.pubkey;
    }
    if (utxo.addressType === AddressType.P2TR || isP2trScript(utxo.scriptPk)) {
      utxo.scriptPk = this.accounts.p2tr.scriptPubkey;
      utxo.pubkey = this.pubkey;
    }

    return utxo;
  }

  async signPsbt(psbt: bitcoin.Psbt): Promise<bitcoin.Psbt> {
    // Tweak signer for P2TR inputs
    const tweakedSigner = tweakSigner(this.keyPair, {
      network: this.network,
    });

    psbt.data.inputs.forEach((input, index) => {
      // Fill tapInternalKey for P2TR inputs if missing
      if (input.witnessUtxo) {
        const isNotSigned = !(input.finalScriptSig || input.finalScriptWitness);
        const isP2trInput = isP2trScript(input.witnessUtxo.script);
        const lostInternalPubkey = !input.tapInternalKey;
        if (isNotSigned && isP2trInput && lostInternalPubkey) {
          if (input.witnessUtxo.script.toString('hex') === this.accounts.p2tr.scriptPubkey) {
            input.tapInternalKey = this.accounts.p2tr.tapInternalKey!;
          }
        }
      }

      // Sign P2WPKH/P2TR inputs
      if (isTaprootInput(input)) {
        psbt.signInput(index, tweakedSigner);
      } else {
        psbt.signInput(index, this.keyPair);
      }
    });

    psbt.finalizeAllInputs();
    return psbt;
  }
}


================================================
File: packages/btc/src/transaction/utxo.ts
================================================
import cloneDeep from 'lodash/cloneDeep.js';
import { ErrorCodes, TxBuildError } from '../error';
import { DataSource } from '../query/source';
import { AddressType, AddressToPubkeyMap } from '../address';
import { TxInput } from './build';
import { limitPromiseBatchSize, remove0x, toXOnly } from '../utils';
import { isP2trScript } from '../script';

export interface BaseOutput {
  txid: string;
  vout: number;
}

export interface Output extends BaseOutput {
  value: number;
  scriptPk: string;
}

export interface Utxo extends Output {
  addressType: AddressType;
  address: string;
  pubkey?: string;
}

export function utxoToInput(utxo: Utxo): TxInput {
  if (utxo.addressType === AddressType.P2WPKH) {
    const data = {
      hash: utxo.txid,
      index: utxo.vout,
      witnessUtxo: {
        value: utxo.value,
        script: Buffer.from(remove0x(utxo.scriptPk), 'hex'),
      },
    };

    return {
      data,
      utxo,
    };
  }
  if (utxo.addressType === AddressType.P2TR) {
    if (!utxo.pubkey) {
      throw TxBuildError.withComment(ErrorCodes.MISSING_PUBKEY, utxo.address);
    }
    const data = {
      hash: utxo.txid,
      index: utxo.vout,
      witnessUtxo: {
        value: utxo.value,
        script: Buffer.from(remove0x(utxo.scriptPk), 'hex'),
      },
      tapInternalKey: toXOnly(Buffer.from(remove0x(utxo.pubkey), 'hex')),
    };
    return {
      data,
      utxo,
    };
  }

  throw new TxBuildError(ErrorCodes.UNSUPPORTED_ADDRESS_TYPE);
}

/**
 * Fill pubkey for P2TR UTXO, and optionally throw an error if pubkey is missing
 */
export function fillUtxoPubkey(
  utxo: Utxo,
  pubkeyMap: AddressToPubkeyMap,
  options?: {
    requirePubkey?: boolean;
  },
): Utxo {
  const newUtxo = cloneDeep(utxo);
  if (isP2trScript(newUtxo.scriptPk) && !newUtxo.pubkey) {
    const pubkey = pubkeyMap[newUtxo.address];
    if (options?.requirePubkey && !pubkey) {
      throw TxBuildError.withComment(ErrorCodes.MISSING_PUBKEY, newUtxo.address);
    }
    if (pubkey) {
      newUtxo.pubkey = pubkey;
    }
  }

  return newUtxo;
}

/**
 * Prepare and validate UTXOs for transaction building:
 * 1. Fill pubkey for P2TR UTXOs, and optionally throw an error if pubkey is missing
 * 2. Optionally check if the UTXOs are confirmed, and throw an error if not
 */
export async function prepareUtxoInputs(props: {
  utxos: Utxo[];
  source: DataSource;
  requirePubkey?: boolean;
  requireConfirmed?: boolean;
  pubkeyMap?: AddressToPubkeyMap;
}): Promise<Utxo[]> {
  const pubkeyMap = props.pubkeyMap ?? {};
  const utxos = props.utxos.map((utxo) => {
    return fillUtxoPubkey(utxo, pubkeyMap, {
      requirePubkey: props.requirePubkey,
    });
  });

  if (props.requireConfirmed) {
    await Promise.all(
      utxos.map(async (utxo) => {
        return limitPromiseBatchSize(async () => {
          const transactionConfirmed = await props.source.isTransactionConfirmed(utxo.txid);
          if (!transactionConfirmed) {
            throw TxBuildError.withComment(ErrorCodes.UNCONFIRMED_UTXO, `hash: ${utxo.txid}, index: ${utxo.vout}`);
          }
        });
      }),
    );
  }

  return utxos;
}


================================================
File: packages/btc/tests/Address.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { bitcoin, ECPair, toXOnly } from '../src';
import { network } from './shared/env';

describe('Address', () => {
  it('Create SegWit (P2WPKH) address', () => {
    const keyPair = ECPair.fromPrivateKey(
      Buffer.from('8d3c23d340ac0841e6c3b58a9bbccb9a28e94ab444f972cff35736fa2fcf9f3f', 'hex'),
      { network },
    );

    expect(keyPair.publicKey.toString('hex')).toEqual(
      '037dff8ff2e0bd222690d785f9277e0c4800fc88b0fad522f1442f21a8226253ce',
    );

    const { address } = bitcoin.payments.p2wpkh({
      pubkey: keyPair.publicKey,
      network,
    });

    expect(address).toEqual('tb1qm06rvrq8jyyckzc5v709u7qpthel9j4d9f7nh3');
  });
  it('Create Taproot (P2TR) address', () => {
    const keyPair = ECPair.fromPrivateKey(
      Buffer.from('8d3c23d340ac0841e6c3b58a9bbccb9a28e94ab444f972cff35736fa2fcf9f3f', 'hex'),
      { network },
    );

    const tapInternalPubkey = toXOnly(keyPair.publicKey);
    expect(tapInternalPubkey.toString('hex')).toEqual(
      '7dff8ff2e0bd222690d785f9277e0c4800fc88b0fad522f1442f21a8226253ce',
    );

    const p2tr = bitcoin.payments.p2tr({
      internalPubkey: tapInternalPubkey,
      network,
    });

    expect(p2tr.pubkey).toBeDefined();
    expect(p2tr.pubkey!.toString('hex')).toEqual('fff71aebedf8ac5a3041f32a7a05bde104b8f523371be6aa63c6f9c00cc05809');

    expect(p2tr.output).toBeDefined();
    expect(p2tr.output!.toString('hex')).toEqual(
      '5120fff71aebedf8ac5a3041f32a7a05bde104b8f523371be6aa63c6f9c00cc05809',
    );

    expect(p2tr.address).toBeDefined();
    expect(p2tr.address).toEqual('tb1pllm346ldlzk95vzp7v485pdauyzt3afrxud7d2nrcmuuqrxqtqysepxvl0');
  });
});


================================================
File: packages/btc/tests/DataSource.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { source } from './shared/env';
import { ErrorCodes } from '../src';

describe('DataSource', { retry: 3 }, () => {
  it('Get OP_RETURN output via getOutput()', async () => {
    const output = await source.getOutput('70b250e2a3cc7a33b47f7a4e94e41e1ee2501ce73b393d824db1dd4c872c5348', 0);

    expect(output).toBeDefined();
    expect(output.txid).toBeTypeOf('string');
    expect(output.vout).toBeTypeOf('number');
    expect(output.value).toBeTypeOf('number');
    expect(output.scriptPk).toBeTypeOf('string');
    expect(output).not.toHaveProperty('address');
    expect(output).not.toHaveProperty('addressType');
  });
  it('Get OP_RETURN output via getUtxo()', async () => {
    await expect(() =>
      source.getUtxo('70b250e2a3cc7a33b47f7a4e94e41e1ee2501ce73b393d824db1dd4c872c5348', 0),
    ).rejects.toHaveProperty('code', ErrorCodes.UNSPENDABLE_OUTPUT);
  });
  describe('collectSatoshi()', () => {
    const address = 'tb1qn5kgn70tpwsw4nuxrch8l7qa9nqn4fahxgzjg6';
    const totalSatoshi = 546 + 2000 + 1500;
    const nonRgbppSatoshi = 1500;
    const nonRgbppUtxo = 1;
    const totalUtxo = 3;

    it('onlyNonRgbppUtxos = false', async () => {
      const c = await source.collectSatoshi({
        address,
        targetAmount: totalSatoshi,
        onlyNonRgbppUtxos: false,
      });
      expect(c.utxos).toHaveLength(totalUtxo);
      expect(c.satoshi).toEqual(totalSatoshi);
    });
    it('onlyNonRgbppUtxos = true', async () => {
      const c = await source.collectSatoshi({
        address,
        targetAmount: nonRgbppSatoshi,
        onlyNonRgbppUtxos: true,
      });
      expect(c.utxos).toHaveLength(nonRgbppUtxo);
      expect(c.satoshi).toEqual(nonRgbppSatoshi);
    });
    it('Try onlyNonRgbppUtxos = true and targetAmount = totalSatoshi', async () => {
      await expect(() =>
        source.collectSatoshi({
          address,
          targetAmount: totalSatoshi,
          onlyNonRgbppUtxos: true,
        }),
      ).rejects.toThrowError();
    });
  });
});


================================================
File: packages/btc/tests/Embed.test.ts
================================================
import { describe, it, expect } from 'vitest';
import { dataToOpReturnScriptPubkey, opReturnScriptPubKeyToData } from '../src';

describe('Embed', () => {
  it('Encode UTF-8 data to OP_RETURN script pubkey', () => {
    const data = Buffer.from('test-commitment', 'utf-8');
    const script = dataToOpReturnScriptPubkey(data);

    expect(script.toString('hex')).toEqual('6a0f746573742d636f6d6d69746d656e74');
  });
  it('Decode UTF-8 data from OP_RETURN script pubkey', () => {
    const script = Buffer.from('6a0f746573742d636f6d6d69746d656e74', 'hex');
    const data = opReturnScriptPubKeyToData(script);

    expect(data.toString('utf-8')).toEqual('test-commitment');
  });

  it('Decode 32-byte hex from OP_RETURN script pubkey', () => {
    const hex = '00'.repeat(32);
    const script = Buffer.from('6a20' + hex, 'hex');
    const data = opReturnScriptPubKeyToData(script);

    expect(data.toString('hex')).toEqual(hex);
  });

  it('Encode 80-byte data to OP_RETURN script pubkey', () => {
    const hex = '00'.repeat(80);
    const data = Buffer.from(hex, 'hex');
    const script = dataToOpReturnScriptPubkey(data);

    expect(script.toString('hex')).toEqual('6a4c50' + hex);
  });
  it('Decode 80-byte hex from OP_RETURN script pubkey', () => {
    const hex = '00'.repeat(80);
    const script = Buffer.from('6a4c50' + hex, 'hex');
    const data = opReturnScriptPubKeyToData(script);

    expect(data.toString('hex')).toEqual(hex);
  });
});


================================================
File: packages/btc/tests/Network.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { bitcoin, NetworkType, networkTypeToConfig, networkToConfig } from '../src';
import { networkToNetworkType, networkTypeToNetwork } from '../src';

describe('Network', () => {
  it('networkTypeToConfig()', () => {
    const testnet = networkTypeToConfig(NetworkType.TESTNET);
    expect(testnet).toBeDefined();
    expect(testnet.networkType).toBe(NetworkType.TESTNET);
    expect(testnet.network).toEqual(bitcoin.networks.testnet);

    const mainnet = networkTypeToConfig(NetworkType.MAINNET);
    expect(mainnet).toBeDefined();
    expect(mainnet.networkType).toBe(NetworkType.MAINNET);
    expect(mainnet.network).toEqual(bitcoin.networks.bitcoin);

    expect(() => networkTypeToConfig(NetworkType.REGTEST)).toThrow();
  });
  it('networkToConfig()', () => {
    const testnet = networkToConfig(bitcoin.networks.testnet);
    expect(testnet).toBeDefined();
    expect(testnet.networkType).toBe(NetworkType.TESTNET);
    expect(testnet.network).toEqual(bitcoin.networks.testnet);

    const mainnet = networkToConfig(bitcoin.networks.bitcoin);
    expect(mainnet).toBeDefined();
    expect(mainnet.networkType).toBe(NetworkType.MAINNET);
    expect(mainnet.network).toEqual(bitcoin.networks.bitcoin);

    expect(() => networkToConfig(bitcoin.networks.regtest)).toThrow();
  });
  it('networkTypeToNetwork()', () => {
    const testnet = networkTypeToNetwork(NetworkType.TESTNET);
    expect(testnet).toEqual(bitcoin.networks.testnet);

    const mainnet = networkTypeToNetwork(NetworkType.MAINNET);
    expect(mainnet).toEqual(bitcoin.networks.bitcoin);

    expect(() => networkTypeToNetwork(NetworkType.REGTEST)).toThrow();
  });
  it('networkToNetworkType()', () => {
    const testnet = networkToNetworkType(bitcoin.networks.testnet);
    expect(testnet).toEqual(NetworkType.TESTNET);

    const mainnet = networkToNetworkType(bitcoin.networks.bitcoin);
    expect(mainnet).toEqual(NetworkType.MAINNET);

    expect(() => networkToNetworkType(bitcoin.networks.regtest)).toThrow();
  });
});


================================================
File: packages/btc/tests/Script.test.ts
================================================
import { isP2trScript, isP2wpkhScript } from '../src';
import { describe, expect, it } from 'vitest';
import { accounts } from './shared/env';

describe('Script', () => {
  const p2wpkh = accounts.charlie.p2wpkh.scriptPubkey;
  const p2tr = accounts.charlie.p2tr.scriptPubkey;

  it('isP2trScript()', () => {
    expect(isP2trScript(p2tr)).toBe(true);
    expect(isP2trScript(p2wpkh)).toBe(false);
  });
  it('isP2wpkhScript()', () => {
    expect(isP2wpkhScript(p2wpkh)).toBe(true);
    expect(isP2wpkhScript(p2tr)).toBe(false);
  });
});


================================================
File: packages/btc/tests/Transaction.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { accounts, config, network, service, source } from './shared/env';
import { expectPsbtFeeInRange, signAndBroadcastPsbt, waitFor } from './shared/utils';
import { bitcoin, ErrorMessages, ErrorCodes, AddressType, TxBuilder, TxBuildError } from '../src';
import { createSendUtxosBuilder, createSendBtcBuilder, sendBtc, sendUtxos, sendRbf, tweakSigner } from '../src';

const STATIC_FEE_RATE = 1;
const BTC_UTXO_DUST_LIMIT = config.btcUtxoDustLimit;
const RGBPP_UTXO_DUST_LIMIT = config.rgbppUtxoDustLimit;

describe('Transaction', () => {
  describe('sendBtc()', () => {
    it('Transfer from Native SegWit (P2WPKH) address', async () => {
      const { builder, feeRate } = await createSendBtcBuilder({
        from: accounts.charlie.p2wpkh.address,
        tos: [
          {
            address: accounts.charlie.p2wpkh.address,
            value: 1000,
          },
        ],
        feeRate: STATIC_FEE_RATE,
        source,
      });

      // Sign & finalize inputs
      const psbt = builder.toPsbt();
      psbt.signAllInputs(accounts.charlie.keyPair);
      psbt.finalizeAllInputs();

      expect(feeRate).toEqual(STATIC_FEE_RATE);
      expectPsbtFeeInRange(psbt, feeRate);

      // Broadcast transaction
      // const tx = psbt.extractTransaction();
      // const res = await service.sendBtcTransaction(tx.toHex());
      // console.log(`explorer: https://mempool.space/testnet/tx/${res.txid}`);
    });
    it('Transfer from Taproot (P2TR) address', async () => {
      const psbt = await sendBtc({
        from: accounts.charlie.p2tr.address,
        fromPubkey: accounts.charlie.publicKey,
        tos: [
          {
            address: accounts.charlie.p2tr.address,
            value: 1000,
          },
        ],
        feeRate: STATIC_FEE_RATE,
        source,
      });

      // Create a tweaked signer
      const tweakedSigner = tweakSigner(accounts.charlie.keyPair, {
        network,
      });

      // Sign & finalize inputs
      psbt.signAllInputs(tweakedSigner);
      psbt.finalizeAllInputs();

      expectPsbtFeeInRange(psbt, STATIC_FEE_RATE);

      // Broadcast transaction
      // const tx = psbt.extractTransaction();
      // const res = await service.sendBtcTransaction(tx.toHex());
      // console.log(`explorer: https://mempool.space/testnet/tx/${res.txid}`);
    });
    it('Transfer with defined value < minUtxoSatoshi', async () => {
      await expect(() =>
        sendBtc({
          from: accounts.charlie.p2wpkh.address,
          tos: [
            {
              address: accounts.charlie.p2wpkh.address,
              value: 546,
            },
          ],
          feeRate: STATIC_FEE_RATE,
          source,
        }),
      ).rejects.toThrow();
    });
    it('Transfer with an impossible "minUtxoSatoshi" filter', async () => {
      const balance = await service.getBtcBalance(accounts.charlie.p2wpkh.address, {
        min_satoshi: BTC_UTXO_DUST_LIMIT,
      });

      const impossibleLimit = balance.satoshi + balance.pending_satoshi + 1;

      await expect(() =>
        sendBtc({
          from: accounts.charlie.p2wpkh.address,
          tos: [
            {
              address: accounts.charlie.p2wpkh.address,
              value: impossibleLimit,
            },
          ],
          minUtxoSatoshi: impossibleLimit,
          feeRate: STATIC_FEE_RATE,
          source,
        }),
      ).rejects.toThrow(ErrorMessages[ErrorCodes.INSUFFICIENT_UTXO]);
    });
    it('Transfer with an extra OP_RETURN output', async () => {
      const psbt = await sendBtc({
        from: accounts.charlie.p2wpkh.address,
        tos: [
          {
            data: Buffer.from('00'.repeat(32), 'hex'),
            value: 0,
          },
          {
            address: accounts.charlie.p2wpkh.address,
            value: 1000,
          },
        ],
        feeRate: STATIC_FEE_RATE,
        source,
      });

      // Sign & finalize inputs
      psbt.signAllInputs(accounts.charlie.keyPair);
      psbt.finalizeAllInputs();

      const outputs = psbt.txOutputs;
      expect(outputs).toHaveLength(3);

      const opReturnOutput = outputs[0];
      expect(opReturnOutput).toBeDefined();
      expect(opReturnOutput.script).toBeDefined();

      const scripts = bitcoin.script.decompile(opReturnOutput.script);
      expect(scripts).toBeDefined();

      const op = scripts![0];
      expect(op).toBeTypeOf('number');
      expect(op).toBe(bitcoin.opcodes.OP_RETURN);

      const data = scripts![1];
      expect(data).toBeInstanceOf(Buffer);
      expect((data as Buffer).toString('hex')).toEqual('00'.repeat(32));

      expectPsbtFeeInRange(psbt, STATIC_FEE_RATE);

      // Broadcast transaction
      // const tx = psbt.extractTransaction();
      // const res = await service.sendBtcTransaction(tx.toHex());
      // console.log(`explorer: https://mempool.space/testnet/tx/${res.txid}`);
    });
    it('Try insufficient-balance transfer, and check error.context', async () => {
      try {
        await createSendBtcBuilder({
          from: accounts.charlie.p2wpkh.address,
          tos: [
            {
              address: accounts.charlie.p2wpkh.address,
              value: 1_0000_0000_0000,
            },
          ],
          feeRate: STATIC_FEE_RATE,
          source,
        });
      } catch (e) {
        expect(e).toBeInstanceOf(TxBuildError);
        expect(e.context).toBeDefined();
        expect(e.context.tx).toBeInstanceOf(TxBuilder);
      }
    });
  });

  describe('sendUtxos()', () => {
    it('Transfer fixed UTXO, sum(ins) = sum(outs)', async () => {
      const { builder, feeRate, changeIndex } = await createSendUtxosBuilder({
        from: accounts.charlie.p2wpkh.address,
        inputs: [
          {
            txid: '4e1e9f8ff4bf245793c05bf2da58bff812c332a296d93c6935fbc980d906e567',
            vout: 1,
            value: 1000,
            addressType: AddressType.P2WPKH,
            address: accounts.charlie.p2wpkh.address,
            scriptPk: accounts.charlie.p2wpkh.scriptPubkey.toString('hex'),
          },
        ],
        outputs: [
          {
            address: accounts.charlie.p2wpkh.address,
            value: 1000,
            fixed: true,
          },
        ],
        source,
        feeRate: STATIC_FEE_RATE,
      });

      // Sign & finalize inputs
      const psbt = builder.toPsbt();
      psbt.signAllInputs(accounts.charlie.keyPair);
      psbt.finalizeAllInputs();

      expect(psbt.txInputs.length).toBeGreaterThanOrEqual(2);
      expect(psbt.txOutputs).toHaveLength(2);
      expect(changeIndex).toEqual(1);
      expect(feeRate).toEqual(STATIC_FEE_RATE);
      expectPsbtFeeInRange(psbt, STATIC_FEE_RATE);

      // Broadcast transaction
      // const tx = psbt.extractTransaction();
      // const res = await service.sendBtcTransaction(tx.toHex());
      // console.log(`explorer: https://mempool.space/testnet/tx/${res.txid}`);
    });
    it('Transfer fixed UTXO, sum(ins) = sum(outs) = 0', async () => {
      const { builder, feeRate } = await createSendUtxosBuilder({
        from: accounts.charlie.p2wpkh.address,
        inputs: [],
        outputs: [
          {
            data: Buffer.from('00'.repeat(32), 'hex'),
            fixed: true,
            value: 0,
          },
        ],
        source,
      });

      // Sign & finalize inputs
      const psbt = builder.toPsbt();
      psbt.signAllInputs(accounts.charlie.keyPair);
      psbt.finalizeAllInputs();

      expect(psbt.txInputs.length).toBeGreaterThanOrEqual(1);
      expect(psbt.txOutputs).toHaveLength(2);
      expectPsbtFeeInRange(psbt, feeRate);

      // Broadcast transaction
      // const tx = psbt.extractTransaction();
      // const res = await service.sendBtcTransaction(tx.toHex());
      // console.log(`explorer: https://mempool.space/testnet/tx/${res.txid}`);
    });
    it('Transfer fixed UTXO, sum(ins) < sum(outs)', async () => {
      const psbt = await sendUtxos({
        from: accounts.charlie.p2wpkh.address,
        inputs: [
          {
            txid: '4e1e9f8ff4bf245793c05bf2da58bff812c332a296d93c6935fbc980d906e567',
            vout: 1,
            value: 1000,
            addressType: AddressType.P2WPKH,
            address: accounts.charlie.p2wpkh.address,
            scriptPk: accounts.charlie.p2wpkh.scriptPubkey.toString('hex'),
          },
        ],
        outputs: [
          {
            address: accounts.charlie.p2wpkh.address,
            value: 2000,
            fixed: true,
          },
        ],
        feeRate: STATIC_FEE_RATE,
        source,
      });

      // Sign & finalize inputs
      psbt.signAllInputs(accounts.charlie.keyPair);
      psbt.finalizeAllInputs();

      expect(psbt.txInputs.length).toBeGreaterThanOrEqual(2);
      expect(psbt.txOutputs).toHaveLength(2);
      expectPsbtFeeInRange(psbt, STATIC_FEE_RATE);

      // Broadcast transaction
      // const tx = psbt.extractTransaction();
      // const res = await service.sendBtcTransaction(tx.toHex());
      // console.log(`explorer: https://mempool.space/testnet/tx/${res.txid}`);
    });
    it('Transfer fixed UTXO, sum(ins) > sum(outs), change > fee, change < fee + minUtxoSatoshi', async () => {
      const psbt = await sendUtxos({
        from: accounts.charlie.p2wpkh.address,
        inputs: [
          {
            txid: '4e1e9f8ff4bf245793c05bf2da58bff812c332a296d93c6935fbc980d906e567',
            vout: 1,
            value: 2000,
            addressType: AddressType.P2WPKH,
            address: accounts.charlie.p2wpkh.address,
            scriptPk: accounts.charlie.p2wpkh.scriptPubkey.toString('hex'),
          },
        ],
        outputs: [
          {
            address: accounts.charlie.p2wpkh.address,
            value: 1500,
            fixed: true,
          },
        ],
        feeRate: STATIC_FEE_RATE,
        source,
      });

      // Sign & finalize inputs
      psbt.signAllInputs(accounts.charlie.keyPair);
      psbt.finalizeAllInputs();

      expect(psbt.txInputs.length).toBeGreaterThanOrEqual(2);
      expect(psbt.txOutputs).toHaveLength(2);
      expectPsbtFeeInRange(psbt, STATIC_FEE_RATE);

      // Broadcast transaction
      // const tx = psbt.extractTransaction();
      // const res = await service.sendBtcTransaction(tx.toHex());
      // console.log(`explorer: https://mempool.space/testnet/tx/${res.txid}`);
    });
    it('Transfer fixed UTXO, sum(ins) > sum(outs), change > fee + minUtxoSatoshi', async () => {
      const psbt = await sendUtxos({
        from: accounts.charlie.p2wpkh.address,
        inputs: [
          {
            txid: '4e1e9f8ff4bf245793c05bf2da58bff812c332a296d93c6935fbc980d906e567',
            vout: 1,
            value: 2500,
            addressType: AddressType.P2WPKH,
            address: accounts.charlie.p2wpkh.address,
            scriptPk: accounts.charlie.p2wpkh.scriptPubkey.toString('hex'),
          },
        ],
        outputs: [
          {
            address: accounts.charlie.p2wpkh.address,
            value: 1000,
            fixed: true,
          },
        ],
        feeRate: STATIC_FEE_RATE,
        source,
      });

      // Sign & finalize inputs
      psbt.signAllInputs(accounts.charlie.keyPair);
      psbt.finalizeAllInputs();

      expect(psbt.txInputs).toHaveLength(1);
      expect(psbt.txOutputs).toHaveLength(2);
      expectPsbtFeeInRange(psbt, STATIC_FEE_RATE);

      // Broadcast transaction
      // const tx = psbt.extractTransaction();
      // const res = await service.sendBtcTransaction(tx.toHex());
      // console.log(`explorer: https://mempool.space/testnet/tx/${res.txid}`);
    });
    it('Transfer fixed UTXO, sum(ins) > sum(outs), change = fee + minUtxoSatoshi', async () => {
      const psbt = await sendUtxos({
        from: accounts.charlie.p2wpkh.address,
        inputs: [
          {
            txid: '4e1e9f8ff4bf245793c05bf2da58bff812c332a296d93c6935fbc980d906e567',
            vout: 1,
            value: 3000,
            addressType: AddressType.P2WPKH,
            address: accounts.charlie.p2wpkh.address,
            scriptPk: accounts.charlie.p2wpkh.scriptPubkey.toString('hex'),
          },
        ],
        outputs: [
          {
            address: accounts.charlie.p2wpkh.address,
            value: 1856,
            fixed: true,
          },
        ],
        feeRate: STATIC_FEE_RATE,
        source,
      });

      // Sign & finalize inputs
      psbt.signAllInputs(accounts.charlie.keyPair);
      psbt.finalizeAllInputs();

      expect(psbt.txInputs).toHaveLength(1);
      expect(psbt.txOutputs).toHaveLength(2);
      expectPsbtFeeInRange(psbt, STATIC_FEE_RATE);

      // Broadcast transaction
      // const tx = psbt.extractTransaction();
      // const res = await service.sendBtcTransaction(tx.toHex());
      // console.log(`explorer: https://mempool.space/testnet/tx/${res.txid}`);
    });
    it('Transfer fixed UTXO, sum(ins) > sum(outs), change < fee', async () => {
      const { builder, feeRate, changeIndex } = await createSendUtxosBuilder({
        from: accounts.charlie.p2wpkh.address,
        inputs: [
          {
            txid: '4e1e9f8ff4bf245793c05bf2da58bff812c332a296d93c6935fbc980d906e567',
            vout: 1,
            value: 2000,
            addressType: AddressType.P2WPKH,
            address: accounts.charlie.p2wpkh.address,
            scriptPk: accounts.charlie.p2wpkh.scriptPubkey.toString('hex'),
          },
        ],
        outputs: [
          {
            address: accounts.charlie.p2wpkh.address,
            value: 1000,
            fixed: true,
          },
        ],
        feeRate: STATIC_FEE_RATE,
        source,
      });

      // Sign & finalize inputs
      const psbt = builder.toPsbt();
      psbt.signAllInputs(accounts.charlie.keyPair);
      psbt.finalizeAllInputs();

      expect(psbt.txInputs.length).toBeGreaterThanOrEqual(2);
      expect(psbt.txOutputs).toHaveLength(2);
      expect(changeIndex).toEqual(1);
      expect(feeRate).toEqual(STATIC_FEE_RATE);
      expectPsbtFeeInRange(psbt, feeRate);

      // Broadcast transaction
      // const tx = psbt.extractTransaction();
      // const res = await service.sendBtcTransaction(tx.toHex());
      // console.log(`explorer: https://mempool.space/testnet/tx/${res.txid}`);
    });
    it('Transfer fixed UTXO, sum(ins) > sum(outs), change = fee', async () => {
      const { builder, feeRate, changeIndex } = await createSendUtxosBuilder({
        from: accounts.charlie.p2wpkh.address,
        inputs: [
          {
            txid: '4e1e9f8ff4bf245793c05bf2da58bff812c332a296d93c6935fbc980d906e567',
            vout: 1,
            value: 3000,
            addressType: AddressType.P2WPKH,
            address: accounts.charlie.p2wpkh.address,
            scriptPk: accounts.charlie.p2wpkh.scriptPubkey.toString('hex'),
          },
        ],
        outputs: [
          {
            address: accounts.charlie.p2wpkh.address,
            value: 1859,
            fixed: true,
          },
          {
            address: accounts.charlie.p2wpkh.address,
            value: 1000,
          },
        ],
        feeRate: STATIC_FEE_RATE,
        source,
      });

      // Sign & finalize inputs
      const psbt = builder.toPsbt();
      psbt.signAllInputs(accounts.charlie.keyPair);
      psbt.finalizeAllInputs();

      expect(psbt.txInputs).toHaveLength(1);
      expect(psbt.txOutputs).toHaveLength(2);
      expect(changeIndex).toEqual(-1);
      expect(feeRate).toEqual(STATIC_FEE_RATE);
      expectPsbtFeeInRange(psbt, STATIC_FEE_RATE);

      // Broadcast transaction
      // const tx = psbt.extractTransaction();
      // const res = await service.sendBtcTransaction(tx.toHex());
      // console.log(`explorer: https://mempool.space/testnet/tx/${res.txid}`);
    });

    it('Transfer protected UTXO, sum(ins) = sum(outs)', async () => {
      const psbt = await sendUtxos({
        from: accounts.charlie.p2wpkh.address,
        inputs: [
          {
            txid: '4e1e9f8ff4bf245793c05bf2da58bff812c332a296d93c6935fbc980d906e567',
            vout: 1,
            value: 2000,
            addressType: AddressType.P2WPKH,
            address: accounts.charlie.p2wpkh.address,
            scriptPk: accounts.charlie.p2wpkh.scriptPubkey.toString('hex'),
          },
          {
            txid: '4e1e9f8ff4bf245793c05bf2da58bff812c332a296d93c6935fbc980d906e567',
            vout: 2,
            value: 2000,
            addressType: AddressType.P2WPKH,
            address: accounts.charlie.p2wpkh.address,
            scriptPk: accounts.charlie.p2wpkh.scriptPubkey.toString('hex'),
          },
        ],
        outputs: [
          {
            address: accounts.charlie.p2wpkh.address,
            value: 2000,
            protected: true,
          },
        ],
        feeRate: STATIC_FEE_RATE,
        source,
      });

      // Sign & finalize inputs
      psbt.signAllInputs(accounts.charlie.keyPair);
      psbt.finalizeAllInputs();

      expect(psbt.txInputs).toHaveLength(2);
      expect(psbt.txOutputs).toHaveLength(1);
      expectPsbtFeeInRange(psbt, STATIC_FEE_RATE);

      // Broadcast transaction
      // const tx = psbt.extractTransaction();
      // const res = await service.sendBtcTransaction(tx.toHex());
      // console.log(`explorer: https://mempool.space/testnet/tx/${res.txid}`);
    });
    it('Transfer protected UTXO, sum(ins) < sum(outs)', async () => {
      const psbt = await sendUtxos({
        from: accounts.charlie.p2wpkh.address,
        inputs: [
          {
            txid: '4e1e9f8ff4bf245793c05bf2da58bff812c332a296d93c6935fbc980d906e567',
            vout: 1,
            value: 1000,
            addressType: AddressType.P2WPKH,
            address: accounts.charlie.p2wpkh.address,
            scriptPk: accounts.charlie.p2wpkh.scriptPubkey.toString('hex'),
          },
        ],
        outputs: [
          {
            address: accounts.charlie.p2wpkh.address,
            value: 2000,
            protected: true,
          },
        ],
        feeRate: STATIC_FEE_RATE,
        source,
      });

      // Sign & finalize inputs
      psbt.signAllInputs(accounts.charlie.keyPair);
      psbt.finalizeAllInputs();

      expect(psbt.txInputs.length).toBeGreaterThanOrEqual(2);
      expect(psbt.txOutputs).toHaveLength(1);
      expectPsbtFeeInRange(psbt, STATIC_FEE_RATE);

      // Broadcast transaction
      // const tx = psbt.extractTransaction();
      // const res = await service.sendBtcTransaction(tx.toHex());
      // console.log(`explorer: https://mempool.space/testnet/tx/${res.txid}`);
    });
    it('Transfer protected UTXO, sum(ins) > sum(outs), change > fee', async () => {
      const psbt = await sendUtxos({
        from: accounts.charlie.p2wpkh.address,
        inputs: [
          {
            txid: '4e1e9f8ff4bf245793c05bf2da58bff812c332a296d93c6935fbc980d906e567',
            vout: 1,
            value: 2000,
            addressType: AddressType.P2WPKH,
            address: accounts.charlie.p2wpkh.address,
            scriptPk: accounts.charlie.p2wpkh.scriptPubkey.toString('hex'),
          },
        ],
        outputs: [
          {
            address: accounts.charlie.p2wpkh.address,
            value: 1500,
            protected: true,
          },
        ],
        feeRate: STATIC_FEE_RATE,
        source,
      });

      // Sign & finalize inputs
      psbt.signAllInputs(accounts.charlie.keyPair);
      psbt.finalizeAllInputs();

      expect(psbt.txInputs).toHaveLength(1);
      expect(psbt.txOutputs).toHaveLength(1);
      expectPsbtFeeInRange(psbt, STATIC_FEE_RATE);

      // Broadcast transaction
      // const tx = psbt.extractTransaction();
      // const res = await service.sendBtcTransaction(tx.toHex());
      // console.log(`explorer: https://mempool.space/testnet/tx/${res.txid}`);
    });
    it('Transfer protected UTXO, sum(ins) > sum(outs), change < fee', async () => {
      const { builder, feeRate } = await createSendUtxosBuilder({
        from: accounts.charlie.p2wpkh.address,
        inputs: [
          {
            txid: '4e1e9f8ff4bf245793c05bf2da58bff812c332a296d93c6935fbc980d906e567',
            vout: 1,
            value: 2000,
            addressType: AddressType.P2WPKH,
            address: accounts.charlie.p2wpkh.address,
            scriptPk: accounts.charlie.p2wpkh.scriptPubkey.toString('hex'),
          },
        ],
        outputs: [
          {
            address: accounts.charlie.p2wpkh.address,
            value: 1000,
            protected: true,
          },
        ],
        feeRate: 10,
        source,
      });

      // Sign & finalize inputs
      const psbt = builder.toPsbt();
      psbt.signAllInputs(accounts.charlie.keyPair);
      psbt.finalizeAllInputs();

      expect(psbt.txInputs.length).toBeGreaterThanOrEqual(2);
      expect(psbt.txOutputs).toHaveLength(1);
      expect(feeRate).toEqual(10);
      expectPsbtFeeInRange(psbt, feeRate);

      // Broadcast transaction
      // const tx = psbt.extractTransaction();
      // const res = await service.sendBtcTransaction(tx.toHex());
      // console.log(`explorer: https://mempool.space/testnet/tx/${res.txid}`);
    });

    it('Transfer protected UTXO, change to the first address-matched output', async () => {
      const { builder, changeIndex } = await createSendUtxosBuilder({
        from: accounts.charlie.p2wpkh.address,
        inputs: [
          {
            txid: '4e1e9f8ff4bf245793c05bf2da58bff812c332a296d93c6935fbc980d906e567',
            vout: 1,
            value: 10000,
            addressType: AddressType.P2WPKH,
            address: accounts.charlie.p2wpkh.address,
            scriptPk: accounts.charlie.p2wpkh.scriptPubkey.toString('hex'),
          },
        ],
        outputs: [
          {
            address: accounts.charlie.p2tr.address,
            value: 1000,
            protected: true,
          },
          {
            address: accounts.charlie.p2wpkh.address,
            value: 1000,
            protected: true,
          },
        ],
        feeRate: STATIC_FEE_RATE,
        source,
      });

      // Sign & finalize inputs
      const psbt = builder.toPsbt();
      psbt.signAllInputs(accounts.charlie.keyPair);
      psbt.finalizeAllInputs();

      expect(changeIndex).toEqual(1);
      expect(psbt.txInputs).toHaveLength(1);
      expect(psbt.txOutputs).toHaveLength(2);
      expectPsbtFeeInRange(psbt, STATIC_FEE_RATE);

      // Broadcast transaction
      // const tx = psbt.extractTransaction();
      // const res = await service.sendBtcTransaction(tx.toHex());
      // console.log(`explorer: https://mempool.space/testnet/tx/${res.txid}`);
    });
    it('Transfer mixed UTXO, change to the first non-fixed output', async () => {
      const { builder, changeIndex } = await createSendUtxosBuilder({
        from: accounts.charlie.p2wpkh.address,
        inputs: [
          {
            txid: '4e1e9f8ff4bf245793c05bf2da58bff812c332a296d93c6935fbc980d906e567',
            vout: 1,
            value: 10000,
            addressType: AddressType.P2WPKH,
            address: accounts.charlie.p2wpkh.address,
            scriptPk: accounts.charlie.p2wpkh.scriptPubkey.toString('hex'),
          },
        ],
        outputs: [
          {
            address: accounts.charlie.p2wpkh.address,
            value: 1000,
            fixed: true,
          },
          {
            address: accounts.charlie.p2wpkh.address,
            value: 1000,
            protected: true,
          },
        ],
        feeRate: STATIC_FEE_RATE,
        source,
      });

      // Sign & finalize inputs
      const psbt = builder.toPsbt();
      psbt.signAllInputs(accounts.charlie.keyPair);
      psbt.finalizeAllInputs();

      expect(changeIndex).toEqual(1);
      expect(psbt.txInputs).toHaveLength(1);
      expect(psbt.txOutputs).toHaveLength(2);
      expectPsbtFeeInRange(psbt, STATIC_FEE_RATE);

      // Broadcast transaction
      // const tx = psbt.extractTransaction();
      // const res = await service.sendBtcTransaction(tx.toHex());
      // console.log(`explorer: https://mempool.space/testnet/tx/${res.txid}`);
    });

    it('Transfer protected RGBPP_UTXOs, sum(ins) = sum(outs)', async () => {
      const psbt = await sendUtxos({
        from: accounts.charlie.p2wpkh.address,
        inputs: [
          {
            txid: '4e1e9f8ff4bf245793c05bf2da58bff812c332a296d93c6935fbc980d906e567',
            vout: 1,
            value: RGBPP_UTXO_DUST_LIMIT,
            addressType: AddressType.P2WPKH,
            address: accounts.charlie.p2wpkh.address,
            scriptPk: accounts.charlie.p2wpkh.scriptPubkey.toString('hex'),
          },
          {
            txid: '4e1e9f8ff4bf245793c05bf2da58bff812c332a296d93c6935fbc980d906e567',
            vout: 2,
            value: RGBPP_UTXO_DUST_LIMIT,
            addressType: AddressType.P2WPKH,
            address: accounts.charlie.p2wpkh.address,
            scriptPk: accounts.charlie.p2wpkh.scriptPubkey.toString('hex'),
          },
        ],
        outputs: [
          {
            address: accounts.charlie.p2wpkh.address,
            minUtxoSatoshi: RGBPP_UTXO_DUST_LIMIT,
            value: RGBPP_UTXO_DUST_LIMIT,
            protected: true,
          },
          {
            address: accounts.charlie.p2wpkh.address,
            minUtxoSatoshi: RGBPP_UTXO_DUST_LIMIT,
            value: RGBPP_UTXO_DUST_LIMIT,
            protected: true,
          },
        ],
        feeRate: STATIC_FEE_RATE,
        source,
      });

      // Sign & finalize inputs
      psbt.signAllInputs(accounts.charlie.keyPair);
      psbt.finalizeAllInputs();

      expect(psbt.txInputs.length).toBeGreaterThanOrEqual(3);
      expect(psbt.txOutputs).toHaveLength(2);
      expect(psbt.txOutputs[0].value).toBeGreaterThan(RGBPP_UTXO_DUST_LIMIT);
      expect(psbt.txOutputs[1].value).toBe(RGBPP_UTXO_DUST_LIMIT);

      expectPsbtFeeInRange(psbt, STATIC_FEE_RATE);

      // Broadcast transaction
      // const tx = psbt.extractTransaction();
      // const res = await service.sendBtcTransaction(tx.toHex());
      // console.log(`explorer: https://mempool.space/testnet/tx/${res.txid}`);
    });
    it('Transfer protected RGBPP_UTXOs, each has free satoshi', async () => {
      const psbt = await sendUtxos({
        from: accounts.charlie.p2wpkh.address,
        inputs: [
          {
            txid: '4e1e9f8ff4bf245793c05bf2da58bff812c332a296d93c6935fbc980d906e567',
            vout: 1,
            value: (RGBPP_UTXO_DUST_LIMIT + 100) * 3,
            addressType: AddressType.P2WPKH,
            address: accounts.charlie.p2wpkh.address,
            scriptPk: accounts.charlie.p2wpkh.scriptPubkey.toString('hex'),
          },
        ],
        outputs: [
          {
            address: accounts.charlie.p2wpkh.address,
            minUtxoSatoshi: RGBPP_UTXO_DUST_LIMIT,
            value: RGBPP_UTXO_DUST_LIMIT + 100,
            protected: true,
          },
          {
            address: accounts.charlie.p2wpkh.address,
            minUtxoSatoshi: RGBPP_UTXO_DUST_LIMIT,
            value: RGBPP_UTXO_DUST_LIMIT + 100,
            protected: true,
          },
          {
            address: accounts.charlie.p2wpkh.address,
            minUtxoSatoshi: RGBPP_UTXO_DUST_LIMIT,
            value: RGBPP_UTXO_DUST_LIMIT + 100,
            protected: true,
          },
        ],
        feeRate: STATIC_FEE_RATE,
        source,
      });

      // Sign & finalize inputs
      psbt.signAllInputs(accounts.charlie.keyPair);
      psbt.finalizeAllInputs();

      expect(psbt.txInputs).toHaveLength(1);
      expect(psbt.txOutputs).toHaveLength(3);
      expect(psbt.txOutputs[0].value).toBeLessThan(psbt.txOutputs[1].value);
      expect(psbt.txOutputs[1].value).toBeLessThan(psbt.txOutputs[2].value);

      expectPsbtFeeInRange(psbt, STATIC_FEE_RATE);

      // Broadcast transaction
      // const tx = psbt.extractTransaction();
      // const res = await service.sendBtcTransaction(tx.toHex());
      // console.log(`explorer: https://mempool.space/testnet/tx/${res.txid}`);
    });
    it('Transfer protected RGBPP_UTXOs, with insufficient free satoshi', async () => {
      const psbt = await sendUtxos({
        from: accounts.charlie.p2wpkh.address,
        inputs: [
          {
            txid: '4e1e9f8ff4bf245793c05bf2da58bff812c332a296d93c6935fbc980d906e567',
            vout: 1,
            value: RGBPP_UTXO_DUST_LIMIT * 2 + 100,
            addressType: AddressType.P2WPKH,
            address: accounts.charlie.p2wpkh.address,
            scriptPk: accounts.charlie.p2wpkh.scriptPubkey.toString('hex'),
          },
        ],
        outputs: [
          {
            address: accounts.charlie.p2wpkh.address,
            minUtxoSatoshi: RGBPP_UTXO_DUST_LIMIT,
            value: RGBPP_UTXO_DUST_LIMIT + 100,
            protected: true,
          },
          {
            address: accounts.charlie.p2wpkh.address,
            minUtxoSatoshi: RGBPP_UTXO_DUST_LIMIT,
            value: RGBPP_UTXO_DUST_LIMIT,
            protected: true,
          },
        ],
        feeRate: STATIC_FEE_RATE,
        source,
      });

      // Sign & finalize inputs
      psbt.signAllInputs(accounts.charlie.keyPair);
      psbt.finalizeAllInputs();

      expect(psbt.txInputs.length).toBeGreaterThanOrEqual(2);
      expect(psbt.txOutputs).toHaveLength(2);
      expect(psbt.txOutputs[0].value).toBeGreaterThan(RGBPP_UTXO_DUST_LIMIT);
      expect(psbt.txOutputs[1].value).toBe(RGBPP_UTXO_DUST_LIMIT);

      expectPsbtFeeInRange(psbt, STATIC_FEE_RATE);

      // Broadcast transaction
      // const tx = psbt.extractTransaction();
      // const res = await service.sendBtcTransaction(tx.toHex());
      // console.log(`explorer: https://mempool.space/testnet/tx/${res.txid}`);
    });

    it('Transfer P2TR, pay fee with P2WPKH', async () => {
      const p2trUtxos = await source.getUtxos(accounts.charlie.p2tr.address, {
        min_satoshi: BTC_UTXO_DUST_LIMIT,
        only_confirmed: true,
      });

      const psbt = await sendUtxos({
        inputs: [p2trUtxos[0]],
        outputs: [
          {
            address: accounts.charlie.p2tr.address,
            value: p2trUtxos[0].value,
            fixed: true,
          },
        ],
        from: accounts.charlie.p2wpkh.address,
        feeRate: STATIC_FEE_RATE,
        pubkeyMap: {
          [accounts.charlie.p2tr.address]: accounts.charlie.publicKey,
        },
        source,
      });

      // Sign & finalize inputs
      await signAndBroadcastPsbt({
        psbt,
        account: accounts.charlie,
        feeRate: STATIC_FEE_RATE,
        send: false,
      });
    });
    it('Transfer P2WPKH, pay fee with P2TR', async () => {
      const p2wpkhUtxos = await source.getUtxos(accounts.charlie.p2wpkh.address, {
        min_satoshi: BTC_UTXO_DUST_LIMIT,
        only_confirmed: true,
      });

      const psbt = await sendUtxos({
        inputs: [p2wpkhUtxos[0]],
        outputs: [
          {
            address: accounts.charlie.p2wpkh.address,
            value: p2wpkhUtxos[0].value,
            fixed: true,
          },
        ],
        from: accounts.charlie.p2tr.address,
        fromPubkey: accounts.charlie.publicKey,
        feeRate: STATIC_FEE_RATE,
        source,
      });

      // Sign & finalize inputs
      await signAndBroadcastPsbt({
        psbt,
        account: accounts.charlie,
        feeRate: STATIC_FEE_RATE,
        send: false,
      });
    });
    it('Try mixed transfer, without pubkeyMap', async () => {
      const p2trUtxos = await source.getUtxos(accounts.charlie.p2tr.address, {
        min_satoshi: BTC_UTXO_DUST_LIMIT,
        only_confirmed: true,
      });

      await expect(() =>
        sendUtxos({
          inputs: [p2trUtxos[0]],
          outputs: [
            {
              address: accounts.charlie.p2tr.address,
              value: p2trUtxos[0].value,
              fixed: true,
            },
          ],
          from: accounts.charlie.p2wpkh.address,
          feeRate: STATIC_FEE_RATE,
          source,
        }),
      ).rejects.toHaveProperty('code', ErrorCodes.MISSING_PUBKEY);
    });
    it('Try mixed transfer, pay fee with P2TR without fromPubkey', async () => {
      const p2wpkhUtxos = await source.getUtxos(accounts.charlie.p2wpkh.address, {
        min_satoshi: BTC_UTXO_DUST_LIMIT,
        only_confirmed: true,
      });

      await expect(() =>
        sendUtxos({
          inputs: [p2wpkhUtxos[0]],
          outputs: [
            {
              address: accounts.charlie.p2wpkh.address,
              value: p2wpkhUtxos[0].value,
              fixed: true,
            },
          ],
          from: accounts.charlie.p2tr.address,
          feeRate: STATIC_FEE_RATE,
          source,
        }),
      ).rejects.toHaveProperty('code', ErrorCodes.MISSING_PUBKEY);
    });

    it('Try transfer non-existence UTXO', async () => {
      await expect(() =>
        sendUtxos({
          from: accounts.charlie.p2wpkh.address,
          inputs: [
            {
              txid: '00'.repeat(32),
              vout: 0,
              value: 1000,
              addressType: AddressType.P2WPKH,
              address: accounts.charlie.p2wpkh.address,
              scriptPk: accounts.charlie.p2wpkh.scriptPubkey.toString('hex'),
            },
          ],
          outputs: [
            {
              address: accounts.charlie.p2wpkh.address,
              value: 1000,
            },
          ],
          onlyConfirmedUtxos: true,
          feeRate: STATIC_FEE_RATE,
          source,
        }),
      ).rejects.toThrow();
    });
  });

  describe.skip('sendRbf()', () => {
    it('Full RBF', async () => {
      /**
       * TX_1, feeRate=minimumFee/2
       */
      const feeRates = await service.getBtcRecommendedFeeRates();
      const expectFeeRate = Math.max(Math.round(feeRates.minimumFee / 2), 1);
      const psbt = await sendBtc({
        from: accounts.charlie.p2wpkh.address,
        tos: [
          {
            address: accounts.charlie.p2wpkh.address,
            value: BTC_UTXO_DUST_LIMIT,
          },
        ],
        feeRate: expectFeeRate,
        source,
      });
      const { txHex } = await signAndBroadcastPsbt({
        psbt,
        account: accounts.charlie,
        feeRate: expectFeeRate,
      });

      /**
       * Wait for 2 seconds
       */
      await waitFor(2000);
      console.log('---');

      /**
       * TX_2, feeRate=fastestFee
       */
      const expectFeeRate2 = Math.max(feeRates.fastestFee, expectFeeRate + 1);
      const psbt2 = await sendRbf({
        txHex: txHex,
        from: accounts.charlie.p2wpkh.address,
        feeRate: expectFeeRate2,
        source,
      });
      await signAndBroadcastPsbt({
        psbt: psbt2,
        account: accounts.charlie,
        feeRate: expectFeeRate2,
      });
    }, 0);
    it('Full RBF with changeIndex', async () => {
      /**
       * TX_1, feeRate=1
       */
      const feeRates = await service.getBtcRecommendedFeeRates();
      const expectFeeRate = Math.max(Math.round(feeRates.minimumFee / 2), 1);
      const psbt = await sendBtc({
        from: accounts.charlie.p2wpkh.address,
        tos: [
          {
            address: accounts.charlie.p2wpkh.address,
            value: BTC_UTXO_DUST_LIMIT,
          },
        ],
        feeRate: expectFeeRate,
        source,
      });
      const { tx, txHex } = await signAndBroadcastPsbt({
        psbt,
        account: accounts.charlie,
        feeRate: expectFeeRate,
      });

      /**
       * Wait for 2 seconds
       */
      await waitFor(2000);
      console.log('---');

      /**
       * TX_2, feeRate=fastestFee
       */
      const expectFeeRate2 = Math.max(feeRates.fastestFee, expectFeeRate + 1);
      const changeIndex = tx.outs.length - 1;
      const psbt2 = await sendRbf({
        txHex: txHex,
        from: accounts.charlie.p2wpkh.address,
        feeRate: expectFeeRate2,
        changeIndex,
        source,
      });
      await signAndBroadcastPsbt({
        psbt: psbt2,
        account: accounts.charlie,
        feeRate: expectFeeRate2,
      });
    }, 0);
    it('Full RBF with changeIndex, outputs.length == 1', async () => {
      /**
       * TX_1, feeRate=1
       */
      const feeRates = await service.getBtcRecommendedFeeRates();
      const expectFeeRate = Math.max(Math.round(feeRates.minimumFee / 2), 1);
      const psbt = await sendBtc({
        from: accounts.charlie.p2wpkh.address,
        tos: [
          {
            address: accounts.charlie.p2wpkh.address,
            value: BTC_UTXO_DUST_LIMIT,
            protected: true,
            fixed: false,
          },
        ],
        feeRate: expectFeeRate,
        source,
      });
      const { tx, txHex } = await signAndBroadcastPsbt({
        psbt,
        account: accounts.charlie,
        feeRate: expectFeeRate,
      });

      console.log(tx.outs);

      /**
       * Wait for 2 seconds
       */
      await waitFor(2000);
      console.log('---');

      /**
       * TX_2, feeRate=fastestFee
       */
      const expectFeeRate2 = Math.max(feeRates.fastestFee, expectFeeRate + 1);
      const changeIndex = tx.outs.length - 1;
      const psbt2 = await sendRbf({
        txHex: txHex,
        from: accounts.charlie.p2wpkh.address,
        feeRate: expectFeeRate2,
        changeIndex,
        source,
      });
      await signAndBroadcastPsbt({
        psbt: psbt2,
        account: accounts.charlie,
        feeRate: expectFeeRate2,
      });
    }, 0);
    it('Full RBF with changeIndex, outputs.length != changeIndex + 1', async () => {
      /**
       * TX_1, feeRate=1
       */
      const feeRates = await service.getBtcRecommendedFeeRates();
      const expectFeeRate = Math.max(Math.round(feeRates.minimumFee / 2), 1);
      const psbt = await sendBtc({
        from: accounts.charlie.p2wpkh.address,
        tos: [
          {
            address: accounts.charlie.p2wpkh.address,
            value: 3000,
          },
        ],
        feeRate: expectFeeRate,
        source,
      });
      const { txHex } = await signAndBroadcastPsbt({
        psbt,
        account: accounts.charlie,
        feeRate: expectFeeRate,
      });

      /**
       * Wait for 2 seconds
       */
      await waitFor(2000);
      console.log('---');

      /**
       * TX_2, feeRate=fastestFee
       */
      const expectFeeRate2 = Math.max(feeRates.fastestFee, expectFeeRate + 1);
      const psbt2 = await sendRbf({
        txHex: txHex,
        from: accounts.charlie.p2wpkh.address,
        feeRate: expectFeeRate2,
        changeIndex: 0,
        source,
      });
      await signAndBroadcastPsbt({
        psbt: psbt2,
        account: accounts.charlie,
        feeRate: expectFeeRate2,
      });
    }, 0);
    it('Try Full RBF with invalid change', async () => {
      /**
       * TX_1, feeRate=1
       */
      const expectFeeRate = 1;
      const psbt = await sendBtc({
        from: accounts.charlie.p2wpkh.address,
        tos: [
          {
            data: Buffer.from('hello'),
            value: 0,
          },
          {
            address: accounts.charlie.p2tr.address,
            value: BTC_UTXO_DUST_LIMIT,
          },
        ],
        feeRate: expectFeeRate,
        source,
      });
      const { tx, txHex } = await signAndBroadcastPsbt({
        psbt,
        account: accounts.charlie,
        feeRate: expectFeeRate,
      });

      /**
       * Wait for 2 seconds
       */
      console.log('---');
      await waitFor(2000);
      const expectFeeRate2 = expectFeeRate * 2;

      /**
       * TX_2, outputs[changeIndex] == undefined
       */
      await expect(() =>
        sendRbf({
          txHex: txHex,
          from: accounts.charlie.p2wpkh.address,
          changeAddress: accounts.charlie.p2tr.address,
          feeRate: expectFeeRate2,
          changeIndex: 3,
          source,
        }),
      ).rejects.toHaveProperty('code', ErrorCodes.INVALID_CHANGE_OUTPUT);
      /**
       * TX_3, changeOutput is not returnable
       */
      await expect(() =>
        sendRbf({
          txHex: txHex,
          from: accounts.charlie.p2wpkh.address,
          feeRate: expectFeeRate2,
          changeIndex: 0,
          source,
        }),
      ).rejects.toHaveProperty('code', ErrorCodes.INVALID_CHANGE_OUTPUT);
      /**
       * TX_4, changeAddress !== changeOutputAddress
       */
      await expect(() =>
        sendRbf({
          txHex: txHex,
          from: accounts.charlie.p2wpkh.address,
          changeAddress: accounts.charlie.p2tr.address,
          changeIndex: tx.outs.length - 1,
          feeRate: expectFeeRate2,
          source,
        }),
      ).rejects.toHaveProperty('code', ErrorCodes.INVALID_CHANGE_OUTPUT);
    }, 0);
    it('Try Full RBF with invalid feeRate', async () => {
      /**
       * TX_1, feeRate=1
       */
      const expectFeeRate = 1;
      const psbt = await sendBtc({
        from: accounts.charlie.p2wpkh.address,
        tos: [
          {
            address: accounts.charlie.p2wpkh.address,
            value: BTC_UTXO_DUST_LIMIT,
          },
        ],
        feeRate: expectFeeRate,
        source,
      });
      const { txHex } = await signAndBroadcastPsbt({
        psbt,
        account: accounts.charlie,
        feeRate: expectFeeRate,
      });

      /**
       * Wait for 2 seconds
       */
      await waitFor(2000);
      console.log('---');

      /**
       * TX_2, feeRate=1
       */
      await expect(
        await sendRbf({
          txHex: txHex,
          from: accounts.charlie.p2wpkh.address,
          feeRate: expectFeeRate,
          source,
        }),
      ).rejects.toHaveProperty('code', ErrorCodes.INVALID_FEE_RATE);
    }, 0);
  });

  describe.todo('sendRgbppUtxos()', () => {
    // TODO: fill tests
  });
});


================================================
File: packages/btc/tests/Utils.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { bitcoin, decodeUtxoId, encodeUtxoId, transactionToHex } from '../src';

describe('Utils', () => {
  it('transactionToHex()', () => {
    const originalHex =
      '02000000000101177e673414fb4a393f0e1faf27a317d92e9f1a7b9a3ff36713d46ef5b7a1a6190100000000ffffffff020000000000000000226a20849f5b17209de17af5a94f0111e2ba03d1409da87a0f06894abb85b3b5024726df3c0f000000000016001462fc12a35b779f0cf7edcb9690be19b0386e0f9a024830450221009d869f20ef22864e02603571ce40da0586c03f20f5b8fb6295a4d636141d39dc02207082fdef40b34f6189491cba98c861ddfc8889d91c48f11f4660f11e93b1153b012103e1c38cf06691d449961d2b8f261a9a238c53da91d3a1e948497f7b1fe717968000000000';
    const tx = bitcoin.Transaction.fromHex(originalHex);

    const defaultHex = tx.toHex();
    const hexWithWitnesses = transactionToHex(tx, true);
    const hexWithoutWitnesses = transactionToHex(tx, false);

    expect(defaultHex).toEqual(originalHex);
    expect(defaultHex).toEqual(hexWithWitnesses);

    expect(hexWithoutWitnesses.length).toBeLessThan(hexWithWitnesses.length);
    expect(hexWithoutWitnesses).toEqual(
      '0200000001177e673414fb4a393f0e1faf27a317d92e9f1a7b9a3ff36713d46ef5b7a1a6190100000000ffffffff020000000000000000226a20849f5b17209de17af5a94f0111e2ba03d1409da87a0f06894abb85b3b5024726df3c0f000000000016001462fc12a35b779f0cf7edcb9690be19b0386e0f9a00000000',
    );
  });
  it('encodeUtxoId()', () => {
    expect(encodeUtxoId('0da44932270292fd3a4165f1f7ab81abf69b951e1e7d3b5c012e00a291c6b222', 0)).toEqual(
      '0da44932270292fd3a4165f1f7ab81abf69b951e1e7d3b5c012e00a291c6b222:0',
    );
    expect(encodeUtxoId('0x0da44932270292fd3a4165f1f7ab81abf69b951e1e7d3b5c012e00a291c6b222', 0)).toEqual(
      '0da44932270292fd3a4165f1f7ab81abf69b951e1e7d3b5c012e00a291c6b222:0',
    );
    expect(encodeUtxoId('0x0da44932270292fd3a4165f1f7ab81abf69b951e1e7d3b5c012e00a291c6b222', 0xffffffff)).toEqual(
      '0da44932270292fd3a4165f1f7ab81abf69b951e1e7d3b5c012e00a291c6b222:4294967295',
    );
    expect(() => encodeUtxoId('0da44932270292fd3a4165f1f7ab81abf69b951e1e7d3b5c012e00a291c6b22', 0)).toThrowError();
    expect(() =>
      encodeUtxoId('0da44932270292fd3a4165f1f7ab81abf69b951e1e7d3b5c012e00a291c6b222', 0xffffffff01),
    ).toThrowError();
  });
  it('decodeUtxoId()', () => {
    expect(decodeUtxoId('0da44932270292fd3a4165f1f7ab81abf69b951e1e7d3b5c012e00a291c6b222:0')).toStrictEqual({
      txid: '0da44932270292fd3a4165f1f7ab81abf69b951e1e7d3b5c012e00a291c6b222',
      vout: 0,
    });
    expect(decodeUtxoId('0da44932270292fd3a4165f1f7ab81abf69b951e1e7d3b5c012e00a291c6b222:4294967295')).toStrictEqual({
      txid: '0da44932270292fd3a4165f1f7ab81abf69b951e1e7d3b5c012e00a291c6b222',
      vout: 4294967295,
    });

    expect(() => decodeUtxoId('0x0da44932270292fd3a4165f1f7ab81abf69b951e1e7d3b5c012e00a291c6b222:0')).toThrowError();
    expect(() =>
      decodeUtxoId('0x0da44932270292fd3a4165f1f7ab81abf69b951e1e7d3b5c012e00a291c6b222:42949672951'),
    ).toThrowError();
  });
});


================================================
File: packages/btc/tests/shared/env.ts
================================================
import { BtcAssetsApi } from '@rgbpp-sdk/service';
import { DataSource, NetworkType, networkTypeToConfig } from '../../src';
import { createAccount } from './utils';

export const networkType = NetworkType.TESTNET;
export const config = networkTypeToConfig(networkType);
export const network = config.network;

export const service = BtcAssetsApi.fromToken(
  process.env.VITE_BTC_SERVICE_URL!,
  process.env.VITE_BTC_SERVICE_TOKEN!,
  process.env.VITE_BTC_SERVICE_ORIGIN!,
);

export const source = new DataSource(service, networkType);

export const accounts = {
  charlie: createAccount({
    privateKey: '8d3c23d340ac0841e6c3b58a9bbccb9a28e94ab444f972cff35736fa2fcf9f3f',
    network,
  }),
};


================================================
File: packages/btc/tests/shared/utils.ts
================================================
import { expect } from 'vitest';
import { ECPairInterface } from 'ecpair';
import { NetworkType, bitcoin, ECPair } from '../../src';
import { toXOnly, remove0x, tweakSigner, isP2trScript, isP2wpkhScript } from '../../src';
import { config, network, networkType, service } from './env';

/**
 * Wait for a number of milliseconds.
 */
export function waitFor(ms: number) {
  return new Promise<void>((resolve) => setTimeout(resolve, ms));
}

/**
 * Estimate a network fee of a PSBT.
 */
export function calculatePsbtFee(psbt: bitcoin.Psbt, feeRate?: number) {
  if (!feeRate) {
    feeRate = config.feeRate;
  }

  const tx = psbt.extractTransaction(false);
  const virtualSize = tx.virtualSize();
  return Math.ceil(virtualSize * feeRate);
}

/**
 * Expect the paid fee of the PSBT to be in ±1 range of the estimated fee.
 */
export function expectPsbtFeeInRange(psbt: bitcoin.Psbt, feeRate?: number) {
  const estimated = calculatePsbtFee(psbt, feeRate);
  const paid = psbt.getFee();

  console.log('fee rate:', psbt.getFeeRate(), 'expected:', feeRate ?? config.feeRate);
  console.log('fee:', paid, 'expected:', estimated);

  const inputs = psbt.data.inputs.length;
  const diff = paid - estimated;

  expect(diff).toBeGreaterThanOrEqual(0);
  expect(diff).toBeLessThanOrEqual(diff + inputs);
}

/**
 * Report transaction info in log
 */
export function logTransaction(tx: bitcoin.Transaction, networkType: NetworkType) {
  const id = tx.getId();
  const hex = tx.toHex();
  const url = networkType === NetworkType.MAINNET ? 'https://mempool.space/tx' : 'https://mempool.space/testnet/tx';

  console.log('id:', id);
  console.log('hex:', hex);
  console.log('explorer:', `${url}/${id}`);
}

/**
 * Create accounts in tests for signing transactions
 */
export interface Account {
  keyPair: ECPairInterface;
  privateKey: Buffer;
  publicKey: string;
  p2wpkh: {
    scriptPubkey: Buffer;
    address: string;
    pubkey: Buffer;
    data: Buffer[];
  };
  p2tr: {
    scriptPubkey: Buffer;
    address: string;
    pubkey: Buffer;
    data: Buffer[];
  };
}
export function createAccount(props: { privateKey: string; network?: bitcoin.Network }): Account {
  const privateKey = Buffer.from(remove0x(props.privateKey), 'hex');
  const keyPair = ECPair.fromPrivateKey(privateKey, {
    network: props.network,
  });

  const p2wpkh = bitcoin.payments.p2wpkh({
    pubkey: keyPair.publicKey,
    network: props.network,
  });
  const p2tr = bitcoin.payments.p2tr({
    internalPubkey: toXOnly(keyPair.publicKey),
    network: props.network,
  });

  return {
    keyPair,
    privateKey,
    publicKey: keyPair.publicKey.toString('hex'),
    p2wpkh: {
      scriptPubkey: p2wpkh.output!,
      address: p2wpkh.address!,
      pubkey: p2wpkh.pubkey!,
      data: p2wpkh.data!,
    },
    p2tr: {
      scriptPubkey: p2tr.output!,
      address: p2tr.address!,
      pubkey: p2tr.pubkey!,
      data: p2tr.data!,
    },
  };
}

/**
 * Sign a PSBT with one or multiple BtcAccounts
 */
export function signPsbt(props: {
  psbt: bitcoin.Psbt;
  account: Account | Account[];
  finalizeInputs?: boolean;
}): bitcoin.Psbt {
  const accounts = Array.isArray(props.account) ? props.account : [props.account];

  const psbt = props.psbt;
  for (const account of accounts) {
    // Create a tweaked signer for P2TR
    const tweakedSigner = tweakSigner(account.keyPair, { network });

    // Sign each input
    psbt.data.inputs.forEach((input, index) => {
      if (input.witnessUtxo) {
        const script = input.witnessUtxo.script.toString('hex');
        if (isP2wpkhScript(script) && script === account.p2wpkh.scriptPubkey.toString('hex')) {
          psbt.signInput(index, account.keyPair);
        }
        if (isP2trScript(script) && script === account.p2tr.scriptPubkey.toString('hex')) {
          psbt.signInput(index, tweakedSigner);
        }
      }
    });
  }

  if (props.finalizeInputs) {
    psbt.finalizeAllInputs();
  }

  return psbt;
}

/**
 * Sign and broadcast a PSBT to the service
 */
export async function signAndBroadcastPsbt(props: {
  psbt: bitcoin.Psbt;
  account: Account | Account[];
  feeRate?: number;
  send?: boolean;
}): Promise<{
  tx: bitcoin.Transaction;
  txId: string;
  txHex: string;
}> {
  const { psbt, account, feeRate, send = true } = props;

  // Sign inputs
  signPsbt({
    psbt,
    account,
    finalizeInputs: true,
  });

  expectPsbtFeeInRange(psbt, feeRate);

  const tx = psbt.extractTransaction();
  logTransaction(tx, networkType);

  if (send) {
    const res = await service.sendBtcTransaction(tx.toHex());
    expect(res.txid).toEqual(tx.getId());
  }

  return {
    tx,
    txId: tx.getId(),
    txHex: tx.toHex(),
  };
}


================================================
File: packages/ckb/README.md
================================================
# @rgbpp-sdk/ckb

RGB++ CKB SDK

## Installation

```
$ npm i @rgbpp-sdk/ckb
# or
$ yarn add @rgbpp-sdk/ckb
# or
$ pnpm add @rgbpp-sdk/ckb
```

## Split paymaster cells

The `example/paymaster.ts` demonstrates how to use `@rgbpp-sdk/ckb` SDK to split multiple cells and you can set the parameters as blow:

- `receiverAddress`: The receiver ckb address
- `capacityWithCKB`: The capacity(unit is CKB) of each cell, for example: 316CKB
- `cellAmount`: The amount of cells to be split

```bash
cd packages/ckb && pnpm splitCells
```

## RGB++ xUDT Transfer on BTC

The method `genBtcTransferCkbVirtualTx` can generate a CKB virtual transaction which contains the necessary `inputCells/outputCells` for RGB++ xUDT transfer and the commitment to be inserted to the BTC tx OP_RETURN.

```TypeScript
export interface BtcTransferVirtualTxResult {
  // CKB raw transaction
  ckbRawTx: CKBComponents.RawTransaction;
  // The rgbpp commitment to be inserted into BTC op_return
  commitment: Hex;
  // The needPaymasterCell indicates whether a paymaster cell is required
  needPaymasterCell: boolean;
  // The sum capacity of the ckb inputs
  sumInputsCapacity: Hex;
}

/**
 * Generate the virtual ckb transaction for the btc transfer tx
 * @param collector The collector that collects CKB live cells and transactions
 * @param xudtTypeBytes The serialized hex string of the XUDT type script
 * @param rgbppLockArgsList The rgbpp assets cell lock script args array whose data structure is: out_index | bitcoin_tx_id
 * @param transferAmount The XUDT amount to be transferred, if the noMergeOutputCells is true, the transferAmount will be ignored
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)
 * @param witnessLockPlaceholderSize(Optional) The WitnessArgs.lock placeholder bytes array size and the default value is 5000
 * @param noMergeOutputCells(Optional) The noMergeOutputCells indicates whether the CKB outputs need to be merged. By default, the outputs will be merged.
 * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100
 * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
 */
export const genBtcTransferCkbVirtualTx = async ({
  collector,
  xudtTypeBytes,
  rgbppLockArgsList,
  transferAmount,
  isMainnet,
  witnessLockPlaceholderSize,
  noMergeOutputCells,
  ckbFeeRate,
  btcTestnetType
}: BtcTransferVirtualTxParams): Promise<BtcTransferVirtualTxResult>
```

## RGB++ xUDT Leap from BTC to CKB

The method `genBtcJumpCkbVirtualTx` can generate a CKB virtual transaction which contains the necessary `inputCells/outputCells` for RGB++ xUDT leaping from BTC to CKB and the commitment to be inserted to the BTC tx OP_RETURN.

```TypeScript
interface BtcJumpCkbVirtualTxResult {
  // CKB raw transaction
  ckbRawTx: CKBComponents.RawTransaction;
  // The rgbpp commitment to be inserted into BTC op_return
  commitment: Hex;
  // The needPaymasterCell indicates whether a paymaster cell is required
  needPaymasterCell: boolean;
  // The sum capacity of the ckb inputs
  sumInputsCapacity: Hex;
}
/**
 * Generate the virtual ckb transaction for the jumping tx from BTC to CKB
 * @param collector The collector that collects CKB live cells and transactions
 * @param xudtTypeBytes The serialized hex string of the XUDT type script
 * @param rgbppLockArgsList The rgbpp assets cell lock script args array whose data structure is: out_index | bitcoin_tx_id
 * @param transferAmount The XUDT amount to be transferred
 * @param witnessLockPlaceholderSize(Optional) The WitnessArgs.lock placeholder bytes array size and the default value is 5000
 * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100
 * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
 */
export const genBtcJumpCkbVirtualTx = async ({
  collector,
  xudtTypeBytes,
  rgbppLockArgsList,
  transferAmount,
  toCkbAddress,
  witnessLockPlaceholderSize,
  ckbFeeRate,
  btcTestnetType
}: BtcJumpCkbVirtualTxParams): Promise<BtcJumpCkbVirtualTxResult>
```

## RGB++ xUDT Leap from CKB to BTC

The method `genCkbJumpBtcVirtualTx` can generate a CKB transaction for RGB++ xUDT leaping from CKB to BTC

```TypeScript
/**
 * Generate the virtual ckb transaction for the jumping tx from CKB to BTC
 * @param collector The collector that collects CKB live cells and transactions
 * @param xudtTypeBytes The serialized hex string of the XUDT type script
 * @param fromCkbAddress The from ckb address who will use his private key to sign the ckb tx
 * @param toRgbppLockArgs The receiver rgbpp lock script args whose data structure is: out_index | bitcoin_tx_id
 * @param transferAmount The XUDT amount to be transferred
 * @param witnessLockPlaceholderSize(Optional) The WitnessArgs.lock placeholder bytes array size and the default value is 5000
 * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100
 * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
 */
export const genCkbJumpBtcVirtualTx = async ({
  collector,
  xudtTypeBytes,
  fromCkbAddress,
  toRgbppLockArgs,
  transferAmount,
  witnessLockPlaceholderSize,
  ckbFeeRate,
}: CkbJumpBtcVirtualTxParams): Promise<CKBComponents.RawTransaction>
```

## RGB++ Spore Creation on BTC

The method `genCreateSporeCkbVirtualTx` can generate a CKB virtual transaction which contains the necessary `inputCells/outputCells` for RGB++ Spore creation and the commitment to be inserted to the BTC tx OP_RETURN.

```TypeScript
export interface SporeCreateVirtualTxResult {
  // CKB raw transaction
  ckbRawTx: CKBComponents.RawTransaction;
  // The rgbpp commitment to be inserted into BTC op_return
  commitment: Hex;
  // The sum capacity of the ckb inputs
  sumInputsCapacity: Hex;
  // The cluster cell from ckb-indexer
  clusterCell: IndexerCell;
}

/**
 * Generate the virtual ckb transaction for creating spores
 * @param collector The collector that collects CKB live cells and transactions
 * @param clusterRgbppLockArgs The cluster rgbpp cell lock script args whose data structure is: out_index | bitcoin_tx_id
 * @param sporeDataList The spore's data list, including name and description.
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)
 * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
 */
export const genCreateSporeCkbVirtualTx = async ({
  collector,
  clusterRgbppLockArgs,
  sporeDataList,
  isMainnet,
  btcTestnetType,
}: CreateSporeCkbVirtualTxParams): Promise<SporeCreateVirtualTxResult>
```

## RGB++ Spore Transfer on BTC

The method `genTransferSporeCkbVirtualTx` can generate a CKB virtual transaction which contains the necessary `inputCells/outputCells` for RGB++ Spore creation and the commitment to be inserted to the BTC tx OP_RETURN.

```TypeScript
export interface SporeTransferVirtualTxResult {
  // CKB raw transaction
  ckbRawTx: CKBComponents.RawTransaction;
  // The rgbpp commitment to be inserted into BTC op_return
  commitment: Hex;
  // The spore cell from ckb-indexer
  sporeCell: IndexerCell;
  // The needPaymasterCell indicates whether a paymaster cell is required
  needPaymasterCell: boolean;
  // The sum capacity of the ckb inputs
  sumInputsCapacity: Hex;
}

/**
 * Generate the virtual ckb transaction for transferring spore
 * @param collector The collector that collects CKB live cells and transactions
 * @param sporeRgbppLockArgs The spore rgbpp cell lock script args whose data structure is: out_index | bitcoin_tx_id
 * @param sporeTypeBytes The spore type script serialized bytes
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)
 * @param witnessLockPlaceholderSize(Optional) The WitnessArgs.lock placeholder bytes array size and the default value is 5000
 * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100
 * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
 */
export const genTransferSporeCkbVirtualTx = async ({
  collector,
  sporeRgbppLockArgs,
  sporeTypeBytes,
  isMainnet,
  witnessLockPlaceholderSize,
  ckbFeeRate,
  btcTestnetType
}: TransferSporeCkbVirtualTxParams): Promise<SporeTransferVirtualTxResult>
```

## RGB++ Spore Leap from BTC to CKB

The method `genBtcJumpCkbVirtualTx` can generate a CKB virtual transaction which contains the necessary `inputCells/outputCells` for RGB++ Spore leaping from BTC to CKB and the commitment to be inserted to the BTC tx OP_RETURN.

```TypeScript
export interface SporeLeapVirtualTxResult {
  // CKB raw transaction
  ckbRawTx: CKBComponents.RawTransaction;
  // The rgbpp commitment to be inserted into BTC op_return
  commitment: Hex;
  // The spore cell from ckb-indexer
  sporeCell: IndexerCell;
  // The needPaymasterCell indicates whether a paymaster cell is required
  needPaymasterCell: boolean;
  // The sum capacity of the ckb inputs
  sumInputsCapacity: Hex;
}

/**
 * Generate the virtual ckb transaction for leaping spore from BTC to CKB
 * @param collector The collector that collects CKB live cells and transactions
 * @param sporeRgbppLockArgs The spore rgbpp cell lock script args whose data structure is: out_index | bitcoin_tx_id
 * @param sporeTypeBytes The spore type script serialized bytes
 * @param toCkbAddress The receiver ckb address
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)
 * @param witnessLockPlaceholderSize(Optional) The WitnessArgs.lock placeholder bytes array size and the default value is 5000
 * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100
 * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
 */
export const genLeapSporeFromBtcToCkbVirtualTx = async ({
  collector,
  sporeRgbppLockArgs,
  sporeTypeBytes,
  toCkbAddress,
  isMainnet,
  witnessLockPlaceholderSize,
  ckbFeeRate,
  btcTestnetType
}: LeapSporeFromBtcToCkbVirtualTxParams): Promise<SporeLeapVirtualTxResult>
```

## RGB++ Spore Leap from CKB to BTC

The method `genLeapSporeFromCkbToBtcRawTx` can generate a CKB transaction for RGB++ Spore leaping from CKB to BTC

```TypeScript
/**
 * Generate the virtual ckb transaction for leaping spore from CKB to BTC
 * @param collector The collector that collects CKB live cells and transactions
 * @param sporeRgbppLockArgs The spore rgbpp cell lock script args whose data structure is: out_index | bitcoin_tx_id
 * @param sporeTypeBytes The spore type script serialized bytes
 * @param toCkbAddress The receiver ckb address
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet
 * @param witnessLockPlaceholderSize(Optional) The WitnessArgs.lock placeholder bytes array size and the default value is 5000
 * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100
 * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet
 */
export const genLeapSporeFromCkbToBtcRawTx = async ({
  collector,
  sporeTypeBytes,
  fromCkbAddress,
  toRgbppLockArgs,
  isMainnet,
  witnessLockPlaceholderSize,
  ckbFeeRate,
}: LeapSporeFromCkbToBtcVirtualTxParams): Promise<CKBComponents.RawTransaction>
```


================================================
File: packages/ckb/CHANGELOG.md
================================================
# @rgbpp-sdk/ckb

## 0.7.0

### Minor Changes

- [#291](https://github.com/utxostack/rgbpp-sdk/pull/291): Support RGB++ compatible xUDT assets([@duanyytop](https://github.com/duanyytop))
  - Fetch compatible xUDT `cellDeps` to build CKB transactions from the `typeid-contract-cell-deps` GitHub repository
  - Update the `ckb` package to support RGB++ compatible xUDT assets leaping and transferring
  - Add optional parameter `compatibleXudtTypeScript` to the functions of the `rgbpp` package to transfer RGB++ compatible xUDT assets
  - Add RGB++ compatible xUDT assets leaping and transferring examples
  - Add RGB++ compatible xUDT assets integration tests

- [#293](https://github.com/utxostack/rgbpp-sdk/pull/293): Add offline btc data source & ckb collector ([@fghdotio](https://github.com/fghdotio))

- [#294](https://github.com/utxostack/rgbpp-sdk/pull/294): Add UTXOAirdropBadge Testnet deployment information ([@duanyytop](https://github.com/duanyytop))
  - Add UTXOAirdropBadge and metadata Testnet deployment information
  - Fetch UTXOAirdropBadge and metadata Testnet deployment information from GitHub and Vercel server
  - Add `isUtxoAirdropBadgeType` and `isTokenMetadataType` for `btc-assets-api` to encode the token information and metadata of the UTXOAirdropBadge

- [#297](https://github.com/utxostack/rgbpp-sdk/pull/297): Add USDI to compatible xUDT list ([@duanyytop](https://github.com/duanyytop))
  - Fetch and cache compatible xUDT list from Vercel or GitHub server
  - Use local static compatible xUDT list when the cache is empty
  - Remove jsdelivr CDN because CDN cache time is too long, causing UTXO Airdrop cellDeps to become outdated

- [#302](https://github.com/utxostack/rgbpp-sdk/pull/302): Encapsulate transaction fee supplementation methods ([@fghdotio](https://github.com/fghdotio))
  - `appendIssuerCellToBtcBatchTransferToSign` for supplementing fees in RGB++ xUDT transactions
  - `prepareBtcTimeCellSpentUnsignedTx` for BTC timelock unlock transaction building and fee supplementation
  - `appendIssuerCellToSporesCreateUnsignedTx` for supplementing fees in Spores creation transactions

- [#303](https://github.com/utxostack/rgbpp-sdk/pull/303): Add offline mode support for compatible xUDT type scripts ([@fghdotio](https://github.com/fghdotio))
  - Introduce an optional `offline` boolean parameter to the following methods:
    - `isUDTTypeSupported`
    - `isCompatibleUDTTypesSupported`
    - `CompatibleXUDTRegistry.getCompatibleTokens`
  - Add examples demonstrating compatible xUDT asset management in offline mode

- [#304](https://github.com/utxostack/rgbpp-sdk/pull/304): Remove duplicate cell deps ([@duanyytop](https://github.com/duanyytop))

### Patch Changes

- [#305](https://github.com/ckb-cell/rgbpp-sdk/pull/305): Upgrade ckb-sdk-js version ([@duanyytop](https://github.com/duanyytop))

## 0.6.0

### Minor Changes

- [#281](https://github.com/ckb-cell/rgbpp-sdk/pull/281): Upgrade ckb-sdk-js to fix esm and commonjs issues ([@duanyytop](https://github.com/duanyytop))

- [#246](https://github.com/ckb-cell/rgbpp-sdk/pull/246): Export ESM packages ([@duanyytop](https://github.com/duanyytop))

- [#270](https://github.com/ckb-cell/rgbpp-sdk/pull/270): Support for batch transferring of RGBPP XUDT assets ([@ShookLyngs](https://github.com/ShookLyngs))

  - Add `buildRgbppTransferAllTxs()` API in the rgbpp lib for generating one or more BTC/CKB transaction groups for transferring the entire amount of a specific type of RGBPP XUDT asset from one or more BTC addresses to a recipient
  - Add `sendRgbppTxGroups()` API in the rgbpp lib for sending BTC/CKB transaction groups to the `BtcAssetsApi`
  - Add `unpackRgbppLockArgs()` API in the ckb lib for unpacking the lock script args of an RGBPP Cell
  - Add `encodeCellId()` and `decodeCellId()` APIs in the ckb lib for handling the ID of a CKB Cell
  - Add `encodeUtxoId()` and `decodeUtxoId()` APIs in the btc lib for handling the ID of a BTC UTXO

### Patch Changes

- [#279](https://github.com/ckb-cell/rgbpp-sdk/pull/279): fix: Update molecule codegen, packing and unpacking ([@duanyytop](https://github.com/duanyytop))

  - Generate molecule code with latest lumos/molecule
  - Update RGB++ witness and BTC time lock args packing and unpacking

- Updated dependencies [[`82d37ab`](https://github.com/ckb-cell/rgbpp-sdk/commit/82d37ab56fc2c2c1dd0437f44966380bae6c9b42), [`a2722c5`](https://github.com/ckb-cell/rgbpp-sdk/commit/a2722c535efa04c9a9a8147228c82957fe33143d)]:
  - @rgbpp-sdk/service@0.6.0

## v0.5.0

### Minor Changes

- [#258](https://github.com/ckb-cell/rgbpp-sdk/pull/258): Support for arbitrary btc confirmation blocks to unlock btc time cells([@duanyytop](https://github.com/duanyytop))

- [#263](https://github.com/ckb-cell/rgbpp-sdk/pull/263): Remove 1CKB from BTC time cell capacity([@duanyytop](https://github.com/duanyytop))

### Patch Changes

- Updated dependencies [[`9afc2a9`](https://github.com/ckb-cell/rgbpp-sdk/commit/9afc2a911e6a4ba8a200755b01159b5b149e4010)]:
  - @rgbpp-sdk/service@0.5.0

## v0.4.0

### Minor Changes

- [#236](https://github.com/ckb-cell/rgbpp-sdk/pull/236): Fix typo and remove useless queue types ([@duanyytop](https://github.com/duanyytop))

### Patch Changes

- Updated dependencies [[`e5f41fd`](https://github.com/ckb-cell/rgbpp-sdk/commit/e5f41fd2b275182d2ab3fdf17e3b8853025fd2b9)]:
  - @rgbpp-sdk/service@0.4.0

## v0.3.0

### Minor Changes

- [#197](https://github.com/ckb-cell/rgbpp-sdk/pull/197): Return needPaymasterCell for RGB++ ckb cirtual tx ([@duanyytop](https://github.com/duanyytop))

- [#191](https://github.com/ckb-cell/rgbpp-sdk/pull/191): Dynamic fetching cell deps deployed by TypeID ([@duanyytop](https://github.com/duanyytop))

### Patch Changes

- [#212](https://github.com/ckb-cell/rgbpp-sdk/pull/212): Fix the XUDT cell data unpacking logic to load only the first 16 bytes ([@ShookLyngs](https://github.com/ShookLyngs))

- Updated dependencies [[`4f05b1b`](https://github.com/ckb-cell/rgbpp-sdk/commit/4f05b1bba898b7acb58bdf20ae275164ad94523b)]:
  - @rgbpp-sdk/service@0.3.0

## v0.2.0

### Minor Changes

- [#179](https://github.com/ckb-cell/rgbpp-sdk/pull/179): Increase the max length of RGB++ inputs to 40 ([@duanyytop](https://github.com/duanyytop))

- [#160](https://github.com/ckb-cell/rgbpp-sdk/pull/160): Collect all RGB++ inputs without isMax parameter ([@duanyytop](https://github.com/duanyytop))

- [#190](https://github.com/ckb-cell/rgbpp-sdk/pull/190): Filter xudt cell whose amount is valid for collector ([@duanyytop](https://github.com/duanyytop))

- [#172](https://github.com/ckb-cell/rgbpp-sdk/pull/172): Check spore type script for spore transfer and leap ([@duanyytop](https://github.com/duanyytop))

- [#171](https://github.com/ckb-cell/rgbpp-sdk/pull/171): Build ckb raw tx to be signed for spores creation ([@duanyytop](https://github.com/duanyytop))

- [#174](https://github.com/ckb-cell/rgbpp-sdk/pull/174): Update ckb cell fields size to make the code more readable ([@duanyytop](https://github.com/duanyytop))

- [#187](https://github.com/ckb-cell/rgbpp-sdk/pull/187): Update RRB++ witnesses for BTC batch transfer TX ([@duanyytop](https://github.com/duanyytop))

### Patch Changes

- Updated dependencies [[`9f9daa9`](https://github.com/ckb-cell/rgbpp-sdk/commit/9f9daa91486ca0cc1015713bd2648aa606da8717), [`e59322e`](https://github.com/ckb-cell/rgbpp-sdk/commit/e59322e7c6b9aff682bc1c8517337e3611dc122d)]:
  - @rgbpp-sdk/service@0.2.0

## v0.1.0

- Release @rgbpp-sdk/ckb for RGBPP CKB-side transaction construction, providing APIs to bind/transfer/leap assets on CKB/BTC. Read the docs for more information: https://github.com/ckb-cell/rgbpp-sdk/tree/develop/packages/ckb


================================================
File: packages/ckb/package.json
================================================
{
  "name": "@rgbpp-sdk/ckb",
  "version": "0.6.0",
  "scripts": {
    "test": "vitest",
    "build": "tsup",
    "lint": "tsc && eslint --ext .ts {src,example}/* && prettier --check '{src,example}/**/*.{js,ts}'",
    "lint:fix": "tsc && eslint --fix --ext .ts {src,example}/* && prettier --write '{src,example}/**/*.{js,ts}'",
    "splitCells": "npx tsx example/paymaster.ts"
  },
  "sideEffects": false,
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "import": {
        "types": "./dist/index.d.mts",
        "default": "./dist/index.mjs"
      },
      "require": {
        "types": "./dist/index.d.ts",
        "default": "./dist/index.js"
      }
    },
    "./package.json": "./package.json"
  },
  "files": [
    "src",
    "dist"
  ],
  "dependencies": {
    "@ckb-lumos/base": "^0.22.2",
    "@ckb-lumos/codec": "^0.22.2",
    "@spore-sdk/core": "^0.2.0-beta.6",
    "@nervosnetwork/ckb-sdk-core": "0.109.5",
    "@nervosnetwork/ckb-sdk-utils": "0.109.5",
    "@nervosnetwork/ckb-types": "0.109.5",
    "@rgbpp-sdk/service": "workspace:^",
    "@exact-realty/multipart-parser": "^1.0.13",
    "axios": "^1.7.4",
    "camelcase-keys": "^7.0.2",
    "js-sha256": "^0.11.0"
  },
  "devDependencies": {
    "@ckb-lumos/molecule": "0.0.0-canary-66bbbfd-20240805132534"
  },
  "publishConfig": {
    "access": "public"
  }
}


================================================
File: packages/ckb/tsconfig.json
================================================
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "compilerOptions": {
    "moduleResolution": "Bundler",
    "module": "ESNext",
    "target": "ESNext",
    "lib": ["ESNext", "DOM"],
    "strict": true,
    "noEmit": true,
    "allowJs": true,
    "sourceMap": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "strictNullChecks": true,
    "resolveJsonModule": true,
    "isolatedModules": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist", "**/*.spec.ts", "example"],
}


================================================
File: packages/ckb/tsup.config.ts
================================================
import { defineConfig } from 'tsup';

export default defineConfig({
  name: '@rgbpp-sdk/ckb',
  dts: true,
  clean: true,
  sourcemap: true,
  format: ['esm', 'cjs'],
  entry: ['src/index.ts'],
});


================================================
File: packages/ckb/example/launch.ts
================================================
import { AddressPrefix, privateKeyToAddress, serializeScript } from '@nervosnetwork/ckb-sdk-utils';
import { genCkbJumpBtcVirtualTx } from '../src/rgbpp';
import { Collector } from '../src/collector';
import { u32ToLe } from '../src/utils';
import { getSecp256k1CellDep } from '../src/constants';

// SECP256K1 private key
const LAUNCH_SECP256K1_PRIVATE_KEY = '0x0000000000000000000000000000000000000000000000000000000000000001';

const launchRgbppAsset = async () => {
  const collector = new Collector({
    ckbNodeUrl: 'https://testnet.ckb.dev/rpc',
    ckbIndexerUrl: 'https://testnet.ckb.dev/indexer',
  });
  const address = privateKeyToAddress(LAUNCH_SECP256K1_PRIVATE_KEY, { prefix: AddressPrefix.Testnet });
  console.log('master address: ', address);

  // TODO: Use real btc utxo information
  const outIndex = 1;
  const btcTxId = '47448104a611ecb16ab8d8e500b2166689612c93fc7ef18783d8189f3079f447';
  const toRgbppLockArgs = `0x${u32ToLe(outIndex)}${btcTxId}`;

  // TODO: Use real XUDT type script
  const xudtType: CKBComponents.Script = {
    codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
    hashType: 'type',
    args: '0xaafd7e7eab79726c669d7565888b194dc06bd1dbec16749a721462151e4f1762',
  };

  const ckbRawTx = await genCkbJumpBtcVirtualTx({
    collector,
    fromCkbAddress: address,
    toRgbppLockArgs,
    xudtTypeBytes: serializeScript(xudtType),
    transferAmount: BigInt(200_0000_0000),
  });

  const emptyWitness = { lock: '', inputType: '', outputType: '' };
  const unsignedTx: CKBComponents.RawTransactionToSign = {
    ...ckbRawTx,
    cellDeps: [...ckbRawTx.cellDeps, getSecp256k1CellDep(false)],
    witnesses: [emptyWitness, ...ckbRawTx.witnesses.slice(1)],
  };

  const signedTx = collector.getCkb().signTransaction(LAUNCH_SECP256K1_PRIVATE_KEY)(unsignedTx);

  const txHash = await collector.getCkb().rpc.sendTransaction(signedTx, 'passthrough');
  console.info(`Rgbpp asset has been jumping from CKB to BTC and tx hash is ${txHash}`);
};

launchRgbppAsset();


================================================
File: packages/ckb/example/paymaster.ts
================================================
import { AddressPrefix, privateKeyToAddress } from '@nervosnetwork/ckb-sdk-utils';
import { splitMultiCellsWithSecp256k1 } from '../src/paymaster';
import { Collector } from '../src/collector';

// SECP256K1 private key
const MASTER_SECP256K1_PRIVATE_KEY = '0x0000000000000000000000000000000000000000000000000000000000000001';
const RECEIVER_ADDRESS =
  'ckt1qrfrwcdnvssswdwpn3s9v8fp87emat306ctjwsm3nmlkjg8qyza2cqgqqxqyukftmpfang0z2ks6w6syjutass94fujlf09a';

const splitPaymasterCells = async () => {
  const collector = new Collector({
    ckbNodeUrl: 'https://testnet.ckb.dev/rpc',
    ckbIndexerUrl: 'https://testnet.ckb.dev/indexer',
  });
  const address = privateKeyToAddress(MASTER_SECP256K1_PRIVATE_KEY, { prefix: AddressPrefix.Testnet });
  console.log('master address: ', address);

  // Split 200 cells whose capacity are 316CKB for the receiver address
  await splitMultiCellsWithSecp256k1({
    masterPrivateKey: MASTER_SECP256K1_PRIVATE_KEY,
    collector,
    receiverAddress: RECEIVER_ADDRESS,
    capacityWithCKB: 316,
    cellAmount: 200,
  });
};

splitPaymasterCells();


================================================
File: packages/ckb/src/index.ts
================================================
export * from './schemas/generated/blockchain';
export * from './schemas/generated/rgbpp';
export * from './collector';
export * from './collector/offline';
export * from './error';
export * from './paymaster';
export * from './types';
export * from './rgbpp';
export * from './utils';
export * from './constants';
export * from './spore';


================================================
File: packages/ckb/src/collector/collector.spec.ts
================================================
import { describe, it, expect } from 'vitest';
import { Collector } from '.';

describe('collector', () => {
  const collector = new Collector({
    ckbNodeUrl: 'https://testnet.ckb.dev/rpc',
    ckbIndexerUrl: 'https://testnet.ckb.dev/indexer',
  });

  it('getLiveCell', async () => {
    const cell = await collector.getLiveCell({
      txHash: '0x8f8c79eb6671709633fe6a46de93c0fedc9c1b8a6527a18d3983879542635c9f',
      index: '0x0',
    });
    expect(cell.output.lock.codeHash).toBe('0x0000000000000000000000000000000000000000000000000000000000000000');
  });

  it('getLiveCells', async () => {
    const [cell1, cell2] = await collector.getLiveCells([
      //  Genesis block
      { txHash: '0x8f8c79eb6671709633fe6a46de93c0fedc9c1b8a6527a18d3983879542635c9f', index: '0x0' },
      // Nervos DAO
      { txHash: '0x8277d74d33850581f8d843613ded0c2a1722dec0e87e748f45c115dfb14210f1', index: '0x0' },
    ]);
    expect(cell1.output.lock.codeHash).toBe('0x0000000000000000000000000000000000000000000000000000000000000000');
    expect(cell2.output.type?.codeHash).toBe('0x82d76d1b75fe2fd9a27dfbaa65a039221a380d76c926f378d3f81cf3e7e13f2e');
  });
});


================================================
File: packages/ckb/src/collector/index.ts
================================================
import axios from 'axios';
import CKB from '@nervosnetwork/ckb-sdk-core';
import { CollectConfig, CollectResult, CollectUdtResult, IndexerCell } from '../types/collector';
import { MIN_CAPACITY } from '../constants';
import { CapacityNotEnoughError, IndexerError, UdtAmountNotEnoughError } from '../error';
import { isRgbppLockCellIgnoreChain, leToU128, remove0x, toCamelcase } from '../utils';
import { Hex } from '../types';

interface IndexerScript {
  code_hash: Hex;
  hash_type: Hex;
  args: Hex;
}

interface IndexerSearchKey {
  script?: IndexerScript;
  script_type?: 'lock' | 'type';
  script_search_mode?: 'prefix' | 'exact';
  filter?: {
    script?: IndexerScript;
    script_len_range?: Hex[];
    output_data_len_range?: Hex[];
    output_capacity_range?: Hex[];
    block_range?: Hex[];
  };
  with_data?: boolean;
}

const parseScript = (script: CKBComponents.Script): IndexerScript => ({
  code_hash: script.codeHash,
  hash_type: script.hashType,
  args: script.args,
});

export class Collector {
  private ckbNodeUrl: string;
  private ckbIndexerUrl: string;

  constructor({ ckbNodeUrl, ckbIndexerUrl }: { ckbNodeUrl: string; ckbIndexerUrl: string }) {
    this.ckbNodeUrl = ckbNodeUrl;
    this.ckbIndexerUrl = ckbIndexerUrl;
  }

  getCkb() {
    return new CKB(this.ckbNodeUrl);
  }

  async getCells({
    lock,
    type,
    isDataMustBeEmpty = true,
    outputCapacityRange,
  }: {
    lock?: CKBComponents.Script;
    type?: CKBComponents.Script;
    isDataMustBeEmpty?: boolean;
    outputCapacityRange?: Hex[];
  }): Promise<IndexerCell[]> {
    let searchKey: IndexerSearchKey = {};
    if (lock) {
      searchKey = {
        script_search_mode: 'exact',
        script: parseScript(lock),
        script_type: 'lock',
        filter: {
          script: type ? parseScript(type) : undefined,
          output_data_len_range: isDataMustBeEmpty && !type ? ['0x0', '0x1'] : undefined,
          output_capacity_range: outputCapacityRange,
        },
      };
    } else if (type) {
      searchKey = {
        script_search_mode: 'exact',
        script: parseScript(type),
        script_type: 'type',
      };
    }
    const payload = {
      id: Math.floor(Math.random() * 100000),
      jsonrpc: '2.0',
      method: 'get_cells',
      params: [searchKey, 'asc', '0x3E8'],
    };
    const body = JSON.stringify(payload, null, '  ');
    const response = (
      await axios({
        method: 'post',
        url: this.ckbIndexerUrl,
        headers: {
          'Content-Type': 'application/json',
        },
        timeout: 20000,
        data: body,
      })
    ).data;
    if (response.error) {
      console.error(response.error);
      throw new IndexerError('Get cells from indexer error');
    } else {
      const res = toCamelcase<IndexerCell[]>(response.result.objects);
      if (res === null) {
        throw new IndexerError('The response of indexer RPC get_cells is invalid');
      }
      return res;
    }
  }

  collectInputs(liveCells: IndexerCell[], needCapacity: bigint, fee: bigint, config?: CollectConfig): CollectResult {
    const changeCapacity = config?.minCapacity ?? MIN_CAPACITY;
    const inputs: CKBComponents.CellInput[] = [];
    let sumInputsCapacity = BigInt(0);
    const isRgbppLock = liveCells.length > 0 && isRgbppLockCellIgnoreChain(liveCells[0].output);
    for (const cell of liveCells) {
      inputs.push({
        previousOutput: {
          txHash: cell.outPoint.txHash,
          index: cell.outPoint.index,
        },
        since: '0x0',
      });
      sumInputsCapacity += BigInt(cell.output.capacity);
      if (sumInputsCapacity >= needCapacity + changeCapacity + fee && !isRgbppLock) {
        break;
      }
    }
    if (sumInputsCapacity < needCapacity + changeCapacity + fee) {
      const message = config?.errMsg ?? 'Insufficient free CKB balance';
      throw new CapacityNotEnoughError(message);
    }
    return { inputs, sumInputsCapacity };
  }

  collectUdtInputs({ liveCells, needAmount }: { liveCells: IndexerCell[]; needAmount: bigint }): CollectUdtResult {
    const inputs: CKBComponents.CellInput[] = [];
    let sumInputsCapacity = BigInt(0);
    let sumAmount = BigInt(0);
    const isRgbppLock = liveCells.length > 0 && isRgbppLockCellIgnoreChain(liveCells[0].output);
    for (const cell of liveCells) {
      if (cell.outputData === '0x') {
        continue;
      }
      inputs.push({
        previousOutput: {
          txHash: cell.outPoint.txHash,
          index: cell.outPoint.index,
        },
        since: '0x0',
      });
      sumInputsCapacity = sumInputsCapacity + BigInt(cell.output.capacity);
      // XUDT cell.data = <amount: uint128> <xudt data (optional)>
      // Ref: https://blog.cryptape.com/enhance-sudts-programmability-with-xudt#heading-xudt-cell
      sumAmount += leToU128(remove0x(cell.outputData).slice(0, 32));
      if (sumAmount >= needAmount && !isRgbppLock) {
        break;
      }
    }
    if (sumAmount < needAmount) {
      throw new UdtAmountNotEnoughError('Insufficient UDT balance');
    }
    return { inputs, sumInputsCapacity, sumAmount };
  }

  async getLiveCell(outPoint: CKBComponents.OutPoint, withData = true): Promise<CKBComponents.LiveCell> {
    const ckb = new CKB(this.ckbNodeUrl);
    const { cell } = await ckb.rpc.getLiveCell(outPoint, withData);
    return cell;
  }

  async getLiveCells(outPoints: CKBComponents.OutPoint[], withData = false): Promise<CKBComponents.LiveCell[]> {
    const ckb = new CKB(this.ckbNodeUrl);
    const batch = ckb.rpc.createBatchRequest(outPoints.map((outPoint) => ['getLiveCell', outPoint, withData]));
    return batch.exec().then((liveCells) => liveCells.map((liveCell) => liveCell.cell));
  }
}


================================================
File: packages/ckb/src/collector/offline.ts
================================================
import { IndexerCell } from '../types/collector';
import { Collector } from './index';
import { isScriptEqual } from '../utils/ckb-tx';
import { Hex } from '../types';

export class OfflineCollector extends Collector {
  private cells: IndexerCell[];

  constructor(cells: IndexerCell[]) {
    super({ ckbNodeUrl: '', ckbIndexerUrl: '' });
    this.cells = cells;
  }

  getCkb(): never {
    throw new Error('OfflineCollector does not have a CKB instance');
  }

  async getCells({
    lock,
    type,
    isDataMustBeEmpty = true,
    outputCapacityRange,
  }: {
    lock?: CKBComponents.Script;
    type?: CKBComponents.Script;
    isDataMustBeEmpty?: boolean;
    outputCapacityRange?: Hex[];
  }): Promise<IndexerCell[]> {
    let cells: IndexerCell[] = [];

    if (lock) {
      cells = this.cells.filter((cell) => {
        if (type) {
          return isScriptEqual(cell.output.lock, lock) && cell.output.type && isScriptEqual(cell.output.type, type);
        }
        return isScriptEqual(cell.output.lock, lock);
      });
    } else if (type) {
      cells = this.cells.filter((cell) => {
        if (!cell.output.type) {
          return false;
        }
        return isScriptEqual(cell.output.type, type);
      });
    }

    if (isDataMustBeEmpty && !type) {
      cells = cells.filter((cell) => cell.outputData === '0x' || cell.outputData === '');
    }

    if (outputCapacityRange) {
      if (outputCapacityRange.length === 2) {
        cells = cells.filter((cell) => {
          const capacity = BigInt(cell.output.capacity);
          return capacity >= BigInt(outputCapacityRange[0]) && capacity < BigInt(outputCapacityRange[1]);
        });
      } else {
        throw new Error('Invalid output capacity range');
      }
    }

    return cells.map((cell) => ({
      blockNumber: cell.blockNumber,
      outPoint: cell.outPoint,
      output: cell.output,
      outputData: cell.outputData,
      txIndex: cell.txIndex,
    }));
  }

  // https://github.com/nervosnetwork/ckb/blob/master/rpc/README.md#method-get_live_cell
  async getLiveCell(outPoint: CKBComponents.OutPoint, withData = true): Promise<CKBComponents.LiveCell> {
    const cell = this.cells.find((cell) => {
      return outPoint.txHash === cell.outPoint.txHash && outPoint.index === cell.outPoint.index;
    });
    if (!cell) {
      throw new Error(
        `Cell corresponding to the outPoint: {txHash: ${outPoint.txHash}, index: ${outPoint.index}} not found`,
      );
    }

    return {
      output: cell.output,
      data: withData
        ? {
            content: cell.outputData,
            hash: '', // not used, leave it empty for now
          }
        : undefined,
    };
  }

  async getLiveCells(outPoints: CKBComponents.OutPoint[], withData = false): Promise<CKBComponents.LiveCell[]> {
    return Promise.all(outPoints.map((outPoint) => this.getLiveCell(outPoint, withData)));
  }
}


================================================
File: packages/ckb/src/constants/index.ts
================================================
import { BTCTestnetType } from '../types';

export const CKB_UNIT = BigInt(10000_0000);
export const MAX_FEE = BigInt(2000_0000);
export const MIN_CAPACITY = BigInt(61) * BigInt(10000_0000);
export const SECP256K1_WITNESS_LOCK_SIZE = 65;
export const BTC_JUMP_CONFIRMATION_BLOCKS = 6;
export const RGBPP_TX_WITNESS_MAX_SIZE = 5000;
export const RGBPP_TX_INPUTS_MAX_LENGTH = 40;

export const RGBPP_WITNESS_PLACEHOLDER = '0xFF';
export const RGBPP_TX_ID_PLACEHOLDER = '0000000000000000000000000000000000000000000000000000000000000000';

const TestnetInfo = {
  Secp256k1LockDep: {
    outPoint: {
      txHash: '0xf8de3bb47d055cdf460d93a2a6e1b05f7432f9777c8c474abf4eec1d4aee5d37',
      index: '0x0',
    },
    depType: 'depGroup',
  } as CKBComponents.CellDep,

  RgbppLockScript: {
    codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
    hashType: 'type',
    args: '',
  } as CKBComponents.Script,

  RgbppLockDep: {
    outPoint: { txHash: '0xf1de59e973b85791ec32debbba08dff80c63197e895eb95d67fc1e9f6b413e00', index: '0x0' },
    depType: 'code',
  } as CKBComponents.CellDep,

  RgbppLockConfigDep: {
    outPoint: { txHash: '0xf1de59e973b85791ec32debbba08dff80c63197e895eb95d67fc1e9f6b413e00', index: '0x1' },
    depType: 'code',
  } as CKBComponents.CellDep,

  BtcTimeLockScript: {
    codeHash: '0x00cdf8fab0f8ac638758ebf5ea5e4052b1d71e8a77b9f43139718621f6849326',
    hashType: 'type',
    args: '',
  } as CKBComponents.Script,

  BtcTimeLockDep: {
    outPoint: { txHash: '0xde0f87878a97500f549418e5d46d2f7704c565a262aa17036c9c1c13ad638529', index: '0x0' },
    depType: 'code',
  } as CKBComponents.CellDep,

  BtcTimeLockConfigDep: {
    outPoint: { txHash: '0xde0f87878a97500f549418e5d46d2f7704c565a262aa17036c9c1c13ad638529', index: '0x1' },
    depType: 'code',
  } as CKBComponents.CellDep,

  XUDTTypeScript: {
    codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
    hashType: 'type',
    args: '',
  } as CKBComponents.Script,

  XUDTTypeDep: {
    outPoint: {
      txHash: '0xbf6fb538763efec2a70a6a3dcb7242787087e1030c4e7d86585bc63a9d337f5f',
      index: '0x0',
    },
    depType: 'code',
  } as CKBComponents.CellDep,

  UniqueTypeScript: {
    codeHash: '0x8e341bcfec6393dcd41e635733ff2dca00a6af546949f70c57a706c0f344df8b',
    hashType: 'type',
    args: '',
  } as CKBComponents.Script,

  UniqueTypeDep: {
    outPoint: {
      txHash: '0xff91b063c78ed06f10a1ed436122bd7d671f9a72ef5f5fa28d05252c17cf4cef',
      index: '0x0',
    },
    depType: 'code',
  } as CKBComponents.CellDep,

  ClusterTypeScript: {
    codeHash: '0x0bbe768b519d8ea7b96d58f1182eb7e6ef96c541fbd9526975077ee09f049058',
    hashType: 'data1',
    args: '',
  } as CKBComponents.Script,

  ClusterTypeDep: {
    outPoint: {
      txHash: '0xcebb174d6e300e26074aea2f5dbd7f694bb4fe3de52b6dfe205e54f90164510a',
      index: '0x0',
    },
    depType: 'code',
  } as CKBComponents.CellDep,

  SporeTypeScript: {
    codeHash: '0x685a60219309029d01310311dba953d67029170ca4848a4ff638e57002130a0d',
    hashType: 'data1',
    args: '',
  } as CKBComponents.Script,

  SporeTypeDep: {
    outPoint: {
      txHash: '0x5e8d2a517d50fd4bb4d01737a7952a1f1d35c8afc77240695bb569cd7d9d5a1f',
      index: '0x0',
    },
    depType: 'code',
  } as CKBComponents.CellDep,

  // The CKB testnet RGB++ deployment information for the BTC Signet network
  RgbppSignetLockScript: {
    codeHash: '0xd07598deec7ce7b5665310386b4abd06a6d48843e953c5cc2112ad0d5a220364',
    hashType: 'type',
    args: '',
  } as CKBComponents.Script,

  RgbppSignetLockDep: {
    outPoint: { txHash: '0x61efdeddbaa0bb4132c0eb174b3e8002ff5ec430f61ba46f30768d683c516eec', index: '0x0' },
    depType: 'code',
  } as CKBComponents.CellDep,

  RgbppSignetLockConfigDep: {
    outPoint: { txHash: '0x61efdeddbaa0bb4132c0eb174b3e8002ff5ec430f61ba46f30768d683c516eec', index: '0x1' },
    depType: 'code',
  } as CKBComponents.CellDep,

  BtcTimeSignetLockScript: {
    codeHash: '0x80a09eca26d77cea1f5a69471c59481be7404febf40ee90f886c36a948385b55',
    hashType: 'type',
    args: '',
  } as CKBComponents.Script,

  BtcTimeSignetLockDep: {
    outPoint: { txHash: '0x5364b3535965e9eac9a35dd7af8e9e45a61d30a16e115923c032f80b28783e21', index: '0x0' },
    depType: 'code',
  } as CKBComponents.CellDep,

  BtcTimeSignetLockConfigDep: {
    outPoint: { txHash: '0x5364b3535965e9eac9a35dd7af8e9e45a61d30a16e115923c032f80b28783e21', index: '0x1' },
    depType: 'code',
  } as CKBComponents.CellDep,

  UtxoAirdropBadgeTypeScript: {
    codeHash: '0xf5da9003e31fa9301a3915fe304de9bdb80524b5f0d8fc325fb699317998ee7a',
    hashType: 'type',
    args: '',
  } as CKBComponents.Script,

  UtxoAirdropBadgeTypeDep: {
    outPoint: { txHash: '0xbbbb73972ac260a0f7204bea707288c3970688fe8714c3246a5e9a538168a42a', index: '0x0' },
    depType: 'code',
  } as CKBComponents.CellDep,

  TokenMetadataTypeScript: {
    codeHash: '0x0c7dc8caec145b51b142e13f47fe4262c80628213d1b6c3d9c1aa6a62088804e',
    hashType: 'type',
    args: '',
  } as CKBComponents.Script,
};

const MainnetInfo = {
  Secp256k1LockDep: {
    outPoint: {
      txHash: '0x71a7ba8fc96349fea0ed3a5c47992e3b4084b031a42264a018e0072e8172e46c',
      index: '0x0',
    },
    depType: 'depGroup',
  } as CKBComponents.CellDep,

  RgbppLockScript: {
    codeHash: '0xbc6c568a1a0d0a09f6844dc9d74ddb4343c32143ff25f727c59edf4fb72d6936',
    hashType: 'type',
    args: '',
  } as CKBComponents.Script,

  RgbppLockDep: {
    outPoint: { txHash: '0x04c5c3e69f1aa6ee27fb9de3d15a81704e387ab3b453965adbe0b6ca343c6f41', index: '0x0' },
    depType: 'code',
  } as CKBComponents.CellDep,

  RgbppLockConfigDep: {
    outPoint: { txHash: '0x04c5c3e69f1aa6ee27fb9de3d15a81704e387ab3b453965adbe0b6ca343c6f41', index: '0x1' },
    depType: 'code',
  } as CKBComponents.CellDep,

  BtcTimeLockScript: {
    codeHash: '0x70d64497a075bd651e98ac030455ea200637ee325a12ad08aff03f1a117e5a62',
    hashType: 'type',
    args: '',
  } as CKBComponents.Script,

  BtcTimeLockDep: {
    outPoint: { txHash: '0x6257bf4297ee75fcebe2654d8c5f8d93bc9fc1b3dc62b8cef54ffe166162e996', index: '0x0' },
    depType: 'code',
  } as CKBComponents.CellDep,

  BtcTimeLockConfigDep: {
    outPoint: { txHash: '0x6257bf4297ee75fcebe2654d8c5f8d93bc9fc1b3dc62b8cef54ffe166162e996', index: '0x1' },
    depType: 'code',
  } as CKBComponents.CellDep,

  XUDTTypeScript: {
    codeHash: '0x50bd8d6680b8b9cf98b73f3c08faf8b2a21914311954118ad6609be6e78a1b95',
    hashType: 'data1',
    args: '',
  } as CKBComponents.Script,

  XUDTTypeDep: {
    outPoint: {
      txHash: '0xc07844ce21b38e4b071dd0e1ee3b0e27afd8d7532491327f39b786343f558ab7',
      index: '0x0',
    },
    depType: 'code',
  } as CKBComponents.CellDep,

  UniqueTypeScript: {
    codeHash: '0x2c8c11c985da60b0a330c61a85507416d6382c130ba67f0c47ab071e00aec628',
    hashType: 'data1',
    args: '',
  } as CKBComponents.Script,

  UniqueTypeDep: {
    outPoint: {
      txHash: '0x67524c01c0cb5492e499c7c7e406f2f9d823e162d6b0cf432eacde0c9808c2ad',
      index: '0x0',
    },
    depType: 'code',
  } as CKBComponents.CellDep,

  ClusterTypeScript: {
    codeHash: '0x7366a61534fa7c7e6225ecc0d828ea3b5366adec2b58206f2ee84995fe030075',
    hashType: 'data1',
    args: '',
  } as CKBComponents.Script,

  ClusterTypeDep: {
    outPoint: {
      txHash: '0xe464b7fb9311c5e2820e61c99afc615d6b98bdefbe318c34868c010cbd0dc938',
      index: '0x0',
    },
    depType: 'code',
  } as CKBComponents.CellDep,

  SporeTypeScript: {
    codeHash: '0x4a4dce1df3dffff7f8b2cd7dff7303df3b6150c9788cb75dcf6747247132b9f5',
    hashType: 'data1',
    args: '',
  } as CKBComponents.Script,

  SporeTypeDep: {
    outPoint: {
      txHash: '0x96b198fb5ddbd1eed57ed667068f1f1e55d07907b4c0dbd38675a69ea1b69824',
      index: '0x0',
    },
    depType: 'code',
  } as CKBComponents.CellDep,

  // TODO: Update the UtxoAirdropBadgeTypeScript and UtxoAirdropBadgeTypeDep after the mainnet deployment
  UtxoAirdropBadgeTypeScript: {
    codeHash: '0xf5da9003e31fa9301a3915fe304de9bdb80524b5f0d8fc325fb699317998ee7a',
    hashType: 'type',
    args: '',
  } as CKBComponents.Script,

  UtxoAirdropBadgeTypeDep: {
    outPoint: { txHash: '0xfa0a6821293cc1ef4ee67a900862208e27f67b98237c9b13bf93c84607c5cd33', index: '0x2' },
    depType: 'code',
  } as CKBComponents.CellDep,

  // TODO: Update the TokenMetadataTypeScript after the mainnet deployment
  TokenMetadataTypeScript: {
    codeHash: '0x0c7dc8caec145b51b142e13f47fe4262c80628213d1b6c3d9c1aa6a62088804e',
    hashType: 'type',
    args: '',
  } as CKBComponents.Script,
};

export const COMPATIBLE_XUDT_TYPE_SCRIPTS: CKBComponents.Script[] = [
  // RUSD Mainnet
  {
    codeHash: '0x26a33e0815888a4a0614a0b7d09fa951e0993ff21e55905510104a0b1312032b',
    hashType: 'type',
    args: '',
  },
  // RUSD Testnet
  {
    codeHash: '0x1142755a044bf2ee358cba9f2da187ce928c91cd4dc8692ded0337efa677d21a',
    hashType: 'type',
    args: '',
  },
  // USDI Mainnet
  {
    codeHash: '0xbfa35a9c38a676682b65ade8f02be164d48632281477e36f8dc2f41f79e56bfc',
    hashType: 'type',
    args: '',
  },
  // USDI Testnet
  {
    codeHash: '0xcc9dc33ef234e14bc788c43a4848556a5fb16401a04662fc55db9bb201987037',
    hashType: 'type',
    args: '',
  },
];

export const UNLOCKABLE_LOCK_SCRIPT = {
  codeHash: '0x0000000000000000000000000000000000000000000000000000000000000000',
  hashType: 'data',
  args: '0x',
} as CKBComponents.Script;

export const getSecp256k1CellDep = (isMainnet: boolean) =>
  isMainnet ? MainnetInfo.Secp256k1LockDep : TestnetInfo.Secp256k1LockDep;

export const getXudtTypeScript = (isMainnet: boolean) =>
  isMainnet ? MainnetInfo.XUDTTypeScript : TestnetInfo.XUDTTypeScript;
export const getXudtDep = (isMainnet: boolean) => (isMainnet ? MainnetInfo.XUDTTypeDep : TestnetInfo.XUDTTypeDep);

export const getRgbppLockScript = (isMainnet: boolean, btcTestnetType?: BTCTestnetType) => {
  if (isMainnet) {
    return MainnetInfo.RgbppLockScript;
  }
  return btcTestnetType === 'Signet' ? TestnetInfo.RgbppSignetLockScript : TestnetInfo.RgbppLockScript;
};

export const getRgbppLockDep = (isMainnet: boolean, btcTestnetType?: BTCTestnetType) => {
  if (isMainnet) {
    return MainnetInfo.RgbppLockDep;
  }
  return btcTestnetType === 'Signet' ? TestnetInfo.RgbppSignetLockDep : TestnetInfo.RgbppLockDep;
};

export const getRgbppLockConfigDep = (isMainnet: boolean, btcTestnetType?: BTCTestnetType) => {
  if (isMainnet) {
    return MainnetInfo.RgbppLockConfigDep;
  }
  return btcTestnetType === 'Signet' ? TestnetInfo.RgbppSignetLockConfigDep : TestnetInfo.RgbppLockConfigDep;
};

export const getBtcTimeLockScript = (isMainnet: boolean, btcTestnetType?: BTCTestnetType) => {
  if (isMainnet) {
    return MainnetInfo.BtcTimeLockScript;
  }
  return btcTestnetType === 'Signet' ? TestnetInfo.BtcTimeSignetLockScript : TestnetInfo.BtcTimeLockScript;
};
export const getBtcTimeLockDep = (isMainnet: boolean, btcTestnetType?: BTCTestnetType) => {
  if (isMainnet) {
    return MainnetInfo.BtcTimeLockDep;
  }
  return btcTestnetType === 'Signet' ? TestnetInfo.BtcTimeSignetLockDep : TestnetInfo.BtcTimeLockDep;
};

export const getBtcTimeLockConfigDep = (isMainnet: boolean, btcTestnetType?: BTCTestnetType) => {
  if (isMainnet) {
    return MainnetInfo.BtcTimeLockConfigDep;
  }
  return btcTestnetType === 'Signet' ? TestnetInfo.BtcTimeSignetLockConfigDep : TestnetInfo.BtcTimeLockConfigDep;
};

export const getUniqueTypeScript = (isMainnet: boolean) =>
  isMainnet ? MainnetInfo.UniqueTypeScript : TestnetInfo.UniqueTypeScript;
export const getUniqueTypeDep = (isMainnet: boolean) =>
  isMainnet ? MainnetInfo.UniqueTypeDep : TestnetInfo.UniqueTypeDep;

export const getClusterTypeScript = (isMainnet: boolean) =>
  isMainnet ? MainnetInfo.ClusterTypeScript : TestnetInfo.ClusterTypeScript;
export const getClusterTypeDep = (isMainnet: boolean) =>
  isMainnet ? MainnetInfo.ClusterTypeDep : TestnetInfo.ClusterTypeDep;

export const getSporeTypeScript = (isMainnet: boolean) =>
  isMainnet ? MainnetInfo.SporeTypeScript : TestnetInfo.SporeTypeScript;
export const getSporeTypeDep = (isMainnet: boolean) =>
  isMainnet ? MainnetInfo.SporeTypeDep : TestnetInfo.SporeTypeDep;

export const getUtxoAirdropBadgeTypeScript = (isMainnet: boolean) =>
  isMainnet ? MainnetInfo.UtxoAirdropBadgeTypeScript : TestnetInfo.UtxoAirdropBadgeTypeScript;
export const getUtxoAirdropBadgeTypeDep = (isMainnet: boolean) =>
  isMainnet ? MainnetInfo.UtxoAirdropBadgeTypeDep : TestnetInfo.UtxoAirdropBadgeTypeDep;

export const getTokenMetadataTypeScript = (isMainnet: boolean) =>
  isMainnet ? MainnetInfo.TokenMetadataTypeScript : TestnetInfo.TokenMetadataTypeScript;


================================================
File: packages/ckb/src/error/index.ts
================================================
enum ErrorCode {
  CapacityNotEnough = 100,
  IndexerRpcError = 101,
  NoLiveCell = 102,
  NoXudtLiveCell = 103,
  NoRgbppLiveCell = 104,
  UdtAmountNotEnough = 105,
  InputsCapacityNotEnough = 106,
  TypeAssetNotSupported = 107,
  InputsOrOutputsLenInvalid = 108,
  RgbppCkbTxInputsExceeded = 109,
  RgbppUtxoBindMultiTypeAssets = 110,
  RgbppSporeTypeMismatch = 111,
  InvalidCellId = 112,
}

export class CapacityNotEnoughError extends Error {
  code = ErrorCode.CapacityNotEnough;
  constructor(message: string) {
    super(message);
  }
}

export class IndexerError extends Error {
  code = ErrorCode.IndexerRpcError;
  constructor(message: string) {
    super(message);
  }
}

export class NoLiveCellError extends Error {
  code = ErrorCode.NoLiveCell;
  constructor(message: string) {
    super(message);
  }
}

export class NoXudtLiveCellError extends Error {
  code = ErrorCode.NoXudtLiveCell;
  constructor(message: string) {
    super(message);
  }
}

export class NoRgbppLiveCellError extends Error {
  code = ErrorCode.NoRgbppLiveCell;
  constructor(message: string) {
    super(message);
  }
}

export class UdtAmountNotEnoughError extends Error {
  code = ErrorCode.UdtAmountNotEnough;
  constructor(message: string) {
    super(message);
  }
}

export class InputsCapacityNotEnoughError extends Error {
  code = ErrorCode.InputsCapacityNotEnough;
  constructor(message: string) {
    super(message);
  }
}

export class TypeAssetNotSupportedError extends Error {
  code = ErrorCode.TypeAssetNotSupported;
  constructor(message: string) {
    super(message);
  }
}

export class InputsOrOutputsLenError extends Error {
  code = ErrorCode.InputsOrOutputsLenInvalid;
  constructor(message: string) {
    super(message);
  }
}

export class RgbppCkbTxInputsExceededError extends Error {
  code = ErrorCode.RgbppCkbTxInputsExceeded;
  constructor(message: string) {
    super(message);
  }
}

export class RgbppUtxoBindMultiTypeAssetsError extends Error {
  code = ErrorCode.RgbppUtxoBindMultiTypeAssets;
  constructor(message: string) {
    super(message);
  }
}

export class RgbppSporeTypeMismatchError extends Error {
  code = ErrorCode.RgbppSporeTypeMismatch;
  constructor(message: string) {
    super(message);
  }
}

export class InvalidCellIdError extends Error {
  code = ErrorCode.InvalidCellId;
  constructor(message: string) {
    super(message);
  }
}


================================================
File: packages/ckb/src/paymaster/index.ts
================================================
import { ConstructPaymasterParams } from '../types/rgbpp';
import { NoLiveCellError } from '../error';
import { CKB_UNIT, MAX_FEE, SECP256K1_WITNESS_LOCK_SIZE, getSecp256k1CellDep } from '../constants';
import { append0x, calculateTransactionFee } from '../utils';
import { AddressPrefix, addressToScript, getTransactionSize, privateKeyToAddress } from '@nervosnetwork/ckb-sdk-utils';

const SECP256K1_MIN_CAPACITY = BigInt(61) * CKB_UNIT;

export const splitMultiCellsWithSecp256k1 = async ({
  masterPrivateKey,
  collector,
  receiverAddress,
  capacityWithCKB,
  cellAmount,
}: ConstructPaymasterParams) => {
  const isMainnet = receiverAddress.startsWith('ckb');
  const masterAddress = privateKeyToAddress(masterPrivateKey, {
    prefix: isMainnet ? AddressPrefix.Mainnet : AddressPrefix.Testnet,
  });
  const masterLock = addressToScript(masterAddress);

  let emptyCells = await collector.getCells({
    lock: masterLock,
  });
  if (!emptyCells || emptyCells.length === 0) {
    throw new NoLiveCellError('The address has no empty cells');
  }
  emptyCells = emptyCells.filter((cell) => !cell.output.type);

  const cellCapacity = BigInt(capacityWithCKB) * CKB_UNIT;
  const needCapacity = cellCapacity * BigInt(cellAmount);
  const txFee = MAX_FEE;
  const { inputs, sumInputsCapacity } = collector.collectInputs(emptyCells, needCapacity, txFee, {
    minCapacity: SECP256K1_MIN_CAPACITY,
  });

  const outputs: CKBComponents.CellOutput[] = new Array(cellAmount).fill({
    lock: addressToScript(receiverAddress),
    capacity: append0x(cellCapacity.toString(16)),
  });

  const changeCapacity = sumInputsCapacity - needCapacity - txFee;
  outputs.push({
    lock: masterLock,
    capacity: append0x(changeCapacity.toString(16)),
  });
  const outputsData = new Array(cellAmount + 1).fill('0x');

  const emptyWitness = { lock: '', inputType: '', outputType: '' };
  const witnesses = inputs.map((_, index) => (index === 0 ? emptyWitness : '0x'));

  const cellDeps = [getSecp256k1CellDep(isMainnet)];

  const unsignedTx = {
    version: '0x0',
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses,
  };

  if (txFee === MAX_FEE) {
    const txSize = getTransactionSize(unsignedTx) + SECP256K1_WITNESS_LOCK_SIZE;
    const estimatedTxFee = calculateTransactionFee(txSize);
    const estimatedChangeCapacity = changeCapacity + (MAX_FEE - estimatedTxFee);
    unsignedTx.outputs[unsignedTx.outputs.length - 1].capacity = append0x(estimatedChangeCapacity.toString(16));
  }

  const signedTx = collector.getCkb().signTransaction(masterPrivateKey)(unsignedTx);
  const txHash = await collector.getCkb().rpc.sendTransaction(signedTx, 'passthrough');

  console.info(`Paymaster cells has been split and tx hash is ${txHash}`);
};


================================================
File: packages/ckb/src/rgbpp/btc-jump-ckb.ts
================================================
import { RgbppCkbVirtualTx, BtcJumpCkbVirtualTxParams, BtcJumpCkbVirtualTxResult } from '../types/rgbpp';
import { TypeAssetNotSupportedError } from '../error';
import {
  append0x,
  calculateRgbppCellCapacity,
  calculateTransactionFee,
  deduplicateList,
  fetchTypeIdCellDeps,
  isLockArgsSizeExceeded,
  isScriptEqual,
  isUDTTypeSupported,
  u128ToLe,
  buildPreLockArgs,
  calculateCommitment,
  throwErrorWhenTxInputsExceeded,
  compareInputs,
  estimateWitnessSize,
  genBtcTimeLockScript,
  genRgbppLockScript,
  throwErrorWhenRgbppCellsInvalid,
  isRgbppCapacitySufficientForChange,
  isStandardUDTTypeSupported,
  isOfflineMode,
} from '../utils';
import { Hex, IndexerCell } from '../types';
import { RGBPP_WITNESS_PLACEHOLDER, getSecp256k1CellDep } from '../constants';
import { blockchain } from '@ckb-lumos/base';
import { addressToScript, getTransactionSize } from '@nervosnetwork/ckb-sdk-utils';

/**
 * Generate the virtual ckb transaction for the jumping tx from BTC to CKB
 * @param collector The collector that collects CKB live cells and transactions
 * @param xudtTypeBytes The serialized hex string of the XUDT type script
 * @param rgbppLockArgsList The rgbpp assets cell lock script args array whose data structure is: out_index | bitcoin_tx_id
 * @param transferAmount The XUDT amount to be transferred
 * @param toCkbAddress The receiver ckb address
 * @param witnessLockPlaceholderSize(Optional) The WitnessArgs.lock placeholder bytes array size and the default value is 5000
 * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100
 * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
 * @param btcConfirmationBlocks(Optional) The BTC confirmation blocks for BTC Time lock args
 */
export const genBtcJumpCkbVirtualTx = async ({
  collector,
  xudtTypeBytes,
  rgbppLockArgsList,
  transferAmount,
  toCkbAddress,
  witnessLockPlaceholderSize,
  ckbFeeRate,
  btcTestnetType,
  btcConfirmationBlocks,
  vendorCellDeps,
}: BtcJumpCkbVirtualTxParams): Promise<BtcJumpCkbVirtualTxResult> => {
  const isMainnet = toCkbAddress.startsWith('ckb');
  const xudtType = blockchain.Script.unpack(xudtTypeBytes) as CKBComponents.Script;
  const isOffline = isOfflineMode(vendorCellDeps);

  if (!isUDTTypeSupported(xudtType, isMainnet, isOffline)) {
    throw new TypeAssetNotSupportedError('The type script asset is not supported now');
  }

  const deduplicatedLockArgsList = deduplicateList(rgbppLockArgsList);

  const rgbppLocks = deduplicatedLockArgsList.map((args) => genRgbppLockScript(args, isMainnet, btcTestnetType));
  let rgbppTargetCells: IndexerCell[] = [];
  let rgbppOtherTypeCells: IndexerCell[] = [];
  for await (const rgbppLock of rgbppLocks) {
    const cells = await collector.getCells({ lock: rgbppLock, isDataMustBeEmpty: false });

    throwErrorWhenRgbppCellsInvalid(cells, xudtTypeBytes, isMainnet, isOffline);

    const targetCells = cells!.filter((cell) => isScriptEqual(cell.output.type!, xudtTypeBytes));
    const otherTypeCells = cells!.filter((cell) => !isScriptEqual(cell.output.type!, xudtTypeBytes));
    rgbppTargetCells = [...rgbppTargetCells, ...targetCells];
    rgbppOtherTypeCells = [...rgbppOtherTypeCells, ...otherTypeCells];
  }
  rgbppTargetCells = rgbppTargetCells.sort(compareInputs);
  rgbppOtherTypeCells = rgbppOtherTypeCells.sort(compareInputs);

  const {
    inputs,
    sumInputsCapacity: sumUdtCapacity,
    sumAmount,
  } = collector.collectUdtInputs({
    liveCells: rgbppTargetCells,
    needAmount: transferAmount,
  });
  let sumInputsCapacity = sumUdtCapacity;

  throwErrorWhenTxInputsExceeded(inputs.length);

  const rgbppCellCapacity = calculateRgbppCellCapacity(xudtType);

  const toLock = addressToScript(toCkbAddress);
  if (isLockArgsSizeExceeded(toLock.args)) {
    throw new Error('The lock script size of the to ckb address is too large');
  }

  let needPaymasterCell = false;
  const needRgbppChange = sumAmount > transferAmount;
  // To simplify, when the xUDT does not need change, all the capacity of the inputs will be given to the receiver
  const receiverOutputCapacity = needRgbppChange ? BigInt(rgbppTargetCells[0].output.capacity) : sumInputsCapacity;
  // The BTC time cell does not need to be bound to the BTC UTXO
  const outputs: CKBComponents.CellOutput[] = [
    {
      lock: genBtcTimeLockScript(toLock, isMainnet, btcTestnetType, btcConfirmationBlocks),
      type: xudtType,
      capacity: append0x(receiverOutputCapacity.toString(16)),
    },
  ];
  const outputsData = [append0x(u128ToLe(transferAmount))];

  if (needRgbppChange) {
    const isCapacitySufficient = isRgbppCapacitySufficientForChange(sumInputsCapacity, receiverOutputCapacity);
    needPaymasterCell = !isCapacitySufficient;
    // When the capacity of inputs is enough for the outputs, the sender needs to recover the excess capacity.
    const udtChangeCapacity = isCapacitySufficient ? sumInputsCapacity - receiverOutputCapacity : rgbppCellCapacity;
    outputs.push({
      // The Vouts[0] for OP_RETURN and Vouts[1] for RGBPP assets, BTC time cells don't need btc tx out_index
      lock: genRgbppLockScript(buildPreLockArgs(1), isMainnet, btcTestnetType),
      type: xudtType,
      capacity: append0x(udtChangeCapacity.toString(16)),
    });
    outputsData.push(append0x(u128ToLe(sumAmount - transferAmount)));
  }

  const targetRgbppOutputLen = outputs.length;
  for (const [index, otherRgbppCell] of rgbppOtherTypeCells.entries()) {
    inputs.push({
      previousOutput: otherRgbppCell.outPoint,
      since: '0x0',
    });
    sumInputsCapacity += BigInt(otherRgbppCell.output.capacity);
    outputs.push({
      ...otherRgbppCell.output,
      // Vouts[targetRgbppOutputLen + 1], ..., Vouts[targetRgbppOutputLen + rgbppOtherTypeCells.length] for other RGBPP assets
      lock: genRgbppLockScript(buildPreLockArgs(targetRgbppOutputLen + index + 1), isMainnet, btcTestnetType),
    });
    outputsData.push(otherRgbppCell.outputData);
  }

  const isStandardUDT = isStandardUDTTypeSupported(xudtType, isMainnet);
  const cellDeps = await fetchTypeIdCellDeps(
    isMainnet,
    {
      rgbpp: true,
      xudt: isStandardUDT,
      compatibleXudtCodeHashes: isStandardUDT ? [] : [xudtType.codeHash],
    },
    btcTestnetType,
    vendorCellDeps,
  );
  if (needPaymasterCell) {
    cellDeps.push(getSecp256k1CellDep(isMainnet));
  }

  const witnesses: Hex[] = [];
  const lockArgsSet: Set<string> = new Set();
  const allRgbppCells = rgbppTargetCells.concat(rgbppOtherTypeCells);
  for (const cell of allRgbppCells) {
    if (lockArgsSet.has(cell.output.lock.args)) {
      witnesses.push('0x');
    } else {
      lockArgsSet.add(cell.output.lock.args);
      witnesses.push(RGBPP_WITNESS_PLACEHOLDER);
    }
  }

  const ckbRawTx: CKBComponents.RawTransaction = {
    version: '0x0',
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses,
  };

  if (!needPaymasterCell) {
    const txSize =
      getTransactionSize(ckbRawTx) + (witnessLockPlaceholderSize ?? estimateWitnessSize(deduplicatedLockArgsList));
    const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);
    const changeCapacity = BigInt(outputs[outputs.length - 1].capacity) - estimatedTxFee;
    ckbRawTx.outputs[ckbRawTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));
  }

  const virtualTx: RgbppCkbVirtualTx = {
    ...ckbRawTx,
  };
  const commitment = calculateCommitment(virtualTx);

  return {
    ckbRawTx,
    commitment,
    needPaymasterCell,
    sumInputsCapacity: append0x(sumInputsCapacity.toString(16)),
  };
};


================================================
File: packages/ckb/src/rgbpp/btc-time.ts
================================================
import {
  addressToScript,
  bytesToHex,
  getTransactionSize,
  serializeOutPoint,
  serializeWitnessArgs,
} from '@nervosnetwork/ckb-sdk-utils';
import {
  BTC_JUMP_CONFIRMATION_BLOCKS,
  SECP256K1_WITNESS_LOCK_SIZE,
  getBtcTimeLockScript,
  getSecp256k1CellDep,
} from '../constants';
import { BTCTimeUnlock } from '../schemas/generated/rgbpp';
import { BtcTimeCellStatusParams, BtcTimeCellsParams, Hex, SignBtcTimeCellsTxParams } from '../types';
import {
  append0x,
  btcTxIdAndAfterFromBtcTimeLockArgs,
  calculateTransactionFee,
  compareInputs,
  fetchTypeIdCellDeps,
  genBtcTimeLockArgs,
  lockScriptFromBtcTimeLockArgs,
  transformSpvProof,
  buildSpvClientCellDep,
  isStandardUDTTypeSupported,
  isCompatibleUDTTypesSupported,
  signCkbTransaction,
  addressToScriptHash,
  isOfflineMode,
} from '../utils';

export const buildBtcTimeUnlockWitness = (btcTxProof: Hex): Hex => {
  const btcTimeUnlock = BTCTimeUnlock.pack({ btcTxProof });
  return append0x(bytesToHex(btcTimeUnlock));
};

/**
 * Collect btc time cells and spend them to create xUDT cells for the specific lock scripts in the btc time lock args
 * The btc time lock args data structure is: lock_script | after | new_bitcoin_tx_id
 * @param btcTimeCells The BTC time cells of xUDT
 * @param btcAssetsApi BTC Assets Api
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)
 * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
 */
export const buildBtcTimeCellsSpentTx = async ({
  btcTimeCells,
  btcAssetsApi,
  isMainnet,
  btcTestnetType,
  vendorCellDeps,
}: BtcTimeCellsParams): Promise<CKBComponents.RawTransaction> => {
  const sortedBtcTimeCells = btcTimeCells.sort(compareInputs);
  const inputs: CKBComponents.CellInput[] = sortedBtcTimeCells.map((cell) => ({
    previousOutput: cell.outPoint,
    since: '0x0',
  }));

  const outputs: CKBComponents.CellOutput[] = sortedBtcTimeCells.map((cell) => ({
    lock: lockScriptFromBtcTimeLockArgs(cell.output.lock.args),
    type: cell.output.type,
    capacity: cell.output.capacity,
  }));

  const outputsData = sortedBtcTimeCells.map((cell) => cell.outputData);

  const hasStandardUDT = outputs.some((output) => isStandardUDTTypeSupported(output.type!, isMainnet));
  const compatibleXudtCodeHashes = outputs
    .filter((output) => isCompatibleUDTTypesSupported(output.type!, isOfflineMode(vendorCellDeps)))
    .map((output) => output.type!.codeHash);
  const cellDeps = await fetchTypeIdCellDeps(
    isMainnet,
    {
      btcTime: true,
      xudt: hasStandardUDT,
      compatibleXudtCodeHashes,
    },
    btcTestnetType,
    vendorCellDeps,
  );

  const witnesses: Hex[] = [];

  const lockArgsSet: Set<string> = new Set();
  const cellDepsSet: Set<string> = new Set();
  for await (const btcTimeCell of sortedBtcTimeCells) {
    if (lockArgsSet.has(btcTimeCell.output.lock.args)) {
      witnesses.push('0x');
      continue;
    }
    lockArgsSet.add(btcTimeCell.output.lock.args);
    const { btcTxId, after } = btcTxIdAndAfterFromBtcTimeLockArgs(btcTimeCell.output.lock.args);
    const result = await btcAssetsApi.getRgbppSpvProof(btcTxId, after);
    const { spvClient, proof } = transformSpvProof(result);

    if (!cellDepsSet.has(serializeOutPoint(spvClient))) {
      cellDeps.push(buildSpvClientCellDep(spvClient));
      cellDepsSet.add(serializeOutPoint(spvClient));
    }

    const btcTimeWitness = append0x(
      serializeWitnessArgs({ lock: buildBtcTimeUnlockWitness(proof), inputType: '', outputType: '' }),
    );
    witnesses.push(btcTimeWitness);
  }

  const ckbTx: CKBComponents.RawTransaction = {
    version: '0x0',
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses,
  };

  return ckbTx;
};

export const prepareBtcTimeCellSpentUnsignedTx = async ({
  ckbRawTx,
  collector,
  masterCkbAddress,
  isMainnet,
  outputCapacityRange,
  ckbFeeRate,
}: Omit<SignBtcTimeCellsTxParams, 'secp256k1PrivateKey'>): Promise<{
  ckbRawTx: CKBComponents.RawTransactionToSign;
  inputCells: { outPoint: CKBComponents.OutPoint; lock: CKBComponents.Script }[];
}> => {
  const masterLock = addressToScript(masterCkbAddress);
  let emptyCells = await collector.getCells({
    lock: masterLock,
    outputCapacityRange,
  });
  if (!emptyCells || emptyCells.length === 0) {
    throw new Error('No empty cell found');
  }
  emptyCells = emptyCells.filter((cell) => !cell.output.type);
  const emptyInput: CKBComponents.CellInput = {
    previousOutput: emptyCells[0].outPoint,
    since: '0x0',
  };

  const changeOutput = emptyCells[0].output;
  const rawTx = {
    ...ckbRawTx,
    cellDeps: [...ckbRawTx.cellDeps, getSecp256k1CellDep(isMainnet)],
    inputs: [emptyInput, ...ckbRawTx.inputs],
    outputs: [changeOutput, ...ckbRawTx.outputs],
    outputsData: ['0x', ...ckbRawTx.outputsData],
    witnesses: [{ lock: '', inputType: '', outputType: '' }, ...ckbRawTx.witnesses],
  };

  const txSize = getTransactionSize(rawTx) + SECP256K1_WITNESS_LOCK_SIZE;
  const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);

  const changeCapacity = BigInt(emptyCells[0].output.capacity) - estimatedTxFee;
  rawTx.outputs[0].capacity = append0x(changeCapacity.toString(16));

  const cells = rawTx.inputs.map((input, index) => ({
    outPoint: input.previousOutput as CKBComponents.OutPoint,
    lock: index === 0 ? masterLock : getBtcTimeLockScript(isMainnet),
  }));

  return { ckbRawTx: rawTx, inputCells: cells };
};

/**
 * Sign the BTC time cells spent transaction with Secp256k1 private key
 * @param secp256k1PrivateKey The Secp256k1 private key of the master address
 * @param ckbRawTx The CKB raw transaction to be signed
 * @param collector The collector that collects CKB live cells and transactions
 * @param masterCkbAddress The master CKB address
 * @param outputCapacityRange(Optional) [u64; 2], filter cells by output capacity range, [inclusive, exclusive]
 * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet
 */
export const signBtcTimeCellSpentTx = async ({
  secp256k1PrivateKey,
  ckbRawTx,
  collector,
  masterCkbAddress,
  isMainnet,
  outputCapacityRange,
  ckbFeeRate,
}: SignBtcTimeCellsTxParams): Promise<CKBComponents.RawTransaction> => {
  const { ckbRawTx: rawTx, inputCells } = await prepareBtcTimeCellSpentUnsignedTx({
    ckbRawTx,
    collector,
    masterCkbAddress,
    isMainnet,
    outputCapacityRange,
    ckbFeeRate,
  });

  const keyMap = new Map<string, string>();
  keyMap.set(addressToScriptHash(masterCkbAddress), secp256k1PrivateKey);
  return signCkbTransaction(keyMap, rawTx, inputCells, true);
};

/**
 * Check if the BTC time cells have been spent. If so, it means the RGB++ asset jumping(from BTC to CKB) has been successful.
 * @param collector The collector that collects CKB live cells and transactions
 * @param ckbAddress The CKB address
 * @param btcTxId The BTC transaction id
 */
export const isBtcTimeCellsSpent = async ({
  collector,
  ckbAddress,
  btcTxId,
  btcTestnetType,
}: BtcTimeCellStatusParams): Promise<boolean> => {
  const isMainnet = ckbAddress.startsWith('ckb');
  const lock = addressToScript(ckbAddress);
  const btcTimeLock: CKBComponents.Script = {
    ...getBtcTimeLockScript(isMainnet, btcTestnetType),
    args: genBtcTimeLockArgs(lock, btcTxId, BTC_JUMP_CONFIRMATION_BLOCKS),
  };
  const btcTimeCells = await collector.getCells({ lock: btcTimeLock, isDataMustBeEmpty: false });
  const isSpent = !btcTimeCells || btcTimeCells.length === 0;
  return isSpent;
};


================================================
File: packages/ckb/src/rgbpp/btc-transfer.ts
================================================
import {
  AppendIssuerCellToBtcBatchTransfer,
  BtcBatchTransferVirtualTxParams,
  BtcBatchTransferVirtualTxResult,
  BtcTransferVirtualTxParams,
  BtcTransferVirtualTxResult,
  RgbppCkbVirtualTx,
} from '../types/rgbpp';
import { NoLiveCellError, NoRgbppLiveCellError, TypeAssetNotSupportedError } from '../error';
import {
  append0x,
  calculateRgbppCellCapacity,
  calculateTransactionFee,
  deduplicateList,
  fetchTypeIdCellDeps,
  isScriptEqual,
  isUDTTypeSupported,
  u128ToLe,
  buildPreLockArgs,
  calculateCommitment,
  compareInputs,
  estimateWitnessSize,
  genRgbppLockScript,
  isRgbppCapacitySufficientForChange,
  throwErrorWhenRgbppCellsInvalid,
  throwErrorWhenTxInputsExceeded,
  isStandardUDTTypeSupported,
  signCkbTransaction,
  addressToScriptHash,
  isOfflineMode,
} from '../utils';
import { Hex, IndexerCell } from '../types';
import {
  MAX_FEE,
  MIN_CAPACITY,
  RGBPP_WITNESS_PLACEHOLDER,
  SECP256K1_WITNESS_LOCK_SIZE,
  getRgbppLockScript,
  getSecp256k1CellDep,
} from '../constants';
import { blockchain } from '@ckb-lumos/base';
import { addressToScript, getTransactionSize } from '@nervosnetwork/ckb-sdk-utils';

/**
 * Generate the virtual ckb transaction for the btc transfer tx
 * @param collector The collector that collects CKB live cells and transactions
 * @param xudtTypeBytes The serialized hex string of the XUDT type script
 * @param rgbppLockArgsList The rgbpp assets cell lock script args array whose data structure is: out_index | bitcoin_tx_id
 * @param transferAmount The XUDT amount to be transferred, if the noMergeOutputCells is true, the transferAmount will be ignored
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)
 * @param noMergeOutputCells(Optional) The noMergeOutputCells indicates whether the CKB outputs need to be merged. By default, the outputs will be merged.
 * @param witnessLockPlaceholderSize(Optional) The WitnessArgs.lock placeholder bytes array size and the default value is 5000
 * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100
 * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
 */
export const genBtcTransferCkbVirtualTx = async ({
  collector,
  xudtTypeBytes,
  rgbppLockArgsList,
  transferAmount,
  isMainnet,
  noMergeOutputCells,
  witnessLockPlaceholderSize,
  ckbFeeRate,
  btcTestnetType,
  vendorCellDeps,
}: BtcTransferVirtualTxParams): Promise<BtcTransferVirtualTxResult> => {
  const xudtType = blockchain.Script.unpack(xudtTypeBytes) as CKBComponents.Script;
  const isOffline = isOfflineMode(vendorCellDeps);

  if (!isUDTTypeSupported(xudtType, isMainnet, isOffline)) {
    throw new TypeAssetNotSupportedError('The type script asset is not supported now');
  }

  const deduplicatedLockArgsList = deduplicateList(rgbppLockArgsList);

  const rgbppLocks = deduplicatedLockArgsList.map((args) => genRgbppLockScript(args, isMainnet, btcTestnetType));
  let rgbppTargetCells: IndexerCell[] = [];
  let rgbppOtherTypeCells: IndexerCell[] = [];
  for await (const rgbppLock of rgbppLocks) {
    const cells = await collector.getCells({ lock: rgbppLock, isDataMustBeEmpty: false });

    throwErrorWhenRgbppCellsInvalid(cells, xudtTypeBytes, isMainnet, isOffline);

    const targetCells = cells!.filter((cell) => isScriptEqual(cell.output.type!, xudtTypeBytes));
    const otherTypeCells = cells!.filter((cell) => !isScriptEqual(cell.output.type!, xudtTypeBytes));
    rgbppTargetCells = [...rgbppTargetCells, ...targetCells];
    rgbppOtherTypeCells = [...rgbppOtherTypeCells, ...otherTypeCells];
  }
  rgbppTargetCells = rgbppTargetCells.sort(compareInputs);
  rgbppOtherTypeCells = rgbppOtherTypeCells.sort(compareInputs);

  let inputs: CKBComponents.CellInput[] = [];
  let sumInputsCapacity = BigInt(0);
  const outputs: CKBComponents.CellOutput[] = [];
  const outputsData: Hex[] = [];
  let needPaymasterCell = false;

  // The non-target RGBPP outputs correspond to the RGBPP inputs one-to-one, and the outputs are still bound to the sender’s BTC UTXOs
  const handleNonTargetRgbppCells = (targetRgbppOutputLen: number) => {
    for (const [index, otherRgbppCell] of rgbppOtherTypeCells.entries()) {
      inputs.push({
        previousOutput: otherRgbppCell.outPoint,
        since: '0x0',
      });
      sumInputsCapacity += BigInt(otherRgbppCell.output.capacity);
      outputs.push({
        ...otherRgbppCell.output,
        // Vouts[targetRgbppOutputLen + 1], ..., Vouts[targetRgbppOutputLen + rgbppOtherTypeCells.length] for other RGBPP assets
        lock: genRgbppLockScript(buildPreLockArgs(targetRgbppOutputLen + index + 1), isMainnet, btcTestnetType),
      });
      outputsData.push(otherRgbppCell.outputData);
    }
  };

  if (noMergeOutputCells) {
    // The target RGBPP outputs correspond to the RGBPP inputs one-to-one, and the outputs are bound to the receivers' BTC UTXOs
    for (const [index, targetRgbppCell] of rgbppTargetCells.entries()) {
      inputs.push({
        previousOutput: targetRgbppCell.outPoint,
        since: '0x0',
      });
      sumInputsCapacity += BigInt(targetRgbppCell.output.capacity);
      outputs.push({
        ...targetRgbppCell.output,
        // The Vouts[0] for OP_RETURN and Vouts[1], ..., Vouts[rgbppTargetCells.length] for target RGBPP assets
        lock: genRgbppLockScript(buildPreLockArgs(index + 1), isMainnet, btcTestnetType),
      });
      outputsData.push(targetRgbppCell.outputData);
    }
    handleNonTargetRgbppCells(rgbppTargetCells.length);
  } else {
    // The target RGBPP assets are divided into two parts: transfer(bound to the receivers' BTC UTXO) and change(bound to the sender’s BTC UTXO).
    const collectResult = collector.collectUdtInputs({
      liveCells: rgbppTargetCells,
      needAmount: transferAmount,
    });
    inputs = collectResult.inputs;
    throwErrorWhenTxInputsExceeded(inputs.length);
    sumInputsCapacity = collectResult.sumInputsCapacity;

    const rgbppCellCapacity = calculateRgbppCellCapacity(xudtType);

    const needRgbppChange = collectResult.sumAmount > transferAmount;
    // To simplify, when the xUDT does not need change, all the capacity of the inputs will be given to the receiver
    const receiverOutputCapacity = needRgbppChange ? BigInt(rgbppTargetCells[0].output.capacity) : sumInputsCapacity;
    // The Vouts[0] for OP_RETURN and Vouts[1] for target transfer RGBPP assets
    outputs.push({
      lock: genRgbppLockScript(buildPreLockArgs(1), isMainnet, btcTestnetType),
      type: xudtType,
      capacity: append0x(receiverOutputCapacity.toString(16)),
    });
    outputsData.push(append0x(u128ToLe(transferAmount)));

    if (needRgbppChange) {
      const isCapacitySufficient = isRgbppCapacitySufficientForChange(sumInputsCapacity, receiverOutputCapacity);
      needPaymasterCell = !isCapacitySufficient;
      // When the capacity of inputs is enough for the outputs, the sender needs to recover the excess capacity.
      const udtChangeCapacity = isCapacitySufficient ? sumInputsCapacity - receiverOutputCapacity : rgbppCellCapacity;
      // The Vouts[2] for target change RGBPP assets
      outputs.push({
        lock: genRgbppLockScript(buildPreLockArgs(2), isMainnet, btcTestnetType),
        type: xudtType,
        capacity: append0x(udtChangeCapacity.toString(16)),
      });
      outputsData.push(append0x(u128ToLe(collectResult.sumAmount - transferAmount)));
    }

    handleNonTargetRgbppCells(outputs.length);
  }

  const isStandardUDT = isStandardUDTTypeSupported(xudtType, isMainnet);
  const cellDeps = await fetchTypeIdCellDeps(
    isMainnet,
    {
      rgbpp: true,
      xudt: isStandardUDT,
      compatibleXudtCodeHashes: isStandardUDT ? [] : [xudtType.codeHash],
    },
    btcTestnetType,
    vendorCellDeps,
  );
  if (needPaymasterCell) {
    cellDeps.push(getSecp256k1CellDep(isMainnet));
  }
  const witnesses: Hex[] = [];
  const lockArgsSet: Set<string> = new Set();
  const allRgbppCells = rgbppTargetCells.concat(rgbppOtherTypeCells);
  for (const cell of allRgbppCells) {
    if (lockArgsSet.has(cell.output.lock.args)) {
      witnesses.push('0x');
    } else {
      lockArgsSet.add(cell.output.lock.args);
      witnesses.push(RGBPP_WITNESS_PLACEHOLDER);
    }
  }

  const ckbRawTx: CKBComponents.RawTransaction = {
    version: '0x0',
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses,
  };

  if (!needPaymasterCell) {
    const txSize =
      getTransactionSize(ckbRawTx) + (witnessLockPlaceholderSize ?? estimateWitnessSize(deduplicatedLockArgsList));
    const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);

    const changeCapacity = BigInt(outputs[outputs.length - 1].capacity) - estimatedTxFee;
    ckbRawTx.outputs[ckbRawTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));
  }

  const virtualTx: RgbppCkbVirtualTx = {
    ...ckbRawTx,
  };
  const commitment = calculateCommitment(virtualTx);

  return {
    ckbRawTx,
    commitment,
    needPaymasterCell,
    sumInputsCapacity: append0x(sumInputsCapacity.toString(16)),
  };
};

/**
 * Generate the virtual ckb transaction for the btc batch transfer tx
 * @param collector The collector that collects CKB live cells and transactions
 * @param xudtTypeBytes The serialized hex string of the XUDT type script
 * @param rgbppLockArgsList The rgbpp assets cell lock script args array whose data structure is: out_index | bitcoin_tx_id
 * @param rgbppReceivers The rgbpp receiver list which include toBtcAddress and transferAmount
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)
 * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
 */
export const genBtcBatchTransferCkbVirtualTx = async ({
  collector,
  xudtTypeBytes,
  rgbppLockArgsList,
  rgbppReceivers,
  isMainnet,
  btcTestnetType,
  vendorCellDeps,
}: BtcBatchTransferVirtualTxParams): Promise<BtcBatchTransferVirtualTxResult> => {
  const xudtType = blockchain.Script.unpack(xudtTypeBytes) as CKBComponents.Script;

  if (!isUDTTypeSupported(xudtType, isMainnet, isOfflineMode(vendorCellDeps))) {
    throw new TypeAssetNotSupportedError('The type script asset is not supported now');
  }

  const rgbppLocks = rgbppLockArgsList.map((args) => genRgbppLockScript(args, isMainnet, btcTestnetType));
  let rgbppCells: IndexerCell[] = [];
  for await (const rgbppLock of rgbppLocks) {
    const cells = await collector.getCells({ lock: rgbppLock, type: xudtType });
    if (!cells || cells.length === 0) {
      throw new NoRgbppLiveCellError('No rgbpp cells found with the xudt type script and the rgbpp lock args');
    }
    rgbppCells = [...rgbppCells, ...cells];
  }
  rgbppCells = rgbppCells.sort(compareInputs);

  const sumTransferAmount = rgbppReceivers
    .map((receiver) => receiver.transferAmount)
    .reduce((prev, current) => prev + current, BigInt(0));

  const rpbppCellCapacity = calculateRgbppCellCapacity(xudtType);
  const outputs: CKBComponents.CellOutput[] = rgbppReceivers.map((_, index) => ({
    // The Vouts[0] for OP_RETURN and Vouts[1], Vouts[2], ... for RGBPP assets
    lock: genRgbppLockScript(buildPreLockArgs(index + 1), isMainnet, btcTestnetType),
    type: xudtType,
    capacity: append0x(rpbppCellCapacity.toString(16)),
  }));
  const outputsData = rgbppReceivers.map((receiver) => append0x(u128ToLe(receiver.transferAmount)));

  const { inputs, sumInputsCapacity, sumAmount } = collector.collectUdtInputs({
    liveCells: rgbppCells,
    needAmount: sumTransferAmount,
  });

  throwErrorWhenTxInputsExceeded(inputs.length);

  // Rgbpp change cell index, if it is -1, it means there is no change rgbpp cell
  let rgbppChangeOutIndex = -1;
  if (sumAmount > sumTransferAmount) {
    // Rgbpp change cell is placed at the last position by default
    rgbppChangeOutIndex = rgbppReceivers.length + 1;
    outputs.push({
      // The Vouts[0] for OP_RETURN and Vouts[rgbppChangeOutIndex] for RGBPP change assets
      lock: genRgbppLockScript(buildPreLockArgs(rgbppChangeOutIndex), isMainnet, btcTestnetType),
      type: xudtType,
      capacity: append0x(rpbppCellCapacity.toString(16)),
    });
    outputsData.push(append0x(u128ToLe(sumAmount - sumTransferAmount)));
  }

  const isStandardUDT = isStandardUDTTypeSupported(xudtType, isMainnet);
  let cellDeps = await fetchTypeIdCellDeps(
    isMainnet,
    {
      rgbpp: true,
      xudt: isStandardUDT,
      compatibleXudtCodeHashes: isStandardUDT ? [] : [xudtType.codeHash],
    },
    btcTestnetType,
    vendorCellDeps,
  );
  cellDeps = [...cellDeps, getSecp256k1CellDep(isMainnet)];

  const witnesses: Hex[] = [];
  const lockArgsSet: Set<string> = new Set();
  for (const cell of rgbppCells) {
    if (lockArgsSet.has(cell.output.lock.args)) {
      witnesses.push('0x');
    } else {
      lockArgsSet.add(cell.output.lock.args);
      witnesses.push(RGBPP_WITNESS_PLACEHOLDER);
    }
  }

  const ckbRawTx: CKBComponents.RawTransaction = {
    version: '0x0',
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses,
  };

  const virtualTx: RgbppCkbVirtualTx = {
    ...ckbRawTx,
  };
  const commitment = calculateCommitment(virtualTx);

  return {
    ckbRawTx,
    commitment,
    rgbppChangeOutIndex,
    needPaymasterCell: false,
    sumInputsCapacity: append0x(sumInputsCapacity.toString(16)),
  };
};

/**
 * Appends cells from the issuer address to cover transaction fees and ensures sufficient capacity
 * @param issuerAddress The address that provides cells for transaction fees
 * @param collector The collector that collects CKB live cells and transactions
 * @param ckbRawTx The raw transaction to append cells to
 * @param sumInputsCapacity The sum capacity of ckb inputs which is to be used to calculate ckb tx fee
 * @param sumInputsCapacity The total capacity of existing inputs
 * @param ckbFeeRate The CKB transaction fee rate, default value is 1100
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet
 * @returns The updated transaction and input cells information
 */
export const appendIssuerCellToBtcBatchTransferToSign = async ({
  issuerAddress,
  collector,
  ckbRawTx,
  sumInputsCapacity,
  ckbFeeRate,
  isMainnet,
}: Omit<AppendIssuerCellToBtcBatchTransfer, 'secp256k1PrivateKey'>): Promise<{
  ckbRawTx: CKBComponents.RawTransactionToSign;
  inputCells: { outPoint: CKBComponents.OutPoint; lock: CKBComponents.Script }[];
}> => {
  const rgbppInputsLength = ckbRawTx.inputs.length;
  const rawTx = ckbRawTx as CKBComponents.RawTransactionToSign;

  const sumOutputsCapacity: bigint = rawTx.outputs
    .map((output) => BigInt(output.capacity))
    .reduce((prev, current) => prev + current, BigInt(0));

  const issuerLock = addressToScript(issuerAddress);
  let emptyCells = await collector.getCells({ lock: issuerLock });
  if (!emptyCells || emptyCells.length === 0) {
    throw new NoLiveCellError('The issuer address has no empty cells');
  }
  emptyCells = emptyCells.filter((cell) => !cell.output.type);

  let actualInputsCapacity = BigInt(sumInputsCapacity);
  const txFee = MAX_FEE;
  if (actualInputsCapacity <= sumOutputsCapacity) {
    const needCapacity = sumOutputsCapacity - actualInputsCapacity + MIN_CAPACITY;
    const { inputs, sumInputsCapacity: sumEmptyCapacity } = collector.collectInputs(emptyCells, needCapacity, txFee);
    rawTx.inputs = [...rawTx.inputs, ...inputs];
    actualInputsCapacity += sumEmptyCapacity;
  }

  let changeCapacity = actualInputsCapacity - sumOutputsCapacity;
  const changeOutput = {
    lock: issuerLock,
    capacity: append0x(changeCapacity.toString(16)),
  };
  rawTx.outputs = [...rawTx.outputs, changeOutput];
  rawTx.outputsData = [...rawTx.outputsData, '0x'];

  const txSize = getTransactionSize(rawTx) + SECP256K1_WITNESS_LOCK_SIZE;
  const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);
  changeCapacity -= estimatedTxFee;
  rawTx.outputs[rawTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));

  const issuerCellIndex = rgbppInputsLength;
  const cells = rawTx.inputs.map((input, index) => ({
    outPoint: input.previousOutput as CKBComponents.OutPoint,
    lock: index >= issuerCellIndex ? issuerLock : getRgbppLockScript(isMainnet),
  }));

  const emptyWitness = { lock: '', inputType: '', outputType: '' };
  const issuerWitnesses = rawTx.inputs.slice(rgbppInputsLength).map((_, index) => (index === 0 ? emptyWitness : '0x'));
  rawTx.witnesses = [...rawTx.witnesses, ...issuerWitnesses];

  return { ckbRawTx: rawTx, inputCells: cells };
};

/**
 * Append paymaster cell to the ckb transaction inputs and sign the transaction with paymaster cell's secp256k1 private key
 * @param secp256k1PrivateKey The Secp256k1 private key of the paymaster cells maintainer
 * @param issuerAddress The issuer ckb address
 * @param collector The collector that collects CKB live cells and transactions
 * @param ckbRawTx CKB raw transaction
 * @param sumInputsCapacity The sum capacity of ckb inputs which is to be used to calculate ckb tx fee
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet
 * @param ckbFeeRate The CKB transaction fee rate, default value is 1100
 */
export const appendIssuerCellToBtcBatchTransfer = async ({
  secp256k1PrivateKey,
  issuerAddress,
  collector,
  ckbRawTx,
  sumInputsCapacity,
  isMainnet,
  ckbFeeRate,
}: AppendIssuerCellToBtcBatchTransfer): Promise<CKBComponents.RawTransaction> => {
  const { ckbRawTx: rawTx, inputCells } = await appendIssuerCellToBtcBatchTransferToSign({
    issuerAddress,
    collector,
    ckbRawTx,
    sumInputsCapacity,
    ckbFeeRate,
    isMainnet,
  });

  const keyMap = new Map<string, string>();
  keyMap.set(addressToScriptHash(issuerAddress), secp256k1PrivateKey);

  return signCkbTransaction(keyMap, rawTx, inputCells, true);
};


================================================
File: packages/ckb/src/rgbpp/ckb-builder.ts
================================================
import {
  UpdateCkbTxWithRealBtcTxIdParams,
  AppendPaymasterCellAndSignTxParams,
  AppendWitnessesParams,
  Hex,
  SendCkbTxParams,
} from '../types';
import { MIN_CAPACITY, RGBPP_WITNESS_PLACEHOLDER, SECP256K1_WITNESS_LOCK_SIZE, getRgbppLockScript } from '../constants';
import {
  append0x,
  calculateTransactionFee,
  isRgbppLockOrBtcTimeLock,
  replaceLockArgsWithRealBtcTxId,
  transformSpvProof,
  u8ToHex,
} from '../utils';
import { InputsCapacityNotEnoughError } from '../error';
import { buildSpvClientCellDep } from '../utils';
import { RGBPPUnlock, Uint16 } from '../schemas/generated/rgbpp';
import signWitnesses from '@nervosnetwork/ckb-sdk-core/lib/signWitnesses';
import {
  bytesToHex,
  getTransactionSize,
  rawTransactionToHash,
  scriptToHash,
  serializeWitnessArgs,
} from '@nervosnetwork/ckb-sdk-utils';

export const buildRgbppUnlockWitness = (
  btcTxBytes: Hex,
  btcTxProof: Hex,
  inputsLen: number,
  outputsLen: number,
): Hex => {
  const inputLen = append0x(u8ToHex(inputsLen));
  const outputLen = append0x(u8ToHex(outputsLen));

  const version = Uint16.pack([0, 0]);
  const rgbppUnlock = RGBPPUnlock.pack({
    version,
    extraData: { inputLen, outputLen },
    btcTx: append0x(btcTxBytes),
    btcTxProof: append0x(btcTxProof),
  });
  return append0x(bytesToHex(rgbppUnlock));
};

/**
 * Append RGBPP unlock witnesses to ckb tx and the tx can be sent to blockchain if the needPaymasterCell is false.
 * And if the needPaymasterCell is true, appending paymaster cell to inputs and signing ckb tx are required.
 * @param collector The collector that collects CKB live cells and transactions
 * @param spvService SPV RPC service
 * @param btcTxBytes The hex string of btc transaction, refer to https://github.com/bitcoinjs/bitcoinjs-lib/blob/master/ts_src/transaction.ts#L609
 * @param rgbppApiSpvProof The SPV client cell and tx proof which is from BTCAssetsApi
 */
export const appendCkbTxWitnesses = async ({
  ckbRawTx,
  btcTxBytes,
  rgbppApiSpvProof,
}: AppendWitnessesParams): Promise<CKBComponents.RawTransaction> => {
  const rawTx = ckbRawTx;

  const { spvClient, proof } = transformSpvProof(rgbppApiSpvProof);
  rawTx.cellDeps.push(buildSpvClientCellDep(spvClient));

  const rgbppUnlock = buildRgbppUnlockWitness(btcTxBytes, proof, ckbRawTx.inputs.length, ckbRawTx.outputs.length);
  const rgbppWitness = append0x(serializeWitnessArgs({ lock: rgbppUnlock, inputType: '', outputType: '' }));
  rawTx.witnesses = rawTx.witnesses.map((witness) => (witness === RGBPP_WITNESS_PLACEHOLDER ? rgbppWitness : witness));

  return rawTx;
};

/**
 * Append paymaster cell to the ckb transaction inputs and sign the transaction with paymaster cell's secp256k1 private key
 * @param secp256k1PrivateKey The Secp256k1 private key of the paymaster cells maintainer
 * @param ckbRawTx CKB raw transaction
 * @param sumInputsCapacity The sum capacity of ckb inputs which is to be used to calculate ckb tx fee
 * @param paymasterCell The paymaster cell whose type is IndexerCell is used to pay the extra output cell
 * @param ckbFeeRate The CKB transaction fee rate, default value is 1100
 */
export const appendPaymasterCellAndSignCkbTx = async ({
  secp256k1PrivateKey,
  ckbRawTx,
  sumInputsCapacity,
  paymasterCell,
  isMainnet,
  ckbFeeRate,
}: AppendPaymasterCellAndSignTxParams): Promise<CKBComponents.RawTransaction> => {
  const rawTx = ckbRawTx as CKBComponents.RawTransactionToSign;
  const paymasterInput = { previousOutput: paymasterCell.outPoint, since: '0x0' };
  rawTx.inputs = [...rawTx.inputs, paymasterInput];
  const inputsCapacity = BigInt(sumInputsCapacity) + BigInt(paymasterCell.output.capacity);

  const sumOutputsCapacity: bigint = rawTx.outputs
    .map((output) => BigInt(output.capacity))
    .reduce((prev, current) => prev + current, BigInt(0));

  if (inputsCapacity <= sumOutputsCapacity + MIN_CAPACITY) {
    throw new InputsCapacityNotEnoughError('The sum of inputs capacity is not enough');
  }

  let changeCapacity = inputsCapacity - sumOutputsCapacity;
  const changeOutput = {
    lock: paymasterCell.output.lock,
    capacity: append0x(changeCapacity.toString(16)),
  };
  rawTx.outputs = [...rawTx.outputs, changeOutput];
  rawTx.outputsData = [...rawTx.outputsData, '0x'];

  const txSize = getTransactionSize(rawTx) + SECP256K1_WITNESS_LOCK_SIZE;
  const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);
  changeCapacity -= estimatedTxFee;
  rawTx.outputs[rawTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));

  const keyMap = new Map<string, string>();
  keyMap.set(scriptToHash(paymasterCell.output.lock), secp256k1PrivateKey);
  keyMap.set(scriptToHash(getRgbppLockScript(isMainnet)), '');

  const paymasterCellIndex = rawTx.inputs.length - 1;
  const cells = rawTx.inputs.map((input, index) => ({
    outPoint: input.previousOutput,
    lock: index === paymasterCellIndex ? paymasterCell.output.lock : getRgbppLockScript(isMainnet),
  }));

  const emptyWitness = { lock: '', inputType: '', outputType: '' };
  rawTx.witnesses = [...rawTx.witnesses, emptyWitness];

  const transactionHash = rawTransactionToHash(rawTx);
  const signedWitnesses = signWitnesses(keyMap)({
    transactionHash,
    witnesses: rawTx.witnesses,
    inputCells: cells,
    skipMissingKeys: true,
  });

  const signedTx = {
    ...rawTx,
    witnesses: signedWitnesses.map((witness) =>
      typeof witness !== 'string' ? serializeWitnessArgs(witness) : witness,
    ),
  };
  return signedTx;
};

export const sendCkbTx = async ({ collector, signedTx }: SendCkbTxParams) => {
  const txHash = await collector.getCkb().rpc.sendTransaction(signedTx, 'passthrough');
  return txHash;
};

/**
 * Replace the RGBPP_TX_ID_PLACEHOLDER with the real btc tx id of the rgbpp lock args and BTC time lock args
 * @param ckbRawTx CKB raw transaction
 * @param btcTxId The BTC transaction id
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet
 */
export const updateCkbTxWithRealBtcTxId = ({
  ckbRawTx,
  btcTxId,
  isMainnet,
}: UpdateCkbTxWithRealBtcTxIdParams): CKBComponents.RawTransaction => {
  const outputs = ckbRawTx.outputs.map((output) => {
    if (isRgbppLockOrBtcTimeLock(output.lock, isMainnet)) {
      return {
        ...output,
        lock: {
          ...output.lock,
          args: replaceLockArgsWithRealBtcTxId(output.lock.args, btcTxId),
        },
      };
    }
    return output;
  });
  const newRawTx: CKBComponents.RawTransaction = {
    ...ckbRawTx,
    outputs,
  };
  return newRawTx;
};


================================================
File: packages/ckb/src/rgbpp/ckb-jump-btc.ts
================================================
import { CkbBatchJumpBtcVirtualTxParams, CkbJumpBtcVirtualTxParams } from '../types/rgbpp';
import { NoLiveCellError, NoXudtLiveCellError, TypeAssetNotSupportedError } from '../error';
import {
  append0x,
  calculateRgbppCellCapacity,
  calculateTransactionFee,
  calculateUdtCellCapacity,
  fetchTypeIdCellDeps,
  isTypeAssetSupported,
  u128ToLe,
  genRgbppLockScript,
  isStandardUDTTypeSupported,
  isOfflineMode,
} from '../utils';
import { MAX_FEE, MIN_CAPACITY, RGBPP_TX_WITNESS_MAX_SIZE } from '../constants';
import { blockchain } from '@ckb-lumos/base';
import { addressToScript, getTransactionSize } from '@nervosnetwork/ckb-sdk-utils';

/**
 * Generate the virtual ckb transaction for the jumping tx from CKB to BTC
 * @param collector The collector that collects CKB live cells and transactions
 * @param xudtTypeBytes The serialized hex string of the XUDT type script
 * @param fromCkbAddress The from ckb address who will use his private key to sign the ckb tx
 * @param toRgbppLockArgs The receiver rgbpp lock script args whose data structure is: out_index | bitcoin_tx_id
 * @param transferAmount The XUDT amount to be transferred
 * @param witnessLockPlaceholderSize(Optional)  The WitnessArgs.lock placeholder bytes array size and the default value is 5000
 * @param ckbFeeRate(Optional)  The CKB transaction fee rate, default value is 1100
 * @param btcTestnetType(Optional)  The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
 */
export const genCkbJumpBtcVirtualTx = async ({
  collector,
  xudtTypeBytes,
  fromCkbAddress,
  toRgbppLockArgs,
  transferAmount,
  witnessLockPlaceholderSize,
  ckbFeeRate,
  btcTestnetType,
  vendorCellDeps,
}: CkbJumpBtcVirtualTxParams): Promise<CKBComponents.RawTransaction> => {
  const isMainnet = fromCkbAddress.startsWith('ckb');
  const xudtType = blockchain.Script.unpack(xudtTypeBytes) as CKBComponents.Script;
  if (!isTypeAssetSupported(xudtType, isMainnet, isOfflineMode(vendorCellDeps))) {
    throw new TypeAssetNotSupportedError('The type script asset is not supported now');
  }

  const fromLock = addressToScript(fromCkbAddress);

  const xudtCells = await collector.getCells({ lock: fromLock, type: xudtType });
  if (!xudtCells || xudtCells.length === 0) {
    throw new NoXudtLiveCellError('No rgbpp cells found with the xudt type script and the rgbpp lock args');
  }

  const collected = collector.collectUdtInputs({
    liveCells: xudtCells,
    needAmount: transferAmount,
  });

  let { inputs, sumInputsCapacity } = collected;
  const { sumAmount } = collected;

  const rpbppCellCapacity = calculateRgbppCellCapacity(xudtType);
  const outputsData = [append0x(u128ToLe(transferAmount))];

  const outputs: CKBComponents.CellOutput[] = [
    {
      lock: genRgbppLockScript(toRgbppLockArgs, isMainnet, btcTestnetType),
      type: xudtType,
      capacity: append0x(rpbppCellCapacity.toString(16)),
    },
  ];

  const txFee = MAX_FEE;
  const xudtCellCapacity = calculateUdtCellCapacity(fromLock, xudtType);
  if (sumInputsCapacity < xudtCellCapacity + rpbppCellCapacity + MIN_CAPACITY + txFee) {
    let emptyCells = await collector.getCells({ lock: fromLock });
    if (!emptyCells || emptyCells.length === 0) {
      throw new NoLiveCellError('The address has no empty cells');
    }
    emptyCells = emptyCells.filter((cell) => !cell.output.type);
    const { inputs: emptyInputs, sumInputsCapacity: sumEmptyCapacity } = collector.collectInputs(
      emptyCells,
      rpbppCellCapacity,
      txFee,
    );
    inputs = [...emptyInputs, ...inputs];
    sumInputsCapacity += sumEmptyCapacity;
  }

  let changeCapacity = sumInputsCapacity - rpbppCellCapacity - txFee;
  if (sumAmount > transferAmount) {
    outputs.push({
      lock: fromLock,
      type: xudtType,
      capacity: append0x(xudtCellCapacity.toString(16)),
    });
    outputsData.push(append0x(u128ToLe(sumAmount - transferAmount)));
    changeCapacity -= xudtCellCapacity;
  }
  outputs.push({
    lock: fromLock,
    capacity: append0x(changeCapacity.toString(16)),
  });
  outputsData.push('0x');

  const isStandardUDT = isStandardUDTTypeSupported(xudtType, isMainnet);
  const cellDeps = await fetchTypeIdCellDeps(
    isMainnet,
    {
      xudt: isStandardUDT,
      compatibleXudtCodeHashes: isStandardUDT ? [] : [xudtType.codeHash],
    },
    btcTestnetType,
    vendorCellDeps,
  );
  const witnesses = inputs.map(() => '0x');

  const ckbRawTx: CKBComponents.RawTransaction = {
    version: '0x0',
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses,
  };

  if (txFee === MAX_FEE) {
    const txSize = getTransactionSize(ckbRawTx) + (witnessLockPlaceholderSize ?? RGBPP_TX_WITNESS_MAX_SIZE);
    const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);
    const estimatedChangeCapacity = changeCapacity + (MAX_FEE - estimatedTxFee);
    ckbRawTx.outputs[ckbRawTx.outputs.length - 1].capacity = append0x(estimatedChangeCapacity.toString(16));
  }

  return ckbRawTx;
};

/**
 * Generate a virtual ckb transaction to realize a batch jump of assets from CKB to BTC
 * @param collector The collector that collects CKB live cells and transactions
 * @param xudtTypeBytes The serialized hex string of the XUDT type script
 * @param fromCkbAddress The from ckb address who will use his private key to sign the ckb tx
 * @param rgbppReceivers The rgbpp receiver list which include toRgbppLockArgs and transferAmount
 * @param witnessLockPlaceholderSize(Optional)  The WitnessArgs.lock placeholder bytes array size and the default value is 5000
 * @param ckbFeeRate(Optional)  The CKB transaction fee rate, default value is 1100
 * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
 */
export const genCkbBatchJumpBtcVirtualTx = async ({
  collector,
  xudtTypeBytes,
  fromCkbAddress,
  rgbppReceivers,
  witnessLockPlaceholderSize,
  ckbFeeRate,
  btcTestnetType,
  vendorCellDeps,
}: CkbBatchJumpBtcVirtualTxParams): Promise<CKBComponents.RawTransaction> => {
  const isMainnet = fromCkbAddress.startsWith('ckb');
  const xudtType = blockchain.Script.unpack(xudtTypeBytes) as CKBComponents.Script;
  if (!isTypeAssetSupported(xudtType, isMainnet, isOfflineMode(vendorCellDeps))) {
    throw new TypeAssetNotSupportedError('The type script asset is not supported now');
  }

  const fromLock = addressToScript(fromCkbAddress);

  const xudtCells = await collector.getCells({ lock: fromLock, type: xudtType });
  if (!xudtCells || xudtCells.length === 0) {
    throw new NoXudtLiveCellError('No rgbpp cells found with the xudt type script and the rgbpp lock args');
  }

  const sumTransferAmount = rgbppReceivers
    .map((receiver) => receiver.transferAmount)
    .reduce((prev, current) => prev + current, BigInt(0));

  const collected = collector.collectUdtInputs({
    liveCells: xudtCells,
    needAmount: sumTransferAmount,
  });

  let { inputs, sumInputsCapacity } = collected;
  const { sumAmount } = collected;

  const rpbppCellCapacity = calculateRgbppCellCapacity(xudtType);
  const sumRgbppCellCapacity = rpbppCellCapacity * BigInt(rgbppReceivers.length);
  const outputs: CKBComponents.CellOutput[] = rgbppReceivers.map((receiver) => ({
    lock: genRgbppLockScript(receiver.toRgbppLockArgs, isMainnet, btcTestnetType),
    type: xudtType,
    capacity: append0x(rpbppCellCapacity.toString(16)),
  }));
  const outputsData = rgbppReceivers.map((receiver) => append0x(u128ToLe(receiver.transferAmount)));

  const txFee = MAX_FEE;
  const xudtCellCapacity = calculateUdtCellCapacity(fromLock, xudtType);
  if (sumInputsCapacity < xudtCellCapacity + sumRgbppCellCapacity + MIN_CAPACITY + txFee) {
    let emptyCells = await collector.getCells({ lock: fromLock });
    if (!emptyCells || emptyCells.length === 0) {
      throw new NoLiveCellError('The address has no empty cells');
    }
    emptyCells = emptyCells.filter((cell) => !cell.output.type);
    const { inputs: emptyInputs, sumInputsCapacity: sumEmptyCapacity } = collector.collectInputs(
      emptyCells,
      rpbppCellCapacity,
      txFee,
    );
    inputs = [...emptyInputs, ...inputs];
    sumInputsCapacity += sumEmptyCapacity;
  }

  let changeCapacity = sumInputsCapacity - sumRgbppCellCapacity - txFee;
  if (sumAmount > sumTransferAmount) {
    outputs.push({
      lock: fromLock,
      type: xudtType,
      capacity: append0x(xudtCellCapacity.toString(16)),
    });
    outputsData.push(append0x(u128ToLe(sumAmount - sumTransferAmount)));
    changeCapacity -= xudtCellCapacity;
  }
  outputs.push({
    lock: fromLock,
    capacity: append0x(changeCapacity.toString(16)),
  });
  outputsData.push('0x');

  const isStandardUDT = isStandardUDTTypeSupported(xudtType, isMainnet);
  const cellDeps = await fetchTypeIdCellDeps(
    isMainnet,
    {
      xudt: isStandardUDT,
      compatibleXudtCodeHashes: isStandardUDT ? [] : [xudtType.codeHash],
    },
    btcTestnetType,
    vendorCellDeps,
  );
  const witnesses = inputs.map(() => '0x');

  const ckbRawTx: CKBComponents.RawTransaction = {
    version: '0x0',
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses,
  };

  if (txFee === MAX_FEE) {
    const txSize = getTransactionSize(ckbRawTx) + (witnessLockPlaceholderSize ?? RGBPP_TX_WITNESS_MAX_SIZE);
    const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);
    const estimatedChangeCapacity = changeCapacity + (MAX_FEE - estimatedTxFee);
    ckbRawTx.outputs[ckbRawTx.outputs.length - 1].capacity = append0x(estimatedChangeCapacity.toString(16));
  }

  return ckbRawTx;
};


================================================
File: packages/ckb/src/rgbpp/index.ts
================================================
export * from './btc-transfer';
export * from './ckb-builder';
export * from './btc-jump-ckb';
export * from './btc-time';
export * from './ckb-jump-btc';
export * from './launch';


================================================
File: packages/ckb/src/rgbpp/launch.ts
================================================
import { RgbppCkbVirtualTx, RgbppLaunchCkbVirtualTxParams, RgbppLaunchVirtualTxResult } from '../types/rgbpp';
import { NoLiveCellError } from '../error';
import {
  append0x,
  calculateRgbppTokenInfoCellCapacity,
  calculateTransactionFee,
  fetchTypeIdCellDeps,
  generateUniqueTypeArgs,
  u128ToLe,
  buildPreLockArgs,
  calculateCommitment,
  encodeRgbppTokenInfo,
  genBtcTimeLockScript,
  genRgbppLockScript,
} from '../utils';
import { Hex } from '../types';
import {
  MAX_FEE,
  RGBPP_TX_WITNESS_MAX_SIZE,
  RGBPP_WITNESS_PLACEHOLDER,
  getXudtTypeScript,
  getUniqueTypeScript,
  UNLOCKABLE_LOCK_SCRIPT,
} from '../constants';
import { getTransactionSize, scriptToHash } from '@nervosnetwork/ckb-sdk-utils';

/**
 * Generate the virtual ckb transaction for the btc transfer tx
 * @param collector The collector that collects CKB live cells and transactions
 * @param ownerRgbppLockArgs The owner RGBPP lock args whose data structure is: out_index | bitcoin_tx_id
 * @param launchAmount The total amount of RGBPP assets issued
 * @param rgbppTokenInfo The RGBPP token info https://github.com/ckb-cell/unique-cell?tab=readme-ov-file#xudt-information
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)
 * @param witnessLockPlaceholderSize(Optional) The WitnessArgs.lock placeholder bytes array size and the default value is 5000
 * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100
 * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
 */
export const genRgbppLaunchCkbVirtualTx = async ({
  collector,
  ownerRgbppLockArgs,
  launchAmount,
  rgbppTokenInfo,
  witnessLockPlaceholderSize,
  ckbFeeRate,
  isMainnet,
  btcTestnetType,
  vendorCellDeps,
}: RgbppLaunchCkbVirtualTxParams): Promise<RgbppLaunchVirtualTxResult> => {
  const ownerLock = genRgbppLockScript(ownerRgbppLockArgs, isMainnet, btcTestnetType);
  let emptyCells = await collector.getCells({ lock: ownerLock });
  if (!emptyCells || emptyCells.length === 0) {
    throw new NoLiveCellError('The owner address has no empty cells');
  }
  emptyCells = emptyCells.filter((cell) => !cell.output.type);
  const infoCellCapacity = calculateRgbppTokenInfoCellCapacity(rgbppTokenInfo, isMainnet);

  const txFee = MAX_FEE;
  const { inputs, sumInputsCapacity } = collector.collectInputs(emptyCells, infoCellCapacity, txFee);

  let rgbppCellCapacity = sumInputsCapacity - infoCellCapacity;
  const outputs: CKBComponents.CellOutput[] = [
    {
      lock: genRgbppLockScript(buildPreLockArgs(1), isMainnet, btcTestnetType),
      type: {
        ...getXudtTypeScript(isMainnet),
        args: append0x(scriptToHash(ownerLock)),
      },
      capacity: append0x(rgbppCellCapacity.toString(16)),
    },
    {
      lock: genBtcTimeLockScript(UNLOCKABLE_LOCK_SCRIPT, isMainnet, btcTestnetType),
      type: {
        ...getUniqueTypeScript(isMainnet),
        args: generateUniqueTypeArgs(inputs[0], 1),
      },
      capacity: append0x(infoCellCapacity.toString(16)),
    },
  ];

  const outputsData = [append0x(u128ToLe(launchAmount)), encodeRgbppTokenInfo(rgbppTokenInfo)];
  const cellDeps = await fetchTypeIdCellDeps(
    isMainnet,
    { rgbpp: true, xudt: true, unique: true },
    btcTestnetType,
    vendorCellDeps,
  );

  const witnesses: Hex[] = inputs.map((_, index) => (index === 0 ? RGBPP_WITNESS_PLACEHOLDER : '0x'));

  const ckbRawTx: CKBComponents.RawTransaction = {
    version: '0x0',
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses,
  };

  const txSize = getTransactionSize(ckbRawTx) + (witnessLockPlaceholderSize ?? RGBPP_TX_WITNESS_MAX_SIZE);
  const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);
  rgbppCellCapacity -= estimatedTxFee;
  ckbRawTx.outputs[0].capacity = append0x(rgbppCellCapacity.toString(16));

  const virtualTx: RgbppCkbVirtualTx = {
    ...ckbRawTx,
    outputs: ckbRawTx.outputs,
  };

  const commitment = calculateCommitment(virtualTx);

  return {
    ckbRawTx,
    commitment,
    needPaymasterCell: false,
  };
};


================================================
File: packages/ckb/src/rgbpp/schemas.spec.ts
================================================
import { describe, it, expect } from 'vitest';
import { buildRgbppUnlockWitness } from './ckb-builder';
import { buildBtcTimeUnlockWitness } from './btc-time';

describe('RGBPP schemas', () => {
  // The test data is from RGBPP lock contract test
  it('buildRgbppUnlockWitness', () => {
    const btcTx =
      '0x000000000181aad32adc6b05a424281403c9a835279247befaf84fe4c411bbcfaffe0a7cea0000000020a7c2244ec166e1fa756ba0e5562fd13ade25df22e9ced69dea8364c4671261b0000000000200000000000001f4226a2067b900ca0203de66033cff3d62bfbff11f41d43071f56b11e2818ee2aa6e2b0000000000000001f42097f437158a724699056fc27259a9a73b3b5f39792760bad78582ec334b81c16600000000';
    const txProof =
      '0xb900000014000000180000001c00000025000000020000002a0000000500000070726f6f660200000064000000e803000001000000000000000000000000000000000000000000000000000000000000000303030303030303030303030303030303030303030303030303030303030303e8030000d007000001000000000000000000000000000000000000000000000000000000000000000303030303030303030303030303030303030303030303030303030303030303';
    const inputsLen = 1;
    const outputsLen = 2;
    const rgbppUnlock = buildRgbppUnlockWitness(btcTx, txProof, inputsLen, outputsLen);
    expect(
      '0x80010000140000001600000018000000c300000000000102a7000000000000000181aad32adc6b05a424281403c9a835279247befaf84fe4c411bbcfaffe0a7cea0000000020a7c2244ec166e1fa756ba0e5562fd13ade25df22e9ced69dea8364c4671261b0000000000200000000000001f4226a2067b900ca0203de66033cff3d62bfbff11f41d43071f56b11e2818ee2aa6e2b0000000000000001f42097f437158a724699056fc27259a9a73b3b5f39792760bad78582ec334b81c16600000000b9000000b900000014000000180000001c00000025000000020000002a0000000500000070726f6f660200000064000000e803000001000000000000000000000000000000000000000000000000000000000000000303030303030303030303030303030303030303030303030303030303030303e8030000d007000001000000000000000000000000000000000000000000000000000000000000000303030303030303030303030303030303030303030303030303030303030303',
    ).toBe(rgbppUnlock);
  });

  it('buildBtcTimeUnlockWitness', () => {
    const txProof = '0x0102030405060708';
    const btcTimeUnlock = buildBtcTimeUnlockWitness(txProof);
    expect('0x1400000008000000080000000102030405060708').toBe(btcTimeUnlock);
  });
});


================================================
File: packages/ckb/src/schemas/customized.ts
================================================
import { createFixedBytesCodec, number } from '@ckb-lumos/codec';

const { Uint32, Uint64, Uint128 } = number;

/**
 * <pre>
 *  0b0000000 0
 *    ───┬─── │
 *       │    ▼
 *       │   type - the last bit indicates locating contract(script) via type hash and runs in the latest version of the CKB-VM
 *       │
 *       ▼
 * data* - the first 7 bits indicate locating contract(script) via code hash and runs in the specified version of the CKB-VM
 * </pre>
 *
 */
const HashType = createFixedBytesCodec<'data' | 'type' | 'data1' | 'data2'>({
  byteLength: 1,
  // prettier-ignore
  pack: (hashType) => {
    if (hashType === "type")  return new Uint8Array([0b0000000_1]);
    if (hashType === "data")  return new Uint8Array([0b0000000_0]);
    if (hashType === "data1") return new Uint8Array([0b0000001_0]);
    if (hashType === "data2") return new Uint8Array([0b0000010_0]);

    throw new Error('Unknown hash type')
  },
  unpack: (byte) => {
    if (byte[0] === 0b0000000_1) return 'type';
    if (byte[0] === 0b0000000_0) return 'data';
    if (byte[0] === 0b0000001_0) return 'data1';
    if (byte[0] === 0b0000010_0) return 'data2';

    throw new Error('Unknown hash type');
  },
});

const DepType = createFixedBytesCodec<'code' | 'depGroup'>({
  byteLength: 1,
  // prettier-ignore
  pack: (depType) => {
    if (depType === "code")     return new Uint8Array([0]);
    if (depType === "depGroup") return new Uint8Array([1]);

    throw new Error("Unknown dep type");
  },
  unpack: (byte) => {
    if (byte[0] === 0) return 'code';
    if (byte[0] === 1) return 'depGroup';

    throw new Error('Unknown dep type');
  },
});

export { Uint32, Uint64, Uint128, DepType, HashType };


================================================
File: packages/ckb/src/schemas/lumos-molecule-codegen.json
================================================
{
  "objectKeyFormat": "camelcase",
  "prepend": "import { Uint32, Uint64, Uint128, DepType, HashType } from './customized'",
  "schemaDir": "schemas",
  "outDir": "generated"
}


================================================
File: packages/ckb/src/schemas/generated/blockchain.ts
================================================
// This file is generated by @ckb-lumos/molecule, please do not modify it manually.
/* eslint-disable */
import { bytes, createBytesCodec, createFixedBytesCodec, molecule } from '@ckb-lumos/codec';
import { Uint32, Uint64, Uint128, DepType, HashType } from '../customized';

const { array, vector, union, option, struct, table, byteVecOf } = molecule;

const fallbackBytesCodec = byteVecOf({ pack: bytes.bytify, unpack: bytes.hexify });

function createFallbackFixedBytesCodec(byteLength: number) {
  return createFixedBytesCodec({
    pack: bytes.bytify,
    unpack: bytes.hexify,
    byteLength,
  });
}

const byte = createFallbackFixedBytesCodec(1);

export const Byte32 = createFallbackFixedBytesCodec(32);

export const Uint256 = createFallbackFixedBytesCodec(32);

export const Bytes = fallbackBytesCodec;

export const BytesOpt = option(Bytes);

export const BytesOptVec = vector(BytesOpt);

export const BytesVec = vector(Bytes);

export const Byte32Vec = vector(Byte32);

export const ProposalShortId = createFallbackFixedBytesCodec(10);

export const ProposalShortIdVec = vector(ProposalShortId);

export const Script = table(
  {
    codeHash: Byte32,
    hashType: byte,
    args: Bytes,
  },
  ['codeHash', 'hashType', 'args'],
);

export const OutPoint = struct(
  {
    txHash: Byte32,
    index: Uint32,
  },
  ['txHash', 'index'],
);

export const CellInput = struct(
  {
    since: Uint64,
    previousOutput: OutPoint,
  },
  ['since', 'previousOutput'],
);

export const CellDep = struct(
  {
    outPoint: OutPoint,
    depType: byte,
  },
  ['outPoint', 'depType'],
);

export const RawHeader = struct(
  {
    version: Uint32,
    compactTarget: Uint32,
    timestamp: Uint64,
    number: Uint64,
    epoch: Uint64,
    parentHash: Byte32,
    transactionsRoot: Byte32,
    proposalsHash: Byte32,
    extraHash: Byte32,
    dao: Byte32,
  },
  [
    'version',
    'compactTarget',
    'timestamp',
    'number',
    'epoch',
    'parentHash',
    'transactionsRoot',
    'proposalsHash',
    'extraHash',
    'dao',
  ],
);

export const Header = struct(
  {
    raw: RawHeader,
    nonce: Uint128,
  },
  ['raw', 'nonce'],
);

export const UncleBlock = table(
  {
    header: Header,
    proposals: ProposalShortIdVec,
  },
  ['header', 'proposals'],
);

export const CellbaseWitness = table(
  {
    lock: Script,
    message: Bytes,
  },
  ['lock', 'message'],
);

export const WitnessArgs = table(
  {
    lock: BytesOpt,
    inputType: BytesOpt,
    outputType: BytesOpt,
  },
  ['lock', 'inputType', 'outputType'],
);

export const ScriptOpt = option(Script);

export const UncleBlockVec = vector(UncleBlock);

export const CellDepVec = vector(CellDep);

export const CellInputVec = vector(CellInput);

export const CellOutput = table(
  {
    capacity: Uint64,
    lock: Script,
    type_: ScriptOpt,
  },
  ['capacity', 'lock', 'type_'],
);

export const CellOutputVec = vector(CellOutput);

export const RawTransaction = table(
  {
    version: Uint32,
    cellDeps: CellDepVec,
    headerDeps: Byte32Vec,
    inputs: CellInputVec,
    outputs: CellOutputVec,
    outputsData: BytesVec,
  },
  ['version', 'cellDeps', 'headerDeps', 'inputs', 'outputs', 'outputsData'],
);

export const Transaction = table(
  {
    raw: RawTransaction,
    witnesses: BytesVec,
  },
  ['raw', 'witnesses'],
);

export const TransactionVec = vector(Transaction);

export const Block = table(
  {
    header: Header,
    uncles: UncleBlockVec,
    transactions: TransactionVec,
    proposals: ProposalShortIdVec,
  },
  ['header', 'uncles', 'transactions', 'proposals'],
);

export const BlockV1 = table(
  {
    header: Header,
    uncles: UncleBlockVec,
    transactions: TransactionVec,
    proposals: ProposalShortIdVec,
    extension: Bytes,
  },
  ['header', 'uncles', 'transactions', 'proposals', 'extension'],
);


================================================
File: packages/ckb/src/schemas/generated/rgbpp.ts
================================================
// This file is generated by @ckb-lumos/molecule, please do not modify it manually.
/* eslint-disable */
import { bytes, createBytesCodec, createFixedBytesCodec, molecule } from '@ckb-lumos/codec';
import { Uint32, Uint64, Uint128, DepType, HashType } from '../customized';
import {
  Byte32,
  Uint256,
  Bytes,
  BytesOpt,
  BytesOptVec,
  BytesVec,
  Byte32Vec,
  ProposalShortId,
  ProposalShortIdVec,
  Script,
  OutPoint,
  CellInput,
  CellDep,
  RawHeader,
  Header,
  UncleBlock,
  CellbaseWitness,
  WitnessArgs,
  ScriptOpt,
  UncleBlockVec,
  CellDepVec,
  CellInputVec,
  CellOutput,
  CellOutputVec,
  RawTransaction,
  Transaction,
  TransactionVec,
  Block,
  BlockV1,
} from './blockchain';

const { array, vector, union, option, struct, table, byteVecOf } = molecule;

const fallbackBytesCodec = byteVecOf({ pack: bytes.bytify, unpack: bytes.hexify });

function createFallbackFixedBytesCodec(byteLength: number) {
  return createFixedBytesCodec({
    pack: bytes.bytify,
    unpack: bytes.hexify,
    byteLength,
  });
}

const byte = createFallbackFixedBytesCodec(1);

export const RGBPPConfig = struct(
  {
    btcLcTypeHash: Byte32,
    btcTimeLockTypeHash: Byte32,
  },
  ['btcLcTypeHash', 'btcTimeLockTypeHash'],
);

export const RGBPPLock = struct(
  {
    outIndex: Uint32,
    btcTxid: Byte32,
  },
  ['outIndex', 'btcTxid'],
);

export const ExtraCommitmentData = struct(
  {
    inputLen: byte,
    outputLen: byte,
  },
  ['inputLen', 'outputLen'],
);

export const Uint16 = createFallbackFixedBytesCodec(2);

export const RGBPPUnlock = table(
  {
    version: Uint16,
    extraData: ExtraCommitmentData,
    btcTx: Bytes,
    btcTxProof: Bytes,
  },
  ['version', 'extraData', 'btcTx', 'btcTxProof'],
);

export const BTCTimeLock = table(
  {
    lockScript: Script,
    after: Uint32,
    btcTxid: Byte32,
  },
  ['lockScript', 'after', 'btcTxid'],
);

export const BTCTimeLockConfig = struct(
  {
    btcLcTypeHash: Byte32,
  },
  ['btcLcTypeHash'],
);

export const BTCTimeUnlock = table(
  {
    btcTxProof: Bytes,
  },
  ['btcTxProof'],
);


================================================
File: packages/ckb/src/schemas/schemas/blockchain.mol
================================================

/* Basic Types */

// The `UintN` is used to store a `N` bits unsigned integer
// as a byte array in little endian.
array Uint32 [byte; 4];
array Uint64 [byte; 8];
array Uint128 [byte; 16];
array Byte32 [byte; 32];
array Uint256 [byte; 32];

vector Bytes <byte>;
option BytesOpt (Bytes);
vector BytesOptVec <BytesOpt>;
vector BytesVec <Bytes>;
vector Byte32Vec <Byte32>;

/* Types for Chain */

option ScriptOpt (Script);

array ProposalShortId [byte; 10];

vector UncleBlockVec <UncleBlock>;
vector TransactionVec <Transaction>;
vector ProposalShortIdVec <ProposalShortId>;
vector CellDepVec <CellDep>;
vector CellInputVec <CellInput>;
vector CellOutputVec <CellOutput>;

table Script {
    code_hash:      Byte32,
    hash_type:      byte,
    args:           Bytes,
}

struct OutPoint {
    tx_hash:        Byte32,
    index:          Uint32,
}

struct CellInput {
    since:           Uint64,
    previous_output: OutPoint,
}

table CellOutput {
    capacity:       Uint64,
    lock:           Script,
    type_:          ScriptOpt,
}

struct CellDep {
    out_point:      OutPoint,
    dep_type:       byte,
}

table RawTransaction {
    version:        Uint32,
    cell_deps:      CellDepVec,
    header_deps:    Byte32Vec,
    inputs:         CellInputVec,
    outputs:        CellOutputVec,
    outputs_data:   BytesVec,
}

table Transaction {
    raw:            RawTransaction,
    witnesses:      BytesVec,
}

struct RawHeader {
    version:                Uint32,
    compact_target:         Uint32,
    timestamp:              Uint64,
    number:                 Uint64,
    epoch:                  Uint64,
    parent_hash:            Byte32,
    transactions_root:      Byte32,
    proposals_hash:         Byte32,
    extra_hash:             Byte32,
    dao:                    Byte32,
}

struct Header {
    raw:                    RawHeader,
    nonce:                  Uint128,
}

table UncleBlock {
    header:                 Header,
    proposals:              ProposalShortIdVec,
}

table Block {
    header:                 Header,
    uncles:                 UncleBlockVec,
    transactions:           TransactionVec,
    proposals:              ProposalShortIdVec,
}

table BlockV1 {
    header:                 Header,
    uncles:                 UncleBlockVec,
    transactions:           TransactionVec,
    proposals:              ProposalShortIdVec,
    extension:              Bytes,
}

table CellbaseWitness {
    lock:    Script,
    message: Bytes,
}

table WitnessArgs {
    lock:                   BytesOpt,          // Lock args
    input_type:             BytesOpt,          // Type args for input
    output_type:            BytesOpt,          // Type args for output
}


================================================
File: packages/ckb/src/schemas/schemas/rgbpp.mol
================================================
import blockchain;
/* RGBPP Types */

// Type hash of bitcoin light client and type hash of bitcoin time lock contract
struct RGBPPConfig {
  btc_lc_type_hash: Byte32,
  btc_time_lock_type_hash: Byte32,
}

struct RGBPPLock {
  out_index: Uint32,
  btc_txid: Byte32,
}

struct ExtraCommitmentData {
 input_len: byte,
 output_len: byte,
}

array Uint16 [byte; 2];

table RGBPPUnlock {
  version: Uint16,
  extra_data: ExtraCommitmentData,
  btc_tx: Bytes,
  btc_tx_proof: Bytes,
}

table BTCTimeLock {
  lock_script: Script,
  after: Uint32,
  btc_txid: Byte32,
}

struct BTCTimeLockConfig {
  btc_lc_type_hash: Byte32,
}

table BTCTimeUnlock {
  btc_tx_proof: Bytes,
}

================================================
File: packages/ckb/src/spore/cluster.ts
================================================
import { packRawClusterData } from '@spore-sdk/core';
import { RgbppCkbVirtualTx } from '../types/rgbpp';
import {
  append0x,
  calculateTransactionFee,
  fetchTypeIdCellDeps,
  buildPreLockArgs,
  calculateCommitment,
  genRgbppLockScript,
  generateClusterCreateCoBuild,
  generateClusterId,
} from '../utils';
import { CreateClusterCkbVirtualTxParams, Hex, SporeVirtualTxResult } from '../types';
import {
  RGBPP_TX_WITNESS_MAX_SIZE,
  RGBPP_WITNESS_PLACEHOLDER,
  getClusterTypeDep,
  getClusterTypeScript,
} from '../constants';
import { NoRgbppLiveCellError } from '../error';
import { bytesToHex, getTransactionSize } from '@nervosnetwork/ckb-sdk-utils';

/**
 * Generate the virtual ckb transaction for creating cluster
 * @param collector The collector that collects CKB live cells and transactions
 * @param rgbppLockArgs The rgbpp assets cell lock script args whose data structure is: out_index | bitcoin_tx_id
 * @param clusterData The cluster's data, including name and description.
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)
 * @param witnessLockPlaceholderSize(Optional) The WitnessArgs.lock placeholder bytes array size and the default value is 5000
 * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100
 * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
 */
export const genCreateClusterCkbVirtualTx = async ({
  collector,
  rgbppLockArgs,
  clusterData,
  isMainnet,
  witnessLockPlaceholderSize,
  ckbFeeRate,
  btcTestnetType,
  vendorCellDeps,
}: CreateClusterCkbVirtualTxParams): Promise<SporeVirtualTxResult> => {
  const rgbppLock = genRgbppLockScript(rgbppLockArgs, isMainnet, btcTestnetType);
  const rgbppCells = await collector.getCells({ lock: rgbppLock });
  if (!rgbppCells || rgbppCells.length === 0) {
    throw new NoRgbppLiveCellError('No rgbpp cells found with the rgbpp lock args');
  }
  const rgbppCell = rgbppCells[0];

  const inputs: CKBComponents.CellInput[] = [
    {
      previousOutput: rgbppCell.outPoint,
      since: '0x0',
    },
  ];

  const clusterId = generateClusterId(inputs[0], 0);
  const outputs: CKBComponents.CellOutput[] = [
    {
      ...rgbppCell.output,
      // The BTC transaction Vouts[0] for OP_RETURN, Vouts[1] for cluster
      lock: genRgbppLockScript(buildPreLockArgs(1), isMainnet, btcTestnetType),
      type: {
        ...getClusterTypeScript(isMainnet),
        args: clusterId,
      },
    },
  ];
  const outputsData: Hex[] = [bytesToHex(packRawClusterData(clusterData))];
  const cellDeps = [
    ...(await fetchTypeIdCellDeps(isMainnet, { rgbpp: true }, btcTestnetType, vendorCellDeps)),
    getClusterTypeDep(isMainnet),
  ];
  const sporeCoBuild = generateClusterCreateCoBuild(outputs[0], outputsData[0]);
  const witnesses = [RGBPP_WITNESS_PLACEHOLDER, sporeCoBuild];

  const ckbRawTx: CKBComponents.RawTransaction = {
    version: '0x0',
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses,
  };

  let changeCapacity = BigInt(rgbppCell.output.capacity);
  const txSize = getTransactionSize(ckbRawTx) + (witnessLockPlaceholderSize ?? RGBPP_TX_WITNESS_MAX_SIZE);
  const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);
  changeCapacity -= estimatedTxFee;

  ckbRawTx.outputs[ckbRawTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));

  const virtualTx: RgbppCkbVirtualTx = {
    ...ckbRawTx,
  };
  const commitment = calculateCommitment(virtualTx);

  return {
    ckbRawTx,
    commitment,
    clusterId,
    needPaymasterCell: false,
  };
};


================================================
File: packages/ckb/src/spore/index.ts
================================================
export type { RawSporeData, RawClusterData } from '@spore-sdk/core';

export * from './cluster';
export * from './spore';
export * from './leap';


================================================
File: packages/ckb/src/spore/leap.ts
================================================
import { BtcTimeCellsParams, RgbppCkbVirtualTx } from '../types/rgbpp';
import {
  btcTxIdAndAfterFromBtcTimeLockArgs,
  buildSpvClientCellDep,
  calculateCommitment,
  compareInputs,
  genBtcTimeLockScript,
  lockScriptFromBtcTimeLockArgs,
  transformSpvProof,
  generateSporeTransferCoBuild,
  throwErrorWhenSporeCellsInvalid,
  append0x,
  fetchTypeIdCellDeps,
  calculateTransactionFee,
} from '../utils';
import {
  Hex,
  LeapSporeFromBtcToCkbVirtualTxParams,
  LeapSporeFromCkbToBtcVirtualTxParams,
  SporeLeapVirtualTxResult,
} from '../types';
import {
  RGBPP_TX_WITNESS_MAX_SIZE,
  RGBPP_WITNESS_PLACEHOLDER,
  getRgbppLockScript,
  getSporeTypeDep,
} from '../constants';
import { NoRgbppLiveCellError } from '../error';
import { buildBtcTimeUnlockWitness } from '../rgbpp';
import { blockchain } from '@ckb-lumos/base';
import {
  addressToScript,
  getTransactionSize,
  serializeOutPoint,
  serializeWitnessArgs,
} from '@nervosnetwork/ckb-sdk-utils';

/**
 * Generate the virtual ckb transaction for leaping spore from BTC to CKB
 * @param collector The collector that collects CKB live cells and transactions
 * @param sporeRgbppLockArgs The spore rgbpp cell lock script args whose data structure is: out_index | bitcoin_tx_id
 * @param sporeTypeBytes The spore type script serialized bytes
 * @param toCkbAddress The receiver ckb address
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)
 * @param witnessLockPlaceholderSize(Optional) The WitnessArgs.lock placeholder bytes array size and the default value is 5000
 * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100
 * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
 */
export const genLeapSporeFromBtcToCkbVirtualTx = async ({
  collector,
  sporeRgbppLockArgs,
  sporeTypeBytes,
  toCkbAddress,
  isMainnet,
  witnessLockPlaceholderSize,
  ckbFeeRate,
  btcTestnetType,
  vendorCellDeps,
}: LeapSporeFromBtcToCkbVirtualTxParams): Promise<SporeLeapVirtualTxResult> => {
  const sporeRgbppLock = {
    ...getRgbppLockScript(isMainnet, btcTestnetType),
    args: append0x(sporeRgbppLockArgs),
  };
  const sporeCells = await collector.getCells({ lock: sporeRgbppLock, isDataMustBeEmpty: false });

  throwErrorWhenSporeCellsInvalid(sporeCells, sporeTypeBytes, isMainnet);

  const sporeCell = sporeCells![0];

  const inputs: CKBComponents.CellInput[] = [
    {
      previousOutput: sporeCell.outPoint,
      since: '0x0',
    },
  ];

  const toLock = addressToScript(toCkbAddress);
  const outputs: CKBComponents.CellOutput[] = [
    {
      ...sporeCell.output,
      lock: genBtcTimeLockScript(toLock, isMainnet, btcTestnetType),
    },
  ];
  const outputsData: Hex[] = [sporeCell.outputData];
  const cellDeps = [
    ...(await fetchTypeIdCellDeps(isMainnet, { rgbpp: true }, btcTestnetType, vendorCellDeps)),
    getSporeTypeDep(isMainnet),
  ];
  const sporeCoBuild = generateSporeTransferCoBuild([sporeCell], outputs);
  const witnesses = [RGBPP_WITNESS_PLACEHOLDER, sporeCoBuild];

  const ckbRawTx: CKBComponents.RawTransaction = {
    version: '0x0',
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses,
  };

  let changeCapacity = BigInt(sporeCell.output.capacity);
  const txSize = getTransactionSize(ckbRawTx) + (witnessLockPlaceholderSize ?? RGBPP_TX_WITNESS_MAX_SIZE);
  const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);
  changeCapacity -= estimatedTxFee;

  ckbRawTx.outputs[ckbRawTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));

  const virtualTx: RgbppCkbVirtualTx = {
    ...ckbRawTx,
  };
  const commitment = calculateCommitment(virtualTx);

  return {
    ckbRawTx,
    commitment,
    sporeCell,
    needPaymasterCell: false,
    sumInputsCapacity: sporeCell.output.capacity,
  };
};

/**
 * Collect btc time cells and spend them to create spore cells for the specific lock scripts in the btc time lock args
 * The btc time lock args data structure is: lock_script | after | new_bitcoin_tx_id
 * @param btcTimeCells The BTC time cells of spore
 * @param btcAssetsApi BTC Assets Api
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)
 * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
 */
export const buildSporeBtcTimeCellsSpentTx = async ({
  btcTimeCells,
  btcAssetsApi,
  isMainnet,
  btcTestnetType,
  vendorCellDeps,
}: BtcTimeCellsParams): Promise<CKBComponents.RawTransaction> => {
  const sortedBtcTimeCells = btcTimeCells.sort(compareInputs);
  const inputs: CKBComponents.CellInput[] = sortedBtcTimeCells.map((cell) => ({
    previousOutput: cell.outPoint,
    since: '0x0',
  }));

  const outputs: CKBComponents.CellOutput[] = sortedBtcTimeCells.map((cell) => ({
    lock: lockScriptFromBtcTimeLockArgs(cell.output.lock.args),
    type: cell.output.type,
    capacity: cell.output.capacity,
  }));

  const outputsData = sortedBtcTimeCells.map((cell) => cell.outputData);

  const cellDeps: CKBComponents.CellDep[] = [
    ...(await fetchTypeIdCellDeps(isMainnet, { btcTime: true }, btcTestnetType, vendorCellDeps)),
    getSporeTypeDep(isMainnet),
  ];

  const witnesses: Hex[] = [];

  const lockArgsSet: Set<string> = new Set();
  const cellDepsSet: Set<string> = new Set();
  for await (const btcTimeCell of sortedBtcTimeCells) {
    if (lockArgsSet.has(btcTimeCell.output.lock.args)) {
      witnesses.push('0x');
      continue;
    }
    lockArgsSet.add(btcTimeCell.output.lock.args);
    const { btcTxId, after } = btcTxIdAndAfterFromBtcTimeLockArgs(btcTimeCell.output.lock.args);
    const result = await btcAssetsApi.getRgbppSpvProof(btcTxId, after);
    const { spvClient, proof } = transformSpvProof(result);

    if (!cellDepsSet.has(serializeOutPoint(spvClient))) {
      cellDeps.push(buildSpvClientCellDep(spvClient));
      cellDepsSet.add(serializeOutPoint(spvClient));
    }

    const btcTimeWitness = append0x(
      serializeWitnessArgs({ lock: buildBtcTimeUnlockWitness(proof), inputType: '', outputType: '' }),
    );
    witnesses.push(btcTimeWitness);
  }

  const sporeCoBuild = generateSporeTransferCoBuild(sortedBtcTimeCells, outputs);
  witnesses.push(sporeCoBuild);

  const ckbTx: CKBComponents.RawTransaction = {
    version: '0x0',
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses,
  };

  return ckbTx;
};

/**
 * Generate the virtual ckb transaction for leaping spore from CKB to BTC
 * @param collector The collector that collects CKB live cells and transactions
 * @param sporeRgbppLockArgs The spore rgbpp cell lock script args whose data structure is: out_index | bitcoin_tx_id
 * @param sporeTypeBytes The spore type script serialized bytes
 * @param toCkbAddress The receiver ckb address
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet
 * @param witnessLockPlaceholderSize(Optional) The WitnessArgs.lock placeholder bytes array size and the default value is 5000
 * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100
 */
export const genLeapSporeFromCkbToBtcRawTx = async ({
  collector,
  sporeTypeBytes,
  fromCkbAddress,
  toRgbppLockArgs,
  isMainnet,
  witnessLockPlaceholderSize,
  ckbFeeRate,
  btcTestnetType,
}: LeapSporeFromCkbToBtcVirtualTxParams): Promise<CKBComponents.RawTransaction> => {
  const fromLock = addressToScript(fromCkbAddress);
  const sporeType = blockchain.Script.unpack(sporeTypeBytes) as CKBComponents.Script;
  const sporeCells = await collector.getCells({ lock: fromLock, type: sporeType });
  if (!sporeCells || sporeCells.length === 0) {
    throw new NoRgbppLiveCellError('No spore rgbpp cells found with the spore rgbpp lock args and spore type script');
  }
  const sporeCell = sporeCells[0];

  const inputs: CKBComponents.CellInput[] = [
    {
      previousOutput: sporeCell.outPoint,
      since: '0x0',
    },
  ];

  const outputs: CKBComponents.CellOutput[] = [
    {
      ...sporeCell.output,
      lock: {
        ...getRgbppLockScript(isMainnet, btcTestnetType),
        args: append0x(toRgbppLockArgs),
      },
    },
  ];
  const outputsData: Hex[] = [sporeCell.outputData];
  const cellDeps = [getSporeTypeDep(isMainnet)];
  const sporeCoBuild = generateSporeTransferCoBuild([sporeCell], outputs);
  const witnesses = [RGBPP_WITNESS_PLACEHOLDER, sporeCoBuild];

  const ckbRawTx: CKBComponents.RawTransaction = {
    version: '0x0',
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses,
  };

  let changeCapacity = BigInt(sporeCell.output.capacity);
  const txSize = getTransactionSize(ckbRawTx) + (witnessLockPlaceholderSize ?? RGBPP_TX_WITNESS_MAX_SIZE);
  const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);
  changeCapacity -= estimatedTxFee;

  ckbRawTx.outputs[ckbRawTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));

  return ckbRawTx;
};


================================================
File: packages/ckb/src/spore/spore.ts
================================================
import { RgbppCkbVirtualTx } from '../types/rgbpp';
import { packRawSporeData } from '@spore-sdk/core';
import {
  append0x,
  calculateRgbppSporeCellCapacity,
  calculateTransactionFee,
  fetchTypeIdCellDeps,
  isClusterSporeTypeSupported,
  buildPreLockArgs,
  calculateCommitment,
  genRgbppLockScript,
  generateSporeCreateCoBuild,
  generateSporeId,
  generateSporeTransferCoBuild,
  throwErrorWhenSporeCellsInvalid,
  addressToScriptHash,
  signCkbTransaction,
} from '../utils';
import {
  AppendIssuerCellToSporeCreate,
  BuildAppendingIssuerCellTxParams,
  CreateSporeCkbVirtualTxParams,
  Hex,
  SporeCreateVirtualTxResult,
  SporeTransferVirtualTxResult,
  TransferSporeCkbVirtualTxParams,
} from '../types';
import {
  MAX_FEE,
  MIN_CAPACITY,
  RGBPP_TX_WITNESS_MAX_SIZE,
  RGBPP_WITNESS_PLACEHOLDER,
  SECP256K1_WITNESS_LOCK_SIZE,
  getClusterTypeDep,
  getRgbppLockScript,
  getSecp256k1CellDep,
  getSporeTypeDep,
  getSporeTypeScript,
} from '../constants';
import {
  NoLiveCellError,
  NoRgbppLiveCellError,
  RgbppUtxoBindMultiTypeAssetsError,
  TypeAssetNotSupportedError,
} from '../error';
import { addressToScript, bytesToHex, getTransactionSize } from '@nervosnetwork/ckb-sdk-utils';

/**
 * Generate the virtual ckb transaction for creating spores
 * @param collector The collector that collects CKB live cells and transactions
 * @param clusterRgbppLockArgs The cluster rgbpp cell lock script args whose data structure is: out_index | bitcoin_tx_id
 * @param sporeDataList The spore's data list, including name and description.
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)
 * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
 */
export const genCreateSporeCkbVirtualTx = async ({
  collector,
  clusterRgbppLockArgs,
  sporeDataList,
  isMainnet,
  btcTestnetType,
  vendorCellDeps,
}: CreateSporeCkbVirtualTxParams): Promise<SporeCreateVirtualTxResult> => {
  const clusterRgbppLock = genRgbppLockScript(clusterRgbppLockArgs, isMainnet, btcTestnetType);
  const clusterCells = await collector.getCells({ lock: clusterRgbppLock, isDataMustBeEmpty: false });
  if (!clusterCells || clusterCells.length === 0) {
    throw new NoRgbppLiveCellError('No cluster rgbpp cells found with the cluster rgbpp lock args');
  }
  if (clusterCells.length > 1) {
    throw new RgbppUtxoBindMultiTypeAssetsError('The BTC UTXO must not be bound to multiple CKB cells');
  }
  const clusterCell = clusterCells[0];

  if (!clusterCell.output.type || !isClusterSporeTypeSupported(clusterCell.output.type, isMainnet)) {
    throw new TypeAssetNotSupportedError('The type script asset is not supported now');
  }

  const sumInputsCapacity = clusterCell.output.capacity;

  const inputs: CKBComponents.CellInput[] = [
    {
      previousOutput: clusterCell.outPoint,
      since: '0x0',
    },
  ];

  const clusterCellDep: CKBComponents.CellDep = {
    outPoint: clusterCell.outPoint,
    depType: 'code',
  };

  const sporeOutputs = sporeDataList.map((data, index) => ({
    // The BTC transaction Vouts[0] for OP_RETURN, Vouts[1] for cluster and Vouts[2]... for spore
    lock: genRgbppLockScript(buildPreLockArgs(index + 2), isMainnet, btcTestnetType),
    type: {
      ...getSporeTypeScript(isMainnet),
      // The CKB transaction outputs[0] fro cluster and outputs[1]... for spore
      args: generateSporeId(inputs[0], index + 1),
    },
    capacity: append0x(calculateRgbppSporeCellCapacity(data).toString(16)),
  }));
  const sporeOutputsData = sporeDataList.map((data) => bytesToHex(packRawSporeData(data)));

  const outputs: CKBComponents.CellOutput[] = [
    {
      ...clusterCell.output,
      // The BTC transaction Vouts[0] for OP_RETURN, Vouts[1] for cluster
      lock: genRgbppLockScript(buildPreLockArgs(1), isMainnet, btcTestnetType),
    },
    ...sporeOutputs,
  ];
  const outputsData: Hex[] = [clusterCell.outputData, ...sporeOutputsData];
  const cellDeps = [
    ...(await fetchTypeIdCellDeps(isMainnet, { rgbpp: true }, btcTestnetType, vendorCellDeps)),
    getClusterTypeDep(isMainnet),
    getSporeTypeDep(isMainnet),
    clusterCellDep,
  ];
  const sporeCoBuild = generateSporeCreateCoBuild({
    sporeOutputs,
    sporeOutputsData,
    clusterCell,
    clusterOutputCell: outputs[0],
  });
  const witnesses = [RGBPP_WITNESS_PLACEHOLDER, sporeCoBuild];

  const ckbRawTx: CKBComponents.RawTransaction = {
    version: '0x0',
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses,
  };

  const virtualTx: RgbppCkbVirtualTx = {
    ...ckbRawTx,
  };
  const commitment = calculateCommitment(virtualTx);

  return {
    ckbRawTx,
    commitment,
    sumInputsCapacity,
    clusterCell,
    needPaymasterCell: false,
  };
};

const CELL_DEP_SIZE = 32 + 4 + 1;

/**
 * Append paymaster cell to the ckb transaction inputs and build the raw tx to be signed for spores creation
 * @param issuerAddress The issuer ckb address
 * @param collector The collector that collects CKB live cells and transactions
 * @param ckbRawTx CKB raw transaction
 * @param sumInputsCapacity The sum capacity of ckb inputs which is to be used to calculate ckb tx fee
 * @param witnessLockPlaceholderSize(Optional) The WitnessArgs.lock placeholder bytes array size and the default value is 65
 * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100
 */
export const buildAppendingIssuerCellToSporesCreateTx = async ({
  issuerAddress,
  collector,
  ckbRawTx,
  sumInputsCapacity,
  witnessLockPlaceholderSize = SECP256K1_WITNESS_LOCK_SIZE,
  ckbFeeRate,
}: BuildAppendingIssuerCellTxParams): Promise<CKBComponents.RawTransactionToSign> => {
  const rawTx = ckbRawTx as CKBComponents.RawTransactionToSign;

  const sumOutputsCapacity: bigint = rawTx.outputs
    .map((output) => BigInt(output.capacity))
    .reduce((prev, current) => prev + current, BigInt(0));

  const issuerLock = addressToScript(issuerAddress);
  let emptyCells = await collector.getCells({ lock: issuerLock });
  if (!emptyCells || emptyCells.length === 0) {
    throw new NoLiveCellError('The issuer address has no empty cells');
  }
  emptyCells = emptyCells.filter((cell) => !cell.output.type);

  let actualInputsCapacity = BigInt(sumInputsCapacity);
  const txFee = MAX_FEE;
  if (actualInputsCapacity <= sumOutputsCapacity) {
    const needCapacity = sumOutputsCapacity - actualInputsCapacity + MIN_CAPACITY;
    const { inputs, sumInputsCapacity: sumEmptyCapacity } = collector.collectInputs(emptyCells, needCapacity, txFee);
    rawTx.inputs = [...rawTx.inputs, ...inputs];
    actualInputsCapacity += sumEmptyCapacity;
  }

  let changeCapacity = actualInputsCapacity - sumOutputsCapacity;
  const changeOutput = {
    lock: issuerLock,
    capacity: append0x(changeCapacity.toString(16)),
  };
  rawTx.outputs = [...rawTx.outputs, changeOutput];
  rawTx.outputsData = [...rawTx.outputsData, '0x'];

  const txSize = getTransactionSize(rawTx) + witnessLockPlaceholderSize + CELL_DEP_SIZE;
  const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);
  changeCapacity -= estimatedTxFee;
  rawTx.outputs[rawTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));

  return rawTx;
};

export const appendIssuerCellToSporesCreateUnsignedTx = async ({
  ckbRawTx,
  isMainnet,
  issuerAddress,
  collector,
  sumInputsCapacity,
  ckbFeeRate,
}: Omit<AppendIssuerCellToSporeCreate, 'secp256k1PrivateKey'>): Promise<{
  ckbRawTx: CKBComponents.RawTransactionToSign;
  inputCells: { outPoint: CKBComponents.OutPoint; lock: CKBComponents.Script }[];
}> => {
  const rgbppInputsLength = ckbRawTx.inputs.length;

  const rawTx = await buildAppendingIssuerCellToSporesCreateTx({
    issuerAddress,
    collector,
    ckbRawTx,
    sumInputsCapacity,
    ckbFeeRate,
  });

  rawTx.cellDeps = [...rawTx.cellDeps, getSecp256k1CellDep(isMainnet)];

  const issuerLock = addressToScript(issuerAddress);

  const issuerCellIndex = rgbppInputsLength;
  const cells = rawTx.inputs.map((input, index) => ({
    outPoint: input.previousOutput as CKBComponents.OutPoint,
    lock: index >= issuerCellIndex ? issuerLock : getRgbppLockScript(isMainnet),
  }));

  const emptyWitness = { lock: '', inputType: '', outputType: '' };
  const issuerWitnesses = rawTx.inputs.slice(rgbppInputsLength).map((_, index) => (index === 0 ? emptyWitness : '0x'));

  const lastRawTxWitnessIndex = rawTx.witnesses.length - 1;
  rawTx.witnesses = [
    ...rawTx.witnesses.slice(0, lastRawTxWitnessIndex),
    ...issuerWitnesses,
    // The cobuild witness will be placed to the tail of the witnesses
    rawTx.witnesses[lastRawTxWitnessIndex],
  ];

  return { ckbRawTx: rawTx, inputCells: cells };
};

/**
 * Append paymaster cell to the ckb transaction inputs and sign the transaction with paymaster cell's secp256k1 private key
 * @param secp256k1PrivateKey The Secp256k1 private key of the paymaster cells maintainer
 * @param issuerAddress The issuer ckb address
 * @param collector The collector that collects CKB live cells and transactions
 * @param ckbRawTx CKB raw transaction
 * @param sumInputsCapacity The sum capacity of ckb inputs which is to be used to calculate ckb tx fee
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)
 * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100
 */
export const appendIssuerCellToSporesCreate = async ({
  secp256k1PrivateKey,
  issuerAddress,
  collector,
  ckbRawTx,
  sumInputsCapacity,
  isMainnet,
  ckbFeeRate,
}: AppendIssuerCellToSporeCreate): Promise<CKBComponents.RawTransaction> => {
  const { ckbRawTx: rawTx, inputCells } = await appendIssuerCellToSporesCreateUnsignedTx({
    ckbRawTx,
    isMainnet,
    issuerAddress,
    collector,
    sumInputsCapacity,
    ckbFeeRate,
  });

  const keyMap = new Map<string, string>();
  keyMap.set(addressToScriptHash(issuerAddress), secp256k1PrivateKey);
  return signCkbTransaction(keyMap, rawTx, inputCells, true);
};

/**
 * Generate the virtual ckb transaction for transferring spore
 * @param collector The collector that collects CKB live cells and transactions
 * @param sporeRgbppLockArgs The spore rgbpp cell lock script args whose data structure is: out_index | bitcoin_tx_id
 * @param sporeTypeBytes The spore type script serialized bytes
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)
 * @param witnessLockPlaceholderSize(Optional) The WitnessArgs.lock placeholder bytes array size and the default value is 5000
 * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100
 * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
 */
export const genTransferSporeCkbVirtualTx = async ({
  collector,
  sporeRgbppLockArgs,
  sporeTypeBytes,
  isMainnet,
  witnessLockPlaceholderSize,
  ckbFeeRate,
  btcTestnetType,
  vendorCellDeps,
}: TransferSporeCkbVirtualTxParams): Promise<SporeTransferVirtualTxResult> => {
  const sporeRgbppLock = genRgbppLockScript(sporeRgbppLockArgs, isMainnet, btcTestnetType);
  const sporeCells = await collector.getCells({ lock: sporeRgbppLock, isDataMustBeEmpty: false });

  throwErrorWhenSporeCellsInvalid(sporeCells, sporeTypeBytes, isMainnet);

  const sporeCell = sporeCells![0];

  const inputs: CKBComponents.CellInput[] = [
    {
      previousOutput: sporeCell.outPoint,
      since: '0x0',
    },
  ];

  const outputs: CKBComponents.CellOutput[] = [
    {
      ...sporeCell.output,
      // The BTC transaction Vouts[0] for OP_RETURN, Vouts[1] for spore
      lock: genRgbppLockScript(buildPreLockArgs(1), isMainnet, btcTestnetType),
    },
  ];
  const outputsData: Hex[] = [sporeCell.outputData];
  const cellDeps = [
    ...(await fetchTypeIdCellDeps(isMainnet, { rgbpp: true }, btcTestnetType, vendorCellDeps)),
    getSporeTypeDep(isMainnet),
  ];
  const sporeCoBuild = generateSporeTransferCoBuild([sporeCell], outputs);
  const witnesses = [RGBPP_WITNESS_PLACEHOLDER, sporeCoBuild];

  const ckbRawTx: CKBComponents.RawTransaction = {
    version: '0x0',
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses,
  };

  let changeCapacity = BigInt(sporeCell.output.capacity);
  const txSize = getTransactionSize(ckbRawTx) + (witnessLockPlaceholderSize ?? RGBPP_TX_WITNESS_MAX_SIZE);
  const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);
  changeCapacity -= estimatedTxFee;

  ckbRawTx.outputs[ckbRawTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));

  const virtualTx: RgbppCkbVirtualTx = {
    ...ckbRawTx,
  };
  const commitment = calculateCommitment(virtualTx);

  return {
    ckbRawTx,
    commitment,
    sporeCell,
    needPaymasterCell: false,
    sumInputsCapacity: sporeCell.output.capacity,
  };
};


================================================
File: packages/ckb/src/types/collector.ts
================================================
import { Capacity, Hex } from './common';

export interface IndexerCell {
  blockNumber: CKBComponents.BlockNumber;
  outPoint: CKBComponents.OutPoint;
  output: CKBComponents.CellOutput;
  outputData: Hex;
  txIndex: Hex;
}

export interface IndexerCapacity {
  blockNumber: CKBComponents.BlockNumber;
  blockHash: CKBComponents.Hash;
  capacity: Hex;
}

export interface CollectResult {
  inputs: CKBComponents.CellInput[];
  sumInputsCapacity: Capacity;
}

export interface CollectUdtResult extends CollectResult {
  sumAmount: bigint;
}

export interface CollectConfig {
  minCapacity?: bigint;
  errMsg?: string;
}


================================================
File: packages/ckb/src/types/common.ts
================================================
export type Hex = string;
export type U32 = bigint;
export type Address = string;
export type Capacity = bigint;

export type BTCTestnetType = 'Testnet3' | 'Signet';


================================================
File: packages/ckb/src/types/index.ts
================================================
export * from './common';
export * from './collector';
export * from './rgbpp';
export * from './spv';
export * from './spore';


================================================
File: packages/ckb/src/types/rgbpp.ts
================================================
import { BtcAssetsApi, RgbppApiSpvProof } from '@rgbpp-sdk/service';
import { Collector } from '../collector';
import { IndexerCell } from './collector';
import { Address, Hex, BTCTestnetType } from './common';
import { CellDepsObject } from '../utils/cell-dep';

export interface ConstructPaymasterParams {
  // The collector that collects CKB live cells and transactions
  collector: Collector;
  // The Secp256k1 private key of the cold key maintainer
  masterPrivateKey: Hex;
  // The ckb address of paymaster cells maintainer
  receiverAddress: Address;
  // The Capacity(the unit is CKB) of each paymaster cell
  capacityWithCKB: number;
  // The amount of paymaster cells to be produced
  cellAmount: number;
}

export interface BtcTransferVirtualTxParams {
  // The collector that collects CKB live cells and transactions
  collector: Collector;
  // The serialized hex string of the XUDT type script
  xudtTypeBytes: Hex;
  // The rgbpp assets cell lock script args array whose data structure is: out_index | bitcoin_tx_id
  rgbppLockArgsList: Hex[];
  // The XUDT amount to be transferred, if the noMergeOutputCells is true, the transferAmount will be ignored
  transferAmount: bigint;
  // True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)
  isMainnet: boolean;
  // The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
  btcTestnetType?: BTCTestnetType;
  // The noMergeOutputCells indicates whether the CKB outputs need to be merged. By default, the outputs will be merged.
  noMergeOutputCells?: boolean;
  // The WitnessArgs.lock placeholder bytes array size and the default value is 5000
  witnessLockPlaceholderSize?: number;
  // The CKB transaction fee rate, default value is 1100
  ckbFeeRate?: bigint;

  /*
   * Vendor cell deps provided by the caller.
   * These cell deps belong to scripts that may be upgraded in the future.
   * Please ensure the cell dep information is up to date. The latest cell dep information is maintained at:
   * https://raw.githubusercontent.com/utxostack/typeid-contract-cell-deps/main/deployment/cell-deps.json.
   */
  vendorCellDeps?: CellDepsObject;
}

export interface RgbppBtcAddressReceiver {
  // The BTC address
  toBtcAddress: string;
  // The XUDT amount to be transferred
  transferAmount: bigint;
}

export interface BtcBatchTransferVirtualTxParams {
  // The collector that collects CKB live cells and transactions
  collector: Collector;
  // The serialized hex string of the XUDT type script
  xudtTypeBytes: Hex;
  // The rgbpp assets cell lock script args array whose data structure is: out_index | bitcoin_tx_id
  rgbppLockArgsList: Hex[];
  // The rgbpp receiver list which include toRgbppLockArgs and transferAmount
  rgbppReceivers: RgbppBtcAddressReceiver[];
  // True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)
  isMainnet: boolean;
  // The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
  btcTestnetType?: BTCTestnetType;

  /*
   * Vendor cell deps provided by the caller.
   * These cell deps belong to scripts that may be upgraded in the future.
   * Please ensure the cell dep information is up to date. The latest cell dep information is maintained at:
   * https://raw.githubusercontent.com/utxostack/typeid-contract-cell-deps/main/deployment/cell-deps.json.
   */
  vendorCellDeps?: CellDepsObject;
}

export interface RgbppCkbVirtualTx {
  // The rgbpp inputs whose lock scripts must be rgbpp lock and type scripts must be XUDT type
  inputs: CKBComponents.CellInput[];
  // The rgbpp outputs whose lock scripts must be rgbpp lock or btc time lock and type scripts must be XUDT type
  outputs: CKBComponents.CellOutput[];
  // The outputsData must be XUDT cell data(16bytes XUDT amount)
  outputsData: Hex[];
}

export interface BaseCkbVirtualTxResult {
  // CKB raw transaction
  ckbRawTx: CKBComponents.RawTransaction;
  // The rgbpp commitment to be inserted into BTC op_return
  commitment: Hex;
  // The needPaymasterCell indicates whether a paymaster cell is required
  needPaymasterCell: boolean;
  // The sum capacity of the ckb inputs
  sumInputsCapacity: Hex;
}

export interface BtcTransferVirtualTxResult extends BaseCkbVirtualTxResult {}

export interface BtcBatchTransferVirtualTxResult extends BaseCkbVirtualTxResult {
  rgbppChangeOutIndex: number;
}

export interface RgbppLaunchVirtualTxResult {
  // CKB raw transaction
  ckbRawTx: CKBComponents.RawTransaction;
  // The rgbpp commitment to be inserted into BTC op_return
  commitment: Hex;
  // The needPaymasterCell indicates whether a paymaster cell is required
  needPaymasterCell: boolean;
}

export interface AppendWitnessesParams {
  // CKB raw transaction
  ckbRawTx: CKBComponents.RawTransaction;
  // The SPV client cell and tx proof which is from BTCAssetsApi
  rgbppApiSpvProof: RgbppApiSpvProof;
  // The hex string of btc transaction, refer to https://github.com/bitcoinjs/bitcoinjs-lib/blob/master/ts_src/transaction.ts#L609
  btcTxBytes: Hex;
}

export interface AppendPaymasterCellAndSignTxParams {
  // The Secp256k1 private key of the paymaster cells maintainer
  secp256k1PrivateKey: Hex;
  // CKB raw transaction
  ckbRawTx: CKBComponents.RawTransaction;
  // The sum capacity of the ckb inputs
  sumInputsCapacity: Hex;
  // The paymaster cell to be inserted into CKB transaction to pay an extra output cell
  paymasterCell: IndexerCell;
  // True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet
  isMainnet: boolean;
  // The CKB transaction fee rate, default value is 1100
  ckbFeeRate?: bigint;
}

export interface SendCkbTxParams {
  // The collector that collects CKB live cells and transactions
  collector: Collector;
  // The signed CKB transaction which can be sent to CKB blockchain node
  signedTx: CKBComponents.RawTransaction;
}

export interface BtcJumpCkbVirtualTxParams extends BtcTransferVirtualTxParams {
  // The receiver ckb address
  toCkbAddress: Address;
  // The BTC confirmation blocks for BTC Time lock args, default value is 6
  btcConfirmationBlocks?: number;
}

export interface BtcJumpCkbVirtualTxResult extends BaseCkbVirtualTxResult {}

export interface BtcTimeCellsParams {
  // The BTC time cells
  btcTimeCells: IndexerCell[];
  // BTC Assets Api
  btcAssetsApi: BtcAssetsApi;
  // True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet
  isMainnet: boolean;
  // The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
  btcTestnetType?: BTCTestnetType;

  /*
   * Vendor cell deps provided by the caller.
   * These cell deps belong to scripts that may be upgraded in the future.
   * Please ensure the cell dep information is up to date. The latest cell dep information is maintained at:
   * https://raw.githubusercontent.com/utxostack/typeid-contract-cell-deps/main/deployment/cell-deps.json.
   */
  vendorCellDeps?: CellDepsObject;
}

export interface SignBtcTimeCellsTxParams {
  // The Secp256k1 private key of the master address
  secp256k1PrivateKey: Hex;
  // CKB raw transaction
  ckbRawTx: CKBComponents.RawTransaction;
  // The collector that collects CKB live cells and transactions
  collector: Collector;
  // The master CKB address to pay the time cells spent tx fee
  masterCkbAddress: Address;
  // True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet
  isMainnet: boolean;
  // [u64; 2], filter cells by output capacity range, [inclusive, exclusive]
  outputCapacityRange?: Hex[];
  // The CKB transaction fee rate, default value is 1100
  ckbFeeRate?: bigint;
}

export interface CkbJumpBtcVirtualTxParams {
  // The collector that collects CKB live cells and transactions
  collector: Collector;
  // The serialized hex string of the XUDT type script
  xudtTypeBytes: Hex;
  // The from ckb address who will use his private key to sign the ckb tx
  fromCkbAddress: Address;
  // The receiver rgbpp lock script args whose data structure is: out_index | bitcoin_tx_id
  toRgbppLockArgs: Hex;
  // The XUDT amount to be transferred
  transferAmount: bigint;
  // The WitnessArgs.lock placeholder bytes array size and the default value is 5000
  witnessLockPlaceholderSize?: number;
  // The CKB transaction fee rate, default value is 1100
  ckbFeeRate?: bigint;
  // The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
  btcTestnetType?: BTCTestnetType;

  /*
   * Vendor cell deps provided by the caller.
   * These cell deps belong to scripts that may be upgraded in the future.
   * Please ensure the cell dep information is up to date. The latest cell dep information is maintained at:
   * https://raw.githubusercontent.com/utxostack/typeid-contract-cell-deps/main/deployment/cell-deps.json.
   */
  vendorCellDeps?: CellDepsObject;
}

export interface UpdateCkbTxWithRealBtcTxIdParams {
  // CKB raw transaction
  ckbRawTx: CKBComponents.RawTransaction;
  // The BTC transaction id
  btcTxId: Hex;
  // True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet
  isMainnet: boolean;
}

export interface BtcTimeCellStatusParams {
  // The collector that collects CKB live cells and transactions
  collector: Collector;
  // The ckb address who is the receiver of the btc time lock args
  ckbAddress: Address;
  // The BTC transaction id
  btcTxId: Hex;
  // The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
  btcTestnetType?: BTCTestnetType;
}

export interface RgbppLockArgsReceiver {
  // The receiver rgbpp lock script args whose data structure is: out_index | bitcoin_tx_id
  toRgbppLockArgs: Hex;
  // The XUDT amount to be transferred
  transferAmount: bigint;
}

export interface CkbBatchJumpBtcVirtualTxParams {
  // The collector that collects CKB live cells and transactions
  collector: Collector;
  // The serialized hex string of the XUDT type script
  xudtTypeBytes: Hex;
  // The from ckb address who will use his private key to sign the ckb tx
  fromCkbAddress: Address;
  // The rgbpp receiver list which include toRgbppLockArgs and transferAmount
  rgbppReceivers: RgbppLockArgsReceiver[];
  // The WitnessArgs.lock placeholder bytes array size and the default value is 5000
  witnessLockPlaceholderSize?: number;
  // The CKB transaction fee rate, default value is 1100
  ckbFeeRate?: bigint;
  // The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
  btcTestnetType?: BTCTestnetType;

  /*
   * Vendor cell deps provided by the caller.
   * These cell deps belong to scripts that may be upgraded in the future.
   * Please ensure the cell dep information is up to date. The latest cell dep information is maintained at:
   * https://raw.githubusercontent.com/utxostack/typeid-contract-cell-deps/main/deployment/cell-deps.json.
   */
  vendorCellDeps?: CellDepsObject;
}

export interface AppendIssuerCellToBtcBatchTransfer {
  // The Secp256k1 private key of the issuer cells maintainer
  secp256k1PrivateKey: Hex;
  // The issuer ckb address
  issuerAddress: Address;
  // The collector that collects CKB live cells and transactions
  collector: Collector;
  // CKB raw transaction
  ckbRawTx: CKBComponents.RawTransaction;
  // The sum capacity of the ckb inputs
  sumInputsCapacity: Hex;
  // True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet
  isMainnet: boolean;
  // The CKB transaction fee rate, default value is 1100
  ckbFeeRate?: bigint;
}

/**
 * @see {@link https://github.com/ckb-cell/unique-cell?tab=readme-ov-file#xudt-information} for the definition of xUDT information
 */
export interface RgbppTokenInfo {
  // The number of decimals the RGBPP token uses
  decimal: number;
  // The name of the RGBPP token, and maximum number of characters is 255
  name: string;
  // The symbol of the RGBPP token, and maximum number of characters is 255
  symbol: string;
}

export interface RgbppLaunchCkbVirtualTxParams {
  // The collector that collects CKB live cells and transactions
  collector: Collector;
  // The owner RGBPP lock args whose data structure is: out_index | bitcoin_tx_id
  ownerRgbppLockArgs: Address;
  // The total amount of RGBPP assets issued
  launchAmount: bigint;
  // The RGBPP token info https://github.com/ckb-cell/unique-cell?tab=readme-ov-file#xudt-information
  rgbppTokenInfo: RgbppTokenInfo;
  // True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)
  isMainnet: boolean;
  // The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
  btcTestnetType?: BTCTestnetType;
  // The WitnessArgs.lock placeholder bytes array size and the default value is 5000
  witnessLockPlaceholderSize?: number;
  // The CKB transaction fee rate, default value is 1100
  ckbFeeRate?: bigint;

  /*
   * Vendor cell deps provided by the caller.
   * These cell deps belong to scripts that may be upgraded in the future.
   * Please ensure the cell dep information is up to date. The latest cell dep information is maintained at:
   * https://raw.githubusercontent.com/utxostack/typeid-contract-cell-deps/main/deployment/cell-deps.json.
   */
  vendorCellDeps?: CellDepsObject;
}


================================================
File: packages/ckb/src/types/spore.ts
================================================
import { RawClusterData, RawSporeData } from '@spore-sdk/core';
import { Address, Hex, BTCTestnetType } from './common';
import { Collector } from '../collector';
import { IndexerCell } from './collector';
import { CellDepsObject } from '../utils/cell-dep';

export interface CreateClusterCkbVirtualTxParams {
  // The collector that collects CKB live cells and transactions
  collector: Collector;
  // The rgbpp assets cell lock script args whose data structure is: out_index | bitcoin_tx_id
  rgbppLockArgs: Hex;
  // The cluster's data, including name and description.
  clusterData: RawClusterData;
  // True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet
  isMainnet: boolean;
  // The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
  btcTestnetType?: BTCTestnetType;
  // The WitnessArgs.lock placeholder bytes array size and the default value is 5000
  witnessLockPlaceholderSize?: number;
  // The CKB transaction fee rate, default value is 1100
  ckbFeeRate?: bigint;

  /*
   * Vendor cell deps provided by the caller.
   * These cell deps belong to scripts that may be upgraded in the future.
   * Please ensure the cell dep information is up to date. The latest cell dep information is maintained at:
   * https://raw.githubusercontent.com/utxostack/typeid-contract-cell-deps/main/deployment/cell-deps.json.
   */
  vendorCellDeps?: CellDepsObject;
}

export interface SporeVirtualTxResult {
  // CKB raw transaction
  ckbRawTx: CKBComponents.RawTransaction;
  // The rgbpp commitment to be inserted into BTC op_return
  commitment: Hex;
  // The needPaymasterCell indicates whether a paymaster cell is required
  needPaymasterCell: boolean;
  // The ID of the cluster to be assigned to the spore. The cluster's ID is equivalent to the type script args of the cluster
  clusterId?: Hex;
}

export interface CreateSporeCkbVirtualTxParams {
  // The collector that collects CKB live cells and transactions
  collector: Collector;
  // The cluster rgbpp cell lock script args whose data structure is: out_index | bitcoin_tx_id
  clusterRgbppLockArgs: Hex;
  // The cluster's data, including name and description.
  sporeDataList: RawSporeData[];
  // True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet
  isMainnet: boolean;
  // The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
  btcTestnetType?: BTCTestnetType;
  // The WitnessArgs.lock placeholder bytes array size and the default value is 5000
  witnessLockPlaceholderSize?: number;
  // The CKB transaction fee rate, default value is 1100
  ckbFeeRate?: bigint;

  /*
   * Vendor cell deps provided by the caller.
   * These cell deps belong to scripts that may be upgraded in the future.
   * Please ensure the cell dep information is up to date. The latest cell dep information is maintained at:
   * https://raw.githubusercontent.com/utxostack/typeid-contract-cell-deps/main/deployment/cell-deps.json.
   */
  vendorCellDeps?: CellDepsObject;
}

export interface SporeCreateVirtualTxResult {
  // CKB raw transaction
  ckbRawTx: CKBComponents.RawTransaction;
  // The rgbpp commitment to be inserted into BTC op_return
  commitment: Hex;
  // The sum capacity of the ckb inputs
  sumInputsCapacity: Hex;
  // The cluster cell from ckb-indexer
  clusterCell: IndexerCell;
  // The needPaymasterCell indicates whether a paymaster cell is required
  needPaymasterCell: boolean;
}

export interface BuildAppendingIssuerCellTxParams {
  // The issuer ckb address
  issuerAddress: Address;
  // The collector that collects CKB live cells and transactions
  collector: Collector;
  // CKB raw transaction
  ckbRawTx: CKBComponents.RawTransaction;
  // The sum capacity of the ckb inputs
  sumInputsCapacity: Hex;
  // The WitnessArgs.lock placeholder bytes array size and the default value is 5000
  witnessLockPlaceholderSize?: number;
  // The CKB transaction fee rate, default value is 1100
  ckbFeeRate?: bigint;
}

export interface AppendIssuerCellToSporeCreate {
  // The Secp256k1 private key of the issuer cells maintainer
  secp256k1PrivateKey: Hex;
  // The issuer ckb address
  issuerAddress: Address;
  // The collector that collects CKB live cells and transactions
  collector: Collector;
  // CKB raw transaction
  ckbRawTx: CKBComponents.RawTransaction;
  // The sum capacity of the ckb inputs
  sumInputsCapacity: Hex;
  // True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet
  isMainnet: boolean;
  // The CKB transaction fee rate, default value is 1100
  ckbFeeRate?: bigint;
}

export interface SporesCreateCobuildParams {
  sporeOutputs: CKBComponents.CellOutput[];
  sporeOutputsData: Hex[];
  clusterCell: IndexerCell;
  clusterOutputCell: CKBComponents.CellOutput;
}

export interface TransferSporeCkbVirtualTxParams {
  // The collector that collects CKB live cells and transactions
  collector: Collector;
  // The spore rgbpp cell lock script args whose data structure is: out_index | bitcoin_tx_id
  sporeRgbppLockArgs: Hex;
  // The spore type script serialized bytes
  sporeTypeBytes: Hex;
  // True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet
  isMainnet: boolean;
  // The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
  btcTestnetType?: BTCTestnetType;
  // The WitnessArgs.lock placeholder bytes array size and the default value is 5000
  witnessLockPlaceholderSize?: number;
  // The CKB transaction fee rate, default value is 1100
  ckbFeeRate?: bigint;

  /*
   * Vendor cell deps provided by the caller.
   * These cell deps belong to scripts that may be upgraded in the future.
   * Please ensure the cell dep information is up to date. The latest cell dep information is maintained at:
   * https://raw.githubusercontent.com/utxostack/typeid-contract-cell-deps/main/deployment/cell-deps.json.
   */
  vendorCellDeps?: CellDepsObject;
}

export interface SporeTransferVirtualTxResult {
  // CKB raw transaction
  ckbRawTx: CKBComponents.RawTransaction;
  // The rgbpp commitment to be inserted into BTC op_return
  commitment: Hex;
  // The spore cell from ckb-indexer
  sporeCell: IndexerCell;
  // The needPaymasterCell indicates whether a paymaster cell is required
  needPaymasterCell: boolean;
  // The sum capacity of the ckb inputs
  sumInputsCapacity: Hex;
}

export interface SporeLeapVirtualTxResult extends SporeTransferVirtualTxResult {}

export interface LeapSporeFromBtcToCkbVirtualTxParams {
  // The collector that collects CKB live cells and transactions
  collector: Collector;
  // The spore rgbpp cell lock script args whose data structure is: out_index | bitcoin_tx_id
  sporeRgbppLockArgs: Hex;
  // The spore type script serialized bytes
  sporeTypeBytes: Hex;
  // The receiver ckb address
  toCkbAddress: Address;
  // True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet
  isMainnet: boolean;
  // The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
  btcTestnetType?: BTCTestnetType;
  // The WitnessArgs.lock placeholder bytes array size and the default value is 5000
  witnessLockPlaceholderSize?: number;
  // The CKB transaction fee rate, default value is 1100
  ckbFeeRate?: bigint;

  /*
   * Vendor cell deps provided by the caller.
   * These cell deps belong to scripts that may be upgraded in the future.
   * Please ensure the cell dep information is up to date. The latest cell dep information is maintained at:
   * https://raw.githubusercontent.com/utxostack/typeid-contract-cell-deps/main/deployment/cell-deps.json.
   */
  vendorCellDeps?: CellDepsObject;
}

export interface LeapSporeFromCkbToBtcVirtualTxParams {
  // The collector that collects CKB live cells and transactions
  collector: Collector;
  // The sender ckb address
  fromCkbAddress: Address;
  // The receiver spore rgbpp cell lock script args whose data structure is: out_index | bitcoin_tx_id
  toRgbppLockArgs: Hex;
  // The spore type script serialized bytes
  sporeTypeBytes: Hex;
  // True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet
  isMainnet: boolean;
  // The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
  btcTestnetType?: BTCTestnetType;
  // The WitnessArgs.lock placeholder bytes array size and the default value is 5000
  witnessLockPlaceholderSize?: number;
  // The CKB transaction fee rate, default value is 1100
  ckbFeeRate?: bigint;
}


================================================
File: packages/ckb/src/types/spv.ts
================================================
import { Hex } from './common';

export interface SpvClientCellTxProof {
  // The OutPoint of spv client cell
  spvClient: CKBComponents.OutPoint;
  // The BTC transaction proof
  proof: Hex;
}


================================================
File: packages/ckb/src/utils/case-parser.spec.ts
================================================
import { describe, it, expect } from 'vitest';
import { toCamelcase } from './case-parser';

interface TestType {
  firstField: number;
  secondField: string[];
  thirdField: { subFirstField: boolean; subSecondField: 'abc' };
}

describe('case parser', () => {
  it('toCamelcase', () => {
    const result = toCamelcase<TestType>({
      first_field: 1,
      second_field: ['0', '1'],
      third_field: { sub_first_field: false, sub_second_field: 'abc' },
    });
    expect(1).toBe(result?.firstField);
    expect('0').toBe(result?.secondField[0]);
    expect('abc').toBe(result?.thirdField.subSecondField);

    const list = toCamelcase<TestType[]>([
      {
        first_field: 1,
        second_field: ['0', '1'],
        third_field: { sub_first_field: false, sub_second_field: 'abc' },
      },
    ]);
    expect(1).toBe(list![0].firstField);
    expect('0').toBe(list![0].secondField[0]);
    expect('abc').toBe(list![0].thirdField.subSecondField);
  });
});


================================================
File: packages/ckb/src/utils/case-parser.ts
================================================
import camelcaseKeys from 'camelcase-keys';

export const toCamelcase = <T>(obj: object): T | null => {
  try {
    return camelcaseKeys(obj, {
      deep: true,
    }) as T;
  } catch (error) {
    console.error(error);
  }
  return null;
};


================================================
File: packages/ckb/src/utils/cell-dep.spec.ts
================================================
import { describe, it, expect } from 'vitest';
import { CompatibleXUDTRegistry, fetchTypeIdCellDeps } from './cell-dep';
import { getBtcTimeLockDep, getRgbppLockDep, getUniqueTypeDep, getXudtDep } from '../constants';

describe('dynamic fetch cell dep', () => {
  it(
    'fetchTypeIdCellDeps with xudt and unique',
    async () => {
      const isMainnet = false;
      const [xudtDep, uniqueDep] = await fetchTypeIdCellDeps(isMainnet, { xudt: true, unique: true });
      expect(xudtDep.outPoint?.txHash).toBe(getXudtDep(isMainnet).outPoint?.txHash);
      expect(uniqueDep.outPoint?.txHash).toBe(getUniqueTypeDep(isMainnet).outPoint?.txHash);
    },
    { timeout: 10000 },
  );

  it(
    'fetchTypeIdCellDeps with rgbpp and config',
    async () => {
      const isMainnet = false;
      const [rgbppDep, configDep] = await fetchTypeIdCellDeps(isMainnet, { rgbpp: true });
      expect(rgbppDep.outPoint?.txHash).toBe(getRgbppLockDep(isMainnet).outPoint?.txHash);
      expect(configDep.outPoint?.index).toBe('0x1');
    },
    { timeout: 10000 },
  );

  it(
    'fetchTypeIdCellDeps with rgbpp, config and xudt',
    async () => {
      const isMainnet = false;
      const [rgbppDep, configDep, xudtDep] = await fetchTypeIdCellDeps(isMainnet, { rgbpp: true, xudt: true });
      expect(rgbppDep.outPoint?.txHash).toBe(getRgbppLockDep(isMainnet).outPoint?.txHash);
      expect(configDep.outPoint?.index).toBe('0x1');
      expect(xudtDep.outPoint?.txHash).toBe(getXudtDep(isMainnet).outPoint?.txHash);
    },
    { timeout: 10000 },
  );

  it(
    'fetchTypeIdCellDeps with btcTime and config',
    async () => {
      const isMainnet = true;
      const [btcTimeDep, configDep] = await fetchTypeIdCellDeps(isMainnet, { btcTime: true });
      expect(btcTimeDep.outPoint?.txHash).toBe(getBtcTimeLockDep(isMainnet).outPoint?.txHash);
      expect(configDep.outPoint?.index).toBe('0x1');
    },
    { timeout: 10000 },
  );

  it(
    'fetchTypeIdCellDeps with btcTime, config and xudt',
    async () => {
      const isMainnet = true;
      const [btcTimeDep, configDep, xudtDep] = await fetchTypeIdCellDeps(isMainnet, { btcTime: true, xudt: true });
      expect(btcTimeDep.outPoint?.txHash).toBe(getBtcTimeLockDep(isMainnet).outPoint?.txHash);
      expect(configDep.outPoint?.index).toBe('0x1');
      expect(xudtDep.outPoint?.txHash).toBe(getXudtDep(isMainnet).outPoint?.txHash);
    },
    { timeout: 10000 },
  );

  it(
    'fetchTypeIdCellDeps with rgbpp, btcTime, xudt and unique',
    async () => {
      const isMainnet = false;
      const cellDeps = await fetchTypeIdCellDeps(isMainnet, { rgbpp: true, btcTime: true, xudt: true, unique: true });
      expect(cellDeps[0].outPoint?.txHash).toBe(getRgbppLockDep(isMainnet).outPoint?.txHash);
      expect(cellDeps[1].outPoint?.index).toBe('0x1');

      expect(cellDeps[2].outPoint?.txHash).toBe(getBtcTimeLockDep(isMainnet).outPoint?.txHash);
      expect(cellDeps[3].outPoint?.index).toBe('0x1');

      expect(cellDeps[4].outPoint?.txHash).toBe(getXudtDep(isMainnet).outPoint?.txHash);

      expect(cellDeps[5].outPoint?.txHash).toBe(getUniqueTypeDep(isMainnet).outPoint?.txHash);
    },
    { timeout: 10000 },
  );

  it(
    'fetchTypeIdCellDeps without cell deps',
    async () => {
      const isMainnet = false;
      const cellDeps = await fetchTypeIdCellDeps(isMainnet, {});
      expect(cellDeps.length).toBe(0);
    },
    { timeout: 10000 },
  );

  it(
    'fetchTypeIdCellDeps with RUSD',
    async () => {
      const isMainnet = false;
      const cellDeps = await fetchTypeIdCellDeps(isMainnet, {
        xudt: false,
        compatibleXudtCodeHashes: [
          '0x1142755a044bf2ee358cba9f2da187ce928c91cd4dc8692ded0337efa677d21a',
          '0x1142755a044bf2ee358cba9f2da187ce928c91cd4dc8692ded0337efa677d21a',
        ],
      });
      expect(cellDeps[0].outPoint?.txHash).toBe('0xed7d65b9ad3d99657e37c4285d585fea8a5fcaf58165d54dacf90243f911548b');
      expect(cellDeps[0].outPoint?.index).toBe('0x0');
      expect(cellDeps.length).toBe(1);
    },
    { timeout: 10000 },
  );

  it(
    'fetchTypeIdCellDeps with UTXOAirdropBadge',
    async () => {
      const isMainnet = false;
      const cellDeps = await fetchTypeIdCellDeps(isMainnet, {
        utxoAirdropBadge: true,
      });
      expect(cellDeps[0].outPoint?.txHash).toBe('0xbbbb73972ac260a0f7204bea707288c3970688fe8714c3246a5e9a538168a42a');
      expect(cellDeps[0].outPoint?.index).toBe('0x0');
    },
    { timeout: 10000 },
  );

  it(
    'CompatibleXUDTRegistry.getCompatibleTokens',
    async () => {
      const scripts = CompatibleXUDTRegistry.getCompatibleTokens();
      expect(scripts.length > 0).toBe(true);
      // RUSD Mainnet
      expect(scripts[0].codeHash).toBe('0x26a33e0815888a4a0614a0b7d09fa951e0993ff21e55905510104a0b1312032b');
      // USDI Testnet
      expect(scripts[3].codeHash).toBe('0xcc9dc33ef234e14bc788c43a4848556a5fb16401a04662fc55db9bb201987037');

      await CompatibleXUDTRegistry.refreshCache();
      const latestScripts = CompatibleXUDTRegistry.getCompatibleTokens();
      expect(latestScripts.length > 0).toBe(true);
      // RUSD Testnet
      expect(latestScripts[0].codeHash).toBe('0x1142755a044bf2ee358cba9f2da187ce928c91cd4dc8692ded0337efa677d21a');
      // USDI Mainnet
      expect(latestScripts[3].codeHash).toBe('0xbfa35a9c38a676682b65ade8f02be164d48632281477e36f8dc2f41f79e56bfc');
    },
    { timeout: 10000 },
  );
});


================================================
File: packages/ckb/src/utils/cell-dep.ts
================================================
import axios from 'axios';
import {
  COMPATIBLE_XUDT_TYPE_SCRIPTS,
  getBtcTimeLockDep,
  getRgbppLockDep,
  getUniqueTypeDep,
  getUtxoAirdropBadgeTypeDep,
  getXudtDep,
} from '../constants';
import { BTCTestnetType } from '../types';

export interface CellDepsObject {
  rgbpp: {
    mainnet: CKBComponents.CellDep;
    testnet: CKBComponents.CellDep;
    signet: CKBComponents.CellDep;
  };
  btcTime: {
    mainnet: CKBComponents.CellDep;
    testnet: CKBComponents.CellDep;
    signet: CKBComponents.CellDep;
  };
  xudt: {
    testnet: CKBComponents.CellDep;
  };
  unique: {
    testnet: CKBComponents.CellDep;
  };
  utxoAirdropBadge: {
    testnet: CKBComponents.CellDep;
    mainnet: CKBComponents.CellDep;
  };
  compatibleXudt: {
    [codeHash: string]: CKBComponents.CellDep;
  };
}
const GITHUB_CELL_DEPS_JSON_URL =
  'https://raw.githubusercontent.com/utxostack/typeid-contract-cell-deps/main/deployment/cell-deps.json';

const VERCEL_CELL_DEPS_JSON_STATIC_URL = 'https://typeid-contract-cell-deps.vercel.app/deployment/cell-deps.json';

const VERCEL_SERVER_CELL_DEPS_JSON_URL = 'https://typeid-contract-cell-deps.vercel.app/api/cell-deps';

const request = (url: string) => axios.get(url, { timeout: 10000 });

const fetchCellDepsJsonFromStaticSource = async () => {
  try {
    const response = await Promise.any([request(VERCEL_CELL_DEPS_JSON_STATIC_URL), request(GITHUB_CELL_DEPS_JSON_URL)]);
    return response.data as CellDepsObject;
  } catch (error) {
    // for (const e of error.errors) {
    //   console.error('Error fetching cell deps from static source:', e);
    // }
  }
};

export const fetchCellDepsJson = async () => {
  try {
    const response = await request(VERCEL_SERVER_CELL_DEPS_JSON_URL);
    if (response && response.data) {
      return response.data as CellDepsObject;
    }
    return await fetchCellDepsJsonFromStaticSource();
  } catch (error) {
    // console.error('Error fetching cell deps from vercel server:', error);
    return await fetchCellDepsJsonFromStaticSource();
  }
};

export interface CellDepsSelected {
  rgbpp?: boolean;
  btcTime?: boolean;
  xudt?: boolean;
  unique?: boolean;
  compatibleXudtCodeHashes?: string[];
  utxoAirdropBadge?: boolean;
}

export const fetchTypeIdCellDeps = async (
  isMainnet: boolean,
  selected: CellDepsSelected,
  btcTestnetType?: BTCTestnetType,
  vendorCellDeps?: CellDepsObject,
): Promise<CKBComponents.CellDep[]> => {
  let cellDeps: CKBComponents.CellDep[] = [];

  let rgbppLockDep = getRgbppLockDep(isMainnet, btcTestnetType);
  let btcTimeDep = getBtcTimeLockDep(isMainnet, btcTestnetType);
  let xudtDep = getXudtDep(isMainnet);
  let uniqueDep = getUniqueTypeDep(isMainnet);
  let utxoAirdropBadgeDep = getUtxoAirdropBadgeTypeDep(isMainnet);

  const cellDepsObj = vendorCellDeps ?? (await fetchCellDepsJson());

  if (selected.rgbpp === true) {
    if (cellDepsObj?.rgbpp) {
      const { signet, testnet, mainnet } = cellDepsObj.rgbpp;
      if (btcTestnetType === 'Signet') {
        rgbppLockDep = signet;
      } else {
        rgbppLockDep = isMainnet ? mainnet : testnet;
      }
    }
    // RGB++ config cell is deployed together with the RGB++ lock contract
    //
    // contract_deployment_transaction:
    //   - output(index=0, data=rgbpp_code)
    //   - output(index=1, data=rgbpp_config)
    //
    cellDeps = [
      ...cellDeps,
      rgbppLockDep,
      {
        ...rgbppLockDep,
        outPoint: {
          ...rgbppLockDep.outPoint,
          index: '0x1',
        },
      },
    ] as CKBComponents.CellDep[];
  }

  if (selected.btcTime === true) {
    if (cellDepsObj?.btcTime) {
      const { signet, testnet, mainnet } = cellDepsObj.btcTime;
      if (btcTestnetType === 'Signet') {
        btcTimeDep = signet;
      } else {
        btcTimeDep = isMainnet ? mainnet : testnet;
      }
    }
    // BTC Time config cell is deployed together with the BTC Time lock contract
    //
    // contract_deployment_transaction:
    //   - output(index=0, data=rgbpp_code)
    //   - output(index=1, data=rgbpp_config)
    //
    cellDeps = [
      ...cellDeps,
      btcTimeDep,
      {
        ...btcTimeDep,
        outPoint: {
          ...btcTimeDep.outPoint,
          index: '0x1',
        },
      },
    ] as CKBComponents.CellDep[];
  }

  if (selected.xudt === true) {
    if (!isMainnet && cellDepsObj?.xudt) {
      xudtDep = cellDepsObj.xudt.testnet;
    }
    cellDeps = [...cellDeps, xudtDep] as CKBComponents.CellDep[];
  }

  if (selected.unique === true) {
    if (!isMainnet && cellDepsObj?.unique) {
      uniqueDep = cellDepsObj.unique.testnet;
    }
    cellDeps = [...cellDeps, uniqueDep] as CKBComponents.CellDep[];
  }

  if (selected.utxoAirdropBadge === true) {
    if (cellDepsObj?.utxoAirdropBadge) {
      utxoAirdropBadgeDep = isMainnet ? cellDepsObj.utxoAirdropBadge.mainnet : cellDepsObj.utxoAirdropBadge.testnet;
    }
    cellDeps = [...cellDeps, utxoAirdropBadgeDep] as CKBComponents.CellDep[];
  }

  /**
   * "compatibleXudt": {
    "0x1142755a044bf2ee358cba9f2da187ce928c91cd4dc8692ded0337efa677d21a": {
      "outPoint": {
        "index": "0x0",
        "txHash": "0xed7d65b9ad3d99657e37c4285d585fea8a5fcaf58165d54dacf90243f911548b"
      },
      "depType": "code"
    },
    "0x26a33e0815888a4a0614a0b7d09fa951e0993ff21e55905510104a0b1312032b": {
      "outPoint": {
        "index": "0x0",
        "txHash": "0x8ec1081bd03e5417bb4467e96f4cec841acdd35924538a35e7547fe320118977"
      },
      "depType": "code"
    }
  }
   */
  if (selected.compatibleXudtCodeHashes && selected.compatibleXudtCodeHashes?.length > 0) {
    if (cellDepsObj?.compatibleXudt === undefined) {
      throw new Error('Compatible xUDT cell deps are null');
    }
    let compatibleCellDeps = selected.compatibleXudtCodeHashes.map((codeHash) => cellDepsObj.compatibleXudt[codeHash]);
    compatibleCellDeps = Array.from(new Set(compatibleCellDeps));
    if (compatibleCellDeps.length === 0) {
      throw new Error('The specific compatible xUDT cell deps are not found');
    }
    cellDeps = [...cellDeps, ...compatibleCellDeps] as CKBComponents.CellDep[];
  }

  return cellDeps;
};

const VERCEL_STATIC_COMPATIBLE_XUDT_URL = 'https://typeid-contract-cell-deps.vercel.app/compatible-udt.json';
const GITHUB_STATIC_COMPATIBLE_XUDT_URL =
  'https://raw.githubusercontent.com/utxostack/typeid-contract-cell-deps/main/compatible-udt.json';

/**
 * The `CompatibleXUDTRegistry` class is responsible for managing a cache of compatible XUDT (eXtensible User-Defined Token) scripts.
 * It fetches and caches the compatible tokens from specified URLs and refreshes the cache periodically.
 * Alternatively, the compatible tokens can also be fetched from the static list only when offline mode is enabled.
 */
export class CompatibleXUDTRegistry {
  private static cache: CKBComponents.Script[] = [];
  private static lastFetchTime: number = 0;
  private static CACHE_DURATION = 3 * 60 * 1000; // 3 minutes ([about 24 CKB blocks](https://docs-old.nervos.org/docs/essays/tx-confirmation))
  private static xudtUrl = VERCEL_STATIC_COMPATIBLE_XUDT_URL;

  // If you want to get the latest compatible xUDT list, CompatibleXUDTRegistry.refreshCache should be called first
  static getCompatibleTokens(offline?: boolean): CKBComponents.Script[] {
    if (offline) {
      return COMPATIBLE_XUDT_TYPE_SCRIPTS;
    }

    const now = Date.now();
    if (this.cache.length === 0 || now - this.lastFetchTime > this.CACHE_DURATION) {
      this.refreshCache(this.xudtUrl);
    }
    return this.cache.length > 0 ? this.cache : COMPATIBLE_XUDT_TYPE_SCRIPTS;
  }

  /**
   * Refreshes the cache by fetching data from the provided URL or a default URL.
   *
   * This method attempts to fetch data from the provided URL or a default URL
   * using `Promise.any` to handle multiple potential sources. If the fetch is
   * successful, it updates the cache with the fetched data and sets the last
   * fetch time to the current timestamp.
   *
   * @param url - An optional URL to fetch data from. If not provided, a default
   * URL (`VERCEL_CELL_DEPS_JSON_STATIC_URL`) will be used.
   * @returns A promise that resolves when the cache has been refreshed.
   */
  static async refreshCache(url?: string): Promise<void> {
    this.xudtUrl = url ?? VERCEL_STATIC_COMPATIBLE_XUDT_URL;
    const isExternal = url !== VERCEL_STATIC_COMPATIBLE_XUDT_URL && url !== GITHUB_STATIC_COMPATIBLE_XUDT_URL;
    try {
      const response = await (isExternal
        ? request(this.xudtUrl)
        : Promise.any([request(this.xudtUrl), request(GITHUB_STATIC_COMPATIBLE_XUDT_URL)]));
      if (response && response.data) {
        const xudtList = response.data as { codeHash: string }[];
        this.cache = xudtList.map((xudt) => {
          return {
            codeHash: xudt.codeHash,
            hashType: 'type',
          } as CKBComponents.Script;
        });
      }
      this.lastFetchTime = Date.now();
    } catch (error) {
      // console.error(error)
    }
  }
}


================================================
File: packages/ckb/src/utils/ckb-tx.spec.ts
================================================
import { describe, it, expect } from 'vitest';
import {
  calculateRgbppCellCapacity,
  calculateRgbppClusterCellCapacity,
  calculateRgbppSporeCellCapacity,
  calculateTransactionFee,
  deduplicateList,
  generateUniqueTypeArgs,
  isClusterSporeTypeSupported,
  isLockArgsSizeExceeded,
  isScriptEqual,
  isTypeAssetSupported,
  checkCkbTxInputsCapacitySufficient,
  calculateCellOccupiedCapacity,
} from './ckb-tx';
import { hexToBytes } from '@nervosnetwork/ckb-sdk-utils';
import { Collector } from '../collector';
import { NoLiveCellError } from '../error';
import { utf8ToHex } from './hex';
import { IndexerCell } from '../types';

describe('ckb tx utils', () => {
  it('calculateTransactionFee', () => {
    const fee1 = calculateTransactionFee(1245);
    expect(BigInt(1370)).toBe(fee1);

    const fee2 = calculateTransactionFee(1245, BigInt(1200));
    expect(BigInt(1494)).toBe(fee2);
  });

  it('calculateTransactionFee', () => {
    const longLockArgs = '0x06ec22c2def100bba3e295a1ff279c490d227151bf3166a4f3f008906c849399';
    expect(true).toBe(isLockArgsSizeExceeded(longLockArgs));

    const shortLockArgs = '0x06ec22c2def100bba3e295a1ff279c490d227151bf3166a4f3';
    expect(false).toBe(isLockArgsSizeExceeded(shortLockArgs));
  });

  it('calculateRgbppCellCapacity', () => {
    const xudtType: CKBComponents.Script = {
      codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
      hashType: 'type',
      args: '0x06ec22c2def100bba3e295a1ff279c490d227151bf3166a4f3f008906c849399',
    };
    const capacity = calculateRgbppCellCapacity(xudtType);
    expect(BigInt(253_0000_0000)).toBe(capacity);

    const actual = calculateRgbppCellCapacity();
    expect(actual).toBe(BigInt(253_0000_0000));
  });

  it('isClusterSporeTypeSupported', () => {
    const clusterTestnetType: CKBComponents.Script = {
      codeHash: '0x0bbe768b519d8ea7b96d58f1182eb7e6ef96c541fbd9526975077ee09f049058',
      hashType: 'data1',
      args: '0x06ec22c2def100bba3e295a1ff279c490d227151bf3166a4f3f008906c849399',
    };
    expect(isClusterSporeTypeSupported(clusterTestnetType, false)).toBe(true);

    const clusterMainnetType: CKBComponents.Script = {
      codeHash: '0x7366a61534fa7c7e6225ecc0d828ea3b5366adec2b58206f2ee84995fe030075',
      hashType: 'data1',
      args: '0x06ec22c2def100bba3e295a1ff279c490d227151bf3166a4f3f008906c849399',
    };
    expect(isClusterSporeTypeSupported(clusterMainnetType, true)).toBe(true);

    const sporeTestnetType: CKBComponents.Script = {
      codeHash: '0x685a60219309029d01310311dba953d67029170ca4848a4ff638e57002130a0d',
      hashType: 'data1',
      args: '0x06ec22c2def100bba3e295a1ff279c490d227151bf3166a4f3f008906c849399',
    };
    expect(isClusterSporeTypeSupported(sporeTestnetType, false)).toBe(true);

    const sporeMainnetType: CKBComponents.Script = {
      codeHash: '0x4a4dce1df3dffff7f8b2cd7dff7303df3b6150c9788cb75dcf6747247132b9f5',
      hashType: 'data1',
      args: '0x06ec22c2def100bba3e295a1ff279c490d227151bf3166a4f3f008906c849399',
    };
    expect(isTypeAssetSupported(sporeMainnetType, true)).toBe(true);

    const sporeMainnetErrorType: CKBComponents.Script = {
      codeHash: '0x50bd8d6680b8b9cf98b73f3c08faf8b2a21914311954118ad6609be6e78a1b95',
      hashType: 'type',
      args: '0x06ec22c2def100bba3e295a1ff279c490d227151bf3166a4f3f008906c849399',
    };
    expect(isTypeAssetSupported(sporeMainnetErrorType, true)).toBe(false);
  });

  it('isTypeAssetSupported', () => {
    const xudtTestnetType: CKBComponents.Script = {
      codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
      hashType: 'type',
      args: '0x06ec22c2def100bba3e295a1ff279c490d227151bf3166a4f3f008906c849399',
    };
    expect(isTypeAssetSupported(xudtTestnetType, false)).toBe(true);

    const xudtMainnetType: CKBComponents.Script = {
      codeHash: '0x50bd8d6680b8b9cf98b73f3c08faf8b2a21914311954118ad6609be6e78a1b95',
      hashType: 'data1',
      args: '0x06ec22c2def100bba3e295a1ff279c490d227151bf3166a4f3f008906c849399',
    };
    expect(isTypeAssetSupported(xudtMainnetType, true)).toBe(true);

    const xudtMainnetErrorType: CKBComponents.Script = {
      codeHash: '0x50bd8d6680b8b9cf98b73f3c08faf8b2a21914311954118ad6609be6e78a1b95',
      hashType: 'type',
      args: '0x06ec22c2def100bba3e295a1ff279c490d227151bf3166a4f3f008906c849399',
    };
    expect(isTypeAssetSupported(xudtMainnetErrorType, true)).toBe(false);
  });

  it('generateUniqueTypeArgs', () => {
    const firstInput = {
      previousOutput: {
        txHash: '0x047b6894a0b7a4d7a73b1503d1ae35c51fc5fa6306776dcf22b1fb3daaa32a29',
        index: '0x0',
      },
      since: '0x0',
    };

    const typeId = generateUniqueTypeArgs(firstInput, 0);
    expect(typeId).toBe('0xdc03ec5c4086fcb813707c6dd8bf5b9848d7e335');
  });

  it('calculateRgbppClusterCellCapacity', () => {
    const clusterData = {
      name: 'Name of the cluster',
      description: 'Description of the cluster',
    };
    const capacity = calculateRgbppClusterCellCapacity(clusterData);
    expect(capacity).toBe(BigInt(212_0000_0000));
  });

  it('calculateRgbppSporeCellCapacity', () => {
    const sporeData = {
      contentType: 'text/plain',
      content: hexToBytes(utf8ToHex('First Spore')),
      clusterId: '0xbc5168a4f90116fada921e185d4b018e784dc0f6266e539a3c092321c932700a',
    };
    expect(calculateRgbppSporeCellCapacity(sporeData)).toBe(BigInt(319_0000_0000));
  });

  it('deduplicateList', () => {
    const rgbppLockArgsList = [
      '0x01000000c12747f21eb725b02d8ce3fd062547756b30879504093389cd74f9b3cf357f05',
      '0x01000000c12747f21eb725b02d8ce3fd062547756b30879504093389cd74f9b3cf357f05',
    ];
    expect(1).toBe(deduplicateList(rgbppLockArgsList).length);
  });

  it('isScriptEqual', () => {
    expect(true).toBe(isScriptEqual('0x1234', '1234'));
    expect(false).toBe(isScriptEqual('0x1234', '123456'));
    expect(true).toBe(
      isScriptEqual(
        {
          codeHash: '0x50bd8d6680b8b9cf98b73f3c08faf8b2a21914311954118ad6609be6e78a1b95',
          hashType: 'type',
          args: '0x06ec22c2def100bba3e295a1ff279c490d227151bf3166a4f3f008906c849399',
        },
        '0x5500000010000000300000003100000050bd8d6680b8b9cf98b73f3c08faf8b2a21914311954118ad6609be6e78a1b95012000000006ec22c2def100bba3e295a1ff279c490d227151bf3166a4f3f008906c849399',
      ),
    );
    expect(false).toBe(
      isScriptEqual(
        {
          codeHash: '0x50bd8d6680b8b9cf98b73f3c08faf8b2a21914311954118ad6609be6e78a1b95',
          hashType: 'type',
          args: '0x06ec22c2def100bba3e295a1ff279c490d227151bf3166a4f3f008906c849399',
        },
        '0x123456',
      ),
    );
  });

  it('calculateCellOccupiedCapacity', () => {
    const cell: IndexerCell = {
      output: {
        capacity: '0x5e9f53e00',
        lock: {
          args: '0x6b6a9580fc2aceb920c63adea27a667acfc180f67cf875b36f31b42546ac4920',
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          hashType: 'type',
        },
        type: {
          args: '0x6b6a9580fc2aceb920c63adea27a667acfc180f67cf875b36f31b42546ac4920',
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          hashType: 'type',
        },
      },
      outPoint: {
        index: '0x1',
        txHash: '0x1a6d2b18faed84293b81ada9d00600a3cdb637fa43a5cfa20eb63934757352ea',
      },
      blockNumber: '0x0',
      txIndex: '0x0',
      outputData: '0x6b6a9580fc2aceb920c63adea27a667acfc180f67cf875b36f31b42546ac4920',
    };
    expect(BigInt(17000000000)).toBe(calculateCellOccupiedCapacity(cell));
  });

  it('checkCkbTxInputsCapacitySufficient', { timeout: 20000 }, async () => {
    const collector = new Collector({
      ckbNodeUrl: 'https://testnet.ckb.dev/rpc',
      ckbIndexerUrl: 'https://testnet.ckb.dev/indexer',
    });
    const ckbTxWithDeadCell: CKBComponents.RawTransaction = {
      cellDeps: [],
      headerDeps: [],
      inputs: [
        {
          previousOutput: {
            index: '0x0',
            txHash: '0x8f8c79eb6671709633fe6a46de93c0fedc9c1b8a6527a18d3983879542635c9f',
          },
          since: '0x0',
        },
      ],
      outputs: [
        {
          capacity: '0x5e9f53e00',
          lock: {
            args: '0x01000000850cf65f93ed86e53044e94049ae76115ab25a4897de9247f947d390dcf4a4fc',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0x6b6a9580fc2aceb920c63adea27a667acfc180f67cf875b36f31b42546ac4920',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
      ],
      outputsData: ['0x00743ba40b0000000000000000000000'],
      version: '0x0',
      witnesses: [],
    };
    try {
      await checkCkbTxInputsCapacitySufficient(ckbTxWithDeadCell, collector);
    } catch (error) {
      if (error instanceof NoLiveCellError) {
        expect(102).toBe(error.code);
        expect('The cell with the specific out point is dead').toBe(error.message);
      }
    }

    const invalidCkbTx: CKBComponents.RawTransaction = {
      cellDeps: [],
      headerDeps: [],
      inputs: [
        {
          previousOutput: {
            index: '0x0',
            txHash: '0x8f8c79eb6671709633fe6a46de93c0fedc9c1b8a6527a18d3983879542635c9f',
          },
          since: '0x0',
        },
      ],
      outputs: [
        {
          capacity: '0x65e9f53e00',
          lock: {
            args: '0x01000000850cf65f93ed86e53044e94049ae76115ab25a4897de9247f947d390dcf4a4fc',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0x6b6a9580fc2aceb920c63adea27a667acfc180f67cf875b36f31b42546ac4920',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
      ],
      outputsData: ['0x00743ba40b0000000000000000000000'],
      version: '0x0',
      witnesses: [],
    };
    expect(false).toBe(await checkCkbTxInputsCapacitySufficient(invalidCkbTx, collector));

    const ckbTx: CKBComponents.RawTransaction = {
      cellDeps: [],
      headerDeps: [],
      inputs: [
        {
          previousOutput: {
            index: '0x1',
            txHash: '0x8f8c79eb6671709633fe6a46de93c0fedc9c1b8a6527a18d3983879542635c9f',
          },
          since: '0x0',
        },
      ],
      outputs: [
        {
          capacity: '0x5e9f53e00',
          lock: {
            args: '0x01000000850cf65f93ed86e53044e94049ae76115ab25a4897de9247f947d390dcf4a4fc',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0x6b6a9580fc2aceb920c63adea27a667acfc180f67cf875b36f31b42546ac4920',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
      ],
      outputsData: ['0x00743ba40b0000000000000000000000'],
      version: '0x0',
      witnesses: [],
    };
    expect(true).toBe(await checkCkbTxInputsCapacitySufficient(ckbTx, collector));
  });
});


================================================
File: packages/ckb/src/utils/ckb-tx.ts
================================================
import {
  PERSONAL,
  addressToScript,
  blake2b,
  hexToBytes,
  rawTransactionToHash,
  scriptToHash,
  serializeInput,
  serializeScript,
  serializeWitnessArgs,
} from '@nervosnetwork/ckb-sdk-utils';
import signWitnesses from '@nervosnetwork/ckb-sdk-core/lib/signWitnesses';
import { RawClusterData, packRawClusterData, SporeDataProps, packRawSporeData } from '@spore-sdk/core';
import { remove0x, u64ToLe } from './hex';
import {
  CKB_UNIT,
  UNLOCKABLE_LOCK_SCRIPT,
  getClusterTypeScript,
  getSporeTypeScript,
  getTokenMetadataTypeScript,
  getUtxoAirdropBadgeTypeScript,
  getXudtTypeScript,
} from '../constants';
import { Hex, IndexerCell, RgbppTokenInfo } from '../types';
import { encodeRgbppTokenInfo, genBtcTimeLockScript } from './rgbpp';
import { Collector } from '../collector';
import { NoLiveCellError } from '../error';
import { CompatibleXUDTRegistry } from './cell-dep';

export { serializeScript };

export const calculateTransactionFee = (txSize: number, feeRate?: bigint): bigint => {
  const rate = feeRate ?? BigInt(1100);
  const ratio = BigInt(1000);
  const base = BigInt(txSize) * rate;
  const fee = base / ratio;
  return fee * ratio < base ? fee + BigInt(1) : fee;
};

export const isUtxoAirdropBadgeType = (type: CKBComponents.Script, isMainnet: boolean): boolean => {
  const utxoAirdropBadgeType = serializeScript(getUtxoAirdropBadgeTypeScript(isMainnet));
  const typeAsset = serializeScript({
    ...type,
    args: '',
  });
  return utxoAirdropBadgeType === typeAsset;
};

export const isTokenMetadataType = (type: CKBComponents.Script, isMainnet: boolean): boolean => {
  const tokenMetadataType = serializeScript(getTokenMetadataTypeScript(isMainnet));
  const typeAsset = serializeScript({
    ...type,
    args: '',
  });
  return tokenMetadataType === typeAsset;
};

//
/**
 * Checks if the provided UDT (User Defined Token) type script is supported by comparing it against a list of compatible UDT types.
 * If you want to get the latest compatible xUDT list, CompatibleXUDTRegistry.refreshCache should be called before the isCompatibleUDTTypesSupported
 *
 * @param type - The UDT type script to check for compatibility.
 * @param offline - Whether to use the offline mode.
 * @returns A boolean indicating whether the provided UDT type script is supported.
 */
export const isCompatibleUDTTypesSupported = (type: CKBComponents.Script, offline?: boolean): boolean => {
  const compatibleList = CompatibleXUDTRegistry.getCompatibleTokens(offline);
  const compatibleXudtTypeBytes = compatibleList.map((script) => serializeScript(script));
  const typeAsset = serializeScript({
    ...type,
    args: '',
  });
  return compatibleXudtTypeBytes.includes(typeAsset);
};

export const isStandardUDTTypeSupported = (type: CKBComponents.Script, isMainnet: boolean): boolean => {
  const xudtType = serializeScript(getXudtTypeScript(isMainnet));
  const typeAsset = serializeScript({
    ...type,
    args: '',
  });
  return xudtType === typeAsset;
};

export const isUDTTypeSupported = (type: CKBComponents.Script, isMainnet: boolean, offline?: boolean): boolean => {
  return isStandardUDTTypeSupported(type, isMainnet) || isCompatibleUDTTypesSupported(type, offline);
};

export const isSporeTypeSupported = (type: CKBComponents.Script, isMainnet: boolean): boolean => {
  const sporeType = serializeScript(getSporeTypeScript(isMainnet));
  const typeAsset = serializeScript({
    ...type,
    args: '',
  });
  return sporeType === typeAsset;
};

export const isClusterSporeTypeSupported = (type: CKBComponents.Script, isMainnet: boolean): boolean => {
  const typeAsset = serializeScript({
    ...type,
    args: '',
  });
  const clusterType = serializeScript(getClusterTypeScript(isMainnet));
  return isSporeTypeSupported(type, isMainnet) || clusterType === typeAsset;
};

export const isTypeAssetSupported = (type: CKBComponents.Script, isMainnet: boolean, offline?: boolean): boolean => {
  return isUDTTypeSupported(type, isMainnet, offline) || isClusterSporeTypeSupported(type, isMainnet);
};

const CELL_CAPACITY_SIZE = 8;
const UDT_CELL_DATA_SIZE = 16;

// Assume the length of the lock script args cannot exceed 26 bytes. If it exceeds, an error will be thrown.
const LOCK_ARGS_HEX_MAX_SIZE = 26;
export const isLockArgsSizeExceeded = (args: Hex) => remove0x(args).length > LOCK_ARGS_HEX_MAX_SIZE * 2;

// The BTC_TIME_CELL_INCREASED_SIZE depends on the receiver lock script args whose length cannot exceed LOCK_ARGS_HEX_MAX_SIZE bytes
const BTC_TIME_CELL_INCREASED_SIZE = 95;

// For simplicity, we keep the capacity of the RGBPP cell the same as the BTC time cell
// minimum occupied capacity and assume UDT cell data size is 16bytes
/**
 * RGB_lock:
    code_hash: 
      RGB_lock
    args:
      out_index | bitcoin_tx_id
 */
const RGBPP_LOCK_SIZE = 32 + 1 + 36;
export const calculateRgbppCellCapacity = (xudtType?: CKBComponents.Script): bigint => {
  const typeArgsSize = xudtType ? remove0x(xudtType.args).length / 2 : 32;
  const udtTypeSize = 33 + typeArgsSize;
  const cellSize =
    RGBPP_LOCK_SIZE + udtTypeSize + CELL_CAPACITY_SIZE + UDT_CELL_DATA_SIZE + BTC_TIME_CELL_INCREASED_SIZE;
  return BigInt(cellSize) * CKB_UNIT;
};

// Minimum occupied capacity and 1 ckb for transaction fee
// Assume UDT cell data size is 16bytes
// The default length of xut type args is 32 bytes
const DEFAULT_UDT_ARGS_SIZE = 32;
export const calculateUdtCellCapacity = (lock: CKBComponents.Script, udtType?: CKBComponents.Script): bigint => {
  const lockArgsSize = remove0x(lock.args).length / 2;
  const typeArgsSize = udtType ? remove0x(udtType.args).length / 2 : DEFAULT_UDT_ARGS_SIZE;
  const lockSize = 33 + lockArgsSize;
  const typeSize = 33 + typeArgsSize;
  const cellSize = lockSize + typeSize + CELL_CAPACITY_SIZE + UDT_CELL_DATA_SIZE;
  return BigInt(cellSize + 1) * CKB_UNIT;
};

// Unique Type Script: https://github.com/ckb-cell/unique-cell?tab=readme-ov-file#unique-type-script
export const calculateXudtTokenInfoCellCapacity = (tokenInfo: RgbppTokenInfo, lock: CKBComponents.Script): bigint => {
  const lockSize = remove0x(lock.args).length / 2 + 33;
  const cellDataSize = remove0x(encodeRgbppTokenInfo(tokenInfo)).length / 2;
  const uniqueTypeSize = 32 + 1 + 20;
  const cellSize = lockSize + uniqueTypeSize + CELL_CAPACITY_SIZE + cellDataSize;
  return BigInt(cellSize) * CKB_UNIT;
};

// Unique Type Script: https://github.com/ckb-cell/unique-cell?tab=readme-ov-file#unique-type-script
export const calculateRgbppTokenInfoCellCapacity = (tokenInfo: RgbppTokenInfo, isMainnet: boolean): bigint => {
  const btcTimeLock = genBtcTimeLockScript(UNLOCKABLE_LOCK_SCRIPT, isMainnet);
  const lockSize = remove0x(btcTimeLock.args).length / 2 + 33;
  const cellDataSize = remove0x(encodeRgbppTokenInfo(tokenInfo)).length / 2;
  const typeSize = 32 + 1 + 20;
  const cellSize = lockSize + typeSize + CELL_CAPACITY_SIZE + cellDataSize;
  return BigInt(cellSize) * CKB_UNIT;
};

// Generate type id for Unique type script args
export const generateUniqueTypeArgs = (firstInput: CKBComponents.CellInput, firstOutputIndex: number) => {
  const input = hexToBytes(serializeInput(firstInput));
  const s = blake2b(32, null, null, PERSONAL);
  s.update(input);
  s.update(hexToBytes(`0x${u64ToLe(BigInt(firstOutputIndex))}`));
  return `0x${s.digest('hex').slice(0, 40)}`;
};

// https://docs.spore.pro/recipes/Create/create-private-cluster
// Minimum occupied capacity and 1 ckb for transaction fee
export const calculateRgbppClusterCellCapacity = (clusterData: RawClusterData): bigint => {
  const clusterDataSize = packRawClusterData(clusterData).length;
  const clusterTypeSize = 32 + 1 + 32;
  const cellSize = RGBPP_LOCK_SIZE + clusterTypeSize + CELL_CAPACITY_SIZE + clusterDataSize;
  return BigInt(cellSize + 1) * CKB_UNIT;
};

// https://docs.spore.pro/recipes/Create/create-clustered-spore
// For simplicity, we keep the capacity of the RGBPP cell the same as the BTC time cell
// minimum occupied capacity and 1 ckb for transaction fee
/**
 * rgbpp_spore_cell:
    lock: rgbpp_lock
    type: spore_type
    data: sporeData
 */
export const calculateRgbppSporeCellCapacity = (sporeData: SporeDataProps): bigint => {
  const sporeDataSize = packRawSporeData(sporeData).length;
  const sporeTypeSize = 32 + 1 + 32;
  const cellSize = RGBPP_LOCK_SIZE + sporeTypeSize + CELL_CAPACITY_SIZE + sporeDataSize + BTC_TIME_CELL_INCREASED_SIZE;
  return BigInt(cellSize + 1) * CKB_UNIT;
};

// Calculate the occupied capacity of the CKB cell
export const calculateCellOccupiedCapacity = (cell: IndexerCell): bigint => {
  const cellDataSize = remove0x(cell.outputData).length / 2;
  const lockSize = remove0x(cell.output.lock.args).length / 2 + 1 + 32;
  const typeSize = cell.output.type ? remove0x(cell.output.type.args).length / 2 + 1 + 32 : 0;
  const cellSize = cellDataSize + lockSize + typeSize + CELL_CAPACITY_SIZE;
  return BigInt(cellSize) * CKB_UNIT;
};

export const deduplicateList = (rgbppLockArgsList: Hex[]): Hex[] => {
  return Array.from(new Set(rgbppLockArgsList));
};

// Compare the whole script
export const isScriptEqual = (s1: Hex | CKBComponents.Script, s2: Hex | CKBComponents.Script) => {
  const temp1 = typeof s1 === 'string' ? remove0x(s1) : remove0x(serializeScript(s1));
  const temp2 = typeof s2 === 'string' ? remove0x(s2) : remove0x(serializeScript(s2));
  return temp1 === temp2;
};

/**
 * Check whether the capacity of inputs is sufficient for outputs
 * @param ckbTx CKB raw transaction
 * @param collector The collector that collects CKB live cells and transactions
 * @returns When the capacity of inputs is sufficient for outputs, return true, otherwise return false
 */
export const checkCkbTxInputsCapacitySufficient = async (
  ckbTx: CKBComponents.RawTransaction,
  collector: Collector,
): Promise<boolean> => {
  let sumInputsCapacity = BigInt(0);
  for await (const input of ckbTx.inputs) {
    const liveCell = await collector.getLiveCell(input.previousOutput!);
    if (!liveCell) {
      throw new NoLiveCellError('The cell with the specific out point is dead');
    }
    sumInputsCapacity += BigInt(liveCell.output.capacity);
  }
  const sumOutputsCapacity = ckbTx.outputs
    .map((output) => BigInt(output.capacity))
    .reduce((prev, current) => prev + current, BigInt(0));
  return sumInputsCapacity > sumOutputsCapacity;
};

export function signCkbTransaction(
  key: string | Map<string, string>,
  ckbTx: CKBComponents.RawTransactionToSign,
  inputCells: { outPoint: CKBComponents.OutPoint; lock: CKBComponents.Script }[] = [],
  skipMissingKeys = false,
) {
  if (key instanceof Map && inputCells.length === 0) {
    throw new Error('inputCells must not be empty when using Map of keys');
  }

  const transactionHash = rawTransactionToHash(ckbTx);
  const signedWitnesses = signWitnesses(key)({
    transactionHash,
    witnesses: ckbTx.witnesses,
    inputCells,
    skipMissingKeys,
  });

  // Serialize the witness args if needed to ensure all witnesses are consistently in string format
  return {
    ...ckbTx,
    witnesses: signedWitnesses.map((witness) =>
      typeof witness !== 'string' ? serializeWitnessArgs(witness) : witness,
    ),
  };
}

export const addressToScriptHash = (address: string) => {
  const script = addressToScript(address);
  return scriptToHash(script);
};


================================================
File: packages/ckb/src/utils/hex.spec.ts
================================================
import { describe, it, expect } from 'vitest';
import { leToU128, reverseHex, u128ToLe, u32ToLe, u32ToLeHex, u64ToLe, u8ToHex, utf8ToHex } from './hex';
import { bytesToHex } from '@nervosnetwork/ckb-sdk-utils';

describe('number to little endian', () => {
  it('u32toLe', () => {
    const expected = u32ToLe(21000000);
    expect('406f4001').toBe(expected);
  });

  it('u32toLeHex', () => {
    expect('0x2c01').toBe(u32ToLeHex(300));
    expect('0x1').toBe(u32ToLeHex(1));
    expect('0xe803').toBe(u32ToLeHex(1000));
  });

  it('u64ToLe', () => {
    const expected = u64ToLe(BigInt(21000000));
    expect('406f400100000000').toBe(expected);
  });

  it('u128ToLe', () => {
    const expected = u128ToLe(BigInt(2100_0000) * BigInt(10 ** 8));
    expect('0040075af07507000000000000000000').toBe(expected);
  });

  it('leToU128', () => {
    const expected = leToU128('0x00b864d9450000000000000000000000');
    expect(BigInt(3000_0000_0000)).toBe(expected);
  });

  it('bytesToHex', () => {
    const expected = bytesToHex(new Uint8Array([0x12, 0x34, 0x56]));
    expect('0x123456').toBe(expected);
  });

  it('u8ToHex', () => {
    const actual = u8ToHex(8);
    expect(actual).toBe('08');
  });

  it('utf8ToHex', () => {
    const actual = utf8ToHex('RGBPP Test Token');
    expect(actual).toBe('0x5247425050205465737420546f6b656e');
  });

  it('reverseHex', () => {
    const expected1 = reverseHex('0x2f061a27abcab1d1d146514ffada6a83c0d974fe0813835ad8be2a39a6b1a6ee');
    expect(expected1).toBe('0xeea6b1a6392abed85a831308fe74d9c0836adafa4f5146d1d1b1caab271a062f');

    const expected2 = reverseHex('2f061a27abcab1d1d146514ffada6a83c0d974fe0813835ad8be2a39a6b1a6ee');
    expect(expected2).toBe('0xeea6b1a6392abed85a831308fe74d9c0836adafa4f5146d1d1b1caab271a062f');
  });
});


================================================
File: packages/ckb/src/utils/hex.ts
================================================
import { hexToBytes, bytesToHex } from '@nervosnetwork/ckb-sdk-utils';
import { Hex } from '../types';

export const remove0x = (hex: string): string => {
  if (hex.startsWith('0x')) {
    return hex.substring(2);
  }
  return hex;
};

export const append0x = (hex?: string): string => {
  return hex?.startsWith('0x') ? hex : `0x${hex}`;
};

const ArrayBufferToHex = (arrayBuffer: ArrayBuffer): string => {
  return Array.prototype.map.call(new Uint8Array(arrayBuffer), (x) => ('00' + x.toString(16)).slice(-2)).join('');
};

export const u8ToHex = (u8: number): string => {
  const buffer = new ArrayBuffer(1);
  const view = new DataView(buffer);
  view.setUint8(0, u8);
  return ArrayBufferToHex(buffer);
};

export const u16ToLe = (u16: number): string => {
  const buffer = new ArrayBuffer(2);
  const view = new DataView(buffer);
  view.setUint16(0, u16, true);
  return ArrayBufferToHex(buffer);
};

const u32ToHex = (u32: string | number, littleEndian?: boolean): string => {
  const buffer = new ArrayBuffer(4);
  const view = new DataView(buffer);
  view.setUint32(0, Number(u32), littleEndian);
  return ArrayBufferToHex(buffer);
};

export const u32ToBe = (u32: string | number): string => {
  return u32ToHex(u32, false);
};

export const u32ToLe = (u32: string | number): string => {
  return u32ToHex(u32, true);
};

export const u32ToLeHex = (u32: string | number): string => {
  const hex = u32ToBe(u32);
  const le = reverseHex(parseInt(hex, 16).toString(16));
  return append0x(parseInt(le, 16).toString(16));
};

export const leToU32 = (leHex: string): number => {
  const bytes = hexToBytes(append0x(leHex));
  const beHex = `0x${bytes.reduceRight((pre, cur) => pre + cur.toString(16).padStart(2, '0'), '')}`;
  return parseInt(beHex, 16);
};

export const u64ToLe = (u64: bigint): string => {
  const val = u64.toString(16).padStart(16, '0');
  const viewLeft = u32ToLe(`0x${val.slice(8)}`);
  const viewRight = u32ToLe(`0x${val.slice(0, 8)}`);
  return `${viewLeft}${viewRight}`;
};

export const u128ToLe = (u128: bigint): string => {
  const val = u128.toString(16).padStart(32, '0');
  const viewLeft = u64ToLe(BigInt(`0x${val.slice(16)}`));
  const viewRight = u64ToLe(BigInt(`0x${val.slice(0, 16)}`));
  return `${viewLeft}${viewRight}`;
};

export const leToU128 = (leHex: string): bigint => {
  const bytes = hexToBytes(append0x(leHex));
  const beHex = `0x${bytes.reduceRight((pre, cur) => pre + cur.toString(16).padStart(2, '0'), '')}`;
  return BigInt(beHex);
};

export const utf8ToHex = (text: string) => {
  let result = text.trim();
  if (result.startsWith('0x')) {
    return result;
  }
  result = bytesToHex(new TextEncoder().encode(result));
  return result;
};

export const hexToUtf8 = (hex: string) => {
  let result = hex.trim();
  try {
    result = new TextDecoder().decode(hexToBytes(result));
  } catch (error) {
    console.error('hexToUtf8 error:', error);
  }
  return result;
};

export const reverseHex = (str: Hex) => {
  return bytesToHex(hexToBytes(append0x(str)).reverse());
};


================================================
File: packages/ckb/src/utils/id.spec.ts
================================================
import { describe, it, expect } from 'vitest';
import { encodeCellId, decodeCellId } from './id';

describe('cell id', () => {
  it('encodeCellId', () => {
    expect(encodeCellId('0x7610efaec3b9ce66349909fea88a1ae78cd488de3128bc6f71afc068306e0e65', '0x0')).toBe(
      '0x7610efaec3b9ce66349909fea88a1ae78cd488de3128bc6f71afc068306e0e65:0x0',
    );
    expect(encodeCellId('0x7610efaec3b9ce66349909fea88a1ae78cd488de3128bc6f71afc068306e0e65', '0xffffffff')).toBe(
      '0x7610efaec3b9ce66349909fea88a1ae78cd488de3128bc6f71afc068306e0e65:0xffffffff',
    );

    expect(() =>
      encodeCellId('0x7610efaec3b9ce66349909fea88a1ae78cd488de3128bc6f71afc068306e0e6', '0x0'),
    ).toThrowError();
    expect(() =>
      encodeCellId('0x7610efaec3b9ce66349909fea88a1ae78cd488de3128bc6f71afc068306e0e65', '0xffffffff01'),
    ).toThrowError();
    expect(() =>
      encodeCellId('7610efaec3b9ce66349909fea88a1ae78cd488de3128bc6f71afc068306e0e65', '0x0'),
    ).toThrowError();
    expect(() =>
      encodeCellId('0x7610efaec3b9ce66349909fea88a1ae78cd488de3128bc6f71afc068306e0e65', '0'),
    ).toThrowError();
  });
  it('decodeCellId', () => {
    expect(decodeCellId('0x7610efaec3b9ce66349909fea88a1ae78cd488de3128bc6f71afc068306e0e65:0x0')).toStrictEqual({
      txHash: '0x7610efaec3b9ce66349909fea88a1ae78cd488de3128bc6f71afc068306e0e65',
      index: '0x0',
    });
    expect(decodeCellId('0x7610efaec3b9ce66349909fea88a1ae78cd488de3128bc6f71afc068306e0e65:0xffffffff')).toStrictEqual(
      {
        txHash: '0x7610efaec3b9ce66349909fea88a1ae78cd488de3128bc6f71afc068306e0e65',
        index: '0xffffffff',
      },
    );

    expect(() => decodeCellId('0x7610efaec3b9ce66349909fea88a1ae78cd488de3128bc6f71afc068306e0e6:0x0')).toThrowError();
    expect(() =>
      decodeCellId('0x7610efaec3b9ce66349909fea88a1ae78cd488de3128bc6f71afc068306e0e65:0xffffffff01'),
    ).toThrowError();
    expect(() => decodeCellId('7610efaec3b9ce66349909fea88a1ae78cd488de3128bc6f71afc068306e0e65:0x0')).toThrowError();
    expect(() => decodeCellId('0x7610efaec3b9ce66349909fea88a1ae78cd488de3128bc6f71afc068306e0e65:0')).toThrowError();
  });
});


================================================
File: packages/ckb/src/utils/id.ts
================================================
import { Hash, HexNumber, OutPoint, blockchain } from '@ckb-lumos/base';
import { InvalidCellIdError } from '../error';
import { append0x } from './hex';

export const encodeCellId = (txHash: Hash, index: HexNumber): string => {
  if (!txHash.startsWith('0x') || !index.startsWith('0x')) {
    throw new InvalidCellIdError(`Cannot encode CellId due to valid format: txHash=${txHash}, index=${index}`);
  }
  try {
    blockchain.OutPoint.pack({
      txHash,
      index,
    });
    return `${txHash}:${index}`;
  } catch {
    throw new InvalidCellIdError(`Cannot encode CellId due to valid format: txHash=${txHash}, index=${index}`);
  }
};

export const decodeCellId = (cellId: string): OutPoint => {
  const [txHash, index] = cellId.split(':');
  if (!txHash.startsWith('0x') || !index.startsWith('0x')) {
    throw new InvalidCellIdError(`Cannot decode CellId: ${cellId}`);
  }
  try {
    blockchain.OutPoint.pack({
      txHash,
      index,
    });
    return {
      txHash: append0x(txHash),
      index: append0x(index),
    };
  } catch {
    throw new InvalidCellIdError(`Cannot decode CellId due to valid format: ${cellId}`);
  }
};


================================================
File: packages/ckb/src/utils/index.ts
================================================
export * from './case-parser';
export * from './hex';
export * from './ckb-tx';
export * from './rgbpp';
export * from './spore';
export * from './cell-dep';
export * from './id';


================================================
File: packages/ckb/src/utils/rgbpp.spec.ts
================================================
import { describe, it, expect } from 'vitest';
import { sha256 } from 'js-sha256';
import { addressToScript, hexToBytes, serializeScript } from '@nervosnetwork/ckb-sdk-utils';
import {
  btcTxIdAndAfterFromBtcTimeLockArgs,
  buildPreLockArgs,
  buildRgbppLockArgs,
  calculateCommitment,
  estimateWitnessSize,
  calculateRgbppTokenInfoSize,
  encodeRgbppTokenInfo,
  genBtcTimeLockArgs,
  genBtcTimeLockScript,
  lockScriptFromBtcTimeLockArgs,
  replaceLockArgsWithRealBtcTxId,
  transformSpvProof,
  throwErrorWhenTxInputsExceeded,
  throwErrorWhenRgbppCellsInvalid,
  isRgbppCapacitySufficientForChange,
  unpackRgbppLockArgs,
} from './rgbpp';
import { getXudtTypeScript } from '../constants';
import { IndexerCell, RgbppCkbVirtualTx } from '../types';
import { calculateUdtCellCapacity } from './ckb-tx';
import {
  InputsOrOutputsLenError,
  NoRgbppLiveCellError,
  RgbppCkbTxInputsExceededError,
  RgbppUtxoBindMultiTypeAssetsError,
} from '../error';
import { remove0x } from './hex';

describe('rgbpp tests', () => {
  it('sha256', () => {
    const message = '0x2f061a27abcab1d1d146514ffada6a83c0d974fe0813835ad8be2a39a6b1a6ee';
    const hash = sha256(hexToBytes(message));
    expect(hash).toBe('c0a45d9d7c024adcc8076c18b3f07c08de7c42120cdb7e6cbc05a28266b15b5f');
  });

  it('calculateCommitment with the test data which is from RGBPP lock contract test cases', () => {
    const rgbppVirtualTx: RgbppCkbVirtualTx = {
      inputs: [
        {
          previousOutput: {
            txHash: '0x047b6894a0b7a4d7a73b1503d1ae35c51fc5fa6306776dcf22b1fb3daaa32a29',
            index: '0x0',
          },
          since: '0x0',
        },
      ],
      outputs: [
        {
          lock: {
            codeHash: '0xd5a4e241104041f6f12f11bddcf30bd7b2f818722f78353fde019f5081cd6b49',
            hashType: 'type',
            args: '0x010000000000000000000000000000000000000000000000000000000000000000000000',
          },
          capacity: '0x0000000000000000',
          type: {
            codeHash: '0xc4957f239eb3db9f5c5fb949e9dd99adbb8068b8ac7fe7ae49495486d5e5d235',
            hashType: 'type',
            args: '0x43094caf2f2bcdf6f5ab02c2de744936897278d558a2b6924db98a4f27d629e2',
          },
        },
        {
          lock: {
            codeHash: '0xd5a4e241104041f6f12f11bddcf30bd7b2f818722f78353fde019f5081cd6b49',
            hashType: 'type',
            args: '0x010000000000000000000000000000000000000000000000000000000000000000000000',
          },
          capacity: '0x0000000000000000',
          type: {
            codeHash: '0xc4957f239eb3db9f5c5fb949e9dd99adbb8068b8ac7fe7ae49495486d5e5d235',
            hashType: 'type',
            args: '0x43094caf2f2bcdf6f5ab02c2de744936897278d558a2b6924db98a4f27d629e2',
          },
        },
      ],
      outputsData: ['0x2c010000000000000000000000000000', '0xbc020000000000000000000000000000'],
    };
    const commitment = calculateCommitment(rgbppVirtualTx);
    expect('7cdecc8cc293d491a0cbf44e92feabfc29e79408c1d2f7547b334c42efe13131').toBe(commitment);

    const invalidRgbppVirtualTx: RgbppCkbVirtualTx = {
      inputs: new Array(300).fill({
        previousOutput: {
          txHash: '0x047b6894a0b7a4d7a73b1503d1ae35c51fc5fa6306776dcf22b1fb3daaa32a29',
          index: '0x0',
        },
        since: '0x0',
      }),
      outputs: [
        {
          lock: {
            codeHash: '0xd5a4e241104041f6f12f11bddcf30bd7b2f818722f78353fde019f5081cd6b49',
            hashType: 'type',
            args: '0x010000000000000000000000000000000000000000000000000000000000000000000000',
          },
          capacity: '0x0000000000000000',
          type: {
            codeHash: '0xc4957f239eb3db9f5c5fb949e9dd99adbb8068b8ac7fe7ae49495486d5e5d235',
            hashType: 'type',
            args: '0x43094caf2f2bcdf6f5ab02c2de744936897278d558a2b6924db98a4f27d629e2',
          },
        },
      ],
      outputsData: ['0xbc020000000000000000000000000000'],
    };
    try {
      calculateCommitment(invalidRgbppVirtualTx);
    } catch (error) {
      if (error instanceof InputsOrOutputsLenError) {
        expect(108).toBe(error.code);
        expect('The inputs or outputs length of RGB++ CKB virtual tx cannot be greater than 255').toBe(error.message);
      }
    }
  });

  it('genBtcTimeLockArgs', () => {
    const toLock: CKBComponents.Script = {
      args: '0x0202020202020202020202020202020202020202',
      codeHash: '0x0101010101010101010101010101010101010101010101010101010101010101',
      hashType: 'type',
    };
    const btcTxId = '0x0303030303030303030303030303030303030303030303030303030303030303';
    const after = 0x2a;
    const args = genBtcTimeLockArgs(toLock, btcTxId, after);
    expect(args).toBe(
      '0x7d00000010000000590000005d000000490000001000000030000000310000000101010101010101010101010101010101010101010101010101010101010101011400000002020202020202020202020202020202020202022a0000000303030303030303030303030303030303030303030303030303030303030303',
    );
  });

  it('genBtcTimeLockArgs2', () => {
    const toLock: CKBComponents.Script = {
      args: '0x00016c61f984f12d3c8a4f649e60acda5deda0b8837c',
      codeHash: '0xd23761b364210735c19c60561d213fb3beae2fd6172743719eff6920e020baac',
      hashType: 'type',
    };
    const btcTxId = '018025fb6989eed484774170eefa2bef1074b0c24537f992a64dbc138277bc4a';
    const after = 0x20;
    const args = genBtcTimeLockArgs(toLock, btcTxId, after);
    expect(args).toBe(
      '0x7f000000100000005b0000005f0000004b000000100000003000000031000000d23761b364210735c19c60561d213fb3beae2fd6172743719eff6920e020baac011600000000016c61f984f12d3c8a4f649e60acda5deda0b8837c200000004abc778213bc4da692f93745c2b07410ef2bfaee70417784d4ee8969fb258001',
    );

    const btcTimeLockArgs = btcTxIdAndAfterFromBtcTimeLockArgs(args);
    expect(btcTimeLockArgs.after).toBe(after);
    expect(remove0x(btcTimeLockArgs.btcTxId)).toBe(btcTxId);
  });

  it('genBtcTimeLockArgs3', () => {
    const toAddress =
      'ckt1qrfrwcdnvssswdwpn3s9v8fp87emat306ctjwsm3nmlkjg8qyza2cqgqq9kxr7vy7yknezj0vj0xptx6thk6pwyr0sxamv6q';
    const btcTxId = 'd44e5f02bc28394b97f6d584cf9e43ba731cc049655599cbb3c1274789bf1372';
    const after = 0x6;
    const args = genBtcTimeLockArgs(addressToScript(toAddress), btcTxId, after);
    expect(args).toBe(
      '0x7f000000100000005b0000005f0000004b000000100000003000000031000000d23761b364210735c19c60561d213fb3beae2fd6172743719eff6920e020baac011600000000016c61f984f12d3c8a4f649e60acda5deda0b8837c060000007213bf894727c1b3cb99556549c01c73ba439ecf84d5f6974b3928bc025f4ed4',
    );
    const toLock = lockScriptFromBtcTimeLockArgs(args);
    expect(toLock.args).toBe('0x00016c61f984f12d3c8a4f649e60acda5deda0b8837c');

    const btcTimeLockArgs = btcTxIdAndAfterFromBtcTimeLockArgs(args);
    expect(btcTimeLockArgs.after).toBe(after);
    expect(remove0x(btcTimeLockArgs.btcTxId)).toBe(btcTxId);
  });

  it('genBtcTimeLockScript', () => {
    const lock: CKBComponents.Script = {
      args: '0xc0a45d9d7c024adcc8076c18b3f07c08de7c42120cdb7e6cbc05a28266b15b5f',
      codeHash: '0x28e83a1277d48add8e72fadaa9248559e1b632bab2bd60b27955ebc4c03800a5',
      hashType: 'data',
    };
    const btcTimeLock = genBtcTimeLockScript(lock, false);
    expect(btcTimeLock.args).toBe(
      '0x890000001000000065000000690000005500000010000000300000003100000028e83a1277d48add8e72fadaa9248559e1b632bab2bd60b27955ebc4c03800a50020000000c0a45d9d7c024adcc8076c18b3f07c08de7c42120cdb7e6cbc05a28266b15b5f060000000000000000000000000000000000000000000000000000000000000000000000',
    );

    const btcTimeLockArgs = genBtcTimeLockScript(lock, false, 'Testnet3', 4032).args;
    expect(btcTimeLockArgs).toBe(
      '0x890000001000000065000000690000005500000010000000300000003100000028e83a1277d48add8e72fadaa9248559e1b632bab2bd60b27955ebc4c03800a50020000000c0a45d9d7c024adcc8076c18b3f07c08de7c42120cdb7e6cbc05a28266b15b5fc00f00000000000000000000000000000000000000000000000000000000000000000000',
    );
  });

  it('lockScriptFromBtcTimeLockArgs', () => {
    let lockArgs =
      '0x7d00000010000000590000005d000000490000001000000030000000310000000101010101010101010101010101010101010101010101010101010101010101011400000002020202020202020202020202020202020202022a0000000303030303030303030303030303030303030303030303030303030303030303';
    const lock = lockScriptFromBtcTimeLockArgs(lockArgs);
    expect(lock.codeHash).toBe('0x0101010101010101010101010101010101010101010101010101010101010101');
    expect(lock.args).toBe('0x0202020202020202020202020202020202020202');

    lockArgs =
      '0x890000001000000065000000690000005500000010000000300000003100000028e83a1277d48add8e72fadaa9248559e1b632bab2bd60b27955ebc4c03800a50020000000c0a45d9d7c024adcc8076c18b3f07c08de7c42120cdb7e6cbc05a28266b15b5f060000000000000000000000000000000000000000000000000000000000000000000000';
    const { codeHash, args, hashType } = lockScriptFromBtcTimeLockArgs(lockArgs);
    expect(codeHash).toBe('0x28e83a1277d48add8e72fadaa9248559e1b632bab2bd60b27955ebc4c03800a5');
    expect(args).toBe('0xc0a45d9d7c024adcc8076c18b3f07c08de7c42120cdb7e6cbc05a28266b15b5f');
    expect(hashType).toBe('data');

    lockArgs =
      '0x7f000000100000005b0000005f0000004b0000001000000030000000310000009b819793a64463aed77c615d6cb226eea5487ccfc0783043a587254cda2b6f2601160000000430455c7db8901bee35dc70eeff078c2adfc729920006000000964663ab3b35fd5f02ac29f268ea29401504255707c0b3a943fe143196e80770';
    const result = lockScriptFromBtcTimeLockArgs(lockArgs);
    expect(result.codeHash).toBe('0x9b819793a64463aed77c615d6cb226eea5487ccfc0783043a587254cda2b6f26');
    expect(result.args).toBe('0x0430455c7db8901bee35dc70eeff078c2adfc7299200');
    expect(hashType).toBe('data');
  });

  it('btcTxIdAndAfterFromBtcTimeLockArgs', () => {
    let lockArgs =
      '0x7f000000100000005b0000005f0000004b000000100000003000000031000000d23761b364210735c19c60561d213fb3beae2fd6172743719eff6920e020baac011600000000016c61f984f12d3c8a4f649e60acda5deda0b8837c060000007213bf894727c1b3cb99556549c01c73ba439ecf84d5f6974b3928bc025f4ed4';
    const { btcTxId, after } = btcTxIdAndAfterFromBtcTimeLockArgs(lockArgs);
    expect(btcTxId).toBe('0xd44e5f02bc28394b97f6d584cf9e43ba731cc049655599cbb3c1274789bf1372');
    expect(after).toBe(6);

    lockArgs =
      '0x7f000000100000005b0000005f0000004b0000001000000030000000310000009b819793a64463aed77c615d6cb226eea5487ccfc0783043a587254cda2b6f2601160000000430455c7db8901bee35dc70eeff078c2adfc729920006000000964663ab3b35fd5f02ac29f268ea29401504255707c0b3a943fe143196e80770';
    const result = btcTxIdAndAfterFromBtcTimeLockArgs(lockArgs);
    expect(result.btcTxId).toBe('0x7007e8963114fe43a9b3c007572504154029ea68f229ac025ffd353bab634696');
    expect(result.after).toBe(6);
  });

  it('calculateUdtCellCapacity', () => {
    const joyIDLock: CKBComponents.Script = {
      codeHash: '0xd23761b364210735c19c60561d213fb3beae2fd6172743719eff6920e020baac',
      hashType: 'type',
      args: '0x0001f21be6c96d2103946d37a1ee882011f7530a92a7',
    };
    const xudtType: CKBComponents.Script = {
      codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
      hashType: 'type',
      args: '0x06ec22c2def100bba3e295a1ff279c490d227151bf3166a4f3f008906c849399',
    };
    const capacity = calculateUdtCellCapacity(joyIDLock, xudtType);
    expect(BigInt(145_0000_0000)).toBe(capacity);
  });

  it('buildRgbppLockArgs', () => {
    const expected = buildRgbppLockArgs(2, '0x9993846c9008f0f3a46631bf5171220d499c27ffa195e2a3bb00f1dec222ec06');
    expect('0x0200000006ec22c2def100bba3e295a1ff279c490d227151bf3166a4f3f008906c849399').toBe(expected);
  });

  it('buildPreLockArgs', () => {
    expect('0x020000000000000000000000000000000000000000000000000000000000000000000000').toBe(buildPreLockArgs(2));
  });

  it('unpackRgbppLockArgs', () => {
    const unpacked = unpackRgbppLockArgs('0x0200000006ec22c2def100bba3e295a1ff279c490d227151bf3166a4f3f008906c849399');
    expect('0x9993846c9008f0f3a46631bf5171220d499c27ffa195e2a3bb00f1dec222ec06').toBe(unpacked.btcTxId);
    expect(2).toBe(unpacked.outIndex);
  });

  it('replaceRealBtcTxId', () => {
    const rgbppLockArgs = '0x020000000000000000000000000000000000000000000000000000000000000000000000';
    const realBtcTxId = '0x9993846c9008f0f3a46631bf5171220d499c27ffa195e2a3bb00f1dec222ec06';
    const lockArgs = replaceLockArgsWithRealBtcTxId(rgbppLockArgs, realBtcTxId);
    expect('0x0200000006ec22c2def100bba3e295a1ff279c490d227151bf3166a4f3f008906c849399').toBe(lockArgs);

    const btcTimeLockArgs =
      '0x850000001000000061000000650000005100000010000000300000003100000028e83a1277d48add8e72fadaa9248559e1b632bab2bd60b27955ebc4c03800a500c0a45d9d7c024adcc8076c18b3f07c08de7c42120cdb7e6cbc05a28266b15b5f060000000000000000000000000000000000000000000000000000000000000000000000';
    const args = replaceLockArgsWithRealBtcTxId(btcTimeLockArgs, realBtcTxId);
    expect(
      '0x850000001000000061000000650000005100000010000000300000003100000028e83a1277d48add8e72fadaa9248559e1b632bab2bd60b27955ebc4c03800a500c0a45d9d7c024adcc8076c18b3f07c08de7c42120cdb7e6cbc05a28266b15b5f0600000006ec22c2def100bba3e295a1ff279c490d227151bf3166a4f3f008906c849399',
    ).toBe(args);
  });

  it('transformSpvProof', () => {
    const expected = transformSpvProof({
      spv_client: {
        tx_hash: '0x047b6894a0b7a4d7a73b1503d1ae35c51fc5fa6306776dcf22b1fb3daaa32a29',
        index: '0xa',
      },
      proof: '0x2f061a27abcab1d1d146514ffada6a83c0d974fe0813835ad8be2a39a6b1a6ee',
    });
    expect('0x047b6894a0b7a4d7a73b1503d1ae35c51fc5fa6306776dcf22b1fb3daaa32a29').toBe(expected.spvClient.txHash);
    expect('0xa').toBe(expected.spvClient.index);
    expect('0x2f061a27abcab1d1d146514ffada6a83c0d974fe0813835ad8be2a39a6b1a6ee').toBe(expected.proof);
  });

  it('estimatedWitnessSize', () => {
    const actual = estimateWitnessSize([
      '0x000000002f061a27abcab1d1d146514ffada6a83c0d974fe0813835ad8be2a39a6b1a6ee',
      '0x010000002f061a27abcab1d1d146514ffada6a83c0d974fe0813835ad8be2a39a6b1a6ee',
      '0x01000000047b6894a0b7a4d7a73b1503d1ae35c51fc5fa6306776dcf22b1fb3daaa32a29',
      '0x010000002f061a27abcab1d1d146514ffada6a83c0d974fe0813835ad8be2a39a6b1a6ee',
    ]);
    expect(actual).toBe(15000);
  });

  it('encodeRgbppTokenInfo', () => {
    const actual = encodeRgbppTokenInfo({ decimal: 8, name: 'RGBPP Test Token', symbol: 'RTT' });
    expect(actual).toBe('0x08105247425050205465737420546f6b656e03525454');
  });

  it('calculateRgbppTokenInfoSize', () => {
    const actual = calculateRgbppTokenInfoSize({ decimal: 8, name: 'RGBPP Test Token', symbol: 'RTT' });
    expect(actual).toBe(BigInt(22));
  });

  it('throwErrorWhenTxInputsExceeded', () => {
    try {
      throwErrorWhenTxInputsExceeded(10);
    } catch (error) {
      if (error instanceof RgbppCkbTxInputsExceededError) {
        expect(109).toBe(error.code);
        expect('Please ensure the tx inputs do not exceed 10').toBe(error.message);
      }
    }
  });

  it('throwErrorWhenRgbppCellsInvalid', () => {
    const xudtTypeBytes = serializeScript({
      ...getXudtTypeScript(false),
      args: '0x205fe15af04e59d3ff1ff8e0b0a1e3bc201af406a38964760c24848ed6029b6b',
    });

    try {
      throwErrorWhenRgbppCellsInvalid([], xudtTypeBytes, false);
    } catch (error) {
      if (error instanceof NoRgbppLiveCellError) {
        expect(104).toBe(error.code);
        expect('No rgbpp cells found with the rgbpp lock args').toBe(error.message);
      }
    }

    const typeNullCells: IndexerCell[] = [
      {
        blockNumber: '0x0',
        outPoint: {
          txHash: '0xf2bfcd0ec5f7b2a33577168b7a647e71cc81a731560a7ad23b1c31fc08bbe1bb',
          index: '0x1',
        },
        output: {
          capacity: '0x460913c00',
          lock: {
            args: '0x0200000050b34b391fd8f8084bf9b6af4368350c1510df4964496b87495ebee4bd8d86d5',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
        },
        outputData: '0x2d000000100000001e0000002d0000000a000000746578742f706c61696e0b00000046697273742053706f7265',
        txIndex: '0x0',
      },
    ];
    try {
      throwErrorWhenRgbppCellsInvalid(typeNullCells, xudtTypeBytes, false);
    } catch (error) {
      if (error instanceof NoRgbppLiveCellError) {
        expect(104).toBe(error.code);
        expect('No rgbpp cells found with the rgbpp lock args').toBe(error.message);
      }
    }

    const nonXUDTCells: IndexerCell[] = [
      {
        blockNumber: '0x0',
        outPoint: {
          txHash: '0xf2bfcd0ec5f7b2a33577168b7a647e71cc81a731560a7ad23b1c31fc08bbe1bb',
          index: '0x1',
        },
        output: {
          capacity: '0x460913c00',
          lock: {
            args: '0x0200000050b34b391fd8f8084bf9b6af4368350c1510df4964496b87495ebee4bd8d86d5',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xf2bfcd0ec5f7b2a33577168b7a647e71cc81a731560a7ad23b1c31fc08bbe1bb',
            codeHash: '0xf2bfcd0ec5f7b2a33577168b7a647e71cc81a731560a7ad23b1c31fc08bbe1bb',
            hashType: 'data1',
          },
        },
        outputData: '0x2d000000100000001e0000002d0000000a000000746578742f706c61696e0b00000046697273742053706f7265',
        txIndex: '0x0',
      },
    ];
    try {
      throwErrorWhenRgbppCellsInvalid(nonXUDTCells, xudtTypeBytes, false);
    } catch (error) {
      if (error instanceof RgbppUtxoBindMultiTypeAssetsError) {
        expect(110).toBe(error.code);
        expect('The BTC UTXO must not be bound to xUDT and other type cells at the same time').toBe(error.message);
      }
    }

    const noTargetCells: IndexerCell[] = [
      {
        blockNumber: '0x0',
        outPoint: {
          txHash: '0xf2bfcd0ec5f7b2a33577168b7a647e71cc81a731560a7ad23b1c31fc08bbe1bb',
          index: '0x1',
        },
        output: {
          capacity: '0x460913c00',
          lock: {
            args: '0x0200000050b34b391fd8f8084bf9b6af4368350c1510df4964496b87495ebee4bd8d86d5',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xf2bfcd0ec5f7b2a33577168b7a647e71cc81a731560a7ad23b1c31fc08bbe1bb',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'data1',
          },
        },
        outputData: '0x2d000000100000001e0000002d0000000a000000746578742f706c61696e0b00000046697273742053706f7265',
        txIndex: '0x0',
      },
    ];
    try {
      throwErrorWhenRgbppCellsInvalid(noTargetCells, xudtTypeBytes, false);
    } catch (error) {
      if (error instanceof NoRgbppLiveCellError) {
        expect(104).toBe(error.code);
        expect('No rgbpp cells found with the xudt type script and the rgbpp lock args').toBe(error.message);
      }
    }
  });

  it('isRgbppCapacityEnoughForChange', () => {
    expect(false).toBe(
      isRgbppCapacitySufficientForChange(BigInt(500) * BigInt(10000_0000), BigInt(254) * BigInt(10000_0000)),
    );
    expect(false).toBe(
      isRgbppCapacitySufficientForChange(BigInt(507) * BigInt(10000_0000), BigInt(254) * BigInt(10000_0000)),
    );
    expect(true).toBe(
      isRgbppCapacitySufficientForChange(BigInt(508) * BigInt(10000_0000), BigInt(254) * BigInt(10000_0000)),
    );
  });
});


================================================
File: packages/ckb/src/utils/rgbpp.ts
================================================
import { sha256 } from 'js-sha256';
import { RgbppApiSpvProof } from '@rgbpp-sdk/service';
import { BTCTestnetType, Hex, IndexerCell, RgbppCkbVirtualTx, RgbppTokenInfo, SpvClientCellTxProof } from '../types';
import { append0x, remove0x, reverseHex, u32ToLe, u8ToHex, utf8ToHex } from './hex';
import {
  BTC_JUMP_CONFIRMATION_BLOCKS,
  RGBPP_TX_ID_PLACEHOLDER,
  RGBPP_TX_INPUTS_MAX_LENGTH,
  RGBPP_TX_WITNESS_MAX_SIZE,
  getBtcTimeLockScript,
  getRgbppLockScript,
} from '../constants';
import { RGBPPLock } from '../schemas/generated/rgbpp';
import { BTCTimeLock } from '../schemas/generated/rgbpp';
import { Script } from '../schemas/generated/blockchain';
import { BytesLike } from '@ckb-lumos/codec';
import { toCamelcase } from './case-parser';
import {
  InputsOrOutputsLenError,
  NoRgbppLiveCellError,
  RgbppCkbTxInputsExceededError,
  RgbppUtxoBindMultiTypeAssetsError,
} from '../error';
import { calculateRgbppCellCapacity, isScriptEqual, isUDTTypeSupported } from './ckb-tx';
import { blockchain } from '@ckb-lumos/base';
import {
  bytesToHex,
  hexToBytes,
  serializeOutPoint,
  serializeOutput,
  serializeScript,
} from '@nervosnetwork/ckb-sdk-utils';
import { HashType } from '../schemas/customized';
import { CellDepsObject } from './cell-dep';

export const genRgbppLockScript = (rgbppLockArgs: Hex, isMainnet: boolean, btcTestnetType?: BTCTestnetType) => {
  return {
    ...getRgbppLockScript(isMainnet, btcTestnetType),
    args: append0x(rgbppLockArgs),
  } as CKBComponents.Script;
};

export const genBtcTimeLockArgs = (lock: CKBComponents.Script, btcTxId: Hex, after: number): Hex => {
  const btcTxid = blockchain.Byte32.pack(reverseHex(btcTxId));
  const lockScript = Script.unpack(serializeScript(lock));
  return bytesToHex(BTCTimeLock.pack({ lockScript, after, btcTxid }));
};

/**
 * btcTimeLockArgs: 
 * table BTCTimeLock {
    lock_script: Script,
    after: Uint32,
    btc_txid: Byte32,
  }
 */
export const genBtcTimeLockScript = (
  toLock: CKBComponents.Script,
  isMainnet: boolean,
  btcTestnetType?: BTCTestnetType,
  btcConfirmationBlocks?: number,
) => {
  const args = genBtcTimeLockArgs(
    toLock,
    RGBPP_TX_ID_PLACEHOLDER,
    btcConfirmationBlocks ?? BTC_JUMP_CONFIRMATION_BLOCKS,
  );
  return {
    ...getBtcTimeLockScript(isMainnet, btcTestnetType),
    args,
  } as CKBComponents.Script;
};

// The maximum length of inputs and outputs is 255, and the field type representing the length in the RGB++ protocol is Uint8
const MAX_RGBPP_CELL_NUM = 255;
// refer to https://github.com/ckb-cell/rgbpp/blob/0c090b039e8d026aad4336395b908af283a70ebf/contracts/rgbpp-lock/src/main.rs#L173-L211
export const calculateCommitment = (rgbppVirtualTx: RgbppCkbVirtualTx | CKBComponents.RawTransaction): Hex => {
  const hash = sha256.create();
  hash.update(hexToBytes(utf8ToHex('RGB++')));
  const version = [0, 0];
  hash.update(version);

  const { inputs, outputs, outputsData } = rgbppVirtualTx;

  if (inputs.length > MAX_RGBPP_CELL_NUM || outputs.length > MAX_RGBPP_CELL_NUM) {
    throw new InputsOrOutputsLenError(
      'The inputs or outputs length of RGB++ CKB virtual tx cannot be greater than 255',
    );
  }
  hash.update([inputs.length, outputs.length]);

  for (const input of inputs) {
    hash.update(hexToBytes(serializeOutPoint(input.previousOutput)));
  }
  for (let index = 0; index < outputs.length; index++) {
    const output = outputs[index];
    const outputData = outputsData[index];
    hash.update(hexToBytes(serializeOutput(output)));

    const outputDataLen = u32ToLe(remove0x(outputData).length / 2);
    hash.update(hexToBytes(append0x(outputDataLen)));
    hash.update(hexToBytes(outputData));
  }
  // double sha256
  return sha256(hash.array());
};

/**
 * table BTCTimeLock {
    lock_script: Script,
    after: Uint32,
    btc_txid: Byte32,
  }
 */
export const lockScriptFromBtcTimeLockArgs = (args: Hex): CKBComponents.Script => {
  const { lockScript } = BTCTimeLock.unpack(append0x(args));
  return {
    ...lockScript,
    hashType: HashType.unpack(lockScript.hashType),
  };
};

export interface BTCTimeLockArgs {
  btcTxId: Hex;
  after: number;
}
export const btcTxIdAndAfterFromBtcTimeLockArgs = (args: Hex): BTCTimeLockArgs => {
  const { btcTxid, after } = BTCTimeLock.unpack(append0x(args));
  return {
    btcTxId: reverseHex(append0x(btcTxid)),
    after,
  };
};

/**
 * https://learnmeabitcoin.com/technical/general/byte-order/
 * Whenever you're working with transaction/block hashes internally (e.g. inside raw bitcoin data), you use the natural byte order.
 * Whenever you're displaying or searching for transaction/block hashes, you use the reverse byte order.
 */
export const buildRgbppLockArgs = (outIndex: number, btcTxId: Hex): Hex => {
  return `0x${u32ToLe(outIndex)}${remove0x(reverseHex(btcTxId))}`;
};

export const buildPreLockArgs = (outIndex: number) => {
  return buildRgbppLockArgs(outIndex, RGBPP_TX_ID_PLACEHOLDER);
};

export interface RgbppLockArgs {
  btcTxId: Hex;
  outIndex: number;
}
export const unpackRgbppLockArgs = (source: BytesLike): RgbppLockArgs => {
  const unpacked = RGBPPLock.unpack(source);
  return {
    btcTxId: reverseHex(unpacked.btcTxid),
    outIndex: unpacked.outIndex,
  };
};

export const compareInputs = (a: IndexerCell, b: IndexerCell) => {
  if (a.output.lock.args < b.output.lock.args) {
    return -1;
  }
  if (a.output.lock.args > b.output.lock.args) {
    return 1;
  }
  return 0;
};

/**
 * RGBPP lock args: out_index | bitcoin_tx_id
 * BTC time lock args: lock_script | after | bitcoin_tx_id
 *
 * https://learnmeabitcoin.com/technical/general/byte-order/
 * Whenever you're working with transaction/block hashes internally (e.g. inside raw bitcoin data), you use the natural byte order.
 * Whenever you're displaying or searching for transaction/block hashes, you use the reverse byte order.
 */
const RGBPP_MIN_LOCK_ARGS_SIZE = 36 * 2;
const BTC_TX_ID_SIZE = 32 * 2;
export const replaceLockArgsWithRealBtcTxId = (lockArgs: Hex, txId: Hex): Hex => {
  const argsLength = remove0x(lockArgs).length;
  if (argsLength < RGBPP_MIN_LOCK_ARGS_SIZE) {
    throw new Error('Rgbpp lock args or BTC time lock args length is invalid');
  }
  return `0x${remove0x(lockArgs).substring(0, argsLength - BTC_TX_ID_SIZE)}${remove0x(reverseHex(txId))}`;
};

const BTC_TESTNETS: BTCTestnetType[] = ['Testnet3', 'Signet'];
const isLockEqual = (lock1: CKBComponents.Script, lock2: CKBComponents.Script) =>
  lock1.codeHash === lock2.codeHash && lock1.hashType === lock2.hashType;

export const isRgbppLockCell = (cell: CKBComponents.CellOutput, isMainnet: boolean): boolean => {
  if (isMainnet) {
    return isLockEqual(cell.lock, getRgbppLockScript(isMainnet));
  }
  return BTC_TESTNETS.some((network) => isLockEqual(cell.lock, getRgbppLockScript(isMainnet, network)));
};

export const isRgbppLockCellIgnoreChain = (cell: CKBComponents.CellOutput): boolean => {
  return isRgbppLockCell(cell, true) || isRgbppLockCell(cell, false);
};

export const isBtcTimeLockCell = (cell: CKBComponents.CellOutput, isMainnet: boolean): boolean => {
  if (isMainnet) {
    return isLockEqual(cell.lock, getBtcTimeLockScript(isMainnet));
  }
  return BTC_TESTNETS.some((network) => isLockEqual(cell.lock, getBtcTimeLockScript(isMainnet, network)));
};

export const isRgbppLockOrBtcTimeLock = (lock: CKBComponents.Script, isMainnet: boolean) => {
  if (isMainnet) {
    return isLockEqual(lock, getRgbppLockScript(isMainnet)) || isLockEqual(lock, getBtcTimeLockScript(isMainnet));
  }
  return BTC_TESTNETS.flatMap((network) => [
    getRgbppLockScript(isMainnet, network),
    getBtcTimeLockScript(isMainnet, network),
  ]).some((script) => isLockEqual(script, lock));
};

export const transformSpvProof = (spvProof: RgbppApiSpvProof): SpvClientCellTxProof => {
  return toCamelcase(spvProof) as SpvClientCellTxProof;
};

export const buildSpvClientCellDep = (spvClient: CKBComponents.OutPoint) => {
  const cellDep: CKBComponents.CellDep = {
    outPoint: spvClient,
    depType: 'code',
  };
  return cellDep;
};

/**
 * Estimate the size of the witness based on the number of groups of lock args
 * @param rgbppLockArgsList The rgbpp assets cell lock script args array whose data structure is: out_index | bitcoin_tx_id
 */
export const estimateWitnessSize = (rgbppLockArgsList: Hex[]): number => {
  const rgbppLockArgsSet = new Set(rgbppLockArgsList);
  const inputsGroupSize = rgbppLockArgsSet.size;
  return RGBPP_TX_WITNESS_MAX_SIZE * inputsGroupSize;
};

/**
 * Encode RGBPP token information into hex format
 * @param tokenInfo RGBPP token information
 * @returns hex string for cell data
 */
export const encodeRgbppTokenInfo = (tokenInfo: RgbppTokenInfo) => {
  const decimal = u8ToHex(tokenInfo.decimal);
  const name = remove0x(utf8ToHex(tokenInfo.name));
  const nameSize = u8ToHex(name.length / 2);
  const symbol = remove0x(utf8ToHex(tokenInfo.symbol));
  const symbolSize = u8ToHex(symbol.length / 2);
  return `0x${decimal}${nameSize}${name}${symbolSize}${symbol}`;
};

export const calculateRgbppTokenInfoSize = (tokenInfo: RgbppTokenInfo): bigint => {
  const encodedTokenInfo = encodeRgbppTokenInfo(tokenInfo);
  return BigInt(remove0x(encodedTokenInfo).length / 2);
};

export const throwErrorWhenTxInputsExceeded = (inputLen: number) => {
  if (inputLen > RGBPP_TX_INPUTS_MAX_LENGTH) {
    throw new RgbppCkbTxInputsExceededError(`Please ensure the tx inputs do not exceed ${RGBPP_TX_INPUTS_MAX_LENGTH}`);
  }
};

// Check the validity of RGB++ cells and throw an exception if the conditions are not met to avoid building invalid CKB TX
export const throwErrorWhenRgbppCellsInvalid = (
  cells: IndexerCell[] | undefined,
  xudtTypeBytes: Hex,
  isMainnet: boolean,
  isOffline?: boolean,
) => {
  if (!cells || cells.length === 0) {
    throw new NoRgbppLiveCellError('No rgbpp cells found with the rgbpp lock args');
  }
  const typeCells = cells.filter((cell) => !!cell.output.type);
  if (typeCells.length === 0) {
    throw new NoRgbppLiveCellError('No rgbpp cells found with the rgbpp lock args');
  }

  const isUDTTypeNotSupported = typeCells.some(
    (cell) => cell.output.type && !isUDTTypeSupported(cell.output.type, isMainnet, isOffline),
  );
  if (isUDTTypeNotSupported) {
    throw new RgbppUtxoBindMultiTypeAssetsError(
      'The BTC UTXO must not be bound to xUDT and other type cells at the same time',
    );
  }

  const isTargetExist = typeCells.some((cell) => isScriptEqual(cell.output.type!, xudtTypeBytes));
  if (!isTargetExist) {
    throw new NoRgbppLiveCellError('No rgbpp cells found with the xudt type script and the rgbpp lock args');
  }
};

/**
 * Check if the tx's unoccupied capacity is enough to create a new rgbpp-cell as a UDT change cell
 */
export const isRgbppCapacitySufficientForChange = (
  sumUdtInputsCapacity: bigint,
  receiverOutputCapacity: bigint,
): boolean => {
  const rgbppOccupiedCapacity = calculateRgbppCellCapacity();
  return sumUdtInputsCapacity > receiverOutputCapacity + rgbppOccupiedCapacity;
};

/**
 * When vendorCellDeps is provided, this indicates offline mode, which means cellDeps and compatible xUDT Type Scripts will not be fetched through network requests
 */
export const isOfflineMode = (vendorCellDeps: CellDepsObject | undefined) => {
  return vendorCellDeps === undefined;
};


================================================
File: packages/ckb/src/utils/spore.spec.ts
================================================
import { describe, it, expect } from 'vitest';
import {
  generateClusterId,
  generateSporeCreateCoBuild,
  generateSporeTransferCoBuild,
  throwErrorWhenSporeCellsInvalid,
} from './spore';
import { IndexerCell } from '../types';
import { getSporeTypeScript } from '../constants';
import { serializeScript } from '@nervosnetwork/ckb-sdk-utils';
import { NoRgbppLiveCellError, RgbppSporeTypeMismatchError, RgbppUtxoBindMultiTypeAssetsError } from '../error';

describe('spore utils', () => {
  it('generateClusterId', () => {
    const firstInput = {
      previousOutput: {
        txHash: '0x047b6894a0b7a4d7a73b1503d1ae35c51fc5fa6306776dcf22b1fb3daaa32a29',
        index: '0x0',
      },
      since: '0x0',
    };

    const typeId = generateClusterId(firstInput, 0);
    expect(typeId).toBe('0xdc03ec5c4086fcb813707c6dd8bf5b9848d7e335e9c39389bfc9e6f9e65150ca');
  });

  it('generateSporeCreateCoBuild', () => {
    const ckbTx: CKBComponents.RawTransaction = JSON.parse(
      `{"version":"0x0","cellDeps":[{"outPoint":{"txHash":"0xf1de59e973b85791ec32debbba08dff80c63197e895eb95d67fc1e9f6b413e00","index":"0x0"},"depType":"code"},{"outPoint":{"txHash":"0xf1de59e973b85791ec32debbba08dff80c63197e895eb95d67fc1e9f6b413e00","index":"0x1"},"depType":"code"},{"outPoint":{"txHash":"0xcebb174d6e300e26074aea2f5dbd7f694bb4fe3de52b6dfe205e54f90164510a","index":"0x0"},"depType":"code"},{"outPoint":{"txHash":"0x5e8d2a517d50fd4bb4d01737a7952a1f1d35c8afc77240695bb569cd7d9d5a1f","index":"0x0"},"depType":"code"},{"outPoint":{"txHash":"0x6550bd4d93d121e3cb41754c4d77dbd23d87197504f415eeddce96f229edae8f","index":"0x1"},"depType":"code"},{"outPoint":{"txHash":"0xf8de3bb47d055cdf460d93a2a6e1b05f7432f9777c8c474abf4eec1d4aee5d37","index":"0x0"},"depType":"depGroup"}],"headerDeps":[],"inputs":[{"previousOutput":{"index":"0x0","txHash":"0xf0c18d9511cb7cd64901c7b7eff7e3e9ba0ec51a21b2c5d3c8edba938ef43b07"},"since":"0x0"},{"previousOutput":{"txHash":"0x17a43bd8694e976bdbf4fa74cbd503d9846e9d7c5b3501925d35aef17dbaf4da","index":"0x1"},"since":"0x0"},{"previousOutput":{"txHash":"0xadf1c0462013cb46cb4bb3420ec564b3af9e96a6d15f27526aeb34f78d54285f","index":"0x2"},"since":"0x0"},{"previousOutput":{"txHash":"0xe22ebc15d15117c9d34885acf9dac3c9d71f4a5541a63ff25ad5135dc52ca9b1","index":"0x2"},"since":"0x0"},{"previousOutput":{"txHash":"0xf56d3a5f9a5634f6447fcafd0fc3cad4bde25efcb1d4f54a6d097bc6755f82e3","index":"0x2"},"since":"0x0"}],"outputs":[{"capacity":"0x4c5e51c9d","lock":{"codeHash":"0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248","hashType":"type","args":"0x0100000050b34b391fd8f8084bf9b6af4368350c1510df4964496b87495ebee4bd8d86d5"},"type":{"args":"0xbc5168a4f90116fada921e185d4b018e784dc0f6266e539a3c092321c932700a","codeHash":"0x0bbe768b519d8ea7b96d58f1182eb7e6ef96c541fbd9526975077ee09f049058","hashType":"data1"}},{"lock":{"codeHash":"0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248","hashType":"type","args":"0x0200000050b34b391fd8f8084bf9b6af4368350c1510df4964496b87495ebee4bd8d86d5"},"type":{"codeHash":"0x685a60219309029d01310311dba953d67029170ca4848a4ff638e57002130a0d","hashType":"data1","args":"0x205fe15af04e59d3ff1ff8e0b0a1e3bc201af406a38964760c24848ed6029b6b"},"capacity":"0x460913c00"},{"lock":{"codeHash":"0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248","hashType":"type","args":"0x0300000050b34b391fd8f8084bf9b6af4368350c1510df4964496b87495ebee4bd8d86d5"},"type":{"codeHash":"0x685a60219309029d01310311dba953d67029170ca4848a4ff638e57002130a0d","hashType":"data1","args":"0x8c72c7831de29dd1a4d95b2b187cf4a6d22536d75492f6b3ea8261f35aee2682"},"capacity":"0x466871d00"},{"lock":{"codeHash":"0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8","hashType":"type","args":"0x75178f34549c5fe9cd1a0c57aebd01e7ddf9249e"},"capacity":"0x1b3fb2fe87e3"}],"outputsData":["0x3e00000010000000200000003e0000000c000000436c7573746572206e616d651a0000004465736372697074696f6e206f662074686520636c7573746572","0x2d000000100000001e0000002d0000000a000000746578742f706c61696e0b00000046697273742053706f7265","0x2e000000100000001e0000002e0000000a000000746578742f706c61696e0c0000005365636f6e642053706f7265","0x"],"witnesses":["0x","0x","0x","0x","0x","0x"]}`,
    );

    const clusterCell: IndexerCell = {
      blockNumber: '0x0',
      outPoint: {
        txHash: '0xf0c18d9511cb7cd64901c7b7eff7e3e9ba0ec51a21b2c5d3c8edba938ef43b07',
        index: '0x0',
      },
      output: {
        ...ckbTx.outputs[0],
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          hashType: 'type',
          args: '0x010000004442ba224799de3cc23590789bb180a43f676a07699e43fae0f7d815876d17f7',
        },
      },
      outputData:
        '0x3e00000010000000200000003e0000000c000000436c7573746572206e616d651a0000004465736372697074696f6e206f662074686520636c7573746572',
      txIndex: '0x0',
    };

    const cobuild = generateSporeCreateCoBuild({
      clusterCell,
      clusterOutputCell: ckbTx.outputs[0],
      sporeOutputs: ckbTx.outputs.slice(1, 3),
      sporeOutputsData: ckbTx.outputsData.slice(1, 3),
    });
    expect(cobuild).toBe(
      '0x010000ff740300000c000000100000000000000064030000080000005c030000100000005201000057020000420100001000000030000000500000008b478561829d384ac1832a78bbb62b9b8d64a4f8970b0d4cd1eaa6f7d8738638552ea5a271a96cd8442d7501f05ffbe07bcc1033982e7a369bfd38b9cc1060baee00000004000000ea00000010000000300000008d000000bc5168a4f90116fada921e185d4b018e784dc0f6266e539a3c092321c932700a000000005900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c32480124000000010000004442ba224799de3cc23590789bb180a43f676a07699e43fae0f7d815876d17f7000000005900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c324801240000000100000050b34b391fd8f8084bf9b6af4368350c1510df4964496b87495ebee4bd8d86d505010000100000003000000050000000aad7f6a215b3b115dcf4a5c595b05aac12013adf97278d163cc4bb9a7987414a7d70430a5c4be5955b954abb394afb745a9027ba931dab9575ef45f3303947c7b100000000000000ad00000010000000300000008d000000205fe15af04e59d3ff1ff8e0b0a1e3bc201af406a38964760c24848ed6029b6b000000005900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c324801240000000200000050b34b391fd8f8084bf9b6af4368350c1510df4964496b87495ebee4bd8d86d5659c98d1e69d14a7198f2d0ea589be71caa7d34d01de3ae9371d9fa81d8b693d05010000100000003000000050000000fd5cfb4595e35c17eb4a98f131e079c843b0a376f036b3fbf962f1198c4769f6dd7b9800ec88fe828c6a8e91773d0214df9b1880ece3abded2f4cab584bb775db100000000000000ad00000010000000300000008d0000008c72c7831de29dd1a4d95b2b187cf4a6d22536d75492f6b3ea8261f35aee2682000000005900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c324801240000000300000050b34b391fd8f8084bf9b6af4368350c1510df4964496b87495ebee4bd8d86d5ec2e91d4fb973de32f149fe5070422b86c2f8408e481cacc54e9a967b01d08dd',
    );
  });

  it('generateSporeTransferCoBuild', () => {
    const sporeIndexerCell: IndexerCell = {
      blockNumber: '0x0',
      outPoint: {
        txHash: '0xf2bfcd0ec5f7b2a33577168b7a647e71cc81a731560a7ad23b1c31fc08bbe1bb',
        index: '0x1',
      },
      output: {
        capacity: '0x460913c00',
        lock: {
          args: '0x0200000050b34b391fd8f8084bf9b6af4368350c1510df4964496b87495ebee4bd8d86d5',
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          hashType: 'type',
        },
        type: {
          args: '0x205fe15af04e59d3ff1ff8e0b0a1e3bc201af406a38964760c24848ed6029b6b',
          codeHash: '0x685a60219309029d01310311dba953d67029170ca4848a4ff638e57002130a0d',
          hashType: 'data1',
        },
      },
      outputData: '0x2d000000100000001e0000002d0000000a000000746578742f706c61696e0b00000046697273742053706f7265',
      txIndex: '0x0',
    };
    const sporeOutput: CKBComponents.CellOutput = {
      ...sporeIndexerCell.output,
      lock: {
        args: '0x01000000e190b9af52d5c497d9b1635314f833f2853c966a285df826d1dbac3ec1c803f2',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
    };

    const cobuild = generateSporeTransferCoBuild([sporeIndexerCell], [sporeOutput]);
    expect(cobuild).toBe(
      '0x010000ff620100000c000000100000000000000052010000080000004a0100000800000042010000100000003000000050000000aad7f6a215b3b115dcf4a5c595b05aac12013adf97278d163cc4bb9a7987414a7d70430a5c4be5955b954abb394afb745a9027ba931dab9575ef45f3303947c7ee00000001000000ea00000010000000300000008d000000205fe15af04e59d3ff1ff8e0b0a1e3bc201af406a38964760c24848ed6029b6b000000005900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c324801240000000200000050b34b391fd8f8084bf9b6af4368350c1510df4964496b87495ebee4bd8d86d5000000005900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248012400000001000000e190b9af52d5c497d9b1635314f833f2853c966a285df826d1dbac3ec1c803f2',
    );

    const sporeLiveCell: CKBComponents.LiveCell = {
      data: {
        content: '0x2d000000100000001e0000002d0000000a000000746578742f706c61696e0b00000046697273742053706f7265',
        hash: '',
      },
      output: sporeIndexerCell.output,
    };

    const sporeCoBuild = generateSporeTransferCoBuild([sporeLiveCell], [sporeOutput]);
    expect(sporeCoBuild).toBe(
      '0x010000ff620100000c000000100000000000000052010000080000004a0100000800000042010000100000003000000050000000aad7f6a215b3b115dcf4a5c595b05aac12013adf97278d163cc4bb9a7987414a7d70430a5c4be5955b954abb394afb745a9027ba931dab9575ef45f3303947c7ee00000001000000ea00000010000000300000008d000000205fe15af04e59d3ff1ff8e0b0a1e3bc201af406a38964760c24848ed6029b6b000000005900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c324801240000000200000050b34b391fd8f8084bf9b6af4368350c1510df4964496b87495ebee4bd8d86d5000000005900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248012400000001000000e190b9af52d5c497d9b1635314f833f2853c966a285df826d1dbac3ec1c803f2',
    );
  });

  it('throwErrorWhenSporeCellsInvalid', () => {
    const sporeTypeBytes = serializeScript({
      ...getSporeTypeScript(false),
      args: '0x205fe15af04e59d3ff1ff8e0b0a1e3bc201af406a38964760c24848ed6029b6b',
    });

    try {
      throwErrorWhenSporeCellsInvalid([], sporeTypeBytes, false);
    } catch (error) {
      if (error instanceof NoRgbppLiveCellError) {
        expect(104).toBe(error.code);
        expect('No spore rgbpp cells found with the spore rgbpp lock args').toBe(error.message);
      }
    }

    const multiSporeCells: IndexerCell[] = [
      {
        blockNumber: '0x0',
        outPoint: {
          txHash: '0xf2bfcd0ec5f7b2a33577168b7a647e71cc81a731560a7ad23b1c31fc08bbe1bb',
          index: '0x1',
        },
        output: {
          capacity: '0x460913c00',
          lock: {
            args: '0x0200000050b34b391fd8f8084bf9b6af4368350c1510df4964496b87495ebee4bd8d86d5',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xf2bfcd0ec5f7b2a33577168b7a647e71cc81a731560a7ad23b1c31fc08bbe1bb',
            codeHash: '0x685a60219309029d01310311dba953d67029170ca4848a4ff638e57002130a0d',
            hashType: 'data1',
          },
        },
        outputData: '0x2d000000100000001e0000002d0000000a000000746578742f706c61696e0b00000046697273742053706f7265',
        txIndex: '0x0',
      },
      {
        blockNumber: '0x0',
        outPoint: {
          txHash: '0xf2bfcd0ec5f7b2a33577168b7a647e71cc81a731560a7ad23b1c31fc08bbe1bb',
          index: '0x1',
        },
        output: {
          capacity: '0x460913c00',
          lock: {
            args: '0x0200000050b34b391fd8f8084bf9b6af4368350c1510df4964496b87495ebee4bd8d86d5',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            codeHash: '0x685a60219309029d01310311dba953d67029170ca4848a4ff638e57002130a0d',
            hashType: 'data1',
          },
        },
        outputData: '0x2d000000100000001e0000002d0000000a000000746578742f706c61696e0b00000046697273742053706f7265',
        txIndex: '0x0',
      },
    ];
    try {
      throwErrorWhenSporeCellsInvalid(multiSporeCells, sporeTypeBytes, false);
    } catch (error) {
      if (error instanceof RgbppUtxoBindMultiTypeAssetsError) {
        expect(110).toBe(error.code);
        expect('The BTC UTXO must not be bound to multiple CKB cells').toBe(error.message);
      }
    }

    const noSupportedSporeCell: IndexerCell[] = [
      {
        blockNumber: '0x0',
        outPoint: {
          txHash: '0xf2bfcd0ec5f7b2a33577168b7a647e71cc81a731560a7ad23b1c31fc08bbe1bb',
          index: '0x1',
        },
        output: {
          capacity: '0x460913c00',
          lock: {
            args: '0x0200000050b34b391fd8f8084bf9b6af4368350c1510df4964496b87495ebee4bd8d86d5',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xf2bfcd0ec5f7b2a33577168b7a647e71cc81a731560a7ad23b1c31fc08bbe1bb',
            codeHash: '0xf2bfcd0ec5f7b2a33577168b7a647e71cc81a731560a7ad23b1c31fc08bbe1bb',
            hashType: 'data1',
          },
        },
        outputData: '0x2d000000100000001e0000002d0000000a000000746578742f706c61696e0b00000046697273742053706f7265',
        txIndex: '0x0',
      },
    ];
    try {
      throwErrorWhenSporeCellsInvalid(noSupportedSporeCell, sporeTypeBytes, false);
    } catch (error) {
      if (error instanceof RgbppSporeTypeMismatchError) {
        expect(111).toBe(error.code);
        expect('The cell type is not the supported spore type script').toBe(error.message);
      }
    }

    const noTargetCells: IndexerCell[] = [
      {
        blockNumber: '0x0',
        outPoint: {
          txHash: '0xf2bfcd0ec5f7b2a33577168b7a647e71cc81a731560a7ad23b1c31fc08bbe1bb',
          index: '0x1',
        },
        output: {
          capacity: '0x460913c00',
          lock: {
            args: '0x0200000050b34b391fd8f8084bf9b6af4368350c1510df4964496b87495ebee4bd8d86d5',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xf2bfcd0ec5f7b2a33577168b7a647e71cc81a731560a7ad23b1c31fc08bbe1bb',
            codeHash: '0x685a60219309029d01310311dba953d67029170ca4848a4ff638e57002130a0d',
            hashType: 'data1',
          },
        },
        outputData: '0x2d000000100000001e0000002d0000000a000000746578742f706c61696e0b00000046697273742053706f7265',
        txIndex: '0x0',
      },
    ];
    try {
      throwErrorWhenSporeCellsInvalid(noTargetCells, sporeTypeBytes, false);
    } catch (error) {
      if (error instanceof RgbppSporeTypeMismatchError) {
        expect(111).toBe(error.code);
        expect('The spore cell type with the rgbpp lock args does not match').toBe(error.message);
      }
    }
  });
});


================================================
File: packages/ckb/src/utils/spore.ts
================================================
import { Cell as LumosCell } from '@ckb-lumos/base';
import { UnpackResult } from '@ckb-lumos/codec';
import {
  Action,
  assembleTransferSporeAction,
  assembleCobuildWitnessLayout,
  assembleCreateClusterAction,
  assembleCreateSporeAction,
  assembleTransferClusterAction,
} from '@spore-sdk/core/lib/cobuild/index.js';
import { u64ToLe } from './hex';
import { Hex, IndexerCell, SporesCreateCobuildParams } from '../types';
import { NoRgbppLiveCellError, RgbppSporeTypeMismatchError, RgbppUtxoBindMultiTypeAssetsError } from '../error';
import { isScriptEqual, isSporeTypeSupported } from './ckb-tx';
import { blake2b, hexToBytes, PERSONAL, serializeInput } from '@nervosnetwork/ckb-sdk-utils';

// Generate type id for cluster id
export const generateClusterId = (firstInput: CKBComponents.CellInput, firstOutputIndex: number) => {
  const input = hexToBytes(serializeInput(firstInput));
  const s = blake2b(32, null, null, PERSONAL);
  s.update(input);
  s.update(hexToBytes(`0x${u64ToLe(BigInt(firstOutputIndex))}`));
  return `0x${s.digest('hex')}`;
};

// Generate type id for spore id
export const generateSporeId = (firstInput: CKBComponents.CellInput, firstOutputIndex: number) => {
  return generateClusterId(firstInput, firstOutputIndex);
};

export const generateClusterCreateCoBuild = (
  clusterOutput: CKBComponents.CellOutput,
  clusterOutputData: Hex,
): string => {
  const output = {
    cellOutput: clusterOutput,
    data: clusterOutputData,
  } as LumosCell;
  const { actions } = assembleCreateClusterAction(output);
  return assembleCobuildWitnessLayout(actions);
};

export const generateSporeCreateCoBuild = ({
  sporeOutputs,
  sporeOutputsData,
  clusterCell,
  clusterOutputCell,
}: SporesCreateCobuildParams): string => {
  if (sporeOutputs.length !== sporeOutputsData.length) {
    throw new Error('The length of spore outputs and spore cell data are not same');
  }
  let sporeActions: UnpackResult<typeof Action>[] = [];

  // cluster transfer actions
  const clusterInput = {
    cellOutput: clusterCell.output,
    data: clusterCell.outputData,
  } as LumosCell;
  const clusterOutput = {
    cellOutput: clusterOutputCell,
    data: clusterCell.outputData,
  } as LumosCell;
  const { actions } = assembleTransferClusterAction(clusterInput, clusterOutput);
  sporeActions = sporeActions.concat(actions);

  // spores create actions
  for (let index = 0; index < sporeOutputs.length; index++) {
    const sporeOutput = {
      cellOutput: sporeOutputs[index],
      data: sporeOutputsData[index],
    } as LumosCell;
    const { actions } = assembleCreateSporeAction(sporeOutput);
    sporeActions = sporeActions.concat(actions);
  }
  return assembleCobuildWitnessLayout(sporeActions);
};

export const generateSporeTransferCoBuild = (
  sporeCells: IndexerCell[] | CKBComponents.LiveCell[],
  outputCells: CKBComponents.CellOutput[],
): string => {
  if (sporeCells.length !== outputCells.length) {
    throw new Error('The length of spore input cells and spore output cells are not same');
  }
  let sporeActions: UnpackResult<typeof Action>[] = [];
  for (let index = 0; index < sporeCells.length; index++) {
    const sporeCell = sporeCells[index];
    const outputData = 'outputData' in sporeCell ? sporeCell.outputData : sporeCell.data!.content!;
    const sporeInput = {
      cellOutput: sporeCells[index].output,
      data: outputData,
    } as LumosCell;
    const sporeOutput = {
      cellOutput: outputCells[index],
      data: outputData,
    } as LumosCell;
    const { actions } = assembleTransferSporeAction(sporeInput, sporeOutput);
    sporeActions = sporeActions.concat(actions);
  }
  return assembleCobuildWitnessLayout(sporeActions);
};

// Check the validity of RGB++ spore cells and throw an exception if the conditions are not met to avoid building invalid CKB TX
export const throwErrorWhenSporeCellsInvalid = (
  sporeCells: IndexerCell[] | undefined,
  sporeTypeBytes: Hex,
  isMainnet: boolean,
) => {
  if (!sporeCells || sporeCells.length === 0) {
    throw new NoRgbppLiveCellError('No spore rgbpp cells found with the spore rgbpp lock args');
  }
  if (sporeCells.length > 1) {
    throw new RgbppUtxoBindMultiTypeAssetsError('The BTC UTXO must not be bound to multiple CKB cells');
  }
  const sporeCell = sporeCells[0];

  if (!sporeCell.output.type) {
    throw new RgbppSporeTypeMismatchError('The cell with the rgbpp lock args has no spore asset');
  }

  if (!isSporeTypeSupported(sporeCell.output.type, isMainnet)) {
    throw new RgbppSporeTypeMismatchError('The cell type is not the supported spore type script');
  }

  if (!isScriptEqual(sporeCell.output.type, sporeTypeBytes)) {
    throw new RgbppSporeTypeMismatchError('The spore cell type with the rgbpp lock args does not match');
  }
};


================================================
File: packages/rgbpp/README.md
================================================
# rgbpp

RGB++ SDK

A root package to integrate of common functions from the RGB++ SDK sub-packages(btc/ckb/service).

## Installation

```
$ npm i rgbpp
# or
$ yarn add rgbpp
# or
$ pnpm add rgbpp
```

## Transfer RGB++ Assets on BTC

The function `buildRgbppTransferTx` will generate a CKB virtual transaction and a related BTC transaction with the commitment for the RGB++ assets transfer on BTC. 

The `btcPsbtHex` can be used to construct bitcoin PSBT to sign and send BTC transaction with BTC wallet, and then the BTC transaction id and `ckbVirtualTxResult` will be used to post to RGB++ Queue Service to complete the isomorphic CKB transaction.

```TypeScript
const { ckbVirtualTxResult, btcPsbtHex } = await buildRgbppTransferTx({
  ckb: {
    collector,
    xudtTypeArgs,
    rgbppLockArgsList,
    transferAmount,
    ckbFeeRate,
    // If the asset is compatible xUDT(not standard xUDT), the compatibleXudtTypeScript is required
    compatibleXudtTypeScript,
  },
  btc: {
    fromBtcAddress,
    toBtcAddress,
    btcDataSource,
    fromPubkey,
    feeRate
  },
  isMainnet,
});

// Construct PSBT with btcPsbtHex to sign and send BTC transaction with the BTC key pair
const psbt = bitcoin.Psbt.fromHex(btcPsbtHex);
psbt.signAllInputs(btcKeyPair);
psbt.finalizeAllInputs();

const btcTx = psbt.extractTransaction();
const { txid: btcTxId } = await btcService.sendBtcTransaction(btcTx.toHex());

// Post the BTC txId and ckbVirtualTxResult to the RGB++ Queue Service
await btcService.sendRgbppCkbTransaction({ btc_txid: btcTxId, ckb_virtual_result: ckbVirtualTxResult });
```

## Transfer all balance of an RGB++ Asset on BTC

Similar to using the `buildRgbppTransferTx` function, the function `buildRgbppTransferAllTxs` will generate a list of RGB++ transaction groups (a transaction group includes a CKB virtual transaction and a BTC isomorphic transaction).

You should sign all the PSBTs in the `transactions` and send all the BTC transactions, and then post all the BTC txIds and ckbVirtualTxResults to the RGB++ Queue Service. You can also review the transfer details in the `summary` object.

```TypeScript
const { transactions, summary } = await buildRgbppTransferAllTxs({
  ckb: {
    // The type script args of the target RGB++ xUDT
    xudtTypeArgs,
    // The collector that collects CKB live cells and transactions
    collector,
    // The CKB transaction fee rate, default value is 1100
    feeRate,
    // (Optional) If the asset is compatible xUDT(not standard xUDT), the compatibleXudtTypeScript is required
    compatibleXudtTypeScript,
  },
  btc: {
    // The list of BTC addresses to provide RGB++ xUDT assets
    // All available amounts of the target asset (specified by ckb.xudtTypeArgs) will be included in the transfers
    // However, if more than 40 cells are bound to the same UTXO, the amounts within those 40 cells are excluded
    assetAddresses,
    // The BTC address for paying all the transaction costs, but not provide any RGB++ xUDT assets
    fromAddress,
    // The BTC address for receiving all the RGB++ xUDT assets
    toAddress,
    // The data source for collecting Bitcoin-related info
    dataSource,
    // The public key of sender BTC address, must fill if the fromAddress is a P2TR address
    fromPubkey,
    // The map helps find the corresponding public key of a BTC address,
    // note that you must specify a pubkey for each P2TR address in assetAddresses/fromAddress
    pubkeyMap,
    // The BTC address to return change satoshi, default value is fromAddress
    changeAddress,
    // The fee rate of the BTC transactions, will use the fastest fee rate if not specified
    feeRate,
  },
  // True is for BTC and CKB Mainnet, false is for BTC Testnet3/Signet and CKB Testnet
  isMainnet,
});

// Sign BTC PSBTs with all the related BTC key pairs, and convert them to BTC transactions
const signedGroups: RgbppTxGroup[] = transactions.map((group) => {
  const psbt = bitcoin.Psbt.fromHex(group.btc.psbtHex);
  signPsbt(psbt, keyPair);
  psbt.finalizeAllInputs();

  return {
    ckbVirtualTxResult: JSON.stringify(group.ckb.virtualTxResult),
    btcTxHex: psbt.extractTransaction().toHex(),
  };
});

// Post the transaction groups to the RGB++ Queue Service
const sentResult = await sendRgbppTxGroups({
  txGroups: signedGroups,
  btcService: btcSource.service,
});

// Review the summary of the transfer
console.log(summary);
```


================================================
File: packages/rgbpp/CHANGELOG.md
================================================
# rgbpp

## 0.7.0

### Minor Changes

- [#291](https://github.com/utxostack/rgbpp-sdk/pull/291): Support RGB++ compatible xUDT assets([@duanyytop](https://github.com/duanyytop))

- [#303](https://github.com/utxostack/rgbpp-sdk/pull/303): Add offline mode support for compatible xUDT type scripts ([@fghdotio](https://github.com/fghdotio))

### Patch Changes

- [#305](https://github.com/ckb-cell/rgbpp-sdk/pull/305): Upgrade ckb-sdk-js version ([@duanyytop](https://github.com/duanyytop))

## 0.6.0

### Minor Changes

- [#281](https://github.com/ckb-cell/rgbpp-sdk/pull/281): Upgrade ckb-sdk-js to fix esm and commonjs issues ([@duanyytop](https://github.com/duanyytop))

- [#246](https://github.com/ckb-cell/rgbpp-sdk/pull/246): Export ESM packages ([@duanyytop](https://github.com/duanyytop))

- [#283](https://github.com/ckb-cell/rgbpp-sdk/pull/283): Update response of sending RGB++ group txs ([@duanyytop](https://github.com/duanyytop))

- [#270](https://github.com/ckb-cell/rgbpp-sdk/pull/270): Support for batch transferring of RGBPP XUDT assets ([@ShookLyngs](https://github.com/ShookLyngs))

  - Add `buildRgbppTransferAllTxs()` API in the rgbpp lib for generating one or more BTC/CKB transaction groups for transferring the entire amount of a specific type of RGBPP XUDT asset from one or more BTC addresses to a recipient
  - Add `sendRgbppTxGroups()` API in the rgbpp lib for sending BTC/CKB transaction groups to the `BtcAssetsApi`
  - Add `unpackRgbppLockArgs()` API in the ckb lib for unpacking the lock script args of an RGBPP Cell
  - Add `encodeCellId()` and `decodeCellId()` APIs in the ckb lib for handling the ID of a CKB Cell
  - Add `encodeUtxoId()` and `decodeUtxoId()` APIs in the btc lib for handling the ID of a BTC UTXO

### Patch Changes

- [#275](https://github.com/ckb-cell/rgbpp-sdk/pull/275): Calculate XUDT amount separately in AssetSummarizer ([@ShookLyngs](https://github.com/ShookLyngs))

- Updated dependencies [[`82d37ab`](https://github.com/ckb-cell/rgbpp-sdk/commit/82d37ab56fc2c2c1dd0437f44966380bae6c9b42), [`a2722c5`](https://github.com/ckb-cell/rgbpp-sdk/commit/a2722c535efa04c9a9a8147228c82957fe33143d), [`a9a787d`](https://github.com/ckb-cell/rgbpp-sdk/commit/a9a787d059950b5e8d3641688680e31e3635f35a), [`a31a376`](https://github.com/ckb-cell/rgbpp-sdk/commit/a31a3761056754fb6624ff571736cf18ccbdcd98), [`ec2a38e`](https://github.com/ckb-cell/rgbpp-sdk/commit/ec2a38ec5858380b2ca34de596d1eb98d1db4611)]:
  - @rgbpp-sdk/btc@0.6.0
  - @rgbpp-sdk/ckb@0.6.0
  - @rgbpp-sdk/service@0.6.0

## v0.5.0

### Patch Changes

- Updated dependencies [[`9afc2a9`](https://github.com/ckb-cell/rgbpp-sdk/commit/9afc2a911e6a4ba8a200755b01159b5b149e4010), [`8f99429`](https://github.com/ckb-cell/rgbpp-sdk/commit/8f99429de45899e5169771e87e73603318a49ae8), [`475b3c3`](https://github.com/ckb-cell/rgbpp-sdk/commit/475b3c35ab1a25ba3aae28123f2820460101c889), [`1a8bb1c`](https://github.com/ckb-cell/rgbpp-sdk/commit/1a8bb1c8c305ddaba80e139a0730c9c76f8c7784)]:
  - @rgbpp-sdk/ckb@0.5.0
  - @rgbpp-sdk/btc@0.5.0
  - @rgbpp-sdk/service@0.5.0

## v0.4.0

### Minor Changes

- [#216](https://github.com/ckb-cell/rgbpp-sdk/pull/216): Export buildRgbppTransferTx from rgbpp package ([@duanyytop](https://github.com/duanyytop))

### Patch Changes

- Updated dependencies [[`1ecac34`](https://github.com/ckb-cell/rgbpp-sdk/commit/1ecac341d5ced04e59bfdcd432a9bce84bedd959), [`e5f41fd`](https://github.com/ckb-cell/rgbpp-sdk/commit/e5f41fd2b275182d2ab3fdf17e3b8853025fd2b9), [`08200c9`](https://github.com/ckb-cell/rgbpp-sdk/commit/08200c974ef336661723cc7556a003932babda9a), [`6e840c1`](https://github.com/ckb-cell/rgbpp-sdk/commit/6e840c196fbece06430c559aebbdadaf7fb6e632)]:
  - @rgbpp-sdk/btc@0.4.0
  - @rgbpp-sdk/service@0.4.0
  - @rgbpp-sdk/ckb@0.4.0

## v0.3.0

### Patch Changes

- Updated dependencies [[`d2d963c`](https://github.com/ckb-cell/rgbpp-sdk/commit/d2d963c8f40d0316491df5bdccca4eba7a33977c), [`4c77e69`](https://github.com/ckb-cell/rgbpp-sdk/commit/4c77e69cadc8ce3d24f631c1348dcd7141fb1099), [`3d41751`](https://github.com/ckb-cell/rgbpp-sdk/commit/3d417518c0224c6cd3cc3e55123cf4a691c0a976), [`4f05b1b`](https://github.com/ckb-cell/rgbpp-sdk/commit/4f05b1bba898b7acb58bdf20ae275164ad94523b), [`d0e62e2`](https://github.com/ckb-cell/rgbpp-sdk/commit/d0e62e2be8e21f02a84753cbc0f2200c8f88f155)]:
  - @rgbpp-sdk/ckb@0.3.0
  - @rgbpp-sdk/btc@0.3.0
  - @rgbpp-sdk/service@0.3.0

## v0.2.0

### Minor Changes

- [#157](https://github.com/ckb-cell/rgbpp-sdk/pull/157): Add rgbpp sub package ([@duanyytop](https://github.com/duanyytop))

### Patch Changes

- [#177](https://github.com/ckb-cell/rgbpp-sdk/pull/177): Fix the export of NetworkType/AddressType in the rgbpp lib ([@ShookLyngs](https://github.com/ShookLyngs))

- Updated dependencies [[`8a8e11b`](https://github.com/ckb-cell/rgbpp-sdk/commit/8a8e11bdca4d3fb8b8d20c771e116bb1684bb1c6), [`5e0e817`](https://github.com/ckb-cell/rgbpp-sdk/commit/5e0e8175a4c195e6491a37abedc755728c91cbed), [`a9b9796`](https://github.com/ckb-cell/rgbpp-sdk/commit/a9b9796f5ef8d27a9ad94d09a832bb9a7fe56c8e), [`9f9daa9`](https://github.com/ckb-cell/rgbpp-sdk/commit/9f9daa91486ca0cc1015713bd2648aa606da8717), [`299b404`](https://github.com/ckb-cell/rgbpp-sdk/commit/299b404217036feab409956d8888bfdc8fa820f4), [`e59322e`](https://github.com/ckb-cell/rgbpp-sdk/commit/e59322e7c6b9aff682bc1c8517337e3611dc122d), [`64c4312`](https://github.com/ckb-cell/rgbpp-sdk/commit/64c4312768885cb965285d41de99d023a4517ed3), [`d37cf5b`](https://github.com/ckb-cell/rgbpp-sdk/commit/d37cf5b1aaf50f42a2f900f9b6aa073a916840b2), [`1d58dd5`](https://github.com/ckb-cell/rgbpp-sdk/commit/1d58dd531947f4078667bb7294d2b3bb9351ead9), [`8cfc06e`](https://github.com/ckb-cell/rgbpp-sdk/commit/8cfc06e449c213868f103d9757f79f24521da280), [`4fcf4fa`](https://github.com/ckb-cell/rgbpp-sdk/commit/4fcf4fa6c0b20cf2fa957664a320f66601991817)]:
  - @rgbpp-sdk/btc@0.2.0
  - @rgbpp-sdk/ckb@0.2.0
  - @rgbpp-sdk/service@0.2.0


================================================
File: packages/rgbpp/package.json
================================================
{
  "name": "rgbpp",
  "version": "0.6.0",
  "scripts": {
    "test": "vitest",
    "build": "tsup",
    "lint": "tsc && eslint --ext .ts src/* && prettier --check 'src/*.ts'",
    "lint:fix": "tsc && eslint --fix --ext .ts src/* && prettier --write 'src/*.ts'"
  },
  "sideEffects": false,
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "import": {
        "types": "./dist/index.d.mts",
        "default": "./dist/index.mjs"
      },
      "require": {
        "types": "./dist/index.d.ts",
        "default": "./dist/index.js"
      }
    },
    "./btc": {
      "import": {
        "types": "./dist/btc.d.mts",
        "default": "./dist/btc.mjs"
      },
      "require": {
        "types": "./dist/btc.d.ts",
        "default": "./dist/btc.js"
      }
    },
    "./ckb": {
      "import": {
        "types": "./dist/ckb.d.mts",
        "default": "./dist/ckb.mjs"
      },
      "require": {
        "types": "./dist/ckb.d.ts",
        "default": "./dist/ckb.js"
      }
    },
    "./service": {
      "import": {
        "types": "./dist/service.d.mts",
        "default": "./dist/service.mjs"
      },
      "require": {
        "types": "./dist/service.d.ts",
        "default": "./dist/service.js"
      }
    },
    "./dist/*": "./dist/*",
    "./package.json": "./package.json"
  },
  "files": [
    "src",
    "dist"
  ],
  "dependencies": {
    "@ckb-lumos/base": "^0.22.2",
    "@ckb-lumos/codec": "^0.22.2",
    "@nervosnetwork/ckb-sdk-utils": "0.109.5",
    "@rgbpp-sdk/btc": "workspace:*",
    "@rgbpp-sdk/ckb": "workspace:*",
    "@rgbpp-sdk/service": "workspace:*"
  },
  "publishConfig": {
    "access": "public"
  },
  "devDependencies": {
    "@types/node": "^20.3.1",
    "lodash": "^4.17.21",
    "zod": "^3.23.8"
  }
}


================================================
File: packages/rgbpp/tsconfig.json
================================================
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "compilerOptions": {
    "moduleResolution": "Bundler",
    "module": "ESNext",
    "target": "ESNext",
    "lib": ["ESNext", "DOM"],
    "strict": true,
    "noEmit": true,
    "allowJs": true,
    "sourceMap": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "strictNullChecks": true,
    "resolveJsonModule": true,
    "isolatedModules": true
  },
  "include": ["src/**/*.ts"],
  "exclude": ["node_modules", "dist"]
}


================================================
File: packages/rgbpp/tsup.config.ts
================================================
import { defineConfig } from 'tsup';

export default defineConfig({
  name: 'rgbpp',
  dts: true,
  clean: true,
  sourcemap: true,
  format: ['esm', 'cjs'],
  entry: ['src/index.ts', 'src/btc.ts', 'src/ckb.ts', 'src/service.ts'],
});


================================================
File: packages/rgbpp/.env.example
================================================
# Network
VITE_IS_MAINNET=false

# CKB
VITE_CKB_NODE_URL=https://testnet.ckb.dev/rpc
VITE_CKB_INDEXER_URL=https://testnet.ckb.dev/indexer

# BTC
VITE_BTC_SERVICE_URL=https://btc-assets-api.testnet.mibao.pro
VITE_BTC_SERVICE_TOKEN=
VITE_BTC_SERVICE_ORIGIN=


================================================
File: packages/rgbpp/src/btc.ts
================================================
export * from '@rgbpp-sdk/btc';


================================================
File: packages/rgbpp/src/ckb.ts
================================================
export * from '@rgbpp-sdk/ckb';


================================================
File: packages/rgbpp/src/index.ts
================================================
/**
 * ckb
 */
export {
  genCreateClusterCkbVirtualTx,
  genCreateSporeCkbVirtualTx,
  genLeapSporeFromBtcToCkbVirtualTx,
  genTransferSporeCkbVirtualTx,
  genBtcTransferCkbVirtualTx,
  genCkbJumpBtcVirtualTx,
  genBtcBatchTransferCkbVirtualTx,
  genLeapSporeFromCkbToBtcRawTx,
  genRgbppLaunchCkbVirtualTx,
  genBtcJumpCkbVirtualTx,
  buildBtcTimeCellsSpentTx,
  buildSporeBtcTimeCellsSpentTx,
  signBtcTimeCellSpentTx,
} from '@rgbpp-sdk/ckb';
export type {
  CreateClusterCkbVirtualTxParams,
  CreateSporeCkbVirtualTxParams,
  LeapSporeFromBtcToCkbVirtualTxParams,
  TransferSporeCkbVirtualTxParams,
  BtcTransferVirtualTxParams,
  BtcJumpCkbVirtualTxParams,
  BtcBatchTransferVirtualTxParams,
  CkbJumpBtcVirtualTxParams,
  SporeCreateVirtualTxResult,
  BtcTransferVirtualTxResult,
  BtcJumpCkbVirtualTxResult,
  BtcBatchTransferVirtualTxResult,
  SporeTransferVirtualTxResult,
  SporeLeapVirtualTxResult,
  SporeVirtualTxResult,
} from '@rgbpp-sdk/ckb';

/**
 * service
 */
export { BtcAssetsApi, BtcAssetsApiError } from '@rgbpp-sdk/service';

/**
 * btc
 */
export {
  DataSource,
  NetworkType,
  AddressType,
  sendBtc,
  sendUtxos,
  sendRgbppUtxos,
  createSendBtcBuilder,
  createSendUtxosBuilder,
  createSendRgbppUtxosBuilder,
} from '@rgbpp-sdk/btc';
export type { SendBtcProps, SendUtxosProps, SendRgbppUtxosProps } from '@rgbpp-sdk/btc';

/**
 * RGB++
 */
export type {
  RgbppTransferTxParams,
  RgbppTransferTxResult,
  RgbppTransferAllTxsParams,
  RgbppTransferAllTxsResult,
  RgbppTransferAllTxGroup,
} from './rgbpp/types/xudt';
export type { TransactionGroupSummary } from './rgbpp/summary/asset-summarizer';
export type { RgbppTxGroup, SentRgbppTxGroup } from './rgbpp/utils/transaction';
export { RgbppError, RgbppErrorCodes } from './rgbpp/error';
export { buildRgbppTransferTx } from './rgbpp/xudt/btc-transfer';
export { buildRgbppTransferAllTxs } from './rgbpp/xudt/btc-transfer-all';
export { sendRgbppTxGroups } from './rgbpp/utils/transaction';


================================================
File: packages/rgbpp/src/service.ts
================================================
export * from '@rgbpp-sdk/service';


================================================
File: packages/rgbpp/src/rgbpp/error.ts
================================================
export enum RgbppErrorCodes {
  UNKNOWN,

  UNEXPECTED_CKB_VTX_OUTPUTS_LENGTH = 20,
}

export const RgbppErrorMessages = {
  [RgbppErrorCodes.UNKNOWN]: 'Unknown error',

  [RgbppErrorCodes.UNEXPECTED_CKB_VTX_OUTPUTS_LENGTH]: 'Unexpected length of the CkbVirtualTx outputs',
};

export class RgbppError extends Error {
  public code = RgbppErrorCodes.UNKNOWN;
  constructor(code: RgbppErrorCodes, message = RgbppErrorMessages[code] || 'Unknown error') {
    super(message);
    this.code = code;
    Object.setPrototypeOf(this, RgbppError.prototype);
  }

  static withComment(code: RgbppErrorCodes, comment?: string): RgbppError {
    const message: string | undefined = RgbppErrorMessages[code];
    return new RgbppError(code, comment ? `${message}: ${comment}` : message);
  }
}


================================================
File: packages/rgbpp/src/rgbpp/summary/asset-summarizer.ts
================================================
import { Cell } from '@ckb-lumos/base';
import { Utxo, encodeUtxoId } from '@rgbpp-sdk/btc';
import { leToU128, encodeCellId, isUDTTypeSupported } from '@rgbpp-sdk/ckb';

export interface AssetGroup {
  utxo: Utxo;
  cells: Cell[];
}

export interface XudtAssetSummary {
  amount: bigint;
  utxoCount: number;
  cellCount: number;
}

export interface AssetGroupSummary {
  utxoId: string;
  cellIds: string[];
  xudtCellIds: string[];
  xudtAssets: Record<string, XudtAssetSummary>; // Record<xudtTypeArgs, AssetSummary>
}

export interface TransactionGroupSummary {
  utxoCount: number;
  cellCount: number;
  xudtCellCount: number;
  utxoIds: string[];
  cellIds: string[];
  xudtCellIds: string[];
  xudtAssets: Record<string, XudtAssetSummary>; // Record<xudtTypeArgs, AssetSummary>
}

export class AssetSummarizer {
  groups: AssetGroupSummary[] = [];

  constructor(public isMainnet: boolean) {}

  addGroup(utxo: Utxo, cells: Cell[], offline: boolean = false): AssetGroupSummary {
    const utxoId = encodeUtxoId(utxo.txid, utxo.vout);

    const cellIds: string[] = [];
    const xudtCellIds: string[] = [];
    const xudtAssets: Record<string, XudtAssetSummary> = {};
    for (const cell of cells) {
      const cellId = encodeCellId(cell.outPoint!.txHash, cell.outPoint!.index);
      cellIds.push(cellId);

      const isXudt = !!cell.cellOutput.type && isUDTTypeSupported(cell.cellOutput.type, this.isMainnet, offline);
      if (isXudt) {
        // If the cell type is a supported xUDT type, record its asset information
        const xudtTypeArgs = cell.cellOutput.type?.args ?? 'empty';
        const amount = leToU128(cell.data.substring(0, 34));
        if (xudtAssets[xudtTypeArgs] === undefined) {
          xudtAssets[xudtTypeArgs] = {
            utxoCount: 1,
            cellCount: 0,
            amount: 0n,
          };
        }

        xudtCellIds.push(cellId);
        xudtAssets[xudtTypeArgs]!.cellCount += 1;
        xudtAssets[xudtTypeArgs]!.amount += amount;
      } else {
        // TODO: if the cell type is empty or is not xUDT, how to handle/record its info?
      }
    }

    const result: AssetGroupSummary = {
      utxoId,
      cellIds,
      xudtCellIds,
      xudtAssets,
    };

    this.groups.push(result);
    return result;
  }

  addGroups(groups: AssetGroup[], offline: boolean = false): TransactionGroupSummary {
    const groupResults = groups.map((group) => this.addGroup(group.utxo, group.cells, offline));
    return this.summarizeGroups(groupResults);
  }

  /**
   * Summarizes asset information across multiple AssetGroupSummary objects.
   * If no groups are provided, it summarizes the internally stored groups.
   *
   * @param groups - Optional array of AssetGroupSummary objects to summarize.
   * @returns TransactionGroupSummary - A summary of all assets across the specified groups,
   *          including total UTXO and cell counts, UTXO and cell IDs, and aggregated asset information.
   */
  summarizeGroups(groups?: AssetGroupSummary[]): TransactionGroupSummary {
    const targetGroups = groups ?? this.groups;
    const utxoIds = targetGroups.map((summary) => summary.utxoId);
    const cellIds = targetGroups.flatMap((summary) => summary.cellIds);
    const xudtCellIds = targetGroups.flatMap((summary) => summary.xudtCellIds);
    const xudtAssets = targetGroups.reduce(
      (result, summary) => {
        for (const xudtTypeArgs in summary.xudtAssets) {
          if (!result[xudtTypeArgs]) {
            result[xudtTypeArgs] = {
              utxoCount: 0,
              cellCount: 0,
              amount: 0n,
            };
          }

          result[xudtTypeArgs]!.utxoCount += summary.xudtAssets[xudtTypeArgs]!.utxoCount;
          result[xudtTypeArgs]!.cellCount += summary.xudtAssets[xudtTypeArgs]!.cellCount;
          result[xudtTypeArgs]!.amount += summary.xudtAssets[xudtTypeArgs]!.amount;
        }
        return result;
      },
      {} as Record<string, XudtAssetSummary>,
    );

    return {
      utxoCount: utxoIds.length,
      cellCount: cellIds.length,
      xudtCellCount: xudtCellIds.length,
      utxoIds,
      cellIds,
      xudtCellIds,
      xudtAssets,
    };
  }
}


================================================
File: packages/rgbpp/src/rgbpp/types/xudt.ts
================================================
import {
  BaseCkbVirtualTxResult,
  BTCTestnetType,
  BtcTransferVirtualTxResult,
  Collector,
  Hex,
  CellDepsObject,
} from '@rgbpp-sdk/ckb';
import { AddressToPubkeyMap, DataSource } from '@rgbpp-sdk/btc';
import { TransactionGroupSummary } from '../summary/asset-summarizer';

export interface RgbppTransferCkbParams {
  // The collector that collects CKB live cells and transactions
  collector: Collector;
  // The transferred RGB++ xUDT type script args
  xudtTypeArgs: Hex;
  // The rgbpp assets cell lock script args array whose data structure is: out_index | bitcoin_tx_id
  rgbppLockArgsList: Hex[];
  // The XUDT amount to be transferred, if the noMergeOutputCells is true, the transferAmount will be ignored
  transferAmount: bigint;
  // The CKB transaction fee rate, default value is 1100
  feeRate?: bigint;
  // If the asset is compatible xUDT(not standard xUDT), the compatibleXudtTypeScript is required
  compatibleXudtTypeScript?: CKBComponents.Script;
}

export interface RgbppTransferBtcParams {
  // The sender BTC address
  fromAddress: string;
  // The receiver BTC address
  toAddress: string;
  // The data source for collecting Bitcoin-related info
  dataSource: DataSource;
  // The public key of sender BTC address, must fill if the fromAddress is a P2TR address
  fromPubkey?: Hex;
  // The fee rate of the BTC transaction
  feeRate?: number;
  // The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
  testnetType?: BTCTestnetType;
}

export interface RgbppTransferTxParams {
  ckb: RgbppTransferCkbParams;
  btc: RgbppTransferBtcParams;
  // True is for BTC and CKB Mainnet, false is for BTC Testnet3/Signet and CKB Testnet
  isMainnet: boolean;
}

export interface RgbppTransferTxResult {
  ckbVirtualTxResult: BtcTransferVirtualTxResult;
  // The BTC PSBT hex string which can be used to construct Bitcoin PSBT
  btcPsbtHex: Hex;
}

export interface RgbppTransferAllTxsParams {
  ckb: {
    // The collector that collects CKB live cells and transactions
    collector: Collector;
    // The transferred RGB++ xUDT type script args
    xudtTypeArgs: Hex;
    // The CKB transaction fee rate, default value is 1100
    feeRate?: bigint;
    // If the asset is compatible xUDT(not standard xUDT), the compatibleXudtTypeScript is required
    compatibleXudtTypeScript?: CKBComponents.Script;

    /*
     * Vendor cell deps provided by the caller.
     * These cell deps belong to scripts that may be upgraded in the future.
     * Please ensure the cell dep information is up to date. The latest cell dep information is maintained at:
     * https://raw.githubusercontent.com/utxostack/typeid-contract-cell-deps/main/deployment/cell-deps.json.
     */
    vendorCellDeps?: CellDepsObject;
  };
  btc: {
    // The list of BTC addresses to provide RGB++ xUDT assets
    // All available amounts of the target asset (specified by ckb.xudtTypeArgs) will be included in the transfers
    // However, if more than 40 cells are bound to the same UTXO, the amounts within those 40 cells are excluded
    assetAddresses: string[];
    // The BTC address for paying all the transaction costs, but not provide any RGB++ assets
    fromAddress: string;
    // The BTC address for receiving all the RGB++ assets
    toAddress: string;
    // The data source for collecting Bitcoin-related info
    dataSource: DataSource;
    // The public key of sender BTC address, must fill if the fromAddress is a P2TR address
    fromPubkey?: string;
    // The map helps find the corresponding public key of a BTC address,
    // note that you must specify a pubkey for each P2TR address in assetAddresses/fromAddress
    pubkeyMap?: AddressToPubkeyMap;
    // The BTC address to return change satoshi, default value is fromAddress
    changeAddress?: string;
    // The fee rate of the BTC transactions, will use the fastest fee rate if not specified
    feeRate?: number;
    // The BTC Testnet to use, supports "Testnet3" and "Signet", default value is "Testnet3",
    // the param helps find the targeting version of rgbpp-lock script on CKB Testnet
    testnetType?: BTCTestnetType;
  };
  // True is for BTC and CKB Mainnet, false is for BTC Testnet3/Signet and CKB Testnet
  isMainnet: boolean;
}

export interface RgbppTransferAllTxsResult {
  transactions: RgbppTransferAllTxGroup[];
  summary: {
    included: TransactionGroupSummary;
    excluded: TransactionGroupSummary;
  };
}

export interface RgbppTransferAllTxGroup {
  ckb: {
    virtualTxResult: BaseCkbVirtualTxResult;
  };
  btc: {
    psbtHex: string;
    feeRate: number;
    fee: number;
  };
  summary: TransactionGroupSummary;
}


================================================
File: packages/rgbpp/src/rgbpp/utils/group.ts
================================================
export function groupNumbersBySum(
  numbers: number[],
  target: number,
): {
  indices: number[][];
  numbers: number[][];
} {
  const groups: number[][] = [];
  const groupIds = new Set<string>();
  const usedIndices = new Set<number>();

  function backtrack(group: number[], sum: number, start: number): boolean {
    if (sum === target) {
      return true;
    }
    if (sum > target) {
      return false;
    }
    for (let i = start; i < numbers.length; i++) {
      if (usedIndices.has(i)) {
        continue;
      }
      usedIndices.add(i);
      group.push(i);
      if (backtrack(group, sum + numbers[i]!, i + 1)) {
        addGroup(group);
        return true;
      }
      usedIndices.delete(i);
      group.pop();
    }
    if (group.length > 0 && sum < target) {
      addGroup(group);
      return true;
    }
    return false;
  }

  function addGroup(group: number[]) {
    const sortedGroup = [...group].sort((a, b) => a - b);
    const groupId = sortedGroup.join(',');
    if (!groupIds.has(groupId)) {
      groups.push([...group]);
      groupIds.add(groupId);
    }
  }

  numbers.forEach((_, index) => {
    if (!usedIndices.has(index)) {
      backtrack([], 0, index);
    }
  });

  return {
    indices: groups,
    numbers: groups.map((group) => {
      return group.map((index) => numbers[index]!);
    }),
  };
}

export function mapGroupsByIndices<T>(indices: number[][], getter: (index: number) => T): T[][] {
  return indices.map((group) => {
    return group.map((index) => getter(index));
  });
}


================================================
File: packages/rgbpp/src/rgbpp/utils/transaction.ts
================================================
import { BaseCkbVirtualTxResult } from '@rgbpp-sdk/ckb';
import { BtcAssetsApi, BtcAssetsApiError } from '@rgbpp-sdk/service';

export interface RgbppTxGroup {
  ckbVirtualTxResult: BaseCkbVirtualTxResult | string;
  btcTxHex: string;
}

export interface SentRgbppTxGroup {
  btcTxId?: string;
  error?: string;
}

export async function sendRgbppTxGroups(props: {
  txGroups: RgbppTxGroup[];
  btcService: BtcAssetsApi;
}): Promise<SentRgbppTxGroup[]> {
  const results: SentRgbppTxGroup[] = [];
  for (const group of props.txGroups) {
    try {
      const { txid } = await props.btcService.sendBtcTransaction(group.btcTxHex);
      await props.btcService.sendRgbppCkbTransaction({
        btc_txid: txid,
        ckb_virtual_result: group.ckbVirtualTxResult,
      });
      results.push({ btcTxId: txid });
    } catch (e) {
      console.error(e);
      if (e instanceof BtcAssetsApiError) {
        results.push({ error: e.message });
      } else {
        results.push({ error: 'Sending the RGB++ group transactions failed' });
      }
    }
  }

  return results;
}


================================================
File: packages/rgbpp/src/rgbpp/xudt/btc-transfer-all.ts
================================================
import {
  encodeCellId,
  isScriptEqual,
  getXudtTypeScript,
  isUDTTypeSupported,
  buildRgbppLockArgs,
  unpackRgbppLockArgs,
  genBtcTransferCkbVirtualTx,
  RGBPP_TX_INPUTS_MAX_LENGTH,
  isOfflineMode,
} from '@rgbpp-sdk/ckb';
import {
  Utxo,
  BaseOutput,
  encodeUtxoId,
  decodeUtxoId,
  limitPromiseBatchSize,
  createSendRgbppUtxosBuilder,
} from '@rgbpp-sdk/btc';
import { bytes } from '@ckb-lumos/codec';
import { blockchain, Cell } from '@ckb-lumos/base';
import { groupNumbersBySum, mapGroupsByIndices } from '../utils/group';
import { RgbppTransferAllTxGroup, RgbppTransferAllTxsParams, RgbppTransferAllTxsResult } from '../types/xudt';
import { AssetSummarizer } from '../summary/asset-summarizer';
import { RgbppError, RgbppErrorCodes } from '../error';

/**
 * Build BTC/CKB transaction group(s) to transfer all amount of an RGB++ XUDT asset from the specified BTC addresses to the target BTC address.
 * Due to the input size limitation, each CKB transaction can contain up to 40 RGB++ cells.
 * Therefore, the generated result may contain more than one transaction group.
 */
export async function buildRgbppTransferAllTxs(params: RgbppTransferAllTxsParams): Promise<RgbppTransferAllTxsResult> {
  // Prepare base props
  const maxRgbppCellsPerCkbTx = RGBPP_TX_INPUTS_MAX_LENGTH;
  const isMainnet = params.isMainnet;
  const isOffline = isOfflineMode(params.ckb.vendorCellDeps);
  const btcSource = params.btc.dataSource;
  const btcService = btcSource.service;
  const ckbCollector = params.ckb.collector;
  const typeScript = params.ckb.compatibleXudtTypeScript ?? {
    ...getXudtTypeScript(isMainnet),
    args: params.ckb.xudtTypeArgs,
  };
  const xudtTypeHex = bytes.hexify(blockchain.Script.pack(typeScript));

  // Get L2 Cells own by the assetAccounts,
  // and build L1 UTXO IDs (`${txid}:${vout}`) from each cell.cellOutput.lock.args
  const accountCells = await Promise.all(
    params.btc.assetAddresses.map((address) => {
      return limitPromiseBatchSize(() =>
        btcService.getRgbppAssetsByBtcAddress(address, {
          type_script: xudtTypeHex,
        }),
      );
    }),
  );
  const utxoIds = new Set<string>(
    accountCells.flat().map((rgbppCell) => {
      const lockArgs = unpackRgbppLockArgs(rgbppCell.cellOutput.lock.args);
      return encodeUtxoId(lockArgs.btcTxId, lockArgs.outIndex);
    }),
  );

  // Get all L1 UTXOs from the asset accounts
  const accountUtxos = await Promise.all(
    params.btc.assetAddresses.map((address) => {
      return limitPromiseBatchSize(() => btcSource.getUtxos(address));
    }),
  );

  // Storage variables for cache querying
  const invalidUtxoIds = new Set<string>(); // Set<UtxoId>
  const cellsMap = new Map<string, Cell[]>(); // Map<UtxoId, Cell[]>
  const utxosMap = new Map<string, Utxo>(); // Map<CellId, Utxo>
  const cellMap = new Map<string, Cell>(); // Map<CellId, Cell>
  const utxoMap = accountUtxos.flat().reduce(
    // Map<UtxoId, Utxo>
    (map, utxo) => {
      const utxoId = encodeUtxoId(utxo.txid, utxo.vout);
      if (utxoIds.has(utxoId)) {
        map.set(utxoId, utxo);
      }
      return map;
    },
    new Map<string, Utxo>(),
  );

  // Get each L1 UTXO's corresponding L2 Cells
  // If a UTXO has more L2 Cells than maxRgbppCellsPerCkbTx, the UTXO/Cells are invalid.
  // Invalid L1 UTXO and its corresponding L2 Cells are excluded from the transfer process.
  const rgbppGroups: { id: string; cells: number }[] = [];
  await Promise.all(
    [...utxoIds].map(async (utxoId) => {
      return limitPromiseBatchSize(async () => {
        const { txid, vout } = decodeUtxoId(utxoId);
        const cells = await btcService.getRgbppAssetsByBtcUtxo(txid, vout);
        if (cells) {
          cellsMap.set(utxoId, cells);
        }
        const utxo = utxoMap.get(utxoId);
        const hasUnsupportedTypeCell = cells.some((cell) => {
          return cell.cellOutput.type && !isUDTTypeSupported(cell.cellOutput.type, isMainnet, isOffline);
        });
        if (!utxo || !cells || cells.length > maxRgbppCellsPerCkbTx || hasUnsupportedTypeCell) {
          invalidUtxoIds.add(utxoId);
          return;
        }
        cells.forEach((cell) => {
          const cellId = encodeCellId(cell.outPoint!.txHash, cell.outPoint!.index);
          utxosMap.set(cellId, utxo);
          cellMap.set(cellId, cell);
        });
        rgbppGroups.push({
          id: utxoId,
          cells: cells.length,
        });
      });
    }),
  );

  // Relocate UTXO/Cells groups for constructing transactions later, the rules:
  // 1. All Cells corresponding to the same UTXO should be included in the same CKB_VTX
  // 2. Each CKB_VTX can only include (<= maxRgbppCellsPerCkbTx) amount of Cells
  const boundCells = rgbppGroups.map((group) => group.cells);
  const groupedByInputs = groupNumbersBySum(boundCells, maxRgbppCellsPerCkbTx);
  const groupedAssetGroups = mapGroupsByIndices(groupedByInputs.indices, (index) => rgbppGroups[index]!);

  // Construct transaction groups
  const summarizer = new AssetSummarizer(isMainnet);
  const usedBtcUtxos: BaseOutput[] = [];
  const transactionGroups: RgbppTransferAllTxGroup[] = [];
  for (const assetGroups of groupedAssetGroups) {
    // Collect summary of the assets group, including XUDT amounts
    const groupSummary = summarizer.addGroups(
      assetGroups.map((group) => ({
        utxo: utxoMap.get(group.id)!,
        cells: cellsMap.get(group.id)!,
      })),
      isOffline,
    );

    // Props for constructing CKB_VTX
    const xudtAmount = groupSummary.xudtAssets[params.ckb.xudtTypeArgs]!.amount;
    const lockArgsList = groupSummary.utxoIds.map((utxoId) => {
      const output = decodeUtxoId(utxoId)!;
      return buildRgbppLockArgs(output.vout, output.txid);
    });

    // Construct CKB_VTX
    const ckbVtxResult = await genBtcTransferCkbVirtualTx({
      collector: ckbCollector,
      xudtTypeBytes: xudtTypeHex,
      transferAmount: xudtAmount,
      rgbppLockArgsList: lockArgsList,
      btcTestnetType: params.btc.testnetType,
      isMainnet,
    });

    // Generate an address list of the non-target RGBPP cells,
    // because non-target RGBPP cells should be returned one-to-one to their original owners
    const nonTargetTos = ckbVtxResult.ckbRawTx.inputs.reduce((utxos, input) => {
      const cellId = encodeCellId(input.previousOutput!.txHash, input.previousOutput!.index);
      const cell = cellMap.get(cellId)!;
      if (!cell.cellOutput.type || !isScriptEqual(cell.cellOutput.type!, xudtTypeHex)) {
        const utxo = utxosMap.get(cellId)!;
        utxos.push(utxo.address);
      }
      return utxos;
    }, [] as string[]);

    // Expect the CKB_TX's outputs to be [transferRgbppCell, ...nonTargetRgbppCells].
    // All collected XUDT amount will be compact into a single cell, so no change cell is expected.
    const expectCkbOutputsLength = nonTargetTos.length + 1;
    const ckbOutputsLength = ckbVtxResult.ckbRawTx.outputs.length;
    if (ckbVtxResult.ckbRawTx.outputs.length !== expectCkbOutputsLength) {
      throw RgbppError.withComment(
        RgbppErrorCodes.UNEXPECTED_CKB_VTX_OUTPUTS_LENGTH,
        `expected: ${expectCkbOutputsLength}, actual: ${ckbOutputsLength}`,
      );
    }

    // Construct BTC_TX
    const { builder, fee, feeRate } = await createSendRgbppUtxosBuilder({
      // CKB
      ckbCollector: params.ckb.collector,
      ckbVirtualTx: ckbVtxResult.ckbRawTx,
      commitment: ckbVtxResult.commitment,
      tos: [params.btc.toAddress, ...nonTargetTos],
      // BTC
      from: params.btc.fromAddress,
      fromPubkey: params.btc.fromPubkey,
      changeAddress: params.btc.changeAddress,
      pubkeyMap: params.btc.pubkeyMap,
      feeRate: params.btc.feeRate,
      excludeUtxos: usedBtcUtxos,
      source: btcSource,
    });

    // Exclude used BTC UTXOs in the next BTC_TX
    const psbt = builder.toPsbt();
    for (let i = groupSummary.utxoIds.length; i < builder.inputs.length; i++) {
      const vin = builder.inputs[i];
      if (vin) {
        usedBtcUtxos.push({
          txid: vin.utxo.txid,
          vout: vin.utxo.vout,
        });
      }
    }

    // Add generated BTC_TX and CKB_VTX to the groups
    transactionGroups.push({
      ckb: {
        virtualTxResult: ckbVtxResult,
      },
      btc: {
        psbtHex: psbt.toHex(),
        feeRate,
        fee,
      },
      summary: groupSummary,
    });
  }

  // Generate result
  const excludedSummarizer = new AssetSummarizer(isMainnet);
  excludedSummarizer.addGroups(
    [...invalidUtxoIds].map((utxoId) => ({
      utxo: utxoMap.get(utxoId)!,
      cells: cellsMap.get(utxoId)!,
    })),
  );
  return {
    transactions: transactionGroups,
    summary: {
      included: summarizer.summarizeGroups(),
      excluded: excludedSummarizer.summarizeGroups(),
    },
  };
}


================================================
File: packages/rgbpp/src/rgbpp/xudt/btc-transfer.ts
================================================
import { genBtcTransferCkbVirtualTx, getXudtTypeScript, serializeScript } from '@rgbpp-sdk/ckb';
import { sendRgbppUtxos } from '@rgbpp-sdk/btc';
import { RgbppTransferTxParams, RgbppTransferTxResult } from '../types/xudt';

/**
 * Build the CKB virtual transaction and BTC transaction to be signed for the RGB++ transfer tx
 * CKB parameters
 * @param collector The collector that collects CKB live cells and transactions
 * @param xudtTypeArgs The transferred xUDT type script args
 * @param rgbppLockArgsList The RGB++ assets cell lock script args array whose data structure is: out_index | bitcoin_tx_id
 * @param transferAmount The XUDT amount to be transferred, if the noMergeOutputCells is true, the transferAmount will be ignored
 * @param feeRate The CKB transaction fee rate, default value is 1100
 * @param compatibleXudtTypeScript(Optional) If the asset is compatible xUDT(not standard xUDT), the compatibleXudtTypeScript is required
 *
 * BTC parameters
 * @param fromAddress The sender BTC address
 * @param fromPubkey The public key of the sender BTC address
 * @param toAddress The receiver BTC address
 * @param dataSource The BTC data source
 * @param feeRate The fee rate of the BTC transaction
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)
 * @param testnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
 */
export const buildRgbppTransferTx = async ({
  ckb: { collector, xudtTypeArgs, rgbppLockArgsList, transferAmount, feeRate: ckbFeeRate, compatibleXudtTypeScript },
  btc,
  isMainnet,
}: RgbppTransferTxParams): Promise<RgbppTransferTxResult> => {
  const xudtType: CKBComponents.Script = compatibleXudtTypeScript ?? {
    ...getXudtTypeScript(isMainnet),
    args: xudtTypeArgs,
  };

  const ckbVirtualTxResult = await genBtcTransferCkbVirtualTx({
    collector,
    rgbppLockArgsList,
    xudtTypeBytes: serializeScript(xudtType),
    transferAmount,
    isMainnet,
    ckbFeeRate,
    btcTestnetType: btc.testnetType,
  });

  const { commitment, ckbRawTx } = ckbVirtualTxResult;

  // Send BTC tx
  const psbt = await sendRgbppUtxos({
    ckbVirtualTx: ckbRawTx,
    commitment,
    tos: [btc.toAddress],
    ckbCollector: collector,
    from: btc.fromAddress!,
    fromPubkey: btc.fromPubkey,
    source: btc.dataSource,
    feeRate: btc.feeRate,
  });

  return {
    ckbVirtualTxResult,
    btcPsbtHex: psbt.toHex(),
  };
};


================================================
File: packages/rgbpp/tests/Group.test.ts
================================================
import { describe, it, expect } from 'vitest';
import { groupNumbersBySum } from '../src/rgbpp/utils/group';

describe('Group', () => {
  describe('groupNumbersBySum()', () => {
    it('[9]', () => {
      const target = 10;
      const numbers = [9];
      const groups = groupNumbersBySum(numbers, target);
      expect(groups.indices).toEqual([[0]]);
      expect(groups.numbers).toEqual([[9]]);
    });
    it('[9, 1]', () => {
      const target = 10;
      const numbers = [9, 1];
      const groups = groupNumbersBySum(numbers, target);
      expect(groups.indices).toEqual([[0, 1]]);
      expect(groups.numbers).toEqual([[9, 1]]);
    });
    it('[10, 1]', () => {
      const target = 10;
      const numbers = [10, 1];
      const groups = groupNumbersBySum(numbers, target);
      expect(groups.indices).toEqual([[0], [1]]);
      expect(groups.numbers).toEqual([[10], [1]]);
    });
    it('[5, 5, 5]', () => {
      const target = 10;
      const numbers = [5, 5, 5];
      const groups = groupNumbersBySum(numbers, target);
      expect(groups.indices).toEqual([[0, 1], [2]]);
      expect(groups.numbers).toEqual([[5, 5], [5]]);
    });
    it('[1, 1, 1, 1, 1]', () => {
      const target = 10;
      const numbers = [1, 1, 1, 1, 1];
      const groups = groupNumbersBySum(numbers, target);
      expect(groups.indices).toEqual([[0, 1, 2, 3, 4]]);
      expect(groups.numbers).toEqual([[1, 1, 1, 1, 1]]);
    });
    it('[5, 10, 5]', () => {
      const target = 10;
      const numbers = [5, 10, 5];
      const groups = groupNumbersBySum(numbers, target);
      expect(groups.indices).toEqual([[0, 2], [1]]);
      expect(groups.numbers).toEqual([[5, 5], [10]]);
    });
    it('[10, 5, 10, 5]', () => {
      const target = 10;
      const numbers = [10, 5, 10, 5];
      const groups = groupNumbersBySum(numbers, target);
      expect(groups.indices).toEqual([[0], [1, 3], [2]]);
      expect(groups.numbers).toEqual([[10], [5, 5], [10]]);
    });
    it('[11]', () => {
      const target = 10;
      const numbers = [11];
      const groups = groupNumbersBySum(numbers, target);
      expect(groups.indices).toEqual([]);
      expect(groups.numbers).toEqual([]);
    });
    it('[]', () => {
      const target = 10;
      const numbers: number[] = [];
      const groups = groupNumbersBySum(numbers, target);
      expect(groups.indices).toEqual([]);
      expect(groups.numbers).toEqual([]);
    });
  });
});


================================================
File: packages/rgbpp/tests/RgbppXudt.test.ts
================================================
import { describe, expect, it, vi, afterEach } from 'vitest';
import { bitcoin, encodeUtxoId } from '@rgbpp-sdk/btc';
import { bytes } from '@ckb-lumos/codec';
import { blockchain } from '@ckb-lumos/base';
import { RgbppTxGroup } from '../src/rgbpp/utils/transaction';
import { buildRgbppTransferAllTxs, sendRgbppTxGroups } from '../src';
import { createP2trAccount, signPsbt } from './shared/account';
import { btcNetworkType, btcSource, ckbCollector, isMainnet } from './shared/env';

import MOCKED_50_INCLUDED_AND_41_EXCLUDED from './mocked/50-included-41-excluded';

describe('RgbppXudt', () => {
  afterEach(() => {
    vi.restoreAllMocks();
  });
  describe('buildRgbppTransferAllTxs()', () => {
    const mocked = MOCKED_50_INCLUDED_AND_41_EXCLUDED;

    it('50 included cells, 41 excluded cells', async () => {
      // The sender account, with:
      // - 41 cells, all bound to the same UTXO
      // - 50 cells, each bound to an individual UTXO
      const alice = mocked.sender;
      // The recipient account, also the sponsor to pay for the transfer transactions on BTC
      const bob = mocked.receiver;
      // The target XUDT, transferring all this type of asset from alice to bob
      const xudtTypeArgs = mocked.xudtTypeArgs;

      // Mock service responses
      vi.spyOn(btcSource, 'getUtxo').mockImplementation((txid: string, vout: number) => {
        const utxoId = encodeUtxoId(txid, vout);
        if (alice.utxosByUtxoId[utxoId]) {
          return Promise.resolve(alice.utxosByUtxoId[utxoId]);
        }
        return Promise.resolve(undefined);
      });
      vi.spyOn(btcSource.service, 'getBtcUtxos').mockImplementation((address: string) => {
        if (address === alice.account.address) {
          return Promise.resolve(alice.btcUtxos);
        }
        if (address === bob.account.address) {
          return Promise.resolve(bob.btcUtxos);
        }
        return Promise.resolve([]);
      });
      vi.spyOn(btcSource.service, 'getRgbppAssetsByBtcAddress').mockImplementation((address: string) => {
        if (address === alice.account.address) {
          return Promise.resolve(alice.rgbppCells);
        }
        return Promise.resolve([]);
      });
      vi.spyOn(btcSource.service, 'getRgbppAssetsByBtcUtxo').mockImplementation((txid, vout) => {
        const utxoId = encodeUtxoId(txid, vout);
        if (alice.rgbppCellsByUtxoId[utxoId]) {
          return Promise.resolve(alice.rgbppCellsByUtxoId[utxoId]);
        }
        return Promise.resolve([]);
      });
      vi.spyOn(ckbCollector, 'getCells').mockImplementation(({ lock }) => {
        const lockHash = bytes.hexify(blockchain.Script.pack(lock));
        if (alice.rgbppCellsByLockHash[lockHash]) {
          return Promise.resolve(alice.rgbppCellsByLockHash[lockHash]);
        }
        return Promise.resolve([]);
      });
      vi.spyOn(ckbCollector, 'getLiveCells').mockImplementation((outPoints) => {
        const outPointsString = btoa(JSON.stringify(outPoints));
        for (const record of alice.liveCellsByOutPoints) {
          const aliceOutPointsString = btoa(JSON.stringify(record.outPoints));
          if (outPointsString === aliceOutPointsString) {
            return Promise.resolve(record.liveCells);
          }
        }
        return Promise.resolve([]);
      });
      vi.spyOn(ckbCollector, 'getLiveCell').mockImplementation((outPoint) => {
        const outPointsString = JSON.stringify(outPoint);
        return Promise.resolve(alice.liveCellByOutPoint[outPointsString]);
      });

      // Transfer all assets from alice to bob
      const result = await buildRgbppTransferAllTxs({
        ckb: {
          xudtTypeArgs,
          collector: ckbCollector,
        },
        btc: {
          assetAddresses: [alice.account.address],
          fromAddress: bob.account.address,
          toAddress: bob.account.address,
          dataSource: btcSource,
          feeRate: 1,
          pubkeyMap: {
            [alice.account.address]: alice.account.pubkey,
          },
        },
        isMainnet,
      });

      console.log('result.transactions.length', result.transactions.length);
      console.log('result.summary.included.assets', result.summary.included.xudtAssets);
      console.log('result.summary.excluded.assets', result.summary.excluded.xudtAssets);

      expect(result.summary.included.xudtAssets).toHaveProperty(xudtTypeArgs);
      expect(result.summary.included.xudtAssets[xudtTypeArgs].cellCount).toEqual(50);
      expect(result.summary.included.xudtAssets[xudtTypeArgs].utxoCount).toEqual(50);

      expect(result.summary.excluded.xudtAssets).toHaveProperty(xudtTypeArgs);
      expect(result.summary.excluded.xudtAssets[xudtTypeArgs].cellCount).toEqual(41);
      expect(result.summary.excluded.xudtAssets[xudtTypeArgs].utxoCount).toEqual(1);

      expect(result.transactions).toHaveLength(2);
      expect(result).toMatchSnapshot();
    }, 0);
    it('Sign P2WPKH/P2TR inputs and send transactions', async () => {
      const SEND_TX_GROUPS = false;

      // The sender account, with:
      // - 41 cells, all bound to the same UTXO
      // - 50 cells, each bound to an individual UTXO
      const alice = mocked.sender;
      const aliceAccount = createP2trAccount(alice.account.privateKey, btcNetworkType);

      // Sign transactions
      const signedGroups: RgbppTxGroup[] = mocked.buildResult.transactions.map((group) => {
        const psbt = bitcoin.Psbt.fromHex(group.btc.psbtHex);
        signPsbt(psbt, aliceAccount);
        psbt.finalizeAllInputs();

        return {
          ckbVirtualTxResult: JSON.stringify(group.ckb.virtualTxResult),
          btcTxHex: psbt.extractTransaction().toHex(),
        };
      });

      console.log('signedGroups', JSON.stringify(signedGroups, null, 2));

      if (!SEND_TX_GROUPS) {
        return;
      }

      // Send transactions
      const sentGroups = await sendRgbppTxGroups({
        txGroups: signedGroups,
        btcService: btcSource.service,
      });

      console.log('sentGroups', JSON.stringify(sentGroups, null, 2));
    }, 0);
  });
});


================================================
File: packages/rgbpp/tests/__snapshots__/RgbppXudt.test.ts.snap
================================================
// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`RgbppXudt > buildRgbppTransferAllTxs() > 50 included cells, 41 excluded cells 1`] = `
{
  "summary": {
    "excluded": {
      "cellCount": 41,
      "cellIds": [
        "0x00f43b843640fab7c9951a7931632e6ade6ef3337f89489b1c2b400793ece665:0x0",
        "0xa398426747fb052d0832a3296ad89b72253428b6caa19e8be14d4fcb0befeb2d:0x0",
        "0xc657c0531c349e0602397f6369a462bbd3ec84efcd8876e1ccdc0e6f0201a8b0:0x0",
        "0xde2c71de17ebd73b1925805754b1fd2c2cd40b27d5de3edf23812b270439b162:0x0",
        "0xd2466255b2b05a229d3bb9c5f9f1b3def078283cdfd9cef1645ef1046c9047d5:0x0",
        "0xd64f32b7a5daf5c5fd7f0cf0ba76d9263383265fbc706b9043f344afd5fe00e8:0x0",
        "0x16bb55a5c1fd0d6a7d7e7b60892da24c2a33c27041fbf8ada93aab691a311f9b:0x0",
        "0xede3544e671ac287ff67ddea7ce99e7d0afafac5f2889f4f8b1c6c1cd09dcbcc:0x0",
        "0x67cad749783b7d8595b7e5818c08eb380575c64badbd792443f36ae5888ceaff:0x0",
        "0xcaacf9b9b495e1c811598e86d904768162914b1aca7c3537cdd1af2cbe640303:0x0",
        "0x85a5fa2ba570c35fd22e132b3f6a0ad03b8c151d0fd82abdbc8e4c3845615660:0x0",
        "0x62cb0ad5fdcfdfe819135f970604b0c7e7ba6761544d2db2f6e093e8dd50734f:0x0",
        "0x965155d63fa8c9fb00cebb360753911efec9718b0db13f64d7dddd45edc53ab0:0x0",
        "0xea07337354751ba2068e9fb1f56c0b7cd5b4f8b96392387cf4d8c32b39092067:0x0",
        "0xcf8ca99732c62de85820c8670e4257a035dd1c96af440caaa3c60e1fb30a064d:0x0",
        "0x9b661830567bc2b2917d9295bccac8409472c181623091bb80cd15d242256d5a:0x0",
        "0x3c86f4acd287c73551e1ecba3787c139158d9756e5127a1540b979167beb37e3:0x0",
        "0x700ac6b78787cfc2e446ecaef1e7885f05d8138c1b3211d1eed3df6b745e0047:0x0",
        "0x2ed6aca14bdf96fa4174b345ae1840a1c31ac41be4fd4fafa4550b0b9bb94a04:0x0",
        "0x7dfaffb686d86face0c9ae1b7cbd938627ed7f34a7e020465f7bd2d0ca0aefa5:0x0",
        "0xd25420447d02822f43dc7a15ffd9dd00ee3bfe72ef10227256c9878e327ea4c0:0x0",
        "0x5f20ab1a846b0018e91b17d364d31684d1f69c0226e0b71c1b8dc87684411f8a:0x0",
        "0xbccd8a4febd86e65f2508d87b787c791144312c62524d7425b2736f383f20d15:0x0",
        "0xa8aa116e9420c20d4513fad4f9c43e1b8578f77822345b67ad8553d7a4700b00:0x0",
        "0x8a2c1dbea8b03b80d27486b912a4466077e9774321580b96999a5c2b47e8a9c4:0x0",
        "0x1426d8ddd17d048900ab6649c8831ea0597020f8a3f391db33012faf3f426fad:0x0",
        "0x35b073cfad16bba683b74c0306c00f0a0620fd8e27db7151673dcdbd0857a750:0x0",
        "0xc33e4d35bb9d899f71cbbd2d0f9f8f19538fbd16afcef5b6843d4b5eddd743db:0x0",
        "0x4976ed59d93bbedcfc1a2822c0d65774060fa8cb4c0b0d41bed13054c3ccf7fb:0x0",
        "0xdaa57218ca7f632353ce3736ca0d46bbf80553d4b67843d73ac6037e8ddb7ff0:0x0",
        "0x103f9e99efddbb86171c87cabcd1a53b5e09df7863c1b3d63bc6ce71361eaa5a:0x0",
        "0x73068eb36a97ac7f35fd996761d4822a88afd3cf77252ab3b51966eadeb78491:0x0",
        "0xec6d8bc79cd7e0d7353726a438aa9c4cffa4683363331549af30d2542704a556:0x0",
        "0x05398d634a13a662dcbd1504fff11bcc12e287a779b1f35051997ad33ec2aa9f:0x0",
        "0x2bc0dcb5bc6b2cc5ccd4022db998004de578242d6ceeff5303d81a16828ffed5:0x0",
        "0x1976c37d6709fc5d128c1a1b547a598fdce892b4bcb54591d9dccf5f3f2fbb08:0x0",
        "0xc3ea8f82ea187c4fcb0d69aee9f12cfd2cebd52e9fa4aae7c51f4dcbf4e22107:0x0",
        "0xdb3f80f8e2e5f599e7a335f8da68791a87e94bb1042a20bbfef33f655aad0a21:0x0",
        "0x3bac25553adcd0ce92577f8fdeda52212388cbe307a3e6564cf1d5ae6dba4121:0x0",
        "0x3e7a84ff71358d30b6e4213cd5f5cf56bae03053a665bed68277a6fb5c852818:0x0",
        "0xb0ffef5e6998ddc86019de4d90a035c3aceb17fbfcaabb6a225dd27533e8673b:0x0",
      ],
      "utxoCount": 1,
      "utxoIds": [
        "69eea91d69b850abd92338fa4f0c9a11d0ed68f74bf5201cb7424dc49506af38:0",
      ],
      "xudtAssets": {
        "0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e": {
          "amount": 4100000000n,
          "cellCount": 41,
          "utxoCount": 1,
        },
      },
      "xudtCellCount": 41,
      "xudtCellIds": [
        "0x00f43b843640fab7c9951a7931632e6ade6ef3337f89489b1c2b400793ece665:0x0",
        "0xa398426747fb052d0832a3296ad89b72253428b6caa19e8be14d4fcb0befeb2d:0x0",
        "0xc657c0531c349e0602397f6369a462bbd3ec84efcd8876e1ccdc0e6f0201a8b0:0x0",
        "0xde2c71de17ebd73b1925805754b1fd2c2cd40b27d5de3edf23812b270439b162:0x0",
        "0xd2466255b2b05a229d3bb9c5f9f1b3def078283cdfd9cef1645ef1046c9047d5:0x0",
        "0xd64f32b7a5daf5c5fd7f0cf0ba76d9263383265fbc706b9043f344afd5fe00e8:0x0",
        "0x16bb55a5c1fd0d6a7d7e7b60892da24c2a33c27041fbf8ada93aab691a311f9b:0x0",
        "0xede3544e671ac287ff67ddea7ce99e7d0afafac5f2889f4f8b1c6c1cd09dcbcc:0x0",
        "0x67cad749783b7d8595b7e5818c08eb380575c64badbd792443f36ae5888ceaff:0x0",
        "0xcaacf9b9b495e1c811598e86d904768162914b1aca7c3537cdd1af2cbe640303:0x0",
        "0x85a5fa2ba570c35fd22e132b3f6a0ad03b8c151d0fd82abdbc8e4c3845615660:0x0",
        "0x62cb0ad5fdcfdfe819135f970604b0c7e7ba6761544d2db2f6e093e8dd50734f:0x0",
        "0x965155d63fa8c9fb00cebb360753911efec9718b0db13f64d7dddd45edc53ab0:0x0",
        "0xea07337354751ba2068e9fb1f56c0b7cd5b4f8b96392387cf4d8c32b39092067:0x0",
        "0xcf8ca99732c62de85820c8670e4257a035dd1c96af440caaa3c60e1fb30a064d:0x0",
        "0x9b661830567bc2b2917d9295bccac8409472c181623091bb80cd15d242256d5a:0x0",
        "0x3c86f4acd287c73551e1ecba3787c139158d9756e5127a1540b979167beb37e3:0x0",
        "0x700ac6b78787cfc2e446ecaef1e7885f05d8138c1b3211d1eed3df6b745e0047:0x0",
        "0x2ed6aca14bdf96fa4174b345ae1840a1c31ac41be4fd4fafa4550b0b9bb94a04:0x0",
        "0x7dfaffb686d86face0c9ae1b7cbd938627ed7f34a7e020465f7bd2d0ca0aefa5:0x0",
        "0xd25420447d02822f43dc7a15ffd9dd00ee3bfe72ef10227256c9878e327ea4c0:0x0",
        "0x5f20ab1a846b0018e91b17d364d31684d1f69c0226e0b71c1b8dc87684411f8a:0x0",
        "0xbccd8a4febd86e65f2508d87b787c791144312c62524d7425b2736f383f20d15:0x0",
        "0xa8aa116e9420c20d4513fad4f9c43e1b8578f77822345b67ad8553d7a4700b00:0x0",
        "0x8a2c1dbea8b03b80d27486b912a4466077e9774321580b96999a5c2b47e8a9c4:0x0",
        "0x1426d8ddd17d048900ab6649c8831ea0597020f8a3f391db33012faf3f426fad:0x0",
        "0x35b073cfad16bba683b74c0306c00f0a0620fd8e27db7151673dcdbd0857a750:0x0",
        "0xc33e4d35bb9d899f71cbbd2d0f9f8f19538fbd16afcef5b6843d4b5eddd743db:0x0",
        "0x4976ed59d93bbedcfc1a2822c0d65774060fa8cb4c0b0d41bed13054c3ccf7fb:0x0",
        "0xdaa57218ca7f632353ce3736ca0d46bbf80553d4b67843d73ac6037e8ddb7ff0:0x0",
        "0x103f9e99efddbb86171c87cabcd1a53b5e09df7863c1b3d63bc6ce71361eaa5a:0x0",
        "0x73068eb36a97ac7f35fd996761d4822a88afd3cf77252ab3b51966eadeb78491:0x0",
        "0xec6d8bc79cd7e0d7353726a438aa9c4cffa4683363331549af30d2542704a556:0x0",
        "0x05398d634a13a662dcbd1504fff11bcc12e287a779b1f35051997ad33ec2aa9f:0x0",
        "0x2bc0dcb5bc6b2cc5ccd4022db998004de578242d6ceeff5303d81a16828ffed5:0x0",
        "0x1976c37d6709fc5d128c1a1b547a598fdce892b4bcb54591d9dccf5f3f2fbb08:0x0",
        "0xc3ea8f82ea187c4fcb0d69aee9f12cfd2cebd52e9fa4aae7c51f4dcbf4e22107:0x0",
        "0xdb3f80f8e2e5f599e7a335f8da68791a87e94bb1042a20bbfef33f655aad0a21:0x0",
        "0x3bac25553adcd0ce92577f8fdeda52212388cbe307a3e6564cf1d5ae6dba4121:0x0",
        "0x3e7a84ff71358d30b6e4213cd5f5cf56bae03053a665bed68277a6fb5c852818:0x0",
        "0xb0ffef5e6998ddc86019de4d90a035c3aceb17fbfcaabb6a225dd27533e8673b:0x0",
      ],
    },
    "included": {
      "cellCount": 50,
      "cellIds": [
        "0x6adafca165f29c713d15da4e9415d610c02c1b8ce585cc4f5430aa5de3e0e239:0x0",
        "0x122d92afd897e5cce4f17896468453bef911e8ee5a2141e8da4e91fa37863b7d:0x0",
        "0x2e2ef6a59efa324e51cdf48f769ed044701719a47de696197ab2d52b10b46f02:0x0",
        "0x3ee4107480a679cfdc296dc05c8d71b27a68215a9d3991494e0c13d60ae13792:0x0",
        "0xd1cfd6764c4aae04eebd0f9e5b69dccd2708194b1331b92adb88c3de5a96a9da:0x0",
        "0x296b94918d48bf6a6a0c3ba8eb301472879060b6339d8ebb93fd59fcaa0fda62:0x0",
        "0xa368465ce2b6b717312755fea8d95eb475fdd66f019cd67050c0c383409c0667:0x0",
        "0xd8fcef10d92024e220bc314a216b9f1decca2f05138d6592a280ad3bb5c0d922:0x0",
        "0xe7797d33ca22ebe3052b273307ccc4472ac57747dcb70d5249efea4957f04f73:0x0",
        "0x2e4d2051d9d5182aa2d9d8360d55a9629e964a8a1562485f928963f39932563d:0x0",
        "0x79f810935bf3ac47bc97c50c78527d71cacc9594ec148eeb294159f6ced0483b:0x0",
        "0x27bf1271e34d3b89b8908302b1b52122cd4aabc9b05559c1f347ff1fdc943a12:0x0",
        "0x5d573c5fb16adaa17c42c7936fcfd7105818e4ef4bc613d4b6062698182500a6:0x0",
        "0x6204bf05f0b76e0f57eeda3e34773d0b75b9c8fbc4dec329b5a5e09b6fa418ee:0x0",
        "0xad5be28bad16f4792cc0dc9375b96b74721aafa0383a978ec24ad2ced05cfd16:0x0",
        "0x715a0ad3a91a8e88ae31998aa667e02c973da57f1a287e21dbe4dfcf9f133b65:0x0",
        "0x83c92b4592a287cfa76b15c1d0dec0abd7f487b201a1720f3004d1d742a5e581:0x0",
        "0xe763055974a3c1c58a9a8c6f14cd5d0251f26fbfc4f1dd86319411e8794f8889:0x0",
        "0xe0732a33f99598399e0d1bdeaa6ee96b9f0fca39651626a30b0bafa883a12419:0x0",
        "0xf8168a6392c0691293ec803cd599b3fbc631cf18ad9102dd35c6225f110ba29f:0x0",
        "0xefff789561ce58884324454924e62c1567e70e835c657b54df9a636f95029722:0x0",
        "0x21c7b033b9eb7eb4f4b28783a77447acc8a284b83dc99a353794175ee5c50de8:0x0",
        "0x1414ed5987b243661f6f911fab762b08d84146be46e2950d3f7e20f13df1f6f6:0x0",
        "0x418de4600629116373b24becdcab626f19d113a6093a75a5cef54a695714a20a:0x0",
        "0xd223e96ee030c303c31d79710ea19c7347a04f4b44ca4551c3342ce119e86132:0x0",
        "0xec2df4da6b567c7be7f698e1895be815626c6b5e504930d1c5b1431792465784:0x0",
        "0xcac45b975c8c52ca6199f39de541c0c069556fd54640f4b2838946344f42ce6d:0x0",
        "0x2f8b991d647b91c931eb32b224c5693991266ed10c89326795f5b71e22a57bea:0x0",
        "0x1ba483627e1dc86c2054a9a7c3ff34df116b2446f1c3c8c0fc70e2f9daf63a1f:0x0",
        "0xb65cf4b3f9705253dacc74a83589024e9f751ac3b2cef41d9dfe075b957c5477:0x0",
        "0x9ffa6b826ed3ab1f5fa8f32ee743b4820682897b671dd96f4fea414e04ec3ecc:0x0",
        "0xbd629504d74fda29a8b9187dc55a4a675c791d25a501862446c4c1d8a1ede2de:0x0",
        "0xc26347679c6f9c321af89838cac070c3a87d4280ed0054fbdd46d94a20683a8e:0x0",
        "0xedd3f3dde6f4253f32b4a24f3c95d9824f546732f51e67447580d3a590b1468e:0x0",
        "0x30b3d64d1df36113707f0918d406c3d79482ecc8e22439121cebc458c8960fbe:0x0",
        "0x6cac3ce5884577e922afe944e9bf05887e7ab3c847310eb79e6f39cd716cc307:0x0",
        "0xbc2a834cbb5b40f5cb47bd3f328297ca851a0c0628be06b2d6a43423750ed0aa:0x0",
        "0x75143c1c6e64b01d45122bfa5db70cc5dbb90e945e1c7c781c73363b5e3fb4e0:0x0",
        "0x6fb324d629f69d1d011015325559bd1a3f58cd2bd0e2dce23b006ea85eade376:0x0",
        "0xb5c70400545feef1c591c072b386e663805d984ecc90c9ebd282f39990a7cf17:0x0",
        "0xdc0c3056e70b4fe64eda00cdc1fd6b2ae435871608b9fbb75efd13a3e78b496e:0x0",
        "0xd30143cc94d6fdbb656db10a7635e936929febebc9e1424d163ab36a9041e9ba:0x0",
        "0x3b0d7d2072c86a2b6f72a1290a70c48f451c1f290adc207e063f8ca3f3edd2b0:0x0",
        "0xd7d8aa87e70834cbf1d4cf95767381471bdfd16b2d9a916d0927b7b81c3d134f:0x0",
        "0xa4c06a0f9be53d5416f8fe34d7be1a5229a8a2515e3814b6b1ebf18ee11fd032:0x0",
        "0x2ac48fd1b5db05851b756b6536f63f080598a8962ca365e20991b86ae547d456:0x0",
        "0xa01db6b79bd41ab7adf4b6f4e10b9a70e14489c109b218d3c6f24770eb5d3000:0x0",
        "0x4fcac5d05e7cbfc7352ade62e44f78cca09450c419fb39b3af05f94f02a48210:0x0",
        "0xa75bca0eaa472a83b9a155d4c75dbc3c0e846b7a841fd143ac051c2c07e4aa38:0x0",
        "0x5860c0a6a834e0bb2dfbc8d5f4c1885cbbe3367285f5dfb7d464fa042031d17c:0x0",
      ],
      "utxoCount": 50,
      "utxoIds": [
        "fd16aafb86ef05a373e59d2b812fcb117c65b647aa899085136913961127efca:0",
        "1007a173f8ace6567758d309fb7a281c1f19c5961ff69fa32789c9a83ddfac10:0",
        "f6a9fac73edd1d2e3f2e0570d1f80d5e6818d10064be28e37afbebfbdeb1595d:0",
        "b8292604f1da9ece395004f02ecc78db120983c1aeffab1eeb6cae26fd2d1505:0",
        "14ac28c1d76bf7162276a3311b71e480d3970879bd83bd68f5c1bdfc78811b80:0",
        "e7f558adc0e05221888ab0e48f14f5b525d1a32444f70969003ee0d1e37fa28a:0",
        "1b7cc9cbe2c78a4b5aea41aa54649184b1f3cb2fd1cda9e5ee9e3e50612ddcbb:0",
        "8ab11c1526ecc7461c81d759b59a2d80d043dcca5715507af10f935e77813a88:0",
        "7be2f3dc348825c68544058405d9057f687108efe538563111a871f6e08e6ee4:0",
        "a415b62a23b23a48de418eafa839f0927d51f03256b4ea7cb588c6ad0d353442:0",
        "30c0b1f5a45b35f78398553e080c677c45b502852ccd329175e3979312adb5f3:0",
        "a16e1f231219ea76a4a4929f2568db00d1011958d93fc470d0a3d959be345ac8:0",
        "1ea31870ecf0510f24227da536c904940e8b7f586ee2de112b747f018795146e:0",
        "7dec2763f1c3e3789ff9f5d5367fda365412810ac7af1fa1830249d7036d1d06:0",
        "f555aa0f0dd0dc6276fbdaab1cf97c4dc0bb766d831841b8e4c45923334224b8:0",
        "5c1694d43954222b0023521173f2a311ac7d6d7f5c4717d3b06367392947c80d:0",
        "c05e07bf2197e19131ae72451ee317d50e865daa921fb5141949f86bbae56e87:0",
        "8733ca61d872e77d00cfe22bf7aca4042ea6578acf8e083ded3cc3219e9137c5:0",
        "f7df15bc919dc91cc4ef89d21ce3b036fd6b8f9248d86e97835aeac7d603dbfb:0",
        "d11e507b66c2ae82b22d241587b4472801da9666186ae079fbfc0d9d367b9981:0",
        "336597fbbc83e9370411119b4a2b0f3d3124889a7fe5a08a15e706ea188d2c5f:0",
        "c3ba320ec1e942b035c13f2ae8846e182642cffdd37d960df6e1b8370a62f52d:0",
        "a6e2990ec036b293f208db50da247e02f902a2ba22d6c5794b34478e7b04cb68:0",
        "dfb3b97b3d8298e689a13ee06164746f792f6c6437794f54381ca51f70600a7b:0",
        "94d14ced4ee4e83a4c32966de2e2f2f2bad542d6b9cccb963de106b86f20a7c8:0",
        "e48f46324d903a1c160ef72c0f239f62433ca3d24c0ccc9e63d29286df1a2088:0",
        "3a9dcdd63cc65980ff31d5c8228b21615d4f8ba0ad8686b8dae941acbac4890f:0",
        "1184235765f54076dddc67cbcfcff020ac684044f548c97b6c756047138e68e7:0",
        "a1babcf38126037040a389ecd19bf391e9474f827d0553e5d60b402c8f8514ec:0",
        "6ef4e8ff6b6d7e8599dc0bb27ee808baa575cc207a628e995f18414a8009ee10:0",
        "9f8150acb2a1c31cb705b38982ff35bf822ba92a279a9b66af2268774969b495:0",
        "a7bfa3545f53d31b0d57b1cef3e916388acffcb8f9920d93d21005e11a0bb409:0",
        "9b31a06692b1f2ea7fc6cc6a3c5f4c9c5fb421d56e2d0e23900dd0ce94056a6c:0",
        "5a7d4cd78a230e24cd203a8b2a43199f9fa5099f9ea2480fc183e147d9e0960c:0",
        "7e0514d1ac12c4904af6aa3abbce83d10890f566bf4d886c596041fd7514f16a:0",
        "0cc6e2300bcf39d0eafa370ecd14c1191f93bd5255bd1efbeb55ecb1a9370f73:0",
        "3445ee96a6537fa97105aebd3e9331aeeebd1b9a7f08bec91bd76398c0a631a1:0",
        "fac32590b2203a17730f342c652e26c39107202d34e5596f6d4667e8cd694e0e:0",
        "8a81a8dc324d22499562e416a884e7bf9a55f5de7b28ee454ad3e76fa6597283:0",
        "ce808ec46872008364568e931b4fe484e0e8ea3c154770adb10f5c6b2b3ec286:0",
        "2c5d749dc3451230f2497384c02dc0e07efc5743bce02faf47db4a191095c5d8:0",
        "4418969debbb39c1ff3e82ba90375106ba471ffc66f87dd004ce216e3bd3d8a4:0",
        "6dad378f3bd75864adedbcffe0760838e68e9ba7403d4f968f2c16916270bbf2:0",
        "5c67a33f7685cdf656325aa7bad6631099a096189bd6db77ee954bd573b301db:0",
        "7f16485b8a8d9a1e142efb7dcd8b87a9f779a99468b26082a1b4258e1551ffb3:0",
        "2e589957d60da868c01821af5f99c19738c9963f12828cee966404fbfd96ce0a:0",
        "3ac82fb4579a4c94d639b8fe2e9d320e587eabf47d9912ae389d2442f61b140d:0",
        "d295a78cc0e60895cf05b8ab142e8992d159307cc7347bff9d5f84da8ef8688f:0",
        "f1ee2c32debdbca6e0bdd654f3356501951e9fda7f288df62144583b38c5d6b6:0",
        "f6ce37f9d89597172566ae0b3e18edcb1c92011add8190e0b53b5caf9566aea1:0",
      ],
      "xudtAssets": {
        "0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e": {
          "amount": 50000000000n,
          "cellCount": 50,
          "utxoCount": 50,
        },
      },
      "xudtCellCount": 50,
      "xudtCellIds": [
        "0x6adafca165f29c713d15da4e9415d610c02c1b8ce585cc4f5430aa5de3e0e239:0x0",
        "0x122d92afd897e5cce4f17896468453bef911e8ee5a2141e8da4e91fa37863b7d:0x0",
        "0x2e2ef6a59efa324e51cdf48f769ed044701719a47de696197ab2d52b10b46f02:0x0",
        "0x3ee4107480a679cfdc296dc05c8d71b27a68215a9d3991494e0c13d60ae13792:0x0",
        "0xd1cfd6764c4aae04eebd0f9e5b69dccd2708194b1331b92adb88c3de5a96a9da:0x0",
        "0x296b94918d48bf6a6a0c3ba8eb301472879060b6339d8ebb93fd59fcaa0fda62:0x0",
        "0xa368465ce2b6b717312755fea8d95eb475fdd66f019cd67050c0c383409c0667:0x0",
        "0xd8fcef10d92024e220bc314a216b9f1decca2f05138d6592a280ad3bb5c0d922:0x0",
        "0xe7797d33ca22ebe3052b273307ccc4472ac57747dcb70d5249efea4957f04f73:0x0",
        "0x2e4d2051d9d5182aa2d9d8360d55a9629e964a8a1562485f928963f39932563d:0x0",
        "0x79f810935bf3ac47bc97c50c78527d71cacc9594ec148eeb294159f6ced0483b:0x0",
        "0x27bf1271e34d3b89b8908302b1b52122cd4aabc9b05559c1f347ff1fdc943a12:0x0",
        "0x5d573c5fb16adaa17c42c7936fcfd7105818e4ef4bc613d4b6062698182500a6:0x0",
        "0x6204bf05f0b76e0f57eeda3e34773d0b75b9c8fbc4dec329b5a5e09b6fa418ee:0x0",
        "0xad5be28bad16f4792cc0dc9375b96b74721aafa0383a978ec24ad2ced05cfd16:0x0",
        "0x715a0ad3a91a8e88ae31998aa667e02c973da57f1a287e21dbe4dfcf9f133b65:0x0",
        "0x83c92b4592a287cfa76b15c1d0dec0abd7f487b201a1720f3004d1d742a5e581:0x0",
        "0xe763055974a3c1c58a9a8c6f14cd5d0251f26fbfc4f1dd86319411e8794f8889:0x0",
        "0xe0732a33f99598399e0d1bdeaa6ee96b9f0fca39651626a30b0bafa883a12419:0x0",
        "0xf8168a6392c0691293ec803cd599b3fbc631cf18ad9102dd35c6225f110ba29f:0x0",
        "0xefff789561ce58884324454924e62c1567e70e835c657b54df9a636f95029722:0x0",
        "0x21c7b033b9eb7eb4f4b28783a77447acc8a284b83dc99a353794175ee5c50de8:0x0",
        "0x1414ed5987b243661f6f911fab762b08d84146be46e2950d3f7e20f13df1f6f6:0x0",
        "0x418de4600629116373b24becdcab626f19d113a6093a75a5cef54a695714a20a:0x0",
        "0xd223e96ee030c303c31d79710ea19c7347a04f4b44ca4551c3342ce119e86132:0x0",
        "0xec2df4da6b567c7be7f698e1895be815626c6b5e504930d1c5b1431792465784:0x0",
        "0xcac45b975c8c52ca6199f39de541c0c069556fd54640f4b2838946344f42ce6d:0x0",
        "0x2f8b991d647b91c931eb32b224c5693991266ed10c89326795f5b71e22a57bea:0x0",
        "0x1ba483627e1dc86c2054a9a7c3ff34df116b2446f1c3c8c0fc70e2f9daf63a1f:0x0",
        "0xb65cf4b3f9705253dacc74a83589024e9f751ac3b2cef41d9dfe075b957c5477:0x0",
        "0x9ffa6b826ed3ab1f5fa8f32ee743b4820682897b671dd96f4fea414e04ec3ecc:0x0",
        "0xbd629504d74fda29a8b9187dc55a4a675c791d25a501862446c4c1d8a1ede2de:0x0",
        "0xc26347679c6f9c321af89838cac070c3a87d4280ed0054fbdd46d94a20683a8e:0x0",
        "0xedd3f3dde6f4253f32b4a24f3c95d9824f546732f51e67447580d3a590b1468e:0x0",
        "0x30b3d64d1df36113707f0918d406c3d79482ecc8e22439121cebc458c8960fbe:0x0",
        "0x6cac3ce5884577e922afe944e9bf05887e7ab3c847310eb79e6f39cd716cc307:0x0",
        "0xbc2a834cbb5b40f5cb47bd3f328297ca851a0c0628be06b2d6a43423750ed0aa:0x0",
        "0x75143c1c6e64b01d45122bfa5db70cc5dbb90e945e1c7c781c73363b5e3fb4e0:0x0",
        "0x6fb324d629f69d1d011015325559bd1a3f58cd2bd0e2dce23b006ea85eade376:0x0",
        "0xb5c70400545feef1c591c072b386e663805d984ecc90c9ebd282f39990a7cf17:0x0",
        "0xdc0c3056e70b4fe64eda00cdc1fd6b2ae435871608b9fbb75efd13a3e78b496e:0x0",
        "0xd30143cc94d6fdbb656db10a7635e936929febebc9e1424d163ab36a9041e9ba:0x0",
        "0x3b0d7d2072c86a2b6f72a1290a70c48f451c1f290adc207e063f8ca3f3edd2b0:0x0",
        "0xd7d8aa87e70834cbf1d4cf95767381471bdfd16b2d9a916d0927b7b81c3d134f:0x0",
        "0xa4c06a0f9be53d5416f8fe34d7be1a5229a8a2515e3814b6b1ebf18ee11fd032:0x0",
        "0x2ac48fd1b5db05851b756b6536f63f080598a8962ca365e20991b86ae547d456:0x0",
        "0xa01db6b79bd41ab7adf4b6f4e10b9a70e14489c109b218d3c6f24770eb5d3000:0x0",
        "0x4fcac5d05e7cbfc7352ade62e44f78cca09450c419fb39b3af05f94f02a48210:0x0",
        "0xa75bca0eaa472a83b9a155d4c75dbc3c0e846b7a841fd143ac051c2c07e4aa38:0x0",
        "0x5860c0a6a834e0bb2dfbc8d5f4c1885cbbe3367285f5dfb7d464fa042031d17c:0x0",
      ],
    },
  },
  "transactions": [
    {
      "btc": {
        "fee": 2426,
        "feeRate": 1,
        "psbtHex": "70736274ff0100fddb06020000002805152dfd26ae6ceb1eabffaec1830912db78cc2ef0045039ce9edaf1042629b80000000000ffffffff061d6d03d7490283a11fafc70a81125436da7f36d5f5f99f78e3c3f16327ec7d0000000000ffffffff09b40b1ae10510d2930d92f9b8fccf8a3816e9f3ceb1570d1bd3535f54a3bfa70000000000ffffffff0c96e0d947e183c10f48a29e9f09a59f9f19432a8b3a20cd240e238ad74c7d5a0000000000ffffffff0dc84729396763b0d317475c7f6d7dac11a3f273115223002b225439d494165c0000000000ffffffff0e4e69cde867466d6f59e5342d200791c3262e652c340f73173a20b29025c3fa0000000000ffffffff0f89c4baac41e9dab88686ada08b4f5d61218b22c8d531ff8059c63cd6cd9d3a0000000000ffffffff10acdf3da8c98927a39ff61f96c5191f1c287afb09d3587756e6acf873a107100000000000ffffffff10ee09804a41185f998e627a20cc75a5ba08e87eb20bdc99857e6d6bffe8f46e0000000000ffffffff2df5620a37b8e1f60d967dd3fdcf4226186e84e82a3fc135b042e9c10e32bac30000000000ffffffff4234350dadc688b57ceab45632f0517d92f039a8af8e41de483ab2232ab615a40000000000ffffffff5d59b1defbebfb7ae328be6400d118685e0df8d170052e3f2e1ddd3ec7faa9f60000000000ffffffff5f2c8d18ea06e7158aa0e57f9a8824313d0f2b4a9b11110437e983bcfb9765330000000000ffffffff68cb047b8e47344b79c5d622baa202f9027e24da50db08f293b236c00e99e2a60000000000ffffffff6af11475fd4160596c884dbf66f59008d183cebb3aaaf64a90c412acd114057e0000000000ffffffff6c6a0594ced00d90230e2d6ed521b45f9c4c5f3c6accc67feaf2b19266a0319b0000000000ffffffff6e149587017f742b11dee26e587f8b0e9404c936a57d22240f51f0ec7018a31e0000000000ffffffff730f37a9b1ec55ebfb1ebd5552bd931f19c114cd0e37faead039cf0b30e2c60c0000000000ffffffff7b0a60701fa51c38544f7937646c2f796f746461e03ea189e698823d7bb9b3df0000000000ffffffff801b8178fcbdc1f568bd83bd790897d380e4711b31a3762216f76bd7c128ac140000000000ffffffff81997b369d0dfcfb79e06a186696da012847b48715242db282aec2667b501ed10000000000ffffffff837259a66fe7d34a45ee287bdef5559abfe784a816e4629549224d32dca8818a0000000000ffffffff86c23e2b6b5c0fb1ad7047153ceae8e084e44f1b938e566483007268c48e80ce0000000000ffffffff876ee5ba6bf8491914b51f92aa5d860ed517e31e4572ae3191e19721bf075ec00000000000ffffffff88201adf8692d2639ecc0c4cd2a33c43629f230f2cf70e161c3a904d32468fe40000000000ffffffff883a81775e930ff17a501557cadc43d0802d9ab559d7811c46c7ec26151cb18a0000000000ffffffff8aa27fe3d1e03e006909f74424a3d125b5f5148fe4b08a882152e0c0ad58f5e70000000000ffffffff95b46949776822af669b9a272aa92b82bf35ff8289b305b71cc3a1b2ac50819f0000000000ffffffffa131a6c09863d71bc9be087f9a1bbdeeae31933ebdae0571a97f53a696ee45340000000000ffffffffb82442332359c4e4b84118836d76bbc04d7cf91cabdafb7662dcd00d0faa55f50000000000ffffffffbbdc2d61503e9eeee5a9cdd12fcbf3b184916454aa41ea5a4b8ac7e2cbc97c1b0000000000ffffffffc537919e21c33ced3d088ecf8a57a62e04a4acf72be2cf007de772d861ca33870000000000ffffffffc85a34be59d9a3d070c43fd9581901d100db68259f92a4a476ea1912231f6ea10000000000ffffffffc8a7206fb806e13d96cbccb9d642d5baf2f2e2e26d96324c3ae8e44eed4cd1940000000000ffffffffcaef271196136913859089aa47b6657c11cb2f812b9de573a305ef86fbaa16fd0000000000ffffffffe46e8ee0f671a811315638e5ef0871687f05d90584054485c6258834dcf3e27b0000000000ffffffffe7688e134760756c7bc948f5444068ac20f0cfcfcb67dcdd7640f565572384110000000000ffffffffec14858f2c400bd6e553057d824f47e991f39bd1ec89a34070032681f3bcbaa10000000000fffffffff3b5ad129397e3759132cd2c8502b5457c670c083e559883f7355ba4f5b1c0300000000000fffffffffbdb03d6c7ea5a83976ed848928f6bfd36b0e31cd289efc41cc99d91bc15dff70000000000ffffffff030000000000000000226a20e2614965809a619bfa47b36631c3896fca24780336a8d524930dd61ef4e67d11220200000000000016001497b7383f7c10b415a8963f4b35c1afa505fff366b44900000000000016001497b7383f7c10b415a8963f4b35c1afa505fff366000000000001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e927100000000",
      },
      "ckb": {
        "virtualTxResult": {
          "ckbRawTx": {
            "cellDeps": [
              {
                "depType": "code",
                "outPoint": {
                  "index": "0x0",
                  "txHash": "0xf1de59e973b85791ec32debbba08dff80c63197e895eb95d67fc1e9f6b413e00",
                },
              },
              {
                "depType": "code",
                "outPoint": {
                  "index": "0x1",
                  "txHash": "0xf1de59e973b85791ec32debbba08dff80c63197e895eb95d67fc1e9f6b413e00",
                },
              },
              {
                "depType": "code",
                "outPoint": {
                  "index": "0x0",
                  "txHash": "0xbf6fb538763efec2a70a6a3dcb7242787087e1030c4e7d86585bc63a9d337f5f",
                },
              },
            ],
            "headerDeps": [],
            "inputs": [
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0x3ee4107480a679cfdc296dc05c8d71b27a68215a9d3991494e0c13d60ae13792",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0x6204bf05f0b76e0f57eeda3e34773d0b75b9c8fbc4dec329b5a5e09b6fa418ee",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0xbd629504d74fda29a8b9187dc55a4a675c791d25a501862446c4c1d8a1ede2de",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0xedd3f3dde6f4253f32b4a24f3c95d9824f546732f51e67447580d3a590b1468e",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0x715a0ad3a91a8e88ae31998aa667e02c973da57f1a287e21dbe4dfcf9f133b65",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0x75143c1c6e64b01d45122bfa5db70cc5dbb90e945e1c7c781c73363b5e3fb4e0",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0xcac45b975c8c52ca6199f39de541c0c069556fd54640f4b2838946344f42ce6d",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0x122d92afd897e5cce4f17896468453bef911e8ee5a2141e8da4e91fa37863b7d",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0xb65cf4b3f9705253dacc74a83589024e9f751ac3b2cef41d9dfe075b957c5477",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0x21c7b033b9eb7eb4f4b28783a77447acc8a284b83dc99a353794175ee5c50de8",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0x2e4d2051d9d5182aa2d9d8360d55a9629e964a8a1562485f928963f39932563d",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0x2e2ef6a59efa324e51cdf48f769ed044701719a47de696197ab2d52b10b46f02",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0xefff789561ce58884324454924e62c1567e70e835c657b54df9a636f95029722",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0x1414ed5987b243661f6f911fab762b08d84146be46e2950d3f7e20f13df1f6f6",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0x30b3d64d1df36113707f0918d406c3d79482ecc8e22439121cebc458c8960fbe",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0xc26347679c6f9c321af89838cac070c3a87d4280ed0054fbdd46d94a20683a8e",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0x5d573c5fb16adaa17c42c7936fcfd7105818e4ef4bc613d4b6062698182500a6",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0x6cac3ce5884577e922afe944e9bf05887e7ab3c847310eb79e6f39cd716cc307",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0x418de4600629116373b24becdcab626f19d113a6093a75a5cef54a695714a20a",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0xd1cfd6764c4aae04eebd0f9e5b69dccd2708194b1331b92adb88c3de5a96a9da",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0xf8168a6392c0691293ec803cd599b3fbc631cf18ad9102dd35c6225f110ba29f",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0x6fb324d629f69d1d011015325559bd1a3f58cd2bd0e2dce23b006ea85eade376",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0xb5c70400545feef1c591c072b386e663805d984ecc90c9ebd282f39990a7cf17",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0x83c92b4592a287cfa76b15c1d0dec0abd7f487b201a1720f3004d1d742a5e581",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0xec2df4da6b567c7be7f698e1895be815626c6b5e504930d1c5b1431792465784",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0xd8fcef10d92024e220bc314a216b9f1decca2f05138d6592a280ad3bb5c0d922",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0x296b94918d48bf6a6a0c3ba8eb301472879060b6339d8ebb93fd59fcaa0fda62",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0x9ffa6b826ed3ab1f5fa8f32ee743b4820682897b671dd96f4fea414e04ec3ecc",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0xbc2a834cbb5b40f5cb47bd3f328297ca851a0c0628be06b2d6a43423750ed0aa",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0xad5be28bad16f4792cc0dc9375b96b74721aafa0383a978ec24ad2ced05cfd16",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0xa368465ce2b6b717312755fea8d95eb475fdd66f019cd67050c0c383409c0667",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0xe763055974a3c1c58a9a8c6f14cd5d0251f26fbfc4f1dd86319411e8794f8889",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0x27bf1271e34d3b89b8908302b1b52122cd4aabc9b05559c1f347ff1fdc943a12",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0xd223e96ee030c303c31d79710ea19c7347a04f4b44ca4551c3342ce119e86132",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0x6adafca165f29c713d15da4e9415d610c02c1b8ce585cc4f5430aa5de3e0e239",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0xe7797d33ca22ebe3052b273307ccc4472ac57747dcb70d5249efea4957f04f73",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0x2f8b991d647b91c931eb32b224c5693991266ed10c89326795f5b71e22a57bea",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0x1ba483627e1dc86c2054a9a7c3ff34df116b2446f1c3c8c0fc70e2f9daf63a1f",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0x79f810935bf3ac47bc97c50c78527d71cacc9594ec148eeb294159f6ced0483b",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0xe0732a33f99598399e0d1bdeaa6ee96b9f0fca39651626a30b0bafa883a12419",
                },
                "since": "0x0",
              },
            ],
            "outputs": [
              {
                "capacity": "0xeb9fe321c2",
                "lock": {
                  "args": "0x010000000000000000000000000000000000000000000000000000000000000000000000",
                  "codeHash": "0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248",
                  "hashType": "type",
                },
                "type": {
                  "args": "0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e",
                  "codeHash": "0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb",
                  "hashType": "type",
                },
              },
            ],
            "outputsData": [
              "0x00902f50090000000000000000000000",
            ],
            "version": "0x0",
            "witnesses": [
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
            ],
          },
          "commitment": "e2614965809a619bfa47b36631c3896fca24780336a8d524930dd61ef4e67d11",
          "needPaymasterCell": false,
          "sumInputsCapacity": "0xeb9fe68800",
        },
      },
      "summary": {
        "cellCount": 40,
        "cellIds": [
          "0x6adafca165f29c713d15da4e9415d610c02c1b8ce585cc4f5430aa5de3e0e239:0x0",
          "0x122d92afd897e5cce4f17896468453bef911e8ee5a2141e8da4e91fa37863b7d:0x0",
          "0x2e2ef6a59efa324e51cdf48f769ed044701719a47de696197ab2d52b10b46f02:0x0",
          "0x3ee4107480a679cfdc296dc05c8d71b27a68215a9d3991494e0c13d60ae13792:0x0",
          "0xd1cfd6764c4aae04eebd0f9e5b69dccd2708194b1331b92adb88c3de5a96a9da:0x0",
          "0x296b94918d48bf6a6a0c3ba8eb301472879060b6339d8ebb93fd59fcaa0fda62:0x0",
          "0xa368465ce2b6b717312755fea8d95eb475fdd66f019cd67050c0c383409c0667:0x0",
          "0xd8fcef10d92024e220bc314a216b9f1decca2f05138d6592a280ad3bb5c0d922:0x0",
          "0xe7797d33ca22ebe3052b273307ccc4472ac57747dcb70d5249efea4957f04f73:0x0",
          "0x2e4d2051d9d5182aa2d9d8360d55a9629e964a8a1562485f928963f39932563d:0x0",
          "0x79f810935bf3ac47bc97c50c78527d71cacc9594ec148eeb294159f6ced0483b:0x0",
          "0x27bf1271e34d3b89b8908302b1b52122cd4aabc9b05559c1f347ff1fdc943a12:0x0",
          "0x5d573c5fb16adaa17c42c7936fcfd7105818e4ef4bc613d4b6062698182500a6:0x0",
          "0x6204bf05f0b76e0f57eeda3e34773d0b75b9c8fbc4dec329b5a5e09b6fa418ee:0x0",
          "0xad5be28bad16f4792cc0dc9375b96b74721aafa0383a978ec24ad2ced05cfd16:0x0",
          "0x715a0ad3a91a8e88ae31998aa667e02c973da57f1a287e21dbe4dfcf9f133b65:0x0",
          "0x83c92b4592a287cfa76b15c1d0dec0abd7f487b201a1720f3004d1d742a5e581:0x0",
          "0xe763055974a3c1c58a9a8c6f14cd5d0251f26fbfc4f1dd86319411e8794f8889:0x0",
          "0xe0732a33f99598399e0d1bdeaa6ee96b9f0fca39651626a30b0bafa883a12419:0x0",
          "0xf8168a6392c0691293ec803cd599b3fbc631cf18ad9102dd35c6225f110ba29f:0x0",
          "0xefff789561ce58884324454924e62c1567e70e835c657b54df9a636f95029722:0x0",
          "0x21c7b033b9eb7eb4f4b28783a77447acc8a284b83dc99a353794175ee5c50de8:0x0",
          "0x1414ed5987b243661f6f911fab762b08d84146be46e2950d3f7e20f13df1f6f6:0x0",
          "0x418de4600629116373b24becdcab626f19d113a6093a75a5cef54a695714a20a:0x0",
          "0xd223e96ee030c303c31d79710ea19c7347a04f4b44ca4551c3342ce119e86132:0x0",
          "0xec2df4da6b567c7be7f698e1895be815626c6b5e504930d1c5b1431792465784:0x0",
          "0xcac45b975c8c52ca6199f39de541c0c069556fd54640f4b2838946344f42ce6d:0x0",
          "0x2f8b991d647b91c931eb32b224c5693991266ed10c89326795f5b71e22a57bea:0x0",
          "0x1ba483627e1dc86c2054a9a7c3ff34df116b2446f1c3c8c0fc70e2f9daf63a1f:0x0",
          "0xb65cf4b3f9705253dacc74a83589024e9f751ac3b2cef41d9dfe075b957c5477:0x0",
          "0x9ffa6b826ed3ab1f5fa8f32ee743b4820682897b671dd96f4fea414e04ec3ecc:0x0",
          "0xbd629504d74fda29a8b9187dc55a4a675c791d25a501862446c4c1d8a1ede2de:0x0",
          "0xc26347679c6f9c321af89838cac070c3a87d4280ed0054fbdd46d94a20683a8e:0x0",
          "0xedd3f3dde6f4253f32b4a24f3c95d9824f546732f51e67447580d3a590b1468e:0x0",
          "0x30b3d64d1df36113707f0918d406c3d79482ecc8e22439121cebc458c8960fbe:0x0",
          "0x6cac3ce5884577e922afe944e9bf05887e7ab3c847310eb79e6f39cd716cc307:0x0",
          "0xbc2a834cbb5b40f5cb47bd3f328297ca851a0c0628be06b2d6a43423750ed0aa:0x0",
          "0x75143c1c6e64b01d45122bfa5db70cc5dbb90e945e1c7c781c73363b5e3fb4e0:0x0",
          "0x6fb324d629f69d1d011015325559bd1a3f58cd2bd0e2dce23b006ea85eade376:0x0",
          "0xb5c70400545feef1c591c072b386e663805d984ecc90c9ebd282f39990a7cf17:0x0",
        ],
        "utxoCount": 40,
        "utxoIds": [
          "fd16aafb86ef05a373e59d2b812fcb117c65b647aa899085136913961127efca:0",
          "1007a173f8ace6567758d309fb7a281c1f19c5961ff69fa32789c9a83ddfac10:0",
          "f6a9fac73edd1d2e3f2e0570d1f80d5e6818d10064be28e37afbebfbdeb1595d:0",
          "b8292604f1da9ece395004f02ecc78db120983c1aeffab1eeb6cae26fd2d1505:0",
          "14ac28c1d76bf7162276a3311b71e480d3970879bd83bd68f5c1bdfc78811b80:0",
          "e7f558adc0e05221888ab0e48f14f5b525d1a32444f70969003ee0d1e37fa28a:0",
          "1b7cc9cbe2c78a4b5aea41aa54649184b1f3cb2fd1cda9e5ee9e3e50612ddcbb:0",
          "8ab11c1526ecc7461c81d759b59a2d80d043dcca5715507af10f935e77813a88:0",
          "7be2f3dc348825c68544058405d9057f687108efe538563111a871f6e08e6ee4:0",
          "a415b62a23b23a48de418eafa839f0927d51f03256b4ea7cb588c6ad0d353442:0",
          "30c0b1f5a45b35f78398553e080c677c45b502852ccd329175e3979312adb5f3:0",
          "a16e1f231219ea76a4a4929f2568db00d1011958d93fc470d0a3d959be345ac8:0",
          "1ea31870ecf0510f24227da536c904940e8b7f586ee2de112b747f018795146e:0",
          "7dec2763f1c3e3789ff9f5d5367fda365412810ac7af1fa1830249d7036d1d06:0",
          "f555aa0f0dd0dc6276fbdaab1cf97c4dc0bb766d831841b8e4c45923334224b8:0",
          "5c1694d43954222b0023521173f2a311ac7d6d7f5c4717d3b06367392947c80d:0",
          "c05e07bf2197e19131ae72451ee317d50e865daa921fb5141949f86bbae56e87:0",
          "8733ca61d872e77d00cfe22bf7aca4042ea6578acf8e083ded3cc3219e9137c5:0",
          "f7df15bc919dc91cc4ef89d21ce3b036fd6b8f9248d86e97835aeac7d603dbfb:0",
          "d11e507b66c2ae82b22d241587b4472801da9666186ae079fbfc0d9d367b9981:0",
          "336597fbbc83e9370411119b4a2b0f3d3124889a7fe5a08a15e706ea188d2c5f:0",
          "c3ba320ec1e942b035c13f2ae8846e182642cffdd37d960df6e1b8370a62f52d:0",
          "a6e2990ec036b293f208db50da247e02f902a2ba22d6c5794b34478e7b04cb68:0",
          "dfb3b97b3d8298e689a13ee06164746f792f6c6437794f54381ca51f70600a7b:0",
          "94d14ced4ee4e83a4c32966de2e2f2f2bad542d6b9cccb963de106b86f20a7c8:0",
          "e48f46324d903a1c160ef72c0f239f62433ca3d24c0ccc9e63d29286df1a2088:0",
          "3a9dcdd63cc65980ff31d5c8228b21615d4f8ba0ad8686b8dae941acbac4890f:0",
          "1184235765f54076dddc67cbcfcff020ac684044f548c97b6c756047138e68e7:0",
          "a1babcf38126037040a389ecd19bf391e9474f827d0553e5d60b402c8f8514ec:0",
          "6ef4e8ff6b6d7e8599dc0bb27ee808baa575cc207a628e995f18414a8009ee10:0",
          "9f8150acb2a1c31cb705b38982ff35bf822ba92a279a9b66af2268774969b495:0",
          "a7bfa3545f53d31b0d57b1cef3e916388acffcb8f9920d93d21005e11a0bb409:0",
          "9b31a06692b1f2ea7fc6cc6a3c5f4c9c5fb421d56e2d0e23900dd0ce94056a6c:0",
          "5a7d4cd78a230e24cd203a8b2a43199f9fa5099f9ea2480fc183e147d9e0960c:0",
          "7e0514d1ac12c4904af6aa3abbce83d10890f566bf4d886c596041fd7514f16a:0",
          "0cc6e2300bcf39d0eafa370ecd14c1191f93bd5255bd1efbeb55ecb1a9370f73:0",
          "3445ee96a6537fa97105aebd3e9331aeeebd1b9a7f08bec91bd76398c0a631a1:0",
          "fac32590b2203a17730f342c652e26c39107202d34e5596f6d4667e8cd694e0e:0",
          "8a81a8dc324d22499562e416a884e7bf9a55f5de7b28ee454ad3e76fa6597283:0",
          "ce808ec46872008364568e931b4fe484e0e8ea3c154770adb10f5c6b2b3ec286:0",
        ],
        "xudtAssets": {
          "0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e": {
            "amount": 40000000000n,
            "cellCount": 40,
            "utxoCount": 40,
          },
        },
        "xudtCellCount": 40,
        "xudtCellIds": [
          "0x6adafca165f29c713d15da4e9415d610c02c1b8ce585cc4f5430aa5de3e0e239:0x0",
          "0x122d92afd897e5cce4f17896468453bef911e8ee5a2141e8da4e91fa37863b7d:0x0",
          "0x2e2ef6a59efa324e51cdf48f769ed044701719a47de696197ab2d52b10b46f02:0x0",
          "0x3ee4107480a679cfdc296dc05c8d71b27a68215a9d3991494e0c13d60ae13792:0x0",
          "0xd1cfd6764c4aae04eebd0f9e5b69dccd2708194b1331b92adb88c3de5a96a9da:0x0",
          "0x296b94918d48bf6a6a0c3ba8eb301472879060b6339d8ebb93fd59fcaa0fda62:0x0",
          "0xa368465ce2b6b717312755fea8d95eb475fdd66f019cd67050c0c383409c0667:0x0",
          "0xd8fcef10d92024e220bc314a216b9f1decca2f05138d6592a280ad3bb5c0d922:0x0",
          "0xe7797d33ca22ebe3052b273307ccc4472ac57747dcb70d5249efea4957f04f73:0x0",
          "0x2e4d2051d9d5182aa2d9d8360d55a9629e964a8a1562485f928963f39932563d:0x0",
          "0x79f810935bf3ac47bc97c50c78527d71cacc9594ec148eeb294159f6ced0483b:0x0",
          "0x27bf1271e34d3b89b8908302b1b52122cd4aabc9b05559c1f347ff1fdc943a12:0x0",
          "0x5d573c5fb16adaa17c42c7936fcfd7105818e4ef4bc613d4b6062698182500a6:0x0",
          "0x6204bf05f0b76e0f57eeda3e34773d0b75b9c8fbc4dec329b5a5e09b6fa418ee:0x0",
          "0xad5be28bad16f4792cc0dc9375b96b74721aafa0383a978ec24ad2ced05cfd16:0x0",
          "0x715a0ad3a91a8e88ae31998aa667e02c973da57f1a287e21dbe4dfcf9f133b65:0x0",
          "0x83c92b4592a287cfa76b15c1d0dec0abd7f487b201a1720f3004d1d742a5e581:0x0",
          "0xe763055974a3c1c58a9a8c6f14cd5d0251f26fbfc4f1dd86319411e8794f8889:0x0",
          "0xe0732a33f99598399e0d1bdeaa6ee96b9f0fca39651626a30b0bafa883a12419:0x0",
          "0xf8168a6392c0691293ec803cd599b3fbc631cf18ad9102dd35c6225f110ba29f:0x0",
          "0xefff789561ce58884324454924e62c1567e70e835c657b54df9a636f95029722:0x0",
          "0x21c7b033b9eb7eb4f4b28783a77447acc8a284b83dc99a353794175ee5c50de8:0x0",
          "0x1414ed5987b243661f6f911fab762b08d84146be46e2950d3f7e20f13df1f6f6:0x0",
          "0x418de4600629116373b24becdcab626f19d113a6093a75a5cef54a695714a20a:0x0",
          "0xd223e96ee030c303c31d79710ea19c7347a04f4b44ca4551c3342ce119e86132:0x0",
          "0xec2df4da6b567c7be7f698e1895be815626c6b5e504930d1c5b1431792465784:0x0",
          "0xcac45b975c8c52ca6199f39de541c0c069556fd54640f4b2838946344f42ce6d:0x0",
          "0x2f8b991d647b91c931eb32b224c5693991266ed10c89326795f5b71e22a57bea:0x0",
          "0x1ba483627e1dc86c2054a9a7c3ff34df116b2446f1c3c8c0fc70e2f9daf63a1f:0x0",
          "0xb65cf4b3f9705253dacc74a83589024e9f751ac3b2cef41d9dfe075b957c5477:0x0",
          "0x9ffa6b826ed3ab1f5fa8f32ee743b4820682897b671dd96f4fea414e04ec3ecc:0x0",
          "0xbd629504d74fda29a8b9187dc55a4a675c791d25a501862446c4c1d8a1ede2de:0x0",
          "0xc26347679c6f9c321af89838cac070c3a87d4280ed0054fbdd46d94a20683a8e:0x0",
          "0xedd3f3dde6f4253f32b4a24f3c95d9824f546732f51e67447580d3a590b1468e:0x0",
          "0x30b3d64d1df36113707f0918d406c3d79482ecc8e22439121cebc458c8960fbe:0x0",
          "0x6cac3ce5884577e922afe944e9bf05887e7ab3c847310eb79e6f39cd716cc307:0x0",
          "0xbc2a834cbb5b40f5cb47bd3f328297ca851a0c0628be06b2d6a43423750ed0aa:0x0",
          "0x75143c1c6e64b01d45122bfa5db70cc5dbb90e945e1c7c781c73363b5e3fb4e0:0x0",
          "0x6fb324d629f69d1d011015325559bd1a3f58cd2bd0e2dce23b006ea85eade376:0x0",
          "0xb5c70400545feef1c591c072b386e663805d984ecc90c9ebd282f39990a7cf17:0x0",
        ],
      },
    },
    {
      "btc": {
        "fee": 693,
        "feeRate": 1,
        "psbtHex": "70736274ff0100fd0d02020000000a0ace96fdfb046496ee8c82123f96c93897c1995faf2118c068a80dd65799582e0000000000ffffffff0d141bf642249d38ae12997df4ab7e580e329d2efeb839d6944c9a57b42fc83a0000000000ffffffff8f68f88eda845f9dff7b34c77c3059d192892e14abb805cf9508e6c08ca795d20000000000ffffffffa1ae6695af5c3bb5e09081dd1a01921ccbed183e0bae6625179795d8f937cef60000000000ffffffffa4d8d33b6e21ce04d07df866fc1f47ba06513790ba823effc139bbeb9d9618440000000000ffffffffb3ff51158e25b4a18260b26894a979f7a9878bcd7dfb2e141e9a8d8a5b48167f0000000000ffffffffb6d6c5383b584421f68d287fda9f1e95016535f354d6bde0a6bcbdde322ceef10000000000ffffffffd8c59510194adb47af2fe0bc4357fc7ee0c02dc0847349f2301245c39d745d2c0000000000ffffffffdb01b373d54b95ee77dbd69b1896a0991063d6baa75a3256f6cd85763fa3675c0000000000fffffffff2bb706291162c8f964f3d40a79b8ee6380876e0ffbcedad6458d73b8f37ad6d0000000000ffffffff030000000000000000226a2027b431806c81ab81c42dd4908e1fb3cbe9eb7e8f248b05a38c904b7f5e4063cd220200000000000016001497b7383f7c10b415a8963f4b35c1afa505fff3667d1000000000000016001497b7383f7c10b415a8963f4b35c1afa505fff366000000000001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e927100000000",
      },
      "ckb": {
        "virtualTxResult": {
          "ckbRawTx": {
            "cellDeps": [
              {
                "depType": "code",
                "outPoint": {
                  "index": "0x0",
                  "txHash": "0xf1de59e973b85791ec32debbba08dff80c63197e895eb95d67fc1e9f6b413e00",
                },
              },
              {
                "depType": "code",
                "outPoint": {
                  "index": "0x1",
                  "txHash": "0xf1de59e973b85791ec32debbba08dff80c63197e895eb95d67fc1e9f6b413e00",
                },
              },
              {
                "depType": "code",
                "outPoint": {
                  "index": "0x0",
                  "txHash": "0xbf6fb538763efec2a70a6a3dcb7242787087e1030c4e7d86585bc63a9d337f5f",
                },
              },
            ],
            "headerDeps": [],
            "inputs": [
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0x2ac48fd1b5db05851b756b6536f63f080598a8962ca365e20991b86ae547d456",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0xa01db6b79bd41ab7adf4b6f4e10b9a70e14489c109b218d3c6f24770eb5d3000",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0x4fcac5d05e7cbfc7352ade62e44f78cca09450c419fb39b3af05f94f02a48210",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0x5860c0a6a834e0bb2dfbc8d5f4c1885cbbe3367285f5dfb7d464fa042031d17c",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0xd30143cc94d6fdbb656db10a7635e936929febebc9e1424d163ab36a9041e9ba",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0xa4c06a0f9be53d5416f8fe34d7be1a5229a8a2515e3814b6b1ebf18ee11fd032",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0xa75bca0eaa472a83b9a155d4c75dbc3c0e846b7a841fd143ac051c2c07e4aa38",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0xdc0c3056e70b4fe64eda00cdc1fd6b2ae435871608b9fbb75efd13a3e78b496e",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0xd7d8aa87e70834cbf1d4cf95767381471bdfd16b2d9a916d0927b7b81c3d134f",
                },
                "since": "0x0",
              },
              {
                "previousOutput": {
                  "index": "0x0",
                  "txHash": "0x3b0d7d2072c86a2b6f72a1290a70c48f451c1f290adc207e063f8ca3f3edd2b0",
                },
                "since": "0x0",
              },
            ],
            "outputs": [
              {
                "capacity": "0x3ae7f8c71f",
                "lock": {
                  "args": "0x010000000000000000000000000000000000000000000000000000000000000000000000",
                  "codeHash": "0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248",
                  "hashType": "type",
                },
                "type": {
                  "args": "0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e",
                  "codeHash": "0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb",
                  "hashType": "type",
                },
              },
            ],
            "outputsData": [
              "0x00e40b54020000000000000000000000",
            ],
            "version": "0x0",
            "witnesses": [
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
              "0xFF",
            ],
          },
          "commitment": "27b431806c81ab81c42dd4908e1fb3cbe9eb7e8f248b05a38c904b7f5e4063cd",
          "needPaymasterCell": false,
          "sumInputsCapacity": "0x3ae7f9a200",
        },
      },
      "summary": {
        "cellCount": 10,
        "cellIds": [
          "0xdc0c3056e70b4fe64eda00cdc1fd6b2ae435871608b9fbb75efd13a3e78b496e:0x0",
          "0xd30143cc94d6fdbb656db10a7635e936929febebc9e1424d163ab36a9041e9ba:0x0",
          "0x3b0d7d2072c86a2b6f72a1290a70c48f451c1f290adc207e063f8ca3f3edd2b0:0x0",
          "0xd7d8aa87e70834cbf1d4cf95767381471bdfd16b2d9a916d0927b7b81c3d134f:0x0",
          "0xa4c06a0f9be53d5416f8fe34d7be1a5229a8a2515e3814b6b1ebf18ee11fd032:0x0",
          "0x2ac48fd1b5db05851b756b6536f63f080598a8962ca365e20991b86ae547d456:0x0",
          "0xa01db6b79bd41ab7adf4b6f4e10b9a70e14489c109b218d3c6f24770eb5d3000:0x0",
          "0x4fcac5d05e7cbfc7352ade62e44f78cca09450c419fb39b3af05f94f02a48210:0x0",
          "0xa75bca0eaa472a83b9a155d4c75dbc3c0e846b7a841fd143ac051c2c07e4aa38:0x0",
          "0x5860c0a6a834e0bb2dfbc8d5f4c1885cbbe3367285f5dfb7d464fa042031d17c:0x0",
        ],
        "utxoCount": 10,
        "utxoIds": [
          "2c5d749dc3451230f2497384c02dc0e07efc5743bce02faf47db4a191095c5d8:0",
          "4418969debbb39c1ff3e82ba90375106ba471ffc66f87dd004ce216e3bd3d8a4:0",
          "6dad378f3bd75864adedbcffe0760838e68e9ba7403d4f968f2c16916270bbf2:0",
          "5c67a33f7685cdf656325aa7bad6631099a096189bd6db77ee954bd573b301db:0",
          "7f16485b8a8d9a1e142efb7dcd8b87a9f779a99468b26082a1b4258e1551ffb3:0",
          "2e589957d60da868c01821af5f99c19738c9963f12828cee966404fbfd96ce0a:0",
          "3ac82fb4579a4c94d639b8fe2e9d320e587eabf47d9912ae389d2442f61b140d:0",
          "d295a78cc0e60895cf05b8ab142e8992d159307cc7347bff9d5f84da8ef8688f:0",
          "f1ee2c32debdbca6e0bdd654f3356501951e9fda7f288df62144583b38c5d6b6:0",
          "f6ce37f9d89597172566ae0b3e18edcb1c92011add8190e0b53b5caf9566aea1:0",
        ],
        "xudtAssets": {
          "0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e": {
            "amount": 10000000000n,
            "cellCount": 10,
            "utxoCount": 10,
          },
        },
        "xudtCellCount": 10,
        "xudtCellIds": [
          "0xdc0c3056e70b4fe64eda00cdc1fd6b2ae435871608b9fbb75efd13a3e78b496e:0x0",
          "0xd30143cc94d6fdbb656db10a7635e936929febebc9e1424d163ab36a9041e9ba:0x0",
          "0x3b0d7d2072c86a2b6f72a1290a70c48f451c1f290adc207e063f8ca3f3edd2b0:0x0",
          "0xd7d8aa87e70834cbf1d4cf95767381471bdfd16b2d9a916d0927b7b81c3d134f:0x0",
          "0xa4c06a0f9be53d5416f8fe34d7be1a5229a8a2515e3814b6b1ebf18ee11fd032:0x0",
          "0x2ac48fd1b5db05851b756b6536f63f080598a8962ca365e20991b86ae547d456:0x0",
          "0xa01db6b79bd41ab7adf4b6f4e10b9a70e14489c109b218d3c6f24770eb5d3000:0x0",
          "0x4fcac5d05e7cbfc7352ade62e44f78cca09450c419fb39b3af05f94f02a48210:0x0",
          "0xa75bca0eaa472a83b9a155d4c75dbc3c0e846b7a841fd143ac051c2c07e4aa38:0x0",
          "0x5860c0a6a834e0bb2dfbc8d5f4c1885cbbe3367285f5dfb7d464fa042031d17c:0x0",
        ],
      },
    },
  ],
}
`;


================================================
File: packages/rgbpp/tests/mocked/50-included-41-excluded.ts
================================================
import { BtcApiUtxo, RgbppCell } from '@rgbpp-sdk/service';
import { Hash, LiveCell, OutPoint } from '@ckb-lumos/base';
import { IndexerCell } from '@rgbpp-sdk/ckb';
import { Utxo } from '@rgbpp-sdk/btc';
import { RgbppTransferAllTxsResult } from '../../src';

/**
 * Sender
 */

const account = {
  privateKey: '34296c47d1a8663da29b22bb9657ab19457753bdf92c88f9c85a8416b3de4ca8',
  address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
  pubkey: '0375ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e9271',
};

const btcUtxos: BtcApiUtxo[] = [
  {
    status: {
      block_hash: '000000000000000ce327fa467b9a9e574934ac682f85e1057294614300372c0f',
      block_height: 2872518,
      block_time: 1723003274,
      confirmed: true,
    },
    txid: 'fd16aafb86ef05a373e59d2b812fcb117c65b647aa899085136913961127efca',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000357ef9efa8b936dddaaf614059499ba82537b7cb4c6f13f74',
      block_height: 2872527,
      block_time: 1723008692,
      confirmed: true,
    },
    txid: '1007a173f8ace6567758d309fb7a281c1f19c5961ff69fa32789c9a83ddfac10',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000722c7185cf12fe5f6c0bfc9ee33ca872b61076660d9eabb01',
      block_height: 2872514,
      block_time: 1723002322,
      confirmed: true,
    },
    txid: 'f6a9fac73edd1d2e3f2e0570d1f80d5e6818d10064be28e37afbebfbdeb1595d',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000722c7185cf12fe5f6c0bfc9ee33ca872b61076660d9eabb01',
      block_height: 2872514,
      block_time: 1723002322,
      confirmed: true,
    },
    txid: 'b8292604f1da9ece395004f02ecc78db120983c1aeffab1eeb6cae26fd2d1505',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000722c7185cf12fe5f6c0bfc9ee33ca872b61076660d9eabb01',
      block_height: 2872514,
      block_time: 1723002322,
      confirmed: true,
    },
    txid: '14ac28c1d76bf7162276a3311b71e480d3970879bd83bd68f5c1bdfc78811b80',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000722c7185cf12fe5f6c0bfc9ee33ca872b61076660d9eabb01',
      block_height: 2872514,
      block_time: 1723002322,
      confirmed: true,
    },
    txid: 'e7f558adc0e05221888ab0e48f14f5b525d1a32444f70969003ee0d1e37fa28a',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000722c7185cf12fe5f6c0bfc9ee33ca872b61076660d9eabb01',
      block_height: 2872514,
      block_time: 1723002322,
      confirmed: true,
    },
    txid: '1b7cc9cbe2c78a4b5aea41aa54649184b1f3cb2fd1cda9e5ee9e3e50612ddcbb',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000722c7185cf12fe5f6c0bfc9ee33ca872b61076660d9eabb01',
      block_height: 2872514,
      block_time: 1723002322,
      confirmed: true,
    },
    txid: '8ab11c1526ecc7461c81d759b59a2d80d043dcca5715507af10f935e77813a88',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000722c7185cf12fe5f6c0bfc9ee33ca872b61076660d9eabb01',
      block_height: 2872514,
      block_time: 1723002322,
      confirmed: true,
    },
    txid: '7be2f3dc348825c68544058405d9057f687108efe538563111a871f6e08e6ee4',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000ce327fa467b9a9e574934ac682f85e1057294614300372c0f',
      block_height: 2872518,
      block_time: 1723003274,
      confirmed: true,
    },
    txid: 'a415b62a23b23a48de418eafa839f0927d51f03256b4ea7cb588c6ad0d353442',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000ce327fa467b9a9e574934ac682f85e1057294614300372c0f',
      block_height: 2872518,
      block_time: 1723003274,
      confirmed: true,
    },
    txid: '30c0b1f5a45b35f78398553e080c677c45b502852ccd329175e3979312adb5f3',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000ce327fa467b9a9e574934ac682f85e1057294614300372c0f',
      block_height: 2872518,
      block_time: 1723003274,
      confirmed: true,
    },
    txid: 'a16e1f231219ea76a4a4929f2568db00d1011958d93fc470d0a3d959be345ac8',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '0000000000000014559d88afa5e4eec69fcaf7b920947ba1b995f65940714127',
      block_height: 2872546,
      block_time: 1723013238,
      confirmed: true,
    },
    txid: '69eea91d69b850abd92338fa4f0c9a11d0ed68f74bf5201cb7424dc49506af38',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000722c7185cf12fe5f6c0bfc9ee33ca872b61076660d9eabb01',
      block_height: 2872514,
      block_time: 1723002322,
      confirmed: true,
    },
    txid: '1ea31870ecf0510f24227da536c904940e8b7f586ee2de112b747f018795146e',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000722c7185cf12fe5f6c0bfc9ee33ca872b61076660d9eabb01',
      block_height: 2872514,
      block_time: 1723002322,
      confirmed: true,
    },
    txid: '7dec2763f1c3e3789ff9f5d5367fda365412810ac7af1fa1830249d7036d1d06',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000ce327fa467b9a9e574934ac682f85e1057294614300372c0f',
      block_height: 2872518,
      block_time: 1723003274,
      confirmed: true,
    },
    txid: 'f555aa0f0dd0dc6276fbdaab1cf97c4dc0bb766d831841b8e4c45923334224b8',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000ce327fa467b9a9e574934ac682f85e1057294614300372c0f',
      block_height: 2872518,
      block_time: 1723003274,
      confirmed: true,
    },
    txid: '5c1694d43954222b0023521173f2a311ac7d6d7f5c4717d3b06367392947c80d',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000722c7185cf12fe5f6c0bfc9ee33ca872b61076660d9eabb01',
      block_height: 2872514,
      block_time: 1723002322,
      confirmed: true,
    },
    txid: 'c05e07bf2197e19131ae72451ee317d50e865daa921fb5141949f86bbae56e87',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000722c7185cf12fe5f6c0bfc9ee33ca872b61076660d9eabb01',
      block_height: 2872514,
      block_time: 1723002322,
      confirmed: true,
    },
    txid: '8733ca61d872e77d00cfe22bf7aca4042ea6578acf8e083ded3cc3219e9137c5',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000ce327fa467b9a9e574934ac682f85e1057294614300372c0f',
      block_height: 2872518,
      block_time: 1723003274,
      confirmed: true,
    },
    txid: 'f7df15bc919dc91cc4ef89d21ce3b036fd6b8f9248d86e97835aeac7d603dbfb',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000722c7185cf12fe5f6c0bfc9ee33ca872b61076660d9eabb01',
      block_height: 2872514,
      block_time: 1723002322,
      confirmed: true,
    },
    txid: 'd11e507b66c2ae82b22d241587b4472801da9666186ae079fbfc0d9d367b9981',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000ce327fa467b9a9e574934ac682f85e1057294614300372c0f',
      block_height: 2872518,
      block_time: 1723003274,
      confirmed: true,
    },
    txid: '336597fbbc83e9370411119b4a2b0f3d3124889a7fe5a08a15e706ea188d2c5f',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000ce327fa467b9a9e574934ac682f85e1057294614300372c0f',
      block_height: 2872518,
      block_time: 1723003274,
      confirmed: true,
    },
    txid: 'c3ba320ec1e942b035c13f2ae8846e182642cffdd37d960df6e1b8370a62f52d',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000722c7185cf12fe5f6c0bfc9ee33ca872b61076660d9eabb01',
      block_height: 2872514,
      block_time: 1723002322,
      confirmed: true,
    },
    txid: 'a6e2990ec036b293f208db50da247e02f902a2ba22d6c5794b34478e7b04cb68',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000722c7185cf12fe5f6c0bfc9ee33ca872b61076660d9eabb01',
      block_height: 2872514,
      block_time: 1723002322,
      confirmed: true,
    },
    txid: 'dfb3b97b3d8298e689a13ee06164746f792f6c6437794f54381ca51f70600a7b',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000357ef9efa8b936dddaaf614059499ba82537b7cb4c6f13f74',
      block_height: 2872527,
      block_time: 1723008692,
      confirmed: true,
    },
    txid: '94d14ced4ee4e83a4c32966de2e2f2f2bad542d6b9cccb963de106b86f20a7c8',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000722c7185cf12fe5f6c0bfc9ee33ca872b61076660d9eabb01',
      block_height: 2872514,
      block_time: 1723002322,
      confirmed: true,
    },
    txid: 'e48f46324d903a1c160ef72c0f239f62433ca3d24c0ccc9e63d29286df1a2088',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000ce327fa467b9a9e574934ac682f85e1057294614300372c0f',
      block_height: 2872518,
      block_time: 1723003274,
      confirmed: true,
    },
    txid: '3a9dcdd63cc65980ff31d5c8228b21615d4f8ba0ad8686b8dae941acbac4890f',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000ce327fa467b9a9e574934ac682f85e1057294614300372c0f',
      block_height: 2872518,
      block_time: 1723003274,
      confirmed: true,
    },
    txid: '1184235765f54076dddc67cbcfcff020ac684044f548c97b6c756047138e68e7',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000722c7185cf12fe5f6c0bfc9ee33ca872b61076660d9eabb01',
      block_height: 2872514,
      block_time: 1723002322,
      confirmed: true,
    },
    txid: 'a1babcf38126037040a389ecd19bf391e9474f827d0553e5d60b402c8f8514ec',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000ce327fa467b9a9e574934ac682f85e1057294614300372c0f',
      block_height: 2872518,
      block_time: 1723003274,
      confirmed: true,
    },
    txid: '6ef4e8ff6b6d7e8599dc0bb27ee808baa575cc207a628e995f18414a8009ee10',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000722c7185cf12fe5f6c0bfc9ee33ca872b61076660d9eabb01',
      block_height: 2872514,
      block_time: 1723002322,
      confirmed: true,
    },
    txid: '9f8150acb2a1c31cb705b38982ff35bf822ba92a279a9b66af2268774969b495',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000722c7185cf12fe5f6c0bfc9ee33ca872b61076660d9eabb01',
      block_height: 2872514,
      block_time: 1723002322,
      confirmed: true,
    },
    txid: 'a7bfa3545f53d31b0d57b1cef3e916388acffcb8f9920d93d21005e11a0bb409',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000722c7185cf12fe5f6c0bfc9ee33ca872b61076660d9eabb01',
      block_height: 2872514,
      block_time: 1723002322,
      confirmed: true,
    },
    txid: '9b31a06692b1f2ea7fc6cc6a3c5f4c9c5fb421d56e2d0e23900dd0ce94056a6c',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000ce327fa467b9a9e574934ac682f85e1057294614300372c0f',
      block_height: 2872518,
      block_time: 1723003274,
      confirmed: true,
    },
    txid: '5a7d4cd78a230e24cd203a8b2a43199f9fa5099f9ea2480fc183e147d9e0960c',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000ce327fa467b9a9e574934ac682f85e1057294614300372c0f',
      block_height: 2872518,
      block_time: 1723003274,
      confirmed: true,
    },
    txid: '7e0514d1ac12c4904af6aa3abbce83d10890f566bf4d886c596041fd7514f16a',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000ce327fa467b9a9e574934ac682f85e1057294614300372c0f',
      block_height: 2872518,
      block_time: 1723003274,
      confirmed: true,
    },
    txid: '0cc6e2300bcf39d0eafa370ecd14c1191f93bd5255bd1efbeb55ecb1a9370f73',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000722c7185cf12fe5f6c0bfc9ee33ca872b61076660d9eabb01',
      block_height: 2872514,
      block_time: 1723002322,
      confirmed: true,
    },
    txid: '3445ee96a6537fa97105aebd3e9331aeeebd1b9a7f08bec91bd76398c0a631a1',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000ce327fa467b9a9e574934ac682f85e1057294614300372c0f',
      block_height: 2872518,
      block_time: 1723003274,
      confirmed: true,
    },
    txid: 'fac32590b2203a17730f342c652e26c39107202d34e5596f6d4667e8cd694e0e',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000ce327fa467b9a9e574934ac682f85e1057294614300372c0f',
      block_height: 2872518,
      block_time: 1723003274,
      confirmed: true,
    },
    txid: '8a81a8dc324d22499562e416a884e7bf9a55f5de7b28ee454ad3e76fa6597283',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000ce327fa467b9a9e574934ac682f85e1057294614300372c0f',
      block_height: 2872518,
      block_time: 1723003274,
      confirmed: true,
    },
    txid: 'ce808ec46872008364568e931b4fe484e0e8ea3c154770adb10f5c6b2b3ec286',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000ce327fa467b9a9e574934ac682f85e1057294614300372c0f',
      block_height: 2872518,
      block_time: 1723003274,
      confirmed: true,
    },
    txid: '2c5d749dc3451230f2497384c02dc0e07efc5743bce02faf47db4a191095c5d8',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000ce327fa467b9a9e574934ac682f85e1057294614300372c0f',
      block_height: 2872518,
      block_time: 1723003274,
      confirmed: true,
    },
    txid: '4418969debbb39c1ff3e82ba90375106ba471ffc66f87dd004ce216e3bd3d8a4',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000ce327fa467b9a9e574934ac682f85e1057294614300372c0f',
      block_height: 2872518,
      block_time: 1723003274,
      confirmed: true,
    },
    txid: '6dad378f3bd75864adedbcffe0760838e68e9ba7403d4f968f2c16916270bbf2',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000722c7185cf12fe5f6c0bfc9ee33ca872b61076660d9eabb01',
      block_height: 2872514,
      block_time: 1723002322,
      confirmed: true,
    },
    txid: '5c67a33f7685cdf656325aa7bad6631099a096189bd6db77ee954bd573b301db',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000722c7185cf12fe5f6c0bfc9ee33ca872b61076660d9eabb01',
      block_height: 2872514,
      block_time: 1723002322,
      confirmed: true,
    },
    txid: '7f16485b8a8d9a1e142efb7dcd8b87a9f779a99468b26082a1b4258e1551ffb3',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000722c7185cf12fe5f6c0bfc9ee33ca872b61076660d9eabb01',
      block_height: 2872514,
      block_time: 1723002322,
      confirmed: true,
    },
    txid: '2e589957d60da868c01821af5f99c19738c9963f12828cee966404fbfd96ce0a',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000ce327fa467b9a9e574934ac682f85e1057294614300372c0f',
      block_height: 2872518,
      block_time: 1723003274,
      confirmed: true,
    },
    txid: '3ac82fb4579a4c94d639b8fe2e9d320e587eabf47d9912ae389d2442f61b140d',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000ce327fa467b9a9e574934ac682f85e1057294614300372c0f',
      block_height: 2872518,
      block_time: 1723003274,
      confirmed: true,
    },
    txid: 'd295a78cc0e60895cf05b8ab142e8992d159307cc7347bff9d5f84da8ef8688f',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000722c7185cf12fe5f6c0bfc9ee33ca872b61076660d9eabb01',
      block_height: 2872514,
      block_time: 1723002322,
      confirmed: true,
    },
    txid: 'f1ee2c32debdbca6e0bdd654f3356501951e9fda7f288df62144583b38c5d6b6',
    value: 546,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000ce327fa467b9a9e574934ac682f85e1057294614300372c0f',
      block_height: 2872518,
      block_time: 1723003274,
      confirmed: true,
    },
    txid: 'f6ce37f9d89597172566ae0b3e18edcb1c92011add8190e0b53b5caf9566aea1',
    value: 546,
    vout: 0,
  },
];

const utxosByUtxoId: Record<string, Utxo> = {
  'fd16aafb86ef05a373e59d2b812fcb117c65b647aa899085136913961127efca:0': {
    txid: 'fd16aafb86ef05a373e59d2b812fcb117c65b647aa899085136913961127efca',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  '1007a173f8ace6567758d309fb7a281c1f19c5961ff69fa32789c9a83ddfac10:0': {
    txid: '1007a173f8ace6567758d309fb7a281c1f19c5961ff69fa32789c9a83ddfac10',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  'f6a9fac73edd1d2e3f2e0570d1f80d5e6818d10064be28e37afbebfbdeb1595d:0': {
    txid: 'f6a9fac73edd1d2e3f2e0570d1f80d5e6818d10064be28e37afbebfbdeb1595d',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  'b8292604f1da9ece395004f02ecc78db120983c1aeffab1eeb6cae26fd2d1505:0': {
    txid: 'b8292604f1da9ece395004f02ecc78db120983c1aeffab1eeb6cae26fd2d1505',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  '14ac28c1d76bf7162276a3311b71e480d3970879bd83bd68f5c1bdfc78811b80:0': {
    txid: '14ac28c1d76bf7162276a3311b71e480d3970879bd83bd68f5c1bdfc78811b80',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  'e7f558adc0e05221888ab0e48f14f5b525d1a32444f70969003ee0d1e37fa28a:0': {
    txid: 'e7f558adc0e05221888ab0e48f14f5b525d1a32444f70969003ee0d1e37fa28a',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  '1b7cc9cbe2c78a4b5aea41aa54649184b1f3cb2fd1cda9e5ee9e3e50612ddcbb:0': {
    txid: '1b7cc9cbe2c78a4b5aea41aa54649184b1f3cb2fd1cda9e5ee9e3e50612ddcbb',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  '8ab11c1526ecc7461c81d759b59a2d80d043dcca5715507af10f935e77813a88:0': {
    txid: '8ab11c1526ecc7461c81d759b59a2d80d043dcca5715507af10f935e77813a88',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  '7be2f3dc348825c68544058405d9057f687108efe538563111a871f6e08e6ee4:0': {
    txid: '7be2f3dc348825c68544058405d9057f687108efe538563111a871f6e08e6ee4',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  'a415b62a23b23a48de418eafa839f0927d51f03256b4ea7cb588c6ad0d353442:0': {
    txid: 'a415b62a23b23a48de418eafa839f0927d51f03256b4ea7cb588c6ad0d353442',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  '30c0b1f5a45b35f78398553e080c677c45b502852ccd329175e3979312adb5f3:0': {
    txid: '30c0b1f5a45b35f78398553e080c677c45b502852ccd329175e3979312adb5f3',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  'a16e1f231219ea76a4a4929f2568db00d1011958d93fc470d0a3d959be345ac8:0': {
    txid: 'a16e1f231219ea76a4a4929f2568db00d1011958d93fc470d0a3d959be345ac8',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  '69eea91d69b850abd92338fa4f0c9a11d0ed68f74bf5201cb7424dc49506af38:0': {
    txid: '69eea91d69b850abd92338fa4f0c9a11d0ed68f74bf5201cb7424dc49506af38',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  '1ea31870ecf0510f24227da536c904940e8b7f586ee2de112b747f018795146e:0': {
    txid: '1ea31870ecf0510f24227da536c904940e8b7f586ee2de112b747f018795146e',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  '7dec2763f1c3e3789ff9f5d5367fda365412810ac7af1fa1830249d7036d1d06:0': {
    txid: '7dec2763f1c3e3789ff9f5d5367fda365412810ac7af1fa1830249d7036d1d06',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  'f555aa0f0dd0dc6276fbdaab1cf97c4dc0bb766d831841b8e4c45923334224b8:0': {
    txid: 'f555aa0f0dd0dc6276fbdaab1cf97c4dc0bb766d831841b8e4c45923334224b8',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  '5c1694d43954222b0023521173f2a311ac7d6d7f5c4717d3b06367392947c80d:0': {
    txid: '5c1694d43954222b0023521173f2a311ac7d6d7f5c4717d3b06367392947c80d',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  'c05e07bf2197e19131ae72451ee317d50e865daa921fb5141949f86bbae56e87:0': {
    txid: 'c05e07bf2197e19131ae72451ee317d50e865daa921fb5141949f86bbae56e87',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  '8733ca61d872e77d00cfe22bf7aca4042ea6578acf8e083ded3cc3219e9137c5:0': {
    txid: '8733ca61d872e77d00cfe22bf7aca4042ea6578acf8e083ded3cc3219e9137c5',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  'f7df15bc919dc91cc4ef89d21ce3b036fd6b8f9248d86e97835aeac7d603dbfb:0': {
    txid: 'f7df15bc919dc91cc4ef89d21ce3b036fd6b8f9248d86e97835aeac7d603dbfb',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  'd11e507b66c2ae82b22d241587b4472801da9666186ae079fbfc0d9d367b9981:0': {
    txid: 'd11e507b66c2ae82b22d241587b4472801da9666186ae079fbfc0d9d367b9981',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  '336597fbbc83e9370411119b4a2b0f3d3124889a7fe5a08a15e706ea188d2c5f:0': {
    txid: '336597fbbc83e9370411119b4a2b0f3d3124889a7fe5a08a15e706ea188d2c5f',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  'c3ba320ec1e942b035c13f2ae8846e182642cffdd37d960df6e1b8370a62f52d:0': {
    txid: 'c3ba320ec1e942b035c13f2ae8846e182642cffdd37d960df6e1b8370a62f52d',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  'a6e2990ec036b293f208db50da247e02f902a2ba22d6c5794b34478e7b04cb68:0': {
    txid: 'a6e2990ec036b293f208db50da247e02f902a2ba22d6c5794b34478e7b04cb68',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  'dfb3b97b3d8298e689a13ee06164746f792f6c6437794f54381ca51f70600a7b:0': {
    txid: 'dfb3b97b3d8298e689a13ee06164746f792f6c6437794f54381ca51f70600a7b',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  '94d14ced4ee4e83a4c32966de2e2f2f2bad542d6b9cccb963de106b86f20a7c8:0': {
    txid: '94d14ced4ee4e83a4c32966de2e2f2f2bad542d6b9cccb963de106b86f20a7c8',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  'e48f46324d903a1c160ef72c0f239f62433ca3d24c0ccc9e63d29286df1a2088:0': {
    txid: 'e48f46324d903a1c160ef72c0f239f62433ca3d24c0ccc9e63d29286df1a2088',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  '3a9dcdd63cc65980ff31d5c8228b21615d4f8ba0ad8686b8dae941acbac4890f:0': {
    txid: '3a9dcdd63cc65980ff31d5c8228b21615d4f8ba0ad8686b8dae941acbac4890f',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  '1184235765f54076dddc67cbcfcff020ac684044f548c97b6c756047138e68e7:0': {
    txid: '1184235765f54076dddc67cbcfcff020ac684044f548c97b6c756047138e68e7',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  'a1babcf38126037040a389ecd19bf391e9474f827d0553e5d60b402c8f8514ec:0': {
    txid: 'a1babcf38126037040a389ecd19bf391e9474f827d0553e5d60b402c8f8514ec',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  '6ef4e8ff6b6d7e8599dc0bb27ee808baa575cc207a628e995f18414a8009ee10:0': {
    txid: '6ef4e8ff6b6d7e8599dc0bb27ee808baa575cc207a628e995f18414a8009ee10',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  '9f8150acb2a1c31cb705b38982ff35bf822ba92a279a9b66af2268774969b495:0': {
    txid: '9f8150acb2a1c31cb705b38982ff35bf822ba92a279a9b66af2268774969b495',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  'a7bfa3545f53d31b0d57b1cef3e916388acffcb8f9920d93d21005e11a0bb409:0': {
    txid: 'a7bfa3545f53d31b0d57b1cef3e916388acffcb8f9920d93d21005e11a0bb409',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  '9b31a06692b1f2ea7fc6cc6a3c5f4c9c5fb421d56e2d0e23900dd0ce94056a6c:0': {
    txid: '9b31a06692b1f2ea7fc6cc6a3c5f4c9c5fb421d56e2d0e23900dd0ce94056a6c',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  '5a7d4cd78a230e24cd203a8b2a43199f9fa5099f9ea2480fc183e147d9e0960c:0': {
    txid: '5a7d4cd78a230e24cd203a8b2a43199f9fa5099f9ea2480fc183e147d9e0960c',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  '7e0514d1ac12c4904af6aa3abbce83d10890f566bf4d886c596041fd7514f16a:0': {
    txid: '7e0514d1ac12c4904af6aa3abbce83d10890f566bf4d886c596041fd7514f16a',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  '0cc6e2300bcf39d0eafa370ecd14c1191f93bd5255bd1efbeb55ecb1a9370f73:0': {
    txid: '0cc6e2300bcf39d0eafa370ecd14c1191f93bd5255bd1efbeb55ecb1a9370f73',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  '3445ee96a6537fa97105aebd3e9331aeeebd1b9a7f08bec91bd76398c0a631a1:0': {
    txid: '3445ee96a6537fa97105aebd3e9331aeeebd1b9a7f08bec91bd76398c0a631a1',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  'fac32590b2203a17730f342c652e26c39107202d34e5596f6d4667e8cd694e0e:0': {
    txid: 'fac32590b2203a17730f342c652e26c39107202d34e5596f6d4667e8cd694e0e',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  '8a81a8dc324d22499562e416a884e7bf9a55f5de7b28ee454ad3e76fa6597283:0': {
    txid: '8a81a8dc324d22499562e416a884e7bf9a55f5de7b28ee454ad3e76fa6597283',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  'ce808ec46872008364568e931b4fe484e0e8ea3c154770adb10f5c6b2b3ec286:0': {
    txid: 'ce808ec46872008364568e931b4fe484e0e8ea3c154770adb10f5c6b2b3ec286',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  '2c5d749dc3451230f2497384c02dc0e07efc5743bce02faf47db4a191095c5d8:0': {
    txid: '2c5d749dc3451230f2497384c02dc0e07efc5743bce02faf47db4a191095c5d8',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  '4418969debbb39c1ff3e82ba90375106ba471ffc66f87dd004ce216e3bd3d8a4:0': {
    txid: '4418969debbb39c1ff3e82ba90375106ba471ffc66f87dd004ce216e3bd3d8a4',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  '6dad378f3bd75864adedbcffe0760838e68e9ba7403d4f968f2c16916270bbf2:0': {
    txid: '6dad378f3bd75864adedbcffe0760838e68e9ba7403d4f968f2c16916270bbf2',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  '5c67a33f7685cdf656325aa7bad6631099a096189bd6db77ee954bd573b301db:0': {
    txid: '5c67a33f7685cdf656325aa7bad6631099a096189bd6db77ee954bd573b301db',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  '7f16485b8a8d9a1e142efb7dcd8b87a9f779a99468b26082a1b4258e1551ffb3:0': {
    txid: '7f16485b8a8d9a1e142efb7dcd8b87a9f779a99468b26082a1b4258e1551ffb3',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  '2e589957d60da868c01821af5f99c19738c9963f12828cee966404fbfd96ce0a:0': {
    txid: '2e589957d60da868c01821af5f99c19738c9963f12828cee966404fbfd96ce0a',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  '3ac82fb4579a4c94d639b8fe2e9d320e587eabf47d9912ae389d2442f61b140d:0': {
    txid: '3ac82fb4579a4c94d639b8fe2e9d320e587eabf47d9912ae389d2442f61b140d',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  'd295a78cc0e60895cf05b8ab142e8992d159307cc7347bff9d5f84da8ef8688f:0': {
    txid: 'd295a78cc0e60895cf05b8ab142e8992d159307cc7347bff9d5f84da8ef8688f',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  'f1ee2c32debdbca6e0bdd654f3356501951e9fda7f288df62144583b38c5d6b6:0': {
    txid: 'f1ee2c32debdbca6e0bdd654f3356501951e9fda7f288df62144583b38c5d6b6',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
  'f6ce37f9d89597172566ae0b3e18edcb1c92011add8190e0b53b5caf9566aea1:0': {
    txid: 'f6ce37f9d89597172566ae0b3e18edcb1c92011add8190e0b53b5caf9566aea1',
    vout: 0,
    value: 546,
    scriptPk: '5120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b88',
    address: 'tb1pxwxda89xx69r2jqeve78zxx0hldhgy73y5hlph2ud3z0u9sf0wyq8uxxju',
    addressType: 2,
  },
};

const rgbppCells: RgbppCell[] = [
  {
    blockNumber: '0xd81c6a',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x00000000caef271196136913859089aa47b6657c11cb2f812b9de573a305ef86fbaa16fd',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x6adafca165f29c713d15da4e9415d610c02c1b8ce585cc4f5430aa5de3e0e239',
    },
    txIndex: '0x4',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81c75',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000010acdf3da8c98927a39ff61f96c5191f1c287afb09d3587756e6acf873a10710',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x122d92afd897e5cce4f17896468453bef911e8ee5a2141e8da4e91fa37863b7d',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81c45',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x000000005d59b1defbebfb7ae328be6400d118685e0df8d170052e3f2e1ddd3ec7faa9f6',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x2e2ef6a59efa324e51cdf48f769ed044701719a47de696197ab2d52b10b46f02',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81bc3',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000005152dfd26ae6ceb1eabffaec1830912db78cc2ef0045039ce9edaf1042629b8',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x3ee4107480a679cfdc296dc05c8d71b27a68215a9d3991494e0c13d60ae13792',
    },
    txIndex: '0x2',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81c3b',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x00000000801b8178fcbdc1f568bd83bd790897d380e4711b31a3762216f76bd7c128ac14',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xd1cfd6764c4aae04eebd0f9e5b69dccd2708194b1331b92adb88c3de5a96a9da',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81c2e',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x000000008aa27fe3d1e03e006909f74424a3d125b5f5148fe4b08a882152e0c0ad58f5e7',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x296b94918d48bf6a6a0c3ba8eb301472879060b6339d8ebb93fd59fcaa0fda62',
    },
    txIndex: '0x4',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81bc7',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x00000000bbdc2d61503e9eeee5a9cdd12fcbf3b184916454aa41ea5a4b8ac7e2cbc97c1b',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xa368465ce2b6b717312755fea8d95eb475fdd66f019cd67050c0c383409c0667',
    },
    txIndex: '0x2',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81b9f',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x00000000883a81775e930ff17a501557cadc43d0802d9ab559d7811c46c7ec26151cb18a',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xd8fcef10d92024e220bc314a216b9f1decca2f05138d6592a280ad3bb5c0d922',
    },
    txIndex: '0x2',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81c5f',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x00000000e46e8ee0f671a811315638e5ef0871687f05d90584054485c6258834dcf3e27b',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xe7797d33ca22ebe3052b273307ccc4472ac57747dcb70d5249efea4957f04f73',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81c0a',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x000000004234350dadc688b57ceab45632f0517d92f039a8af8e41de483ab2232ab615a4',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x2e4d2051d9d5182aa2d9d8360d55a9629e964a8a1562485f928963f39932563d',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81bed',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x00000000f3b5ad129397e3759132cd2c8502b5457c670c083e559883f7355ba4f5b1c030',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x79f810935bf3ac47bc97c50c78527d71cacc9594ec148eeb294159f6ced0483b',
    },
    txIndex: '0x2',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81c66',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x00000000c85a34be59d9a3d070c43fd9581901d100db68259f92a4a476ea1912231f6ea1',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x27bf1271e34d3b89b8908302b1b52122cd4aabc9b05559c1f347ff1fdc943a12',
    },
    txIndex: '0x4',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81e71',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x00f43b843640fab7c9951a7931632e6ade6ef3337f89489b1c2b400793ece665',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81e5d',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xa398426747fb052d0832a3296ad89b72253428b6caa19e8be14d4fcb0befeb2d',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81e59',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xc657c0531c349e0602397f6369a462bbd3ec84efcd8876e1ccdc0e6f0201a8b0',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81e56',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xde2c71de17ebd73b1925805754b1fd2c2cd40b27d5de3edf23812b270439b162',
    },
    txIndex: '0x3',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81e51',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xd2466255b2b05a229d3bb9c5f9f1b3def078283cdfd9cef1645ef1046c9047d5',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81e4d',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xd64f32b7a5daf5c5fd7f0cf0ba76d9263383265fbc706b9043f344afd5fe00e8',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81e48',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x16bb55a5c1fd0d6a7d7e7b60892da24c2a33c27041fbf8ada93aab691a311f9b',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81e44',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xede3544e671ac287ff67ddea7ce99e7d0afafac5f2889f4f8b1c6c1cd09dcbcc',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81e41',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x67cad749783b7d8595b7e5818c08eb380575c64badbd792443f36ae5888ceaff',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81e3d',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xcaacf9b9b495e1c811598e86d904768162914b1aca7c3537cdd1af2cbe640303',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81e38',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x85a5fa2ba570c35fd22e132b3f6a0ad03b8c151d0fd82abdbc8e4c3845615660',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81e2b',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x62cb0ad5fdcfdfe819135f970604b0c7e7ba6761544d2db2f6e093e8dd50734f',
    },
    txIndex: '0x4',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81e24',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x965155d63fa8c9fb00cebb360753911efec9718b0db13f64d7dddd45edc53ab0',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81e20',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xea07337354751ba2068e9fb1f56c0b7cd5b4f8b96392387cf4d8c32b39092067',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81e19',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xcf8ca99732c62de85820c8670e4257a035dd1c96af440caaa3c60e1fb30a064d',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81e13',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x9b661830567bc2b2917d9295bccac8409472c181623091bb80cd15d242256d5a',
    },
    txIndex: '0x4',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81e0f',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x3c86f4acd287c73551e1ecba3787c139158d9756e5127a1540b979167beb37e3',
    },
    txIndex: '0x5',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81e0b',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x700ac6b78787cfc2e446ecaef1e7885f05d8138c1b3211d1eed3df6b745e0047',
    },
    txIndex: '0x4',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81e02',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x2ed6aca14bdf96fa4174b345ae1840a1c31ac41be4fd4fafa4550b0b9bb94a04',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81dfe',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x7dfaffb686d86face0c9ae1b7cbd938627ed7f34a7e020465f7bd2d0ca0aefa5',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81dfb',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xd25420447d02822f43dc7a15ffd9dd00ee3bfe72ef10227256c9878e327ea4c0',
    },
    txIndex: '0x4',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81df2',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x5f20ab1a846b0018e91b17d364d31684d1f69c0226e0b71c1b8dc87684411f8a',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81def',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xbccd8a4febd86e65f2508d87b787c791144312c62524d7425b2736f383f20d15',
    },
    txIndex: '0x4',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81deb',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xa8aa116e9420c20d4513fad4f9c43e1b8578f77822345b67ad8553d7a4700b00',
    },
    txIndex: '0x3',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81de7',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x8a2c1dbea8b03b80d27486b912a4466077e9774321580b96999a5c2b47e8a9c4',
    },
    txIndex: '0x3',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81de4',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x1426d8ddd17d048900ab6649c8831ea0597020f8a3f391db33012faf3f426fad',
    },
    txIndex: '0x2',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81de0',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x35b073cfad16bba683b74c0306c00f0a0620fd8e27db7151673dcdbd0857a750',
    },
    txIndex: '0x2',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81ddd',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xc33e4d35bb9d899f71cbbd2d0f9f8f19538fbd16afcef5b6843d4b5eddd743db',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81dd9',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x4976ed59d93bbedcfc1a2822c0d65774060fa8cb4c0b0d41bed13054c3ccf7fb',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81dd5',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xdaa57218ca7f632353ce3736ca0d46bbf80553d4b67843d73ac6037e8ddb7ff0',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81dd2',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x103f9e99efddbb86171c87cabcd1a53b5e09df7863c1b3d63bc6ce71361eaa5a',
    },
    txIndex: '0x2',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81dc3',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x73068eb36a97ac7f35fd996761d4822a88afd3cf77252ab3b51966eadeb78491',
    },
    txIndex: '0x3',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81db8',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xec6d8bc79cd7e0d7353726a438aa9c4cffa4683363331549af30d2542704a556',
    },
    txIndex: '0x2',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81db3',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x05398d634a13a662dcbd1504fff11bcc12e287a779b1f35051997ad33ec2aa9f',
    },
    txIndex: '0x2',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81daf',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x2bc0dcb5bc6b2cc5ccd4022db998004de578242d6ceeff5303d81a16828ffed5',
    },
    txIndex: '0x2',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81dac',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x1976c37d6709fc5d128c1a1b547a598fdce892b4bcb54591d9dccf5f3f2fbb08',
    },
    txIndex: '0x3',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81d9b',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xc3ea8f82ea187c4fcb0d69aee9f12cfd2cebd52e9fa4aae7c51f4dcbf4e22107',
    },
    txIndex: '0x2',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81d97',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xdb3f80f8e2e5f599e7a335f8da68791a87e94bb1042a20bbfef33f655aad0a21',
    },
    txIndex: '0x2',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81d91',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x3bac25553adcd0ce92577f8fdeda52212388cbe307a3e6564cf1d5ae6dba4121',
    },
    txIndex: '0x2',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81d8c',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x3e7a84ff71358d30b6e4213cd5f5cf56bae03053a665bed68277a6fb5c852818',
    },
    txIndex: '0x3',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81d88',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00e1f505000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xb0ffef5e6998ddc86019de4d90a035c3aceb17fbfcaabb6a225dd27533e8673b',
    },
    txIndex: '0x3',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81bf2',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x000000006e149587017f742b11dee26e587f8b0e9404c936a57d22240f51f0ec7018a31e',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x5d573c5fb16adaa17c42c7936fcfd7105818e4ef4bc613d4b6062698182500a6',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81bfc',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x00000000061d6d03d7490283a11fafc70a81125436da7f36d5f5f99f78e3c3f16327ec7d',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x6204bf05f0b76e0f57eeda3e34773d0b75b9c8fbc4dec329b5a5e09b6fa418ee',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81c72',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x00000000b82442332359c4e4b84118836d76bbc04d7cf91cabdafb7662dcd00d0faa55f5',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xad5be28bad16f4792cc0dc9375b96b74721aafa0383a978ec24ad2ced05cfd16',
    },
    txIndex: '0x4',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81c07',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x000000000dc84729396763b0d317475c7f6d7dac11a3f273115223002b225439d494165c',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x715a0ad3a91a8e88ae31998aa667e02c973da57f1a287e21dbe4dfcf9f133b65',
    },
    txIndex: '0x2',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81bff',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x00000000876ee5ba6bf8491914b51f92aa5d860ed517e31e4572ae3191e19721bf075ec0',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x83c92b4592a287cfa76b15c1d0dec0abd7f487b201a1720f3004d1d742a5e581',
    },
    txIndex: '0x2',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81c90',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x00000000c537919e21c33ced3d088ecf8a57a62e04a4acf72be2cf007de772d861ca3387',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xe763055974a3c1c58a9a8c6f14cd5d0251f26fbfc4f1dd86319411e8794f8889',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81c29',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x00000000fbdb03d6c7ea5a83976ed848928f6bfd36b0e31cd289efc41cc99d91bc15dff7',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xe0732a33f99598399e0d1bdeaa6ee96b9f0fca39651626a30b0bafa883a12419',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81bb3',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000081997b369d0dfcfb79e06a186696da012847b48715242db282aec2667b501ed1',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xf8168a6392c0691293ec803cd599b3fbc631cf18ad9102dd35c6225f110ba29f',
    },
    txIndex: '0x2',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81be4',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x000000005f2c8d18ea06e7158aa0e57f9a8824313d0f2b4a9b11110437e983bcfb976533',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xefff789561ce58884324454924e62c1567e70e835c657b54df9a636f95029722',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81c04',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x000000002df5620a37b8e1f60d967dd3fdcf4226186e84e82a3fc135b042e9c10e32bac3',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x21c7b033b9eb7eb4f4b28783a77447acc8a284b83dc99a353794175ee5c50de8',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81bc0',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000068cb047b8e47344b79c5d622baa202f9027e24da50db08f293b236c00e99e2a6',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x1414ed5987b243661f6f911fab762b08d84146be46e2950d3f7e20f13df1f6f6',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81c37',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x000000007b0a60701fa51c38544f7937646c2f796f746461e03ea189e698823d7bb9b3df',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x418de4600629116373b24becdcab626f19d113a6093a75a5cef54a695714a20a',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81c7f',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x00000000c8a7206fb806e13d96cbccb9d642d5baf2f2e2e26d96324c3ae8e44eed4cd194',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xd223e96ee030c303c31d79710ea19c7347a04f4b44ca4551c3342ce119e86132',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81c4c',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000088201adf8692d2639ecc0c4cd2a33c43629f230f2cf70e161c3a904d32468fe4',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xec2df4da6b567c7be7f698e1895be815626c6b5e504930d1c5b1431792465784',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81bba',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x000000000f89c4baac41e9dab88686ada08b4f5d61218b22c8d531ff8059c63cd6cd9d3a',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xcac45b975c8c52ca6199f39de541c0c069556fd54640f4b2838946344f42ce6d',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81c23',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x00000000e7688e134760756c7bc948f5444068ac20f0cfcfcb67dcdd7640f56557238411',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x2f8b991d647b91c931eb32b224c5693991266ed10c89326795f5b71e22a57bea',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81c20',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x00000000ec14858f2c400bd6e553057d824f47e991f39bd1ec89a34070032681f3bcbaa1',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x1ba483627e1dc86c2054a9a7c3ff34df116b2446f1c3c8c0fc70e2f9daf63a1f',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81bdf',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000010ee09804a41185f998e627a20cc75a5ba08e87eb20bdc99857e6d6bffe8f46e',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xb65cf4b3f9705253dacc74a83589024e9f751ac3b2cef41d9dfe075b957c5477',
    },
    txIndex: '0x2',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81c57',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000095b46949776822af669b9a272aa92b82bf35ff8289b305b71cc3a1b2ac50819f',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x9ffa6b826ed3ab1f5fa8f32ee743b4820682897b671dd96f4fea414e04ec3ecc',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81bdb',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000009b40b1ae10510d2930d92f9b8fccf8a3816e9f3ceb1570d1bd3535f54a3bfa7',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xbd629504d74fda29a8b9187dc55a4a675c791d25a501862446c4c1d8a1ede2de',
    },
    txIndex: '0x2',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81ba5',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x000000006c6a0594ced00d90230e2d6ed521b45f9c4c5f3c6accc67feaf2b19266a0319b',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xc26347679c6f9c321af89838cac070c3a87d4280ed0054fbdd46d94a20683a8e',
    },
    txIndex: '0x3',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81c8b',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x000000000c96e0d947e183c10f48a29e9f09a59f9f19432a8b3a20cd240e238ad74c7d5a',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xedd3f3dde6f4253f32b4a24f3c95d9824f546732f51e67447580d3a590b1468e',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81c0f',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x000000006af11475fd4160596c884dbf66f59008d183cebb3aaaf64a90c412acd114057e',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x30b3d64d1df36113707f0918d406c3d79482ecc8e22439121cebc458c8960fbe',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81c15',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x00000000730f37a9b1ec55ebfb1ebd5552bd931f19c114cd0e37faead039cf0b30e2c60c',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x6cac3ce5884577e922afe944e9bf05887e7ab3c847310eb79e6f39cd716cc307',
    },
    txIndex: '0x4',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81c5a',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x00000000a131a6c09863d71bc9be087f9a1bbdeeae31933ebdae0571a97f53a696ee4534',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xbc2a834cbb5b40f5cb47bd3f328297ca851a0c0628be06b2d6a43423750ed0aa',
    },
    txIndex: '0x4',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81c53',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x000000000e4e69cde867466d6f59e5342d200791c3262e652c340f73173a20b29025c3fa',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x75143c1c6e64b01d45122bfa5db70cc5dbb90e945e1c7c781c73363b5e3fb4e0',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81bca',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x00000000837259a66fe7d34a45ee287bdef5559abfe784a816e4629549224d32dca8818a',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x6fb324d629f69d1d011015325559bd1a3f58cd2bd0e2dce23b006ea85eade376',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81c63',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x0000000086c23e2b6b5c0fb1ad7047153ceae8e084e44f1b938e566483007268c48e80ce',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xb5c70400545feef1c591c072b386e663805d984ecc90c9ebd282f39990a7cf17',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81c1b',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x00000000d8c59510194adb47af2fe0bc4357fc7ee0c02dc0847349f2301245c39d745d2c',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xdc0c3056e70b4fe64eda00cdc1fd6b2ae435871608b9fbb75efd13a3e78b496e',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81bab',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x00000000a4d8d33b6e21ce04d07df866fc1f47ba06513790ba823effc139bbeb9d961844',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xd30143cc94d6fdbb656db10a7635e936929febebc9e1424d163ab36a9041e9ba',
    },
    txIndex: '0x2',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81bae',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x00000000f2bb706291162c8f964f3d40a79b8ee6380876e0ffbcedad6458d73b8f37ad6d',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x3b0d7d2072c86a2b6f72a1290a70c48f451c1f290adc207e063f8ca3f3edd2b0',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81bf6',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x00000000db01b373d54b95ee77dbd69b1896a0991063d6baa75a3256f6cd85763fa3675c',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xd7d8aa87e70834cbf1d4cf95767381471bdfd16b2d9a916d0927b7b81c3d134f',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81bcf',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x00000000b3ff51158e25b4a18260b26894a979f7a9878bcd7dfb2e141e9a8d8a5b48167f',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xa4c06a0f9be53d5416f8fe34d7be1a5229a8a2515e3814b6b1ebf18ee11fd032',
    },
    txIndex: '0x2',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81c40',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x000000000ace96fdfb046496ee8c82123f96c93897c1995faf2118c068a80dd65799582e',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x2ac48fd1b5db05851b756b6536f63f080598a8962ca365e20991b86ae547d456',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81bbd',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x000000000d141bf642249d38ae12997df4ab7e580e329d2efeb839d6944c9a57b42fc83a',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xa01db6b79bd41ab7adf4b6f4e10b9a70e14489c109b218d3c6f24770eb5d3000',
    },
    txIndex: '0x3',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81bea',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x000000008f68f88eda845f9dff7b34c77c3059d192892e14abb805cf9508e6c08ca795d2',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x4fcac5d05e7cbfc7352ade62e44f78cca09450c419fb39b3af05f94f02a48210',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81c87',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x00000000b6d6c5383b584421f68d287fda9f1e95016535f354d6bde0a6bcbdde322ceef1',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0xa75bca0eaa472a83b9a155d4c75dbc3c0e846b7a841fd143ac051c2c07e4aa38',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
  {
    blockNumber: '0xd81c6d',
    cellOutput: {
      capacity: '0x5e3ff5d00',
      lock: {
        args: '0x00000000a1ae6695af5c3bb5e09081dd1a01921ccbed183e0bae6625179795d8f937cef6',
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
      },
      type: {
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
      },
    },
    data: '0x00ca9a3b000000000000000000000000',
    outPoint: {
      index: '0x0',
      txHash: '0x5860c0a6a834e0bb2dfbc8d5f4c1885cbbe3367285f5dfb7d464fa042031d17c',
    },
    txIndex: '0x1',
    typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
  },
];

const rgbppCellsByUtxoId: Record<string, RgbppCell[]> = {
  '8ab11c1526ecc7461c81d759b59a2d80d043dcca5715507af10f935e77813a88:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x00000000883a81775e930ff17a501557cadc43d0802d9ab559d7811c46c7ec26151cb18a',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0xd8fcef10d92024e220bc314a216b9f1decca2f05138d6592a280ad3bb5c0d922',
        index: '0x0',
      },
      blockNumber: '0xd81b9f',
      txIndex: '0x2',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  'fd16aafb86ef05a373e59d2b812fcb117c65b647aa899085136913961127efca:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x00000000caef271196136913859089aa47b6657c11cb2f812b9de573a305ef86fbaa16fd',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0x6adafca165f29c713d15da4e9415d610c02c1b8ce585cc4f5430aa5de3e0e239',
        index: '0x0',
      },
      blockNumber: '0xd81c6a',
      txIndex: '0x4',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  '14ac28c1d76bf7162276a3311b71e480d3970879bd83bd68f5c1bdfc78811b80:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x00000000801b8178fcbdc1f568bd83bd790897d380e4711b31a3762216f76bd7c128ac14',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0xd1cfd6764c4aae04eebd0f9e5b69dccd2708194b1331b92adb88c3de5a96a9da',
        index: '0x0',
      },
      blockNumber: '0xd81c3b',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  '7be2f3dc348825c68544058405d9057f687108efe538563111a871f6e08e6ee4:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x00000000e46e8ee0f671a811315638e5ef0871687f05d90584054485c6258834dcf3e27b',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0xe7797d33ca22ebe3052b273307ccc4472ac57747dcb70d5249efea4957f04f73',
        index: '0x0',
      },
      blockNumber: '0xd81c5f',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  '1007a173f8ace6567758d309fb7a281c1f19c5961ff69fa32789c9a83ddfac10:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000010acdf3da8c98927a39ff61f96c5191f1c287afb09d3587756e6acf873a10710',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0x122d92afd897e5cce4f17896468453bef911e8ee5a2141e8da4e91fa37863b7d',
        index: '0x0',
      },
      blockNumber: '0xd81c75',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  'b8292604f1da9ece395004f02ecc78db120983c1aeffab1eeb6cae26fd2d1505:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000005152dfd26ae6ceb1eabffaec1830912db78cc2ef0045039ce9edaf1042629b8',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0x3ee4107480a679cfdc296dc05c8d71b27a68215a9d3991494e0c13d60ae13792',
        index: '0x0',
      },
      blockNumber: '0xd81bc3',
      txIndex: '0x2',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  'e7f558adc0e05221888ab0e48f14f5b525d1a32444f70969003ee0d1e37fa28a:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x000000008aa27fe3d1e03e006909f74424a3d125b5f5148fe4b08a882152e0c0ad58f5e7',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0x296b94918d48bf6a6a0c3ba8eb301472879060b6339d8ebb93fd59fcaa0fda62',
        index: '0x0',
      },
      blockNumber: '0xd81c2e',
      txIndex: '0x4',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  'a415b62a23b23a48de418eafa839f0927d51f03256b4ea7cb588c6ad0d353442:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x000000004234350dadc688b57ceab45632f0517d92f039a8af8e41de483ab2232ab615a4',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0x2e4d2051d9d5182aa2d9d8360d55a9629e964a8a1562485f928963f39932563d',
        index: '0x0',
      },
      blockNumber: '0xd81c0a',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  'f6a9fac73edd1d2e3f2e0570d1f80d5e6818d10064be28e37afbebfbdeb1595d:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x000000005d59b1defbebfb7ae328be6400d118685e0df8d170052e3f2e1ddd3ec7faa9f6',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0x2e2ef6a59efa324e51cdf48f769ed044701719a47de696197ab2d52b10b46f02',
        index: '0x0',
      },
      blockNumber: '0xd81c45',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  '1b7cc9cbe2c78a4b5aea41aa54649184b1f3cb2fd1cda9e5ee9e3e50612ddcbb:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x00000000bbdc2d61503e9eeee5a9cdd12fcbf3b184916454aa41ea5a4b8ac7e2cbc97c1b',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0xa368465ce2b6b717312755fea8d95eb475fdd66f019cd67050c0c383409c0667',
        index: '0x0',
      },
      blockNumber: '0xd81bc7',
      txIndex: '0x2',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  '5c1694d43954222b0023521173f2a311ac7d6d7f5c4717d3b06367392947c80d:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x000000000dc84729396763b0d317475c7f6d7dac11a3f273115223002b225439d494165c',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0x715a0ad3a91a8e88ae31998aa667e02c973da57f1a287e21dbe4dfcf9f133b65',
        index: '0x0',
      },
      blockNumber: '0xd81c07',
      txIndex: '0x2',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  'c05e07bf2197e19131ae72451ee317d50e865daa921fb5141949f86bbae56e87:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x00000000876ee5ba6bf8491914b51f92aa5d860ed517e31e4572ae3191e19721bf075ec0',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0x83c92b4592a287cfa76b15c1d0dec0abd7f487b201a1720f3004d1d742a5e581',
        index: '0x0',
      },
      blockNumber: '0xd81bff',
      txIndex: '0x2',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  'f555aa0f0dd0dc6276fbdaab1cf97c4dc0bb766d831841b8e4c45923334224b8:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x00000000b82442332359c4e4b84118836d76bbc04d7cf91cabdafb7662dcd00d0faa55f5',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0xad5be28bad16f4792cc0dc9375b96b74721aafa0383a978ec24ad2ced05cfd16',
        index: '0x0',
      },
      blockNumber: '0xd81c72',
      txIndex: '0x4',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  '7dec2763f1c3e3789ff9f5d5367fda365412810ac7af1fa1830249d7036d1d06:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x00000000061d6d03d7490283a11fafc70a81125436da7f36d5f5f99f78e3c3f16327ec7d',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0x6204bf05f0b76e0f57eeda3e34773d0b75b9c8fbc4dec329b5a5e09b6fa418ee',
        index: '0x0',
      },
      blockNumber: '0xd81bfc',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  'f7df15bc919dc91cc4ef89d21ce3b036fd6b8f9248d86e97835aeac7d603dbfb:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x00000000fbdb03d6c7ea5a83976ed848928f6bfd36b0e31cd289efc41cc99d91bc15dff7',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0xe0732a33f99598399e0d1bdeaa6ee96b9f0fca39651626a30b0bafa883a12419',
        index: '0x0',
      },
      blockNumber: '0xd81c29',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  'dfb3b97b3d8298e689a13ee06164746f792f6c6437794f54381ca51f70600a7b:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x000000007b0a60701fa51c38544f7937646c2f796f746461e03ea189e698823d7bb9b3df',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0x418de4600629116373b24becdcab626f19d113a6093a75a5cef54a695714a20a',
        index: '0x0',
      },
      blockNumber: '0xd81c37',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  '336597fbbc83e9370411119b4a2b0f3d3124889a7fe5a08a15e706ea188d2c5f:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x000000005f2c8d18ea06e7158aa0e57f9a8824313d0f2b4a9b11110437e983bcfb976533',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0xefff789561ce58884324454924e62c1567e70e835c657b54df9a636f95029722',
        index: '0x0',
      },
      blockNumber: '0xd81be4',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  'd11e507b66c2ae82b22d241587b4472801da9666186ae079fbfc0d9d367b9981:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000081997b369d0dfcfb79e06a186696da012847b48715242db282aec2667b501ed1',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0xf8168a6392c0691293ec803cd599b3fbc631cf18ad9102dd35c6225f110ba29f',
        index: '0x0',
      },
      blockNumber: '0xd81bb3',
      txIndex: '0x2',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  'a6e2990ec036b293f208db50da247e02f902a2ba22d6c5794b34478e7b04cb68:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000068cb047b8e47344b79c5d622baa202f9027e24da50db08f293b236c00e99e2a6',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0x1414ed5987b243661f6f911fab762b08d84146be46e2950d3f7e20f13df1f6f6',
        index: '0x0',
      },
      blockNumber: '0xd81bc0',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  'c3ba320ec1e942b035c13f2ae8846e182642cffdd37d960df6e1b8370a62f52d:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x000000002df5620a37b8e1f60d967dd3fdcf4226186e84e82a3fc135b042e9c10e32bac3',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0x21c7b033b9eb7eb4f4b28783a77447acc8a284b83dc99a353794175ee5c50de8',
        index: '0x0',
      },
      blockNumber: '0xd81c04',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  '94d14ced4ee4e83a4c32966de2e2f2f2bad542d6b9cccb963de106b86f20a7c8:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x00000000c8a7206fb806e13d96cbccb9d642d5baf2f2e2e26d96324c3ae8e44eed4cd194',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0xd223e96ee030c303c31d79710ea19c7347a04f4b44ca4551c3342ce119e86132',
        index: '0x0',
      },
      blockNumber: '0xd81c7f',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  'e48f46324d903a1c160ef72c0f239f62433ca3d24c0ccc9e63d29286df1a2088:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000088201adf8692d2639ecc0c4cd2a33c43629f230f2cf70e161c3a904d32468fe4',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0xec2df4da6b567c7be7f698e1895be815626c6b5e504930d1c5b1431792465784',
        index: '0x0',
      },
      blockNumber: '0xd81c4c',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  'a1babcf38126037040a389ecd19bf391e9474f827d0553e5d60b402c8f8514ec:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x00000000ec14858f2c400bd6e553057d824f47e991f39bd1ec89a34070032681f3bcbaa1',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0x1ba483627e1dc86c2054a9a7c3ff34df116b2446f1c3c8c0fc70e2f9daf63a1f',
        index: '0x0',
      },
      blockNumber: '0xd81c20',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  'a16e1f231219ea76a4a4929f2568db00d1011958d93fc470d0a3d959be345ac8:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x00000000c85a34be59d9a3d070c43fd9581901d100db68259f92a4a476ea1912231f6ea1',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0x27bf1271e34d3b89b8908302b1b52122cd4aabc9b05559c1f347ff1fdc943a12',
        index: '0x0',
      },
      blockNumber: '0xd81c66',
      txIndex: '0x4',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  '3a9dcdd63cc65980ff31d5c8228b21615d4f8ba0ad8686b8dae941acbac4890f:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x000000000f89c4baac41e9dab88686ada08b4f5d61218b22c8d531ff8059c63cd6cd9d3a',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0xcac45b975c8c52ca6199f39de541c0c069556fd54640f4b2838946344f42ce6d',
        index: '0x0',
      },
      blockNumber: '0xd81bba',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  '30c0b1f5a45b35f78398553e080c677c45b502852ccd329175e3979312adb5f3:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x00000000f3b5ad129397e3759132cd2c8502b5457c670c083e559883f7355ba4f5b1c030',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0x79f810935bf3ac47bc97c50c78527d71cacc9594ec148eeb294159f6ced0483b',
        index: '0x0',
      },
      blockNumber: '0xd81bed',
      txIndex: '0x2',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  '8733ca61d872e77d00cfe22bf7aca4042ea6578acf8e083ded3cc3219e9137c5:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x00000000c537919e21c33ced3d088ecf8a57a62e04a4acf72be2cf007de772d861ca3387',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0xe763055974a3c1c58a9a8c6f14cd5d0251f26fbfc4f1dd86319411e8794f8889',
        index: '0x0',
      },
      blockNumber: '0xd81c90',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  '1184235765f54076dddc67cbcfcff020ac684044f548c97b6c756047138e68e7:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x00000000e7688e134760756c7bc948f5444068ac20f0cfcfcb67dcdd7640f56557238411',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0x2f8b991d647b91c931eb32b224c5693991266ed10c89326795f5b71e22a57bea',
        index: '0x0',
      },
      blockNumber: '0xd81c23',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  '1ea31870ecf0510f24227da536c904940e8b7f586ee2de112b747f018795146e:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x000000006e149587017f742b11dee26e587f8b0e9404c936a57d22240f51f0ec7018a31e',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0x5d573c5fb16adaa17c42c7936fcfd7105818e4ef4bc613d4b6062698182500a6',
        index: '0x0',
      },
      blockNumber: '0xd81bf2',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  '69eea91d69b850abd92338fa4f0c9a11d0ed68f74bf5201cb7424dc49506af38:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0x00f43b843640fab7c9951a7931632e6ade6ef3337f89489b1c2b400793ece665',
        index: '0x0',
      },
      blockNumber: '0xd81e71',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0xa398426747fb052d0832a3296ad89b72253428b6caa19e8be14d4fcb0befeb2d',
        index: '0x0',
      },
      blockNumber: '0xd81e5d',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0xc657c0531c349e0602397f6369a462bbd3ec84efcd8876e1ccdc0e6f0201a8b0',
        index: '0x0',
      },
      blockNumber: '0xd81e59',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0xde2c71de17ebd73b1925805754b1fd2c2cd40b27d5de3edf23812b270439b162',
        index: '0x0',
      },
      blockNumber: '0xd81e56',
      txIndex: '0x3',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0xd2466255b2b05a229d3bb9c5f9f1b3def078283cdfd9cef1645ef1046c9047d5',
        index: '0x0',
      },
      blockNumber: '0xd81e51',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0xd64f32b7a5daf5c5fd7f0cf0ba76d9263383265fbc706b9043f344afd5fe00e8',
        index: '0x0',
      },
      blockNumber: '0xd81e4d',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0x16bb55a5c1fd0d6a7d7e7b60892da24c2a33c27041fbf8ada93aab691a311f9b',
        index: '0x0',
      },
      blockNumber: '0xd81e48',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0xede3544e671ac287ff67ddea7ce99e7d0afafac5f2889f4f8b1c6c1cd09dcbcc',
        index: '0x0',
      },
      blockNumber: '0xd81e44',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0x67cad749783b7d8595b7e5818c08eb380575c64badbd792443f36ae5888ceaff',
        index: '0x0',
      },
      blockNumber: '0xd81e41',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0xcaacf9b9b495e1c811598e86d904768162914b1aca7c3537cdd1af2cbe640303',
        index: '0x0',
      },
      blockNumber: '0xd81e3d',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0x85a5fa2ba570c35fd22e132b3f6a0ad03b8c151d0fd82abdbc8e4c3845615660',
        index: '0x0',
      },
      blockNumber: '0xd81e38',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0x62cb0ad5fdcfdfe819135f970604b0c7e7ba6761544d2db2f6e093e8dd50734f',
        index: '0x0',
      },
      blockNumber: '0xd81e2b',
      txIndex: '0x4',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0x965155d63fa8c9fb00cebb360753911efec9718b0db13f64d7dddd45edc53ab0',
        index: '0x0',
      },
      blockNumber: '0xd81e24',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0xea07337354751ba2068e9fb1f56c0b7cd5b4f8b96392387cf4d8c32b39092067',
        index: '0x0',
      },
      blockNumber: '0xd81e20',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0xcf8ca99732c62de85820c8670e4257a035dd1c96af440caaa3c60e1fb30a064d',
        index: '0x0',
      },
      blockNumber: '0xd81e19',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0x9b661830567bc2b2917d9295bccac8409472c181623091bb80cd15d242256d5a',
        index: '0x0',
      },
      blockNumber: '0xd81e13',
      txIndex: '0x4',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0x3c86f4acd287c73551e1ecba3787c139158d9756e5127a1540b979167beb37e3',
        index: '0x0',
      },
      blockNumber: '0xd81e0f',
      txIndex: '0x5',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0x700ac6b78787cfc2e446ecaef1e7885f05d8138c1b3211d1eed3df6b745e0047',
        index: '0x0',
      },
      blockNumber: '0xd81e0b',
      txIndex: '0x4',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0x2ed6aca14bdf96fa4174b345ae1840a1c31ac41be4fd4fafa4550b0b9bb94a04',
        index: '0x0',
      },
      blockNumber: '0xd81e02',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0x7dfaffb686d86face0c9ae1b7cbd938627ed7f34a7e020465f7bd2d0ca0aefa5',
        index: '0x0',
      },
      blockNumber: '0xd81dfe',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0xd25420447d02822f43dc7a15ffd9dd00ee3bfe72ef10227256c9878e327ea4c0',
        index: '0x0',
      },
      blockNumber: '0xd81dfb',
      txIndex: '0x4',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0x5f20ab1a846b0018e91b17d364d31684d1f69c0226e0b71c1b8dc87684411f8a',
        index: '0x0',
      },
      blockNumber: '0xd81df2',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0xbccd8a4febd86e65f2508d87b787c791144312c62524d7425b2736f383f20d15',
        index: '0x0',
      },
      blockNumber: '0xd81def',
      txIndex: '0x4',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0xa8aa116e9420c20d4513fad4f9c43e1b8578f77822345b67ad8553d7a4700b00',
        index: '0x0',
      },
      blockNumber: '0xd81deb',
      txIndex: '0x3',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0x8a2c1dbea8b03b80d27486b912a4466077e9774321580b96999a5c2b47e8a9c4',
        index: '0x0',
      },
      blockNumber: '0xd81de7',
      txIndex: '0x3',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0x1426d8ddd17d048900ab6649c8831ea0597020f8a3f391db33012faf3f426fad',
        index: '0x0',
      },
      blockNumber: '0xd81de4',
      txIndex: '0x2',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0x35b073cfad16bba683b74c0306c00f0a0620fd8e27db7151673dcdbd0857a750',
        index: '0x0',
      },
      blockNumber: '0xd81de0',
      txIndex: '0x2',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0xc33e4d35bb9d899f71cbbd2d0f9f8f19538fbd16afcef5b6843d4b5eddd743db',
        index: '0x0',
      },
      blockNumber: '0xd81ddd',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0x4976ed59d93bbedcfc1a2822c0d65774060fa8cb4c0b0d41bed13054c3ccf7fb',
        index: '0x0',
      },
      blockNumber: '0xd81dd9',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0xdaa57218ca7f632353ce3736ca0d46bbf80553d4b67843d73ac6037e8ddb7ff0',
        index: '0x0',
      },
      blockNumber: '0xd81dd5',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0x103f9e99efddbb86171c87cabcd1a53b5e09df7863c1b3d63bc6ce71361eaa5a',
        index: '0x0',
      },
      blockNumber: '0xd81dd2',
      txIndex: '0x2',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0x73068eb36a97ac7f35fd996761d4822a88afd3cf77252ab3b51966eadeb78491',
        index: '0x0',
      },
      blockNumber: '0xd81dc3',
      txIndex: '0x3',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0xec6d8bc79cd7e0d7353726a438aa9c4cffa4683363331549af30d2542704a556',
        index: '0x0',
      },
      blockNumber: '0xd81db8',
      txIndex: '0x2',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0x05398d634a13a662dcbd1504fff11bcc12e287a779b1f35051997ad33ec2aa9f',
        index: '0x0',
      },
      blockNumber: '0xd81db3',
      txIndex: '0x2',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0x2bc0dcb5bc6b2cc5ccd4022db998004de578242d6ceeff5303d81a16828ffed5',
        index: '0x0',
      },
      blockNumber: '0xd81daf',
      txIndex: '0x2',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0x1976c37d6709fc5d128c1a1b547a598fdce892b4bcb54591d9dccf5f3f2fbb08',
        index: '0x0',
      },
      blockNumber: '0xd81dac',
      txIndex: '0x3',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0xc3ea8f82ea187c4fcb0d69aee9f12cfd2cebd52e9fa4aae7c51f4dcbf4e22107',
        index: '0x0',
      },
      blockNumber: '0xd81d9b',
      txIndex: '0x2',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0xdb3f80f8e2e5f599e7a335f8da68791a87e94bb1042a20bbfef33f655aad0a21',
        index: '0x0',
      },
      blockNumber: '0xd81d97',
      txIndex: '0x2',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0x3bac25553adcd0ce92577f8fdeda52212388cbe307a3e6564cf1d5ae6dba4121',
        index: '0x0',
      },
      blockNumber: '0xd81d91',
      txIndex: '0x2',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0x3e7a84ff71358d30b6e4213cd5f5cf56bae03053a665bed68277a6fb5c852818',
        index: '0x0',
      },
      blockNumber: '0xd81d8c',
      txIndex: '0x3',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00e1f505000000000000000000000000',
      outPoint: {
        txHash: '0xb0ffef5e6998ddc86019de4d90a035c3aceb17fbfcaabb6a225dd27533e8673b',
        index: '0x0',
      },
      blockNumber: '0xd81d88',
      txIndex: '0x3',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  'a7bfa3545f53d31b0d57b1cef3e916388acffcb8f9920d93d21005e11a0bb409:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000009b40b1ae10510d2930d92f9b8fccf8a3816e9f3ceb1570d1bd3535f54a3bfa7',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0xbd629504d74fda29a8b9187dc55a4a675c791d25a501862446c4c1d8a1ede2de',
        index: '0x0',
      },
      blockNumber: '0xd81bdb',
      txIndex: '0x2',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  '9b31a06692b1f2ea7fc6cc6a3c5f4c9c5fb421d56e2d0e23900dd0ce94056a6c:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x000000006c6a0594ced00d90230e2d6ed521b45f9c4c5f3c6accc67feaf2b19266a0319b',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0xc26347679c6f9c321af89838cac070c3a87d4280ed0054fbdd46d94a20683a8e',
        index: '0x0',
      },
      blockNumber: '0xd81ba5',
      txIndex: '0x3',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  '5a7d4cd78a230e24cd203a8b2a43199f9fa5099f9ea2480fc183e147d9e0960c:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x000000000c96e0d947e183c10f48a29e9f09a59f9f19432a8b3a20cd240e238ad74c7d5a',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0xedd3f3dde6f4253f32b4a24f3c95d9824f546732f51e67447580d3a590b1468e',
        index: '0x0',
      },
      blockNumber: '0xd81c8b',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  '6ef4e8ff6b6d7e8599dc0bb27ee808baa575cc207a628e995f18414a8009ee10:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000010ee09804a41185f998e627a20cc75a5ba08e87eb20bdc99857e6d6bffe8f46e',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0xb65cf4b3f9705253dacc74a83589024e9f751ac3b2cef41d9dfe075b957c5477',
        index: '0x0',
      },
      blockNumber: '0xd81bdf',
      txIndex: '0x2',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  '8a81a8dc324d22499562e416a884e7bf9a55f5de7b28ee454ad3e76fa6597283:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x00000000837259a66fe7d34a45ee287bdef5559abfe784a816e4629549224d32dca8818a',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0x6fb324d629f69d1d011015325559bd1a3f58cd2bd0e2dce23b006ea85eade376',
        index: '0x0',
      },
      blockNumber: '0xd81bca',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  '9f8150acb2a1c31cb705b38982ff35bf822ba92a279a9b66af2268774969b495:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000095b46949776822af669b9a272aa92b82bf35ff8289b305b71cc3a1b2ac50819f',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0x9ffa6b826ed3ab1f5fa8f32ee743b4820682897b671dd96f4fea414e04ec3ecc',
        index: '0x0',
      },
      blockNumber: '0xd81c57',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  'ce808ec46872008364568e931b4fe484e0e8ea3c154770adb10f5c6b2b3ec286:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x0000000086c23e2b6b5c0fb1ad7047153ceae8e084e44f1b938e566483007268c48e80ce',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0xb5c70400545feef1c591c072b386e663805d984ecc90c9ebd282f39990a7cf17',
        index: '0x0',
      },
      blockNumber: '0xd81c63',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  '6dad378f3bd75864adedbcffe0760838e68e9ba7403d4f968f2c16916270bbf2:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x00000000f2bb706291162c8f964f3d40a79b8ee6380876e0ffbcedad6458d73b8f37ad6d',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0x3b0d7d2072c86a2b6f72a1290a70c48f451c1f290adc207e063f8ca3f3edd2b0',
        index: '0x0',
      },
      blockNumber: '0xd81bae',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  '2c5d749dc3451230f2497384c02dc0e07efc5743bce02faf47db4a191095c5d8:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x00000000d8c59510194adb47af2fe0bc4357fc7ee0c02dc0847349f2301245c39d745d2c',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0xdc0c3056e70b4fe64eda00cdc1fd6b2ae435871608b9fbb75efd13a3e78b496e',
        index: '0x0',
      },
      blockNumber: '0xd81c1b',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  '4418969debbb39c1ff3e82ba90375106ba471ffc66f87dd004ce216e3bd3d8a4:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x00000000a4d8d33b6e21ce04d07df866fc1f47ba06513790ba823effc139bbeb9d961844',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0xd30143cc94d6fdbb656db10a7635e936929febebc9e1424d163ab36a9041e9ba',
        index: '0x0',
      },
      blockNumber: '0xd81bab',
      txIndex: '0x2',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  '7f16485b8a8d9a1e142efb7dcd8b87a9f779a99468b26082a1b4258e1551ffb3:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x00000000b3ff51158e25b4a18260b26894a979f7a9878bcd7dfb2e141e9a8d8a5b48167f',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0xa4c06a0f9be53d5416f8fe34d7be1a5229a8a2515e3814b6b1ebf18ee11fd032',
        index: '0x0',
      },
      blockNumber: '0xd81bcf',
      txIndex: '0x2',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  '5c67a33f7685cdf656325aa7bad6631099a096189bd6db77ee954bd573b301db:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x00000000db01b373d54b95ee77dbd69b1896a0991063d6baa75a3256f6cd85763fa3675c',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0xd7d8aa87e70834cbf1d4cf95767381471bdfd16b2d9a916d0927b7b81c3d134f',
        index: '0x0',
      },
      blockNumber: '0xd81bf6',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  '3ac82fb4579a4c94d639b8fe2e9d320e587eabf47d9912ae389d2442f61b140d:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x000000000d141bf642249d38ae12997df4ab7e580e329d2efeb839d6944c9a57b42fc83a',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0xa01db6b79bd41ab7adf4b6f4e10b9a70e14489c109b218d3c6f24770eb5d3000',
        index: '0x0',
      },
      blockNumber: '0xd81bbd',
      txIndex: '0x3',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  '2e589957d60da868c01821af5f99c19738c9963f12828cee966404fbfd96ce0a:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x000000000ace96fdfb046496ee8c82123f96c93897c1995faf2118c068a80dd65799582e',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0x2ac48fd1b5db05851b756b6536f63f080598a8962ca365e20991b86ae547d456',
        index: '0x0',
      },
      blockNumber: '0xd81c40',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  'f6ce37f9d89597172566ae0b3e18edcb1c92011add8190e0b53b5caf9566aea1:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x00000000a1ae6695af5c3bb5e09081dd1a01921ccbed183e0bae6625179795d8f937cef6',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0x5860c0a6a834e0bb2dfbc8d5f4c1885cbbe3367285f5dfb7d464fa042031d17c',
        index: '0x0',
      },
      blockNumber: '0xd81c6d',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  'd295a78cc0e60895cf05b8ab142e8992d159307cc7347bff9d5f84da8ef8688f:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x000000008f68f88eda845f9dff7b34c77c3059d192892e14abb805cf9508e6c08ca795d2',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0x4fcac5d05e7cbfc7352ade62e44f78cca09450c419fb39b3af05f94f02a48210',
        index: '0x0',
      },
      blockNumber: '0xd81bea',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  'f1ee2c32debdbca6e0bdd654f3356501951e9fda7f288df62144583b38c5d6b6:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x00000000b6d6c5383b584421f68d287fda9f1e95016535f354d6bde0a6bcbdde322ceef1',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0xa75bca0eaa472a83b9a155d4c75dbc3c0e846b7a841fd143ac051c2c07e4aa38',
        index: '0x0',
      },
      blockNumber: '0xd81c87',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  '0cc6e2300bcf39d0eafa370ecd14c1191f93bd5255bd1efbeb55ecb1a9370f73:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x00000000730f37a9b1ec55ebfb1ebd5552bd931f19c114cd0e37faead039cf0b30e2c60c',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0x6cac3ce5884577e922afe944e9bf05887e7ab3c847310eb79e6f39cd716cc307',
        index: '0x0',
      },
      blockNumber: '0xd81c15',
      txIndex: '0x4',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  '7e0514d1ac12c4904af6aa3abbce83d10890f566bf4d886c596041fd7514f16a:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x000000006af11475fd4160596c884dbf66f59008d183cebb3aaaf64a90c412acd114057e',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0x30b3d64d1df36113707f0918d406c3d79482ecc8e22439121cebc458c8960fbe',
        index: '0x0',
      },
      blockNumber: '0xd81c0f',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  'fac32590b2203a17730f342c652e26c39107202d34e5596f6d4667e8cd694e0e:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x000000000e4e69cde867466d6f59e5342d200791c3262e652c340f73173a20b29025c3fa',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0x75143c1c6e64b01d45122bfa5db70cc5dbb90e945e1c7c781c73363b5e3fb4e0',
        index: '0x0',
      },
      blockNumber: '0xd81c53',
      txIndex: '0x1',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
  '3445ee96a6537fa97105aebd3e9331aeeebd1b9a7f08bec91bd76398c0a631a1:0': [
    {
      cellOutput: {
        capacity: '0x5e3ff5d00',
        lock: {
          codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
          args: '0x00000000a131a6c09863d71bc9be087f9a1bbdeeae31933ebdae0571a97f53a696ee4534',
          hashType: 'type',
        },
        type: {
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          hashType: 'type',
        },
      },
      data: '0x00ca9a3b000000000000000000000000',
      outPoint: {
        txHash: '0xbc2a834cbb5b40f5cb47bd3f328297ca851a0c0628be06b2d6a43423750ed0aa',
        index: '0x0',
      },
      blockNumber: '0xd81c5a',
      txIndex: '0x4',
      typeHash: '0xbc4163f2bf6cde6dfe3a6578ef129aedf034211149e5c7b28c1bcd82d9fa56cd',
    },
  ],
};

const rgbppCellsByLockHash: Record<Hash, IndexerCell[]> = {
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248012400000000000000caef271196136913859089aa47b6657c11cb2f812b9de573a305ef86fbaa16fd':
    [
      {
        blockNumber: '0xd81c6a',
        outPoint: {
          index: '0x0',
          txHash: '0x6adafca165f29c713d15da4e9415d610c02c1b8ce585cc4f5430aa5de3e0e239',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x00000000caef271196136913859089aa47b6657c11cb2f812b9de573a305ef86fbaa16fd',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x4',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c324801240000000000000010acdf3da8c98927a39ff61f96c5191f1c287afb09d3587756e6acf873a10710':
    [
      {
        blockNumber: '0xd81c75',
        outPoint: {
          index: '0x0',
          txHash: '0x122d92afd897e5cce4f17896468453bef911e8ee5a2141e8da4e91fa37863b7d',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000010acdf3da8c98927a39ff61f96c5191f1c287afb09d3587756e6acf873a10710',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x1',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c32480124000000000000005d59b1defbebfb7ae328be6400d118685e0df8d170052e3f2e1ddd3ec7faa9f6':
    [
      {
        blockNumber: '0xd81c45',
        outPoint: {
          index: '0x0',
          txHash: '0x2e2ef6a59efa324e51cdf48f769ed044701719a47de696197ab2d52b10b46f02',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x000000005d59b1defbebfb7ae328be6400d118685e0df8d170052e3f2e1ddd3ec7faa9f6',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x1',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c324801240000000000000005152dfd26ae6ceb1eabffaec1830912db78cc2ef0045039ce9edaf1042629b8':
    [
      {
        blockNumber: '0xd81bc3',
        outPoint: {
          index: '0x0',
          txHash: '0x3ee4107480a679cfdc296dc05c8d71b27a68215a9d3991494e0c13d60ae13792',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000005152dfd26ae6ceb1eabffaec1830912db78cc2ef0045039ce9edaf1042629b8',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x2',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248012400000000000000801b8178fcbdc1f568bd83bd790897d380e4711b31a3762216f76bd7c128ac14':
    [
      {
        blockNumber: '0xd81c3b',
        outPoint: {
          index: '0x0',
          txHash: '0xd1cfd6764c4aae04eebd0f9e5b69dccd2708194b1331b92adb88c3de5a96a9da',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x00000000801b8178fcbdc1f568bd83bd790897d380e4711b31a3762216f76bd7c128ac14',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x1',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c32480124000000000000008aa27fe3d1e03e006909f74424a3d125b5f5148fe4b08a882152e0c0ad58f5e7':
    [
      {
        blockNumber: '0xd81c2e',
        outPoint: {
          index: '0x0',
          txHash: '0x296b94918d48bf6a6a0c3ba8eb301472879060b6339d8ebb93fd59fcaa0fda62',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x000000008aa27fe3d1e03e006909f74424a3d125b5f5148fe4b08a882152e0c0ad58f5e7',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x4',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248012400000000000000bbdc2d61503e9eeee5a9cdd12fcbf3b184916454aa41ea5a4b8ac7e2cbc97c1b':
    [
      {
        blockNumber: '0xd81bc7',
        outPoint: {
          index: '0x0',
          txHash: '0xa368465ce2b6b717312755fea8d95eb475fdd66f019cd67050c0c383409c0667',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x00000000bbdc2d61503e9eeee5a9cdd12fcbf3b184916454aa41ea5a4b8ac7e2cbc97c1b',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x2',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248012400000000000000883a81775e930ff17a501557cadc43d0802d9ab559d7811c46c7ec26151cb18a':
    [
      {
        blockNumber: '0xd81b9f',
        outPoint: {
          index: '0x0',
          txHash: '0xd8fcef10d92024e220bc314a216b9f1decca2f05138d6592a280ad3bb5c0d922',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x00000000883a81775e930ff17a501557cadc43d0802d9ab559d7811c46c7ec26151cb18a',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x2',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248012400000000000000e46e8ee0f671a811315638e5ef0871687f05d90584054485c6258834dcf3e27b':
    [
      {
        blockNumber: '0xd81c5f',
        outPoint: {
          index: '0x0',
          txHash: '0xe7797d33ca22ebe3052b273307ccc4472ac57747dcb70d5249efea4957f04f73',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x00000000e46e8ee0f671a811315638e5ef0871687f05d90584054485c6258834dcf3e27b',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x1',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c32480124000000000000004234350dadc688b57ceab45632f0517d92f039a8af8e41de483ab2232ab615a4':
    [
      {
        blockNumber: '0xd81c0a',
        outPoint: {
          index: '0x0',
          txHash: '0x2e4d2051d9d5182aa2d9d8360d55a9629e964a8a1562485f928963f39932563d',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x000000004234350dadc688b57ceab45632f0517d92f039a8af8e41de483ab2232ab615a4',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x1',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248012400000000000000f3b5ad129397e3759132cd2c8502b5457c670c083e559883f7355ba4f5b1c030':
    [
      {
        blockNumber: '0xd81bed',
        outPoint: {
          index: '0x0',
          txHash: '0x79f810935bf3ac47bc97c50c78527d71cacc9594ec148eeb294159f6ced0483b',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x00000000f3b5ad129397e3759132cd2c8502b5457c670c083e559883f7355ba4f5b1c030',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x2',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248012400000000000000c85a34be59d9a3d070c43fd9581901d100db68259f92a4a476ea1912231f6ea1':
    [
      {
        blockNumber: '0xd81c66',
        outPoint: {
          index: '0x0',
          txHash: '0x27bf1271e34d3b89b8908302b1b52122cd4aabc9b05559c1f347ff1fdc943a12',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x00000000c85a34be59d9a3d070c43fd9581901d100db68259f92a4a476ea1912231f6ea1',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x4',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c324801240000000000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69':
    [
      {
        blockNumber: '0xd81d88',
        outPoint: {
          index: '0x0',
          txHash: '0xb0ffef5e6998ddc86019de4d90a035c3aceb17fbfcaabb6a225dd27533e8673b',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x3',
      },
      {
        blockNumber: '0xd81d8c',
        outPoint: {
          index: '0x0',
          txHash: '0x3e7a84ff71358d30b6e4213cd5f5cf56bae03053a665bed68277a6fb5c852818',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x3',
      },
      {
        blockNumber: '0xd81d91',
        outPoint: {
          index: '0x0',
          txHash: '0x3bac25553adcd0ce92577f8fdeda52212388cbe307a3e6564cf1d5ae6dba4121',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x2',
      },
      {
        blockNumber: '0xd81d97',
        outPoint: {
          index: '0x0',
          txHash: '0xdb3f80f8e2e5f599e7a335f8da68791a87e94bb1042a20bbfef33f655aad0a21',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x2',
      },
      {
        blockNumber: '0xd81d9b',
        outPoint: {
          index: '0x0',
          txHash: '0xc3ea8f82ea187c4fcb0d69aee9f12cfd2cebd52e9fa4aae7c51f4dcbf4e22107',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x2',
      },
      {
        blockNumber: '0xd81dac',
        outPoint: {
          index: '0x0',
          txHash: '0x1976c37d6709fc5d128c1a1b547a598fdce892b4bcb54591d9dccf5f3f2fbb08',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x3',
      },
      {
        blockNumber: '0xd81daf',
        outPoint: {
          index: '0x0',
          txHash: '0x2bc0dcb5bc6b2cc5ccd4022db998004de578242d6ceeff5303d81a16828ffed5',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x2',
      },
      {
        blockNumber: '0xd81db3',
        outPoint: {
          index: '0x0',
          txHash: '0x05398d634a13a662dcbd1504fff11bcc12e287a779b1f35051997ad33ec2aa9f',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x2',
      },
      {
        blockNumber: '0xd81db8',
        outPoint: {
          index: '0x0',
          txHash: '0xec6d8bc79cd7e0d7353726a438aa9c4cffa4683363331549af30d2542704a556',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x2',
      },
      {
        blockNumber: '0xd81dc3',
        outPoint: {
          index: '0x0',
          txHash: '0x73068eb36a97ac7f35fd996761d4822a88afd3cf77252ab3b51966eadeb78491',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x3',
      },
      {
        blockNumber: '0xd81dd2',
        outPoint: {
          index: '0x0',
          txHash: '0x103f9e99efddbb86171c87cabcd1a53b5e09df7863c1b3d63bc6ce71361eaa5a',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x2',
      },
      {
        blockNumber: '0xd81dd5',
        outPoint: {
          index: '0x0',
          txHash: '0xdaa57218ca7f632353ce3736ca0d46bbf80553d4b67843d73ac6037e8ddb7ff0',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x1',
      },
      {
        blockNumber: '0xd81dd9',
        outPoint: {
          index: '0x0',
          txHash: '0x4976ed59d93bbedcfc1a2822c0d65774060fa8cb4c0b0d41bed13054c3ccf7fb',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x1',
      },
      {
        blockNumber: '0xd81ddd',
        outPoint: {
          index: '0x0',
          txHash: '0xc33e4d35bb9d899f71cbbd2d0f9f8f19538fbd16afcef5b6843d4b5eddd743db',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x1',
      },
      {
        blockNumber: '0xd81de0',
        outPoint: {
          index: '0x0',
          txHash: '0x35b073cfad16bba683b74c0306c00f0a0620fd8e27db7151673dcdbd0857a750',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x2',
      },
      {
        blockNumber: '0xd81de4',
        outPoint: {
          index: '0x0',
          txHash: '0x1426d8ddd17d048900ab6649c8831ea0597020f8a3f391db33012faf3f426fad',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x2',
      },
      {
        blockNumber: '0xd81de7',
        outPoint: {
          index: '0x0',
          txHash: '0x8a2c1dbea8b03b80d27486b912a4466077e9774321580b96999a5c2b47e8a9c4',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x3',
      },
      {
        blockNumber: '0xd81deb',
        outPoint: {
          index: '0x0',
          txHash: '0xa8aa116e9420c20d4513fad4f9c43e1b8578f77822345b67ad8553d7a4700b00',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x3',
      },
      {
        blockNumber: '0xd81def',
        outPoint: {
          index: '0x0',
          txHash: '0xbccd8a4febd86e65f2508d87b787c791144312c62524d7425b2736f383f20d15',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x4',
      },
      {
        blockNumber: '0xd81df2',
        outPoint: {
          index: '0x0',
          txHash: '0x5f20ab1a846b0018e91b17d364d31684d1f69c0226e0b71c1b8dc87684411f8a',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x1',
      },
      {
        blockNumber: '0xd81dfb',
        outPoint: {
          index: '0x0',
          txHash: '0xd25420447d02822f43dc7a15ffd9dd00ee3bfe72ef10227256c9878e327ea4c0',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x4',
      },
      {
        blockNumber: '0xd81dfe',
        outPoint: {
          index: '0x0',
          txHash: '0x7dfaffb686d86face0c9ae1b7cbd938627ed7f34a7e020465f7bd2d0ca0aefa5',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x1',
      },
      {
        blockNumber: '0xd81e02',
        outPoint: {
          index: '0x0',
          txHash: '0x2ed6aca14bdf96fa4174b345ae1840a1c31ac41be4fd4fafa4550b0b9bb94a04',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x1',
      },
      {
        blockNumber: '0xd81e0b',
        outPoint: {
          index: '0x0',
          txHash: '0x700ac6b78787cfc2e446ecaef1e7885f05d8138c1b3211d1eed3df6b745e0047',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x4',
      },
      {
        blockNumber: '0xd81e0f',
        outPoint: {
          index: '0x0',
          txHash: '0x3c86f4acd287c73551e1ecba3787c139158d9756e5127a1540b979167beb37e3',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x5',
      },
      {
        blockNumber: '0xd81e13',
        outPoint: {
          index: '0x0',
          txHash: '0x9b661830567bc2b2917d9295bccac8409472c181623091bb80cd15d242256d5a',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x4',
      },
      {
        blockNumber: '0xd81e19',
        outPoint: {
          index: '0x0',
          txHash: '0xcf8ca99732c62de85820c8670e4257a035dd1c96af440caaa3c60e1fb30a064d',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x1',
      },
      {
        blockNumber: '0xd81e20',
        outPoint: {
          index: '0x0',
          txHash: '0xea07337354751ba2068e9fb1f56c0b7cd5b4f8b96392387cf4d8c32b39092067',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x1',
      },
      {
        blockNumber: '0xd81e24',
        outPoint: {
          index: '0x0',
          txHash: '0x965155d63fa8c9fb00cebb360753911efec9718b0db13f64d7dddd45edc53ab0',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x1',
      },
      {
        blockNumber: '0xd81e2b',
        outPoint: {
          index: '0x0',
          txHash: '0x62cb0ad5fdcfdfe819135f970604b0c7e7ba6761544d2db2f6e093e8dd50734f',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x4',
      },
      {
        blockNumber: '0xd81e38',
        outPoint: {
          index: '0x0',
          txHash: '0x85a5fa2ba570c35fd22e132b3f6a0ad03b8c151d0fd82abdbc8e4c3845615660',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x1',
      },
      {
        blockNumber: '0xd81e3d',
        outPoint: {
          index: '0x0',
          txHash: '0xcaacf9b9b495e1c811598e86d904768162914b1aca7c3537cdd1af2cbe640303',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x1',
      },
      {
        blockNumber: '0xd81e41',
        outPoint: {
          index: '0x0',
          txHash: '0x67cad749783b7d8595b7e5818c08eb380575c64badbd792443f36ae5888ceaff',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x1',
      },
      {
        blockNumber: '0xd81e44',
        outPoint: {
          index: '0x0',
          txHash: '0xede3544e671ac287ff67ddea7ce99e7d0afafac5f2889f4f8b1c6c1cd09dcbcc',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x1',
      },
      {
        blockNumber: '0xd81e48',
        outPoint: {
          index: '0x0',
          txHash: '0x16bb55a5c1fd0d6a7d7e7b60892da24c2a33c27041fbf8ada93aab691a311f9b',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x1',
      },
      {
        blockNumber: '0xd81e4d',
        outPoint: {
          index: '0x0',
          txHash: '0xd64f32b7a5daf5c5fd7f0cf0ba76d9263383265fbc706b9043f344afd5fe00e8',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x1',
      },
      {
        blockNumber: '0xd81e51',
        outPoint: {
          index: '0x0',
          txHash: '0xd2466255b2b05a229d3bb9c5f9f1b3def078283cdfd9cef1645ef1046c9047d5',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x1',
      },
      {
        blockNumber: '0xd81e56',
        outPoint: {
          index: '0x0',
          txHash: '0xde2c71de17ebd73b1925805754b1fd2c2cd40b27d5de3edf23812b270439b162',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x3',
      },
      {
        blockNumber: '0xd81e59',
        outPoint: {
          index: '0x0',
          txHash: '0xc657c0531c349e0602397f6369a462bbd3ec84efcd8876e1ccdc0e6f0201a8b0',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x1',
      },
      {
        blockNumber: '0xd81e5d',
        outPoint: {
          index: '0x0',
          txHash: '0xa398426747fb052d0832a3296ad89b72253428b6caa19e8be14d4fcb0befeb2d',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x1',
      },
      {
        blockNumber: '0xd81e71',
        outPoint: {
          index: '0x0',
          txHash: '0x00f43b843640fab7c9951a7931632e6ade6ef3337f89489b1c2b400793ece665',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000038af0695c44d42b71c20f54bf768edd0119a0c4ffa3823d9ab50b8691da9ee69',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00e1f505000000000000000000000000',
        txIndex: '0x1',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c32480124000000000000006e149587017f742b11dee26e587f8b0e9404c936a57d22240f51f0ec7018a31e':
    [
      {
        blockNumber: '0xd81bf2',
        outPoint: {
          index: '0x0',
          txHash: '0x5d573c5fb16adaa17c42c7936fcfd7105818e4ef4bc613d4b6062698182500a6',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x000000006e149587017f742b11dee26e587f8b0e9404c936a57d22240f51f0ec7018a31e',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x1',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248012400000000000000061d6d03d7490283a11fafc70a81125436da7f36d5f5f99f78e3c3f16327ec7d':
    [
      {
        blockNumber: '0xd81bfc',
        outPoint: {
          index: '0x0',
          txHash: '0x6204bf05f0b76e0f57eeda3e34773d0b75b9c8fbc4dec329b5a5e09b6fa418ee',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x00000000061d6d03d7490283a11fafc70a81125436da7f36d5f5f99f78e3c3f16327ec7d',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x1',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248012400000000000000b82442332359c4e4b84118836d76bbc04d7cf91cabdafb7662dcd00d0faa55f5':
    [
      {
        blockNumber: '0xd81c72',
        outPoint: {
          index: '0x0',
          txHash: '0xad5be28bad16f4792cc0dc9375b96b74721aafa0383a978ec24ad2ced05cfd16',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x00000000b82442332359c4e4b84118836d76bbc04d7cf91cabdafb7662dcd00d0faa55f5',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x4',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c32480124000000000000000dc84729396763b0d317475c7f6d7dac11a3f273115223002b225439d494165c':
    [
      {
        blockNumber: '0xd81c07',
        outPoint: {
          index: '0x0',
          txHash: '0x715a0ad3a91a8e88ae31998aa667e02c973da57f1a287e21dbe4dfcf9f133b65',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x000000000dc84729396763b0d317475c7f6d7dac11a3f273115223002b225439d494165c',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x2',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248012400000000000000876ee5ba6bf8491914b51f92aa5d860ed517e31e4572ae3191e19721bf075ec0':
    [
      {
        blockNumber: '0xd81bff',
        outPoint: {
          index: '0x0',
          txHash: '0x83c92b4592a287cfa76b15c1d0dec0abd7f487b201a1720f3004d1d742a5e581',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x00000000876ee5ba6bf8491914b51f92aa5d860ed517e31e4572ae3191e19721bf075ec0',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x2',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248012400000000000000c537919e21c33ced3d088ecf8a57a62e04a4acf72be2cf007de772d861ca3387':
    [
      {
        blockNumber: '0xd81c90',
        outPoint: {
          index: '0x0',
          txHash: '0xe763055974a3c1c58a9a8c6f14cd5d0251f26fbfc4f1dd86319411e8794f8889',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x00000000c537919e21c33ced3d088ecf8a57a62e04a4acf72be2cf007de772d861ca3387',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x1',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248012400000000000000fbdb03d6c7ea5a83976ed848928f6bfd36b0e31cd289efc41cc99d91bc15dff7':
    [
      {
        blockNumber: '0xd81c29',
        outPoint: {
          index: '0x0',
          txHash: '0xe0732a33f99598399e0d1bdeaa6ee96b9f0fca39651626a30b0bafa883a12419',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x00000000fbdb03d6c7ea5a83976ed848928f6bfd36b0e31cd289efc41cc99d91bc15dff7',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x1',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c324801240000000000000081997b369d0dfcfb79e06a186696da012847b48715242db282aec2667b501ed1':
    [
      {
        blockNumber: '0xd81bb3',
        outPoint: {
          index: '0x0',
          txHash: '0xf8168a6392c0691293ec803cd599b3fbc631cf18ad9102dd35c6225f110ba29f',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000081997b369d0dfcfb79e06a186696da012847b48715242db282aec2667b501ed1',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x2',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c32480124000000000000005f2c8d18ea06e7158aa0e57f9a8824313d0f2b4a9b11110437e983bcfb976533':
    [
      {
        blockNumber: '0xd81be4',
        outPoint: {
          index: '0x0',
          txHash: '0xefff789561ce58884324454924e62c1567e70e835c657b54df9a636f95029722',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x000000005f2c8d18ea06e7158aa0e57f9a8824313d0f2b4a9b11110437e983bcfb976533',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x1',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c32480124000000000000002df5620a37b8e1f60d967dd3fdcf4226186e84e82a3fc135b042e9c10e32bac3':
    [
      {
        blockNumber: '0xd81c04',
        outPoint: {
          index: '0x0',
          txHash: '0x21c7b033b9eb7eb4f4b28783a77447acc8a284b83dc99a353794175ee5c50de8',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x000000002df5620a37b8e1f60d967dd3fdcf4226186e84e82a3fc135b042e9c10e32bac3',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x1',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c324801240000000000000068cb047b8e47344b79c5d622baa202f9027e24da50db08f293b236c00e99e2a6':
    [
      {
        blockNumber: '0xd81bc0',
        outPoint: {
          index: '0x0',
          txHash: '0x1414ed5987b243661f6f911fab762b08d84146be46e2950d3f7e20f13df1f6f6',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000068cb047b8e47344b79c5d622baa202f9027e24da50db08f293b236c00e99e2a6',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x1',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c32480124000000000000007b0a60701fa51c38544f7937646c2f796f746461e03ea189e698823d7bb9b3df':
    [
      {
        blockNumber: '0xd81c37',
        outPoint: {
          index: '0x0',
          txHash: '0x418de4600629116373b24becdcab626f19d113a6093a75a5cef54a695714a20a',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x000000007b0a60701fa51c38544f7937646c2f796f746461e03ea189e698823d7bb9b3df',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x1',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248012400000000000000c8a7206fb806e13d96cbccb9d642d5baf2f2e2e26d96324c3ae8e44eed4cd194':
    [
      {
        blockNumber: '0xd81c7f',
        outPoint: {
          index: '0x0',
          txHash: '0xd223e96ee030c303c31d79710ea19c7347a04f4b44ca4551c3342ce119e86132',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x00000000c8a7206fb806e13d96cbccb9d642d5baf2f2e2e26d96324c3ae8e44eed4cd194',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x1',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c324801240000000000000088201adf8692d2639ecc0c4cd2a33c43629f230f2cf70e161c3a904d32468fe4':
    [
      {
        blockNumber: '0xd81c4c',
        outPoint: {
          index: '0x0',
          txHash: '0xec2df4da6b567c7be7f698e1895be815626c6b5e504930d1c5b1431792465784',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000088201adf8692d2639ecc0c4cd2a33c43629f230f2cf70e161c3a904d32468fe4',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x1',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c32480124000000000000000f89c4baac41e9dab88686ada08b4f5d61218b22c8d531ff8059c63cd6cd9d3a':
    [
      {
        blockNumber: '0xd81bba',
        outPoint: {
          index: '0x0',
          txHash: '0xcac45b975c8c52ca6199f39de541c0c069556fd54640f4b2838946344f42ce6d',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x000000000f89c4baac41e9dab88686ada08b4f5d61218b22c8d531ff8059c63cd6cd9d3a',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x1',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248012400000000000000e7688e134760756c7bc948f5444068ac20f0cfcfcb67dcdd7640f56557238411':
    [
      {
        blockNumber: '0xd81c23',
        outPoint: {
          index: '0x0',
          txHash: '0x2f8b991d647b91c931eb32b224c5693991266ed10c89326795f5b71e22a57bea',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x00000000e7688e134760756c7bc948f5444068ac20f0cfcfcb67dcdd7640f56557238411',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x1',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248012400000000000000ec14858f2c400bd6e553057d824f47e991f39bd1ec89a34070032681f3bcbaa1':
    [
      {
        blockNumber: '0xd81c20',
        outPoint: {
          index: '0x0',
          txHash: '0x1ba483627e1dc86c2054a9a7c3ff34df116b2446f1c3c8c0fc70e2f9daf63a1f',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x00000000ec14858f2c400bd6e553057d824f47e991f39bd1ec89a34070032681f3bcbaa1',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x1',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c324801240000000000000010ee09804a41185f998e627a20cc75a5ba08e87eb20bdc99857e6d6bffe8f46e':
    [
      {
        blockNumber: '0xd81bdf',
        outPoint: {
          index: '0x0',
          txHash: '0xb65cf4b3f9705253dacc74a83589024e9f751ac3b2cef41d9dfe075b957c5477',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000010ee09804a41185f998e627a20cc75a5ba08e87eb20bdc99857e6d6bffe8f46e',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x2',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c324801240000000000000095b46949776822af669b9a272aa92b82bf35ff8289b305b71cc3a1b2ac50819f':
    [
      {
        blockNumber: '0xd81c57',
        outPoint: {
          index: '0x0',
          txHash: '0x9ffa6b826ed3ab1f5fa8f32ee743b4820682897b671dd96f4fea414e04ec3ecc',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000095b46949776822af669b9a272aa92b82bf35ff8289b305b71cc3a1b2ac50819f',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x1',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c324801240000000000000009b40b1ae10510d2930d92f9b8fccf8a3816e9f3ceb1570d1bd3535f54a3bfa7':
    [
      {
        blockNumber: '0xd81bdb',
        outPoint: {
          index: '0x0',
          txHash: '0xbd629504d74fda29a8b9187dc55a4a675c791d25a501862446c4c1d8a1ede2de',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000009b40b1ae10510d2930d92f9b8fccf8a3816e9f3ceb1570d1bd3535f54a3bfa7',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x2',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c32480124000000000000006c6a0594ced00d90230e2d6ed521b45f9c4c5f3c6accc67feaf2b19266a0319b':
    [
      {
        blockNumber: '0xd81ba5',
        outPoint: {
          index: '0x0',
          txHash: '0xc26347679c6f9c321af89838cac070c3a87d4280ed0054fbdd46d94a20683a8e',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x000000006c6a0594ced00d90230e2d6ed521b45f9c4c5f3c6accc67feaf2b19266a0319b',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x3',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c32480124000000000000000c96e0d947e183c10f48a29e9f09a59f9f19432a8b3a20cd240e238ad74c7d5a':
    [
      {
        blockNumber: '0xd81c8b',
        outPoint: {
          index: '0x0',
          txHash: '0xedd3f3dde6f4253f32b4a24f3c95d9824f546732f51e67447580d3a590b1468e',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x000000000c96e0d947e183c10f48a29e9f09a59f9f19432a8b3a20cd240e238ad74c7d5a',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x1',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c32480124000000000000006af11475fd4160596c884dbf66f59008d183cebb3aaaf64a90c412acd114057e':
    [
      {
        blockNumber: '0xd81c0f',
        outPoint: {
          index: '0x0',
          txHash: '0x30b3d64d1df36113707f0918d406c3d79482ecc8e22439121cebc458c8960fbe',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x000000006af11475fd4160596c884dbf66f59008d183cebb3aaaf64a90c412acd114057e',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x1',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248012400000000000000730f37a9b1ec55ebfb1ebd5552bd931f19c114cd0e37faead039cf0b30e2c60c':
    [
      {
        blockNumber: '0xd81c15',
        outPoint: {
          index: '0x0',
          txHash: '0x6cac3ce5884577e922afe944e9bf05887e7ab3c847310eb79e6f39cd716cc307',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x00000000730f37a9b1ec55ebfb1ebd5552bd931f19c114cd0e37faead039cf0b30e2c60c',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x4',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248012400000000000000a131a6c09863d71bc9be087f9a1bbdeeae31933ebdae0571a97f53a696ee4534':
    [
      {
        blockNumber: '0xd81c5a',
        outPoint: {
          index: '0x0',
          txHash: '0xbc2a834cbb5b40f5cb47bd3f328297ca851a0c0628be06b2d6a43423750ed0aa',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x00000000a131a6c09863d71bc9be087f9a1bbdeeae31933ebdae0571a97f53a696ee4534',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x4',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c32480124000000000000000e4e69cde867466d6f59e5342d200791c3262e652c340f73173a20b29025c3fa':
    [
      {
        blockNumber: '0xd81c53',
        outPoint: {
          index: '0x0',
          txHash: '0x75143c1c6e64b01d45122bfa5db70cc5dbb90e945e1c7c781c73363b5e3fb4e0',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x000000000e4e69cde867466d6f59e5342d200791c3262e652c340f73173a20b29025c3fa',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x1',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248012400000000000000837259a66fe7d34a45ee287bdef5559abfe784a816e4629549224d32dca8818a':
    [
      {
        blockNumber: '0xd81bca',
        outPoint: {
          index: '0x0',
          txHash: '0x6fb324d629f69d1d011015325559bd1a3f58cd2bd0e2dce23b006ea85eade376',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x00000000837259a66fe7d34a45ee287bdef5559abfe784a816e4629549224d32dca8818a',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x1',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c324801240000000000000086c23e2b6b5c0fb1ad7047153ceae8e084e44f1b938e566483007268c48e80ce':
    [
      {
        blockNumber: '0xd81c63',
        outPoint: {
          index: '0x0',
          txHash: '0xb5c70400545feef1c591c072b386e663805d984ecc90c9ebd282f39990a7cf17',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x0000000086c23e2b6b5c0fb1ad7047153ceae8e084e44f1b938e566483007268c48e80ce',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x1',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248012400000000000000d8c59510194adb47af2fe0bc4357fc7ee0c02dc0847349f2301245c39d745d2c':
    [
      {
        blockNumber: '0xd81c1b',
        outPoint: {
          index: '0x0',
          txHash: '0xdc0c3056e70b4fe64eda00cdc1fd6b2ae435871608b9fbb75efd13a3e78b496e',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x00000000d8c59510194adb47af2fe0bc4357fc7ee0c02dc0847349f2301245c39d745d2c',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x1',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248012400000000000000a4d8d33b6e21ce04d07df866fc1f47ba06513790ba823effc139bbeb9d961844':
    [
      {
        blockNumber: '0xd81bab',
        outPoint: {
          index: '0x0',
          txHash: '0xd30143cc94d6fdbb656db10a7635e936929febebc9e1424d163ab36a9041e9ba',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x00000000a4d8d33b6e21ce04d07df866fc1f47ba06513790ba823effc139bbeb9d961844',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x2',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248012400000000000000f2bb706291162c8f964f3d40a79b8ee6380876e0ffbcedad6458d73b8f37ad6d':
    [
      {
        blockNumber: '0xd81bae',
        outPoint: {
          index: '0x0',
          txHash: '0x3b0d7d2072c86a2b6f72a1290a70c48f451c1f290adc207e063f8ca3f3edd2b0',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x00000000f2bb706291162c8f964f3d40a79b8ee6380876e0ffbcedad6458d73b8f37ad6d',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x1',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248012400000000000000db01b373d54b95ee77dbd69b1896a0991063d6baa75a3256f6cd85763fa3675c':
    [
      {
        blockNumber: '0xd81bf6',
        outPoint: {
          index: '0x0',
          txHash: '0xd7d8aa87e70834cbf1d4cf95767381471bdfd16b2d9a916d0927b7b81c3d134f',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x00000000db01b373d54b95ee77dbd69b1896a0991063d6baa75a3256f6cd85763fa3675c',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x1',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248012400000000000000b3ff51158e25b4a18260b26894a979f7a9878bcd7dfb2e141e9a8d8a5b48167f':
    [
      {
        blockNumber: '0xd81bcf',
        outPoint: {
          index: '0x0',
          txHash: '0xa4c06a0f9be53d5416f8fe34d7be1a5229a8a2515e3814b6b1ebf18ee11fd032',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x00000000b3ff51158e25b4a18260b26894a979f7a9878bcd7dfb2e141e9a8d8a5b48167f',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x2',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c32480124000000000000000ace96fdfb046496ee8c82123f96c93897c1995faf2118c068a80dd65799582e':
    [
      {
        blockNumber: '0xd81c40',
        outPoint: {
          index: '0x0',
          txHash: '0x2ac48fd1b5db05851b756b6536f63f080598a8962ca365e20991b86ae547d456',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x000000000ace96fdfb046496ee8c82123f96c93897c1995faf2118c068a80dd65799582e',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x1',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c32480124000000000000000d141bf642249d38ae12997df4ab7e580e329d2efeb839d6944c9a57b42fc83a':
    [
      {
        blockNumber: '0xd81bbd',
        outPoint: {
          index: '0x0',
          txHash: '0xa01db6b79bd41ab7adf4b6f4e10b9a70e14489c109b218d3c6f24770eb5d3000',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x000000000d141bf642249d38ae12997df4ab7e580e329d2efeb839d6944c9a57b42fc83a',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x3',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c32480124000000000000008f68f88eda845f9dff7b34c77c3059d192892e14abb805cf9508e6c08ca795d2':
    [
      {
        blockNumber: '0xd81bea',
        outPoint: {
          index: '0x0',
          txHash: '0x4fcac5d05e7cbfc7352ade62e44f78cca09450c419fb39b3af05f94f02a48210',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x000000008f68f88eda845f9dff7b34c77c3059d192892e14abb805cf9508e6c08ca795d2',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x1',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248012400000000000000b6d6c5383b584421f68d287fda9f1e95016535f354d6bde0a6bcbdde322ceef1':
    [
      {
        blockNumber: '0xd81c87',
        outPoint: {
          index: '0x0',
          txHash: '0xa75bca0eaa472a83b9a155d4c75dbc3c0e846b7a841fd143ac051c2c07e4aa38',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x00000000b6d6c5383b584421f68d287fda9f1e95016535f354d6bde0a6bcbdde322ceef1',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x1',
      },
    ],
  '0x5900000010000000300000003100000061ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248012400000000000000a1ae6695af5c3bb5e09081dd1a01921ccbed183e0bae6625179795d8f937cef6':
    [
      {
        blockNumber: '0xd81c6d',
        outPoint: {
          index: '0x0',
          txHash: '0x5860c0a6a834e0bb2dfbc8d5f4c1885cbbe3367285f5dfb7d464fa042031d17c',
        },
        output: {
          capacity: '0x5e3ff5d00',
          lock: {
            args: '0x00000000a1ae6695af5c3bb5e09081dd1a01921ccbed183e0bae6625179795d8f937cef6',
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
          },
          type: {
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
          },
        },
        outputData: '0x00ca9a3b000000000000000000000000',
        txIndex: '0x1',
      },
    ],
};

const liveCellsByOutPoints: { outPoints: OutPoint[]; liveCells: LiveCell[] }[] = [
  {
    outPoints: [
      { txHash: '0x3ee4107480a679cfdc296dc05c8d71b27a68215a9d3991494e0c13d60ae13792', index: '0x0' },
      { txHash: '0x6204bf05f0b76e0f57eeda3e34773d0b75b9c8fbc4dec329b5a5e09b6fa418ee', index: '0x0' },
      { txHash: '0xbd629504d74fda29a8b9187dc55a4a675c791d25a501862446c4c1d8a1ede2de', index: '0x0' },
      { txHash: '0xedd3f3dde6f4253f32b4a24f3c95d9824f546732f51e67447580d3a590b1468e', index: '0x0' },
      { txHash: '0x715a0ad3a91a8e88ae31998aa667e02c973da57f1a287e21dbe4dfcf9f133b65', index: '0x0' },
      { txHash: '0x75143c1c6e64b01d45122bfa5db70cc5dbb90e945e1c7c781c73363b5e3fb4e0', index: '0x0' },
      { txHash: '0xcac45b975c8c52ca6199f39de541c0c069556fd54640f4b2838946344f42ce6d', index: '0x0' },
      { txHash: '0x122d92afd897e5cce4f17896468453bef911e8ee5a2141e8da4e91fa37863b7d', index: '0x0' },
      { txHash: '0xb65cf4b3f9705253dacc74a83589024e9f751ac3b2cef41d9dfe075b957c5477', index: '0x0' },
      { txHash: '0x21c7b033b9eb7eb4f4b28783a77447acc8a284b83dc99a353794175ee5c50de8', index: '0x0' },
      { txHash: '0x2e4d2051d9d5182aa2d9d8360d55a9629e964a8a1562485f928963f39932563d', index: '0x0' },
      { txHash: '0x2e2ef6a59efa324e51cdf48f769ed044701719a47de696197ab2d52b10b46f02', index: '0x0' },
      { txHash: '0xefff789561ce58884324454924e62c1567e70e835c657b54df9a636f95029722', index: '0x0' },
      { txHash: '0x1414ed5987b243661f6f911fab762b08d84146be46e2950d3f7e20f13df1f6f6', index: '0x0' },
      { txHash: '0x30b3d64d1df36113707f0918d406c3d79482ecc8e22439121cebc458c8960fbe', index: '0x0' },
      { txHash: '0xc26347679c6f9c321af89838cac070c3a87d4280ed0054fbdd46d94a20683a8e', index: '0x0' },
      { txHash: '0x5d573c5fb16adaa17c42c7936fcfd7105818e4ef4bc613d4b6062698182500a6', index: '0x0' },
      { txHash: '0x6cac3ce5884577e922afe944e9bf05887e7ab3c847310eb79e6f39cd716cc307', index: '0x0' },
      { txHash: '0x418de4600629116373b24becdcab626f19d113a6093a75a5cef54a695714a20a', index: '0x0' },
      { txHash: '0xd1cfd6764c4aae04eebd0f9e5b69dccd2708194b1331b92adb88c3de5a96a9da', index: '0x0' },
      { txHash: '0xf8168a6392c0691293ec803cd599b3fbc631cf18ad9102dd35c6225f110ba29f', index: '0x0' },
      { txHash: '0x6fb324d629f69d1d011015325559bd1a3f58cd2bd0e2dce23b006ea85eade376', index: '0x0' },
      { txHash: '0xb5c70400545feef1c591c072b386e663805d984ecc90c9ebd282f39990a7cf17', index: '0x0' },
      { txHash: '0x83c92b4592a287cfa76b15c1d0dec0abd7f487b201a1720f3004d1d742a5e581', index: '0x0' },
      { txHash: '0xec2df4da6b567c7be7f698e1895be815626c6b5e504930d1c5b1431792465784', index: '0x0' },
      { txHash: '0xd8fcef10d92024e220bc314a216b9f1decca2f05138d6592a280ad3bb5c0d922', index: '0x0' },
      { txHash: '0x296b94918d48bf6a6a0c3ba8eb301472879060b6339d8ebb93fd59fcaa0fda62', index: '0x0' },
      { txHash: '0x9ffa6b826ed3ab1f5fa8f32ee743b4820682897b671dd96f4fea414e04ec3ecc', index: '0x0' },
      { txHash: '0xbc2a834cbb5b40f5cb47bd3f328297ca851a0c0628be06b2d6a43423750ed0aa', index: '0x0' },
      { txHash: '0xad5be28bad16f4792cc0dc9375b96b74721aafa0383a978ec24ad2ced05cfd16', index: '0x0' },
      { txHash: '0xa368465ce2b6b717312755fea8d95eb475fdd66f019cd67050c0c383409c0667', index: '0x0' },
      { txHash: '0xe763055974a3c1c58a9a8c6f14cd5d0251f26fbfc4f1dd86319411e8794f8889', index: '0x0' },
      { txHash: '0x27bf1271e34d3b89b8908302b1b52122cd4aabc9b05559c1f347ff1fdc943a12', index: '0x0' },
      { txHash: '0xd223e96ee030c303c31d79710ea19c7347a04f4b44ca4551c3342ce119e86132', index: '0x0' },
      { txHash: '0x6adafca165f29c713d15da4e9415d610c02c1b8ce585cc4f5430aa5de3e0e239', index: '0x0' },
      { txHash: '0xe7797d33ca22ebe3052b273307ccc4472ac57747dcb70d5249efea4957f04f73', index: '0x0' },
      { txHash: '0x2f8b991d647b91c931eb32b224c5693991266ed10c89326795f5b71e22a57bea', index: '0x0' },
      { txHash: '0x1ba483627e1dc86c2054a9a7c3ff34df116b2446f1c3c8c0fc70e2f9daf63a1f', index: '0x0' },
      { txHash: '0x79f810935bf3ac47bc97c50c78527d71cacc9594ec148eeb294159f6ced0483b', index: '0x0' },
      { txHash: '0xe0732a33f99598399e0d1bdeaa6ee96b9f0fca39651626a30b0bafa883a12419', index: '0x0' },
    ],
    liveCells: [
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x0000000005152dfd26ae6ceb1eabffaec1830912db78cc2ef0045039ce9edaf1042629b8',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x00000000061d6d03d7490283a11fafc70a81125436da7f36d5f5f99f78e3c3f16327ec7d',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x0000000009b40b1ae10510d2930d92f9b8fccf8a3816e9f3ceb1570d1bd3535f54a3bfa7',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x000000000c96e0d947e183c10f48a29e9f09a59f9f19432a8b3a20cd240e238ad74c7d5a',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x000000000dc84729396763b0d317475c7f6d7dac11a3f273115223002b225439d494165c',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x000000000e4e69cde867466d6f59e5342d200791c3262e652c340f73173a20b29025c3fa',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x000000000f89c4baac41e9dab88686ada08b4f5d61218b22c8d531ff8059c63cd6cd9d3a',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x0000000010acdf3da8c98927a39ff61f96c5191f1c287afb09d3587756e6acf873a10710',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x0000000010ee09804a41185f998e627a20cc75a5ba08e87eb20bdc99857e6d6bffe8f46e',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x000000002df5620a37b8e1f60d967dd3fdcf4226186e84e82a3fc135b042e9c10e32bac3',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x000000004234350dadc688b57ceab45632f0517d92f039a8af8e41de483ab2232ab615a4',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x000000005d59b1defbebfb7ae328be6400d118685e0df8d170052e3f2e1ddd3ec7faa9f6',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x000000005f2c8d18ea06e7158aa0e57f9a8824313d0f2b4a9b11110437e983bcfb976533',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x0000000068cb047b8e47344b79c5d622baa202f9027e24da50db08f293b236c00e99e2a6',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x000000006af11475fd4160596c884dbf66f59008d183cebb3aaaf64a90c412acd114057e',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x000000006c6a0594ced00d90230e2d6ed521b45f9c4c5f3c6accc67feaf2b19266a0319b',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x000000006e149587017f742b11dee26e587f8b0e9404c936a57d22240f51f0ec7018a31e',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x00000000730f37a9b1ec55ebfb1ebd5552bd931f19c114cd0e37faead039cf0b30e2c60c',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x000000007b0a60701fa51c38544f7937646c2f796f746461e03ea189e698823d7bb9b3df',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x00000000801b8178fcbdc1f568bd83bd790897d380e4711b31a3762216f76bd7c128ac14',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x0000000081997b369d0dfcfb79e06a186696da012847b48715242db282aec2667b501ed1',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x00000000837259a66fe7d34a45ee287bdef5559abfe784a816e4629549224d32dca8818a',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x0000000086c23e2b6b5c0fb1ad7047153ceae8e084e44f1b938e566483007268c48e80ce',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x00000000876ee5ba6bf8491914b51f92aa5d860ed517e31e4572ae3191e19721bf075ec0',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x0000000088201adf8692d2639ecc0c4cd2a33c43629f230f2cf70e161c3a904d32468fe4',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x00000000883a81775e930ff17a501557cadc43d0802d9ab559d7811c46c7ec26151cb18a',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x000000008aa27fe3d1e03e006909f74424a3d125b5f5148fe4b08a882152e0c0ad58f5e7',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x0000000095b46949776822af669b9a272aa92b82bf35ff8289b305b71cc3a1b2ac50819f',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x00000000a131a6c09863d71bc9be087f9a1bbdeeae31933ebdae0571a97f53a696ee4534',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x00000000b82442332359c4e4b84118836d76bbc04d7cf91cabdafb7662dcd00d0faa55f5',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x00000000bbdc2d61503e9eeee5a9cdd12fcbf3b184916454aa41ea5a4b8ac7e2cbc97c1b',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x00000000c537919e21c33ced3d088ecf8a57a62e04a4acf72be2cf007de772d861ca3387',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x00000000c85a34be59d9a3d070c43fd9581901d100db68259f92a4a476ea1912231f6ea1',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x00000000c8a7206fb806e13d96cbccb9d642d5baf2f2e2e26d96324c3ae8e44eed4cd194',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x00000000caef271196136913859089aa47b6657c11cb2f812b9de573a305ef86fbaa16fd',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x00000000e46e8ee0f671a811315638e5ef0871687f05d90584054485c6258834dcf3e27b',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x00000000e7688e134760756c7bc948f5444068ac20f0cfcfcb67dcdd7640f56557238411',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x00000000ec14858f2c400bd6e553057d824f47e991f39bd1ec89a34070032681f3bcbaa1',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x00000000f3b5ad129397e3759132cd2c8502b5457c670c083e559883f7355ba4f5b1c030',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x00000000fbdb03d6c7ea5a83976ed848928f6bfd36b0e31cd289efc41cc99d91bc15dff7',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
    ],
  },
  {
    outPoints: [
      { txHash: '0x2ac48fd1b5db05851b756b6536f63f080598a8962ca365e20991b86ae547d456', index: '0x0' },
      { txHash: '0xa01db6b79bd41ab7adf4b6f4e10b9a70e14489c109b218d3c6f24770eb5d3000', index: '0x0' },
      { txHash: '0x4fcac5d05e7cbfc7352ade62e44f78cca09450c419fb39b3af05f94f02a48210', index: '0x0' },
      { txHash: '0x5860c0a6a834e0bb2dfbc8d5f4c1885cbbe3367285f5dfb7d464fa042031d17c', index: '0x0' },
      { txHash: '0xd30143cc94d6fdbb656db10a7635e936929febebc9e1424d163ab36a9041e9ba', index: '0x0' },
      { txHash: '0xa4c06a0f9be53d5416f8fe34d7be1a5229a8a2515e3814b6b1ebf18ee11fd032', index: '0x0' },
      { txHash: '0xa75bca0eaa472a83b9a155d4c75dbc3c0e846b7a841fd143ac051c2c07e4aa38', index: '0x0' },
      { txHash: '0xdc0c3056e70b4fe64eda00cdc1fd6b2ae435871608b9fbb75efd13a3e78b496e', index: '0x0' },
      { txHash: '0xd7d8aa87e70834cbf1d4cf95767381471bdfd16b2d9a916d0927b7b81c3d134f', index: '0x0' },
      { txHash: '0x3b0d7d2072c86a2b6f72a1290a70c48f451c1f290adc207e063f8ca3f3edd2b0', index: '0x0' },
    ],
    liveCells: [
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x000000000ace96fdfb046496ee8c82123f96c93897c1995faf2118c068a80dd65799582e',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x000000000d141bf642249d38ae12997df4ab7e580e329d2efeb839d6944c9a57b42fc83a',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x000000008f68f88eda845f9dff7b34c77c3059d192892e14abb805cf9508e6c08ca795d2',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x00000000a1ae6695af5c3bb5e09081dd1a01921ccbed183e0bae6625179795d8f937cef6',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x00000000a4d8d33b6e21ce04d07df866fc1f47ba06513790ba823effc139bbeb9d961844',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x00000000b3ff51158e25b4a18260b26894a979f7a9878bcd7dfb2e141e9a8d8a5b48167f',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x00000000b6d6c5383b584421f68d287fda9f1e95016535f354d6bde0a6bcbdde322ceef1',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x00000000d8c59510194adb47af2fe0bc4357fc7ee0c02dc0847349f2301245c39d745d2c',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x00000000db01b373d54b95ee77dbd69b1896a0991063d6baa75a3256f6cd85763fa3675c',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
      {
        data: null,
        output: {
          lock: {
            codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
            hashType: 'type',
            args: '0x00000000f2bb706291162c8f964f3d40a79b8ee6380876e0ffbcedad6458d73b8f37ad6d',
          },
          type: {
            codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
            hashType: 'type',
            args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
          },
          capacity: '0x5e3ff5d00',
        },
      },
    ],
  },
];

const liveCellByOutPoint: Record<string, LiveCell> = {
  '{"txHash":"0x3ee4107480a679cfdc296dc05c8d71b27a68215a9d3991494e0c13d60ae13792","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x0000000005152dfd26ae6ceb1eabffaec1830912db78cc2ef0045039ce9edaf1042629b8',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0x6204bf05f0b76e0f57eeda3e34773d0b75b9c8fbc4dec329b5a5e09b6fa418ee","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x00000000061d6d03d7490283a11fafc70a81125436da7f36d5f5f99f78e3c3f16327ec7d',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0xbd629504d74fda29a8b9187dc55a4a675c791d25a501862446c4c1d8a1ede2de","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x0000000009b40b1ae10510d2930d92f9b8fccf8a3816e9f3ceb1570d1bd3535f54a3bfa7',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0xedd3f3dde6f4253f32b4a24f3c95d9824f546732f51e67447580d3a590b1468e","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x000000000c96e0d947e183c10f48a29e9f09a59f9f19432a8b3a20cd240e238ad74c7d5a',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0x715a0ad3a91a8e88ae31998aa667e02c973da57f1a287e21dbe4dfcf9f133b65","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x000000000dc84729396763b0d317475c7f6d7dac11a3f273115223002b225439d494165c',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0x75143c1c6e64b01d45122bfa5db70cc5dbb90e945e1c7c781c73363b5e3fb4e0","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x000000000e4e69cde867466d6f59e5342d200791c3262e652c340f73173a20b29025c3fa',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0xcac45b975c8c52ca6199f39de541c0c069556fd54640f4b2838946344f42ce6d","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x000000000f89c4baac41e9dab88686ada08b4f5d61218b22c8d531ff8059c63cd6cd9d3a',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0x122d92afd897e5cce4f17896468453bef911e8ee5a2141e8da4e91fa37863b7d","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x0000000010acdf3da8c98927a39ff61f96c5191f1c287afb09d3587756e6acf873a10710',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0xb65cf4b3f9705253dacc74a83589024e9f751ac3b2cef41d9dfe075b957c5477","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x0000000010ee09804a41185f998e627a20cc75a5ba08e87eb20bdc99857e6d6bffe8f46e',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0x21c7b033b9eb7eb4f4b28783a77447acc8a284b83dc99a353794175ee5c50de8","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x000000002df5620a37b8e1f60d967dd3fdcf4226186e84e82a3fc135b042e9c10e32bac3',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0x2e4d2051d9d5182aa2d9d8360d55a9629e964a8a1562485f928963f39932563d","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x000000004234350dadc688b57ceab45632f0517d92f039a8af8e41de483ab2232ab615a4',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0x2e2ef6a59efa324e51cdf48f769ed044701719a47de696197ab2d52b10b46f02","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x000000005d59b1defbebfb7ae328be6400d118685e0df8d170052e3f2e1ddd3ec7faa9f6',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0xefff789561ce58884324454924e62c1567e70e835c657b54df9a636f95029722","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x000000005f2c8d18ea06e7158aa0e57f9a8824313d0f2b4a9b11110437e983bcfb976533',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0x1414ed5987b243661f6f911fab762b08d84146be46e2950d3f7e20f13df1f6f6","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x0000000068cb047b8e47344b79c5d622baa202f9027e24da50db08f293b236c00e99e2a6',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0x30b3d64d1df36113707f0918d406c3d79482ecc8e22439121cebc458c8960fbe","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x000000006af11475fd4160596c884dbf66f59008d183cebb3aaaf64a90c412acd114057e',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0xc26347679c6f9c321af89838cac070c3a87d4280ed0054fbdd46d94a20683a8e","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x000000006c6a0594ced00d90230e2d6ed521b45f9c4c5f3c6accc67feaf2b19266a0319b',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0x5d573c5fb16adaa17c42c7936fcfd7105818e4ef4bc613d4b6062698182500a6","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x000000006e149587017f742b11dee26e587f8b0e9404c936a57d22240f51f0ec7018a31e',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0x6cac3ce5884577e922afe944e9bf05887e7ab3c847310eb79e6f39cd716cc307","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x00000000730f37a9b1ec55ebfb1ebd5552bd931f19c114cd0e37faead039cf0b30e2c60c',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0x418de4600629116373b24becdcab626f19d113a6093a75a5cef54a695714a20a","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x000000007b0a60701fa51c38544f7937646c2f796f746461e03ea189e698823d7bb9b3df',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0xd1cfd6764c4aae04eebd0f9e5b69dccd2708194b1331b92adb88c3de5a96a9da","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x00000000801b8178fcbdc1f568bd83bd790897d380e4711b31a3762216f76bd7c128ac14',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0xf8168a6392c0691293ec803cd599b3fbc631cf18ad9102dd35c6225f110ba29f","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x0000000081997b369d0dfcfb79e06a186696da012847b48715242db282aec2667b501ed1',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0x6fb324d629f69d1d011015325559bd1a3f58cd2bd0e2dce23b006ea85eade376","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x00000000837259a66fe7d34a45ee287bdef5559abfe784a816e4629549224d32dca8818a',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0xb5c70400545feef1c591c072b386e663805d984ecc90c9ebd282f39990a7cf17","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x0000000086c23e2b6b5c0fb1ad7047153ceae8e084e44f1b938e566483007268c48e80ce',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0x83c92b4592a287cfa76b15c1d0dec0abd7f487b201a1720f3004d1d742a5e581","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x00000000876ee5ba6bf8491914b51f92aa5d860ed517e31e4572ae3191e19721bf075ec0',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0xec2df4da6b567c7be7f698e1895be815626c6b5e504930d1c5b1431792465784","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x0000000088201adf8692d2639ecc0c4cd2a33c43629f230f2cf70e161c3a904d32468fe4',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0xd8fcef10d92024e220bc314a216b9f1decca2f05138d6592a280ad3bb5c0d922","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x00000000883a81775e930ff17a501557cadc43d0802d9ab559d7811c46c7ec26151cb18a',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0x296b94918d48bf6a6a0c3ba8eb301472879060b6339d8ebb93fd59fcaa0fda62","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x000000008aa27fe3d1e03e006909f74424a3d125b5f5148fe4b08a882152e0c0ad58f5e7',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0x9ffa6b826ed3ab1f5fa8f32ee743b4820682897b671dd96f4fea414e04ec3ecc","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x0000000095b46949776822af669b9a272aa92b82bf35ff8289b305b71cc3a1b2ac50819f',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0xbc2a834cbb5b40f5cb47bd3f328297ca851a0c0628be06b2d6a43423750ed0aa","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x00000000a131a6c09863d71bc9be087f9a1bbdeeae31933ebdae0571a97f53a696ee4534',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0xad5be28bad16f4792cc0dc9375b96b74721aafa0383a978ec24ad2ced05cfd16","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x00000000b82442332359c4e4b84118836d76bbc04d7cf91cabdafb7662dcd00d0faa55f5',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0xa368465ce2b6b717312755fea8d95eb475fdd66f019cd67050c0c383409c0667","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x00000000bbdc2d61503e9eeee5a9cdd12fcbf3b184916454aa41ea5a4b8ac7e2cbc97c1b',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0xe763055974a3c1c58a9a8c6f14cd5d0251f26fbfc4f1dd86319411e8794f8889","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x00000000c537919e21c33ced3d088ecf8a57a62e04a4acf72be2cf007de772d861ca3387',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0x27bf1271e34d3b89b8908302b1b52122cd4aabc9b05559c1f347ff1fdc943a12","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x00000000c85a34be59d9a3d070c43fd9581901d100db68259f92a4a476ea1912231f6ea1',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0xd223e96ee030c303c31d79710ea19c7347a04f4b44ca4551c3342ce119e86132","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x00000000c8a7206fb806e13d96cbccb9d642d5baf2f2e2e26d96324c3ae8e44eed4cd194',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0x6adafca165f29c713d15da4e9415d610c02c1b8ce585cc4f5430aa5de3e0e239","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x00000000caef271196136913859089aa47b6657c11cb2f812b9de573a305ef86fbaa16fd',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0xe7797d33ca22ebe3052b273307ccc4472ac57747dcb70d5249efea4957f04f73","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x00000000e46e8ee0f671a811315638e5ef0871687f05d90584054485c6258834dcf3e27b',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0x2f8b991d647b91c931eb32b224c5693991266ed10c89326795f5b71e22a57bea","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x00000000e7688e134760756c7bc948f5444068ac20f0cfcfcb67dcdd7640f56557238411',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0x1ba483627e1dc86c2054a9a7c3ff34df116b2446f1c3c8c0fc70e2f9daf63a1f","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x00000000ec14858f2c400bd6e553057d824f47e991f39bd1ec89a34070032681f3bcbaa1',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0x79f810935bf3ac47bc97c50c78527d71cacc9594ec148eeb294159f6ced0483b","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x00000000f3b5ad129397e3759132cd2c8502b5457c670c083e559883f7355ba4f5b1c030',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0xe0732a33f99598399e0d1bdeaa6ee96b9f0fca39651626a30b0bafa883a12419","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x00000000fbdb03d6c7ea5a83976ed848928f6bfd36b0e31cd289efc41cc99d91bc15dff7',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0x2ac48fd1b5db05851b756b6536f63f080598a8962ca365e20991b86ae547d456","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x000000000ace96fdfb046496ee8c82123f96c93897c1995faf2118c068a80dd65799582e',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0xa01db6b79bd41ab7adf4b6f4e10b9a70e14489c109b218d3c6f24770eb5d3000","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x000000000d141bf642249d38ae12997df4ab7e580e329d2efeb839d6944c9a57b42fc83a',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0x4fcac5d05e7cbfc7352ade62e44f78cca09450c419fb39b3af05f94f02a48210","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x000000008f68f88eda845f9dff7b34c77c3059d192892e14abb805cf9508e6c08ca795d2',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0x5860c0a6a834e0bb2dfbc8d5f4c1885cbbe3367285f5dfb7d464fa042031d17c","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x00000000a1ae6695af5c3bb5e09081dd1a01921ccbed183e0bae6625179795d8f937cef6',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0xd30143cc94d6fdbb656db10a7635e936929febebc9e1424d163ab36a9041e9ba","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x00000000a4d8d33b6e21ce04d07df866fc1f47ba06513790ba823effc139bbeb9d961844',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0xa4c06a0f9be53d5416f8fe34d7be1a5229a8a2515e3814b6b1ebf18ee11fd032","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x00000000b3ff51158e25b4a18260b26894a979f7a9878bcd7dfb2e141e9a8d8a5b48167f',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0xa75bca0eaa472a83b9a155d4c75dbc3c0e846b7a841fd143ac051c2c07e4aa38","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x00000000b6d6c5383b584421f68d287fda9f1e95016535f354d6bde0a6bcbdde322ceef1',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0xdc0c3056e70b4fe64eda00cdc1fd6b2ae435871608b9fbb75efd13a3e78b496e","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x00000000d8c59510194adb47af2fe0bc4357fc7ee0c02dc0847349f2301245c39d745d2c',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0xd7d8aa87e70834cbf1d4cf95767381471bdfd16b2d9a916d0927b7b81c3d134f","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x00000000db01b373d54b95ee77dbd69b1896a0991063d6baa75a3256f6cd85763fa3675c',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
  '{"txHash":"0x3b0d7d2072c86a2b6f72a1290a70c48f451c1f290adc207e063f8ca3f3edd2b0","index":"0x0"}': {
    data: null,
    output: {
      lock: {
        codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
        hashType: 'type',
        args: '0x00000000f2bb706291162c8f964f3d40a79b8ee6380876e0ffbcedad6458d73b8f37ad6d',
      },
      type: {
        codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
        hashType: 'type',
        args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
      },
      capacity: '0x5e3ff5d00',
    },
  },
};

/**
 * Receiver
 */

const receiverAccount = {
  address: 'tb1qj7mns0muzz6pt2yk8a9ntsd055zllumxhksu9y',
};

const receiverBtcUtxos: BtcApiUtxo[] = [
  {
    status: {
      block_hash: '000000000000000251700f4e82b0ea11c16cd9e7b5e5590bb4ebe85205409d48',
      block_height: 2818436,
      block_time: 1716944911,
      confirmed: true,
    },
    txid: '455c5951a4802ca2374a4c335b027fcbe0dc234684cf0bbd1efe1b13bb5224c0',
    value: 35000,
    vout: 0,
  },
  {
    status: {
      block_hash: '000000000000000251700f4e82b0ea11c16cd9e7b5e5590bb4ebe85205409d48',
      block_height: 2818436,
      block_time: 1716944911,
      confirmed: true,
    },
    txid: '16c818560af258558cf8dfa76489f05fc97b82598f36192a1ee4066b3e9334b3',
    value: 35000,
    vout: 0,
  },
];

/**
 * Build result
 */

const buildResult: RgbppTransferAllTxsResult = {
  summary: {
    excluded: {
      cellCount: 41,
      cellIds: [
        '0x00f43b843640fab7c9951a7931632e6ade6ef3337f89489b1c2b400793ece665:0x0',
        '0xa398426747fb052d0832a3296ad89b72253428b6caa19e8be14d4fcb0befeb2d:0x0',
        '0xc657c0531c349e0602397f6369a462bbd3ec84efcd8876e1ccdc0e6f0201a8b0:0x0',
        '0xde2c71de17ebd73b1925805754b1fd2c2cd40b27d5de3edf23812b270439b162:0x0',
        '0xd2466255b2b05a229d3bb9c5f9f1b3def078283cdfd9cef1645ef1046c9047d5:0x0',
        '0xd64f32b7a5daf5c5fd7f0cf0ba76d9263383265fbc706b9043f344afd5fe00e8:0x0',
        '0x16bb55a5c1fd0d6a7d7e7b60892da24c2a33c27041fbf8ada93aab691a311f9b:0x0',
        '0xede3544e671ac287ff67ddea7ce99e7d0afafac5f2889f4f8b1c6c1cd09dcbcc:0x0',
        '0x67cad749783b7d8595b7e5818c08eb380575c64badbd792443f36ae5888ceaff:0x0',
        '0xcaacf9b9b495e1c811598e86d904768162914b1aca7c3537cdd1af2cbe640303:0x0',
        '0x85a5fa2ba570c35fd22e132b3f6a0ad03b8c151d0fd82abdbc8e4c3845615660:0x0',
        '0x62cb0ad5fdcfdfe819135f970604b0c7e7ba6761544d2db2f6e093e8dd50734f:0x0',
        '0x965155d63fa8c9fb00cebb360753911efec9718b0db13f64d7dddd45edc53ab0:0x0',
        '0xea07337354751ba2068e9fb1f56c0b7cd5b4f8b96392387cf4d8c32b39092067:0x0',
        '0xcf8ca99732c62de85820c8670e4257a035dd1c96af440caaa3c60e1fb30a064d:0x0',
        '0x9b661830567bc2b2917d9295bccac8409472c181623091bb80cd15d242256d5a:0x0',
        '0x3c86f4acd287c73551e1ecba3787c139158d9756e5127a1540b979167beb37e3:0x0',
        '0x700ac6b78787cfc2e446ecaef1e7885f05d8138c1b3211d1eed3df6b745e0047:0x0',
        '0x2ed6aca14bdf96fa4174b345ae1840a1c31ac41be4fd4fafa4550b0b9bb94a04:0x0',
        '0x7dfaffb686d86face0c9ae1b7cbd938627ed7f34a7e020465f7bd2d0ca0aefa5:0x0',
        '0xd25420447d02822f43dc7a15ffd9dd00ee3bfe72ef10227256c9878e327ea4c0:0x0',
        '0x5f20ab1a846b0018e91b17d364d31684d1f69c0226e0b71c1b8dc87684411f8a:0x0',
        '0xbccd8a4febd86e65f2508d87b787c791144312c62524d7425b2736f383f20d15:0x0',
        '0xa8aa116e9420c20d4513fad4f9c43e1b8578f77822345b67ad8553d7a4700b00:0x0',
        '0x8a2c1dbea8b03b80d27486b912a4466077e9774321580b96999a5c2b47e8a9c4:0x0',
        '0x1426d8ddd17d048900ab6649c8831ea0597020f8a3f391db33012faf3f426fad:0x0',
        '0x35b073cfad16bba683b74c0306c00f0a0620fd8e27db7151673dcdbd0857a750:0x0',
        '0xc33e4d35bb9d899f71cbbd2d0f9f8f19538fbd16afcef5b6843d4b5eddd743db:0x0',
        '0x4976ed59d93bbedcfc1a2822c0d65774060fa8cb4c0b0d41bed13054c3ccf7fb:0x0',
        '0xdaa57218ca7f632353ce3736ca0d46bbf80553d4b67843d73ac6037e8ddb7ff0:0x0',
        '0x103f9e99efddbb86171c87cabcd1a53b5e09df7863c1b3d63bc6ce71361eaa5a:0x0',
        '0x73068eb36a97ac7f35fd996761d4822a88afd3cf77252ab3b51966eadeb78491:0x0',
        '0xec6d8bc79cd7e0d7353726a438aa9c4cffa4683363331549af30d2542704a556:0x0',
        '0x05398d634a13a662dcbd1504fff11bcc12e287a779b1f35051997ad33ec2aa9f:0x0',
        '0x2bc0dcb5bc6b2cc5ccd4022db998004de578242d6ceeff5303d81a16828ffed5:0x0',
        '0x1976c37d6709fc5d128c1a1b547a598fdce892b4bcb54591d9dccf5f3f2fbb08:0x0',
        '0xc3ea8f82ea187c4fcb0d69aee9f12cfd2cebd52e9fa4aae7c51f4dcbf4e22107:0x0',
        '0xdb3f80f8e2e5f599e7a335f8da68791a87e94bb1042a20bbfef33f655aad0a21:0x0',
        '0x3bac25553adcd0ce92577f8fdeda52212388cbe307a3e6564cf1d5ae6dba4121:0x0',
        '0x3e7a84ff71358d30b6e4213cd5f5cf56bae03053a665bed68277a6fb5c852818:0x0',
        '0xb0ffef5e6998ddc86019de4d90a035c3aceb17fbfcaabb6a225dd27533e8673b:0x0',
      ],
      utxoCount: 1,
      utxoIds: ['69eea91d69b850abd92338fa4f0c9a11d0ed68f74bf5201cb7424dc49506af38:0'],
      xudtAssets: {
        '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e': {
          amount: BigInt(4100000000),
          cellCount: 41,
          utxoCount: 1,
        },
      },
      xudtCellCount: 41,
      xudtCellIds: [
        '0x00f43b843640fab7c9951a7931632e6ade6ef3337f89489b1c2b400793ece665:0x0',
        '0xa398426747fb052d0832a3296ad89b72253428b6caa19e8be14d4fcb0befeb2d:0x0',
        '0xc657c0531c349e0602397f6369a462bbd3ec84efcd8876e1ccdc0e6f0201a8b0:0x0',
        '0xde2c71de17ebd73b1925805754b1fd2c2cd40b27d5de3edf23812b270439b162:0x0',
        '0xd2466255b2b05a229d3bb9c5f9f1b3def078283cdfd9cef1645ef1046c9047d5:0x0',
        '0xd64f32b7a5daf5c5fd7f0cf0ba76d9263383265fbc706b9043f344afd5fe00e8:0x0',
        '0x16bb55a5c1fd0d6a7d7e7b60892da24c2a33c27041fbf8ada93aab691a311f9b:0x0',
        '0xede3544e671ac287ff67ddea7ce99e7d0afafac5f2889f4f8b1c6c1cd09dcbcc:0x0',
        '0x67cad749783b7d8595b7e5818c08eb380575c64badbd792443f36ae5888ceaff:0x0',
        '0xcaacf9b9b495e1c811598e86d904768162914b1aca7c3537cdd1af2cbe640303:0x0',
        '0x85a5fa2ba570c35fd22e132b3f6a0ad03b8c151d0fd82abdbc8e4c3845615660:0x0',
        '0x62cb0ad5fdcfdfe819135f970604b0c7e7ba6761544d2db2f6e093e8dd50734f:0x0',
        '0x965155d63fa8c9fb00cebb360753911efec9718b0db13f64d7dddd45edc53ab0:0x0',
        '0xea07337354751ba2068e9fb1f56c0b7cd5b4f8b96392387cf4d8c32b39092067:0x0',
        '0xcf8ca99732c62de85820c8670e4257a035dd1c96af440caaa3c60e1fb30a064d:0x0',
        '0x9b661830567bc2b2917d9295bccac8409472c181623091bb80cd15d242256d5a:0x0',
        '0x3c86f4acd287c73551e1ecba3787c139158d9756e5127a1540b979167beb37e3:0x0',
        '0x700ac6b78787cfc2e446ecaef1e7885f05d8138c1b3211d1eed3df6b745e0047:0x0',
        '0x2ed6aca14bdf96fa4174b345ae1840a1c31ac41be4fd4fafa4550b0b9bb94a04:0x0',
        '0x7dfaffb686d86face0c9ae1b7cbd938627ed7f34a7e020465f7bd2d0ca0aefa5:0x0',
        '0xd25420447d02822f43dc7a15ffd9dd00ee3bfe72ef10227256c9878e327ea4c0:0x0',
        '0x5f20ab1a846b0018e91b17d364d31684d1f69c0226e0b71c1b8dc87684411f8a:0x0',
        '0xbccd8a4febd86e65f2508d87b787c791144312c62524d7425b2736f383f20d15:0x0',
        '0xa8aa116e9420c20d4513fad4f9c43e1b8578f77822345b67ad8553d7a4700b00:0x0',
        '0x8a2c1dbea8b03b80d27486b912a4466077e9774321580b96999a5c2b47e8a9c4:0x0',
        '0x1426d8ddd17d048900ab6649c8831ea0597020f8a3f391db33012faf3f426fad:0x0',
        '0x35b073cfad16bba683b74c0306c00f0a0620fd8e27db7151673dcdbd0857a750:0x0',
        '0xc33e4d35bb9d899f71cbbd2d0f9f8f19538fbd16afcef5b6843d4b5eddd743db:0x0',
        '0x4976ed59d93bbedcfc1a2822c0d65774060fa8cb4c0b0d41bed13054c3ccf7fb:0x0',
        '0xdaa57218ca7f632353ce3736ca0d46bbf80553d4b67843d73ac6037e8ddb7ff0:0x0',
        '0x103f9e99efddbb86171c87cabcd1a53b5e09df7863c1b3d63bc6ce71361eaa5a:0x0',
        '0x73068eb36a97ac7f35fd996761d4822a88afd3cf77252ab3b51966eadeb78491:0x0',
        '0xec6d8bc79cd7e0d7353726a438aa9c4cffa4683363331549af30d2542704a556:0x0',
        '0x05398d634a13a662dcbd1504fff11bcc12e287a779b1f35051997ad33ec2aa9f:0x0',
        '0x2bc0dcb5bc6b2cc5ccd4022db998004de578242d6ceeff5303d81a16828ffed5:0x0',
        '0x1976c37d6709fc5d128c1a1b547a598fdce892b4bcb54591d9dccf5f3f2fbb08:0x0',
        '0xc3ea8f82ea187c4fcb0d69aee9f12cfd2cebd52e9fa4aae7c51f4dcbf4e22107:0x0',
        '0xdb3f80f8e2e5f599e7a335f8da68791a87e94bb1042a20bbfef33f655aad0a21:0x0',
        '0x3bac25553adcd0ce92577f8fdeda52212388cbe307a3e6564cf1d5ae6dba4121:0x0',
        '0x3e7a84ff71358d30b6e4213cd5f5cf56bae03053a665bed68277a6fb5c852818:0x0',
        '0xb0ffef5e6998ddc86019de4d90a035c3aceb17fbfcaabb6a225dd27533e8673b:0x0',
      ],
    },
    included: {
      cellCount: 50,
      cellIds: [
        '0x6adafca165f29c713d15da4e9415d610c02c1b8ce585cc4f5430aa5de3e0e239:0x0',
        '0x122d92afd897e5cce4f17896468453bef911e8ee5a2141e8da4e91fa37863b7d:0x0',
        '0x2e2ef6a59efa324e51cdf48f769ed044701719a47de696197ab2d52b10b46f02:0x0',
        '0x3ee4107480a679cfdc296dc05c8d71b27a68215a9d3991494e0c13d60ae13792:0x0',
        '0xd1cfd6764c4aae04eebd0f9e5b69dccd2708194b1331b92adb88c3de5a96a9da:0x0',
        '0x296b94918d48bf6a6a0c3ba8eb301472879060b6339d8ebb93fd59fcaa0fda62:0x0',
        '0xa368465ce2b6b717312755fea8d95eb475fdd66f019cd67050c0c383409c0667:0x0',
        '0xd8fcef10d92024e220bc314a216b9f1decca2f05138d6592a280ad3bb5c0d922:0x0',
        '0xe7797d33ca22ebe3052b273307ccc4472ac57747dcb70d5249efea4957f04f73:0x0',
        '0x2e4d2051d9d5182aa2d9d8360d55a9629e964a8a1562485f928963f39932563d:0x0',
        '0x79f810935bf3ac47bc97c50c78527d71cacc9594ec148eeb294159f6ced0483b:0x0',
        '0x27bf1271e34d3b89b8908302b1b52122cd4aabc9b05559c1f347ff1fdc943a12:0x0',
        '0x5d573c5fb16adaa17c42c7936fcfd7105818e4ef4bc613d4b6062698182500a6:0x0',
        '0x6204bf05f0b76e0f57eeda3e34773d0b75b9c8fbc4dec329b5a5e09b6fa418ee:0x0',
        '0xad5be28bad16f4792cc0dc9375b96b74721aafa0383a978ec24ad2ced05cfd16:0x0',
        '0x715a0ad3a91a8e88ae31998aa667e02c973da57f1a287e21dbe4dfcf9f133b65:0x0',
        '0x83c92b4592a287cfa76b15c1d0dec0abd7f487b201a1720f3004d1d742a5e581:0x0',
        '0xe763055974a3c1c58a9a8c6f14cd5d0251f26fbfc4f1dd86319411e8794f8889:0x0',
        '0xe0732a33f99598399e0d1bdeaa6ee96b9f0fca39651626a30b0bafa883a12419:0x0',
        '0xf8168a6392c0691293ec803cd599b3fbc631cf18ad9102dd35c6225f110ba29f:0x0',
        '0xefff789561ce58884324454924e62c1567e70e835c657b54df9a636f95029722:0x0',
        '0x21c7b033b9eb7eb4f4b28783a77447acc8a284b83dc99a353794175ee5c50de8:0x0',
        '0x1414ed5987b243661f6f911fab762b08d84146be46e2950d3f7e20f13df1f6f6:0x0',
        '0x418de4600629116373b24becdcab626f19d113a6093a75a5cef54a695714a20a:0x0',
        '0xd223e96ee030c303c31d79710ea19c7347a04f4b44ca4551c3342ce119e86132:0x0',
        '0xec2df4da6b567c7be7f698e1895be815626c6b5e504930d1c5b1431792465784:0x0',
        '0xcac45b975c8c52ca6199f39de541c0c069556fd54640f4b2838946344f42ce6d:0x0',
        '0x2f8b991d647b91c931eb32b224c5693991266ed10c89326795f5b71e22a57bea:0x0',
        '0x1ba483627e1dc86c2054a9a7c3ff34df116b2446f1c3c8c0fc70e2f9daf63a1f:0x0',
        '0xb65cf4b3f9705253dacc74a83589024e9f751ac3b2cef41d9dfe075b957c5477:0x0',
        '0x9ffa6b826ed3ab1f5fa8f32ee743b4820682897b671dd96f4fea414e04ec3ecc:0x0',
        '0xbd629504d74fda29a8b9187dc55a4a675c791d25a501862446c4c1d8a1ede2de:0x0',
        '0xc26347679c6f9c321af89838cac070c3a87d4280ed0054fbdd46d94a20683a8e:0x0',
        '0xedd3f3dde6f4253f32b4a24f3c95d9824f546732f51e67447580d3a590b1468e:0x0',
        '0x30b3d64d1df36113707f0918d406c3d79482ecc8e22439121cebc458c8960fbe:0x0',
        '0x6cac3ce5884577e922afe944e9bf05887e7ab3c847310eb79e6f39cd716cc307:0x0',
        '0xbc2a834cbb5b40f5cb47bd3f328297ca851a0c0628be06b2d6a43423750ed0aa:0x0',
        '0x75143c1c6e64b01d45122bfa5db70cc5dbb90e945e1c7c781c73363b5e3fb4e0:0x0',
        '0x6fb324d629f69d1d011015325559bd1a3f58cd2bd0e2dce23b006ea85eade376:0x0',
        '0xb5c70400545feef1c591c072b386e663805d984ecc90c9ebd282f39990a7cf17:0x0',
        '0xdc0c3056e70b4fe64eda00cdc1fd6b2ae435871608b9fbb75efd13a3e78b496e:0x0',
        '0xd30143cc94d6fdbb656db10a7635e936929febebc9e1424d163ab36a9041e9ba:0x0',
        '0x3b0d7d2072c86a2b6f72a1290a70c48f451c1f290adc207e063f8ca3f3edd2b0:0x0',
        '0xd7d8aa87e70834cbf1d4cf95767381471bdfd16b2d9a916d0927b7b81c3d134f:0x0',
        '0xa4c06a0f9be53d5416f8fe34d7be1a5229a8a2515e3814b6b1ebf18ee11fd032:0x0',
        '0x2ac48fd1b5db05851b756b6536f63f080598a8962ca365e20991b86ae547d456:0x0',
        '0xa01db6b79bd41ab7adf4b6f4e10b9a70e14489c109b218d3c6f24770eb5d3000:0x0',
        '0x4fcac5d05e7cbfc7352ade62e44f78cca09450c419fb39b3af05f94f02a48210:0x0',
        '0xa75bca0eaa472a83b9a155d4c75dbc3c0e846b7a841fd143ac051c2c07e4aa38:0x0',
        '0x5860c0a6a834e0bb2dfbc8d5f4c1885cbbe3367285f5dfb7d464fa042031d17c:0x0',
      ],
      utxoCount: 50,
      utxoIds: [
        'fd16aafb86ef05a373e59d2b812fcb117c65b647aa899085136913961127efca:0',
        '1007a173f8ace6567758d309fb7a281c1f19c5961ff69fa32789c9a83ddfac10:0',
        'f6a9fac73edd1d2e3f2e0570d1f80d5e6818d10064be28e37afbebfbdeb1595d:0',
        'b8292604f1da9ece395004f02ecc78db120983c1aeffab1eeb6cae26fd2d1505:0',
        '14ac28c1d76bf7162276a3311b71e480d3970879bd83bd68f5c1bdfc78811b80:0',
        'e7f558adc0e05221888ab0e48f14f5b525d1a32444f70969003ee0d1e37fa28a:0',
        '1b7cc9cbe2c78a4b5aea41aa54649184b1f3cb2fd1cda9e5ee9e3e50612ddcbb:0',
        '8ab11c1526ecc7461c81d759b59a2d80d043dcca5715507af10f935e77813a88:0',
        '7be2f3dc348825c68544058405d9057f687108efe538563111a871f6e08e6ee4:0',
        'a415b62a23b23a48de418eafa839f0927d51f03256b4ea7cb588c6ad0d353442:0',
        '30c0b1f5a45b35f78398553e080c677c45b502852ccd329175e3979312adb5f3:0',
        'a16e1f231219ea76a4a4929f2568db00d1011958d93fc470d0a3d959be345ac8:0',
        '1ea31870ecf0510f24227da536c904940e8b7f586ee2de112b747f018795146e:0',
        '7dec2763f1c3e3789ff9f5d5367fda365412810ac7af1fa1830249d7036d1d06:0',
        'f555aa0f0dd0dc6276fbdaab1cf97c4dc0bb766d831841b8e4c45923334224b8:0',
        '5c1694d43954222b0023521173f2a311ac7d6d7f5c4717d3b06367392947c80d:0',
        'c05e07bf2197e19131ae72451ee317d50e865daa921fb5141949f86bbae56e87:0',
        '8733ca61d872e77d00cfe22bf7aca4042ea6578acf8e083ded3cc3219e9137c5:0',
        'f7df15bc919dc91cc4ef89d21ce3b036fd6b8f9248d86e97835aeac7d603dbfb:0',
        'd11e507b66c2ae82b22d241587b4472801da9666186ae079fbfc0d9d367b9981:0',
        '336597fbbc83e9370411119b4a2b0f3d3124889a7fe5a08a15e706ea188d2c5f:0',
        'c3ba320ec1e942b035c13f2ae8846e182642cffdd37d960df6e1b8370a62f52d:0',
        'a6e2990ec036b293f208db50da247e02f902a2ba22d6c5794b34478e7b04cb68:0',
        'dfb3b97b3d8298e689a13ee06164746f792f6c6437794f54381ca51f70600a7b:0',
        '94d14ced4ee4e83a4c32966de2e2f2f2bad542d6b9cccb963de106b86f20a7c8:0',
        'e48f46324d903a1c160ef72c0f239f62433ca3d24c0ccc9e63d29286df1a2088:0',
        '3a9dcdd63cc65980ff31d5c8228b21615d4f8ba0ad8686b8dae941acbac4890f:0',
        '1184235765f54076dddc67cbcfcff020ac684044f548c97b6c756047138e68e7:0',
        'a1babcf38126037040a389ecd19bf391e9474f827d0553e5d60b402c8f8514ec:0',
        '6ef4e8ff6b6d7e8599dc0bb27ee808baa575cc207a628e995f18414a8009ee10:0',
        '9f8150acb2a1c31cb705b38982ff35bf822ba92a279a9b66af2268774969b495:0',
        'a7bfa3545f53d31b0d57b1cef3e916388acffcb8f9920d93d21005e11a0bb409:0',
        '9b31a06692b1f2ea7fc6cc6a3c5f4c9c5fb421d56e2d0e23900dd0ce94056a6c:0',
        '5a7d4cd78a230e24cd203a8b2a43199f9fa5099f9ea2480fc183e147d9e0960c:0',
        '7e0514d1ac12c4904af6aa3abbce83d10890f566bf4d886c596041fd7514f16a:0',
        '0cc6e2300bcf39d0eafa370ecd14c1191f93bd5255bd1efbeb55ecb1a9370f73:0',
        '3445ee96a6537fa97105aebd3e9331aeeebd1b9a7f08bec91bd76398c0a631a1:0',
        'fac32590b2203a17730f342c652e26c39107202d34e5596f6d4667e8cd694e0e:0',
        '8a81a8dc324d22499562e416a884e7bf9a55f5de7b28ee454ad3e76fa6597283:0',
        'ce808ec46872008364568e931b4fe484e0e8ea3c154770adb10f5c6b2b3ec286:0',
        '2c5d749dc3451230f2497384c02dc0e07efc5743bce02faf47db4a191095c5d8:0',
        '4418969debbb39c1ff3e82ba90375106ba471ffc66f87dd004ce216e3bd3d8a4:0',
        '6dad378f3bd75864adedbcffe0760838e68e9ba7403d4f968f2c16916270bbf2:0',
        '5c67a33f7685cdf656325aa7bad6631099a096189bd6db77ee954bd573b301db:0',
        '7f16485b8a8d9a1e142efb7dcd8b87a9f779a99468b26082a1b4258e1551ffb3:0',
        '2e589957d60da868c01821af5f99c19738c9963f12828cee966404fbfd96ce0a:0',
        '3ac82fb4579a4c94d639b8fe2e9d320e587eabf47d9912ae389d2442f61b140d:0',
        'd295a78cc0e60895cf05b8ab142e8992d159307cc7347bff9d5f84da8ef8688f:0',
        'f1ee2c32debdbca6e0bdd654f3356501951e9fda7f288df62144583b38c5d6b6:0',
        'f6ce37f9d89597172566ae0b3e18edcb1c92011add8190e0b53b5caf9566aea1:0',
      ],
      xudtAssets: {
        '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e': {
          amount: BigInt(50000000000),
          cellCount: 50,
          utxoCount: 50,
        },
      },
      xudtCellCount: 50,
      xudtCellIds: [
        '0x6adafca165f29c713d15da4e9415d610c02c1b8ce585cc4f5430aa5de3e0e239:0x0',
        '0x122d92afd897e5cce4f17896468453bef911e8ee5a2141e8da4e91fa37863b7d:0x0',
        '0x2e2ef6a59efa324e51cdf48f769ed044701719a47de696197ab2d52b10b46f02:0x0',
        '0x3ee4107480a679cfdc296dc05c8d71b27a68215a9d3991494e0c13d60ae13792:0x0',
        '0xd1cfd6764c4aae04eebd0f9e5b69dccd2708194b1331b92adb88c3de5a96a9da:0x0',
        '0x296b94918d48bf6a6a0c3ba8eb301472879060b6339d8ebb93fd59fcaa0fda62:0x0',
        '0xa368465ce2b6b717312755fea8d95eb475fdd66f019cd67050c0c383409c0667:0x0',
        '0xd8fcef10d92024e220bc314a216b9f1decca2f05138d6592a280ad3bb5c0d922:0x0',
        '0xe7797d33ca22ebe3052b273307ccc4472ac57747dcb70d5249efea4957f04f73:0x0',
        '0x2e4d2051d9d5182aa2d9d8360d55a9629e964a8a1562485f928963f39932563d:0x0',
        '0x79f810935bf3ac47bc97c50c78527d71cacc9594ec148eeb294159f6ced0483b:0x0',
        '0x27bf1271e34d3b89b8908302b1b52122cd4aabc9b05559c1f347ff1fdc943a12:0x0',
        '0x5d573c5fb16adaa17c42c7936fcfd7105818e4ef4bc613d4b6062698182500a6:0x0',
        '0x6204bf05f0b76e0f57eeda3e34773d0b75b9c8fbc4dec329b5a5e09b6fa418ee:0x0',
        '0xad5be28bad16f4792cc0dc9375b96b74721aafa0383a978ec24ad2ced05cfd16:0x0',
        '0x715a0ad3a91a8e88ae31998aa667e02c973da57f1a287e21dbe4dfcf9f133b65:0x0',
        '0x83c92b4592a287cfa76b15c1d0dec0abd7f487b201a1720f3004d1d742a5e581:0x0',
        '0xe763055974a3c1c58a9a8c6f14cd5d0251f26fbfc4f1dd86319411e8794f8889:0x0',
        '0xe0732a33f99598399e0d1bdeaa6ee96b9f0fca39651626a30b0bafa883a12419:0x0',
        '0xf8168a6392c0691293ec803cd599b3fbc631cf18ad9102dd35c6225f110ba29f:0x0',
        '0xefff789561ce58884324454924e62c1567e70e835c657b54df9a636f95029722:0x0',
        '0x21c7b033b9eb7eb4f4b28783a77447acc8a284b83dc99a353794175ee5c50de8:0x0',
        '0x1414ed5987b243661f6f911fab762b08d84146be46e2950d3f7e20f13df1f6f6:0x0',
        '0x418de4600629116373b24becdcab626f19d113a6093a75a5cef54a695714a20a:0x0',
        '0xd223e96ee030c303c31d79710ea19c7347a04f4b44ca4551c3342ce119e86132:0x0',
        '0xec2df4da6b567c7be7f698e1895be815626c6b5e504930d1c5b1431792465784:0x0',
        '0xcac45b975c8c52ca6199f39de541c0c069556fd54640f4b2838946344f42ce6d:0x0',
        '0x2f8b991d647b91c931eb32b224c5693991266ed10c89326795f5b71e22a57bea:0x0',
        '0x1ba483627e1dc86c2054a9a7c3ff34df116b2446f1c3c8c0fc70e2f9daf63a1f:0x0',
        '0xb65cf4b3f9705253dacc74a83589024e9f751ac3b2cef41d9dfe075b957c5477:0x0',
        '0x9ffa6b826ed3ab1f5fa8f32ee743b4820682897b671dd96f4fea414e04ec3ecc:0x0',
        '0xbd629504d74fda29a8b9187dc55a4a675c791d25a501862446c4c1d8a1ede2de:0x0',
        '0xc26347679c6f9c321af89838cac070c3a87d4280ed0054fbdd46d94a20683a8e:0x0',
        '0xedd3f3dde6f4253f32b4a24f3c95d9824f546732f51e67447580d3a590b1468e:0x0',
        '0x30b3d64d1df36113707f0918d406c3d79482ecc8e22439121cebc458c8960fbe:0x0',
        '0x6cac3ce5884577e922afe944e9bf05887e7ab3c847310eb79e6f39cd716cc307:0x0',
        '0xbc2a834cbb5b40f5cb47bd3f328297ca851a0c0628be06b2d6a43423750ed0aa:0x0',
        '0x75143c1c6e64b01d45122bfa5db70cc5dbb90e945e1c7c781c73363b5e3fb4e0:0x0',
        '0x6fb324d629f69d1d011015325559bd1a3f58cd2bd0e2dce23b006ea85eade376:0x0',
        '0xb5c70400545feef1c591c072b386e663805d984ecc90c9ebd282f39990a7cf17:0x0',
        '0xdc0c3056e70b4fe64eda00cdc1fd6b2ae435871608b9fbb75efd13a3e78b496e:0x0',
        '0xd30143cc94d6fdbb656db10a7635e936929febebc9e1424d163ab36a9041e9ba:0x0',
        '0x3b0d7d2072c86a2b6f72a1290a70c48f451c1f290adc207e063f8ca3f3edd2b0:0x0',
        '0xd7d8aa87e70834cbf1d4cf95767381471bdfd16b2d9a916d0927b7b81c3d134f:0x0',
        '0xa4c06a0f9be53d5416f8fe34d7be1a5229a8a2515e3814b6b1ebf18ee11fd032:0x0',
        '0x2ac48fd1b5db05851b756b6536f63f080598a8962ca365e20991b86ae547d456:0x0',
        '0xa01db6b79bd41ab7adf4b6f4e10b9a70e14489c109b218d3c6f24770eb5d3000:0x0',
        '0x4fcac5d05e7cbfc7352ade62e44f78cca09450c419fb39b3af05f94f02a48210:0x0',
        '0xa75bca0eaa472a83b9a155d4c75dbc3c0e846b7a841fd143ac051c2c07e4aa38:0x0',
        '0x5860c0a6a834e0bb2dfbc8d5f4c1885cbbe3367285f5dfb7d464fa042031d17c:0x0',
      ],
    },
  },
  transactions: [
    {
      btc: {
        fee: 2426,
        feeRate: 1,
        psbtHex:
          '70736274ff0100fddb06020000002805152dfd26ae6ceb1eabffaec1830912db78cc2ef0045039ce9edaf1042629b80000000000ffffffff061d6d03d7490283a11fafc70a81125436da7f36d5f5f99f78e3c3f16327ec7d0000000000ffffffff09b40b1ae10510d2930d92f9b8fccf8a3816e9f3ceb1570d1bd3535f54a3bfa70000000000ffffffff0c96e0d947e183c10f48a29e9f09a59f9f19432a8b3a20cd240e238ad74c7d5a0000000000ffffffff0dc84729396763b0d317475c7f6d7dac11a3f273115223002b225439d494165c0000000000ffffffff0e4e69cde867466d6f59e5342d200791c3262e652c340f73173a20b29025c3fa0000000000ffffffff0f89c4baac41e9dab88686ada08b4f5d61218b22c8d531ff8059c63cd6cd9d3a0000000000ffffffff10acdf3da8c98927a39ff61f96c5191f1c287afb09d3587756e6acf873a107100000000000ffffffff10ee09804a41185f998e627a20cc75a5ba08e87eb20bdc99857e6d6bffe8f46e0000000000ffffffff2df5620a37b8e1f60d967dd3fdcf4226186e84e82a3fc135b042e9c10e32bac30000000000ffffffff4234350dadc688b57ceab45632f0517d92f039a8af8e41de483ab2232ab615a40000000000ffffffff5d59b1defbebfb7ae328be6400d118685e0df8d170052e3f2e1ddd3ec7faa9f60000000000ffffffff5f2c8d18ea06e7158aa0e57f9a8824313d0f2b4a9b11110437e983bcfb9765330000000000ffffffff68cb047b8e47344b79c5d622baa202f9027e24da50db08f293b236c00e99e2a60000000000ffffffff6af11475fd4160596c884dbf66f59008d183cebb3aaaf64a90c412acd114057e0000000000ffffffff6c6a0594ced00d90230e2d6ed521b45f9c4c5f3c6accc67feaf2b19266a0319b0000000000ffffffff6e149587017f742b11dee26e587f8b0e9404c936a57d22240f51f0ec7018a31e0000000000ffffffff730f37a9b1ec55ebfb1ebd5552bd931f19c114cd0e37faead039cf0b30e2c60c0000000000ffffffff7b0a60701fa51c38544f7937646c2f796f746461e03ea189e698823d7bb9b3df0000000000ffffffff801b8178fcbdc1f568bd83bd790897d380e4711b31a3762216f76bd7c128ac140000000000ffffffff81997b369d0dfcfb79e06a186696da012847b48715242db282aec2667b501ed10000000000ffffffff837259a66fe7d34a45ee287bdef5559abfe784a816e4629549224d32dca8818a0000000000ffffffff86c23e2b6b5c0fb1ad7047153ceae8e084e44f1b938e566483007268c48e80ce0000000000ffffffff876ee5ba6bf8491914b51f92aa5d860ed517e31e4572ae3191e19721bf075ec00000000000ffffffff88201adf8692d2639ecc0c4cd2a33c43629f230f2cf70e161c3a904d32468fe40000000000ffffffff883a81775e930ff17a501557cadc43d0802d9ab559d7811c46c7ec26151cb18a0000000000ffffffff8aa27fe3d1e03e006909f74424a3d125b5f5148fe4b08a882152e0c0ad58f5e70000000000ffffffff95b46949776822af669b9a272aa92b82bf35ff8289b305b71cc3a1b2ac50819f0000000000ffffffffa131a6c09863d71bc9be087f9a1bbdeeae31933ebdae0571a97f53a696ee45340000000000ffffffffb82442332359c4e4b84118836d76bbc04d7cf91cabdafb7662dcd00d0faa55f50000000000ffffffffbbdc2d61503e9eeee5a9cdd12fcbf3b184916454aa41ea5a4b8ac7e2cbc97c1b0000000000ffffffffc537919e21c33ced3d088ecf8a57a62e04a4acf72be2cf007de772d861ca33870000000000ffffffffc85a34be59d9a3d070c43fd9581901d100db68259f92a4a476ea1912231f6ea10000000000ffffffffc8a7206fb806e13d96cbccb9d642d5baf2f2e2e26d96324c3ae8e44eed4cd1940000000000ffffffffcaef271196136913859089aa47b6657c11cb2f812b9de573a305ef86fbaa16fd0000000000ffffffffe46e8ee0f671a811315638e5ef0871687f05d90584054485c6258834dcf3e27b0000000000ffffffffe7688e134760756c7bc948f5444068ac20f0cfcfcb67dcdd7640f565572384110000000000ffffffffec14858f2c400bd6e553057d824f47e991f39bd1ec89a34070032681f3bcbaa10000000000fffffffff3b5ad129397e3759132cd2c8502b5457c670c083e559883f7355ba4f5b1c0300000000000fffffffffbdb03d6c7ea5a83976ed848928f6bfd36b0e31cd289efc41cc99d91bc15dff70000000000ffffffff030000000000000000226a20e2614965809a619bfa47b36631c3896fca24780336a8d524930dd61ef4e67d11220200000000000016001497b7383f7c10b415a8963f4b35c1afa505fff366b44900000000000016001497b7383f7c10b415a8963f4b35c1afa505fff366000000000001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e927100000000',
      },
      ckb: {
        virtualTxResult: {
          ckbRawTx: {
            cellDeps: [
              {
                depType: 'code',
                outPoint: {
                  index: '0x0',
                  txHash: '0xf1de59e973b85791ec32debbba08dff80c63197e895eb95d67fc1e9f6b413e00',
                },
              },
              {
                depType: 'code',
                outPoint: {
                  index: '0x1',
                  txHash: '0xf1de59e973b85791ec32debbba08dff80c63197e895eb95d67fc1e9f6b413e00',
                },
              },
              {
                depType: 'code',
                outPoint: {
                  index: '0x0',
                  txHash: '0xbf6fb538763efec2a70a6a3dcb7242787087e1030c4e7d86585bc63a9d337f5f',
                },
              },
            ],
            headerDeps: [],
            inputs: [
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0x3ee4107480a679cfdc296dc05c8d71b27a68215a9d3991494e0c13d60ae13792',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0x6204bf05f0b76e0f57eeda3e34773d0b75b9c8fbc4dec329b5a5e09b6fa418ee',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0xbd629504d74fda29a8b9187dc55a4a675c791d25a501862446c4c1d8a1ede2de',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0xedd3f3dde6f4253f32b4a24f3c95d9824f546732f51e67447580d3a590b1468e',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0x715a0ad3a91a8e88ae31998aa667e02c973da57f1a287e21dbe4dfcf9f133b65',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0x75143c1c6e64b01d45122bfa5db70cc5dbb90e945e1c7c781c73363b5e3fb4e0',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0xcac45b975c8c52ca6199f39de541c0c069556fd54640f4b2838946344f42ce6d',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0x122d92afd897e5cce4f17896468453bef911e8ee5a2141e8da4e91fa37863b7d',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0xb65cf4b3f9705253dacc74a83589024e9f751ac3b2cef41d9dfe075b957c5477',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0x21c7b033b9eb7eb4f4b28783a77447acc8a284b83dc99a353794175ee5c50de8',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0x2e4d2051d9d5182aa2d9d8360d55a9629e964a8a1562485f928963f39932563d',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0x2e2ef6a59efa324e51cdf48f769ed044701719a47de696197ab2d52b10b46f02',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0xefff789561ce58884324454924e62c1567e70e835c657b54df9a636f95029722',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0x1414ed5987b243661f6f911fab762b08d84146be46e2950d3f7e20f13df1f6f6',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0x30b3d64d1df36113707f0918d406c3d79482ecc8e22439121cebc458c8960fbe',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0xc26347679c6f9c321af89838cac070c3a87d4280ed0054fbdd46d94a20683a8e',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0x5d573c5fb16adaa17c42c7936fcfd7105818e4ef4bc613d4b6062698182500a6',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0x6cac3ce5884577e922afe944e9bf05887e7ab3c847310eb79e6f39cd716cc307',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0x418de4600629116373b24becdcab626f19d113a6093a75a5cef54a695714a20a',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0xd1cfd6764c4aae04eebd0f9e5b69dccd2708194b1331b92adb88c3de5a96a9da',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0xf8168a6392c0691293ec803cd599b3fbc631cf18ad9102dd35c6225f110ba29f',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0x6fb324d629f69d1d011015325559bd1a3f58cd2bd0e2dce23b006ea85eade376',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0xb5c70400545feef1c591c072b386e663805d984ecc90c9ebd282f39990a7cf17',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0x83c92b4592a287cfa76b15c1d0dec0abd7f487b201a1720f3004d1d742a5e581',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0xec2df4da6b567c7be7f698e1895be815626c6b5e504930d1c5b1431792465784',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0xd8fcef10d92024e220bc314a216b9f1decca2f05138d6592a280ad3bb5c0d922',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0x296b94918d48bf6a6a0c3ba8eb301472879060b6339d8ebb93fd59fcaa0fda62',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0x9ffa6b826ed3ab1f5fa8f32ee743b4820682897b671dd96f4fea414e04ec3ecc',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0xbc2a834cbb5b40f5cb47bd3f328297ca851a0c0628be06b2d6a43423750ed0aa',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0xad5be28bad16f4792cc0dc9375b96b74721aafa0383a978ec24ad2ced05cfd16',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0xa368465ce2b6b717312755fea8d95eb475fdd66f019cd67050c0c383409c0667',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0xe763055974a3c1c58a9a8c6f14cd5d0251f26fbfc4f1dd86319411e8794f8889',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0x27bf1271e34d3b89b8908302b1b52122cd4aabc9b05559c1f347ff1fdc943a12',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0xd223e96ee030c303c31d79710ea19c7347a04f4b44ca4551c3342ce119e86132',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0x6adafca165f29c713d15da4e9415d610c02c1b8ce585cc4f5430aa5de3e0e239',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0xe7797d33ca22ebe3052b273307ccc4472ac57747dcb70d5249efea4957f04f73',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0x2f8b991d647b91c931eb32b224c5693991266ed10c89326795f5b71e22a57bea',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0x1ba483627e1dc86c2054a9a7c3ff34df116b2446f1c3c8c0fc70e2f9daf63a1f',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0x79f810935bf3ac47bc97c50c78527d71cacc9594ec148eeb294159f6ced0483b',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0xe0732a33f99598399e0d1bdeaa6ee96b9f0fca39651626a30b0bafa883a12419',
                },
                since: '0x0',
              },
            ],
            outputs: [
              {
                capacity: '0xeb9fe321c2',
                lock: {
                  args: '0x010000000000000000000000000000000000000000000000000000000000000000000000',
                  codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
                  hashType: 'type',
                },
                type: {
                  args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
                  codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
                  hashType: 'type',
                },
              },
            ],
            outputsData: ['0x00902f50090000000000000000000000'],
            version: '0x0',
            witnesses: [
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
              '0xFF',
            ],
          },
          commitment: 'e2614965809a619bfa47b36631c3896fca24780336a8d524930dd61ef4e67d11',
          needPaymasterCell: false,
          sumInputsCapacity: '0xeb9fe68800',
        },
      },
      summary: {
        cellCount: 40,
        cellIds: [
          '0x6adafca165f29c713d15da4e9415d610c02c1b8ce585cc4f5430aa5de3e0e239:0x0',
          '0x122d92afd897e5cce4f17896468453bef911e8ee5a2141e8da4e91fa37863b7d:0x0',
          '0x2e2ef6a59efa324e51cdf48f769ed044701719a47de696197ab2d52b10b46f02:0x0',
          '0x3ee4107480a679cfdc296dc05c8d71b27a68215a9d3991494e0c13d60ae13792:0x0',
          '0xd1cfd6764c4aae04eebd0f9e5b69dccd2708194b1331b92adb88c3de5a96a9da:0x0',
          '0x296b94918d48bf6a6a0c3ba8eb301472879060b6339d8ebb93fd59fcaa0fda62:0x0',
          '0xa368465ce2b6b717312755fea8d95eb475fdd66f019cd67050c0c383409c0667:0x0',
          '0xd8fcef10d92024e220bc314a216b9f1decca2f05138d6592a280ad3bb5c0d922:0x0',
          '0xe7797d33ca22ebe3052b273307ccc4472ac57747dcb70d5249efea4957f04f73:0x0',
          '0x2e4d2051d9d5182aa2d9d8360d55a9629e964a8a1562485f928963f39932563d:0x0',
          '0x79f810935bf3ac47bc97c50c78527d71cacc9594ec148eeb294159f6ced0483b:0x0',
          '0x27bf1271e34d3b89b8908302b1b52122cd4aabc9b05559c1f347ff1fdc943a12:0x0',
          '0x5d573c5fb16adaa17c42c7936fcfd7105818e4ef4bc613d4b6062698182500a6:0x0',
          '0x6204bf05f0b76e0f57eeda3e34773d0b75b9c8fbc4dec329b5a5e09b6fa418ee:0x0',
          '0xad5be28bad16f4792cc0dc9375b96b74721aafa0383a978ec24ad2ced05cfd16:0x0',
          '0x715a0ad3a91a8e88ae31998aa667e02c973da57f1a287e21dbe4dfcf9f133b65:0x0',
          '0x83c92b4592a287cfa76b15c1d0dec0abd7f487b201a1720f3004d1d742a5e581:0x0',
          '0xe763055974a3c1c58a9a8c6f14cd5d0251f26fbfc4f1dd86319411e8794f8889:0x0',
          '0xe0732a33f99598399e0d1bdeaa6ee96b9f0fca39651626a30b0bafa883a12419:0x0',
          '0xf8168a6392c0691293ec803cd599b3fbc631cf18ad9102dd35c6225f110ba29f:0x0',
          '0xefff789561ce58884324454924e62c1567e70e835c657b54df9a636f95029722:0x0',
          '0x21c7b033b9eb7eb4f4b28783a77447acc8a284b83dc99a353794175ee5c50de8:0x0',
          '0x1414ed5987b243661f6f911fab762b08d84146be46e2950d3f7e20f13df1f6f6:0x0',
          '0x418de4600629116373b24becdcab626f19d113a6093a75a5cef54a695714a20a:0x0',
          '0xd223e96ee030c303c31d79710ea19c7347a04f4b44ca4551c3342ce119e86132:0x0',
          '0xec2df4da6b567c7be7f698e1895be815626c6b5e504930d1c5b1431792465784:0x0',
          '0xcac45b975c8c52ca6199f39de541c0c069556fd54640f4b2838946344f42ce6d:0x0',
          '0x2f8b991d647b91c931eb32b224c5693991266ed10c89326795f5b71e22a57bea:0x0',
          '0x1ba483627e1dc86c2054a9a7c3ff34df116b2446f1c3c8c0fc70e2f9daf63a1f:0x0',
          '0xb65cf4b3f9705253dacc74a83589024e9f751ac3b2cef41d9dfe075b957c5477:0x0',
          '0x9ffa6b826ed3ab1f5fa8f32ee743b4820682897b671dd96f4fea414e04ec3ecc:0x0',
          '0xbd629504d74fda29a8b9187dc55a4a675c791d25a501862446c4c1d8a1ede2de:0x0',
          '0xc26347679c6f9c321af89838cac070c3a87d4280ed0054fbdd46d94a20683a8e:0x0',
          '0xedd3f3dde6f4253f32b4a24f3c95d9824f546732f51e67447580d3a590b1468e:0x0',
          '0x30b3d64d1df36113707f0918d406c3d79482ecc8e22439121cebc458c8960fbe:0x0',
          '0x6cac3ce5884577e922afe944e9bf05887e7ab3c847310eb79e6f39cd716cc307:0x0',
          '0xbc2a834cbb5b40f5cb47bd3f328297ca851a0c0628be06b2d6a43423750ed0aa:0x0',
          '0x75143c1c6e64b01d45122bfa5db70cc5dbb90e945e1c7c781c73363b5e3fb4e0:0x0',
          '0x6fb324d629f69d1d011015325559bd1a3f58cd2bd0e2dce23b006ea85eade376:0x0',
          '0xb5c70400545feef1c591c072b386e663805d984ecc90c9ebd282f39990a7cf17:0x0',
        ],
        utxoCount: 40,
        utxoIds: [
          'fd16aafb86ef05a373e59d2b812fcb117c65b647aa899085136913961127efca:0',
          '1007a173f8ace6567758d309fb7a281c1f19c5961ff69fa32789c9a83ddfac10:0',
          'f6a9fac73edd1d2e3f2e0570d1f80d5e6818d10064be28e37afbebfbdeb1595d:0',
          'b8292604f1da9ece395004f02ecc78db120983c1aeffab1eeb6cae26fd2d1505:0',
          '14ac28c1d76bf7162276a3311b71e480d3970879bd83bd68f5c1bdfc78811b80:0',
          'e7f558adc0e05221888ab0e48f14f5b525d1a32444f70969003ee0d1e37fa28a:0',
          '1b7cc9cbe2c78a4b5aea41aa54649184b1f3cb2fd1cda9e5ee9e3e50612ddcbb:0',
          '8ab11c1526ecc7461c81d759b59a2d80d043dcca5715507af10f935e77813a88:0',
          '7be2f3dc348825c68544058405d9057f687108efe538563111a871f6e08e6ee4:0',
          'a415b62a23b23a48de418eafa839f0927d51f03256b4ea7cb588c6ad0d353442:0',
          '30c0b1f5a45b35f78398553e080c677c45b502852ccd329175e3979312adb5f3:0',
          'a16e1f231219ea76a4a4929f2568db00d1011958d93fc470d0a3d959be345ac8:0',
          '1ea31870ecf0510f24227da536c904940e8b7f586ee2de112b747f018795146e:0',
          '7dec2763f1c3e3789ff9f5d5367fda365412810ac7af1fa1830249d7036d1d06:0',
          'f555aa0f0dd0dc6276fbdaab1cf97c4dc0bb766d831841b8e4c45923334224b8:0',
          '5c1694d43954222b0023521173f2a311ac7d6d7f5c4717d3b06367392947c80d:0',
          'c05e07bf2197e19131ae72451ee317d50e865daa921fb5141949f86bbae56e87:0',
          '8733ca61d872e77d00cfe22bf7aca4042ea6578acf8e083ded3cc3219e9137c5:0',
          'f7df15bc919dc91cc4ef89d21ce3b036fd6b8f9248d86e97835aeac7d603dbfb:0',
          'd11e507b66c2ae82b22d241587b4472801da9666186ae079fbfc0d9d367b9981:0',
          '336597fbbc83e9370411119b4a2b0f3d3124889a7fe5a08a15e706ea188d2c5f:0',
          'c3ba320ec1e942b035c13f2ae8846e182642cffdd37d960df6e1b8370a62f52d:0',
          'a6e2990ec036b293f208db50da247e02f902a2ba22d6c5794b34478e7b04cb68:0',
          'dfb3b97b3d8298e689a13ee06164746f792f6c6437794f54381ca51f70600a7b:0',
          '94d14ced4ee4e83a4c32966de2e2f2f2bad542d6b9cccb963de106b86f20a7c8:0',
          'e48f46324d903a1c160ef72c0f239f62433ca3d24c0ccc9e63d29286df1a2088:0',
          '3a9dcdd63cc65980ff31d5c8228b21615d4f8ba0ad8686b8dae941acbac4890f:0',
          '1184235765f54076dddc67cbcfcff020ac684044f548c97b6c756047138e68e7:0',
          'a1babcf38126037040a389ecd19bf391e9474f827d0553e5d60b402c8f8514ec:0',
          '6ef4e8ff6b6d7e8599dc0bb27ee808baa575cc207a628e995f18414a8009ee10:0',
          '9f8150acb2a1c31cb705b38982ff35bf822ba92a279a9b66af2268774969b495:0',
          'a7bfa3545f53d31b0d57b1cef3e916388acffcb8f9920d93d21005e11a0bb409:0',
          '9b31a06692b1f2ea7fc6cc6a3c5f4c9c5fb421d56e2d0e23900dd0ce94056a6c:0',
          '5a7d4cd78a230e24cd203a8b2a43199f9fa5099f9ea2480fc183e147d9e0960c:0',
          '7e0514d1ac12c4904af6aa3abbce83d10890f566bf4d886c596041fd7514f16a:0',
          '0cc6e2300bcf39d0eafa370ecd14c1191f93bd5255bd1efbeb55ecb1a9370f73:0',
          '3445ee96a6537fa97105aebd3e9331aeeebd1b9a7f08bec91bd76398c0a631a1:0',
          'fac32590b2203a17730f342c652e26c39107202d34e5596f6d4667e8cd694e0e:0',
          '8a81a8dc324d22499562e416a884e7bf9a55f5de7b28ee454ad3e76fa6597283:0',
          'ce808ec46872008364568e931b4fe484e0e8ea3c154770adb10f5c6b2b3ec286:0',
        ],
        xudtAssets: {
          '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e': {
            amount: BigInt(40000000000),
            cellCount: 40,
            utxoCount: 40,
          },
        },
        xudtCellCount: 40,
        xudtCellIds: [
          '0x6adafca165f29c713d15da4e9415d610c02c1b8ce585cc4f5430aa5de3e0e239:0x0',
          '0x122d92afd897e5cce4f17896468453bef911e8ee5a2141e8da4e91fa37863b7d:0x0',
          '0x2e2ef6a59efa324e51cdf48f769ed044701719a47de696197ab2d52b10b46f02:0x0',
          '0x3ee4107480a679cfdc296dc05c8d71b27a68215a9d3991494e0c13d60ae13792:0x0',
          '0xd1cfd6764c4aae04eebd0f9e5b69dccd2708194b1331b92adb88c3de5a96a9da:0x0',
          '0x296b94918d48bf6a6a0c3ba8eb301472879060b6339d8ebb93fd59fcaa0fda62:0x0',
          '0xa368465ce2b6b717312755fea8d95eb475fdd66f019cd67050c0c383409c0667:0x0',
          '0xd8fcef10d92024e220bc314a216b9f1decca2f05138d6592a280ad3bb5c0d922:0x0',
          '0xe7797d33ca22ebe3052b273307ccc4472ac57747dcb70d5249efea4957f04f73:0x0',
          '0x2e4d2051d9d5182aa2d9d8360d55a9629e964a8a1562485f928963f39932563d:0x0',
          '0x79f810935bf3ac47bc97c50c78527d71cacc9594ec148eeb294159f6ced0483b:0x0',
          '0x27bf1271e34d3b89b8908302b1b52122cd4aabc9b05559c1f347ff1fdc943a12:0x0',
          '0x5d573c5fb16adaa17c42c7936fcfd7105818e4ef4bc613d4b6062698182500a6:0x0',
          '0x6204bf05f0b76e0f57eeda3e34773d0b75b9c8fbc4dec329b5a5e09b6fa418ee:0x0',
          '0xad5be28bad16f4792cc0dc9375b96b74721aafa0383a978ec24ad2ced05cfd16:0x0',
          '0x715a0ad3a91a8e88ae31998aa667e02c973da57f1a287e21dbe4dfcf9f133b65:0x0',
          '0x83c92b4592a287cfa76b15c1d0dec0abd7f487b201a1720f3004d1d742a5e581:0x0',
          '0xe763055974a3c1c58a9a8c6f14cd5d0251f26fbfc4f1dd86319411e8794f8889:0x0',
          '0xe0732a33f99598399e0d1bdeaa6ee96b9f0fca39651626a30b0bafa883a12419:0x0',
          '0xf8168a6392c0691293ec803cd599b3fbc631cf18ad9102dd35c6225f110ba29f:0x0',
          '0xefff789561ce58884324454924e62c1567e70e835c657b54df9a636f95029722:0x0',
          '0x21c7b033b9eb7eb4f4b28783a77447acc8a284b83dc99a353794175ee5c50de8:0x0',
          '0x1414ed5987b243661f6f911fab762b08d84146be46e2950d3f7e20f13df1f6f6:0x0',
          '0x418de4600629116373b24becdcab626f19d113a6093a75a5cef54a695714a20a:0x0',
          '0xd223e96ee030c303c31d79710ea19c7347a04f4b44ca4551c3342ce119e86132:0x0',
          '0xec2df4da6b567c7be7f698e1895be815626c6b5e504930d1c5b1431792465784:0x0',
          '0xcac45b975c8c52ca6199f39de541c0c069556fd54640f4b2838946344f42ce6d:0x0',
          '0x2f8b991d647b91c931eb32b224c5693991266ed10c89326795f5b71e22a57bea:0x0',
          '0x1ba483627e1dc86c2054a9a7c3ff34df116b2446f1c3c8c0fc70e2f9daf63a1f:0x0',
          '0xb65cf4b3f9705253dacc74a83589024e9f751ac3b2cef41d9dfe075b957c5477:0x0',
          '0x9ffa6b826ed3ab1f5fa8f32ee743b4820682897b671dd96f4fea414e04ec3ecc:0x0',
          '0xbd629504d74fda29a8b9187dc55a4a675c791d25a501862446c4c1d8a1ede2de:0x0',
          '0xc26347679c6f9c321af89838cac070c3a87d4280ed0054fbdd46d94a20683a8e:0x0',
          '0xedd3f3dde6f4253f32b4a24f3c95d9824f546732f51e67447580d3a590b1468e:0x0',
          '0x30b3d64d1df36113707f0918d406c3d79482ecc8e22439121cebc458c8960fbe:0x0',
          '0x6cac3ce5884577e922afe944e9bf05887e7ab3c847310eb79e6f39cd716cc307:0x0',
          '0xbc2a834cbb5b40f5cb47bd3f328297ca851a0c0628be06b2d6a43423750ed0aa:0x0',
          '0x75143c1c6e64b01d45122bfa5db70cc5dbb90e945e1c7c781c73363b5e3fb4e0:0x0',
          '0x6fb324d629f69d1d011015325559bd1a3f58cd2bd0e2dce23b006ea85eade376:0x0',
          '0xb5c70400545feef1c591c072b386e663805d984ecc90c9ebd282f39990a7cf17:0x0',
        ],
      },
    },
    {
      btc: {
        fee: 693,
        feeRate: 1,
        psbtHex:
          '70736274ff0100fd0d02020000000a0ace96fdfb046496ee8c82123f96c93897c1995faf2118c068a80dd65799582e0000000000ffffffff0d141bf642249d38ae12997df4ab7e580e329d2efeb839d6944c9a57b42fc83a0000000000ffffffff8f68f88eda845f9dff7b34c77c3059d192892e14abb805cf9508e6c08ca795d20000000000ffffffffa1ae6695af5c3bb5e09081dd1a01921ccbed183e0bae6625179795d8f937cef60000000000ffffffffa4d8d33b6e21ce04d07df866fc1f47ba06513790ba823effc139bbeb9d9618440000000000ffffffffb3ff51158e25b4a18260b26894a979f7a9878bcd7dfb2e141e9a8d8a5b48167f0000000000ffffffffb6d6c5383b584421f68d287fda9f1e95016535f354d6bde0a6bcbdde322ceef10000000000ffffffffd8c59510194adb47af2fe0bc4357fc7ee0c02dc0847349f2301245c39d745d2c0000000000ffffffffdb01b373d54b95ee77dbd69b1896a0991063d6baa75a3256f6cd85763fa3675c0000000000fffffffff2bb706291162c8f964f3d40a79b8ee6380876e0ffbcedad6458d73b8f37ad6d0000000000ffffffff030000000000000000226a2027b431806c81ab81c42dd4908e1fb3cbe9eb7e8f248b05a38c904b7f5e4063cd220200000000000016001497b7383f7c10b415a8963f4b35c1afa505fff3667d1000000000000016001497b7383f7c10b415a8963f4b35c1afa505fff366000000000001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e92710001012b2202000000000000225120338cde9ca6368a354819667c7118cfbfdb7413d1252ff0dd5c6c44fe16097b8801172075ac94ab03c0d2a9f6a9c37dfb2ada56313da77e223060e92393b29fa93e927100000000',
      },
      ckb: {
        virtualTxResult: {
          ckbRawTx: {
            cellDeps: [
              {
                depType: 'code',
                outPoint: {
                  index: '0x0',
                  txHash: '0xf1de59e973b85791ec32debbba08dff80c63197e895eb95d67fc1e9f6b413e00',
                },
              },
              {
                depType: 'code',
                outPoint: {
                  index: '0x1',
                  txHash: '0xf1de59e973b85791ec32debbba08dff80c63197e895eb95d67fc1e9f6b413e00',
                },
              },
              {
                depType: 'code',
                outPoint: {
                  index: '0x0',
                  txHash: '0xbf6fb538763efec2a70a6a3dcb7242787087e1030c4e7d86585bc63a9d337f5f',
                },
              },
            ],
            headerDeps: [],
            inputs: [
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0x2ac48fd1b5db05851b756b6536f63f080598a8962ca365e20991b86ae547d456',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0xa01db6b79bd41ab7adf4b6f4e10b9a70e14489c109b218d3c6f24770eb5d3000',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0x4fcac5d05e7cbfc7352ade62e44f78cca09450c419fb39b3af05f94f02a48210',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0x5860c0a6a834e0bb2dfbc8d5f4c1885cbbe3367285f5dfb7d464fa042031d17c',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0xd30143cc94d6fdbb656db10a7635e936929febebc9e1424d163ab36a9041e9ba',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0xa4c06a0f9be53d5416f8fe34d7be1a5229a8a2515e3814b6b1ebf18ee11fd032',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0xa75bca0eaa472a83b9a155d4c75dbc3c0e846b7a841fd143ac051c2c07e4aa38',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0xdc0c3056e70b4fe64eda00cdc1fd6b2ae435871608b9fbb75efd13a3e78b496e',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0xd7d8aa87e70834cbf1d4cf95767381471bdfd16b2d9a916d0927b7b81c3d134f',
                },
                since: '0x0',
              },
              {
                previousOutput: {
                  index: '0x0',
                  txHash: '0x3b0d7d2072c86a2b6f72a1290a70c48f451c1f290adc207e063f8ca3f3edd2b0',
                },
                since: '0x0',
              },
            ],
            outputs: [
              {
                capacity: '0x3ae7f8c71f',
                lock: {
                  args: '0x010000000000000000000000000000000000000000000000000000000000000000000000',
                  codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',
                  hashType: 'type',
                },
                type: {
                  args: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
                  codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
                  hashType: 'type',
                },
              },
            ],
            outputsData: ['0x00e40b54020000000000000000000000'],
            version: '0x0',
            witnesses: ['0xFF', '0xFF', '0xFF', '0xFF', '0xFF', '0xFF', '0xFF', '0xFF', '0xFF', '0xFF'],
          },
          commitment: '27b431806c81ab81c42dd4908e1fb3cbe9eb7e8f248b05a38c904b7f5e4063cd',
          needPaymasterCell: false,
          sumInputsCapacity: '0x3ae7f9a200',
        },
      },
      summary: {
        cellCount: 10,
        cellIds: [
          '0xdc0c3056e70b4fe64eda00cdc1fd6b2ae435871608b9fbb75efd13a3e78b496e:0x0',
          '0xd30143cc94d6fdbb656db10a7635e936929febebc9e1424d163ab36a9041e9ba:0x0',
          '0x3b0d7d2072c86a2b6f72a1290a70c48f451c1f290adc207e063f8ca3f3edd2b0:0x0',
          '0xd7d8aa87e70834cbf1d4cf95767381471bdfd16b2d9a916d0927b7b81c3d134f:0x0',
          '0xa4c06a0f9be53d5416f8fe34d7be1a5229a8a2515e3814b6b1ebf18ee11fd032:0x0',
          '0x2ac48fd1b5db05851b756b6536f63f080598a8962ca365e20991b86ae547d456:0x0',
          '0xa01db6b79bd41ab7adf4b6f4e10b9a70e14489c109b218d3c6f24770eb5d3000:0x0',
          '0x4fcac5d05e7cbfc7352ade62e44f78cca09450c419fb39b3af05f94f02a48210:0x0',
          '0xa75bca0eaa472a83b9a155d4c75dbc3c0e846b7a841fd143ac051c2c07e4aa38:0x0',
          '0x5860c0a6a834e0bb2dfbc8d5f4c1885cbbe3367285f5dfb7d464fa042031d17c:0x0',
        ],
        utxoCount: 10,
        utxoIds: [
          '2c5d749dc3451230f2497384c02dc0e07efc5743bce02faf47db4a191095c5d8:0',
          '4418969debbb39c1ff3e82ba90375106ba471ffc66f87dd004ce216e3bd3d8a4:0',
          '6dad378f3bd75864adedbcffe0760838e68e9ba7403d4f968f2c16916270bbf2:0',
          '5c67a33f7685cdf656325aa7bad6631099a096189bd6db77ee954bd573b301db:0',
          '7f16485b8a8d9a1e142efb7dcd8b87a9f779a99468b26082a1b4258e1551ffb3:0',
          '2e589957d60da868c01821af5f99c19738c9963f12828cee966404fbfd96ce0a:0',
          '3ac82fb4579a4c94d639b8fe2e9d320e587eabf47d9912ae389d2442f61b140d:0',
          'd295a78cc0e60895cf05b8ab142e8992d159307cc7347bff9d5f84da8ef8688f:0',
          'f1ee2c32debdbca6e0bdd654f3356501951e9fda7f288df62144583b38c5d6b6:0',
          'f6ce37f9d89597172566ae0b3e18edcb1c92011add8190e0b53b5caf9566aea1:0',
        ],
        xudtAssets: {
          '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e': {
            amount: BigInt(10000000000),
            cellCount: 10,
            utxoCount: 10,
          },
        },
        xudtCellCount: 10,
        xudtCellIds: [
          '0xdc0c3056e70b4fe64eda00cdc1fd6b2ae435871608b9fbb75efd13a3e78b496e:0x0',
          '0xd30143cc94d6fdbb656db10a7635e936929febebc9e1424d163ab36a9041e9ba:0x0',
          '0x3b0d7d2072c86a2b6f72a1290a70c48f451c1f290adc207e063f8ca3f3edd2b0:0x0',
          '0xd7d8aa87e70834cbf1d4cf95767381471bdfd16b2d9a916d0927b7b81c3d134f:0x0',
          '0xa4c06a0f9be53d5416f8fe34d7be1a5229a8a2515e3814b6b1ebf18ee11fd032:0x0',
          '0x2ac48fd1b5db05851b756b6536f63f080598a8962ca365e20991b86ae547d456:0x0',
          '0xa01db6b79bd41ab7adf4b6f4e10b9a70e14489c109b218d3c6f24770eb5d3000:0x0',
          '0x4fcac5d05e7cbfc7352ade62e44f78cca09450c419fb39b3af05f94f02a48210:0x0',
          '0xa75bca0eaa472a83b9a155d4c75dbc3c0e846b7a841fd143ac051c2c07e4aa38:0x0',
          '0x5860c0a6a834e0bb2dfbc8d5f4c1885cbbe3367285f5dfb7d464fa042031d17c:0x0',
        ],
      },
    },
  ],
};

export default {
  xudtTypeArgs: '0xc3fcf12ef840771b1eac4709d61d93be7b13424c16fefd0b2071c204bdeb9f4e',
  sender: {
    account,
    btcUtxos,
    utxosByUtxoId,
    rgbppCells,
    rgbppCellsByUtxoId,
    rgbppCellsByLockHash,
    liveCellsByOutPoints,
    liveCellByOutPoint,
  },
  receiver: {
    account: receiverAccount,
    btcUtxos: receiverBtcUtxos,
  },
  buildResult,
};


================================================
File: packages/rgbpp/tests/shared/account.ts
================================================
import {
  NetworkType,
  ECPair,
  bitcoin,
  toXOnly,
  remove0x,
  tweakSigner,
  isP2trScript,
  isP2wpkhScript,
  networkTypeToNetwork,
} from '@rgbpp-sdk/btc';

export interface BtcAccount {
  address: string;
  scriptPubkey: string;
  keyPair: bitcoin.Signer;
  payment: bitcoin.Payment;
}

export function createP2wpkhAccount(privateKey: string, networkType: NetworkType): BtcAccount {
  const privateKeyBuffer = Buffer.from(remove0x(privateKey), 'hex');
  const keyPair = ECPair.fromPrivateKey(privateKeyBuffer);
  const payment = bitcoin.payments.p2wpkh({
    pubkey: keyPair.publicKey,
    network: networkTypeToNetwork(networkType),
  });

  return {
    keyPair,
    payment,
    address: payment.address!,
    scriptPubkey: payment.output!.toString('hex'),
  };
}

export function createP2trAccount(privateKey: string, networkType: NetworkType): BtcAccount {
  const privateKeyBuffer = Buffer.from(remove0x(privateKey), 'hex');
  const keyPair = ECPair.fromPrivateKey(privateKeyBuffer);
  const payment = bitcoin.payments.p2tr({
    internalPubkey: toXOnly(keyPair.publicKey),
    network: networkTypeToNetwork(networkType),
  });

  return {
    keyPair,
    payment,
    address: payment.address!,
    scriptPubkey: payment.output!.toString('hex'),
  };
}

export function signPsbt(psbt: bitcoin.Psbt, account: BtcAccount): bitcoin.Psbt {
  // Create a tweaked signer for P2TR
  const tweakedSigner = tweakSigner(account.keyPair, {
    network: account.payment.network,
  });

  // Sign each input
  psbt.data.inputs.forEach((input, index) => {
    if (input.witnessUtxo) {
      const script = input.witnessUtxo.script.toString('hex');
      if (isP2wpkhScript(script) && script === account.scriptPubkey) {
        psbt.signInput(index, account.keyPair);
      }
      if (isP2trScript(script) && script === account.scriptPubkey) {
        psbt.signInput(index, tweakedSigner);
      }
    }
  });

  return psbt;
}

export function signAndFinalizePsbt(psbt: bitcoin.Psbt, accounts: BtcAccount[]): bitcoin.Psbt {
  for (const account of accounts) {
    signPsbt(psbt, account);
  }

  return psbt.finalizeAllInputs();
}


================================================
File: packages/rgbpp/tests/shared/env.ts
================================================
import { DataSource, NetworkType, networkTypeToConfig } from '@rgbpp-sdk/btc';
import { BtcAssetsApi } from '@rgbpp-sdk/service';
import { Collector } from '@rgbpp-sdk/ckb';
import { z } from 'zod';

const EnvSchema = z
  .object({
    VITE_IS_MAINNET: z
      .enum(['true', 'false'])
      .default('false')
      .transform((v) => v === 'true'),
    VITE_CKB_NODE_URL: z.string().url(),
    VITE_CKB_INDEXER_URL: z.string().url(),
    VITE_BTC_SERVICE_URL: z.string().url(),
    VITE_BTC_SERVICE_TOKEN: z.string(),
    VITE_BTC_SERVICE_ORIGIN: z.string(),
  })
  .transform((env) => {
    return {
      IS_MAINNET: env.VITE_IS_MAINNET,
      CKB_NODE_URL: env.VITE_CKB_NODE_URL,
      CKB_INDEXER_URL: env.VITE_CKB_INDEXER_URL,
      BTC_SERVICE_URL: env.VITE_BTC_SERVICE_URL,
      BTC_SERVICE_TOKEN: env.VITE_BTC_SERVICE_TOKEN,
      BTC_SERVICE_ORIGIN: env.VITE_BTC_SERVICE_ORIGIN,
    };
  });

/**
 * Common
 */
export const env = EnvSchema.parse(process.env);
export const isMainnet = env.IS_MAINNET;

/**
 * BTC
 */
export const btcNetworkType = isMainnet ? NetworkType.MAINNET : NetworkType.TESTNET;
export const btcService = BtcAssetsApi.fromToken(env.BTC_SERVICE_URL, env.BTC_SERVICE_TOKEN, env.BTC_SERVICE_ORIGIN);
export const btcSource = new DataSource(btcService, btcNetworkType);
export const btcConfig = networkTypeToConfig(btcNetworkType);

/**
 * CKB
 */
export const ckbCollector = new Collector({
  ckbNodeUrl: env.CKB_NODE_URL,
  ckbIndexerUrl: env.CKB_INDEXER_URL,
});


================================================
File: packages/service/README.md
================================================
# @rgbpp-sdk/service

## About

The `@rgbpp-sdk/service` package provides a wrapped class to interact with [`Bitcoin/RGB++ Assets Service`](https://github.com/ckb-cell/btc-assets-api) (BtcAssetsApi). It offers various features for interacting with Bitcoin and RGB++ assets:

- **Retrieve Blockchain Information** including Bitcoin chain info, blocks, headers, transactions, addresses, and RGB++ assets
- **Handle transactions** by posting to `/bitcoin/v1/transaction` or `/rgbpp/v1/transaction/ckb-tx`
- **Generate Bitcoin transaction Proof** via `/rgbpp/v1/btc-spv/proof` through [Bitcoin SPV Service on CKB](https://github.com/ckb-cell/ckb-bitcoin-spv-service)
- Simplify RGB++ assets workflows with **RGB++ CKB transaction Queue** and cron jobs
- More detailed API documentation can be found on [Testnet](https://api.testnet.rgbpp.io/docs), [Signet](https://api.signet.rgbpp.io/docs) and [Mainnet](https://api.rgbpp.io/docs)

> [!NOTE]
> [`Bitcoin/RGB++ Assets Service`](https://github.com/ckb-cell/btc-assets-api) is an open-source project designed to streamline the transaction workflow for Bitcoin and RGB++ Assets. Developers have the option to enhance it by implementing its features by themselves without limitations. For those who prefer to deploy their own `Bitcoin/RGB++ Assets Service`, please follow the instructions at the [Deployment](https://github.com/ckb-cell/btc-assets-api#deployment) section in the btc-assets-api repository.

## Installation

```bash
# Install via npm:
$ npm i @rgbpp-sdk/service
# Install via yarn:
$ yarn add @rgbpp-sdk/service
# Install via pnpm:
$ pnpm add @rgbpp-sdk/service
```

## Get started

### Get a service URL

You can start using the `Bitcoin/RGB++ Assets Service` by accessing one of our deployed services. For those who prefer to deploy their own `Bitcoin/RGB++ Assets Service`, the documentation for deployment can be found at: [Deployment - ckb-cell/btc-assets-api](https://github.com/ckb-cell/btc-assets-api#deployment).

- Testnet: https://api.testnet.rgbpp.io
- Signet: https://api.signet.rgbpp.io
- Mainnet: https://api.rgbpp.io

### Get an access token

You need an access token to interact with the service. The testnet/signet services are currently free to access, you can get an access token of the target network through the following documentation URLs:

- Testnet: [/token/generate](https://api.testnet.rgbpp.io/docs/static/index.html#/Token/post_token_generate)
- Signet: [/token/generate](https://api.signet.rgbpp.io/docs/static/index.html#/Token/post_token_generate)

As to the mainnet service, it's currently limited to verified apps only. When your app development is ready on testnet, and requires a mainnet access token, please email us at `f@cell.studio` to request a mainnet JWT token. In the email, please provide the following information about your app:

- Name: Your app name, e.g. "rgbpp-app"
- Domain: Your app domain, e.g. "rgbpp.app"

### Initialize the service

#### Browser

Initialize the service with the URL and your access token in browser environment:

```typescript
import { BtcAssetsApi } from '@rgbpp-sdk/service';

const service = BtcAssetsApi.fromToken('https://api.testnet.rgbpp.io', 'your_access_token');
```

#### Node.js

When initializing the service in Node.js, you should also pass the `origin` prop:

```typescript
import { BtcAssetsApi } from '@rgbpp-sdk/service';

const service = BtcAssetsApi.fromToken('https://api.testnet.rgbpp.io', 'your_access_token', 'https://your_app.origin');
```

The `origin` prop is used to verify your token's corresponding `domain`.
For example, if your token was generated in the domain of `your.app`,
you should pass `https://your.app` as the `origin` prop.
Otherwise, the service will reject your request.

Note the format difference `domain` and `origin`:

- `domain`: `your.app`, without protocol (`https://`, `http://`, etc.)
- `origin`: `https://your.app`, with protocol `https://`

### Interact with the service

Once initialized, you can start accessing the service:

```typescript
// Query the balance of an address
const res = await service.getBalance('tb1qm06rvrq8jyyckzc5v709u7qpthel9j4d9f7nh3');

console.log(res);
// {
//   address: 'tb1qm06rvrq8jyyckzc5v709u7qpthel9j4d9f7nh3',
//   satoshi: 72921,
//   pending_satoshi: 0,
//   utxo_count: 5
// }
```

All available APIs can be found in the [Types](#types) section.

### Handling service errors

You can identify the error by its `code` and `message`, or by its detailed `context`:

```ts
import { BtcAssetsApiError, ErrorCodes } from '@rgbpp-sdk/service';

try {
...
} catch (e) {
  if (e instanceof BtcAssetsApiError) {
    // check error code
    console.log(e.code === ErrorCodes.ASSETS_API_UNAUTHORIZED); // true
    // print the whole error
    console.log(JSON.stringify(e));
    /*{
      "message": "BtcAssetsAPI unauthorized, please check your token/origin: (401) Authorization token is invalid: The token header is not a valid base64url serialized JSON.",
      "code": 2,
      "context": {
        "request": {
          "url": "https://btc-assets-api.url/bitcoin/v1/info"
        },
        "response": {
          "status": 401,
            "data": {
            "message": "Authorization token is invalid: The token header is not a valid base64url serialized JSON."
          }
        }
      }
    }*/
  }
}
```

## Types

### BtcAssetsApi

```typescript
declare class BtcAssetsApi extends BtcAssetsApiBase implements BtcApis, RgbppApis {
  static fromToken(baseUrl: string, token: string, origin?: string): BtcAssetsApi;
}
```

### BtcAssetsApiBase

```typescript
declare class BtcAssetsApiBase implements BaseApis {}
```

### BaseApis

```typescript
interface BaseApis {
  request<T>(route: string, options?: BaseApiRequestOptions): Promise<T>;
  post<T>(route: string, options?: BaseApiRequestOptions): Promise<T>;
  generateToken(): Promise<BtcAssetsApiToken>;
  init(force?: boolean): Promise<void>;
}

interface BaseApiRequestOptions extends RequestInit {
  params?: Record<string, any>;
  method?: 'GET' | 'POST';
  requireToken?: boolean;
  allow404?: boolean;
}

interface BtcAssetsApiToken {
  token: string;
}
```

### BtcApis

```typescript
interface BtcApis {
  getBtcBlockchainInfo(): Promise<BtcApiBlockchainInfo>;
  getBtcBlockByHash(blockHash: string): Promise<BtcApiBlock>;
  getBtcBlockHeaderByHash(blockHash: string): Promise<BtcApiBlockHeader>;
  getBtcBlockHashByHeight(blockHeight: number): Promise<BtcApiBlockHash>;
  getBtcBlockTransactionIdsByHash(blockHash: number): Promise<BtcApiBlockTransactionIds>;
  getBtcRecommendedFeeRates(): Promise<BtcApiRecommendedFeeRates>;
  getBtcBalance(address: string, params?: BtcApiBalanceParams): Promise<BtcApiBalance>;
  getBtcUtxos(address: string, params?: BtcApiUtxoParams): Promise<BtcApiUtxo[]>;
  getBtcTransactions(address: string, params?: BtcApiTransactionParams): Promise<BtcApiTransaction[]>;
  getBtcTransaction(txId: string): Promise<BtcApiTransaction>;
  sendBtcTransaction(txHex: string): Promise<BtcApiSentTransaction>;
}

interface BtcApiBlockchainInfo {
  chain: string;
  blocks: number;
  bestblockhash: number;
  difficulty: number;
  mediantime: number;
}

interface BtcApiBlock {
  id: string;
  height: number;
  version: number;
  timestamp: number;
  tx_count: number;
  size: number;
  weight: number;
  merkle_root: string;
  previousblockhash: string;
  mediantime: number;
  nonce: number;
  bits: number;
  difficulty: number;
}

interface BtcApiBlockHash {
  hash: string;
}

interface BtcApiBlockHeader {
  header: string;
}

interface BtcApiBlockTransactionIds {
  txids: string[];
}

interface BtcApiRecommendedFeeRates {
  fastestFee: number;
  halfHourFee: number;
  hourFee: number;
  economyFee: number;
  minimumFee: number;
}

interface BtcApiBalanceParams {
  min_satoshi?: number;
  no_cache?: boolean;
}
interface BtcApiBalance {
  address: string;
  // @deprecated Use available_satoshi instead
  satoshi: number;
  total_satoshi: number;
  available_satoshi: number;
  pending_satoshi: number;
  rgbpp_satoshi: number;
  dust_satoshi: number;
  utxo_count: number;
}

interface BtcApiUtxoParams {
  only_non_rgbpp_utxos?: boolean;
  only_confirmed?: boolean;
  min_satoshi?: number;
  no_cache?: boolean;
}
interface BtcApiUtxo {
  txid: string;
  vout: number;
  value: number;
  status: {
    confirmed: boolean;
    block_height: number;
    block_hash: string;
    block_time: number;
  };
}

interface BtcApiSentTransaction {
  txid: string;
}

interface BtcApiTransactionParams {
  after_txid?: string;
}

interface BtcApiTransaction {
  txid: string;
  version: number;
  locktime: number;
  vin: {
    txid: string;
    vout: number;
    prevout: {
      scriptpubkey: string;
      scriptpubkey_asm: string;
      scriptpubkey_type: string;
      scriptpubkey_address: string;
      value: number;
    };
    scriptsig: string;
    scriptsig_asm: string;
    witness: string[];
    is_coinbase: boolean;
    sequence: number;
  }[];
  vout: {
    scriptpubkey: string;
    scriptpubkey_asm: string;
    scriptpubkey_type: string;
    scriptpubkey_address: string;
    value: number;
  }[];
  weight: number;
  size: number;
  fee: number;
  status: {
    confirmed: boolean;
    block_height: number;
    block_hash: string;
    block_time: number;
  };
}
```

### RgbppApis

```typescript
interface RgbppApis {
  getRgbppPaymasterInfo(): Promise<RgbppApiPaymasterInfo>;
  getRgbppTransactionHash(btcTxId: string): Promise<RgbppApiCkbTransactionHash>;
  getRgbppTransactionState(btcTxId: string): Promise<RgbppApiTransactionState>;
  getRgbppAssetsByBtcTxId(btcTxId: string): Promise<RgbppCell[]>;
  getRgbppAssetsByBtcUtxo(btcTxId: string, vout: number): Promise<RgbppCell[]>;
  getRgbppAssetsByBtcAddress(btcAddress: string, params?: RgbppApiAssetsByAddressParams): Promise<RgbppCell[]>;
  getRgbppBalanceByBtcAddress(btcAddress: string, params?: RgbppApiBalanceByAddressParams): Promise<RgbppApiBalance>;
  getRgbppActivityByBtcAddress(btcAddress: string, params?: RgbppApiActivityByAddressParams): Promise<RgbppApiActivity>;
  getRgbppSpvProof(btcTxId: string, confirmations: number): Promise<RgbppApiSpvProof>;
  sendRgbppCkbTransaction(payload: RgbppApiSendCkbTransactionPayload): Promise<RgbppApiTransactionState>;
  retryRgbppCkbTransaction(payload: RgbppApiRetryCkbTransactionPayload): Promise<RgbppApiTransactionRetry>;
}

type RgbppTransactionState = 'completed' | 'failed' | 'delayed' | 'active' | 'waiting';

interface RgbppApiPaymasterInfo {
  btc_address: string;
  fee: number;
}

interface RgbppApiCkbTransactionHash {
  txhash: string;
}

interface RgbppApiTransactionStateParams {
  with_data?: boolean;
}

interface RgbppApiTransactionState {
  state: RgbppTransactionState;
  attempts: number;
  failedReason?: string;
  data?: {
    txid: string;
    ckbVirtualResult: {
      ckbRawTx: CKBComponents.RawTransaction;
      needPaymasterCell: boolean;
      sumInputsCapacity: string;
      commitment: string;
    };
  };
}

interface RgbppCell extends Cell {
  typeHash?: Hash;
}

interface RgbppApiAssetsByAddressParams {
  type_script?: string;
  no_cache?: boolean;
}

interface RgbppApiBalanceByAddressParams {
  type_script?: string;
  no_cache?: boolean;
}
interface RgbppApiBalance {
  address: string;
  xudt: RgbppApiXudtBalance[];
}
interface RgbppApiXudtBalance {
  name: string;
  decimal: number;
  symbol: string;
  total_amount: string;
  available_amount: string;
  pending_amount: string;
  type_hash: string;
  type_script: Script;
}

interface RgbppApiActivityByAddressParams {
  rgbpp_only?: boolean;
  type_script?: string;
  after_btc_txid?: string;
}
interface RgbppApiActivity {
  address: string;
  cursor: string;
  txs: {
    btcTx: BtcApiTransaction;
    isRgbpp: boolean;
    isomorphicTx?: {
      ckbVirtualTx?: CKBComponents.RawTransaction;
      ckbTx?: CKBComponents.Transaction;
      inputs?: CKBComponents.CellOutput[];
      outputs?: CKBComponents.CellOutput[];
      status: {
        confirmed: boolean;
      };
    };
  }[];
}

interface RgbppApiSpvProof {
  proof: string;
  spv_client: {
    tx_hash: string;
    index: string;
  };
}

interface RgbppApiSendCkbTransactionPayload {
  btc_txid: string;
  // Support ckbVirtualTxResult and it's JSON string as request parameter
  ckb_virtual_result: RgbppApiSendCkbVirtualResult | string;
}
interface RgbppApiSendCkbVirtualResult {
  ckbRawTx: CKBComponents.RawTransaction;
  needPaymasterCell: boolean;
  sumInputsCapacity: string;
  commitment: string;
}

interface RgbppApiRetryCkbTransactionPayload {
  btc_txid: string;
}

interface RgbppApiTransactionRetry {
  success: boolean;
  state: RgbppTransactionState;
}

```


================================================
File: packages/service/CHANGELOG.md
================================================
# @rgbpp-sdk/service

## 0.7.0

### Minor Changes

- [#291](https://github.com/utxostack/rgbpp-sdk/pull/291): Support RGB++ compatible xUDT assets([@duanyytop](https://github.com/duanyytop))
  - Add `assets/type` API to the service package

- [#293](https://github.com/utxostack/rgbpp-sdk/pull/293): Add offline btc data source & ckb collector ([@fghdotio](https://github.com/fghdotio))

- [#294](https://github.com/utxostack/rgbpp-sdk/pull/294): Add UTXOAirdropBadge Testnet deployment information ([@duanyytop](https://github.com/duanyytop))

- [#298](https://github.com/utxostack/rgbpp-sdk/pull/298): Implement getRgbppSpvProof for OfflineBtcAssetsDataSource ([@fghdotio](https://github.com/fghdotio))

- [#303](https://github.com/utxostack/rgbpp-sdk/pull/303): Add offline mode support for compatible xUDT type scripts ([@fghdotio](https://github.com/fghdotio))

### Patch Changes

- [#305](https://github.com/ckb-cell/rgbpp-sdk/pull/305): Upgrade ckb-sdk-js version ([@duanyytop](https://github.com/duanyytop))

## 0.6.0

### Minor Changes

- [#281](https://github.com/ckb-cell/rgbpp-sdk/pull/281): Upgrade ckb-sdk-js to fix esm and commonjs issues ([@duanyytop](https://github.com/duanyytop))

- [#246](https://github.com/ckb-cell/rgbpp-sdk/pull/246): Export ESM packages ([@duanyytop](https://github.com/duanyytop))

## v0.5.0

### Minor Changes

- [#248](https://github.com/ckb-cell/rgbpp-sdk/pull/248): Add `type_script` to the response of `/rgbpp/v1/address/{btc_address}/balance` API, and add `typeHash` to the response of rgbpp assets-related APIs ([@ShookLyngs](https://github.com/ShookLyngs))

## v0.4.0

### Minor Changes

- [#222](https://github.com/ckb-cell/rgbpp-sdk/pull/222): Add BtcAssetsApi.getRgbppApiBalanceByAddress() API for querying RGBPP XUDT balances by a BTC address ([@ShookLyngs](https://github.com/ShookLyngs))

## v0.3.0

### Minor Changes

- [#208](https://github.com/ckb-cell/rgbpp-sdk/pull/208): Adapt btc-assets-api#154, adding new props and return values to the /balance and /unspent APIs ([@ShookLyngs](https://github.com/ShookLyngs))

  - Add `available_satoshi` and `total_satoshi` to the BtcAssetsApi.getBtcBalance() API
  - Add `only_non_rgbpp_utxos` to the props of the BtcAssetsApi.getBtcUtxos() API
  - Remove `service.getRgbppAssetsByBtcUtxo()` lines from the DataCollector.collectSatoshi()
  - Remove `hasRgbppAssets` related variables/function from the DataCache

## v0.2.0

### Minor Changes

- [#165](https://github.com/ckb-cell/rgbpp-sdk/pull/165): Replace all "void 0" to "undefined" in the btc/service lib ([@ShookLyngs](https://github.com/ShookLyngs))

### Patch Changes

- [#181](https://github.com/ckb-cell/rgbpp-sdk/pull/181): add no_cache params to btc/rgbpp service api ([@ahonn](https://github.com/ahonn))

## v0.1.0

- Release @rgbpp-sdk/service for communicating with the [btc-assets-api](https://github.com/ckb-cell/btc-assets-api), providing APIs to query data from or post transactions to the service. Read the docs for more information: https://github.com/ckb-cell/rgbpp-sdk/tree/develop/packages/service


================================================
File: packages/service/package.json
================================================
{
  "name": "@rgbpp-sdk/service",
  "version": "0.6.0",
  "scripts": {
    "test": "vitest",
    "build": "tsup",
    "lint": "tsc && eslint '{src,tests}/**/*.{js,ts}' && prettier --check '{src,tests}/**/*.{js,ts}'",
    "lint:fix": "tsc && eslint --fix '{src,tests}/**/*.{js,ts}' && prettier --write '{src,tests}/**/*.{js,ts}'"
  },
  "sideEffects": false,
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "import": {
        "types": "./dist/index.d.mts",
        "default": "./dist/index.mjs"
      },
      "require": {
        "types": "./dist/index.d.ts",
        "default": "./dist/index.js"
      }
    },
    "./package.json": "./package.json"
  },
  "files": [
    "src",
    "dist"
  ],
  "dependencies": {
    "@ckb-lumos/codec": "0.22.2",
    "@ckb-lumos/base": "0.22.2",
    "@nervosnetwork/ckb-types": "0.109.5",
    "lodash": "^4.17.21"
  },
  "publishConfig": {
    "access": "public"
  }
}


================================================
File: packages/service/tsconfig.json
================================================
{
  "compilerOptions": {
    "moduleResolution": "Bundler",
    "module": "ESNext",
    "target": "ESNext",
    "lib": ["ESNext", "DOM"],
    "strict": true,
    "noEmit": true,
    "allowJs": true,
    "sourceMap": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "strictNullChecks": true,
    "resolveJsonModule": true,
    "isolatedModules": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist"]
}


================================================
File: packages/service/tsup.config.ts
================================================
import { defineConfig } from 'tsup';

export default defineConfig({
  name: '@rgbpp-sdk/service',
  dts: true,
  clean: true,
  sourcemap: true,
  format: ['esm', 'cjs'],
  entry: ['src/index.ts'],
});


================================================
File: packages/service/.env.example
================================================
VITE_BTC_SERVICE_URL=    # URL of the service
VITE_BTC_SERVICE_TOKEN=  # JWT token to access the service
VITE_BTC_SERVICE_ORIGIN= # URL representing your token's domain


================================================
File: packages/service/src/ckb-types.d.ts
================================================
/// <reference types="@nervosnetwork/ckb-types/index.d.ts" />


================================================
File: packages/service/src/error.ts
================================================
import { BtcAssetsApiContext } from './types';

export enum ErrorCodes {
  UNKNOWN,

  ASSETS_API_RESPONSE_ERROR,
  ASSETS_API_UNAUTHORIZED,
  ASSETS_API_INVALID_PARAM,
  ASSETS_API_RESOURCE_NOT_FOUND,
  ASSETS_API_RESPONSE_DECODE_ERROR,

  OFFLINE_DATA_SOURCE_METHOD_NOT_AVAILABLE,
  OFFLINE_DATA_SOURCE_SPV_PROOF_NOT_FOUND,
}

export const ErrorMessages = {
  [ErrorCodes.UNKNOWN]: 'Unknown error',

  [ErrorCodes.ASSETS_API_UNAUTHORIZED]: 'BtcAssetsAPI unauthorized, please check your token/origin',
  [ErrorCodes.ASSETS_API_INVALID_PARAM]: 'Invalid param(s) was provided to the BtcAssetsAPI',
  [ErrorCodes.ASSETS_API_RESPONSE_ERROR]: 'BtcAssetsAPI returned an error',
  [ErrorCodes.ASSETS_API_RESOURCE_NOT_FOUND]: 'Resource not found on the BtcAssetsAPI',
  [ErrorCodes.ASSETS_API_RESPONSE_DECODE_ERROR]: 'Failed to decode the response of BtcAssetsAPI',

  [ErrorCodes.OFFLINE_DATA_SOURCE_METHOD_NOT_AVAILABLE]: 'Method not available for offline data source',
  [ErrorCodes.OFFLINE_DATA_SOURCE_SPV_PROOF_NOT_FOUND]: 'SPV proof not found for the given txid and confirmations',
};

export class BtcAssetsApiError extends Error {
  public code = ErrorCodes.UNKNOWN;
  public message: string;
  public context?: BtcAssetsApiContext;

  constructor(payload: { code: ErrorCodes; message?: string; context?: BtcAssetsApiContext }) {
    const message = payload.message ?? ErrorMessages[payload.code] ?? ErrorMessages[ErrorCodes.UNKNOWN];

    super(message);
    this.message = message;
    this.code = payload.code;
    this.context = payload.context;
    Object.setPrototypeOf(this, BtcAssetsApiError.prototype);
  }

  static withComment(code: ErrorCodes, comment?: string, context?: BtcAssetsApiContext): BtcAssetsApiError {
    const prefixMessage = ErrorMessages[code] ?? ErrorMessages[ErrorCodes.UNKNOWN];
    const message = comment ? `${prefixMessage}: ${comment}` : undefined;
    return new BtcAssetsApiError({ code, message, context });
  }
}

export class OfflineBtcAssetsDataSourceError extends Error {
  public code = ErrorCodes.UNKNOWN;

  constructor(errorCode: ErrorCodes, message?: string) {
    const msg = message ?? ErrorMessages[errorCode] ?? ErrorMessages[ErrorCodes.UNKNOWN];
    super(msg);
    this.code = errorCode;
    Object.setPrototypeOf(this, OfflineBtcAssetsDataSourceError.prototype);
  }
}


================================================
File: packages/service/src/index.ts
================================================
export * from './types';
export * from './error';
export * from './utils';
export * from './service';


================================================
File: packages/service/src/utils.ts
================================================
/**
 * Check if target string is a valid domain.
 * @exmaple
 * isDomain('google.com') // => true
 * isDomain('https://google.com') // => false
 * isDomain('localhost') // => false
 * isDomain('localhost', true) // => true
 */
export function isDomain(domain: string, allowLocalhost?: boolean): boolean {
  if (allowLocalhost && domain === 'localhost') {
    return true;
  }
  const regex = /^(?:[-A-Za-z0-9]+\.)+[A-Za-z]{2,}$/;
  return regex.test(domain);
}


================================================
File: packages/service/src/service/base.ts
================================================
import pickBy from 'lodash/pickBy.js';
import { isDomain } from '../utils';
import { BtcAssetsApiError, ErrorCodes } from '../error';
import { BaseApis, BaseApiRequestOptions, BtcAssetsApiToken, BtcAssetsApiContext, Json } from '../types';

export class BtcAssetsApiBase implements BaseApis {
  public url: string;
  public app?: string;
  public domain?: string;
  public origin?: string;
  private token?: string;

  constructor(props: { url: string; app?: string; domain?: string; origin?: string; token?: string }) {
    this.url = props.url;
    this.app = props.app;
    this.domain = props.domain;
    this.origin = props.origin;
    this.token = props.token;

    // Validation
    if (this.domain && !isDomain(this.domain, true)) {
      throw BtcAssetsApiError.withComment(ErrorCodes.ASSETS_API_INVALID_PARAM, 'domain');
    }
  }

  async request<T>(route: string, options?: BaseApiRequestOptions): Promise<T> {
    const { requireToken = true, allow404 = false, method = 'GET', headers, params, ...otherOptions } = options ?? {};
    if (requireToken && !this.token && !(this.app && this.domain)) {
      throw BtcAssetsApiError.withComment(ErrorCodes.ASSETS_API_INVALID_PARAM, 'app, domain');
    }
    if (requireToken && !this.token) {
      await this.init();
    }

    const pickedParams = pickBy(params, (val) => val !== undefined);
    const packedParams = params ? '?' + new URLSearchParams(pickedParams).toString() : '';
    const url = `${this.url}${route}${packedParams}`;
    const res = await fetch(url, {
      method,
      headers: {
        authorization: this.token ? `Bearer ${this.token}` : undefined,
        origin: this.origin,
        ...headers,
      },
      ...otherOptions,
    } as RequestInit);

    let text: string | undefined;
    let json: Json | undefined;
    let ok: boolean = false;
    try {
      text = await res.text();
      json = JSON.parse(text);
      ok = json?.ok ?? res.ok ?? false;
    } catch {
      // do nothing
    }

    let comment: string | undefined;
    const status = res.status;
    const context: BtcAssetsApiContext = {
      request: {
        url,
        params,
        body: tryParseBody(otherOptions.body),
      },
      response: {
        status,
        data: json ?? text,
      },
    };

    if (!json) {
      comment = text ? `(${status}) ${text}` : `${status}`;
    }
    if (json && !ok) {
      const code = json.code ?? json.statusCode ?? json.error?.error?.code ?? res.status;
      const message = json.message ?? (typeof json.error === 'string' ? json.error : json.error?.error?.message);
      if (message) {
        comment = code ? `(${code}) ${message}` : message;
      } else {
        comment = JSON.stringify(json);
      }
    }

    if (status === 200 && !json) {
      throw BtcAssetsApiError.withComment(ErrorCodes.ASSETS_API_RESPONSE_DECODE_ERROR, comment, context);
    }
    if (status === 401) {
      throw BtcAssetsApiError.withComment(ErrorCodes.ASSETS_API_UNAUTHORIZED, comment, context);
    }
    if (status === 404 && !allow404) {
      throw BtcAssetsApiError.withComment(ErrorCodes.ASSETS_API_RESOURCE_NOT_FOUND, comment, context);
    }
    if (status !== 200 && status !== 404 && !allow404) {
      throw BtcAssetsApiError.withComment(ErrorCodes.ASSETS_API_RESPONSE_ERROR, comment, context);
    }
    if (status === 404 && allow404) {
      return undefined as T;
    }

    return json! as T;
  }

  async post<T>(route: string, options?: BaseApiRequestOptions): Promise<T> {
    return this.request(route, {
      method: 'POST',
      ...options,
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
      },
    } as BaseApiRequestOptions);
  }

  async generateToken() {
    if (!this.app || !this.domain) {
      throw BtcAssetsApiError.withComment(ErrorCodes.ASSETS_API_INVALID_PARAM, 'app, domain');
    }

    return this.post<BtcAssetsApiToken>('/token/generate', {
      requireToken: false,
      body: JSON.stringify({
        app: this.app!,
        domain: this.domain!,
      }),
    });
  }

  async init(force?: boolean) {
    // If the token exists and not a force action, do nothing
    if (this.token && !force) {
      return;
    }

    const token = await this.generateToken();
    this.token = token.token;
  }
}

function tryParseBody(body: unknown): Record<string, unknown> | undefined {
  try {
    return typeof body === 'string' ? JSON.parse(body) : undefined;
  } catch {
    return undefined;
  }
}


================================================
File: packages/service/src/service/index.ts
================================================
export * from './base';
export * from './service';
export * from './offline-service';


================================================
File: packages/service/src/service/offline-service.ts
================================================
import { ErrorCodes } from '../error';
import { BtcAssetsApi } from './service';
import { OfflineBtcAssetsDataSourceError } from '../error';

import {
  BtcApiTransaction,
  BtcApiUtxo,
  BtcApiUtxoParams,
  BtcApiTransactionParams,
  BtcApiBalanceParams,
  RgbppApiTransactionStateParams,
  RgbppApiAssetsByAddressParams,
  RgbppApiBalanceByAddressParams,
  RgbppApiActivityByAddressParams,
  RgbppApiSendCkbTransactionPayload,
  RgbppApiRetryCkbTransactionPayload,
  OfflineBtcUtxo,
  BtcApiRecommendedFeeRates,
  RgbppApiSpvProof,
} from '../types';

export interface OfflineBtcData {
  txs: BtcApiTransaction[];
  utxos: OfflineBtcUtxo[];
  rgbppSpvProofs: SpvProofEntry[];
}

export interface SpvProofEntry {
  txid: string;
  confirmations: number;
  proof: RgbppApiSpvProof;
}

/*
 * The offline mode is currently suitable for scenarios where you prefer to manually provide transaction and UTXO data to build BTC transactions.
 * Note that the implemented methods are limited, and the default fee rate is set to 1 sat/vB. It is strongly recommended to provide a real-time
 * BTC fee rate for smoother transaction processing.
 *
 * For access to the full range of functionalities, such as advanced queries or sending transactions, consider switching to BtcAssetsApi.
 */
export class OfflineBtcAssetsDataSource extends BtcAssetsApi {
  // txid -> tx
  private txs: Record<string, BtcApiTransaction>;
  // address -> utxos
  private utxos: Record<string, OfflineBtcUtxo[]>;
  // txid:confirmations -> spv proof
  private rgbppSpvProofs: Record<string, RgbppApiSpvProof>;

  private defaultFee = 1;

  constructor(offlineData: OfflineBtcData) {
    super({ url: 'DUMMY_URL' });

    this.txs = offlineData.txs.reduce(
      (acc, tx) => {
        acc[tx.txid] = tx;
        return acc;
      },
      {} as Record<string, BtcApiTransaction>,
    );

    this.utxos = offlineData.utxos.reduce(
      (acc, utxo) => {
        acc[utxo.address] = [...(acc[utxo.address] ?? []), utxo];
        return acc;
      },
      {} as Record<string, OfflineBtcUtxo[]>,
    );

    this.rgbppSpvProofs = offlineData.rgbppSpvProofs.reduce(
      (acc, proof) => {
        acc[this.spvKey(proof.txid, proof.confirmations)] = proof.proof;
        return acc;
      },
      {} as Record<string, RgbppApiSpvProof>,
    );
  }

  private spvKey(txid: string, confirmations: number) {
    return `${txid}:${confirmations}`;
  }

  getBtcTransaction(txId: string): Promise<BtcApiTransaction> {
    return Promise.resolve(this.txs[txId]);
  }

  getBtcUtxos(address: string, params?: BtcApiUtxoParams): Promise<BtcApiUtxo[]> {
    const addressUtxos = this.utxos[address] || [];
    const { only_non_rgbpp_utxos, only_confirmed, min_satoshi } = params || {};

    return Promise.resolve(
      addressUtxos.filter(
        (utxo) =>
          (!only_non_rgbpp_utxos || utxo.nonRgbpp) &&
          (!only_confirmed || utxo.status.confirmed) &&
          (!min_satoshi || utxo.value >= min_satoshi),
      ),
    );
  }

  getBtcRecommendedFeeRates(): Promise<BtcApiRecommendedFeeRates> {
    return Promise.resolve({
      fastestFee: this.defaultFee,
      halfHourFee: this.defaultFee,
      hourFee: this.defaultFee,
      economyFee: this.defaultFee,
      minimumFee: this.defaultFee,
    });
  }

  getRgbppSpvProof(btcTxId: string, confirmations: number) {
    const proof = this.rgbppSpvProofs[this.spvKey(btcTxId, confirmations)];
    if (!proof) {
      throw new OfflineBtcAssetsDataSourceError(
        ErrorCodes.OFFLINE_DATA_SOURCE_SPV_PROOF_NOT_FOUND,
        `SPV proof not found for txid ${btcTxId} with ${confirmations} confirmations`,
      );
    }
    return Promise.resolve(proof);
  }

  /*
   * The following methods are not available in offline mode.
   */

  getRgbppPaymasterInfo() {
    return Promise.reject(new OfflineBtcAssetsDataSourceError(ErrorCodes.OFFLINE_DATA_SOURCE_METHOD_NOT_AVAILABLE));
  }

  getBtcBlockchainInfo() {
    return Promise.reject(new OfflineBtcAssetsDataSourceError(ErrorCodes.OFFLINE_DATA_SOURCE_METHOD_NOT_AVAILABLE));
  }

  /* eslint-disable @typescript-eslint/no-unused-vars */

  getBtcBlockByHash(blockHash: string) {
    return Promise.reject(new OfflineBtcAssetsDataSourceError(ErrorCodes.OFFLINE_DATA_SOURCE_METHOD_NOT_AVAILABLE));
  }

  getBtcBlockHeaderByHash(blockHash: string) {
    return Promise.reject(new OfflineBtcAssetsDataSourceError(ErrorCodes.OFFLINE_DATA_SOURCE_METHOD_NOT_AVAILABLE));
  }

  getBtcBlockHashByHeight(height: number) {
    return Promise.reject(new OfflineBtcAssetsDataSourceError(ErrorCodes.OFFLINE_DATA_SOURCE_METHOD_NOT_AVAILABLE));
  }

  getBtcBlockTransactionIdsByHash(blockHash: number) {
    return Promise.reject(new OfflineBtcAssetsDataSourceError(ErrorCodes.OFFLINE_DATA_SOURCE_METHOD_NOT_AVAILABLE));
  }

  getBtcBalance(address: string, params?: BtcApiBalanceParams) {
    return Promise.reject(new OfflineBtcAssetsDataSourceError(ErrorCodes.OFFLINE_DATA_SOURCE_METHOD_NOT_AVAILABLE));
  }

  getBtcTransactions(address: string, params?: BtcApiTransactionParams) {
    return Promise.reject(new OfflineBtcAssetsDataSourceError(ErrorCodes.OFFLINE_DATA_SOURCE_METHOD_NOT_AVAILABLE));
  }

  sendBtcTransaction(txHex: string) {
    return Promise.reject(new OfflineBtcAssetsDataSourceError(ErrorCodes.OFFLINE_DATA_SOURCE_METHOD_NOT_AVAILABLE));
  }

  getRgbppTransactionHash(btcTxId: string) {
    return Promise.reject(new OfflineBtcAssetsDataSourceError(ErrorCodes.OFFLINE_DATA_SOURCE_METHOD_NOT_AVAILABLE));
  }

  getRgbppTransactionState(btcTxId: string, params?: RgbppApiTransactionStateParams) {
    return Promise.reject(new OfflineBtcAssetsDataSourceError(ErrorCodes.OFFLINE_DATA_SOURCE_METHOD_NOT_AVAILABLE));
  }

  getRgbppAssetsByBtcTxId(btcTxId: string) {
    return Promise.reject(new OfflineBtcAssetsDataSourceError(ErrorCodes.OFFLINE_DATA_SOURCE_METHOD_NOT_AVAILABLE));
  }

  getRgbppAssetsByBtcUtxo(btcTxId: string, vout: number) {
    return Promise.reject(new OfflineBtcAssetsDataSourceError(ErrorCodes.OFFLINE_DATA_SOURCE_METHOD_NOT_AVAILABLE));
  }

  getRgbppAssetInfoByTypeScript(typeScript: string) {
    return Promise.reject(new OfflineBtcAssetsDataSourceError(ErrorCodes.OFFLINE_DATA_SOURCE_METHOD_NOT_AVAILABLE));
  }

  getRgbppAssetsByBtcAddress(btcAddress: string, params?: RgbppApiAssetsByAddressParams) {
    return Promise.reject(new OfflineBtcAssetsDataSourceError(ErrorCodes.OFFLINE_DATA_SOURCE_METHOD_NOT_AVAILABLE));
  }

  getRgbppBalanceByBtcAddress(btcAddress: string, params?: RgbppApiBalanceByAddressParams) {
    return Promise.reject(new OfflineBtcAssetsDataSourceError(ErrorCodes.OFFLINE_DATA_SOURCE_METHOD_NOT_AVAILABLE));
  }

  getRgbppActivityByBtcAddress(btcAddress: string, params?: RgbppApiActivityByAddressParams) {
    return Promise.reject(new OfflineBtcAssetsDataSourceError(ErrorCodes.OFFLINE_DATA_SOURCE_METHOD_NOT_AVAILABLE));
  }

  sendRgbppCkbTransaction(payload: RgbppApiSendCkbTransactionPayload) {
    return Promise.reject(new OfflineBtcAssetsDataSourceError(ErrorCodes.OFFLINE_DATA_SOURCE_METHOD_NOT_AVAILABLE));
  }

  retryRgbppCkbTransaction(payload: RgbppApiRetryCkbTransactionPayload) {
    return Promise.reject(new OfflineBtcAssetsDataSourceError(ErrorCodes.OFFLINE_DATA_SOURCE_METHOD_NOT_AVAILABLE));
  }
}


================================================
File: packages/service/src/service/service.ts
================================================
import { BtcAssetsApiBase } from './base';
import {
  BtcApis,
  BtcApiBalance,
  BtcApiBalanceParams,
  BtcApiBlock,
  BtcApiBlockchainInfo,
  BtcApiBlockHash,
  BtcApiBlockHeader,
  BtcApiBlockTransactionIds,
  BtcApiSentTransaction,
  BtcApiTransaction,
  BtcApiUtxo,
  BtcApiUtxoParams,
  BtcApiTransactionParams,
  BtcApiRecommendedFeeRates,
  RgbppApiActivityByAddressParams,
  RgbppApiActivity,
  RgbppApiAssetInfo,
} from '../types';
import {
  RgbppApis,
  RgbppCell,
  RgbppApiSpvProof,
  RgbppApiPaymasterInfo,
  RgbppApiTransactionState,
  RgbppApiSendCkbTransactionPayload,
  RgbppApiCkbTransactionHash,
  RgbppApiAssetsByAddressParams,
  RgbppApiBalanceByAddressParams,
  RgbppApiBalance,
  RgbppApiRetryCkbTransactionPayload,
  RgbppApiTransactionStateParams,
  RgbppApiTransactionRetry,
} from '../types';

export class BtcAssetsApi extends BtcAssetsApiBase implements BtcApis, RgbppApis {
  /**
   * Base
   */

  static fromToken(url: string, token: string, origin?: string) {
    return new BtcAssetsApi({ url, token, origin });
  }

  /**
   * Bitcoin APIs, under the /bitcoin/v1 prefix.
   */

  getBtcBlockchainInfo() {
    return this.request<BtcApiBlockchainInfo>('/bitcoin/v1/info');
  }

  getBtcBlockByHash(blockHash: string) {
    return this.request<BtcApiBlock>(`/bitcoin/v1/block/${blockHash}`);
  }

  getBtcBlockHeaderByHash(blockHash: string) {
    return this.request<BtcApiBlockHeader>(`/bitcoin/v1/block/${blockHash}/header`);
  }

  getBtcBlockHashByHeight(height: number) {
    return this.request<BtcApiBlockHash>(`/bitcoin/v1/block/height/${height}`);
  }

  getBtcBlockTransactionIdsByHash(blockHash: number) {
    return this.request<BtcApiBlockTransactionIds>(`/bitcoin/v1/block/${blockHash}/txids`);
  }

  getBtcRecommendedFeeRates() {
    return this.request<BtcApiRecommendedFeeRates>(`/bitcoin/v1/fees/recommended`);
  }

  getBtcBalance(address: string, params?: BtcApiBalanceParams) {
    return this.request<BtcApiBalance>(`/bitcoin/v1/address/${address}/balance`, {
      params,
    });
  }

  getBtcUtxos(address: string, params?: BtcApiUtxoParams) {
    return this.request<BtcApiUtxo[]>(`/bitcoin/v1/address/${address}/unspent`, {
      params,
    });
  }

  getBtcTransactions(address: string, params?: BtcApiTransactionParams) {
    return this.request<BtcApiTransaction[]>(`/bitcoin/v1/address/${address}/txs`, {
      params,
    });
  }

  getBtcTransaction(txId: string) {
    return this.request<BtcApiTransaction>(`/bitcoin/v1/transaction/${txId}`);
  }

  sendBtcTransaction(txHex: string) {
    return this.post<BtcApiSentTransaction>('/bitcoin/v1/transaction', {
      body: JSON.stringify({
        txhex: txHex,
      }),
    });
  }

  /**
   * RGBPP APIs, under the /rgbpp/v1 prefix.
   */

  getRgbppPaymasterInfo() {
    return this.request<RgbppApiPaymasterInfo>('/rgbpp/v1/paymaster/info');
  }

  getRgbppTransactionHash(btcTxId: string) {
    return this.request<RgbppApiCkbTransactionHash>(`/rgbpp/v1/transaction/${btcTxId}`);
  }

  getRgbppTransactionState(btcTxId: string, params?: RgbppApiTransactionStateParams) {
    return this.request<RgbppApiTransactionState>(`/rgbpp/v1/transaction/${btcTxId}/job`, {
      params,
    });
  }

  getRgbppAssetsByBtcTxId(btcTxId: string) {
    return this.request<RgbppCell[]>(`/rgbpp/v1/assets/${btcTxId}`);
  }

  getRgbppAssetsByBtcUtxo(btcTxId: string, vout: number) {
    return this.request<RgbppCell[]>(`/rgbpp/v1/assets/${btcTxId}/${vout}`);
  }

  getRgbppAssetInfoByTypeScript(typeScript: string) {
    return this.request<RgbppApiAssetInfo>('/rgbpp/v1/assets/type', {
      params: {
        type_script: typeScript,
      },
    });
  }

  getRgbppAssetsByBtcAddress(btcAddress: string, params?: RgbppApiAssetsByAddressParams) {
    return this.request<RgbppCell[]>(`/rgbpp/v1/address/${btcAddress}/assets`, {
      params,
    });
  }

  getRgbppBalanceByBtcAddress(btcAddress: string, params?: RgbppApiBalanceByAddressParams) {
    return this.request<RgbppApiBalance>(`/rgbpp/v1/address/${btcAddress}/balance`, {
      params,
    });
  }

  getRgbppActivityByBtcAddress(btcAddress: string, params?: RgbppApiActivityByAddressParams) {
    return this.request<RgbppApiActivity>(`/rgbpp/v1/address/${btcAddress}/activity`, {
      params,
    });
  }

  getRgbppSpvProof(btcTxId: string, confirmations: number) {
    return this.request<RgbppApiSpvProof>('/rgbpp/v1/btc-spv/proof', {
      params: {
        btc_txid: btcTxId,
        confirmations,
      },
    });
  }

  sendRgbppCkbTransaction(payload: RgbppApiSendCkbTransactionPayload) {
    return this.post<RgbppApiTransactionState>('/rgbpp/v1/transaction/ckb-tx', {
      body: JSON.stringify(payload),
    });
  }

  retryRgbppCkbTransaction(payload: RgbppApiRetryCkbTransactionPayload) {
    return this.post<RgbppApiTransactionRetry>('/rgbpp/v1/transaction/retry', {
      body: JSON.stringify(payload),
    });
  }
}


================================================
File: packages/service/src/types/base.ts
================================================
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export type Json = Record<string, any>;

export interface BaseApis {
  request<T>(route: string, options?: BaseApiRequestOptions): Promise<T>;
  post<T>(route: string, options?: BaseApiRequestOptions): Promise<T>;
  generateToken(): Promise<BtcAssetsApiToken>;
  init(force?: boolean): Promise<void>;
}

export interface BaseApiRequestOptions extends RequestInit {
  params?: Json;
  method?: 'GET' | 'POST';
  requireToken?: boolean;
  allow404?: boolean;
}

export interface BtcAssetsApiToken {
  token: string;
}

export interface BtcAssetsApiContext {
  request: {
    url: string;
    body?: Json;
    params?: Json;
  };
  response: {
    status: number;
    data?: Json | string;
  };
}


================================================
File: packages/service/src/types/btc.ts
================================================
export interface BtcApis {
  getBtcBlockchainInfo(): Promise<BtcApiBlockchainInfo>;
  getBtcBlockByHash(blockHash: string): Promise<BtcApiBlock>;
  getBtcBlockHeaderByHash(blockHash: string): Promise<BtcApiBlockHeader>;
  getBtcBlockHashByHeight(blockHeight: number): Promise<BtcApiBlockHash>;
  getBtcBlockTransactionIdsByHash(blockHash: number): Promise<BtcApiBlockTransactionIds>;
  getBtcRecommendedFeeRates(): Promise<BtcApiRecommendedFeeRates>;
  getBtcBalance(address: string, params?: BtcApiBalanceParams): Promise<BtcApiBalance>;
  getBtcUtxos(address: string, params?: BtcApiUtxoParams): Promise<BtcApiUtxo[]>;
  getBtcTransactions(address: string, params?: BtcApiTransactionParams): Promise<BtcApiTransaction[]>;
  getBtcTransaction(txId: string): Promise<BtcApiTransaction>;
  sendBtcTransaction(txHex: string): Promise<BtcApiSentTransaction>;
}

export interface BtcApiBlockchainInfo {
  chain: string;
  blocks: number;
  bestblockhash: string;
  difficulty: number;
  mediantime: number;
}

export interface BtcApiBlock {
  id: string;
  height: number;
  version: number;
  timestamp: number;
  tx_count: number;
  size: number;
  weight: number;
  merkle_root: string;
  previousblockhash: string;
  mediantime: number;
  nonce: number;
  bits: number;
  difficulty: number;
}

export interface BtcApiBlockHash {
  hash: string;
}

export interface BtcApiBlockHeader {
  header: string;
}

export interface BtcApiBlockTransactionIds {
  txids: string[];
}

export interface BtcApiRecommendedFeeRates {
  fastestFee: number;
  halfHourFee: number;
  hourFee: number;
  economyFee: number;
  minimumFee: number;
}

export interface BtcApiBalanceParams {
  min_satoshi?: number;
  no_cache?: boolean;
}
export interface BtcApiBalance {
  address: string;
  // @deprecated Use available_satoshi instead
  satoshi: number;
  total_satoshi: number;
  available_satoshi: number;
  pending_satoshi: number;
  rgbpp_satoshi: number;
  dust_satoshi: number;
  utxo_count: number;
}

export interface BtcApiUtxoParams {
  only_non_rgbpp_utxos?: boolean;
  only_confirmed?: boolean;
  min_satoshi?: number;
  no_cache?: boolean;
}
export interface BtcApiUtxo {
  txid: string;
  vout: number;
  value: number;
  status: {
    confirmed: boolean;
    block_height: number;
    block_hash: string;
    block_time: number;
  };
}

export interface OfflineBtcUtxo extends BtcApiUtxo {
  address: string;
  nonRgbpp: boolean;
}

export interface BtcApiSentTransaction {
  txid: string;
}

export interface BtcApiTransactionParams {
  after_txid?: string;
}

export interface BtcApiTransaction {
  txid: string;
  version: number;
  locktime: number;
  vin: {
    txid: string;
    vout: number;
    prevout: {
      scriptpubkey: string;
      scriptpubkey_asm: string;
      scriptpubkey_type: string;
      scriptpubkey_address: string;
      value: number;
    };
    scriptsig: string;
    scriptsig_asm: string;
    witness: string[];
    is_coinbase: boolean;
    sequence: number;
  }[];
  vout: {
    scriptpubkey: string;
    scriptpubkey_asm: string;
    scriptpubkey_type: string;
    scriptpubkey_address: string;
    value: number;
  }[];
  weight: number;
  size: number;
  fee: number;
  status: {
    confirmed: boolean;
    block_height: number;
    block_hash: string;
    block_time: number;
  };
}


================================================
File: packages/service/src/types/index.ts
================================================
export * from './base';
export * from './btc';
export * from './rgbpp';


================================================
File: packages/service/src/types/rgbpp.ts
================================================
import { Cell, Hash, Script } from '@ckb-lumos/base';
import { BtcApiTransaction } from './btc';

export interface RgbppApis {
  getRgbppPaymasterInfo(): Promise<RgbppApiPaymasterInfo>;
  getRgbppTransactionHash(btcTxId: string): Promise<RgbppApiCkbTransactionHash>;
  getRgbppTransactionState(btcTxId: string): Promise<RgbppApiTransactionState>;
  getRgbppAssetsByBtcTxId(btcTxId: string): Promise<RgbppCell[]>;
  getRgbppAssetsByBtcUtxo(btcTxId: string, vout: number): Promise<RgbppCell[]>;
  getRgbppAssetsByBtcAddress(btcAddress: string, params?: RgbppApiAssetsByAddressParams): Promise<RgbppCell[]>;
  getRgbppBalanceByBtcAddress(btcAddress: string, params?: RgbppApiBalanceByAddressParams): Promise<RgbppApiBalance>;
  getRgbppActivityByBtcAddress(btcAddress: string, params?: RgbppApiActivityByAddressParams): Promise<RgbppApiActivity>;
  getRgbppSpvProof(btcTxId: string, confirmations: number): Promise<RgbppApiSpvProof>;
  sendRgbppCkbTransaction(payload: RgbppApiSendCkbTransactionPayload): Promise<RgbppApiTransactionState>;
  retryRgbppCkbTransaction(payload: RgbppApiRetryCkbTransactionPayload): Promise<RgbppApiTransactionRetry>;
}

export type RgbppTransactionState = 'completed' | 'failed' | 'delayed' | 'active' | 'waiting';

export interface RgbppApiPaymasterInfo {
  btc_address: string;
  fee: number;
}

export interface RgbppApiCkbTransactionHash {
  txhash: string;
}

export interface RgbppApiTransactionStateParams {
  with_data?: boolean;
}

export interface RgbppApiTransactionState {
  state: RgbppTransactionState;
  attempts: number;
  failedReason?: string;
  data?: {
    txid: string;
    ckbVirtualResult: {
      ckbRawTx: CKBComponents.RawTransaction;
      needPaymasterCell: boolean;
      sumInputsCapacity: string;
      commitment: string;
    };
  };
}

export interface RgbppCell extends Cell {
  typeHash?: Hash;
}

export interface RgbppApiAssetsByAddressParams {
  type_script?: string;
  no_cache?: boolean;
}

export interface RgbppApiBalanceByAddressParams {
  type_script?: string;
  no_cache?: boolean;
}
export interface RgbppApiBalance {
  address: string;
  xudt: RgbppApiXudtBalance[];
}
export interface RgbppApiXudtBalance {
  name: string;
  decimal: number;
  symbol: string;
  total_amount: string;
  available_amount: string;
  pending_amount: string;
  type_hash: string;
  type_script: Script;
}

export interface RgbppApiActivityByAddressParams {
  rgbpp_only?: boolean;
  type_script?: string;
  after_btc_txid?: string;
}
export interface RgbppApiActivity {
  address: string;
  cursor: string;
  txs: {
    btcTx: BtcApiTransaction;
    isRgbpp: boolean;
    isomorphicTx?: {
      ckbVirtualTx?: CKBComponents.RawTransaction;
      ckbTx?: CKBComponents.Transaction;
      inputs?: CKBComponents.CellOutput[];
      outputs?: CKBComponents.CellOutput[];
      status: {
        confirmed: boolean;
      };
    };
  }[];
}

export interface RgbppApiSpvProof {
  proof: string;
  spv_client: {
    tx_hash: string;
    index: string;
  };
}

export interface RgbppApiSendCkbTransactionPayload {
  btc_txid: string;
  // Support ckbVirtualTxResult and it's JSON string as request parameter
  ckb_virtual_result: RgbppApiSendCkbVirtualResult | string;
}
export interface RgbppApiSendCkbVirtualResult {
  ckbRawTx: CKBComponents.RawTransaction;
  needPaymasterCell: boolean;
  sumInputsCapacity: string;
  commitment: string;
}

export interface RgbppApiRetryCkbTransactionPayload {
  btc_txid: string;
}

export interface RgbppApiTransactionRetry {
  success: boolean;
  state: RgbppTransactionState;
}

export interface RgbppApiXudtAssetInfo {
  type: string; //  'xudt'
  type_hash: string;
  type_script: Script;
  symbol: string;
  name: string;
  decimal: number;
  total_supply?: string;
  issuer?: string;
  circulating_supply?: string;
  token_info_cell_type_hash?: string;
}

export interface RgbppApiSporeAssetInfo {
  type: string; //  'spore'
  content_type: string;
  cluster: {
    id: string;
    name: string;
    description: string;
  };
}

export type RgbppApiAssetInfo = RgbppApiXudtAssetInfo | RgbppApiSporeAssetInfo;


================================================
File: packages/service/tests/Service.test.ts
================================================
import { Cell, blockchain, Script } from '@ckb-lumos/base';
import { bytes } from '@ckb-lumos/codec';
import { describe, expect, it } from 'vitest';
import { BtcAssetsApiError, BtcAssetsApi, ErrorCodes, ErrorMessages, RgbppCell, RgbppApiXudtAssetInfo } from '../src';

describe(
  'BtcServiceApi',
  {
    retry: 3,
  },
  () => {
    const btcAddress = 'tb1qm06rvrq8jyyckzc5v709u7qpthel9j4d9f7nh3';
    const service = BtcAssetsApi.fromToken(
      process.env.VITE_BTC_SERVICE_URL!,
      process.env.VITE_BTC_SERVICE_TOKEN!,
      process.env.VITE_BTC_SERVICE_ORIGIN!,
    );

    describe('Initiation and token generation', () => {
      it('Generate a valid token', async () => {
        const serviceWithApp = new BtcAssetsApi({
          url: process.env.VITE_BTC_SERVICE_URL!,
          app: 'btc-test-app',
          domain: 'btc-test.app',
          origin: 'https://btc-test.app',
        });

        // Generate a new token
        await serviceWithApp.init();

        // Request with the generated token
        const blockchainInfo = await serviceWithApp.getBtcBlockchainInfo();
        expect(blockchainInfo.chain).toBeTypeOf('string');
      });
      it('Try initiate with invalid "domain" param', async () => {
        expect(
          () =>
            new BtcAssetsApi({
              url: process.env.VITE_BTC_SERVICE_URL!,
              domain: 'https://btc-test.app',
            }),
        ).toThrow(`${ErrorMessages[ErrorCodes.ASSETS_API_INVALID_PARAM]}: domain`);
      });
      it('Try generate token without the "app" param', async () => {
        const serviceWithoutApp = new BtcAssetsApi({
          url: process.env.VITE_BTC_SERVICE_URL!,
          domain: 'btc-test.app',
        });

        await expect(async () => serviceWithoutApp.generateToken()).rejects.toThrow(
          `${ErrorMessages[ErrorCodes.ASSETS_API_INVALID_PARAM]}: app, domain`,
        );
      });
    });

    describe('BTC', () => {
      it('getBtcBlockchainInfo()', async () => {
        const res = await service.getBtcBlockchainInfo();
        expect(res.chain).toBeTypeOf('string');
        expect(res.blocks).toBeTypeOf('number');
        expect(res.mediantime).toBeTypeOf('number');
        expect(res.difficulty).toBeTypeOf('number');
        expect(res.bestblockhash).toBeTypeOf('string');
      });
      it('getBtcRecommendedFeeRates()', async () => {
        const fees = await service.getBtcRecommendedFeeRates();
        expect(fees).toBeDefined();
        expect(fees.fastestFee).toBeTypeOf('number');
        expect(fees.halfHourFee).toBeTypeOf('number');
        expect(fees.hourFee).toBeTypeOf('number');
        expect(fees.economyFee).toBeTypeOf('number');
        expect(fees.minimumFee).toBeTypeOf('number');
        expect(fees.fastestFee).toBeGreaterThanOrEqual(fees.halfHourFee);
        expect(fees.halfHourFee).toBeGreaterThanOrEqual(fees.hourFee);
        expect(fees.hourFee).toBeGreaterThanOrEqual(fees.economyFee);
        expect(fees.economyFee).toBeGreaterThanOrEqual(fees.minimumFee);
      });
      it('getBtcBalance()', async () => {
        const res = await service.getBtcBalance(btcAddress);
        expect(res.address).toEqual(btcAddress);
        expect(res.satoshi).toBeTypeOf('number');
        expect(res.total_satoshi).toBeTypeOf('number');
        expect(res.available_satoshi).toBeTypeOf('number');
        expect(res.pending_satoshi).toBeTypeOf('number');
        expect(res.dust_satoshi).toBeTypeOf('number');
        expect(res.utxo_count).toBeTypeOf('number');
      });
      it('getBtcBalance() with min_satoshi', async () => {
        const originalBalance = await service.getBtcBalance(btcAddress);
        const filteredBalance = await service.getBtcBalance(btcAddress, {
          min_satoshi: originalBalance.satoshi + 1,
        });

        expect(filteredBalance.available_satoshi).toEqual(0);
      });
      it('getBtcBalance() with no_cache', async () => {
        const res = await service.getBtcBalance(btcAddress, {
          no_cache: true,
        });
        expect(res.address).toEqual(btcAddress);
      });
      it('getBtcUtxos()', async () => {
        const res = await service.getBtcUtxos(btcAddress);
        expect(Array.isArray(res)).toBe(true);
        expect(res.length).toBeGreaterThan(0);

        res.forEach((utxo) => {
          expect(utxo.txid).toBeTypeOf('string');
          expect(utxo.vout).toBeTypeOf('number');
          expect(utxo.value).toBeTypeOf('number');
          expect(utxo.value).toBeGreaterThan(0);
          expect(utxo.status).toBeTypeOf('object');
          expect(utxo.status.confirmed).toBeDefined();
          expect(utxo.status.confirmed).toBeTypeOf('boolean');
          if (utxo.status.confirmed) {
            expect(utxo.status.block_height).toBeTypeOf('number');
            expect(utxo.status.block_hash).toBeTypeOf('string');
            expect(utxo.status.block_time).toBeTypeOf('number');
          }
        });
      });
      it('getBtcUtxos() with min_satoshi', async () => {
        const originalUtxos = await service.getBtcUtxos(btcAddress);

        const maxValue = originalUtxos.reduce((max, out) => Math.max(max, out.value), 0);
        const filteredUtxos = await service.getBtcUtxos(btcAddress, {
          min_satoshi: maxValue + 1,
        });

        expect(filteredUtxos.length).toBe(0);
      });
      it('getBtcUtxos() with only_collected', async () => {
        const confirmedUtxos = await service.getBtcUtxos(btcAddress, {
          only_confirmed: true,
        });
        expect(Array.isArray(confirmedUtxos)).toBe(true);
        for (const utxo of confirmedUtxos) {
          expect(utxo.status.confirmed).toBe(true);
        }
      });
      it('getBtcUtxos() with no_cache', async () => {
        const utxos = await service.getBtcUtxos(btcAddress, {
          no_cache: true,
        });
        expect(Array.isArray(utxos)).toBe(true);
      });
      it('getBtcTransactions()', async () => {
        const res = await service.getBtcTransactions(btcAddress);
        expect(Array.isArray(res)).toBe(true);
        expect(res.length).toBeGreaterThan(0);
        res.forEach((transaction) => {
          expect(transaction.txid).toBeTypeOf('string');
          expect(transaction.version).toBeTypeOf('number');
          if (transaction.status.confirmed) {
            expect(transaction.status.block_height).toBeTypeOf('number');
            expect(transaction.status.block_hash).toBeTypeOf('string');
            expect(transaction.status.block_time).toBeTypeOf('number');
          }
        });
      });
      it('getBtcTransactions() with after_txid', async () => {
        const txs = await service.getBtcTransactions(btcAddress);
        expect(Array.isArray(txs)).toBe(true);
        expect(txs.length).toBeGreaterThan(0);

        const filteredTxs = await service.getBtcTransactions(btcAddress, {
          after_txid: txs[txs.length - 2].txid,
        });
        expect(Array.isArray(filteredTxs)).toBe(true);

        if (txs.length > 1) {
          expect(txs.length).toBeGreaterThan(0);
        } else {
          expect(filteredTxs).toHaveLength(0);
        }
      });
      it('getBtcTransaction()', async () => {
        const res = await service.getBtcTransaction('102d5a002e72f0781944eef636117377da6d3601061e47e03025e7cd29a91579');
        expect(res.txid).toBe('102d5a002e72f0781944eef636117377da6d3601061e47e03025e7cd29a91579');
      });
    });

    describe('RGBPP', () => {
      const rgbppBtcAddress = 'tb1qwksrmna6emxrerrgyc8hrlxvl2z4x4tdhzzyej';
      const rgbppBtcTxId = 'da1f32672e3fb0432e1c94ed41298820c8dcca9495cf04a49d992ca4dfc5853d';
      const rgbppBtcVout = 0;
      const rgbppCellType = bytes.hexify(
        blockchain.Script.pack({
          codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',
          args: '0x661cfbe2124b3e79e50e505c406be5b2dcf9da15d8654b749ec536fa4c2eaaae',
          hashType: 'type',
        }),
      );

      const emptyBtcTxId = '0000000000000000000000000000000000000000000000000000000000000001';

      it('getRgbppPaymasterInfo()', async () => {
        try {
          const res = await service.getRgbppPaymasterInfo();
          expect(res).toBeDefined();
          expect(res.btc_address).toBeTypeOf('string');
          expect(res.fee).toBeTypeOf('number');
        } catch (e) {
          expect(e).toBeInstanceOf(BtcAssetsApiError);
          expect(e.code).toBe(ErrorCodes.ASSETS_API_RESOURCE_NOT_FOUND);
        }
      });
      it('getRgbppTransactionHash()', async () => {
        const res = await service.getRgbppTransactionHash(rgbppBtcTxId);
        expect(res).toBeDefined();
        expect(res.txhash).toBeTypeOf('string');
        expect(res.txhash).toHaveLength(66);
      });
      it('getRgbppTransactionHash() with empty BTC_TXID', async () => {
        await expect(() => service.getRgbppTransactionHash(emptyBtcTxId)).rejects.toHaveProperty(
          'code',
          ErrorCodes.ASSETS_API_RESOURCE_NOT_FOUND,
        );
      });
      // TODO: make a record and remove the "skip" marker
      it.skip('getRgbppTransactionState()', async () => {
        const res = await service.getRgbppTransactionState(rgbppBtcTxId);
        expect(res).toBeDefined();
        expect(res.state).toBeTypeOf('string');
        expect(res.state).toSatisfy(
          (state: string) => ['completed', 'failed', 'delayed', 'active', 'waiting'].includes(state),
          `state "${res.state}" should be one of the RgbppTransactionState`,
        );
      });
      it('getRgbppTransactionState() with empty BTC_TXID', async () => {
        await expect(() => service.getRgbppTransactionState(emptyBtcTxId)).rejects.toHaveProperty(
          'code',
          ErrorCodes.ASSETS_API_RESOURCE_NOT_FOUND,
        );
      });
      it('getRgbppAssetsByBtcTxId()', async () => {
        const res = await service.getRgbppAssetsByBtcTxId(rgbppBtcTxId);
        expect(res).toBeDefined();
        expect(res.length).toBeGreaterThan(0);
        for (const cell of res) {
          expectRgbppCell(cell);
        }
      });
      it('getRgbppAssetsByBtcUtxo()', async () => {
        const res = await service.getRgbppAssetsByBtcUtxo(rgbppBtcTxId, rgbppBtcVout);
        expect(res).toBeDefined();
        expect(res.length).toBeGreaterThan(0);
        for (const cell of res) {
          expectRgbppCell(cell);
        }
      });
      it('getRgbppAssetsByBtcAddress()', async () => {
        const res = await service.getRgbppAssetsByBtcAddress(rgbppBtcAddress, {
          type_script: rgbppCellType,
        });
        expect(res).toBeDefined();
        expect(res.length).toBeGreaterThan(0);
        for (const cell of res) {
          expectRgbppCell(cell);
        }
      });
      it('getRgbppBalanceByBtcAddress()', async () => {
        const res = await service.getRgbppBalanceByBtcAddress(rgbppBtcAddress);
        expect(res).toBeDefined();
        expect(res.address).toBeTypeOf('string');
        expect(res.xudt.length).toBeGreaterThan(0);
        for (const xudt of res.xudt) {
          expect(xudt.name).toBeTypeOf('string');
          expect(xudt.decimal).toBeTypeOf('number');
          expect(xudt.symbol).toBeTypeOf('string');
          expect(xudt.total_amount).toBeTypeOf('string');
          expect(xudt.available_amount).toBeTypeOf('string');
          expect(xudt.pending_amount).toBeTypeOf('string');
          expect(xudt.type_hash).toBeTypeOf('string');
          expectScript(xudt.type_script);
        }
      });
      it('getRgbppActivityByBtcAddress()', async () => {
        const res = await service.getRgbppActivityByBtcAddress(rgbppBtcAddress, {
          type_script: rgbppCellType,
        });
        expect(res).toBeDefined();
        expect(res.address).toBeTypeOf('string');
        expect(res.cursor).toBeTypeOf('string');
        expect(res.txs).toHaveProperty('length');
        if (res.txs.length > 0) {
          for (const tx of res.txs) {
            expect(tx.btcTx).toBeDefined();
            expect(tx.isRgbpp).toBeTypeOf('boolean');
            if (tx.isRgbpp) {
              expect(tx.isomorphicTx).toBeDefined();
              expect(tx.isomorphicTx?.status.confirmed).toBeTypeOf('boolean');
              const hasTxOrVirtualTx = tx.isomorphicTx?.ckbVirtualTx ?? tx.isomorphicTx?.ckbTx;
              if (hasTxOrVirtualTx) {
                expect(tx.isomorphicTx?.inputs).toBeDefined();
                expect(tx.isomorphicTx?.outputs).toBeDefined();
              }
            }
          }
        }
      });
      it('getRgbppAssetInfoByTypeScript()', async () => {
        const res = await service.getRgbppAssetInfoByTypeScript(rgbppCellType);
        expect(res).toBeDefined();
        expect(res.type).toBe('xudt');
        expect((res as RgbppApiXudtAssetInfo).symbol).toBe('UBBQT');
        expect((res as RgbppApiXudtAssetInfo).name).toBe('Unique BBQ TEST');
        expect((res as RgbppApiXudtAssetInfo).decimal).toBe(8);
        expect((res as RgbppApiXudtAssetInfo).type_hash).toBe(
          '0x5e122c1523318c3437362aa8e39d9a79af604669b7e38f8d45489516895006e0',
        );
        expect((res as RgbppApiXudtAssetInfo).type_script.args).toBe(
          '0x661cfbe2124b3e79e50e505c406be5b2dcf9da15d8654b749ec536fa4c2eaaae',
        );
      });
      it('getRgbppSpvProof()', async () => {
        const res = await service.getRgbppSpvProof(rgbppBtcTxId, 6);
        expect(res).toBeDefined();
        expect(res.proof).toBeTypeOf('string');
        expect(res.spv_client).toBeDefined();
        expect(res.spv_client.index).toBeTypeOf('string');
        expect(res.spv_client.tx_hash).toBeTypeOf('string');
      });
      it('getRgbppSpvProof() with empty BTC_TXID', async () => {
        await expect(() => service.getRgbppSpvProof(emptyBtcTxId, 0)).rejects.toHaveProperty(
          'code',
          ErrorCodes.ASSETS_API_RESOURCE_NOT_FOUND,
        );
      });
    });
  },
);

function expectCell(cell: Cell) {
  expect(cell).toBeDefined();
  expect(cell.cellOutput).toBeDefined();

  expect(cell.cellOutput.capacity).toBeTypeOf('string');

  expect(cell.cellOutput.lock).toBeDefined();
  expect(cell.cellOutput.lock.codeHash).toBeTypeOf('string');
  expect(cell.cellOutput.lock.hashType).toBeTypeOf('string');
  expect(cell.cellOutput.lock.args).toBeTypeOf('string');

  expect(cell.cellOutput.type).toBeDefined();
  expect(cell.cellOutput.type?.codeHash).toBeTypeOf('string');
  expect(cell.cellOutput.type?.hashType).toBeTypeOf('string');
  expect(cell.cellOutput.type?.args).toBeTypeOf('string');

  expect(cell.outPoint).toBeDefined();
  expect(cell.outPoint?.txHash).toBeTypeOf('string');
  expect(cell.outPoint?.index).toBeTypeOf('string');

  expect(cell.data).toBeTypeOf('string');
}

function expectRgbppCell(cell: RgbppCell) {
  expectCell(cell);

  if (cell.typeHash) {
    expect(cell.typeHash).toBeTypeOf('string');
  }
}

function expectScript(script: Script) {
  expect(script).toBeDefined();
  expect(script.codeHash).toBeTypeOf('string');
  expect(script.hashType).toBeTypeOf('string');
  expect(script.args).toBeTypeOf('string');
}


================================================
File: packages/service/tests/Utils.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { BtcAssetsApiError, ErrorCodes, isDomain } from '../src';

describe('Utils', () => {
  it('isDomain()', () => {
    expect(isDomain('google.com')).toBe(true);
    expect(isDomain('mail.google.com')).toBe(true);
    expect(isDomain('https://google.com')).toBe(false);
    expect(isDomain('google.com/path')).toBe(false);
    expect(isDomain('google')).toBe(false);

    expect(isDomain('localhost', true)).toBe(true);
    expect(isDomain('localhost')).toBe(false);
  });
  it('BtcAssetsApiError with context', () => {
    try {
      throw BtcAssetsApiError.withComment(ErrorCodes.ASSETS_API_INVALID_PARAM, 'param1, param2', {
        request: {
          url: 'https://api.com/api/v1/route',
          params: {
            param1: 'value1',
            param2: 'value2',
          },
        },
        response: {
          status: 400,
          data: {
            error: -10,
            message: 'error message about -10',
          },
        },
      });
    } catch (e) {
      expect(e).toBeInstanceOf(BtcAssetsApiError);
      expect(e.toString()).toEqual('Error: Invalid param(s) was provided to the BtcAssetsAPI: param1, param2');

      if (e instanceof BtcAssetsApiError) {
        expect(e.code).toEqual(ErrorCodes.ASSETS_API_INVALID_PARAM);
        expect(e.message).toEqual('Invalid param(s) was provided to the BtcAssetsAPI: param1, param2');

        expect(e.context).toBeDefined();
        expect(e.context.request).toBeDefined();
        expect(e.context.request.url).toEqual('https://api.com/api/v1/route');
        expect(e.context.request.params).toEqual({
          param1: 'value1',
          param2: 'value2',
        });

        expect(e.context.response).toBeDefined();
        expect(e.context.response.status).toEqual(400);
        expect(e.context.response.data).toEqual({
          error: -10,
          message: 'error message about -10',
        });
      }
    }
  });
});


================================================
File: tests/rgbpp/env.ts
================================================
import {
  blake160,
  bytesToHex,
  privateKeyToPublicKey,
  scriptToAddress,
  systemScripts,
} from '@nervosnetwork/ckb-sdk-utils';
import { DataSource, BtcAssetsApi, AddressType } from 'rgbpp';
import { ECPair, ECPairInterface, bitcoin, NetworkType } from 'rgbpp/btc';
import dotenv from 'dotenv';
import { Collector } from 'rgbpp/ckb';
import { createBtcAccount } from '../../examples/rgbpp/shared/btc-account';

dotenv.config({ path: __dirname + '/.env' });

export const isMainnet = false;

export const BTC_TESTNET_TYPE = 'Testnet3';

export const collector = new Collector({
  ckbNodeUrl: 'https://testnet.ckb.dev/rpc',
  ckbIndexerUrl: 'https://testnet.ckb.dev/indexer',
});
export const CKB_PRIVATE_KEY = process.env.INTEGRATION_CKB_PRIVATE_KEY!;
const secp256k1Lock: CKBComponents.Script = {
  ...systemScripts.SECP256K1_BLAKE160,
  args: bytesToHex(blake160(privateKeyToPublicKey(CKB_PRIVATE_KEY))),
};
export const ckbAddress = scriptToAddress(secp256k1Lock, isMainnet);

export const BTC_PRIVATE_KEY = process.env.INTEGRATION_BTC_PRIVATE_KEY!;
export const BTC_SERVICE_URL = process.env.VITE_SERVICE_URL!;
export const BTC_SERVICE_TOKEN = process.env.VITE_SERVICE_TOKEN!;
export const BTC_SERVICE_ORIGIN = process.env.VITE_SERVICE_ORIGIN!;

const network = isMainnet ? bitcoin.networks.bitcoin : bitcoin.networks.testnet;
export const btcKeyPair: ECPairInterface = ECPair.fromPrivateKey(Buffer.from(BTC_PRIVATE_KEY, 'hex'), { network });

// Read more about the available address types:
// - P2WPKH: https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#p2wpkh
// - P2TR: https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki
const addressType = AddressType.P2WPKH;
const networkType = isMainnet ? NetworkType.MAINNET : NetworkType.TESTNET;
export const btcAccount = createBtcAccount(BTC_PRIVATE_KEY, addressType, networkType);

export const btcService = BtcAssetsApi.fromToken(BTC_SERVICE_URL, BTC_SERVICE_TOKEN, BTC_SERVICE_ORIGIN);
export const btcDataSource = new DataSource(btcService, networkType);


================================================
File: tests/rgbpp/package.json
================================================
{
  "name": "rgbpp-integration-tests",
  "version": "0.1.0",
  "description": "Test the entire process of RGBPP to ensure the proper functioning of the rgbpp-sdk package.",
  "private": true,
  "type": "commonjs",
  "scripts": {
    "format": "prettier --write '**/*.{js,ts}'",
    "lint": "tsc && eslint . && prettier --check '**/*.{js,ts}'",
    "lint:fix": "tsc && eslint --fix --ext .js,.ts . && prettier --write '**/*.{js,ts}'",
    "integration:xudt": "npx tsx shared/prepare-utxo.ts && npx tsx xudt/xudt-on-ckb/1-issue-xudt.ts && npx tsx xudt/xudt-on-ckb/2-transfer-xudt.ts && npx tsx xudt/1-ckb-leap-btc.ts && npx tsx xudt/2-btc-transfer.ts && npx tsx xudt/3-btc-leap-ckb.ts && npx tsx xudt/btc-transfer-all/1-btc-transfer-all.ts",
    "integration:spore": "npx tsx shared/prepare-utxo.ts && npx tsx spore/launch/1-prepare-cluster.ts && npx tsx spore/launch/2-create-cluster.ts && npx tsx spore/launch/3-create-spores.ts && npx tsx spore/4-transfer-spore.ts && npx tsx spore/5-leap-spore-to-ckb.ts",
    "integration:compatible-xudt": "npx tsx shared/prepare-utxo.ts && npx tsx xudt/compatible-xudt/1-ckb-leap-btc.ts && npx tsx xudt/compatible-xudt/2-btc-transfer.ts && npx tsx xudt/compatible-xudt/3-btc-leap-ckb.ts"
  },
  "dependencies": {
    "@nervosnetwork/ckb-sdk-utils": "0.109.5",
    "rgbpp": "workspace:*",
    "zx": "^8.0.2"
 },
  "devDependencies": {
    "dotenv": "^16.4.5",
    "@types/dotenv": "^8.2.0"
  }
}


================================================
File: tests/rgbpp/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2015",
    "lib": ["dom", "esnext"],
    "module": "esnext",
    "composite": false,
    "resolveJsonModule": true,
    "strictNullChecks": true,
    "noEmit": true,
    "declaration": true,
    "declarationMap": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "inlineSources": false,
    "isolatedModules": true,
    "moduleResolution": "Bundler",
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "preserveWatchOutput": true,
    "skipLibCheck": true,
    "strict": true
  },
  "include": ["spore", "xudt", "shared"],
  "exclude": ["node_modules"]
}


================================================
File: tests/rgbpp/shared/prepare-utxo.ts
================================================
import { sendBtc } from 'rgbpp/btc';
import { getFastestFeeRate, writeStepLog } from './utils';
import { BtcAssetsApiError } from 'rgbpp/service';
import { btcAccount, btcDataSource, btcKeyPair, btcService } from '../env';

const prepareUtxo = async (index: string | number) => {
  console.log(btcAccount.from);
  const feeRate = await getFastestFeeRate();
  console.log('feeRate = ', feeRate);
  // Send BTC tx
  const psbt = await sendBtc({
    from: btcAccount.from!,
    tos: [
      {
        address: btcAccount.from!,
        value: 546,
        minUtxoSatoshi: 546,
      },
    ],
    feeRate: feeRate,
    source: btcDataSource,
  });

  // Sign & finalize inputs
  psbt.signAllInputs(btcKeyPair);
  psbt.finalizeAllInputs();

  // Broadcast transaction
  const tx = psbt.extractTransaction();
  console.log(tx.toHex());

  const { txid: btcTxId } = await btcService.sendBtcTransaction(tx.toHex());
  console.log(`explorer: https://mempool.space/testnet/tx/${btcTxId}`);

  writeStepLog(String(index), {
    txid: btcTxId,
    index: 0,
  });

  const interval = setInterval(async () => {
    try {
      console.log('Waiting for BTC tx to be confirmed');
      const tx = await btcService.getBtcTransaction(btcTxId);
      if (tx.status.confirmed) {
        clearInterval(interval);
        console.info(`Utxo is confirmed ${btcTxId}:0`);
      }
    } catch (error) {
      if (!(error instanceof BtcAssetsApiError)) {
        console.error(error);
      }
    }
  }, 20 * 1000);
};

prepareUtxo('prepare-utxo');


================================================
File: tests/rgbpp/shared/utils.ts
================================================
import 'dotenv/config';
import * as fs from 'fs';
import * as path from 'path';
import { btcService } from '../env';

export const network = 'testnet';

export async function getFastestFeeRate() {
  const fees = await btcService.getBtcRecommendedFeeRates();
  // return fees.fastestFee + 1000;
  return Math.ceil(fees.fastestFee * 1.1);
}

export async function writeStepLog(step: string, data: string | object) {
  const file = path.join(__dirname, `../${network}/step-${step}.log`);
  if (typeof data !== 'string') {
    data = JSON.stringify(data);
  }

  fs.writeFileSync(file, data);
}

export function readStepLog(step: string) {
  const file = path.join(__dirname, `../${network}/step-${step}.log`);
  const retryInterval = 10000;
  const maxRetries = 3;

  for (let i = 0; i < 3; i++) {
    try {
      const data = fs.readFileSync(file, 'utf8');
      return JSON.parse(data);
    } catch (error) {
      console.error(`Failed to read file ${file} on attempt ${i + 1}: ${error}`);
      if (i < maxRetries - 1) {
        console.log(`Waiting ${retryInterval / 1000} seconds before retrying...`);
        setTimeout(() => {}, retryInterval);
      }
    }
  }

  console.error(`Failed to read file ${file} after ${maxRetries} attempts.`);
  return null;
}


================================================
File: tests/rgbpp/spore/4-transfer-spore.ts
================================================
import { buildRgbppLockArgs } from 'rgbpp/ckb';
import { genTransferSporeCkbVirtualTx, sendRgbppUtxos } from 'rgbpp';
import { getSporeTypeScript, Hex } from 'rgbpp/ckb';
import { serializeScript } from '@nervosnetwork/ckb-sdk-utils';
import { isMainnet, collector, btcDataSource, btcService, btcAccount, BTC_TESTNET_TYPE } from '../env';
import { getFastestFeeRate, readStepLog } from '../shared/utils';
import { saveCkbVirtualTxResult } from '../../../examples/rgbpp/shared/utils';
import { signAndSendPsbt } from '../../../examples/rgbpp/shared/btc-account';

interface SporeTransferParams {
  sporeRgbppLockArgs: Hex;
  toBtcAddress: string;
  sporeTypeArgs: Hex;
}

const transferSpore = async ({ sporeRgbppLockArgs, toBtcAddress, sporeTypeArgs }: SporeTransferParams) => {
  const { retry } = await import('zx');

  const feeRate = await getFastestFeeRate();
  console.log('feeRate = ', feeRate);

  await retry(20, '10s', async () => {
    const sporeTypeBytes = serializeScript({
      ...getSporeTypeScript(isMainnet),
      args: sporeTypeArgs,
    });

    const ckbVirtualTxResult = await genTransferSporeCkbVirtualTx({
      collector,
      sporeRgbppLockArgs,
      sporeTypeBytes,
      isMainnet,
      btcTestnetType: BTC_TESTNET_TYPE,
    });

    // Save ckbVirtualTxResult
    saveCkbVirtualTxResult(ckbVirtualTxResult, '4-transfer-spore');

    const { commitment, ckbRawTx, needPaymasterCell } = ckbVirtualTxResult;

    // Send BTC tx
    const psbt = await sendRgbppUtxos({
      ckbVirtualTx: ckbRawTx,
      commitment,
      tos: [toBtcAddress],
      needPaymaster: needPaymasterCell,
      ckbCollector: collector,
      from: btcAccount.from,
      fromPubkey: btcAccount.fromPubkey,
      source: btcDataSource,
      feeRate: feeRate,
    });

    const { txId: btcTxId } = await signAndSendPsbt(psbt, btcAccount, btcService);
    console.log('BTC TxId: ', btcTxId);
    console.log(`explorer: https://mempool.space/testnet/tx/${btcTxId}`);

    await btcService.sendRgbppCkbTransaction({ btc_txid: btcTxId, ckb_virtual_result: ckbVirtualTxResult });

    try {
      const interval = setInterval(async () => {
        const { state, failedReason } = await btcService.getRgbppTransactionState(btcTxId);
        console.log('state', state);
        if (state === 'completed' || state === 'failed') {
          clearInterval(interval);
          if (state === 'completed') {
            const { txhash: txHash } = await btcService.getRgbppTransactionHash(btcTxId);
            console.info(`Rgbpp spore has been transferred on BTC and the related CKB tx hash is ${txHash}`);
            console.info(`explorer: https://pudge.explorer.nervos.org/transaction/${txHash}`);
          } else {
            console.warn(`Rgbpp CKB transaction failed and the reason is ${failedReason} `);
          }
        }
      }, 30 * 1000);
    } catch (error) {
      console.error(error);
    }
  });
};

// Please use your real BTC UTXO information on the BTC Testnet
// rgbppLockArgs: outIndexU32 + btcTxId
transferSpore({
  sporeRgbppLockArgs: buildRgbppLockArgs(2, readStepLog('create-spores-id').txid),
  toBtcAddress: 'tb1qhp9fh9qsfeyh0yhewgu27ndqhs5qlrqwau28m7',
  // Please use your own RGB++ spore asset's sporeTypeArgs
  sporeTypeArgs: readStepLog('sporeTypeScripts')[0].args,
});


================================================
File: tests/rgbpp/spore/5-leap-spore-to-ckb.ts
================================================
import { buildRgbppLockArgs } from 'rgbpp/ckb';
import { genLeapSporeFromBtcToCkbVirtualTx, sendRgbppUtxos } from 'rgbpp';
import { getSporeTypeScript, Hex } from 'rgbpp/ckb';
import { serializeScript } from '@nervosnetwork/ckb-sdk-utils';
import { isMainnet, collector, btcDataSource, btcService, btcAccount, BTC_TESTNET_TYPE } from '../env';
import { getFastestFeeRate, readStepLog } from '../shared/utils';
import { saveCkbVirtualTxResult } from '../../../examples/rgbpp/shared/utils';
import { signAndSendPsbt } from '../../../examples/rgbpp/shared/btc-account';

interface SporeLeapParams {
  sporeRgbppLockArgs: Hex;
  toCkbAddress: string;
  sporeTypeArgs: Hex;
}

const leapSporeFromBtcToCkb = async ({ sporeRgbppLockArgs, toCkbAddress, sporeTypeArgs }: SporeLeapParams) => {
  const { retry } = await import('zx');

  const feeRate = await getFastestFeeRate();
  console.log('feeRate = ', feeRate);

  await retry(20, '10s', async () => {
    const sporeTypeBytes = serializeScript({
      ...getSporeTypeScript(isMainnet),
      args: sporeTypeArgs,
    });

    const ckbVirtualTxResult = await genLeapSporeFromBtcToCkbVirtualTx({
      collector,
      sporeRgbppLockArgs,
      sporeTypeBytes,
      toCkbAddress,
      isMainnet,
      btcTestnetType: BTC_TESTNET_TYPE,
    });

    // Save ckbVirtualTxResult
    saveCkbVirtualTxResult(ckbVirtualTxResult, '5-leap-spore-to-ckb');

    const { commitment, ckbRawTx, needPaymasterCell } = ckbVirtualTxResult;

    // Send BTC tx
    const psbt = await sendRgbppUtxos({
      ckbVirtualTx: ckbRawTx,
      commitment,
      tos: [btcAccount.from],
      needPaymaster: needPaymasterCell,
      ckbCollector: collector,
      from: btcAccount.from,
      fromPubkey: btcAccount.fromPubkey,
      source: btcDataSource,
      feeRate: feeRate,
    });

    const { txId: btcTxId } = await signAndSendPsbt(psbt, btcAccount, btcService);
    console.log('BTC TxId: ', btcTxId);
    console.log(`explorer: https://mempool.space/testnet/tx/${btcTxId}`);

    await btcService.sendRgbppCkbTransaction({ btc_txid: btcTxId, ckb_virtual_result: ckbVirtualTxResult });

    try {
      const interval = setInterval(async () => {
        const { state, failedReason } = await btcService.getRgbppTransactionState(btcTxId);
        console.log('state', state);
        if (state === 'completed' || state === 'failed') {
          clearInterval(interval);
          if (state === 'completed') {
            const { txhash: txHash } = await btcService.getRgbppTransactionHash(btcTxId);
            console.info(`Rgbpp spore has been leaped from BTC to CKB and the related CKB tx hash is ${txHash}`);
            console.info(`explorer: https://pudge.explorer.nervos.org/transaction/${txHash}`);
          } else {
            console.warn(`Rgbpp CKB transaction failed and the reason is ${failedReason} `);
          }
        }
      }, 30 * 1000);
    } catch (error) {
      console.error(error);
    }
  });
};

// Please use your real BTC UTXO information on the BTC Testnet
// rgbppLockArgs: outIndexU32 + btcTxId
leapSporeFromBtcToCkb({
  sporeRgbppLockArgs: buildRgbppLockArgs(3, readStepLog('create-spores-id').txid),
  toCkbAddress: 'ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsq0e4xk4rmg5jdkn8aams492a7jlg73ue0gc0ddfj',
  // Please use your own RGB++ spore asset's sporeTypeArgs
  sporeTypeArgs: readStepLog('sporeTypeScripts')[1].args,
});


================================================
File: tests/rgbpp/spore/launch/0-cluster-info.ts
================================================
import { RawClusterData } from 'rgbpp/ckb';

export const CLUSTER_DATA: RawClusterData = {
  name: 'Cluster name',
  description: 'Description of the cluster',
};


================================================
File: tests/rgbpp/spore/launch/1-prepare-cluster.ts
================================================
import { addressToScript, getTransactionSize } from '@nervosnetwork/ckb-sdk-utils';
import {
  MAX_FEE,
  NoLiveCellError,
  SECP256K1_WITNESS_LOCK_SIZE,
  append0x,
  buildRgbppLockArgs,
  calculateRgbppClusterCellCapacity,
  calculateTransactionFee,
  genRgbppLockScript,
  getSecp256k1CellDep,
} from 'rgbpp/ckb';
import { ckbAddress, isMainnet, collector, CKB_PRIVATE_KEY, BTC_TESTNET_TYPE } from '../../env';
import { CLUSTER_DATA } from './0-cluster-info';
import { readStepLog } from '../../shared/utils';

const prepareClusterCell = async ({ outIndex, btcTxId }: { outIndex: number; btcTxId: string }) => {
  const { retry } = await import('zx');
  await retry(20, '10s', async () => {
    const masterLock = addressToScript(ckbAddress);
    console.log('ckb address: ', ckbAddress);

    // The capacity required to launch cells is determined by the token info cell capacity, and transaction fee.
    const clusterCellCapacity = calculateRgbppClusterCellCapacity(CLUSTER_DATA);

    let emptyCells = await collector.getCells({
      lock: masterLock,
    });
    if (!emptyCells || emptyCells.length === 0) {
      throw new NoLiveCellError('The address has no empty cells');
    }
    emptyCells = emptyCells.filter((cell) => !cell.output.type);

    const txFee = MAX_FEE;
    const { inputs, sumInputsCapacity } = collector.collectInputs(emptyCells, clusterCellCapacity, txFee);

    const outputs: CKBComponents.CellOutput[] = [
      {
        lock: genRgbppLockScript(buildRgbppLockArgs(outIndex, btcTxId), isMainnet, BTC_TESTNET_TYPE),
        capacity: append0x(clusterCellCapacity.toString(16)),
      },
    ];
    let changeCapacity = sumInputsCapacity - clusterCellCapacity;
    outputs.push({
      lock: masterLock,
      capacity: append0x(changeCapacity.toString(16)),
    });
    const outputsData = ['0x', '0x'];

    const emptyWitness = { lock: '', inputType: '', outputType: '' };
    const witnesses = inputs.map((_, index) => (index === 0 ? emptyWitness : '0x'));

    const cellDeps = [getSecp256k1CellDep(isMainnet)];

    const unsignedTx = {
      version: '0x0',
      cellDeps,
      headerDeps: [],
      inputs,
      outputs,
      outputsData,
      witnesses,
    };

    const txSize = getTransactionSize(unsignedTx) + SECP256K1_WITNESS_LOCK_SIZE;
    const estimatedTxFee = calculateTransactionFee(txSize);
    changeCapacity -= estimatedTxFee;
    unsignedTx.outputs[unsignedTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));

    const signedTx = collector.getCkb().signTransaction(CKB_PRIVATE_KEY)(unsignedTx);
    const txHash = await collector.getCkb().rpc.sendTransaction(signedTx, 'passthrough');

    console.info(`Cluster cell has been prepared and the tx hash ${txHash}`);
    console.info(`explorer: https://pudge.explorer.nervos.org/transaction/${txHash}`);
  });
};

// Please use your real BTC UTXO information on the BTC Testnet
prepareClusterCell({
  outIndex: readStepLog('prepare-utxo').index,
  btcTxId: readStepLog('prepare-utxo').txid,
});


================================================
File: tests/rgbpp/spore/launch/2-create-cluster.ts
================================================
import { BtcAssetsApiError, genCreateClusterCkbVirtualTx, sendRgbppUtxos } from 'rgbpp';
import { isMainnet, collector, btcDataSource, btcService, btcAccount, BTC_TESTNET_TYPE } from '../../env';
import { CLUSTER_DATA } from './0-cluster-info';
import {
  appendCkbTxWitnesses,
  buildRgbppLockArgs,
  generateClusterCreateCoBuild,
  sendCkbTx,
  updateCkbTxWithRealBtcTxId,
} from 'rgbpp/ckb';
import { getFastestFeeRate, readStepLog, writeStepLog } from '../../shared/utils';
import { saveCkbVirtualTxResult } from '../../../../examples/rgbpp/shared/utils';
import { signAndSendPsbt } from '../../../../examples/rgbpp/shared/btc-account';

// Warning: Before runing this file, please run 1-prepare-cluster.ts
const createCluster = async ({ ownerRgbppLockArgs }: { ownerRgbppLockArgs: string }) => {
  console.log(btcAccount.from);
  const { retry } = await import('zx');

  const feeRate = await getFastestFeeRate();
  console.log('feeRate = ', feeRate);

  await retry(20, '10s', async () => {
    const ckbVirtualTxResult = await genCreateClusterCkbVirtualTx({
      collector,
      rgbppLockArgs: ownerRgbppLockArgs,
      clusterData: CLUSTER_DATA,
      isMainnet,
      ckbFeeRate: BigInt(2000),
      btcTestnetType: BTC_TESTNET_TYPE,
    });

    // Save ckbVirtualTxResult
    saveCkbVirtualTxResult(ckbVirtualTxResult, '2-create-cluster');

    const { commitment, ckbRawTx, clusterId, needPaymasterCell } = ckbVirtualTxResult;

    writeStepLog('clusterid', {
      clusterid: clusterId,
    });
    console.log('clusterId: ', clusterId);

    // Send BTC tx
    const psbt = await sendRgbppUtxos({
      ckbVirtualTx: ckbRawTx,
      commitment,
      tos: [btcAccount.from],
      needPaymaster: needPaymasterCell,
      ckbCollector: collector,
      from: btcAccount.from,
      fromPubkey: btcAccount.fromPubkey,
      source: btcDataSource,
      feeRate: feeRate,
    });

    const { txId: btcTxId, rawTxHex: btcTxBytes } = await signAndSendPsbt(psbt, btcAccount, btcService);

    writeStepLog('create-cluster-id', {
      txid: btcTxId,
      index: 1,
    });
    console.log('BTC TxId: ', btcTxId);
    console.log(`explorer: https://mempool.space/testnet/tx/${btcTxId}`);

    const interval = setInterval(async () => {
      try {
        console.log('Waiting for BTC tx and proof to be ready');
        const rgbppApiSpvProof = await btcService.getRgbppSpvProof(btcTxId, 0);
        clearInterval(interval);
        // Update CKB transaction with the real BTC txId
        const newCkbRawTx = updateCkbTxWithRealBtcTxId({ ckbRawTx, btcTxId, isMainnet });

        console.log('The cluster rgbpp lock args: ', newCkbRawTx.outputs[0].lock.args);

        const ckbTx = await appendCkbTxWitnesses({
          ckbRawTx: newCkbRawTx,
          btcTxBytes,
          rgbppApiSpvProof,
        });
        // Replace cobuild witness with the final rgbpp lock script
        ckbTx.witnesses[ckbTx.witnesses.length - 1] = generateClusterCreateCoBuild(
          ckbTx.outputs[0],
          ckbTx.outputsData[0],
        );

        console.log(JSON.stringify(ckbTx));

        const txHash = await sendCkbTx({ collector, signedTx: ckbTx });
        console.info(`RGB++ Cluster has been created and tx hash is ${txHash}`);
        console.info(`explorer: https://pudge.explorer.nervos.org/transaction/${txHash}`);
      } catch (error) {
        if (!(error instanceof BtcAssetsApiError)) {
          console.error(error);
        }
      }
    }, 30 * 1000);
  });
};

// Please use your real BTC UTXO information on the BTC Testnet which should be same as the 1-prepare-cluster.ts
// rgbppLockArgs: outIndexU32 + btcTxId
createCluster({
  ownerRgbppLockArgs: buildRgbppLockArgs(readStepLog('prepare-utxo').index, readStepLog('prepare-utxo').txid),
});


================================================
File: tests/rgbpp/spore/launch/3-create-spores.ts
================================================
import { BtcAssetsApiError, genCreateSporeCkbVirtualTx, sendRgbppUtxos } from 'rgbpp';
import { isMainnet, collector, btcDataSource, btcService, CKB_PRIVATE_KEY, ckbAddress } from '../../env';
import {
  Hex,
  appendCkbTxWitnesses,
  appendIssuerCellToSporesCreate,
  buildRgbppLockArgs,
  generateSporeCreateCoBuild,
  sendCkbTx,
  updateCkbTxWithRealBtcTxId,
  RawSporeData,
} from 'rgbpp/ckb';
import { utf8ToBuffer } from 'rgbpp/btc';
import { getFastestFeeRate, readStepLog, writeStepLog } from '../../shared/utils';
import { saveCkbVirtualTxResult } from '../../../../examples/rgbpp/shared/utils';
import { BTC_TESTNET_TYPE, btcAccount } from '../../env';
import { signAndSendPsbt } from '../../../../examples/rgbpp/shared/btc-account';

interface SporeCreateParams {
  clusterRgbppLockArgs: Hex;
  receivers: {
    toBtcAddress: string;
    sporeData: RawSporeData;
  }[];
}

// Warning: Before runing this file for the first time, please run 2-prepare-cluster.ts
const createSpores = async ({ clusterRgbppLockArgs, receivers }: SporeCreateParams) => {
  const { retry } = await import('zx');

  const feeRate = await getFastestFeeRate();
  console.log('feeRate = ', feeRate);

  await retry(20, '10s', async () => {
    const ckbVirtualTxResult = await genCreateSporeCkbVirtualTx({
      collector,
      sporeDataList: receivers.map((receiver) => receiver.sporeData),
      clusterRgbppLockArgs,
      isMainnet,
      ckbFeeRate: BigInt(2000),
      btcTestnetType: BTC_TESTNET_TYPE,
    });

    // Save ckbVirtualTxResult
    saveCkbVirtualTxResult(ckbVirtualTxResult, '3-create-spores');

    const { commitment, ckbRawTx, sumInputsCapacity, clusterCell, needPaymasterCell } = ckbVirtualTxResult;

    // Send BTC tx
    // The first btc address is the owner of the cluster cell and the rest btc addresses are spore receivers
    const btcTos = [btcAccount.from, ...receivers.map((receiver) => receiver.toBtcAddress)];
    const psbt = await sendRgbppUtxos({
      ckbVirtualTx: ckbRawTx,
      commitment,
      tos: btcTos,
      needPaymaster: needPaymasterCell,
      ckbCollector: collector,
      from: btcAccount.from,
      fromPubkey: btcAccount.fromPubkey,
      source: btcDataSource,
      feeRate: feeRate,
    });

    const { txId: btcTxId, rawTxHex: btcTxBytes } = await signAndSendPsbt(psbt, btcAccount, btcService);

    writeStepLog('create-spores-id', {
      txid: btcTxId,
    });
    console.log('BTC TxId: ', btcTxId);
    console.log(`explorer: https://mempool.space/testnet/tx/${btcTxId}`);

    const interval = setInterval(async () => {
      try {
        console.log('Waiting for BTC tx and proof to be ready');
        const rgbppApiSpvProof = await btcService.getRgbppSpvProof(btcTxId, 0);
        clearInterval(interval);
        // Update CKB transaction with the real BTC txId
        const newCkbRawTx = updateCkbTxWithRealBtcTxId({ ckbRawTx, btcTxId, isMainnet });
        console.log('The new cluster rgbpp lock args: ', newCkbRawTx.outputs[0].lock.args);

        const ckbTx = await appendCkbTxWitnesses({
          ckbRawTx: newCkbRawTx,
          btcTxBytes,
          rgbppApiSpvProof,
        });

        // The outputs[1..] are spore cells from which you can find spore type scripts,
        // and the spore type scripts will be used to transfer and leap spores
        const sporeTypeScripts = ckbTx.outputs.slice(1).map((output) => output.type);
        console.log('Spore type scripts: ', JSON.stringify(sporeTypeScripts));
        writeStepLog('sporeTypeScripts', sporeTypeScripts);

        // Replace cobuild witness with the final rgbpp lock script
        ckbTx.witnesses[ckbTx.witnesses.length - 1] = generateSporeCreateCoBuild({
          // The first output is cluster cell and the rest of the outputs are spore cells
          sporeOutputs: ckbTx.outputs.slice(1),
          sporeOutputsData: ckbTx.outputsData.slice(1),
          clusterCell,
          clusterOutputCell: ckbTx.outputs[0],
        });

        // console.log('ckbTx: ', JSON.stringify(ckbTx));

        const signedTx = await appendIssuerCellToSporesCreate({
          secp256k1PrivateKey: CKB_PRIVATE_KEY,
          issuerAddress: ckbAddress,
          ckbRawTx: ckbTx,
          collector,
          sumInputsCapacity,
          isMainnet,
        });

        const txHash = await sendCkbTx({ collector, signedTx });
        console.info(`RGB++ Spore has been created and tx hash is ${txHash}`);
        console.info(`explorer: https://pudge.explorer.nervos.org/transaction/${txHash}`);
      } catch (error) {
        if (!(error instanceof BtcAssetsApiError)) {
          console.error(error);
        }
      }
    }, 30 * 1000);
  });
};

// Please use your real BTC UTXO information on the BTC Testnet
// BTC Testnet3: https://mempool.space/testnet
// BTC Signet: https://mempool.space/signet

// rgbppLockArgs: outIndexU32 + btcTxId
createSpores({
  // The cluster cell will be spent and the new cluster cell will be created in each spore creation tx,
  // so the cluster rgbpp lock args should be updated after each spore creation tx is completed.
  // The first cluster rgbpp lock args is from 2-create-cluster.ts and the new cluster rgbpp lock args can be found from the log in the line 71 of this file
  clusterRgbppLockArgs: buildRgbppLockArgs(
    readStepLog('create-cluster-id').index,
    readStepLog('create-cluster-id').txid,
  ),
  receivers: [
    {
      toBtcAddress: 'tb1qssu8pscsuevnmvhnr08840wvuzdan27k9m46ja',
      sporeData: {
        contentType: 'text/plain',
        content: utf8ToBuffer('First Spore'),
        // The cluster id is from 2-create-cluster.ts
        clusterId: readStepLog('clusterid').clusterid,
      },
    },
    {
      toBtcAddress: 'tb1qssu8pscsuevnmvhnr08840wvuzdan27k9m46ja',
      sporeData: {
        contentType: 'text/plain',
        content: utf8ToBuffer('Second Spore'),
        // The cluster id is from 2-create-cluster.ts
        clusterId: readStepLog('clusterid').clusterid,
      },
    },
  ],
});


================================================
File: tests/rgbpp/xudt/1-ckb-leap-btc.ts
================================================
import { serializeScript } from '@nervosnetwork/ckb-sdk-utils';
import { genCkbJumpBtcVirtualTx } from 'rgbpp';
import { getSecp256k1CellDep, buildRgbppLockArgs, getXudtTypeScript } from 'rgbpp/ckb';
import { CKB_PRIVATE_KEY, isMainnet, collector, ckbAddress, BTC_TESTNET_TYPE } from '../env';
import { readStepLog } from '../shared/utils';

interface LeapToBtcParams {
  outIndex: number;
  btcTxId: string;
  xudtTypeArgs: string;
  transferAmount: bigint;
}

const leapFromCkbToBtc = async ({ outIndex, btcTxId, xudtTypeArgs, transferAmount }: LeapToBtcParams) => {
  const { retry } = await import('zx');
  await retry(20, '10s', async () => {
    const toRgbppLockArgs = buildRgbppLockArgs(outIndex, btcTxId);

    // Warning: Please replace with your real xUDT type script here
    const xudtType: CKBComponents.Script = {
      ...getXudtTypeScript(isMainnet),
      args: xudtTypeArgs,
    };

    const ckbRawTx = await genCkbJumpBtcVirtualTx({
      collector,
      fromCkbAddress: ckbAddress,
      toRgbppLockArgs,
      xudtTypeBytes: serializeScript(xudtType),
      transferAmount,
      btcTestnetType: BTC_TESTNET_TYPE,
    });

    const emptyWitness = { lock: '', inputType: '', outputType: '' };
    const unsignedTx: CKBComponents.RawTransactionToSign = {
      ...ckbRawTx,
      cellDeps: [...ckbRawTx.cellDeps, getSecp256k1CellDep(isMainnet)],
      witnesses: [emptyWitness, ...ckbRawTx.witnesses.slice(1)],
    };

    const signedTx = collector.getCkb().signTransaction(CKB_PRIVATE_KEY)(unsignedTx);

    const txHash = await collector.getCkb().rpc.sendTransaction(signedTx, 'passthrough');
    console.info(`Rgbpp asset has been jumped from CKB to BTC and CKB tx hash is ${txHash}`);
    console.info(`explorer: https://pudge.explorer.nervos.org/transaction/${txHash}`);
  });
};

// Use your real BTC UTXO information on the BTC Testnet
leapFromCkbToBtc({
  outIndex: readStepLog('prepare-utxo').index,
  btcTxId: readStepLog('prepare-utxo').txid,
  xudtTypeArgs: readStepLog('xUDT-type-script').args,
  transferAmount: BigInt(800_0000_0000),
});


================================================
File: tests/rgbpp/xudt/2-btc-transfer.ts
================================================
import { buildRgbppLockArgs } from 'rgbpp/ckb';
import { buildRgbppTransferTx } from 'rgbpp';
import { isMainnet, collector, btcService, btcDataSource, BTC_TESTNET_TYPE, btcAccount } from '../env';
import { getFastestFeeRate, readStepLog, writeStepLog } from '../shared/utils';
import { saveCkbVirtualTxResult } from '../../../examples/rgbpp/shared/utils';
import { bitcoin } from 'rgbpp/btc';
import { signAndSendPsbt } from '../../../examples/rgbpp/shared/btc-account';

interface RgbppTransferParams {
  rgbppLockArgsList: string[];
  toBtcAddress: string;
  xudtTypeArgs: string;
  transferAmount: bigint;
}

const transfer = async ({ rgbppLockArgsList, toBtcAddress, xudtTypeArgs, transferAmount }: RgbppTransferParams) => {
  const { retry } = await import('zx');

  const feeRate = await getFastestFeeRate();
  console.log('feeRate = ', feeRate);

  await retry(120, '10s', async () => {
    const { ckbVirtualTxResult, btcPsbtHex } = await buildRgbppTransferTx({
      ckb: {
        collector,
        xudtTypeArgs,
        rgbppLockArgsList,
        transferAmount,
      },
      btc: {
        fromAddress: btcAccount.from,
        toAddress: toBtcAddress,
        fromPubkey: btcAccount.fromPubkey,
        dataSource: btcDataSource,
        testnetType: BTC_TESTNET_TYPE,
        feeRate: feeRate,
      },
      isMainnet,
    });

    // Save ckbVirtualTxResult
    saveCkbVirtualTxResult(ckbVirtualTxResult, '2-btc-transfer');

    // Send BTC tx
    const psbt = bitcoin.Psbt.fromHex(btcPsbtHex);
    const { txId: btcTxId } = await signAndSendPsbt(psbt, btcAccount, btcService);
    console.log(`BTC ${BTC_TESTNET_TYPE} TxId: ${btcTxId}`);
    console.log(`explorer: https://mempool.space/testnet/tx/${btcTxId}`);

    writeStepLog('transfer-id', {
      txid: btcTxId,
      index: 1,
    });

    await btcService.sendRgbppCkbTransaction({ btc_txid: btcTxId, ckb_virtual_result: ckbVirtualTxResult });

    try {
      const interval = setInterval(async () => {
        const { state, failedReason } = await btcService.getRgbppTransactionState(btcTxId);
        console.log('state', state);
        if (state === 'completed' || state === 'failed') {
          clearInterval(interval);
          if (state === 'completed') {
            const { txhash: txHash } = await btcService.getRgbppTransactionHash(btcTxId);
            console.info(`Rgbpp asset has been transferred on BTC and the related CKB tx hash is ${txHash}`);
            console.info(`explorer: https://pudge.explorer.nervos.org/transaction/${txHash}`);
          } else {
            console.warn(`Rgbpp CKB transaction failed and the reason is ${failedReason} `);
          }
        }
      }, 30 * 1000);
    } catch (error) {
      console.error(error);
    }
  });
};

// Use your real BTC UTXO information on the BTC Testnet
// rgbppLockArgs: outIndexU32 + btcTxId
transfer({
  rgbppLockArgsList: [buildRgbppLockArgs(readStepLog('prepare-utxo').index, readStepLog('prepare-utxo').txid)],
  toBtcAddress: 'tb1qtt2vh9q8xam35xxsy35ec6majad8lz8fep8w04',
  xudtTypeArgs: readStepLog('xUDT-type-script').args,
  transferAmount: BigInt(500_0000_0000),
});


================================================
File: tests/rgbpp/xudt/3-btc-leap-ckb.ts
================================================
import { buildRgbppLockArgs, getXudtTypeScript } from 'rgbpp/ckb';
import { serializeScript } from '@nervosnetwork/ckb-sdk-utils';
import { genBtcJumpCkbVirtualTx, sendRgbppUtxos } from 'rgbpp';
import { isMainnet, collector, btcService, btcDataSource, btcAccount, BTC_TESTNET_TYPE } from '../env';
import { getFastestFeeRate, readStepLog } from '../shared/utils';
import { saveCkbVirtualTxResult } from '../../../examples/rgbpp/shared/utils';
import { signAndSendPsbt } from '../../../examples/rgbpp/shared/btc-account';

interface LeapToCkbParams {
  rgbppLockArgsList: string[];
  toCkbAddress: string;
  xudtTypeArgs: string;
  transferAmount: bigint;
}

const leapFromBtcToCKB = async ({ rgbppLockArgsList, toCkbAddress, xudtTypeArgs, transferAmount }: LeapToCkbParams) => {
  const { retry } = await import('zx');

  const feeRate = await getFastestFeeRate();
  console.log('feeRate = ', feeRate);

  await retry(120, '10s', async () => {
    const xudtType: CKBComponents.Script = {
      ...getXudtTypeScript(isMainnet),
      args: xudtTypeArgs,
    };

    const ckbVirtualTxResult = await genBtcJumpCkbVirtualTx({
      collector,
      rgbppLockArgsList,
      xudtTypeBytes: serializeScript(xudtType),
      transferAmount,
      toCkbAddress,
      isMainnet,
      btcTestnetType: BTC_TESTNET_TYPE,
      // btcConfirmationBlocks: 20, // default value is 6
    });

    // Save ckbVirtualTxResult
    saveCkbVirtualTxResult(ckbVirtualTxResult, '3-btc-leap-ckb');

    const { commitment, ckbRawTx } = ckbVirtualTxResult;

    // Send BTC tx
    const psbt = await sendRgbppUtxos({
      ckbVirtualTx: ckbRawTx,
      commitment,
      tos: [btcAccount.from],
      ckbCollector: collector,
      from: btcAccount.from,
      fromPubkey: btcAccount.fromPubkey,
      source: btcDataSource,
      feeRate: feeRate,
    });

    const { txId: btcTxId } = await signAndSendPsbt(psbt, btcAccount, btcService);
    console.log(`BTC ${BTC_TESTNET_TYPE} TxId: ${btcTxId}`);
    console.log(`explorer: https://mempool.space/testnet/tx/${btcTxId}`);

    await btcService.sendRgbppCkbTransaction({ btc_txid: btcTxId, ckb_virtual_result: ckbVirtualTxResult });

    try {
      const interval = setInterval(async () => {
        const { state, failedReason } = await btcService.getRgbppTransactionState(btcTxId);
        console.log('state', state);
        if (state === 'completed' || state === 'failed') {
          clearInterval(interval);
          if (state === 'completed') {
            const { txhash: txHash } = await btcService.getRgbppTransactionHash(btcTxId);
            console.info(`Rgbpp asset has been jumped from BTC to CKB and the related CKB tx hash is ${txHash}`);
            console.info(`explorer: https://pudge.explorer.nervos.org/transaction/${txHash}`);
          } else {
            console.warn(`Rgbpp CKB transaction failed and the reason is ${failedReason} `);
          }
        }
      }, 30 * 1000);
    } catch (error) {
      console.error(error);
    }
  });
};

// rgbppLockArgs: outIndexU32 + btcTxId
leapFromBtcToCKB({
  rgbppLockArgsList: [buildRgbppLockArgs(readStepLog('transfer-id').index, readStepLog('transfer-id').txid)],
  toCkbAddress: 'ckt1qrfrwcdnvssswdwpn3s9v8fp87emat306ctjwsm3nmlkjg8qyza2cqgqq9kxr7vy7yknezj0vj0xptx6thk6pwyr0sxamv6q',
  xudtTypeArgs: readStepLog('xUDT-type-script').args,
  transferAmount: BigInt(300_0000_0000),
});


================================================
File: tests/rgbpp/xudt/btc-transfer-all/1-btc-transfer-all.ts
================================================
import { bitcoin } from 'rgbpp/btc';
import { buildRgbppTransferAllTxs, sendRgbppTxGroups } from 'rgbpp';
import { btcDataSource, isMainnet, collector, btcAccount } from '../../env';
import { signPsbt } from '../../../../examples/rgbpp/shared/btc-account';
import { saveCkbVirtualTxResult } from '../../../../examples/rgbpp/shared/utils';
import { getFastestFeeRate, readStepLog } from '../../shared/utils';

interface TestParams {
  xudtTypeArgs: string;
  fromAddress: string;
  toAddress: string;
}

const rgbppTransferAllTxs = async ({ xudtTypeArgs, fromAddress, toAddress }: TestParams) => {
  const feeRate = await getFastestFeeRate();
  console.log('feeRate = ', feeRate);

  const result = await buildRgbppTransferAllTxs({
    ckb: {
      xudtTypeArgs,
      collector,
    },
    btc: {
      assetAddresses: [fromAddress],
      fromAddress: fromAddress,
      toAddress: toAddress,
      dataSource: btcDataSource,
      feeRate: feeRate,
    },
    isMainnet,
  });

  console.log('result.transactions.length', result.transactions.length);
  console.log('result.summary.included.assets', result.summary.included.xudtAssets);
  console.log('result.summary.excluded.assets', result.summary.excluded.xudtAssets);

  const signedGroups = await Promise.all(
    result.transactions.map(async (group) => {
      const psbt = bitcoin.Psbt.fromHex(group.btc.psbtHex);

      // Sign transactions
      signPsbt(psbt, btcAccount);

      psbt.finalizeAllInputs();

      return {
        ckbVirtualTxResult: JSON.stringify(group.ckb.virtualTxResult),
        btcTxHex: psbt.extractTransaction().toHex(),
      };
    }),
  );

  const signedGroupsData = JSON.parse(JSON.stringify(signedGroups, null, 2));

  // Save signedGroupsData
  saveCkbVirtualTxResult(signedGroupsData, '1-btc-transfer-all');

  console.log('signedGroups', signedGroupsData);

  // Send transactions
  const sentGroups = await sendRgbppTxGroups({
    txGroups: signedGroups,
    btcService: btcDataSource.service,
  });
  console.log('sentGroups', JSON.stringify(sentGroups, null, 2));

  const successfulTxIds = sentGroups
    .filter((group) => group.btcTxId)
    .map((group) => `https://mempool.space/testnet/tx/${group.btcTxId}`);

  console.log('Successful Transactions:', successfulTxIds.join('\n'));

  try {
    const interval = setInterval(async () => {
      try {
        const states = await Promise.all(
          sentGroups
            .filter((group) => group.btcTxId)
            .map(async (group) => {
              const btcTxId = group.btcTxId!;
              const { state, failedReason } = await btcDataSource.service.getRgbppTransactionState(btcTxId);
              return { btcTxId, state, failedReason };
            }),
        );

        for (const { btcTxId, state, failedReason } of states) {
          console.log(`State for transaction ${btcTxId}: ${state}`);
          if (state === 'completed' || state === 'failed') {
            if (state === 'completed') {
              const { txhash: txHash } = await btcDataSource.service.getRgbppTransactionHash(btcTxId);
              console.info(`Rgbpp asset has been transferred on BTC and the related CKB tx hash is ${txHash}`);
              console.info(`Explorer: https://pudge.explorer.nervos.org/transaction/${txHash}`);
            } else {
              console.warn(`Rgbpp CKB transaction failed and the reason is ${failedReason}`);
            }
          }
        }

        if (states.every(({ state }) => state === 'completed' || state === 'failed')) {
          clearInterval(interval);
        }
      } catch (error) {
        console.error('Error during transaction state tracking:', error);
      }
    }, 30 * 1000);
  } catch (error) {
    console.error('Error during transaction state tracking:', error);
  }
};

rgbppTransferAllTxs({
  // Please use your own RGB++ xudt asset's xudtTypeArgs
  xudtTypeArgs: readStepLog('xUDT-type-script').args,
  fromAddress: btcAccount.from,
  toAddress: 'tb1qdnvvnyhc5wegxgh0udwaej04n8w08ahrr0w4q9',
}).catch(console.error);


================================================
File: tests/rgbpp/xudt/compatible-xudt/1-ckb-leap-btc.ts
================================================
import { serializeScript } from '@nervosnetwork/ckb-sdk-utils';
import { genCkbJumpBtcVirtualTx } from 'rgbpp';
import { getSecp256k1CellDep, buildRgbppLockArgs, CompatibleXUDTRegistry } from 'rgbpp/ckb';
import { CKB_PRIVATE_KEY, isMainnet, collector, ckbAddress, BTC_TESTNET_TYPE } from '../../env';
import { readStepLog } from '../../shared/utils';

interface LeapToBtcParams {
  outIndex: number;
  btcTxId: string;
  compatibleXudtTypeScript: CKBComponents.Script;
  transferAmount: bigint;
}

const leapFromCkbToBtc = async ({ outIndex, btcTxId, compatibleXudtTypeScript, transferAmount }: LeapToBtcParams) => {
  const { retry } = await import('zx');
  await retry(20, '10s', async () => {
    const toRgbppLockArgs = buildRgbppLockArgs(outIndex, btcTxId);

    // Refresh the cache by fetching the latest compatible xUDT list from the specified URL.
    // The default URL is:
    // https://raw.githubusercontent.com/utxostack/typeid-contract-cell-deps/main/compatible-udt.json
    // You can set your own trusted URL to fetch the compatible xUDT list.
    // await CompatibleXUDTRegistry.refreshCache("https://your-own-trusted-compatible-xudt-url");
    await CompatibleXUDTRegistry.refreshCache();

    const ckbRawTx = await genCkbJumpBtcVirtualTx({
      collector,
      fromCkbAddress: ckbAddress,
      toRgbppLockArgs,
      xudtTypeBytes: serializeScript(compatibleXudtTypeScript),
      transferAmount,
      btcTestnetType: BTC_TESTNET_TYPE,
    });

    const emptyWitness = { lock: '', inputType: '', outputType: '' };
    const unsignedTx: CKBComponents.RawTransactionToSign = {
      ...ckbRawTx,
      cellDeps: [...ckbRawTx.cellDeps, getSecp256k1CellDep(isMainnet)],
      witnesses: [emptyWitness, ...ckbRawTx.witnesses.slice(1)],
    };

    const signedTx = collector.getCkb().signTransaction(CKB_PRIVATE_KEY)(unsignedTx);

    const txHash = await collector.getCkb().rpc.sendTransaction(signedTx, 'passthrough');
    console.info(`Rgbpp compatible xUDT asset has been jumped from CKB to BTC and CKB tx hash is ${txHash}`);
    console.info(`explorer: https://pudge.explorer.nervos.org/transaction/${txHash}`);
  });
};

// Use your real BTC UTXO information on the BTC Testnet
leapFromCkbToBtc({
  outIndex: readStepLog('prepare-utxo').index,
  btcTxId: readStepLog('prepare-utxo').txid,
  compatibleXudtTypeScript: {
    codeHash: '0x1142755a044bf2ee358cba9f2da187ce928c91cd4dc8692ded0337efa677d21a',
    hashType: 'type',
    args: '0x878fcc6f1f08d48e87bb1c3b3d5083f23f8a39c5d5c764f253b55b998526439b',
  },
  transferAmount: BigInt(100_0000),
});


================================================
File: tests/rgbpp/xudt/compatible-xudt/2-btc-transfer.ts
================================================
import { buildRgbppLockArgs, CompatibleXUDTRegistry } from 'rgbpp/ckb';
import { buildRgbppTransferTx } from 'rgbpp';
import { isMainnet, collector, btcService, btcDataSource, BTC_TESTNET_TYPE, btcAccount } from '../../env';
import { getFastestFeeRate, readStepLog, writeStepLog } from '../../shared/utils';
import { saveCkbVirtualTxResult } from '../../../../examples/rgbpp/shared/utils';
import { bitcoin } from 'rgbpp/btc';
import { signAndSendPsbt } from '../../../../examples/rgbpp/shared/btc-account';

interface RgbppTransferParams {
  rgbppLockArgsList: string[];
  toBtcAddress: string;
  compatibleXudtTypeScript: CKBComponents.Script;
  transferAmount: bigint;
}

const transfer = async ({
  rgbppLockArgsList,
  toBtcAddress,
  compatibleXudtTypeScript,
  transferAmount,
}: RgbppTransferParams) => {
  const { retry } = await import('zx');

  // Refresh the cache by fetching the latest compatible xUDT list from the specified URL.
  // The default URL is:
  // https://raw.githubusercontent.com/utxostack/typeid-contract-cell-deps/main/compatible-udt.json
  // You can set your own trusted URL to fetch the compatible xUDT list.
  // await CompatibleXUDTRegistry.refreshCache("https://your-own-trusted-compatible-xudt-url");
  await CompatibleXUDTRegistry.refreshCache();

  const feeRate = await getFastestFeeRate();
  console.log('feeRate = ', feeRate);

  await retry(120, '10s', async () => {
    const { ckbVirtualTxResult, btcPsbtHex } = await buildRgbppTransferTx({
      ckb: {
        collector,
        xudtTypeArgs: compatibleXudtTypeScript.args,
        rgbppLockArgsList,
        transferAmount,
        compatibleXudtTypeScript,
      },
      btc: {
        fromAddress: btcAccount.from,
        toAddress: toBtcAddress,
        fromPubkey: btcAccount.fromPubkey,
        dataSource: btcDataSource,
        testnetType: BTC_TESTNET_TYPE,
        feeRate: feeRate,
      },
      isMainnet,
    });

    // Save ckbVirtualTxResult
    saveCkbVirtualTxResult(ckbVirtualTxResult, '2-btc-transfer');

    // Send BTC tx
    const psbt = bitcoin.Psbt.fromHex(btcPsbtHex);
    const { txId: btcTxId } = await signAndSendPsbt(psbt, btcAccount, btcService);
    console.log(`BTC ${BTC_TESTNET_TYPE} TxId: ${btcTxId}`);
    console.log(`explorer: https://mempool.space/testnet/tx/${btcTxId}`);

    writeStepLog('transfer-id', {
      txid: btcTxId,
      index: 1,
    });

    await btcService.sendRgbppCkbTransaction({ btc_txid: btcTxId, ckb_virtual_result: ckbVirtualTxResult });

    try {
      const interval = setInterval(async () => {
        const { state, failedReason } = await btcService.getRgbppTransactionState(btcTxId);
        console.log('state', state);
        if (state === 'completed' || state === 'failed') {
          clearInterval(interval);
          if (state === 'completed') {
            const { txhash: txHash } = await btcService.getRgbppTransactionHash(btcTxId);
            console.info(
              `Rgbpp compatible xUDT asset has been transferred on BTC and the related CKB tx hash is ${txHash}`,
            );
            console.info(`explorer: https://pudge.explorer.nervos.org/transaction/${txHash}`);
          } else {
            console.warn(`Rgbpp CKB transaction failed and the reason is ${failedReason} `);
          }
        }
      }, 30 * 1000);
    } catch (error) {
      console.error(error);
    }
  });
};

// Use your real BTC UTXO information on the BTC Testnet
// rgbppLockArgs: outIndexU32 + btcTxId
transfer({
  rgbppLockArgsList: [buildRgbppLockArgs(readStepLog('prepare-utxo').index, readStepLog('prepare-utxo').txid)],
  toBtcAddress: 'tb1q6jf0qguvjz65e4xxdvsltugf4d673hh8nj32gq',
  compatibleXudtTypeScript: {
    codeHash: '0x1142755a044bf2ee358cba9f2da187ce928c91cd4dc8692ded0337efa677d21a',
    hashType: 'type',
    args: '0x878fcc6f1f08d48e87bb1c3b3d5083f23f8a39c5d5c764f253b55b998526439b',
  },
  transferAmount: BigInt(100_0000),
});


================================================
File: tests/rgbpp/xudt/compatible-xudt/3-btc-leap-ckb.ts
================================================
import { buildRgbppLockArgs, CompatibleXUDTRegistry } from 'rgbpp/ckb';
import { serializeScript } from '@nervosnetwork/ckb-sdk-utils';
import { genBtcJumpCkbVirtualTx, sendRgbppUtxos } from 'rgbpp';
import { isMainnet, collector, btcService, btcDataSource, btcAccount, BTC_TESTNET_TYPE } from '../../env';
import { getFastestFeeRate, readStepLog } from '../../shared/utils';
import { saveCkbVirtualTxResult } from '../../../../examples/rgbpp/shared/utils';
import { signAndSendPsbt } from '../../../../examples/rgbpp/shared/btc-account';

interface LeapToCkbParams {
  rgbppLockArgsList: string[];
  toCkbAddress: string;
  compatibleXudtTypeScript: CKBComponents.Script;
  transferAmount: bigint;
}

const leapFromBtcToCKB = async ({
  rgbppLockArgsList,
  toCkbAddress,
  compatibleXudtTypeScript,
  transferAmount,
}: LeapToCkbParams) => {
  const { retry } = await import('zx');

  // Refresh the cache by fetching the latest compatible xUDT list from the specified URL.
  // The default URL is:
  // https://raw.githubusercontent.com/utxostack/typeid-contract-cell-deps/main/compatible-udt.json
  // You can set your own trusted URL to fetch the compatible xUDT list.
  // await CompatibleXUDTRegistry.refreshCache("https://your-own-trusted-compatible-xudt-url");
  await CompatibleXUDTRegistry.refreshCache();

  const feeRate = await getFastestFeeRate();
  console.log('feeRate = ', feeRate);

  await retry(120, '10s', async () => {
    const ckbVirtualTxResult = await genBtcJumpCkbVirtualTx({
      collector,
      rgbppLockArgsList,
      xudtTypeBytes: serializeScript(compatibleXudtTypeScript),
      transferAmount,
      toCkbAddress,
      isMainnet,
      btcTestnetType: BTC_TESTNET_TYPE,
      // btcConfirmationBlocks: 20, // default value is 6
    });

    // Save ckbVirtualTxResult
    saveCkbVirtualTxResult(ckbVirtualTxResult, '3-btc-leap-ckb');

    const { commitment, ckbRawTx } = ckbVirtualTxResult;

    // Send BTC tx
    const psbt = await sendRgbppUtxos({
      ckbVirtualTx: ckbRawTx,
      commitment,
      tos: [btcAccount.from],
      ckbCollector: collector,
      from: btcAccount.from,
      fromPubkey: btcAccount.fromPubkey,
      source: btcDataSource,
      feeRate: feeRate,
    });

    const { txId: btcTxId } = await signAndSendPsbt(psbt, btcAccount, btcService);
    console.log(`BTC ${BTC_TESTNET_TYPE} TxId: ${btcTxId}`);
    console.log(`explorer: https://mempool.space/testnet/tx/${btcTxId}`);

    await btcService.sendRgbppCkbTransaction({ btc_txid: btcTxId, ckb_virtual_result: ckbVirtualTxResult });

    try {
      const interval = setInterval(async () => {
        const { state, failedReason } = await btcService.getRgbppTransactionState(btcTxId);
        console.log('state', state);
        if (state === 'completed' || state === 'failed') {
          clearInterval(interval);
          if (state === 'completed') {
            const { txhash: txHash } = await btcService.getRgbppTransactionHash(btcTxId);
            console.info(
              `Rgbpp compatible xUDT asset has been jumped from BTC to CKB and the related CKB tx hash is ${txHash}`,
            );
            console.info(`explorer: https://pudge.explorer.nervos.org/transaction/${txHash}`);
          } else {
            console.warn(`Rgbpp CKB transaction failed and the reason is ${failedReason} `);
          }
        }
      }, 30 * 1000);
    } catch (error) {
      console.error(error);
    }
  });
};

// rgbppLockArgs: outIndexU32 + btcTxId
leapFromBtcToCKB({
  rgbppLockArgsList: [buildRgbppLockArgs(readStepLog('transfer-id').index, readStepLog('transfer-id').txid)],
  toCkbAddress: 'ckt1qrfrwcdnvssswdwpn3s9v8fp87emat306ctjwsm3nmlkjg8qyza2cqgqq9kxr7vy7yknezj0vj0xptx6thk6pwyr0sxamv6q',
  compatibleXudtTypeScript: {
    codeHash: '0x1142755a044bf2ee358cba9f2da187ce928c91cd4dc8692ded0337efa677d21a',
    hashType: 'type',
    args: '0x878fcc6f1f08d48e87bb1c3b3d5083f23f8a39c5d5c764f253b55b998526439b',
  },
  transferAmount: BigInt(100_0000),
});


================================================
File: tests/rgbpp/xudt/xudt-on-ckb/1-issue-xudt.ts
================================================
import { addressToScript, getTransactionSize, scriptToHash } from '@nervosnetwork/ckb-sdk-utils';
import {
  getSecp256k1CellDep,
  RgbppTokenInfo,
  NoLiveCellError,
  calculateUdtCellCapacity,
  MAX_FEE,
  MIN_CAPACITY,
  getXudtTypeScript,
  append0x,
  getUniqueTypeScript,
  u128ToLe,
  encodeRgbppTokenInfo,
  getXudtDep,
  getUniqueTypeDep,
  SECP256K1_WITNESS_LOCK_SIZE,
  calculateTransactionFee,
  generateUniqueTypeArgs,
  calculateXudtTokenInfoCellCapacity,
} from 'rgbpp/ckb';
import { CKB_PRIVATE_KEY, ckbAddress, collector, isMainnet } from '../../env';
import { writeStepLog } from '../../shared/utils';

/**
 * issueXudt can be used to issue xUDT assets with unique cell as token info cell.
 * @param xudtTotalAmount The xudtTotalAmount specifies the total amount of asset issuance
 * @param tokenInfo The xUDT token info which includes decimal, name and symbol
 */
const issueXudt = async ({ xudtTotalAmount, tokenInfo }: { xudtTotalAmount: bigint; tokenInfo: RgbppTokenInfo }) => {
  console.log(ckbAddress);
  const issueLock = addressToScript(ckbAddress);

  let emptyCells = await collector.getCells({
    lock: issueLock,
  });
  if (!emptyCells || emptyCells.length === 0) {
    throw new NoLiveCellError('The address has no empty cells');
  }
  emptyCells = emptyCells.filter((cell) => !cell.output.type);

  const xudtCapacity = calculateUdtCellCapacity(issueLock);
  const xudtInfoCapacity = calculateXudtTokenInfoCellCapacity(tokenInfo, issueLock);

  const txFee = MAX_FEE;
  const { inputs, sumInputsCapacity } = collector.collectInputs(emptyCells, xudtCapacity + xudtInfoCapacity, txFee, {
    minCapacity: MIN_CAPACITY,
  });

  const xudtType: CKBComponents.Script = {
    ...getXudtTypeScript(isMainnet),
    args: append0x(scriptToHash(issueLock)),
  };

  console.log('xUDT type script', xudtType);

  writeStepLog('xUDT-type-script', {
    codeHash: xudtType.codeHash,
    hashType: xudtType.hashType,
    args: xudtType.args,
  });

  let changeCapacity = sumInputsCapacity - xudtCapacity - xudtInfoCapacity;
  const outputs: CKBComponents.CellOutput[] = [
    {
      lock: issueLock,
      type: xudtType,
      capacity: append0x(xudtCapacity.toString(16)),
    },
    {
      lock: issueLock,
      type: {
        ...getUniqueTypeScript(isMainnet),
        args: generateUniqueTypeArgs(inputs[0], 1),
      },
      capacity: append0x(xudtInfoCapacity.toString(16)),
    },
    {
      lock: issueLock,
      capacity: append0x(changeCapacity.toString(16)),
    },
  ];
  const totalAmount = xudtTotalAmount * BigInt(10 ** tokenInfo.decimal);
  const outputsData = [append0x(u128ToLe(totalAmount)), encodeRgbppTokenInfo(tokenInfo), '0x'];

  const emptyWitness = { lock: '', inputType: '', outputType: '' };
  const witnesses = inputs.map((_, index) => (index === 0 ? emptyWitness : '0x'));

  const cellDeps = [getSecp256k1CellDep(isMainnet), getUniqueTypeDep(isMainnet), getXudtDep(isMainnet)];

  const unsignedTx = {
    version: '0x0',
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses,
  };

  if (txFee === MAX_FEE) {
    const txSize = getTransactionSize(unsignedTx) + SECP256K1_WITNESS_LOCK_SIZE;
    const estimatedTxFee = calculateTransactionFee(txSize);
    changeCapacity -= estimatedTxFee;
    unsignedTx.outputs[unsignedTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));
  }

  const signedTx = collector.getCkb().signTransaction(CKB_PRIVATE_KEY)(unsignedTx);
  const txHash = await collector.getCkb().rpc.sendTransaction(signedTx, 'passthrough');

  console.info(`xUDT asset on CKB has been issued and tx hash is ${txHash}`);
  console.info(`explorer: https://pudge.explorer.nervos.org/transaction/${txHash}`);
};

const XUDT_TOKEN_INFO: RgbppTokenInfo = {
  decimal: 8,
  name: 'XUDT Test Token',
  symbol: 'PDD',
};

issueXudt({ xudtTotalAmount: BigInt(2100_0000), tokenInfo: XUDT_TOKEN_INFO });


================================================
File: tests/rgbpp/xudt/xudt-on-ckb/2-transfer-xudt.ts
================================================
import { addressToScript, getTransactionSize } from '@nervosnetwork/ckb-sdk-utils';
import {
  getSecp256k1CellDep,
  RgbppTokenInfo,
  NoLiveCellError,
  calculateUdtCellCapacity,
  MAX_FEE,
  MIN_CAPACITY,
  append0x,
  u128ToLe,
  SECP256K1_WITNESS_LOCK_SIZE,
  calculateTransactionFee,
  NoXudtLiveCellError,
  fetchTypeIdCellDeps,
} from 'rgbpp/ckb';
import { CKB_PRIVATE_KEY, ckbAddress, collector, isMainnet } from '../../env';
import { readStepLog } from '../../shared/utils';

interface XudtTransferParams {
  xudtType: CKBComponents.Script;
  receivers: {
    toAddress: string;
    transferAmount: bigint;
  }[];
}

/**
 * transferXudt can be used to mint xUDT assets or transfer xUDT assets.
 * @param xudtType The xUDT type script that comes from 1-issue-xudt
 * @param receivers The receiver includes toAddress and transferAmount
 */
const transferXudt = async ({ xudtType, receivers }: XudtTransferParams) => {
  const { retry } = await import('zx');
  await retry(12, '10s', async () => {
    const fromLock = addressToScript(ckbAddress);

    const xudtCells = await collector.getCells({
      lock: fromLock,
      type: xudtType,
    });
    if (!xudtCells || xudtCells.length === 0) {
      throw new NoXudtLiveCellError('The address has no xudt cells');
    }
    const sumTransferAmount = receivers
      .map((receiver) => receiver.transferAmount)
      .reduce((prev, current) => prev + current, BigInt(0));

    let sumXudtOutputCapacity = receivers
      .map(({ toAddress }) => calculateUdtCellCapacity(addressToScript(toAddress)))
      .reduce((prev, current) => prev + current, BigInt(0));

    const {
      inputs: udtInputs,
      sumInputsCapacity: sumXudtInputsCapacity,
      sumAmount,
    } = collector.collectUdtInputs({
      liveCells: xudtCells,
      needAmount: sumTransferAmount,
    });
    let actualInputsCapacity = sumXudtInputsCapacity;
    let inputs = udtInputs;

    const outputs: CKBComponents.CellOutput[] = receivers.map(({ toAddress }) => ({
      lock: addressToScript(toAddress),
      type: xudtType,
      capacity: append0x(calculateUdtCellCapacity(addressToScript(toAddress)).toString(16)),
    }));
    const outputsData = receivers.map(({ transferAmount }) => append0x(u128ToLe(transferAmount)));

    if (sumAmount > sumTransferAmount) {
      const xudtChangeCapacity = calculateUdtCellCapacity(fromLock);
      outputs.push({
        lock: fromLock,
        type: xudtType,
        capacity: append0x(xudtChangeCapacity.toString(16)),
      });
      outputsData.push(append0x(u128ToLe(sumAmount - sumTransferAmount)));
      sumXudtOutputCapacity += xudtChangeCapacity;
    }

    const txFee = MAX_FEE;
    if (sumXudtInputsCapacity <= sumXudtOutputCapacity) {
      let emptyCells = await collector.getCells({
        lock: fromLock,
      });
      if (!emptyCells || emptyCells.length === 0) {
        throw new NoLiveCellError('The address has no empty cells');
      }
      emptyCells = emptyCells.filter((cell) => !cell.output.type);
      const needCapacity = sumXudtOutputCapacity - sumXudtInputsCapacity;
      const { inputs: emptyInputs, sumInputsCapacity: sumEmptyCapacity } = collector.collectInputs(
        emptyCells,
        needCapacity,
        txFee,
        { minCapacity: MIN_CAPACITY },
      );
      inputs = [...inputs, ...emptyInputs];
      actualInputsCapacity += sumEmptyCapacity;
    }

    let changeCapacity = actualInputsCapacity - sumXudtOutputCapacity;
    outputs.push({
      lock: fromLock,
      capacity: append0x(changeCapacity.toString(16)),
    });
    outputsData.push('0x');

    const emptyWitness = { lock: '', inputType: '', outputType: '' };
    const witnesses = inputs.map((_, index) => (index === 0 ? emptyWitness : '0x'));

    const cellDeps = [getSecp256k1CellDep(isMainnet), ...(await fetchTypeIdCellDeps(isMainnet, { xudt: true }))];

    const unsignedTx = {
      version: '0x0',
      cellDeps,
      headerDeps: [],
      inputs,
      outputs,
      outputsData,
      witnesses,
    };

    if (txFee === MAX_FEE) {
      const txSize = getTransactionSize(unsignedTx) + SECP256K1_WITNESS_LOCK_SIZE;
      const estimatedTxFee = calculateTransactionFee(txSize);
      changeCapacity -= estimatedTxFee;
      unsignedTx.outputs[unsignedTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));
    }

    const signedTx = collector.getCkb().signTransaction(CKB_PRIVATE_KEY)(unsignedTx);
    const txHash = await collector.getCkb().rpc.sendTransaction(signedTx, 'passthrough');

    console.info(`xUDT asset has been minted or transferred and tx hash is ${txHash}`);
    console.info(`explorer: https://pudge.explorer.nervos.org/transaction/${txHash}`);
  });
};

const XUDT_TOKEN_INFO: RgbppTokenInfo = {
  decimal: 8,
  name: 'XUDT Test Token',
  symbol: 'PDD',
};

transferXudt({
  // The xudtType comes from 1-issue-xudt
  xudtType: {
    codeHash: readStepLog('xUDT-type-script').codeHash,
    hashType: readStepLog('xUDT-type-script').hashType,
    args: readStepLog('xUDT-type-script').args,
  },
  receivers: [
    {
      toAddress: 'ckt1qrfrwcdnvssswdwpn3s9v8fp87emat306ctjwsm3nmlkjg8qyza2cqgqqxtfdmw2e5kzfcz536qrnf6w36kyhpzweupegx46',
      transferAmount: BigInt(1) * BigInt(10 ** XUDT_TOKEN_INFO.decimal),
    },
    {
      toAddress: 'ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsqgj8re09l7gk267ank62hadpp3t2kp20kqnud0jc',
      transferAmount: BigInt(1000) * BigInt(10 ** XUDT_TOKEN_INFO.decimal),
    },
    {
      toAddress: 'ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsqgj8re09l7gk267ank62hadpp3t2kp20kqnud0jc',
      transferAmount: BigInt(2000) * BigInt(10 ** XUDT_TOKEN_INFO.decimal),
    },
  ],
});


================================================
File: .changeset/README.md
================================================
# Changesets

Hello and welcome! This folder has been automatically generated by `@changesets/cli`, a build tool that works
with multi-package repos, or single-package repos to help you version and publish your code. You can
find the full documentation for it [in our repository](https://github.com/changesets/changesets)

We have a quick list of common questions to get you started engaging with this project in
[our documentation](https://github.com/changesets/changesets/blob/main/docs/common-questions.md)


================================================
File: .changeset/changelog-format.cjs
================================================
// @ts-check
/**
 * Based on the following format:
 * - https://github.com/changesets/changesets/blob/main/packages/changelog-github/src/index.ts
 * - https://github.com/stylelint/stylelint/blob/main/.changeset/changelog-stylelint.cjs
 */

const { getInfo, getInfoFromPullRequest } = require('@changesets/get-github-info');

/**
 * @type {import('@changesets/types').ChangelogFunctions}
 */
const changelogFunctions = {
  async getReleaseLine(changeset, _type, options) {
    if (!options || !options.repo) {
      throw new Error(
        'Please provide a repo to this changelog generator like this:\n"changelog": ["@changesets/changelog-github", { "repo": "org/repo" }]',
      );
    }

    /**
     * @type {number | undefined}
     */
    let prFromSummary;
    /**
     * @type {string | undefined}
     */
    let commitFromSummary;
    /**
     * @type {string[]}
     */
    let usersFromSummary = [];

    const replacedChangelog = changeset.summary
      .replace(/^\s*(?:pr|pull|pull\s+request):\s*#?(\d+)/im, (_, pr) => {
        let num = Number(pr);
        if (!isNaN(num)) {
          prFromSummary = num;
        }
        return '';
      })
      .replace(/^\s*commit:\s*([^\s]+)/im, (_, commit) => {
        commitFromSummary = commit;
        return '';
      })
      .replace(/^\s*(?:author|user):\s*@?([^\s]+)/gim, (_, user) => {
        usersFromSummary.push(user);
        return '';
      })
      .trim();

    const [firstLine, ...futureLines] = replacedChangelog
      .split('\n')
      .map((l) => l.trimRight());

    const links = await (async () => {
      if (prFromSummary !== undefined) {
        let { links } = await getInfoFromPullRequest({
          repo: options.repo,
          pull: prFromSummary,
        });
        if (commitFromSummary) {
          const shortCommitId = commitFromSummary.slice(0, 7);
          links = {
            ...links,
            commit: `[\`${shortCommitId}\`](https://github.com/${options.repo}/commit/${commitFromSummary})`,
          };
        }
        return links;
      }
      const commitToFetchFrom = commitFromSummary || changeset.commit;
      if (commitToFetchFrom) {
        let { links } = await getInfo({
          repo: options.repo,
          commit: commitToFetchFrom,
        });
        return links;
      }
      return {
        commit: null,
        pull: null,
        user: null,
      };
    })();

    const users = usersFromSummary.length
      ? usersFromSummary
        .map((userFromSummary) => `[@${userFromSummary}](https://github.com/${userFromSummary})`)
        .join(', ')
      : links.user;

    const pull = links.pull !== null ? links.pull : '';
    const commit = links.commit !== null ? links.commit : '';
    const prefix = pull || commit ? `${pull || commit}:` : '';
    const mention = users !== null ? `(${users})` : users;
    const fullFirstLine = `${prefix} ${firstLine} ${mention}`;
    const futureLinesText = futureLines.map((l) => `  ${l}`).join('\n');

    return `\n\n - ${fullFirstLine}\n${futureLinesText}`;
  },
  async getDependencyReleaseLine(changesets, deps, options) {
    if (!options.repo) {
      throw new Error(
        'Please provide a repo to this changelog generator like this:\n"changelog": ["@changesets/changelog-github", { "repo": "org/repo" }]',
      );
    }
    if (deps.length === 0) {
      return '';
    }

    const commits = await Promise.all(
      changesets.map(async (cs) => {
        if (cs.commit) {
          let { links } = await getInfo({
            repo: options.repo,
            commit: cs.commit,
          });
          return links.commit;
        }
      }),
    );

    const changesetLink = `- Updated dependencies [${commits.join(', ')}]:`;
    const updatedDeps = deps.map((dep) => `  - ${dep.name}@${dep.newVersion}`);

    return [changesetLink, ...updatedDeps].join('\n');
  },
};

module.exports = changelogFunctions;


================================================
File: .changeset/config.json
================================================
{
  "$schema": "https://unpkg.com/@changesets/config@3.0.0/schema.json",
  "changelog": ["./changelog-format.cjs", { "repo": "ckb-cell/rgbpp-sdk" }],
  "commit": false,
  "fixed": [["@rgbpp-sdk/*", "rgbpp"]],
  "linked": [],
  "access": "public",
  "baseBranch": "origin/main",
  "updateInternalDependencies": "patch",
  "ignore": []
}


================================================
File: .github/workflows/docker.yml
================================================
name: Docker Publish

on:
  workflow_dispatch:
  push:
    branches:
      - main
      - develop
    tags:
      - v*.*.*

jobs:
  docker-build-push:
    runs-on: ubuntu-22.04
    permissions:
      packages: write
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          context: git
          images: ghcr.io/${{ github.repository }}-service
          flavor: |
            latest=auto
          tags: |
            type=ref,event=tag
            type=semver,pattern={{version}}
            type=ref,event=branch
            type=ref,event=branch,suffix=-{{date 'YYYYMMDDHHmm'}}
            type=sha,enable=true,prefix=sha-,format=short
        env:
          DOCKER_METADATA_ANNOTATIONS_LEVELS: manifest,index

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          target: service
          push: true
          provenance: false
          platforms: linux/amd64, linux/arm64
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          annotations: ${{ steps.meta.outputs.annotations }}


================================================
File: .github/workflows/integration-test.yaml
================================================
# Test the entire process of RGBPP to ensure the proper functioning of the rgbpp-sdk package.

name: Integration Tests

on:
  workflow_dispatch:
  pull_request:
  # Run integration-tests every day
  schedule:
    - cron: '59 0 * * *'

# https://docs.github.com/en/actions/using-jobs/using-concurrency
concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: false

jobs:
  test:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        env_set: [ xudt, spore, compatible-xudt ]

    steps:
      - name: Checkout rgbpp-sdk
        uses: actions/checkout@v4

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 21

      - uses: pnpm/action-setup@v3
        name: Install -g pnpm
        with:
          version: 9
          run_install: false

      - name: Install dependencies
        run: pnpm i

      - name: Build packages
        run: pnpm run build:packages


      - name: Run integration:xudt script
        working-directory: ./tests/rgbpp
        if: ${{ matrix.env_set == 'xudt' }}
        run: pnpm run integration:xudt
        env:
          VITE_SERVICE_URL: https://btc-assets-api.testnet.mibao.pro
          VITE_SERVICE_TOKEN: ${{ secrets.TESTNET_SERVICE_TOKEN }}
          VITE_SERVICE_ORIGIN: https://btc-assets-api.testnet.mibao.pro
          INTEGRATION_CKB_PRIVATE_KEY: ${{ secrets.INTEGRATION_CKB_PRIVATE_KEY }}
          INTEGRATION_BTC_PRIVATE_KEY: ${{ secrets.INTEGRATION_BTC_PRIVATE_KEY }}

      - name: Run integration:spore script
        working-directory: ./tests/rgbpp
        if: ${{ matrix.env_set == 'spore' }}
        run: pnpm run integration:spore
        env:
          VITE_SERVICE_URL: https://btc-assets-api.testnet.mibao.pro
          VITE_SERVICE_TOKEN: ${{ secrets.TESTNET_SERVICE_TOKEN }}
          VITE_SERVICE_ORIGIN: https://btc-assets-api.testnet.mibao.pro
          INTEGRATION_CKB_PRIVATE_KEY: ${{ secrets.INTEGRATION_CKB_SPORE_PRIVATE_KEY }}
          INTEGRATION_BTC_PRIVATE_KEY: ${{ secrets.INTEGRATION_BTC_SPORE_PRIVATE_KEY }}

      - name: Run integration:compatible-xudt script
        working-directory: ./tests/rgbpp
        if: ${{ matrix.env_set == 'compatible-xudt' }}
        run: pnpm run integration:compatible-xudt
        env:
          VITE_SERVICE_URL: https://btc-assets-api.testnet.mibao.pro
          VITE_SERVICE_TOKEN: ${{ secrets.TESTNET_SERVICE_TOKEN }}
          VITE_SERVICE_ORIGIN: https://btc-assets-api.testnet.mibao.pro
          INTEGRATION_CKB_PRIVATE_KEY: ${{ secrets.INTEGRATION_CKB_compatible_xudt_PRIVATE_KEY }}
          INTEGRATION_BTC_PRIVATE_KEY: ${{ secrets.INTEGRATION_BTC_compatible_xudt_PRIVATE_KEY }}


================================================
File: .github/workflows/release.yml
================================================
# Release packages to NPM and GitHub.

name: Release

on:
  workflow_dispatch:
  push:
    branches:
      - main

concurrency: ${{ github.workflow }}-${{ github.ref }}

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 21

      - uses: pnpm/action-setup@v3
        name: Install pnpm
        with:
          version: 9
          run_install: false

      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - uses: actions/cache@v4
        name: Setup pnpm cache
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        run: pnpm i

      - name: Create bump PR or release version
        uses: changesets/action@v1
        id: changesets
        with:
          publish: pnpm run release:packages
          title: "bump: assumable rgbpp-sdk version"
          commit: "bump: assumable rgbpp-sdk version"
        env:
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create comment on commit
        uses: actions/github-script@v7
        if: steps.changesets.outputs.published
        env:
          PACKAGES: ${{ steps.changesets.outputs.publishedPackages }}
        with:
          script: |
            const packages = JSON.parse(process.env.PACKAGES)
            const packagesTable = packages.map((p) => `| ${p.name} | \`${p.version}\` |`).join('\n')
            const body = ['New official version of the rgbpp-sdk packages have been released:', '| Name | Version |', '| --- | --- |', packagesTable].join('\n')
            github.rest.repos.createCommitComment({
              commit_sha: context.sha,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body,
            });


================================================
File: .github/workflows/snapshot.yml
================================================
# Release snapshot packages to NPM.

name: Release Snapshots

on:
  workflow_dispatch:
  push:
    branches:
      - develop

concurrency: ${{ github.workflow }}-${{ github.ref }}

jobs:
  release-snapshots:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 21

      - uses: pnpm/action-setup@v3
        name: Install pnpm
        with:
          version: 9
          run_install: false

      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - uses: actions/cache@v4
        name: Setup pnpm cache
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        run: pnpm i

      - name: Build packages
        run: pnpm run build:packages

      - name: Add snapshot changeset (ensure at least has a changeset)
        run: |
          cat << EOF > ".changeset/snap-release-changeset.md"
            ---
            "@rgbpp-sdk/btc": patch
            ---
            Add temp changeset for snapshot releases
          EOF

      - name: Version packages to "0.0.0-snap-{timestamp}"
        run: npx changeset version --snapshot snap
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Publish snapshot versions to npm
        uses: changesets/action@v1
        id: changesets
        with:
          publish: npx changeset publish --snapshot --tag snap
          createGithubReleases: false
        env:
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create comment on commit
        uses: actions/github-script@v7
        if: steps.changesets.outputs.published
        env:
          PACKAGES: ${{ steps.changesets.outputs.publishedPackages }}
        with:
          script: |
            const packages = JSON.parse(process.env.PACKAGES)
            const packagesTable = packages.map((p) => `| ${p.name} | \`${p.version}\` |`).join('\n')
            const body = ['New snapshot version of the rgbpp-sdk packages have been released:', '| Name | Version |', '| --- | --- |', packagesTable].join('\n')
            github.rest.repos.createCommitComment({
              commit_sha: context.sha,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body,
            });


================================================
File: .github/workflows/test.yaml
================================================
# Test the functionality of the rgbpp-sdk packages.

name: Unit Tests

on:
  workflow_dispatch:
  pull_request:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout rgbpp-sdk
        uses: actions/checkout@v4

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 21

      - uses: pnpm/action-setup@v3
        name: Install -g pnpm
        with:
          version: 9
          run_install: false

      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - uses: actions/cache@v4
        name: Setup pnpm cache
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        run: pnpm i

      - name: Build packages
        run: pnpm run build:packages

      - name: Lint packages
        run: pnpm run lint
        
      - name: Run unit tests for the packages
        run: pnpm run test:packages
        env:
          VITE_CKB_NODE_URL: https://testnet.ckb.dev/rpc
          VITE_CKB_INDEXER_URL: https://testnet.ckb.dev/indexer
          VITE_BTC_SERVICE_URL: https://btc-assets-api.testnet.mibao.pro
          VITE_BTC_SERVICE_TOKEN: ${{ secrets.TESTNET_SERVICE_TOKEN }}
          VITE_BTC_SERVICE_ORIGIN: https://btc-assets-api.testnet.mibao.pro

      - name: Run unit tests for the rgbpp-sdk-service
        run: pnpm run test:service


================================================
File: .husky/pre-commit
================================================
pnpm exec lint-staged


