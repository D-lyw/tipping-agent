Directory structure:
â””â”€â”€ sporeprotocol-spore-sdk/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ LICENSE
    â”œâ”€â”€ package.json
    â”œâ”€â”€ pnpm-lock.yaml
    â”œâ”€â”€ pnpm-workspace.yaml
    â”œâ”€â”€ tsconfig.json
    â”œâ”€â”€ turbo.json
    â”œâ”€â”€ .npmrc
    â”œâ”€â”€ .prettierignore
    â”œâ”€â”€ .prettierrc
    â”œâ”€â”€ docs/
    â”‚   â”œâ”€â”€ assets/
    â”‚   â”‚   â””â”€â”€ readme-banner.webp
    â”‚   â”œâ”€â”€ core/
    â”‚   â”‚   â”œâ”€â”€ composed-apis.md
    â”‚   â”‚   â”œâ”€â”€ joint-apis.md
    â”‚   â”‚   â”œâ”€â”€ setup.md
    â”‚   â”‚   â””â”€â”€ utilities.md
    â”‚   â”œâ”€â”€ recipes/
    â”‚   â”‚   â”œâ”€â”€ capacity-margin.md
    â”‚   â”‚   â”œâ”€â”€ configure-spore-config.md
    â”‚   â”‚   â”œâ”€â”€ construct-transaction.md
    â”‚   â”‚   â”œâ”€â”€ create-immortal-spore.md
    â”‚   â”‚   â””â”€â”€ handle-cell-data.md
    â”‚   â””â”€â”€ resources/
    â”‚       â”œâ”€â”€ demos.md
    â”‚       â””â”€â”€ examples.md
    â”œâ”€â”€ examples/
    â”‚   â”œâ”€â”€ acp/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ package.json
    â”‚   â”‚   â”œâ”€â”€ tsconfig.json
    â”‚   â”‚   â”œâ”€â”€ apis/
    â”‚   â”‚   â”‚   â”œâ”€â”€ createAcpCluster.ts
    â”‚   â”‚   â”‚   â””â”€â”€ createSporeWithAcpCluster.ts
    â”‚   â”‚   â””â”€â”€ utils/
    â”‚   â”‚       â”œâ”€â”€ config.ts
    â”‚   â”‚       â””â”€â”€ wallet.ts
    â”‚   â”œâ”€â”€ omnilock/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ package.json
    â”‚   â”‚   â”œâ”€â”€ tsconfig.json
    â”‚   â”‚   â”œâ”€â”€ acp/
    â”‚   â”‚   â”‚   â”œâ”€â”€ createAcpCluster.ts
    â”‚   â”‚   â”‚   â””â”€â”€ createSporeWithAcpCluster.ts
    â”‚   â”‚   â””â”€â”€ utils/
    â”‚   â”‚       â”œâ”€â”€ config.ts
    â”‚   â”‚       â””â”€â”€ wallet.ts
    â”‚   â”œâ”€â”€ secp256k1/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ package.json
    â”‚   â”‚   â”œâ”€â”€ tsconfig.json
    â”‚   â”‚   â”œâ”€â”€ apis/
    â”‚   â”‚   â”‚   â”œâ”€â”€ createCluster.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ createClusterAgent.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ createClusterProxy.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ createSpore.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ createSporeWithCluster.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ createSporeWithClusterAgent.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ meltClusterAgent.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ meltClusterProxy.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ meltSpore.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ transferCluster.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ transferClusterAgent.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ transferClusterProxy.ts
    â”‚   â”‚   â”‚   â””â”€â”€ transferSpore.ts
    â”‚   â”‚   â””â”€â”€ utils/
    â”‚   â”‚       â”œâ”€â”€ config.ts
    â”‚   â”‚       â””â”€â”€ wallet.ts
    â”‚   â””â”€â”€ shared/
    â”‚       â”œâ”€â”€ README.md
    â”‚       â”œâ”€â”€ index.ts
    â”‚       â”œâ”€â”€ package.json
    â”‚       â””â”€â”€ tsconfig.json
    â”œâ”€â”€ packages/
    â”‚   â””â”€â”€ core/
    â”‚       â”œâ”€â”€ README.md
    â”‚       â”œâ”€â”€ CHANGELOG.md
    â”‚       â”œâ”€â”€ package.json
    â”‚       â”œâ”€â”€ tsconfig.build.json
    â”‚       â”œâ”€â”€ tsconfig.json
    â”‚       â”œâ”€â”€ vitest.config.mts
    â”‚       â””â”€â”€ src/
    â”‚           â”œâ”€â”€ env.d.ts
    â”‚           â”œâ”€â”€ index.ts
    â”‚           â”œâ”€â”€ __tests__/
    â”‚           â”‚   â”œâ”€â”€ Buffer.test.ts
    â”‚           â”‚   â”œâ”€â”€ Capacity.test.ts
    â”‚           â”‚   â”œâ”€â”€ Cluster.test.ts
    â”‚           â”‚   â”œâ”€â”€ ClusterProxyAgent.test.ts
    â”‚           â”‚   â”œâ”€â”€ Codec.test.ts
    â”‚           â”‚   â”œâ”€â”€ ContentType.test.ts
    â”‚           â”‚   â”œâ”€â”€ MimeType.test.ts
    â”‚           â”‚   â”œâ”€â”€ MultipartContent.test.ts
    â”‚           â”‚   â”œâ”€â”€ Multiple.test.ts
    â”‚           â”‚   â”œâ”€â”€ Mutant.test.ts
    â”‚           â”‚   â”œâ”€â”€ RetryWork.test.ts
    â”‚           â”‚   â”œâ”€â”€ Spore.test.ts
    â”‚           â”‚   â”œâ”€â”€ SporeConfig.test.ts
    â”‚           â”‚   â”œâ”€â”€ Vitest.test.ts
    â”‚           â”‚   â”œâ”€â”€ helpers/
    â”‚           â”‚   â”‚   â”œâ”€â”€ account.ts
    â”‚           â”‚   â”‚   â”œâ”€â”€ check.ts
    â”‚           â”‚   â”‚   â”œâ”€â”€ combine.ts
    â”‚           â”‚   â”‚   â”œâ”€â”€ config.ts
    â”‚           â”‚   â”‚   â”œâ”€â”€ file.ts
    â”‚           â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚           â”‚   â”‚   â”œâ”€â”€ record.ts
    â”‚           â”‚   â”‚   â”œâ”€â”€ retry.ts
    â”‚           â”‚   â”‚   â””â”€â”€ wallet.ts
    â”‚           â”‚   â”œâ”€â”€ resources/
    â”‚           â”‚   â”‚   â”œâ”€â”€ firstOutputMutant.lua
    â”‚           â”‚   â”‚   â”œâ”€â”€ immortalMutant.lua
    â”‚           â”‚   â”‚   â”œâ”€â”€ mustTransferMutant.lua
    â”‚           â”‚   â”‚   â””â”€â”€ noTransferMutant.lua
    â”‚           â”‚   â””â”€â”€ shared/
    â”‚           â”‚       â”œâ”€â”€ env.ts
    â”‚           â”‚       â”œâ”€â”€ index.ts
    â”‚           â”‚       â””â”€â”€ record.ts
    â”‚           â”œâ”€â”€ api/
    â”‚           â”‚   â”œâ”€â”€ index.ts
    â”‚           â”‚   â”œâ”€â”€ composed/
    â”‚           â”‚   â”‚   â”œâ”€â”€ cluster/
    â”‚           â”‚   â”‚   â”‚   â”œâ”€â”€ createCluster.ts
    â”‚           â”‚   â”‚   â”‚   â””â”€â”€ transferCluster.ts
    â”‚           â”‚   â”‚   â”œâ”€â”€ clusterAgent/
    â”‚           â”‚   â”‚   â”‚   â”œâ”€â”€ createClusterAgent.ts
    â”‚           â”‚   â”‚   â”‚   â”œâ”€â”€ meltClusterAgent.ts
    â”‚           â”‚   â”‚   â”‚   â””â”€â”€ transferClusterAgent.ts
    â”‚           â”‚   â”‚   â”œâ”€â”€ clusterProxy/
    â”‚           â”‚   â”‚   â”‚   â”œâ”€â”€ createClusterProxy.ts
    â”‚           â”‚   â”‚   â”‚   â”œâ”€â”€ meltClusterProxy.ts
    â”‚           â”‚   â”‚   â”‚   â””â”€â”€ transferClusterProxy.ts
    â”‚           â”‚   â”‚   â”œâ”€â”€ mutant/
    â”‚           â”‚   â”‚   â”‚   â”œâ”€â”€ createMutant.ts
    â”‚           â”‚   â”‚   â”‚   â””â”€â”€ transferMutant.ts
    â”‚           â”‚   â”‚   â””â”€â”€ spore/
    â”‚           â”‚   â”‚       â”œâ”€â”€ createSpore.ts
    â”‚           â”‚   â”‚       â”œâ”€â”€ meltSpore.ts
    â”‚           â”‚   â”‚       â”œâ”€â”€ meltThenCreateSpore.ts
    â”‚           â”‚   â”‚       â””â”€â”€ transferSpore.ts
    â”‚           â”‚   â””â”€â”€ joints/
    â”‚           â”‚       â”œâ”€â”€ cluster/
    â”‚           â”‚       â”‚   â”œâ”€â”€ getCluster.ts
    â”‚           â”‚       â”‚   â”œâ”€â”€ injectLiveClusterCell.ts
    â”‚           â”‚       â”‚   â”œâ”€â”€ injectLiveClusterReference.ts
    â”‚           â”‚       â”‚   â”œâ”€â”€ injectNewClusterIds.ts
    â”‚           â”‚       â”‚   â””â”€â”€ injectNewClusterOutput.ts
    â”‚           â”‚       â”œâ”€â”€ clusterAgent/
    â”‚           â”‚       â”‚   â”œâ”€â”€ getClusterAgent.ts
    â”‚           â”‚       â”‚   â”œâ”€â”€ injectLiveClusterAgentCell.ts
    â”‚           â”‚       â”‚   â”œâ”€â”€ injectLiveClusterAgentReference.ts
    â”‚           â”‚       â”‚   â””â”€â”€ injectNewClusterAgentOutput.ts
    â”‚           â”‚       â”œâ”€â”€ clusterProxy/
    â”‚           â”‚       â”‚   â”œâ”€â”€ getClusterProxy.ts
    â”‚           â”‚       â”‚   â”œâ”€â”€ injectLiveClusterProxyCell.ts
    â”‚           â”‚       â”‚   â”œâ”€â”€ injectLiveClusterProxyReference.ts
    â”‚           â”‚       â”‚   â”œâ”€â”€ injectNewClusterProxyIds.ts
    â”‚           â”‚       â”‚   â””â”€â”€ injectNewClusterProxyOutput.ts
    â”‚           â”‚       â”œâ”€â”€ mutant/
    â”‚           â”‚       â”‚   â”œâ”€â”€ getMutant.ts
    â”‚           â”‚       â”‚   â”œâ”€â”€ injectLiveMutantCell.ts
    â”‚           â”‚       â”‚   â”œâ”€â”€ injectLiveMutantReferences.ts
    â”‚           â”‚       â”‚   â”œâ”€â”€ injectNewMutantIds.ts
    â”‚           â”‚       â”‚   â””â”€â”€ injectNewMutantOutput.ts
    â”‚           â”‚       â””â”€â”€ spore/
    â”‚           â”‚           â”œâ”€â”€ getSpore.ts
    â”‚           â”‚           â”œâ”€â”€ injectLiveSporeCell.ts
    â”‚           â”‚           â”œâ”€â”€ injectNewSporeIds.ts
    â”‚           â”‚           â””â”€â”€ injectNewSporeOutput.ts
    â”‚           â”œâ”€â”€ cobuild/
    â”‚           â”‚   â”œâ”€â”€ index.ts
    â”‚           â”‚   â”œâ”€â”€ action/
    â”‚           â”‚   â”‚   â”œâ”€â”€ cluster/
    â”‚           â”‚   â”‚   â”‚   â”œâ”€â”€ createCluster.ts
    â”‚           â”‚   â”‚   â”‚   â”œâ”€â”€ referenceCluster.ts
    â”‚           â”‚   â”‚   â”‚   â””â”€â”€ transferCluster.ts
    â”‚           â”‚   â”‚   â”œâ”€â”€ clusterAgent/
    â”‚           â”‚   â”‚   â”‚   â”œâ”€â”€ createClusterAgent.ts
    â”‚           â”‚   â”‚   â”‚   â”œâ”€â”€ meltClusterAgent.ts
    â”‚           â”‚   â”‚   â”‚   â”œâ”€â”€ referenceClusterAgent.ts
    â”‚           â”‚   â”‚   â”‚   â””â”€â”€ transferClusterAgent.ts
    â”‚           â”‚   â”‚   â”œâ”€â”€ clusterProxy/
    â”‚           â”‚   â”‚   â”‚   â”œâ”€â”€ createClusterProxy.ts
    â”‚           â”‚   â”‚   â”‚   â”œâ”€â”€ meltClusterProxy.ts
    â”‚           â”‚   â”‚   â”‚   â”œâ”€â”€ referenceClusterProxy.ts
    â”‚           â”‚   â”‚   â”‚   â””â”€â”€ transferClusterProxy.ts
    â”‚           â”‚   â”‚   â””â”€â”€ spore/
    â”‚           â”‚   â”‚       â”œâ”€â”€ createSpore.ts
    â”‚           â”‚   â”‚       â”œâ”€â”€ meltSpore.ts
    â”‚           â”‚   â”‚       â””â”€â”€ transferSpore.ts
    â”‚           â”‚   â”œâ”€â”€ base/
    â”‚           â”‚   â”‚   â”œâ”€â”€ buildingPacket.ts
    â”‚           â”‚   â”‚   â”œâ”€â”€ resolvedInputs.ts
    â”‚           â”‚   â”‚   â”œâ”€â”€ sporeScriptInfo.ts
    â”‚           â”‚   â”‚   â””â”€â”€ witnessLayout.ts
    â”‚           â”‚   â””â”€â”€ codec/
    â”‚           â”‚       â”œâ”€â”€ buildingPacket.ts
    â”‚           â”‚       â”œâ”€â”€ sporeAction.ts
    â”‚           â”‚       â””â”€â”€ witnessLayout.ts
    â”‚           â”œâ”€â”€ codec/
    â”‚           â”‚   â”œâ”€â”€ cluster.ts
    â”‚           â”‚   â”œâ”€â”€ clusterAgent.ts
    â”‚           â”‚   â”œâ”€â”€ clusterProxy.ts
    â”‚           â”‚   â”œâ”€â”€ index.ts
    â”‚           â”‚   â”œâ”€â”€ mutant.ts
    â”‚           â”‚   â”œâ”€â”€ spore.ts
    â”‚           â”‚   â””â”€â”€ utils.ts
    â”‚           â”œâ”€â”€ config/
    â”‚           â”‚   â”œâ”€â”€ cache.ts
    â”‚           â”‚   â”œâ”€â”€ config.ts
    â”‚           â”‚   â”œâ”€â”€ hash.ts
    â”‚           â”‚   â”œâ”€â”€ index.ts
    â”‚           â”‚   â”œâ”€â”€ predefined.ts
    â”‚           â”‚   â”œâ”€â”€ script.ts
    â”‚           â”‚   â””â”€â”€ types.ts
    â”‚           â”œâ”€â”€ helpers/
    â”‚           â”‚   â”œâ”€â”€ address.ts
    â”‚           â”‚   â”œâ”€â”€ buffer.ts
    â”‚           â”‚   â”œâ”€â”€ capacity.ts
    â”‚           â”‚   â”œâ”€â”€ cell.ts
    â”‚           â”‚   â”œâ”€â”€ cellDep.ts
    â”‚           â”‚   â”œâ”€â”€ contentType.ts
    â”‚           â”‚   â”œâ”€â”€ fee.ts
    â”‚           â”‚   â”œâ”€â”€ index.ts
    â”‚           â”‚   â”œâ”€â”€ lockProxy.ts
    â”‚           â”‚   â”œâ”€â”€ mimeType.ts
    â”‚           â”‚   â”œâ”€â”€ multipartContent.ts
    â”‚           â”‚   â”œâ”€â”€ retryWork.ts
    â”‚           â”‚   â”œâ”€â”€ script.ts
    â”‚           â”‚   â”œâ”€â”€ transaction.ts
    â”‚           â”‚   â”œâ”€â”€ typeId.ts
    â”‚           â”‚   â””â”€â”€ witness.ts
    â”‚           â””â”€â”€ types/
    â”‚               â”œâ”€â”€ async.ts
    â”‚               â”œâ”€â”€ blockchain.ts
    â”‚               â””â”€â”€ index.ts
    â”œâ”€â”€ .changeset/
    â”‚   â”œâ”€â”€ README.md
    â”‚   â”œâ”€â”€ beige-penguins-melt.md
    â”‚   â”œâ”€â”€ brown-carpets-learn.md
    â”‚   â”œâ”€â”€ config.json
    â”‚   â”œâ”€â”€ early-snakes-tan.md
    â”‚   â”œâ”€â”€ eleven-dots-own.md
    â”‚   â”œâ”€â”€ grumpy-schools-learn.md
    â”‚   â”œâ”€â”€ heavy-falcons-wink.md
    â”‚   â”œâ”€â”€ honest-rice-vanish.md
    â”‚   â”œâ”€â”€ itchy-goats-beam.md
    â”‚   â”œâ”€â”€ itchy-plants-kick.md
    â”‚   â”œâ”€â”€ khaki-elephants-behave.md
    â”‚   â”œâ”€â”€ kind-donkeys-lick.md
    â”‚   â”œâ”€â”€ long-lobsters-walk.md
    â”‚   â”œâ”€â”€ nine-bottles-report.md
    â”‚   â”œâ”€â”€ old-oranges-invite.md
    â”‚   â”œâ”€â”€ polite-donuts-begin.md
    â”‚   â”œâ”€â”€ poor-pumpkins-learn.md
    â”‚   â”œâ”€â”€ pre.json
    â”‚   â”œâ”€â”€ pretty-lobsters-count.md
    â”‚   â”œâ”€â”€ proud-phones-camp.md
    â”‚   â”œâ”€â”€ rare-coins-notice.md
    â”‚   â”œâ”€â”€ shaggy-snakes-collect.md
    â”‚   â”œâ”€â”€ slimy-peas-share.md
    â”‚   â”œâ”€â”€ slow-tools-flow.md
    â”‚   â”œâ”€â”€ small-lobsters-jam.md
    â”‚   â”œâ”€â”€ spotty-islands-sort.md
    â”‚   â”œâ”€â”€ stale-ghosts-lie.md
    â”‚   â”œâ”€â”€ strange-forks-brake.md
    â”‚   â”œâ”€â”€ ten-knives-join.md
    â”‚   â”œâ”€â”€ thirty-bugs-applaud.md
    â”‚   â”œâ”€â”€ three-cows-unite.md
    â”‚   â””â”€â”€ twenty-planets-rest.md
    â”œâ”€â”€ .github/
    â”‚   â””â”€â”€ workflows/
    â”‚       â”œâ”€â”€ release.yml
    â”‚       â””â”€â”€ test.yaml
    â””â”€â”€ .husky/
        â””â”€â”€ pre-commit

================================================
File: README.md
================================================
<br/>

<p align="center">
  <img src="./docs/assets/readme-banner.webp" alt="Spore SDK">
</p>

<h1 align="center">
  Spore SDK
</h1>

<p align="center">
  <b>
    ã€ŒThe Ultimate TypeScript SDK for Spore Protocolã€
  </b>
</p>

<p align="center">
  <a href="https://www.npmjs.com/package/@spore-sdk/core">
    <picture>
      <source media="(prefers-color-scheme: dark)" srcset="https://img.shields.io/npm/v/@spore-sdk/core?colorA=21262d&colorB=21262d&style=flat">
      <img src="https://img.shields.io/npm/v/@spore-sdk/core?colorA=f6f8fa&colorB=f6f8fa&style=flat" alt="Version">
    </picture>
  </a>
  <a href="https://github.com/sporeprotocol/spore-sdk/blob/main/LICENSE">
    <picture>
      <source media="(prefers-color-scheme: dark)" srcset="https://img.shields.io/npm/l/@spore-sdk/core?colorA=21262d&colorB=21262d&style=flat">
      <img src="https://img.shields.io/npm/l/@spore-sdk/core?colorA=f6f8fa&colorB=f6f8fa&style=flat" alt="MIT License">
    </picture>
  </a>
  <a href="https://www.npmjs.com/package/@spore-sdk/core">
    <picture>
      <source media="(prefers-color-scheme: dark)" srcset="https://img.shields.io/npm/dm/@spore-sdk/core?colorA=21262d&colorB=21262d&style=flat">
      <img src="https://img.shields.io/npm/dm/@spore-sdk/core?colorA=f6f8fa&colorB=f6f8fa&style=flat" alt="Downloads per month">
    </picture>
  </a>
</p>

<p align="center">
  Spore SDK is a comprehensive web development kit specifically designed for seamless integration with <a href="https://github.com/sporeprotocol/spore-contract">Spore</a>, an on-chain asset protocol to power digital asset ownership, distribution, and value capture, built on top of <a href="https://github.com/nervosnetwork/ckb">CKB</a>.
</p>

<p align="center">
  With Spore SDK, developers gain access to powerful tools and resources that enable them to effortlessly create spore-related dapps, fully leveraging the immense potential of Spore Protocol.
</p>

## Features

- âš¡ Composed APIs for efficient spores/clusters interactions with minimal time overhead
- ğŸ§© Joint APIs for building advanced transactions as a fun block-building process
- ğŸ› ï¸ Utilities for encoding/decoding data of spores/clusters
- ğŸ¹ Fully written in TypeScript


## Documentation

Full documentation and instructions, visit: [Spore Docs](https://docs.spore.pro).


## Getting started

### Installation

Go through the recipe [Start using Spore SDK](./docs/core/setup.md) for installation.

### Running in Node.js

- Follow the tutorial to learn about spore creation: [Create your first Spore](https://docs.spore.pro/tutorials/create-first-spore)
- Refer to specific code snippets: [Spore Examples](./docs/resources/examples.md)

### Running in browsers

- Follow the tutorial to build a dapp from scratch: [Create simple on-chain blog](https://docs.spore.pro/tutorials/create-on-chain-blog)
- Explore all featured dapp demos: [Spore Demos](./docs/resources/demos.md)


## Development

### Toolchain & utilities

- [@spore-sdk/core](./packages/core) - Provides essential tools for constructing basic and advanced transactions on spores and clusters. Additionally, it offers convenient utilities for handling [serialization](https://github.com/nervosnetwork/molecule) of spores/clusters

### Reference

- [Examples](./docs/resources/examples.md) - Code block examples for implementing basic and specific features

- [Demos](./docs/resources/demos.md) - Demo applications with full functionality, including seamless integration with wallets


### API

- [Composed APIs](./docs/core/composed-apis.md) - Efficient APIs to build Spore transactions with minimal time overhead
  
- [Utilities](./docs/core/utilities.md) - Handy helper functions to save developers' time and effort 
 
 
## Community

Chat everything about Spore here:

- Join our discord channel: [HaCKBee](https://discord.gg/9eufnpZZ8P)
- Contact via email: [contact@spore.pro](mailto:contact@spore.pro)

## Contributing

To submit pull requests, make sure:

- Please submit pull requests based on the `beta` branch
- Please ensure your commit styling won't conflict with the [existing commits](https://github.com/sporeprotocol/spore-sdk/commits)
- Please provide a clear and descriptive title and description for your pull requests

## License

[MIT](./LICENSE) License


================================================
File: LICENSE
================================================
MIT License
-----------

Copyright (c) 2023 sporeprotocol
Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.


================================================
File: package.json
================================================
{
  "name": "spore-sdk",
  "private": true,
  "license": "MIT",
  "workspaces": [
    "packages/*"
  ],
  "scripts": {
    "prepare": "husky install",
    "test": "turbo run test",
    "test:packages": "turbo run test --filter=./packages/*",
    "build": "turbo run build",
    "build:packages": "turbo run build --filter=./packages/*",
    "lint:fix": "turbo run lint:fix",
    "lint:fix-all": "prettier --write '{packages,apps}/**/*.{js,jsx,ts,tsx,md,json}'",
    "clean": "turbo run clean",
    "clean:packages": "turbo run clean --filter=./packags/*",
    "clean:examples": "turbo run clean --filter=./examples/*",
    "clean:dependencies": "pnpm clean:sub-dependencies && rimraf node_modules",
    "clean:sub-dependencies": "rimraf packages/**/node_modules examples/**/node_modules",
    "release:packages": "pnpm run clean:packages && pnpm run build:packages && changeset publish"
  },
  "dependencies": {
    "rimraf": "^5.0.0"
  },
  "devDependencies": {
    "@changesets/cli": "^2.26.1",
    "husky": "^8.0.0",
    "lint-staged": "^15.1.0",
    "prettier": "^3.1.0",
    "ts-node": "^10.9.0",
    "turbo": "^1.10.16",
    "type-fest": "^3.8.0",
    "typescript": "^5.3.2"
  },
  "lint-staged": {
    "{packages,apps}/**/*.{js,jsx,ts,tsx,md,json}": "prettier --ignore-unknown --write"
  },
  "packageManager": "pnpm@8.0.0",
  "engines": {
    "node": ">=18.0.0"
  }
}


================================================
File: pnpm-lock.yaml
================================================
lockfileVersion: '6.0'

settings:
  autoInstallPeers: true
  excludeLinksFromLockfile: false

importers:

  .:
    dependencies:
      rimraf:
        specifier: ^5.0.0
        version: 5.0.0
    devDependencies:
      '@changesets/cli':
        specifier: ^2.26.1
        version: 2.26.1
      husky:
        specifier: ^8.0.0
        version: 8.0.0
      lint-staged:
        specifier: ^15.1.0
        version: 15.1.0
      prettier:
        specifier: ^3.1.0
        version: 3.1.0
      ts-node:
        specifier: ^10.9.0
        version: 10.9.0(@types/node@20.4.1)(typescript@5.3.2)
      turbo:
        specifier: ^1.10.16
        version: 1.10.16
      type-fest:
        specifier: ^3.8.0
        version: 3.8.0
      typescript:
        specifier: ^5.3.2
        version: 5.3.2

  examples/acp:
    dependencies:
      '@ckb-lumos/lumos':
        specifier: 0.24.0-next.1
        version: 0.24.0-next.1
      '@spore-examples/shared':
        specifier: workspace:^
        version: link:../shared
      '@spore-sdk/core':
        specifier: workspace:^
        version: link:../../packages/core
      ts-node:
        specifier: ^10.9.1
        version: 10.9.1(@types/node@20.4.1)(typescript@5.3.2)

  examples/omnilock:
    dependencies:
      '@ckb-lumos/lumos':
        specifier: examples/acp/package.json
        version: link:examples/acp/package.json
      '@spore-examples/shared':
        specifier: workspace:^
        version: link:../shared
      '@spore-sdk/core':
        specifier: workspace:^
        version: link:../../packages/core
      lodash:
        specifier: ^4.17.21
        version: 4.17.21
      ts-node:
        specifier: ^10.9.1
        version: 10.9.1(@types/node@20.4.1)(typescript@5.3.2)

  examples/secp256k1:
    dependencies:
      '@ckb-lumos/lumos':
        specifier: 0.24.0-next.1
        version: 0.24.0-next.1
      '@spore-examples/shared':
        specifier: workspace:^
        version: link:../shared
      '@spore-sdk/core':
        specifier: workspace:^
        version: link:../../packages/core
      ts-node:
        specifier: ^10.9.1
        version: 10.9.1(@types/node@20.4.1)(typescript@5.3.2)

  examples/shared:
    dependencies:
      '@ckb-lumos/lumos':
        specifier: 0.24.0-next.1
        version: 0.24.0-next.1

  packages/core:
    dependencies:
      '@ckb-lumos/lumos':
        specifier: 0.24.0-next.1
        version: 0.24.0-next.1
      lodash:
        specifier: ^4.17.21
        version: 4.17.21
    devDependencies:
      '@exact-realty/multipart-parser':
        specifier: ^1.0.13
        version: 1.0.13
      vitest:
        specifier: ^1.4.0
        version: 1.4.0(@types/node@20.4.1)

packages:

  /@babel/code-frame@7.22.5:
    resolution: {integrity: sha512-Xmwn266vad+6DAqEB2A6V/CcZVp62BbwVmcOJc2RPuwih1kw02TjQvWVWlcKGbBPd+8/0V5DEkOcizRGYsspYQ==}
    engines: {node: '>=6.9.0'}
    dependencies:
      '@babel/highlight': 7.22.5
    dev: true

  /@babel/helper-validator-identifier@7.22.5:
    resolution: {integrity: sha512-aJXu+6lErq8ltp+JhkJUfk1MTGyuA4v7f3pA+BJ5HLfNC6nAQ0Cpi9uOquUj8Hehg0aUiHzWQbOVJGao6ztBAQ==}
    engines: {node: '>=6.9.0'}
    dev: true

  /@babel/highlight@7.22.5:
    resolution: {integrity: sha512-BSKlD1hgnedS5XRnGOljZawtag7H1yPfQp0tdNJCHoH6AZ+Pcm9VvkrK59/Yy593Ypg0zMxH2BxD1VPYUQ7UIw==}
    engines: {node: '>=6.9.0'}
    dependencies:
      '@babel/helper-validator-identifier': 7.22.5
      chalk: 2.4.2
      js-tokens: 4.0.0
    dev: true

  /@babel/runtime@7.22.6:
    resolution: {integrity: sha512-wDb5pWm4WDdF6LFUde3Jl8WzPA+3ZbxYqkC6xAXuD3irdEHN1k0NfTRrJD8ZD378SJ61miMLCqIOXYhd8x+AJQ==}
    engines: {node: '>=6.9.0'}
    dependencies:
      regenerator-runtime: 0.13.11
    dev: true

  /@changesets/apply-release-plan@6.1.4:
    resolution: {integrity: sha512-FMpKF1fRlJyCZVYHr3CbinpZZ+6MwvOtWUuO8uo+svcATEoc1zRDcj23pAurJ2TZ/uVz1wFHH6K3NlACy0PLew==}
    dependencies:
      '@babel/runtime': 7.22.6
      '@changesets/config': 2.3.1
      '@changesets/get-version-range-type': 0.3.2
      '@changesets/git': 2.0.0
      '@changesets/types': 5.2.1
      '@manypkg/get-packages': 1.1.3
      detect-indent: 6.1.0
      fs-extra: 7.0.1
      lodash.startcase: 4.4.0
      outdent: 0.5.0
      prettier: 2.8.7
      resolve-from: 5.0.0
      semver: 7.5.4
    dev: true

  /@changesets/assemble-release-plan@5.2.4:
    resolution: {integrity: sha512-xJkWX+1/CUaOUWTguXEbCDTyWJFECEhmdtbkjhn5GVBGxdP/JwaHBIU9sW3FR6gD07UwZ7ovpiPclQZs+j+mvg==}
    dependencies:
      '@babel/runtime': 7.22.6
      '@changesets/errors': 0.1.4
      '@changesets/get-dependents-graph': 1.3.6
      '@changesets/types': 5.2.1
      '@manypkg/get-packages': 1.1.3
      semver: 7.5.4
    dev: true

  /@changesets/changelog-git@0.1.14:
    resolution: {integrity: sha512-+vRfnKtXVWsDDxGctOfzJsPhaCdXRYoe+KyWYoq5X/GqoISREiat0l3L8B0a453B2B4dfHGcZaGyowHbp9BSaA==}
    dependencies:
      '@changesets/types': 5.2.1
    dev: true

  /@changesets/cli@2.26.1:
    resolution: {integrity: sha512-XnTa+b51vt057fyAudvDKGB0Sh72xutQZNAdXkCqPBKO2zvs2yYZx5hFZj1u9cbtpwM6Sxtcr02/FQJfZOzemQ==}
    hasBin: true
    dependencies:
      '@babel/runtime': 7.22.6
      '@changesets/apply-release-plan': 6.1.4
      '@changesets/assemble-release-plan': 5.2.4
      '@changesets/changelog-git': 0.1.14
      '@changesets/config': 2.3.1
      '@changesets/errors': 0.1.4
      '@changesets/get-dependents-graph': 1.3.6
      '@changesets/get-release-plan': 3.0.17
      '@changesets/git': 2.0.0
      '@changesets/logger': 0.0.5
      '@changesets/pre': 1.0.14
      '@changesets/read': 0.5.9
      '@changesets/types': 5.2.1
      '@changesets/write': 0.2.3
      '@manypkg/get-packages': 1.1.3
      '@types/is-ci': 3.0.0
      '@types/semver': 6.2.3
      ansi-colors: 4.1.3
      chalk: 2.4.2
      enquirer: 2.3.6
      external-editor: 3.1.0
      fs-extra: 7.0.1
      human-id: 1.0.2
      is-ci: 3.0.1
      meow: 6.1.1
      outdent: 0.5.0
      p-limit: 2.3.0
      preferred-pm: 3.0.3
      resolve-from: 5.0.0
      semver: 5.7.1
      spawndamnit: 2.0.0
      term-size: 2.2.1
      tty-table: 4.2.1
    dev: true

  /@changesets/config@2.3.1:
    resolution: {integrity: sha512-PQXaJl82CfIXddUOppj4zWu+987GCw2M+eQcOepxN5s+kvnsZOwjEJO3DH9eVy+OP6Pg/KFEWdsECFEYTtbg6w==}
    dependencies:
      '@changesets/errors': 0.1.4
      '@changesets/get-dependents-graph': 1.3.6
      '@changesets/logger': 0.0.5
      '@changesets/types': 5.2.1
      '@manypkg/get-packages': 1.1.3
      fs-extra: 7.0.1
      micromatch: 4.0.5
    dev: true

  /@changesets/errors@0.1.4:
    resolution: {integrity: sha512-HAcqPF7snsUJ/QzkWoKfRfXushHTu+K5KZLJWPb34s4eCZShIf8BFO3fwq6KU8+G7L5KdtN2BzQAXOSXEyiY9Q==}
    dependencies:
      extendable-error: 0.1.7
    dev: true

  /@changesets/get-dependents-graph@1.3.6:
    resolution: {integrity: sha512-Q/sLgBANmkvUm09GgRsAvEtY3p1/5OCzgBE5vX3vgb5CvW0j7CEljocx5oPXeQSNph6FXulJlXV3Re/v3K3P3Q==}
    dependencies:
      '@changesets/types': 5.2.1
      '@manypkg/get-packages': 1.1.3
      chalk: 2.4.2
      fs-extra: 7.0.1
      semver: 7.5.4
    dev: true

  /@changesets/get-release-plan@3.0.17:
    resolution: {integrity: sha512-6IwKTubNEgoOZwDontYc2x2cWXfr6IKxP3IhKeK+WjyD6y3M4Gl/jdQvBw+m/5zWILSOCAaGLu2ZF6Q+WiPniw==}
    dependencies:
      '@babel/runtime': 7.22.6
      '@changesets/assemble-release-plan': 5.2.4
      '@changesets/config': 2.3.1
      '@changesets/pre': 1.0.14
      '@changesets/read': 0.5.9
      '@changesets/types': 5.2.1
      '@manypkg/get-packages': 1.1.3
    dev: true

  /@changesets/get-version-range-type@0.3.2:
    resolution: {integrity: sha512-SVqwYs5pULYjYT4op21F2pVbcrca4qA/bAA3FmFXKMN7Y+HcO8sbZUTx3TAy2VXulP2FACd1aC7f2nTuqSPbqg==}
    dev: true

  /@changesets/git@2.0.0:
    resolution: {integrity: sha512-enUVEWbiqUTxqSnmesyJGWfzd51PY4H7mH9yUw0hPVpZBJ6tQZFMU3F3mT/t9OJ/GjyiM4770i+sehAn6ymx6A==}
    dependencies:
      '@babel/runtime': 7.22.6
      '@changesets/errors': 0.1.4
      '@changesets/types': 5.2.1
      '@manypkg/get-packages': 1.1.3
      is-subdir: 1.2.0
      micromatch: 4.0.5
      spawndamnit: 2.0.0
    dev: true

  /@changesets/logger@0.0.5:
    resolution: {integrity: sha512-gJyZHomu8nASHpaANzc6bkQMO9gU/ib20lqew1rVx753FOxffnCrJlGIeQVxNWCqM+o6OOleCo/ivL8UAO5iFw==}
    dependencies:
      chalk: 2.4.2
    dev: true

  /@changesets/parse@0.3.16:
    resolution: {integrity: sha512-127JKNd167ayAuBjUggZBkmDS5fIKsthnr9jr6bdnuUljroiERW7FBTDNnNVyJ4l69PzR57pk6mXQdtJyBCJKg==}
    dependencies:
      '@changesets/types': 5.2.1
      js-yaml: 3.14.1
    dev: true

  /@changesets/pre@1.0.14:
    resolution: {integrity: sha512-dTsHmxQWEQekHYHbg+M1mDVYFvegDh9j/kySNuDKdylwfMEevTeDouR7IfHNyVodxZXu17sXoJuf2D0vi55FHQ==}
    dependencies:
      '@babel/runtime': 7.22.6
      '@changesets/errors': 0.1.4
      '@changesets/types': 5.2.1
      '@manypkg/get-packages': 1.1.3
      fs-extra: 7.0.1
    dev: true

  /@changesets/read@0.5.9:
    resolution: {integrity: sha512-T8BJ6JS6j1gfO1HFq50kU3qawYxa4NTbI/ASNVVCBTsKquy2HYwM9r7ZnzkiMe8IEObAJtUVGSrePCOxAK2haQ==}
    dependencies:
      '@babel/runtime': 7.22.6
      '@changesets/git': 2.0.0
      '@changesets/logger': 0.0.5
      '@changesets/parse': 0.3.16
      '@changesets/types': 5.2.1
      chalk: 2.4.2
      fs-extra: 7.0.1
      p-filter: 2.1.0
    dev: true

  /@changesets/types@4.1.0:
    resolution: {integrity: sha512-LDQvVDv5Kb50ny2s25Fhm3d9QSZimsoUGBsUioj6MC3qbMUCuC8GPIvk/M6IvXx3lYhAs0lwWUQLb+VIEUCECw==}
    dev: true

  /@changesets/types@5.2.1:
    resolution: {integrity: sha512-myLfHbVOqaq9UtUKqR/nZA/OY7xFjQMdfgfqeZIBK4d0hA6pgxArvdv8M+6NUzzBsjWLOtvApv8YHr4qM+Kpfg==}
    dev: true

  /@changesets/write@0.2.3:
    resolution: {integrity: sha512-Dbamr7AIMvslKnNYsLFafaVORx4H0pvCA2MHqgtNCySMe1blImEyAEOzDmcgKAkgz4+uwoLz7demIrX+JBr/Xw==}
    dependencies:
      '@babel/runtime': 7.22.6
      '@changesets/types': 5.2.1
      fs-extra: 7.0.1
      human-id: 1.0.2
      prettier: 2.8.7
    dev: true

  /@ckb-lumos/base@0.24.0-next.1:
    resolution: {integrity: sha512-p9veifS3aT0DqdIYWlG6jCUgA68m9baTDzyELIGU1RlLga0yXEElSkY9F534u6eqgriNWBb1b9imMV75sEPauw==}
    engines: {node: '>=12.0.0'}
    dependencies:
      '@ckb-lumos/bi': 0.24.0-next.1
      '@ckb-lumos/codec': 0.24.0-next.1
      '@ckb-lumos/toolkit': 0.24.0-next.1
      '@types/blake2b': 2.1.0
      '@types/lodash.isequal': 4.5.6
      blake2b: 2.1.4
      js-xxhash: 1.0.4
    dev: false

  /@ckb-lumos/bi@0.24.0-next.1:
    resolution: {integrity: sha512-rSkEFSO97b6z58aPrvpXQEBkOBFn/qM2w4VZRhiK64SAwlPPU7c9Pxfd6VBfvp3kK6D3fE9TtVeF/7GRc23Wzw==}
    engines: {node: '>=12.0.0'}
    dependencies:
      jsbi: 4.3.0
    dev: false

  /@ckb-lumos/ckb-indexer@0.24.0-next.1:
    resolution: {integrity: sha512-mdl9cB0IjS8oEixKSWXynObAADjtJIZr1YFFzICLErDHYSOp+KfM7kkmcakE2hLEIpNUPflkOY1eTBilGD7Z0Q==}
    engines: {node: '>=12.0.0'}
    dependencies:
      '@ckb-lumos/base': 0.24.0-next.1
      '@ckb-lumos/bi': 0.24.0-next.1
      '@ckb-lumos/codec': 0.24.0-next.1
      '@ckb-lumos/rpc': 0.24.0-next.1
      '@ckb-lumos/toolkit': 0.24.0-next.1
      cross-fetch: 3.1.8
      events: 3.3.0
    transitivePeerDependencies:
      - encoding
    dev: false

  /@ckb-lumos/codec@0.24.0-next.1:
    resolution: {integrity: sha512-Nc0OtH3WZpa7Ryp/o7QodCuf49/806cz2J4S3KEhL7WZnPwHCwKAhpUNeRTubNzQRlRzUqok3/NoJAlKclOuhw==}
    engines: {node: '>=12.0.0'}
    dependencies:
      '@ckb-lumos/bi': 0.24.0-next.1
    dev: false

  /@ckb-lumos/common-scripts@0.24.0-next.1:
    resolution: {integrity: sha512-4QvQZ8wigZSYzMNfI2R6OrZsIb2pRD1jt6gHXk8WF1bnyZmiyPlNlKyo8sgpXFNdR6x2it5z5yFdv9s4OPl7wA==}
    engines: {node: '>=12.0.0'}
    dependencies:
      '@ckb-lumos/base': 0.24.0-next.1
      '@ckb-lumos/bi': 0.24.0-next.1
      '@ckb-lumos/codec': 0.24.0-next.1
      '@ckb-lumos/config-manager': 0.24.0-next.1
      '@ckb-lumos/crypto': 0.24.0-next.1
      '@ckb-lumos/helpers': 0.24.0-next.1
      '@ckb-lumos/rpc': 0.24.0-next.1
      '@ckb-lumos/toolkit': 0.24.0-next.1
      bech32: 2.0.0
      bs58: 5.0.0
      immutable: 4.3.0
    transitivePeerDependencies:
      - encoding
    dev: false

  /@ckb-lumos/config-manager@0.24.0-next.1:
    resolution: {integrity: sha512-rKgzpVJ0rhFnVjPW2NWnQF/keZTe382GlNt/N2Fz/lEQJidnxfqTb9UizpcuTX2LXYz53iS13c9/PwoLUzmlEw==}
    engines: {node: '>=12.0.0'}
    dependencies:
      '@ckb-lumos/base': 0.24.0-next.1
      '@ckb-lumos/bi': 0.24.0-next.1
      '@ckb-lumos/codec': 0.24.0-next.1
      '@ckb-lumos/rpc': 0.24.0-next.1
      '@types/deep-freeze-strict': 1.1.0
      deep-freeze-strict: 1.1.1
    transitivePeerDependencies:
      - encoding
    dev: false

  /@ckb-lumos/crypto@0.24.0-next.1:
    resolution: {integrity: sha512-sJLZKtnL0C6gi2yKbu4mp6UDNzOpaeidCTGCWhG39527PvQ1CYDh6PVr2zq5K6AL7OgnxsWZK1yvJ+KoHdVOqQ==}
    engines: {node: '>=18.0.0'}
    dependencies:
      '@noble/ciphers': 0.5.3
      '@noble/hashes': 1.4.0
    dev: false

  /@ckb-lumos/hd@0.24.0-next.1:
    resolution: {integrity: sha512-VVOJjU5KZPmb3cmaGPOHJOcxIrKMfYPuo/D51bqSOQ3MZswN4aR6cwW2sQSp7QdDPzOiD/ZPBIMGmuYPEW5zew==}
    engines: {node: '>=12.0.0'}
    dependencies:
      '@ckb-lumos/base': 0.24.0-next.1
      '@ckb-lumos/bi': 0.24.0-next.1
      '@ckb-lumos/codec': 0.24.0-next.1
      '@ckb-lumos/crypto': 0.24.0-next.1
      bn.js: 4.12.0
      elliptic: 6.5.4
      uuid: 8.3.2
    dev: false

  /@ckb-lumos/helpers@0.24.0-next.1:
    resolution: {integrity: sha512-w9L3TdbUEWQXa8CFVDCNuoyrDYba/6+j6ZCXfAWe16CRu5vWsf6gNwMrHy9w9jPJAY2mDRNvgwcMiO7KCMfzbw==}
    engines: {node: '>=12.0.0'}
    dependencies:
      '@ckb-lumos/base': 0.24.0-next.1
      '@ckb-lumos/bi': 0.24.0-next.1
      '@ckb-lumos/codec': 0.24.0-next.1
      '@ckb-lumos/config-manager': 0.24.0-next.1
      '@ckb-lumos/toolkit': 0.24.0-next.1
      bech32: 2.0.0
      immutable: 4.3.0
    transitivePeerDependencies:
      - encoding
    dev: false

  /@ckb-lumos/light-client@0.24.0-next.1:
    resolution: {integrity: sha512-wg4RcmRcAyQhxtwm8sV/hVqfdfngJTot+WBC8+Gsg5jRePfk1O725Pq84QiRKHtR6c3XL9R3fITwYZe8gXZIuA==}
    engines: {node: '>=12.0.0'}
    dependencies:
      '@ckb-lumos/base': 0.24.0-next.1
      '@ckb-lumos/ckb-indexer': 0.24.0-next.1
      '@ckb-lumos/rpc': 0.24.0-next.1
      cross-fetch: 3.1.8
      events: 3.3.0
    transitivePeerDependencies:
      - encoding
    dev: false

  /@ckb-lumos/lumos@0.24.0-next.1:
    resolution: {integrity: sha512-/1mcTQE/32w8wi/OaRokyNE7cSMSNazs7/9RYzh2oXIiVKLc6BNDigkHC3jbJmpHy8chy/UOYPhLfRGkRVXcRQ==}
    engines: {node: '>=12.0.0'}
    dependencies:
      '@ckb-lumos/base': 0.24.0-next.1
      '@ckb-lumos/bi': 0.24.0-next.1
      '@ckb-lumos/ckb-indexer': 0.24.0-next.1
      '@ckb-lumos/codec': 0.24.0-next.1
      '@ckb-lumos/common-scripts': 0.24.0-next.1
      '@ckb-lumos/config-manager': 0.24.0-next.1
      '@ckb-lumos/crypto': 0.24.0-next.1
      '@ckb-lumos/hd': 0.24.0-next.1
      '@ckb-lumos/helpers': 0.24.0-next.1
      '@ckb-lumos/light-client': 0.24.0-next.1
      '@ckb-lumos/rpc': 0.24.0-next.1
      '@ckb-lumos/toolkit': 0.24.0-next.1
      '@ckb-lumos/transaction-manager': 0.24.0-next.1
    transitivePeerDependencies:
      - encoding
    dev: false

  /@ckb-lumos/rpc@0.24.0-next.1:
    resolution: {integrity: sha512-RBIqxxzmkdcSlgwyEv9ezW+x+uovVT7P5+6Ox8eEtoN6L/+hOgLH2MYzishFJXSn93H86GLz/9BPQ/0qx2wUWA==}
    engines: {node: '>=12.0.0'}
    dependencies:
      '@ckb-lumos/base': 0.24.0-next.1
      '@ckb-lumos/bi': 0.24.0-next.1
      abort-controller: 3.0.0
      cross-fetch: 3.1.8
    transitivePeerDependencies:
      - encoding
    dev: false

  /@ckb-lumos/toolkit@0.24.0-next.1:
    resolution: {integrity: sha512-BN0phy014RJV+MhnHkkcO+skQxHN7JPwfszEML0aPnhwtEyZpHjMJx01+BijLUCli9rCZqZrM0QvMoM2wpJV1w==}
    engines: {node: '>=12.0.0'}
    dependencies:
      '@ckb-lumos/bi': 0.24.0-next.1
    dev: false

  /@ckb-lumos/transaction-manager@0.24.0-next.1:
    resolution: {integrity: sha512-m3sLhBlEgFu/LIq50bD5THYfQppOQRKMSb0KY7WjoOyWKGQw9x7TiZr97vvaOmNp7SCk09UHovhZT32U6w7+YA==}
    engines: {node: '>=12.0.0'}
    dependencies:
      '@ckb-lumos/base': 0.24.0-next.1
      '@ckb-lumos/ckb-indexer': 0.24.0-next.1
      '@ckb-lumos/codec': 0.24.0-next.1
      '@ckb-lumos/rpc': 0.24.0-next.1
      '@ckb-lumos/toolkit': 0.24.0-next.1
      immutable: 4.3.0
    transitivePeerDependencies:
      - encoding
    dev: false

  /@cspotcode/source-map-support@0.8.1:
    resolution: {integrity: sha512-IchNf6dN4tHoMFIn/7OE8LWZ19Y6q/67Bmf6vnGREv8RSbBVb9LPJxEcnwrcwX6ixSvaiGoomAUvu4YSxXrVgw==}
    engines: {node: '>=12'}
    dependencies:
      '@jridgewell/trace-mapping': 0.3.9

  /@esbuild/aix-ppc64@0.19.11:
    resolution: {integrity: sha512-FnzU0LyE3ySQk7UntJO4+qIiQgI7KoODnZg5xzXIrFJlKd2P2gwHsHY4927xj9y5PJmJSzULiUCWmv7iWnNa7g==}
    engines: {node: '>=12'}
    cpu: [ppc64]
    os: [aix]
    requiresBuild: true
    dev: true
    optional: true

  /@esbuild/android-arm64@0.19.11:
    resolution: {integrity: sha512-aiu7K/5JnLj//KOnOfEZ0D90obUkRzDMyqd/wNAUQ34m4YUPVhRZpnqKV9uqDGxT7cToSDnIHsGooyIczu9T+Q==}
    engines: {node: '>=12'}
    cpu: [arm64]
    os: [android]
    requiresBuild: true
    dev: true
    optional: true

  /@esbuild/android-arm@0.19.11:
    resolution: {integrity: sha512-5OVapq0ClabvKvQ58Bws8+wkLCV+Rxg7tUVbo9xu034Nm536QTII4YzhaFriQ7rMrorfnFKUsArD2lqKbFY4vw==}
    engines: {node: '>=12'}
    cpu: [arm]
    os: [android]
    requiresBuild: true
    dev: true
    optional: true

  /@esbuild/android-x64@0.19.11:
    resolution: {integrity: sha512-eccxjlfGw43WYoY9QgB82SgGgDbibcqyDTlk3l3C0jOVHKxrjdc9CTwDUQd0vkvYg5um0OH+GpxYvp39r+IPOg==}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [android]
    requiresBuild: true
    dev: true
    optional: true

  /@esbuild/darwin-arm64@0.19.11:
    resolution: {integrity: sha512-ETp87DRWuSt9KdDVkqSoKoLFHYTrkyz2+65fj9nfXsaV3bMhTCjtQfw3y+um88vGRKRiF7erPrh/ZuIdLUIVxQ==}
    engines: {node: '>=12'}
    cpu: [arm64]
    os: [darwin]
    requiresBuild: true
    dev: true
    optional: true

  /@esbuild/darwin-x64@0.19.11:
    resolution: {integrity: sha512-fkFUiS6IUK9WYUO/+22omwetaSNl5/A8giXvQlcinLIjVkxwTLSktbF5f/kJMftM2MJp9+fXqZ5ezS7+SALp4g==}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [darwin]
    requiresBuild: true
    dev: true
    optional: true

  /@esbuild/freebsd-arm64@0.19.11:
    resolution: {integrity: sha512-lhoSp5K6bxKRNdXUtHoNc5HhbXVCS8V0iZmDvyWvYq9S5WSfTIHU2UGjcGt7UeS6iEYp9eeymIl5mJBn0yiuxA==}
    engines: {node: '>=12'}
    cpu: [arm64]
    os: [freebsd]
    requiresBuild: true
    dev: true
    optional: true

  /@esbuild/freebsd-x64@0.19.11:
    resolution: {integrity: sha512-JkUqn44AffGXitVI6/AbQdoYAq0TEullFdqcMY/PCUZ36xJ9ZJRtQabzMA+Vi7r78+25ZIBosLTOKnUXBSi1Kw==}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [freebsd]
    requiresBuild: true
    dev: true
    optional: true

  /@esbuild/linux-arm64@0.19.11:
    resolution: {integrity: sha512-LneLg3ypEeveBSMuoa0kwMpCGmpu8XQUh+mL8XXwoYZ6Be2qBnVtcDI5azSvh7vioMDhoJFZzp9GWp9IWpYoUg==}
    engines: {node: '>=12'}
    cpu: [arm64]
    os: [linux]
    requiresBuild: true
    dev: true
    optional: true

  /@esbuild/linux-arm@0.19.11:
    resolution: {integrity: sha512-3CRkr9+vCV2XJbjwgzjPtO8T0SZUmRZla+UL1jw+XqHZPkPgZiyWvbDvl9rqAN8Zl7qJF0O/9ycMtjU67HN9/Q==}
    engines: {node: '>=12'}
    cpu: [arm]
    os: [linux]
    requiresBuild: true
    dev: true
    optional: true

  /@esbuild/linux-ia32@0.19.11:
    resolution: {integrity: sha512-caHy++CsD8Bgq2V5CodbJjFPEiDPq8JJmBdeyZ8GWVQMjRD0sU548nNdwPNvKjVpamYYVL40AORekgfIubwHoA==}
    engines: {node: '>=12'}
    cpu: [ia32]
    os: [linux]
    requiresBuild: true
    dev: true
    optional: true

  /@esbuild/linux-loong64@0.19.11:
    resolution: {integrity: sha512-ppZSSLVpPrwHccvC6nQVZaSHlFsvCQyjnvirnVjbKSHuE5N24Yl8F3UwYUUR1UEPaFObGD2tSvVKbvR+uT1Nrg==}
    engines: {node: '>=12'}
    cpu: [loong64]
    os: [linux]
    requiresBuild: true
    dev: true
    optional: true

  /@esbuild/linux-mips64el@0.19.11:
    resolution: {integrity: sha512-B5x9j0OgjG+v1dF2DkH34lr+7Gmv0kzX6/V0afF41FkPMMqaQ77pH7CrhWeR22aEeHKaeZVtZ6yFwlxOKPVFyg==}
    engines: {node: '>=12'}
    cpu: [mips64el]
    os: [linux]
    requiresBuild: true
    dev: true
    optional: true

  /@esbuild/linux-ppc64@0.19.11:
    resolution: {integrity: sha512-MHrZYLeCG8vXblMetWyttkdVRjQlQUb/oMgBNurVEnhj4YWOr4G5lmBfZjHYQHHN0g6yDmCAQRR8MUHldvvRDA==}
    engines: {node: '>=12'}
    cpu: [ppc64]
    os: [linux]
    requiresBuild: true
    dev: true
    optional: true

  /@esbuild/linux-riscv64@0.19.11:
    resolution: {integrity: sha512-f3DY++t94uVg141dozDu4CCUkYW+09rWtaWfnb3bqe4w5NqmZd6nPVBm+qbz7WaHZCoqXqHz5p6CM6qv3qnSSQ==}
    engines: {node: '>=12'}
    cpu: [riscv64]
    os: [linux]
    requiresBuild: true
    dev: true
    optional: true

  /@esbuild/linux-s390x@0.19.11:
    resolution: {integrity: sha512-A5xdUoyWJHMMlcSMcPGVLzYzpcY8QP1RtYzX5/bS4dvjBGVxdhuiYyFwp7z74ocV7WDc0n1harxmpq2ePOjI0Q==}
    engines: {node: '>=12'}
    cpu: [s390x]
    os: [linux]
    requiresBuild: true
    dev: true
    optional: true

  /@esbuild/linux-x64@0.19.11:
    resolution: {integrity: sha512-grbyMlVCvJSfxFQUndw5mCtWs5LO1gUlwP4CDi4iJBbVpZcqLVT29FxgGuBJGSzyOxotFG4LoO5X+M1350zmPA==}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [linux]
    requiresBuild: true
    dev: true
    optional: true

  /@esbuild/netbsd-x64@0.19.11:
    resolution: {integrity: sha512-13jvrQZJc3P230OhU8xgwUnDeuC/9egsjTkXN49b3GcS5BKvJqZn86aGM8W9pd14Kd+u7HuFBMVtrNGhh6fHEQ==}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [netbsd]
    requiresBuild: true
    dev: true
    optional: true

  /@esbuild/openbsd-x64@0.19.11:
    resolution: {integrity: sha512-ysyOGZuTp6SNKPE11INDUeFVVQFrhcNDVUgSQVDzqsqX38DjhPEPATpid04LCoUr2WXhQTEZ8ct/EgJCUDpyNw==}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [openbsd]
    requiresBuild: true
    dev: true
    optional: true

  /@esbuild/sunos-x64@0.19.11:
    resolution: {integrity: sha512-Hf+Sad9nVwvtxy4DXCZQqLpgmRTQqyFyhT3bZ4F2XlJCjxGmRFF0Shwn9rzhOYRB61w9VMXUkxlBy56dk9JJiQ==}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [sunos]
    requiresBuild: true
    dev: true
    optional: true

  /@esbuild/win32-arm64@0.19.11:
    resolution: {integrity: sha512-0P58Sbi0LctOMOQbpEOvOL44Ne0sqbS0XWHMvvrg6NE5jQ1xguCSSw9jQeUk2lfrXYsKDdOe6K+oZiwKPilYPQ==}
    engines: {node: '>=12'}
    cpu: [arm64]
    os: [win32]
    requiresBuild: true
    dev: true
    optional: true

  /@esbuild/win32-ia32@0.19.11:
    resolution: {integrity: sha512-6YOrWS+sDJDmshdBIQU+Uoyh7pQKrdykdefC1avn76ss5c+RN6gut3LZA4E2cH5xUEp5/cA0+YxRaVtRAb0xBg==}
    engines: {node: '>=12'}
    cpu: [ia32]
    os: [win32]
    requiresBuild: true
    dev: true
    optional: true

  /@esbuild/win32-x64@0.19.11:
    resolution: {integrity: sha512-vfkhltrjCAb603XaFhqhAF4LGDi2M4OrCRrFusyQ+iTLQ/o60QQXxc9cZC/FFpihBI9N1Grn6SMKVJ4KP7Fuiw==}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [win32]
    requiresBuild: true
    dev: true
    optional: true

  /@exact-realty/multipart-parser@1.0.13:
    resolution: {integrity: sha512-BGnB0VVn18dkz85rvBmp/CyxAMvUcVrsNf3qw8Fdx80V6+MsQUTxRdQnC0PzLIxbN8PKGFs8afd+ur8V1JLv8g==}
    engines: {node: '>=16.0.0', npm: '>=8.0.0'}
    dev: true

  /@isaacs/cliui@8.0.2:
    resolution: {integrity: sha512-O8jcjabXaleOG9DQ0+ARXWZBTfnP4WNAqzuiJK7ll44AmxGKv/J2M4TPjxjY3znBCfvBXFzucm1twdyFybFqEA==}
    engines: {node: '>=12'}
    dependencies:
      string-width: 5.1.2
      string-width-cjs: /string-width@4.2.3
      strip-ansi: 7.1.0
      strip-ansi-cjs: /strip-ansi@6.0.1
      wrap-ansi: 8.1.0
      wrap-ansi-cjs: /wrap-ansi@7.0.0
    dev: false

  /@jest/schemas@29.6.3:
    resolution: {integrity: sha512-mo5j5X+jIZmJQveBKeS/clAueipV7KgiX1vMgCxam1RNYiqE1w62n0/tJJnHtjW8ZHcQco5gY85jA3mi0L+nSA==}
    engines: {node: ^14.15.0 || ^16.10.0 || >=18.0.0}
    dependencies:
      '@sinclair/typebox': 0.27.8
    dev: true

  /@jridgewell/resolve-uri@3.1.1:
    resolution: {integrity: sha512-dSYZh7HhCDtCKm4QakX0xFpsRDqjjtZf/kjI/v3T3Nwt5r8/qz/M19F9ySyOqU94SXBmeG9ttTul+YnR4LOxFA==}
    engines: {node: '>=6.0.0'}

  /@jridgewell/sourcemap-codec@1.4.15:
    resolution: {integrity: sha512-eF2rxCRulEKXHTRiDrDy6erMYWqNw4LPdQ8UQA4huuxaQsVeRPFl2oM8oDGxMFhJUWZf9McpLtJasDDZb/Bpeg==}

  /@jridgewell/trace-mapping@0.3.9:
    resolution: {integrity: sha512-3Belt6tdc8bPgAtbcmdtNJlirVoTmEb5e2gC94PnkwEW9jI6CAHUeoG85tjWP5WquqfavoMtMwiG4P926ZKKuQ==}
    dependencies:
      '@jridgewell/resolve-uri': 3.1.1
      '@jridgewell/sourcemap-codec': 1.4.15

  /@manypkg/find-root@1.1.0:
    resolution: {integrity: sha512-mki5uBvhHzO8kYYix/WRy2WX8S3B5wdVSc9D6KcU5lQNglP2yt58/VfLuAK49glRXChosY8ap2oJ1qgma3GUVA==}
    dependencies:
      '@babel/runtime': 7.22.6
      '@types/node': 12.20.55
      find-up: 4.1.0
      fs-extra: 8.1.0
    dev: true

  /@manypkg/get-packages@1.1.3:
    resolution: {integrity: sha512-fo+QhuU3qE/2TQMQmbVMqaQ6EWbMhi4ABWP+O4AM1NqPBuy0OrApV5LO6BrrgnhtAHS2NH6RrVk9OL181tTi8A==}
    dependencies:
      '@babel/runtime': 7.22.6
      '@changesets/types': 4.1.0
      '@manypkg/find-root': 1.1.0
      fs-extra: 8.1.0
      globby: 11.1.0
      read-yaml-file: 1.1.0
    dev: true

  /@noble/ciphers@0.5.3:
    resolution: {integrity: sha512-B0+6IIHiqEs3BPMT0hcRmHvEj2QHOLu+uwt+tqDDeVd0oyVzh7BPrDcPjRnV1PV/5LaknXJJQvOuRGR0zQJz+w==}
    dev: false

  /@noble/hashes@1.4.0:
    resolution: {integrity: sha512-V1JJ1WTRUqHHrOSh597hURcMqVKVGL/ea3kv0gSnEdsEZ0/+VyPghM1lMNGc00z7CIQorSvbKpuJkxvuHbvdbg==}
    engines: {node: '>= 16'}
    dev: false

  /@nodelib/fs.scandir@2.1.5:
    resolution: {integrity: sha512-vq24Bq3ym5HEQm2NKCr3yXDwjc7vTsEThRDnkp2DK9p1uqLR+DHurm/NOTo0KG7HYHU7eppKZj3MyqYuMBf62g==}
    engines: {node: '>= 8'}
    dependencies:
      '@nodelib/fs.stat': 2.0.5
      run-parallel: 1.2.0
    dev: true

  /@nodelib/fs.stat@2.0.5:
    resolution: {integrity: sha512-RkhPPp2zrqDAQA/2jNhnztcPAlv64XdhIp7a7454A5ovI7Bukxgt7MX7udwAu3zg1DcpPU0rz3VV1SeaqvY4+A==}
    engines: {node: '>= 8'}
    dev: true

  /@nodelib/fs.walk@1.2.8:
    resolution: {integrity: sha512-oGB+UxlgWcgQkgwo8GcEGwemoTFt3FIO9ababBmaGwXIoBKZ+GTy0pP185beGg7Llih/NSHSV2XAs1lnznocSg==}
    engines: {node: '>= 8'}
    dependencies:
      '@nodelib/fs.scandir': 2.1.5
      fastq: 1.15.0
    dev: true

  /@pkgjs/parseargs@0.11.0:
    resolution: {integrity: sha512-+1VkjdD0QBLPodGrJUeqarH8VAIvQODIbwh9XpP5Syisf7YoQgsJKPNFoqqLQlu+VQ/tVSshMR6loPMn8U+dPg==}
    engines: {node: '>=14'}
    requiresBuild: true
    dev: false
    optional: true

  /@rollup/rollup-android-arm-eabi@4.9.2:
    resolution: {integrity: sha512-RKzxFxBHq9ysZ83fn8Iduv3A283K7zPPYuhL/z9CQuyFrjwpErJx0h4aeb/bnJ+q29GRLgJpY66ceQ/Wcsn3wA==}
    cpu: [arm]
    os: [android]
    requiresBuild: true
    dev: true
    optional: true

  /@rollup/rollup-android-arm64@4.9.2:
    resolution: {integrity: sha512-yZ+MUbnwf3SHNWQKJyWh88ii2HbuHCFQnAYTeeO1Nb8SyEiWASEi5dQUygt3ClHWtA9My9RQAYkjvrsZ0WK8Xg==}
    cpu: [arm64]
    os: [android]
    requiresBuild: true
    dev: true
    optional: true

  /@rollup/rollup-darwin-arm64@4.9.2:
    resolution: {integrity: sha512-vqJ/pAUh95FLc/G/3+xPqlSBgilPnauVf2EXOQCZzhZJCXDXt/5A8mH/OzU6iWhb3CNk5hPJrh8pqJUPldN5zw==}
    cpu: [arm64]
    os: [darwin]
    requiresBuild: true
    dev: true
    optional: true

  /@rollup/rollup-darwin-x64@4.9.2:
    resolution: {integrity: sha512-otPHsN5LlvedOprd3SdfrRNhOahhVBwJpepVKUN58L0RnC29vOAej1vMEaVU6DadnpjivVsNTM5eNt0CcwTahw==}
    cpu: [x64]
    os: [darwin]
    requiresBuild: true
    dev: true
    optional: true

  /@rollup/rollup-linux-arm-gnueabihf@4.9.2:
    resolution: {integrity: sha512-ewG5yJSp+zYKBYQLbd1CUA7b1lSfIdo9zJShNTyc2ZP1rcPrqyZcNlsHgs7v1zhgfdS+kW0p5frc0aVqhZCiYQ==}
    cpu: [arm]
    os: [linux]
    requiresBuild: true
    dev: true
    optional: true

  /@rollup/rollup-linux-arm64-gnu@4.9.2:
    resolution: {integrity: sha512-pL6QtV26W52aCWTG1IuFV3FMPL1m4wbsRG+qijIvgFO/VBsiXJjDPE/uiMdHBAO6YcpV4KvpKtd0v3WFbaxBtg==}
    cpu: [arm64]
    os: [linux]
    requiresBuild: true
    dev: true
    optional: true

  /@rollup/rollup-linux-arm64-musl@4.9.2:
    resolution: {integrity: sha512-On+cc5EpOaTwPSNetHXBuqylDW+765G/oqB9xGmWU3npEhCh8xu0xqHGUA+4xwZLqBbIZNcBlKSIYfkBm6ko7g==}
    cpu: [arm64]
    os: [linux]
    requiresBuild: true
    dev: true
    optional: true

  /@rollup/rollup-linux-riscv64-gnu@4.9.2:
    resolution: {integrity: sha512-Wnx/IVMSZ31D/cO9HSsU46FjrPWHqtdF8+0eyZ1zIB5a6hXaZXghUKpRrC4D5DcRTZOjml2oBhXoqfGYyXKipw==}
    cpu: [riscv64]
    os: [linux]
    requiresBuild: true
    dev: true
    optional: true

  /@rollup/rollup-linux-x64-gnu@4.9.2:
    resolution: {integrity: sha512-ym5x1cj4mUAMBummxxRkI4pG5Vht1QMsJexwGP8547TZ0sox9fCLDHw9KCH9c1FO5d9GopvkaJsBIOkTKxksdw==}
    cpu: [x64]
    os: [linux]
    requiresBuild: true
    dev: true
    optional: true

  /@rollup/rollup-linux-x64-musl@4.9.2:
    resolution: {integrity: sha512-m0hYELHGXdYx64D6IDDg/1vOJEaiV8f1G/iO+tejvRCJNSwK4jJ15e38JQy5Q6dGkn1M/9KcyEOwqmlZ2kqaZg==}
    cpu: [x64]
    os: [linux]
    requiresBuild: true
    dev: true
    optional: true

  /@rollup/rollup-win32-arm64-msvc@4.9.2:
    resolution: {integrity: sha512-x1CWburlbN5JjG+juenuNa4KdedBdXLjZMp56nHFSHTOsb/MI2DYiGzLtRGHNMyydPGffGId+VgjOMrcltOksA==}
    cpu: [arm64]
    os: [win32]
    requiresBuild: true
    dev: true
    optional: true

  /@rollup/rollup-win32-ia32-msvc@4.9.2:
    resolution: {integrity: sha512-VVzCB5yXR1QlfsH1Xw1zdzQ4Pxuzv+CPr5qpElpKhVxlxD3CRdfubAG9mJROl6/dmj5gVYDDWk8sC+j9BI9/kQ==}
    cpu: [ia32]
    os: [win32]
    requiresBuild: true
    dev: true
    optional: true

  /@rollup/rollup-win32-x64-msvc@4.9.2:
    resolution: {integrity: sha512-SYRedJi+mweatroB+6TTnJYLts0L0bosg531xnQWtklOI6dezEagx4Q0qDyvRdK+qgdA3YZpjjGuPFtxBmddBA==}
    cpu: [x64]
    os: [win32]
    requiresBuild: true
    dev: true
    optional: true

  /@sinclair/typebox@0.27.8:
    resolution: {integrity: sha512-+Fj43pSMwJs4KRrH/938Uf+uAELIgVBmQzg/q1YG10djyfA3TnrU8N8XzqCh/okZdszqBQTZf96idMfE5lnwTA==}
    dev: true

  /@tsconfig/node10@1.0.9:
    resolution: {integrity: sha512-jNsYVVxU8v5g43Erja32laIDHXeoNvFEpX33OK4d6hljo3jDhCBDhx5dhCCTMWUojscpAagGiRkBKxpdl9fxqA==}

  /@tsconfig/node12@1.0.11:
    resolution: {integrity: sha512-cqefuRsh12pWyGsIoBKJA9luFu3mRxCA+ORZvA4ktLSzIuCUtWVxGIuXigEwO5/ywWFMZ2QEGKWvkZG1zDMTag==}

  /@tsconfig/node14@1.0.3:
    resolution: {integrity: sha512-ysT8mhdixWK6Hw3i1V2AeRqZ5WfXg1G43mqoYlM2nc6388Fq5jcXyr5mRsqViLx/GJYdoL0bfXD8nmF+Zn/Iow==}

  /@tsconfig/node16@1.0.4:
    resolution: {integrity: sha512-vxhUy4J8lyeyinH7Azl1pdd43GJhZH/tP2weN8TntQblOY+A0XbT8DJk1/oCPuOOyg/Ja757rG0CgHcWC8OfMA==}

  /@types/blake2b@2.1.0:
    resolution: {integrity: sha512-Mv8N0qtdb72iW1XJR/4Yp01frtibnv8BpFUZDROnzd7hVEX4cEN/xHgU2ZfsnOnTDt+fHJVc0uRIWcNz6uIB2A==}
    dev: false

  /@types/deep-freeze-strict@1.1.0:
    resolution: {integrity: sha512-fILflsS66kGQ4iIBzYoxuQCWK1wQdy/ooguTofUk0KSxA+G5ZzH8WdU8mf6IU+5cMBW+j9u+eh+7kv63R3O9Tw==}
    dev: false

  /@types/estree@1.0.5:
    resolution: {integrity: sha512-/kYRxGDLWzHOB7q+wtSUQlFrtcdUccpfy+X+9iMBpHK8QLLhx2wIPYuS5DYtR9Wa/YlZAbIovy7qVdB1Aq6Lyw==}
    dev: true

  /@types/is-ci@3.0.0:
    resolution: {integrity: sha512-Q0Op0hdWbYd1iahB+IFNQcWXFq4O0Q5MwQP7uN0souuQ4rPg1vEYcnIOfr1gY+M+6rc8FGoRaBO1mOOvL29sEQ==}
    dependencies:
      ci-info: 3.8.0
    dev: true

  /@types/lodash.isequal@4.5.6:
    resolution: {integrity: sha512-Ww4UGSe3DmtvLLJm2F16hDwEQSv7U0Rr8SujLUA2wHI2D2dm8kPu6Et+/y303LfjTIwSBKXB/YTUcAKpem/XEg==}
    dependencies:
      '@types/lodash': 4.14.195
    dev: false

  /@types/lodash@4.14.195:
    resolution: {integrity: sha512-Hwx9EUgdwf2GLarOjQp5ZH8ZmblzcbTBC2wtQWNKARBSxM9ezRIAUpeDTgoQRAFB0+8CNWXVA9+MaSOzOF3nPg==}
    dev: false

  /@types/minimist@1.2.2:
    resolution: {integrity: sha512-jhuKLIRrhvCPLqwPcx6INqmKeiA5EWrsCOPhrlFSrbrmU4ZMPjj5Ul/oLCMDO98XRUIwVm78xICz4EPCektzeQ==}
    dev: true

  /@types/node@12.20.55:
    resolution: {integrity: sha512-J8xLz7q2OFulZ2cyGTLE1TbbZcjpno7FaN6zdJNrgAdrJ+DZzh/uFR6YrTb4C+nXakvud8Q4+rbhoIWlYQbUFQ==}
    dev: true

  /@types/node@20.4.1:
    resolution: {integrity: sha512-JIzsAvJeA/5iY6Y/OxZbv1lUcc8dNSE77lb2gnBH+/PJ3lFR1Ccvgwl5JWnHAkNHcRsT0TbpVOsiMKZ1F/yyJg==}

  /@types/normalize-package-data@2.4.1:
    resolution: {integrity: sha512-Gj7cI7z+98M282Tqmp2K5EIsoouUEzbBJhQQzDE3jSIRk6r9gsz0oUokqIUR4u1R3dMHo0pDHM7sNOHyhulypw==}
    dev: true

  /@types/semver@6.2.3:
    resolution: {integrity: sha512-KQf+QAMWKMrtBMsB8/24w53tEsxllMj6TuA80TT/5igJalLI/zm0L3oXRbIAl4Ohfc85gyHX/jhMwsVkmhLU4A==}
    dev: true

  /@vitest/expect@1.4.0:
    resolution: {integrity: sha512-Jths0sWCJZ8BxjKe+p+eKsoqev1/T8lYcrjavEaz8auEJ4jAVY0GwW3JKmdVU4mmNPLPHixh4GNXP7GFtAiDHA==}
    dependencies:
      '@vitest/spy': 1.4.0
      '@vitest/utils': 1.4.0
      chai: 4.3.10
    dev: true

  /@vitest/runner@1.4.0:
    resolution: {integrity: sha512-EDYVSmesqlQ4RD2VvWo3hQgTJ7ZrFQ2VSJdfiJiArkCerDAGeyF1i6dHkmySqk573jLp6d/cfqCN+7wUB5tLgg==}
    dependencies:
      '@vitest/utils': 1.4.0
      p-limit: 5.0.0
      pathe: 1.1.1
    dev: true

  /@vitest/snapshot@1.4.0:
    resolution: {integrity: sha512-saAFnt5pPIA5qDGxOHxJ/XxhMFKkUSBJmVt5VgDsAqPTX6JP326r5C/c9UuCMPoXNzuudTPsYDZCoJ5ilpqG2A==}
    dependencies:
      magic-string: 0.30.5
      pathe: 1.1.1
      pretty-format: 29.7.0
    dev: true

  /@vitest/spy@1.4.0:
    resolution: {integrity: sha512-Ywau/Qs1DzM/8Uc+yA77CwSegizMlcgTJuYGAi0jujOteJOUf1ujunHThYo243KG9nAyWT3L9ifPYZ5+As/+6Q==}
    dependencies:
      tinyspy: 2.2.0
    dev: true

  /@vitest/utils@1.4.0:
    resolution: {integrity: sha512-mx3Yd1/6e2Vt/PUC98DcqTirtfxUyAZ32uK82r8rZzbtBeBo+nqgnjx/LvqQdWsrvNtm14VmurNgcf4nqY5gJg==}
    dependencies:
      diff-sequences: 29.6.3
      estree-walker: 3.0.3
      loupe: 2.3.7
      pretty-format: 29.7.0
    dev: true

  /abort-controller@3.0.0:
    resolution: {integrity: sha512-h8lQ8tacZYnR3vNQTgibj+tODHI5/+l06Au2Pcriv/Gmet0eaj4TwWH41sO9wnHDiQsEj19q0drzdWdeAHtweg==}
    engines: {node: '>=6.5'}
    dependencies:
      event-target-shim: 5.0.1
    dev: false

  /acorn-walk@8.2.0:
    resolution: {integrity: sha512-k+iyHEuPgSw6SbuDpGQM+06HQUa04DZ3o+F6CSzXMvvI5KMvnaEqXe+YVe555R9nn6GPt404fos4wcgpw12SDA==}
    engines: {node: '>=0.4.0'}

  /acorn-walk@8.3.2:
    resolution: {integrity: sha512-cjkyv4OtNCIeqhHrfS81QWXoCBPExR/J62oyEqepVw8WaQeSqpW2uhuLPh1m9eWhDuOo/jUXVTlifvesOWp/4A==}
    engines: {node: '>=0.4.0'}
    dev: true

  /acorn@8.10.0:
    resolution: {integrity: sha512-F0SAmZ8iUtS//m8DmCTA0jlh6TDKkHQyK6xc6V4KDTyZKA9dnvX9/3sRTVQrWm79glUAZbnmmNcdYwUIHWVybw==}
    engines: {node: '>=0.4.0'}
    hasBin: true

  /ansi-colors@4.1.3:
    resolution: {integrity: sha512-/6w/C21Pm1A7aZitlI5Ni/2J6FFQN8i1Cvz3kHABAAbw93v/NlvKdVOqz7CCWz/3iv/JplRSEEZ83XION15ovw==}
    engines: {node: '>=6'}
    dev: true

  /ansi-escapes@5.0.0:
    resolution: {integrity: sha512-5GFMVX8HqE/TB+FuBJGuO5XG0WrsA6ptUqoODaT/n9mmUaZFkqnBueB4leqGBCmrUHnCnC4PCZTCd0E7QQ83bA==}
    engines: {node: '>=12'}
    dependencies:
      type-fest: 1.4.0
    dev: true

  /ansi-regex@5.0.1:
    resolution: {integrity: sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==}
    engines: {node: '>=8'}

  /ansi-regex@6.0.1:
    resolution: {integrity: sha512-n5M855fKb2SsfMIiFFoVrABHJC8QtHwVx+mHWP3QcEqBHYienj5dHSgjbxtC0WEZXYt4wcD6zrQElDPhFuZgfA==}
    engines: {node: '>=12'}

  /ansi-styles@3.2.1:
    resolution: {integrity: sha512-VT0ZI6kZRdTh8YyJw3SMbYm/u+NqfsAxEpWO0Pf9sq8/e94WxxOpPKx9FR1FlyCtOVDNOQ+8ntlqFxiRc+r5qA==}
    engines: {node: '>=4'}
    dependencies:
      color-convert: 1.9.3
    dev: true

  /ansi-styles@4.3.0:
    resolution: {integrity: sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==}
    engines: {node: '>=8'}
    dependencies:
      color-convert: 2.0.1

  /ansi-styles@5.2.0:
    resolution: {integrity: sha512-Cxwpt2SfTzTtXcfOlzGEee8O+c+MmUgGrNiBcXnuWxuFJHe6a5Hz7qwhwe5OgaSYI0IJvkLqWX1ASG+cJOkEiA==}
    engines: {node: '>=10'}
    dev: true

  /ansi-styles@6.2.1:
    resolution: {integrity: sha512-bN798gFfQX+viw3R7yrGWRqnrN2oRkEkUjjl4JNn4E8GxxbjtG3FbrEIIY3l8/hrwUwIeCZvi4QuOTP4MErVug==}
    engines: {node: '>=12'}

  /arg@4.1.3:
    resolution: {integrity: sha512-58S9QDqG0Xx27YwPSt9fJxivjYl432YCwfDMfZ+71RAqUrZef7LrKQZ3LHLOwCS4FLNBplP533Zx895SeOCHvA==}

  /argparse@1.0.10:
    resolution: {integrity: sha512-o5Roy6tNG4SL/FOkCAN6RzjiakZS25RLYFrcMttJqbdd8BWrnA+fGz57iN5Pb06pvBGvl5gQ0B48dJlslXvoTg==}
    dependencies:
      sprintf-js: 1.0.3
    dev: true

  /array-buffer-byte-length@1.0.0:
    resolution: {integrity: sha512-LPuwb2P+NrQw3XhxGc36+XSvuBPopovXYTR9Ew++Du9Yb/bx5AzBfrIsBoj0EZUifjQU+sHL21sseZ3jerWO/A==}
    dependencies:
      call-bind: 1.0.2
      is-array-buffer: 3.0.2
    dev: true

  /array-union@2.1.0:
    resolution: {integrity: sha512-HGyxoOTYUyCM6stUe6EJgnd4EoewAI7zMdfqO+kGjnlZmBDz/cR5pf8r/cR4Wq60sL/p0IkcjUEEPwS3GFrIyw==}
    engines: {node: '>=8'}
    dev: true

  /array.prototype.flat@1.3.1:
    resolution: {integrity: sha512-roTU0KWIOmJ4DRLmwKd19Otg0/mT3qPNt0Qb3GWW8iObuZXxrjB/pzn0R3hqpRSWg4HCwqx+0vwOnWnvlOyeIA==}
    engines: {node: '>= 0.4'}
    dependencies:
      call-bind: 1.0.2
      define-properties: 1.2.0
      es-abstract: 1.21.2
      es-shim-unscopables: 1.0.0
    dev: true

  /arrify@1.0.1:
    resolution: {integrity: sha512-3CYzex9M9FGQjCGMGyi6/31c8GJbgb0qGyrx5HWxPd0aCwh4cB2YjMb2Xf9UuoogrMrlO9cTqnB5rI5GHZTcUA==}
    engines: {node: '>=0.10.0'}
    dev: true

  /assertion-error@1.1.0:
    resolution: {integrity: sha512-jgsaNduz+ndvGyFt3uSuWqvy4lCnIJiovtouQN5JZHOKCS2QuhEdbcQHFhVksz2N2U9hXJo8odG7ETyWlEeuDw==}
    dev: true

  /available-typed-arrays@1.0.5:
    resolution: {integrity: sha512-DMD0KiN46eipeziST1LPP/STfDU0sufISXmjSgvVsoU2tqxctQeASejWcfNtxYKqETM1UxQ8sp2OrSBWpHY6sw==}
    engines: {node: '>= 0.4'}
    dev: true

  /b4a@1.6.4:
    resolution: {integrity: sha512-fpWrvyVHEKyeEvbKZTVOeZF3VSKKWtJxFIxX/jaVPf+cLbGUSitjb49pHLqPV2BUNNZ0LcoeEGfE/YCpyDYHIw==}
    dev: false

  /balanced-match@1.0.2:
    resolution: {integrity: sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==}
    dev: false

  /base-x@4.0.0:
    resolution: {integrity: sha512-FuwxlW4H5kh37X/oW59pwTzzTKRzfrrQwhmyspRM7swOEZcHtDZSCt45U6oKgtuFE+WYPblePMVIPR4RZrh/hw==}
    dev: false

  /bech32@2.0.0:
    resolution: {integrity: sha512-LcknSilhIGatDAsY1ak2I8VtGaHNhgMSYVxFrGLXv+xLHytaKZKcaUJJUE7qmBr7h33o5YQwP55pMI0xmkpJwg==}
    dev: false

  /better-path-resolve@1.0.0:
    resolution: {integrity: sha512-pbnl5XzGBdrFU/wT4jqmJVPn2B6UHPBOhzMQkY/SPUPB6QtUXtmBHBIwCbXJol93mOpGMnQyP/+BB19q04xj7g==}
    engines: {node: '>=4'}
    dependencies:
      is-windows: 1.0.2
    dev: true

  /blake2b-wasm@2.4.0:
    resolution: {integrity: sha512-S1kwmW2ZhZFFFOghcx73+ZajEfKBqhP82JMssxtLVMxlaPea1p9uoLiUZ5WYyHn0KddwbLc+0vh4wR0KBNoT5w==}
    dependencies:
      b4a: 1.6.4
      nanoassert: 2.0.0
    dev: false

  /blake2b@2.1.4:
    resolution: {integrity: sha512-AyBuuJNI64gIvwx13qiICz6H6hpmjvYS5DGkG6jbXMOT8Z3WUJ3V1X0FlhIoT1b/5JtHE3ki+xjtMvu1nn+t9A==}
    dependencies:
      blake2b-wasm: 2.4.0
      nanoassert: 2.0.0
    dev: false

  /bn.js@4.12.0:
    resolution: {integrity: sha512-c98Bf3tPniI+scsdk237ku1Dc3ujXQTSgyiPUDEOe7tRkhrqridvh8klBv0HCEso1OLOYcHuCv/cS6DNxKH+ZA==}
    dev: false

  /brace-expansion@2.0.1:
    resolution: {integrity: sha512-XnAIvQ8eM+kC6aULx6wuQiwVsnzsi9d3WxzV3FpWTGA19F621kwdbsAcFKXgKUHZWsy+mY6iL1sHTxWEFCytDA==}
    dependencies:
      balanced-match: 1.0.2
    dev: false

  /braces@3.0.2:
    resolution: {integrity: sha512-b8um+L1RzM3WDSzvhm6gIz1yfTbBt6YTlcEKAvsmqCZZFw46z626lVj9j1yEPW33H5H+lBQpZMP1k8l+78Ha0A==}
    engines: {node: '>=8'}
    dependencies:
      fill-range: 7.0.1
    dev: true

  /breakword@1.0.6:
    resolution: {integrity: sha512-yjxDAYyK/pBvws9H4xKYpLDpYKEH6CzrBPAuXq3x18I+c/2MkVtT3qAr7Oloi6Dss9qNhPVueAAVU1CSeNDIXw==}
    dependencies:
      wcwidth: 1.0.1
    dev: true

  /brorand@1.1.0:
    resolution: {integrity: sha512-cKV8tMCEpQs4hK/ik71d6LrPOnpkpGBR0wzxqr68g2m/LB2GxVYQroAjMJZRVM1Y4BCjCKc3vAamxSzOY2RP+w==}
    dev: false

  /bs58@5.0.0:
    resolution: {integrity: sha512-r+ihvQJvahgYT50JD05dyJNKlmmSlMoOGwn1lCcEzanPglg7TxYjioQUYehQ9mAR/+hOSd2jRc/Z2y5UxBymvQ==}
    dependencies:
      base-x: 4.0.0
    dev: false

  /cac@6.7.14:
    resolution: {integrity: sha512-b6Ilus+c3RrdDk+JhLKUAQfzzgLEPy6wcXqS7f/xe1EETvsDP6GORG7SFuOs6cID5YkqchW/LXZbX5bc8j7ZcQ==}
    engines: {node: '>=8'}
    dev: true

  /call-bind@1.0.2:
    resolution: {integrity: sha512-7O+FbCihrB5WGbFYesctwmTKae6rOiIzmz1icreWJ+0aA7LJfuqhEso2T9ncpcFtzMQtzXf2QGGueWJGTYsqrA==}
    dependencies:
      function-bind: 1.1.1
      get-intrinsic: 1.2.1
    dev: true

  /camelcase-keys@6.2.2:
    resolution: {integrity: sha512-YrwaA0vEKazPBkn0ipTiMpSajYDSe+KjQfrjhcBMxJt/znbvlHd8Pw/Vamaz5EB4Wfhs3SUR3Z9mwRu/P3s3Yg==}
    engines: {node: '>=8'}
    dependencies:
      camelcase: 5.3.1
      map-obj: 4.3.0
      quick-lru: 4.0.1
    dev: true

  /camelcase@5.3.1:
    resolution: {integrity: sha512-L28STB170nwWS63UjtlEOE3dldQApaJXZkOI1uMFfzf3rRuPegHaHesyee+YxQ+W6SvRDQV6UrdOdRiR153wJg==}
    engines: {node: '>=6'}
    dev: true

  /chai@4.3.10:
    resolution: {integrity: sha512-0UXG04VuVbruMUYbJ6JctvH0YnC/4q3/AkT18q4NaITo91CUm0liMS9VqzT9vZhVQ/1eqPanMWjBM+Juhfb/9g==}
    engines: {node: '>=4'}
    dependencies:
      assertion-error: 1.1.0
      check-error: 1.0.3
      deep-eql: 4.1.3
      get-func-name: 2.0.2
      loupe: 2.3.7
      pathval: 1.1.1
      type-detect: 4.0.8
    dev: true

  /chalk@2.4.2:
    resolution: {integrity: sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==}
    engines: {node: '>=4'}
    dependencies:
      ansi-styles: 3.2.1
      escape-string-regexp: 1.0.5
      supports-color: 5.5.0
    dev: true

  /chalk@4.1.2:
    resolution: {integrity: sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==}
    engines: {node: '>=10'}
    dependencies:
      ansi-styles: 4.3.0
      supports-color: 7.2.0
    dev: true

  /chalk@5.3.0:
    resolution: {integrity: sha512-dLitG79d+GV1Nb/VYcCDFivJeK1hiukt9QjRNVOsUtTy1rR1YJsmpGGTZ3qJos+uw7WmWF4wUwBd9jxjocFC2w==}
    engines: {node: ^12.17.0 || ^14.13 || >=16.0.0}
    dev: true

  /chardet@0.7.0:
    resolution: {integrity: sha512-mT8iDcrh03qDGRRmoA2hmBJnxpllMR+0/0qlzjqZES6NdiWDcZkCNAk4rPFZ9Q85r27unkiNNg8ZOiwZXBHwcA==}
    dev: true

  /check-error@1.0.3:
    resolution: {integrity: sha512-iKEoDYaRmd1mxM90a2OEfWhjsjPpYPuQ+lMYsoxB126+t8fw7ySEO48nmDg5COTjxDI65/Y2OWpeEHk3ZOe8zg==}
    dependencies:
      get-func-name: 2.0.2
    dev: true

  /ci-info@3.8.0:
    resolution: {integrity: sha512-eXTggHWSooYhq49F2opQhuHWgzucfF2YgODK4e1566GQs5BIfP30B0oenwBJHfWxAs2fyPB1s7Mg949zLf61Yw==}
    engines: {node: '>=8'}
    dev: true

  /cli-cursor@4.0.0:
    resolution: {integrity: sha512-VGtlMu3x/4DOtIUwEkRezxUZ2lBacNJCHash0N0WeZDBS+7Ux1dm3XWAgWYxLJFMMdOeXMHXorshEFhbMSGelg==}
    engines: {node: ^12.20.0 || ^14.13.1 || >=16.0.0}
    dependencies:
      restore-cursor: 4.0.0
    dev: true

  /cli-truncate@3.1.0:
    resolution: {integrity: sha512-wfOBkjXteqSnI59oPcJkcPl/ZmwvMMOj340qUIY1SKZCv0B9Cf4D4fAucRkIKQmsIuYK3x1rrgU7MeGRruiuiA==}
    engines: {node: ^12.20.0 || ^14.13.1 || >=16.0.0}
    dependencies:
      slice-ansi: 5.0.0
      string-width: 5.1.2
    dev: true

  /cliui@6.0.0:
    resolution: {integrity: sha512-t6wbgtoCXvAzst7QgXxJYqPt0usEfbgQdftEPbLL/cvv6HPE5VgvqCuAIDR0NgU52ds6rFwqrgakNLrHEjCbrQ==}
    dependencies:
      string-width: 4.2.3
      strip-ansi: 6.0.1
      wrap-ansi: 6.2.0
    dev: true

  /cliui@8.0.1:
    resolution: {integrity: sha512-BSeNnyus75C4//NQ9gQt1/csTXyo/8Sb+afLAkzAptFuMsod9HFokGNudZpi/oQV73hnVK+sR+5PVRMd+Dr7YQ==}
    engines: {node: '>=12'}
    dependencies:
      string-width: 4.2.3
      strip-ansi: 6.0.1
      wrap-ansi: 7.0.0
    dev: true

  /clone@1.0.4:
    resolution: {integrity: sha512-JQHZ2QMW6l3aH/j6xCqQThY/9OH4D/9ls34cgkUBiEeocRTU04tHfKPBsUK1PqZCUQM7GiA0IIXJSuXHI64Kbg==}
    engines: {node: '>=0.8'}
    dev: true

  /color-convert@1.9.3:
    resolution: {integrity: sha512-QfAUtd+vFdAtFQcC8CCyYt1fYWxSqAiK2cSD6zDB8N3cpsEBAvRxp9zOGg6G/SHHJYAT88/az/IuDGALsNVbGg==}
    dependencies:
      color-name: 1.1.3
    dev: true

  /color-convert@2.0.1:
    resolution: {integrity: sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==}
    engines: {node: '>=7.0.0'}
    dependencies:
      color-name: 1.1.4

  /color-name@1.1.3:
    resolution: {integrity: sha512-72fSenhMw2HZMTVHeCA9KCmpEIbzWiQsjN+BHcBbS9vr1mtt+vJjPdksIBNUmKAW8TFUDPJK5SUU3QhE9NEXDw==}
    dev: true

  /color-name@1.1.4:
    resolution: {integrity: sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==}

  /colorette@2.0.20:
    resolution: {integrity: sha512-IfEDxwoWIjkeXL1eXcDiow4UbKjhLdq6/EuSVR9GMN7KVH3r9gQ83e73hsz1Nd1T3ijd5xv1wcWRYO+D6kCI2w==}
    dev: true

  /commander@11.1.0:
    resolution: {integrity: sha512-yPVavfyCcRhmorC7rWlkHn15b4wDVgVmBA7kV4QVBsF7kv/9TKJAbAXVTxvTnwP8HHKjRCJDClKbciiYS7p0DQ==}
    engines: {node: '>=16'}
    dev: true

  /create-require@1.1.1:
    resolution: {integrity: sha512-dcKFX3jn0MpIaXjisoRvexIJVEKzaq7z2rZKxf+MSr9TkdmHmsU4m2lcLojrj/FHl8mk5VxMmYA+ftRkP/3oKQ==}

  /cross-fetch@3.1.8:
    resolution: {integrity: sha512-cvA+JwZoU0Xq+h6WkMvAUqPEYy92Obet6UdKLfW60qn99ftItKjB5T+BkyWOFWe2pUyfQ+IJHmpOTznqk1M6Kg==}
    dependencies:
      node-fetch: 2.6.12
    transitivePeerDependencies:
      - encoding
    dev: false

  /cross-spawn@5.1.0:
    resolution: {integrity: sha512-pTgQJ5KC0d2hcY8eyL1IzlBPYjTkyH72XRZPnLyKus2mBfNjQs3klqbJU2VILqZryAZUt9JOb3h/mWMy23/f5A==}
    dependencies:
      lru-cache: 4.1.5
      shebang-command: 1.2.0
      which: 1.3.1
    dev: true

  /cross-spawn@7.0.3:
    resolution: {integrity: sha512-iRDPJKUPVEND7dHPO8rkbOnPpyDygcDFtWjpeWNCgy8WP2rXcxXL8TskReQl6OrB2G7+UJrags1q15Fudc7G6w==}
    engines: {node: '>= 8'}
    dependencies:
      path-key: 3.1.1
      shebang-command: 2.0.0
      which: 2.0.2

  /csv-generate@3.4.3:
    resolution: {integrity: sha512-w/T+rqR0vwvHqWs/1ZyMDWtHHSJaN06klRqJXBEpDJaM/+dZkso0OKh1VcuuYvK3XM53KysVNq8Ko/epCK8wOw==}
    dev: true

  /csv-parse@4.16.3:
    resolution: {integrity: sha512-cO1I/zmz4w2dcKHVvpCr7JVRu8/FymG5OEpmvsZYlccYolPBLoVGKUHgNoc4ZGkFeFlWGEDmMyBM+TTqRdW/wg==}
    dev: true

  /csv-stringify@5.6.5:
    resolution: {integrity: sha512-PjiQ659aQ+fUTQqSrd1XEDnOr52jh30RBurfzkscaE2tPaFsDH5wOAHJiw8XAHphRknCwMUE9KRayc4K/NbO8A==}
    dev: true

  /csv@5.5.3:
    resolution: {integrity: sha512-QTaY0XjjhTQOdguARF0lGKm5/mEq9PD9/VhZZegHDIBq2tQwgNpHc3dneD4mGo2iJs+fTKv5Bp0fZ+BRuY3Z0g==}
    engines: {node: '>= 0.1.90'}
    dependencies:
      csv-generate: 3.4.3
      csv-parse: 4.16.3
      csv-stringify: 5.6.5
      stream-transform: 2.1.3
    dev: true

  /debug@4.3.4:
    resolution: {integrity: sha512-PRWFHuSU3eDtQJPvnNY7Jcket1j0t5OuOsFzPPzsekD52Zl8qUfFIPEiswXqIvHWGVHOgX+7G/vCNNhehwxfkQ==}
    engines: {node: '>=6.0'}
    peerDependencies:
      supports-color: '*'
    peerDependenciesMeta:
      supports-color:
        optional: true
    dependencies:
      ms: 2.1.2
    dev: true

  /decamelize-keys@1.1.1:
    resolution: {integrity: sha512-WiPxgEirIV0/eIOMcnFBA3/IJZAZqKnwAwWyvvdi4lsr1WCN22nhdf/3db3DoZcUjTV2SqfzIwNyp6y2xs3nmg==}
    engines: {node: '>=0.10.0'}
    dependencies:
      decamelize: 1.2.0
      map-obj: 1.0.1
    dev: true

  /decamelize@1.2.0:
    resolution: {integrity: sha512-z2S+W9X73hAUUki+N+9Za2lBlun89zigOyGrsax+KUQ6wKW4ZoWpEYBkGhQjwAjjDCkWxhY0VKEhk8wzY7F5cA==}
    engines: {node: '>=0.10.0'}
    dev: true

  /deep-eql@4.1.3:
    resolution: {integrity: sha512-WaEtAOpRA1MQ0eohqZjpGD8zdI0Ovsm8mmFhaDN8dvDZzyoUMcYDnf5Y6iu7HTXxf8JDS23qWa4a+hKCDyOPzw==}
    engines: {node: '>=6'}
    dependencies:
      type-detect: 4.0.8
    dev: true

  /deep-freeze-strict@1.1.1:
    resolution: {integrity: sha512-QemROZMM2IvhAcCFvahdX2Vbm4S/txeq5rFYU9fh4mQP79WTMW5c/HkQ2ICl1zuzcDZdPZ6zarDxQeQMsVYoNA==}
    dev: false

  /defaults@1.0.4:
    resolution: {integrity: sha512-eFuaLoy/Rxalv2kr+lqMlUnrDWV+3j4pljOIJgLIhI058IQfWJ7vXhyEIHu+HtC738klGALYxOKDO0bQP3tg8A==}
    dependencies:
      clone: 1.0.4
    dev: true

  /define-properties@1.2.0:
    resolution: {integrity: sha512-xvqAVKGfT1+UAvPwKTVw/njhdQ8ZhXK4lI0bCIuCMrp2up9nPnaDftrLtmpTazqd1o+UY4zgzU+avtMbDP+ldA==}
    engines: {node: '>= 0.4'}
    dependencies:
      has-property-descriptors: 1.0.0
      object-keys: 1.1.1
    dev: true

  /detect-indent@6.1.0:
    resolution: {integrity: sha512-reYkTUJAZb9gUuZ2RvVCNhVHdg62RHnJ7WJl8ftMi4diZ6NWlciOzQN88pUhSELEwflJht4oQDv0F0BMlwaYtA==}
    engines: {node: '>=8'}
    dev: true

  /diff-sequences@29.6.3:
    resolution: {integrity: sha512-EjePK1srD3P08o2j4f0ExnylqRs5B9tJjcp9t1krH2qRi8CCdsYfwe9JgSLurFBWwq4uOlipzfk5fHNvwFKr8Q==}
    engines: {node: ^14.15.0 || ^16.10.0 || >=18.0.0}
    dev: true

  /diff@4.0.2:
    resolution: {integrity: sha512-58lmxKSA4BNyLz+HHMUzlOEpg09FV+ev6ZMe3vJihgdxzgcwZ8VoEEPmALCZG9LmqfVoNMMKpttIYTVG6uDY7A==}
    engines: {node: '>=0.3.1'}

  /dir-glob@3.0.1:
    resolution: {integrity: sha512-WkrWp9GR4KXfKGYzOLmTuGVi1UWFfws377n9cc55/tb6DuqyF6pcQ5AbiHEshaDpY9v6oaSr2XCDidGmMwdzIA==}
    engines: {node: '>=8'}
    dependencies:
      path-type: 4.0.0
    dev: true

  /eastasianwidth@0.2.0:
    resolution: {integrity: sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==}

  /elliptic@6.5.4:
    resolution: {integrity: sha512-iLhC6ULemrljPZb+QutR5TQGB+pdW6KGD5RSegS+8sorOZT+rdQFbsQFJgvN3eRqNALqJer4oQ16YvJHlU8hzQ==}
    dependencies:
      bn.js: 4.12.0
      brorand: 1.1.0
      hash.js: 1.1.7
      hmac-drbg: 1.0.1
      inherits: 2.0.4
      minimalistic-assert: 1.0.1
      minimalistic-crypto-utils: 1.0.1
    dev: false

  /emoji-regex@8.0.0:
    resolution: {integrity: sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==}

  /emoji-regex@9.2.2:
    resolution: {integrity: sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==}

  /enquirer@2.3.6:
    resolution: {integrity: sha512-yjNnPr315/FjS4zIsUxYguYUPP2e1NK4d7E7ZOLiyYCcbFBiTMyID+2wvm2w6+pZ/odMA7cRkjhsPbltwBOrLg==}
    engines: {node: '>=8.6'}
    dependencies:
      ansi-colors: 4.1.3
    dev: true

  /error-ex@1.3.2:
    resolution: {integrity: sha512-7dFHNmqeFSEt2ZBsCriorKnn3Z2pj+fd9kmI6QoWw4//DL+icEBfc0U7qJCisqrTsKTjw4fNFy2pW9OqStD84g==}
    dependencies:
      is-arrayish: 0.2.1
    dev: true

  /es-abstract@1.21.2:
    resolution: {integrity: sha512-y/B5POM2iBnIxCiernH1G7rC9qQoM77lLIMQLuob0zhp8C56Po81+2Nj0WFKnd0pNReDTnkYryc+zhOzpEIROg==}
    engines: {node: '>= 0.4'}
    dependencies:
      array-buffer-byte-length: 1.0.0
      available-typed-arrays: 1.0.5
      call-bind: 1.0.2
      es-set-tostringtag: 2.0.1
      es-to-primitive: 1.2.1
      function.prototype.name: 1.1.5
      get-intrinsic: 1.2.1
      get-symbol-description: 1.0.0
      globalthis: 1.0.3
      gopd: 1.0.1
      has: 1.0.3
      has-property-descriptors: 1.0.0
      has-proto: 1.0.1
      has-symbols: 1.0.3
      internal-slot: 1.0.5
      is-array-buffer: 3.0.2
      is-callable: 1.2.7
      is-negative-zero: 2.0.2
      is-regex: 1.1.4
      is-shared-array-buffer: 1.0.2
      is-string: 1.0.7
      is-typed-array: 1.1.10
      is-weakref: 1.0.2
      object-inspect: 1.12.3
      object-keys: 1.1.1
      object.assign: 4.1.4
      regexp.prototype.flags: 1.5.0
      safe-regex-test: 1.0.0
      string.prototype.trim: 1.2.7
      string.prototype.trimend: 1.0.6
      string.prototype.trimstart: 1.0.6
      typed-array-length: 1.0.4
      unbox-primitive: 1.0.2
      which-typed-array: 1.1.9
    dev: true

  /es-set-tostringtag@2.0.1:
    resolution: {integrity: sha512-g3OMbtlwY3QewlqAiMLI47KywjWZoEytKr8pf6iTC8uJq5bIAH52Z9pnQ8pVL6whrCto53JZDuUIsifGeLorTg==}
    engines: {node: '>= 0.4'}
    dependencies:
      get-intrinsic: 1.2.1
      has: 1.0.3
      has-tostringtag: 1.0.0
    dev: true

  /es-shim-unscopables@1.0.0:
    resolution: {integrity: sha512-Jm6GPcCdC30eMLbZ2x8z2WuRwAws3zTBBKuusffYVUrNj/GVSUAZ+xKMaUpfNDR5IbyNA5LJbaecoUVbmUcB1w==}
    dependencies:
      has: 1.0.3
    dev: true

  /es-to-primitive@1.2.1:
    resolution: {integrity: sha512-QCOllgZJtaUo9miYBcLChTUaHNjJF3PYs1VidD7AwiEj1kYxKeQTctLAezAOH5ZKRH0g2IgPn6KwB4IT8iRpvA==}
    engines: {node: '>= 0.4'}
    dependencies:
      is-callable: 1.2.7
      is-date-object: 1.0.5
      is-symbol: 1.0.4
    dev: true

  /esbuild@0.19.11:
    resolution: {integrity: sha512-HJ96Hev2hX/6i5cDVwcqiJBBtuo9+FeIJOtZ9W1kA5M6AMJRHUZlpYZ1/SbEwtO0ioNAW8rUooVpC/WehY2SfA==}
    engines: {node: '>=12'}
    hasBin: true
    requiresBuild: true
    optionalDependencies:
      '@esbuild/aix-ppc64': 0.19.11
      '@esbuild/android-arm': 0.19.11
      '@esbuild/android-arm64': 0.19.11
      '@esbuild/android-x64': 0.19.11
      '@esbuild/darwin-arm64': 0.19.11
      '@esbuild/darwin-x64': 0.19.11
      '@esbuild/freebsd-arm64': 0.19.11
      '@esbuild/freebsd-x64': 0.19.11
      '@esbuild/linux-arm': 0.19.11
      '@esbuild/linux-arm64': 0.19.11
      '@esbuild/linux-ia32': 0.19.11
      '@esbuild/linux-loong64': 0.19.11
      '@esbuild/linux-mips64el': 0.19.11
      '@esbuild/linux-ppc64': 0.19.11
      '@esbuild/linux-riscv64': 0.19.11
      '@esbuild/linux-s390x': 0.19.11
      '@esbuild/linux-x64': 0.19.11
      '@esbuild/netbsd-x64': 0.19.11
      '@esbuild/openbsd-x64': 0.19.11
      '@esbuild/sunos-x64': 0.19.11
      '@esbuild/win32-arm64': 0.19.11
      '@esbuild/win32-ia32': 0.19.11
      '@esbuild/win32-x64': 0.19.11
    dev: true

  /escalade@3.1.1:
    resolution: {integrity: sha512-k0er2gUkLf8O0zKJiAhmkTnJlTvINGv7ygDNPbeIsX/TJjGJZHuh9B2UxbsaEkmlEo9MfhrSzmhIlhRlI2GXnw==}
    engines: {node: '>=6'}
    dev: true

  /escape-string-regexp@1.0.5:
    resolution: {integrity: sha512-vbRorB5FUQWvla16U8R/qgaFIya2qGzwDrNmCZuYKrbdSUMG6I1ZCGQRefkRVhuOkIGVne7BQ35DSfo1qvJqFg==}
    engines: {node: '>=0.8.0'}
    dev: true

  /esprima@4.0.1:
    resolution: {integrity: sha512-eGuFFw7Upda+g4p+QHvnW0RyTX/SVeJBDM/gCtMARO0cLuT2HcEKnTPvhjV6aGeqrCB/sbNop0Kszm0jsaWU4A==}
    engines: {node: '>=4'}
    hasBin: true
    dev: true

  /estree-walker@3.0.3:
    resolution: {integrity: sha512-7RUKfXgSMMkzt6ZuXmqapOurLGPPfgj6l9uRZ7lRGolvk0y2yocc35LdcxKC5PQZdn2DMqioAQ2NoWcrTKmm6g==}
    dependencies:
      '@types/estree': 1.0.5
    dev: true

  /event-target-shim@5.0.1:
    resolution: {integrity: sha512-i/2XbnSz/uxRCU6+NdVJgKWDTM427+MqYbkQzD321DuCQJUqOuJKIA0IM2+W2xtYHdKOmZ4dR6fExsd4SXL+WQ==}
    engines: {node: '>=6'}
    dev: false

  /eventemitter3@5.0.1:
    resolution: {integrity: sha512-GWkBvjiSZK87ELrYOSESUYeVIc9mvLLf/nXalMOS5dYrgZq9o5OVkbZAVM06CVxYsCwH9BDZFPlQTlPA1j4ahA==}
    dev: true

  /events@3.3.0:
    resolution: {integrity: sha512-mQw+2fkQbALzQ7V0MY0IqdnXNOeTtP4r0lN9z7AAawCXgqea7bDii20AYrIBrFd/Hx0M2Ocz6S111CaFkUcb0Q==}
    engines: {node: '>=0.8.x'}
    dev: false

  /execa@8.0.1:
    resolution: {integrity: sha512-VyhnebXciFV2DESc+p6B+y0LjSm0krU4OgJN44qFAhBY0TJ+1V61tYD2+wHusZ6F9n5K+vl8k0sTy7PEfV4qpg==}
    engines: {node: '>=16.17'}
    dependencies:
      cross-spawn: 7.0.3
      get-stream: 8.0.1
      human-signals: 5.0.0
      is-stream: 3.0.0
      merge-stream: 2.0.0
      npm-run-path: 5.1.0
      onetime: 6.0.0
      signal-exit: 4.1.0
      strip-final-newline: 3.0.0
    dev: true

  /extendable-error@0.1.7:
    resolution: {integrity: sha512-UOiS2in6/Q0FK0R0q6UY9vYpQ21mr/Qn1KOnte7vsACuNJf514WvCCUHSRCPcgjPT2bAhNIJdlE6bVap1GKmeg==}
    dev: true

  /external-editor@3.1.0:
    resolution: {integrity: sha512-hMQ4CX1p1izmuLYyZqLMO/qGNw10wSv9QDCPfzXfyFrOaCSSoRfqE1Kf1s5an66J5JZC62NewG+mK49jOCtQew==}
    engines: {node: '>=4'}
    dependencies:
      chardet: 0.7.0
      iconv-lite: 0.4.24
      tmp: 0.0.33
    dev: true

  /fast-glob@3.3.0:
    resolution: {integrity: sha512-ChDuvbOypPuNjO8yIDf36x7BlZX1smcUMTTcyoIjycexOxd6DFsKsg21qVBzEmr3G7fUKIRy2/psii+CIUt7FA==}
    engines: {node: '>=8.6.0'}
    dependencies:
      '@nodelib/fs.stat': 2.0.5
      '@nodelib/fs.walk': 1.2.8
      glob-parent: 5.1.2
      merge2: 1.4.1
      micromatch: 4.0.5
    dev: true

  /fastq@1.15.0:
    resolution: {integrity: sha512-wBrocU2LCXXa+lWBt8RoIRD89Fi8OdABODa/kEnyeyjS5aZO5/GNvI5sEINADqP/h8M29UHTHUb53sUu5Ihqdw==}
    dependencies:
      reusify: 1.0.4
    dev: true

  /fill-range@7.0.1:
    resolution: {integrity: sha512-qOo9F+dMUmC2Lcb4BbVvnKJxTPjCm+RRpe4gDuGrzkL7mEVl/djYSu2OdQ2Pa302N4oqkSg9ir6jaLWJ2USVpQ==}
    engines: {node: '>=8'}
    dependencies:
      to-regex-range: 5.0.1
    dev: true

  /find-up@4.1.0:
    resolution: {integrity: sha512-PpOwAdQ/YlXQ2vj8a3h8IipDuYRi3wceVQQGYWxNINccq40Anw7BlsEXCMbt1Zt+OLA6Fq9suIpIWD0OsnISlw==}
    engines: {node: '>=8'}
    dependencies:
      locate-path: 5.0.0
      path-exists: 4.0.0
    dev: true

  /find-up@5.0.0:
    resolution: {integrity: sha512-78/PXT1wlLLDgTzDs7sjq9hzz0vXD+zn+7wypEe4fXQxCmdmqfGsEPQxmiCSQI3ajFV91bVSsvNtrJRiW6nGng==}
    engines: {node: '>=10'}
    dependencies:
      locate-path: 6.0.0
      path-exists: 4.0.0
    dev: true

  /find-yarn-workspace-root2@1.2.16:
    resolution: {integrity: sha512-hr6hb1w8ePMpPVUK39S4RlwJzi+xPLuVuG8XlwXU3KD5Yn3qgBWVfy3AzNlDhWvE1EORCE65/Qm26rFQt3VLVA==}
    dependencies:
      micromatch: 4.0.5
      pkg-dir: 4.2.0
    dev: true

  /for-each@0.3.3:
    resolution: {integrity: sha512-jqYfLp7mo9vIyQf8ykW2v7A+2N4QjeCeI5+Dz9XraiO1ign81wjiH7Fb9vSOWvQfNtmSa4H2RoQTrrXivdUZmw==}
    dependencies:
      is-callable: 1.2.7
    dev: true

  /foreground-child@3.1.1:
    resolution: {integrity: sha512-TMKDUnIte6bfb5nWv7V/caI169OHgvwjb7V4WkeUvbQQdjr5rWKqHFiKWb/fcOwB+CzBT+qbWjvj+DVwRskpIg==}
    engines: {node: '>=14'}
    dependencies:
      cross-spawn: 7.0.3
      signal-exit: 4.0.2
    dev: false

  /fs-extra@7.0.1:
    resolution: {integrity: sha512-YJDaCJZEnBmcbw13fvdAM9AwNOJwOzrE4pqMqBq5nFiEqXUqHwlK4B+3pUw6JNvfSPtX05xFHtYy/1ni01eGCw==}
    engines: {node: '>=6 <7 || >=8'}
    dependencies:
      graceful-fs: 4.2.11
      jsonfile: 4.0.0
      universalify: 0.1.2
    dev: true

  /fs-extra@8.1.0:
    resolution: {integrity: sha512-yhlQgA6mnOJUKOsRUFsgJdQCvkKhcz8tlZG5HBQfReYZy46OwLcY+Zia0mtdHsOo9y/hP+CxMN0TU9QxoOtG4g==}
    engines: {node: '>=6 <7 || >=8'}
    dependencies:
      graceful-fs: 4.2.11
      jsonfile: 4.0.0
      universalify: 0.1.2
    dev: true

  /fsevents@2.3.3:
    resolution: {integrity: sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==}
    engines: {node: ^8.16.0 || ^10.6.0 || >=11.0.0}
    os: [darwin]
    requiresBuild: true
    dev: true
    optional: true

  /function-bind@1.1.1:
    resolution: {integrity: sha512-yIovAzMX49sF8Yl58fSCWJ5svSLuaibPxXQJFLmBObTuCr0Mf1KiPopGM9NiFjiYBCbfaa2Fh6breQ6ANVTI0A==}
    dev: true

  /function.prototype.name@1.1.5:
    resolution: {integrity: sha512-uN7m/BzVKQnCUF/iW8jYea67v++2u7m5UgENbHRtdDVclOUP+FMPlCNdmk0h/ysGyo2tavMJEDqJAkJdRa1vMA==}
    engines: {node: '>= 0.4'}
    dependencies:
      call-bind: 1.0.2
      define-properties: 1.2.0
      es-abstract: 1.21.2
      functions-have-names: 1.2.3
    dev: true

  /functions-have-names@1.2.3:
    resolution: {integrity: sha512-xckBUXyTIqT97tq2x2AMb+g163b5JFysYk0x4qxNFwbfQkmNZoiRHb6sPzI9/QV33WeuvVYBUIiD4NzNIyqaRQ==}
    dev: true

  /get-caller-file@2.0.5:
    resolution: {integrity: sha512-DyFP3BM/3YHTQOCUL/w0OZHR0lpKeGrxotcHWcqNEdnltqFwXVfhEBQ94eIo34AfQpo0rGki4cyIiftY06h2Fg==}
    engines: {node: 6.* || 8.* || >= 10.*}
    dev: true

  /get-func-name@2.0.2:
    resolution: {integrity: sha512-8vXOvuE167CtIc3OyItco7N/dpRtBbYOsPsXCz7X/PMnlGjYjSGuZJgM1Y7mmew7BKf9BqvLX2tnOVy1BBUsxQ==}
    dev: true

  /get-intrinsic@1.2.1:
    resolution: {integrity: sha512-2DcsyfABl+gVHEfCOaTrWgyt+tb6MSEGmKq+kI5HwLbIYgjgmMcV8KQ41uaKz1xxUcn9tJtgFbQUEVcEbd0FYw==}
    dependencies:
      function-bind: 1.1.1
      has: 1.0.3
      has-proto: 1.0.1
      has-symbols: 1.0.3
    dev: true

  /get-stream@8.0.1:
    resolution: {integrity: sha512-VaUJspBffn/LMCJVoMvSAdmscJyS1auj5Zulnn5UoYcY531UWmdwhRWkcGKnGU93m5HSXP9LP2usOryrBtQowA==}
    engines: {node: '>=16'}
    dev: true

  /get-symbol-description@1.0.0:
    resolution: {integrity: sha512-2EmdH1YvIQiZpltCNgkuiUnyukzxM/R6NDJX31Ke3BG1Nq5b0S2PhX59UKi9vZpPDQVdqn+1IcaAwnzTT5vCjw==}
    engines: {node: '>= 0.4'}
    dependencies:
      call-bind: 1.0.2
      get-intrinsic: 1.2.1
    dev: true

  /glob-parent@5.1.2:
    resolution: {integrity: sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==}
    engines: {node: '>= 6'}
    dependencies:
      is-glob: 4.0.3
    dev: true

  /glob@10.3.3:
    resolution: {integrity: sha512-92vPiMb/iqpmEgsOoIDvTjc50wf9CCCvMzsi6W0JLPeUKE8TWP1a73PgqSrqy7iAZxaSD1YdzU7QZR5LF51MJw==}
    engines: {node: '>=16 || 14 >=14.17'}
    hasBin: true
    dependencies:
      foreground-child: 3.1.1
      jackspeak: 2.2.1
      minimatch: 9.0.3
      minipass: 7.0.1
      path-scurry: 1.10.1
    dev: false

  /globalthis@1.0.3:
    resolution: {integrity: sha512-sFdI5LyBiNTHjRd7cGPWapiHWMOXKyuBNX/cWJ3NfzrZQVa8GI/8cofCl74AOVqq9W5kNmguTIzJ/1s2gyI9wA==}
    engines: {node: '>= 0.4'}
    dependencies:
      define-properties: 1.2.0
    dev: true

  /globby@11.1.0:
    resolution: {integrity: sha512-jhIXaOzy1sb8IyocaruWSn1TjmnBVs8Ayhcy83rmxNJ8q2uWKCAj3CnJY+KpGSXCueAPc0i05kVvVKtP1t9S3g==}
    engines: {node: '>=10'}
    dependencies:
      array-union: 2.1.0
      dir-glob: 3.0.1
      fast-glob: 3.3.0
      ignore: 5.2.4
      merge2: 1.4.1
      slash: 3.0.0
    dev: true

  /gopd@1.0.1:
    resolution: {integrity: sha512-d65bNlIadxvpb/A2abVdlqKqV563juRnZ1Wtk6s1sIR8uNsXR70xqIzVqxVf1eTqDunwT2MkczEeaezCKTZhwA==}
    dependencies:
      get-intrinsic: 1.2.1
    dev: true

  /graceful-fs@4.2.11:
    resolution: {integrity: sha512-RbJ5/jmFcNNCcDV5o9eTnBLJ/HszWV0P73bc+Ff4nS/rJj+YaS6IGyiOL0VoBYX+l1Wrl3k63h/KrH+nhJ0XvQ==}
    dev: true

  /grapheme-splitter@1.0.4:
    resolution: {integrity: sha512-bzh50DW9kTPM00T8y4o8vQg89Di9oLJVLW/KaOGIXJWP/iqCN6WKYkbNOF04vFLJhwcpYUh9ydh/+5vpOqV4YQ==}
    dev: true

  /hard-rejection@2.1.0:
    resolution: {integrity: sha512-VIZB+ibDhx7ObhAe7OVtoEbuP4h/MuOTHJ+J8h/eBXotJYl0fBgR72xDFCKgIh22OJZIOVNxBMWuhAr10r8HdA==}
    engines: {node: '>=6'}
    dev: true

  /has-bigints@1.0.2:
    resolution: {integrity: sha512-tSvCKtBr9lkF0Ex0aQiP9N+OpV4zi2r/Nee5VkRDbaqv35RLYMzbwQfFSZZH0kR+Rd6302UJZ2p/bJCEoR3VoQ==}
    dev: true

  /has-flag@3.0.0:
    resolution: {integrity: sha512-sKJf1+ceQBr4SMkvQnBDNDtf4TXpVhVGateu0t918bl30FnbE2m4vNLX+VWe/dpjlb+HugGYzW7uQXH98HPEYw==}
    engines: {node: '>=4'}
    dev: true

  /has-flag@4.0.0:
    resolution: {integrity: sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==}
    engines: {node: '>=8'}
    dev: true

  /has-property-descriptors@1.0.0:
    resolution: {integrity: sha512-62DVLZGoiEBDHQyqG4w9xCuZ7eJEwNmJRWw2VY84Oedb7WFcA27fiEVe8oUQx9hAUJ4ekurquucTGwsyO1XGdQ==}
    dependencies:
      get-intrinsic: 1.2.1
    dev: true

  /has-proto@1.0.1:
    resolution: {integrity: sha512-7qE+iP+O+bgF9clE5+UoBFzE65mlBiVj3tKCrlNQ0Ogwm0BjpT/gK4SlLYDMybDh5I3TCTKnPPa0oMG7JDYrhg==}
    engines: {node: '>= 0.4'}
    dev: true

  /has-symbols@1.0.3:
    resolution: {integrity: sha512-l3LCuF6MgDNwTDKkdYGEihYjt5pRPbEg46rtlmnSPlUbgmB8LOIrKJbYYFBSbnPaJexMKtiPO8hmeRjRz2Td+A==}
    engines: {node: '>= 0.4'}
    dev: true

  /has-tostringtag@1.0.0:
    resolution: {integrity: sha512-kFjcSNhnlGV1kyoGk7OXKSawH5JOb/LzUc5w9B02hOTO0dfFRjbHQKvg1d6cf3HbeUmtU9VbbV3qzZ2Teh97WQ==}
    engines: {node: '>= 0.4'}
    dependencies:
      has-symbols: 1.0.3
    dev: true

  /has@1.0.3:
    resolution: {integrity: sha512-f2dvO0VU6Oej7RkWJGrehjbzMAjFp5/VKPp5tTpWIV4JHHZK1/BxbFRtf/siA2SWTe09caDmVtYYzWEIbBS4zw==}
    engines: {node: '>= 0.4.0'}
    dependencies:
      function-bind: 1.1.1
    dev: true

  /hash.js@1.1.7:
    resolution: {integrity: sha512-taOaskGt4z4SOANNseOviYDvjEJinIkRgmp7LbKP2YTTmVxWBl87s/uzK9r+44BclBSp2X7K1hqeNfz9JbBeXA==}
    dependencies:
      inherits: 2.0.4
      minimalistic-assert: 1.0.1
    dev: false

  /hmac-drbg@1.0.1:
    resolution: {integrity: sha512-Tti3gMqLdZfhOQY1Mzf/AanLiqh1WTiJgEj26ZuYQ9fbkLomzGchCws4FyrSd4VkpBfiNhaE1On+lOz894jvXg==}
    dependencies:
      hash.js: 1.1.7
      minimalistic-assert: 1.0.1
      minimalistic-crypto-utils: 1.0.1
    dev: false

  /hosted-git-info@2.8.9:
    resolution: {integrity: sha512-mxIDAb9Lsm6DoOJ7xH+5+X4y1LU/4Hi50L9C5sIswK3JzULS4bwk1FvjdBgvYR4bzT4tuUQiC15FE2f5HbLvYw==}
    dev: true

  /human-id@1.0.2:
    resolution: {integrity: sha512-UNopramDEhHJD+VR+ehk8rOslwSfByxPIZyJRfV739NDhN5LF1fa1MqnzKm2lGTQRjNrjK19Q5fhkgIfjlVUKw==}
    dev: true

  /human-signals@5.0.0:
    resolution: {integrity: sha512-AXcZb6vzzrFAUE61HnN4mpLqd/cSIwNQjtNWR0euPm6y0iqx3G4gOXaIDdtdDwZmhwe82LA6+zinmW4UBWVePQ==}
    engines: {node: '>=16.17.0'}
    dev: true

  /husky@8.0.0:
    resolution: {integrity: sha512-4qbE/5dzNDNxFEkX9MNRPKl5+omTXQzdILCUWiqG/lWIAioiM5vln265/l6I2Zx8gpW8l1ukZwGQeCFbBZ6+6w==}
    engines: {node: '>=14'}
    hasBin: true
    dev: true

  /iconv-lite@0.4.24:
    resolution: {integrity: sha512-v3MXnZAcvnywkTUEZomIActle7RXXeedOR31wwl7VlyoXO4Qi9arvSenNQWne1TcRwhCL1HwLI21bEqdpj8/rA==}
    engines: {node: '>=0.10.0'}
    dependencies:
      safer-buffer: 2.1.2
    dev: true

  /ignore@5.2.4:
    resolution: {integrity: sha512-MAb38BcSbH0eHNBxn7ql2NH/kX33OkB3lZ1BNdh7ENeRChHTYsTvWrMubiIAMNS2llXEEgZ1MUOBtXChP3kaFQ==}
    engines: {node: '>= 4'}
    dev: true

  /immutable@4.3.0:
    resolution: {integrity: sha512-0AOCmOip+xgJwEVTQj1EfiDDOkPmuyllDuTuEX+DDXUgapLAsBIfkg3sxCYyCEA8mQqZrrxPUGjcOQ2JS3WLkg==}
    dev: false

  /indent-string@4.0.0:
    resolution: {integrity: sha512-EdDDZu4A2OyIK7Lr/2zG+w5jmbuk1DVBnEwREQvBzspBJkCEbRa8GxU1lghYcaGJCnRWibjDXlq779X1/y5xwg==}
    engines: {node: '>=8'}
    dev: true

  /inherits@2.0.4:
    resolution: {integrity: sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==}
    dev: false

  /internal-slot@1.0.5:
    resolution: {integrity: sha512-Y+R5hJrzs52QCG2laLn4udYVnxsfny9CpOhNhUvk/SSSVyF6T27FzRbF0sroPidSu3X8oEAkOn2K804mjpt6UQ==}
    engines: {node: '>= 0.4'}
    dependencies:
      get-intrinsic: 1.2.1
      has: 1.0.3
      side-channel: 1.0.4
    dev: true

  /is-array-buffer@3.0.2:
    resolution: {integrity: sha512-y+FyyR/w8vfIRq4eQcM1EYgSTnmHXPqaF+IgzgraytCFq5Xh8lllDVmAZolPJiZttZLeFSINPYMaEJ7/vWUa1w==}
    dependencies:
      call-bind: 1.0.2
      get-intrinsic: 1.2.1
      is-typed-array: 1.1.10
    dev: true

  /is-arrayish@0.2.1:
    resolution: {integrity: sha512-zz06S8t0ozoDXMG+ube26zeCTNXcKIPJZJi8hBrF4idCLms4CG9QtK7qBl1boi5ODzFpjswb5JPmHCbMpjaYzg==}
    dev: true

  /is-bigint@1.0.4:
    resolution: {integrity: sha512-zB9CruMamjym81i2JZ3UMn54PKGsQzsJeo6xvN3HJJ4CAsQNB6iRutp2To77OfCNuoxspsIhzaPoO1zyCEhFOg==}
    dependencies:
      has-bigints: 1.0.2
    dev: true

  /is-boolean-object@1.1.2:
    resolution: {integrity: sha512-gDYaKHJmnj4aWxyj6YHyXVpdQawtVLHU5cb+eztPGczf6cjuTdwve5ZIEfgXqH4e57An1D1AKf8CZ3kYrQRqYA==}
    engines: {node: '>= 0.4'}
    dependencies:
      call-bind: 1.0.2
      has-tostringtag: 1.0.0
    dev: true

  /is-callable@1.2.7:
    resolution: {integrity: sha512-1BC0BVFhS/p0qtw6enp8e+8OD0UrK0oFLztSjNzhcKA3WDuJxxAPXzPuPtKkjEY9UUoEWlX/8fgKeu2S8i9JTA==}
    engines: {node: '>= 0.4'}
    dev: true

  /is-ci@3.0.1:
    resolution: {integrity: sha512-ZYvCgrefwqoQ6yTyYUbQu64HsITZ3NfKX1lzaEYdkTDcfKzzCI/wthRRYKkdjHKFVgNiXKAKm65Zo1pk2as/QQ==}
    hasBin: true
    dependencies:
      ci-info: 3.8.0
    dev: true

  /is-core-module@2.12.1:
    resolution: {integrity: sha512-Q4ZuBAe2FUsKtyQJoQHlvP8OvBERxO3jEmy1I7hcRXcJBGGHFh/aJBswbXuS9sgrDH2QUO8ilkwNPHvHMd8clg==}
    dependencies:
      has: 1.0.3
    dev: true

  /is-date-object@1.0.5:
    resolution: {integrity: sha512-9YQaSxsAiSwcvS33MBk3wTCVnWK+HhF8VZR2jRxehM16QcVOdHqPn4VPHmRK4lSr38n9JriurInLcP90xsYNfQ==}
    engines: {node: '>= 0.4'}
    dependencies:
      has-tostringtag: 1.0.0
    dev: true

  /is-extglob@2.1.1:
    resolution: {integrity: sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==}
    engines: {node: '>=0.10.0'}
    dev: true

  /is-fullwidth-code-point@3.0.0:
    resolution: {integrity: sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==}
    engines: {node: '>=8'}

  /is-fullwidth-code-point@4.0.0:
    resolution: {integrity: sha512-O4L094N2/dZ7xqVdrXhh9r1KODPJpFms8B5sGdJLPy664AgvXsreZUyCQQNItZRDlYug4xStLjNp/sz3HvBowQ==}
    engines: {node: '>=12'}
    dev: true

  /is-glob@4.0.3:
    resolution: {integrity: sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==}
    engines: {node: '>=0.10.0'}
    dependencies:
      is-extglob: 2.1.1
    dev: true

  /is-negative-zero@2.0.2:
    resolution: {integrity: sha512-dqJvarLawXsFbNDeJW7zAz8ItJ9cd28YufuuFzh0G8pNHjJMnY08Dv7sYX2uF5UpQOwieAeOExEYAWWfu7ZZUA==}
    engines: {node: '>= 0.4'}
    dev: true

  /is-number-object@1.0.7:
    resolution: {integrity: sha512-k1U0IRzLMo7ZlYIfzRu23Oh6MiIFasgpb9X76eqfFZAqwH44UI4KTBvBYIZ1dSL9ZzChTB9ShHfLkR4pdW5krQ==}
    engines: {node: '>= 0.4'}
    dependencies:
      has-tostringtag: 1.0.0
    dev: true

  /is-number@7.0.0:
    resolution: {integrity: sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==}
    engines: {node: '>=0.12.0'}
    dev: true

  /is-plain-obj@1.1.0:
    resolution: {integrity: sha512-yvkRyxmFKEOQ4pNXCmJG5AEQNlXJS5LaONXo5/cLdTZdWvsZ1ioJEonLGAosKlMWE8lwUy/bJzMjcw8az73+Fg==}
    engines: {node: '>=0.10.0'}
    dev: true

  /is-regex@1.1.4:
    resolution: {integrity: sha512-kvRdxDsxZjhzUX07ZnLydzS1TU/TJlTUHHY4YLL87e37oUA49DfkLqgy+VjFocowy29cKvcSiu+kIv728jTTVg==}
    engines: {node: '>= 0.4'}
    dependencies:
      call-bind: 1.0.2
      has-tostringtag: 1.0.0
    dev: true

  /is-shared-array-buffer@1.0.2:
    resolution: {integrity: sha512-sqN2UDu1/0y6uvXyStCOzyhAjCSlHceFoMKJW8W9EU9cvic/QdsZ0kEU93HEy3IUEFZIiH/3w+AH/UQbPHNdhA==}
    dependencies:
      call-bind: 1.0.2
    dev: true

  /is-stream@3.0.0:
    resolution: {integrity: sha512-LnQR4bZ9IADDRSkvpqMGvt/tEJWclzklNgSw48V5EAaAeDd6qGvN8ei6k5p0tvxSR171VmGyHuTiAOfxAbr8kA==}
    engines: {node: ^12.20.0 || ^14.13.1 || >=16.0.0}
    dev: true

  /is-string@1.0.7:
    resolution: {integrity: sha512-tE2UXzivje6ofPW7l23cjDOMa09gb7xlAqG6jG5ej6uPV32TlWP3NKPigtaGeHNu9fohccRYvIiZMfOOnOYUtg==}
    engines: {node: '>= 0.4'}
    dependencies:
      has-tostringtag: 1.0.0
    dev: true

  /is-subdir@1.2.0:
    resolution: {integrity: sha512-2AT6j+gXe/1ueqbW6fLZJiIw3F8iXGJtt0yDrZaBhAZEG1raiTxKWU+IPqMCzQAXOUCKdA4UDMgacKH25XG2Cw==}
    engines: {node: '>=4'}
    dependencies:
      better-path-resolve: 1.0.0
    dev: true

  /is-symbol@1.0.4:
    resolution: {integrity: sha512-C/CPBqKWnvdcxqIARxyOh4v1UUEOCHpgDa0WYgpKDFMszcrPcffg5uhwSgPCLD2WWxmq6isisz87tzT01tuGhg==}
    engines: {node: '>= 0.4'}
    dependencies:
      has-symbols: 1.0.3
    dev: true

  /is-typed-array@1.1.10:
    resolution: {integrity: sha512-PJqgEHiWZvMpaFZ3uTc8kHPM4+4ADTlDniuQL7cU/UDA0Ql7F70yGfHph3cLNe+c9toaigv+DFzTJKhc2CtO6A==}
    engines: {node: '>= 0.4'}
    dependencies:
      available-typed-arrays: 1.0.5
      call-bind: 1.0.2
      for-each: 0.3.3
      gopd: 1.0.1
      has-tostringtag: 1.0.0
    dev: true

  /is-weakref@1.0.2:
    resolution: {integrity: sha512-qctsuLZmIQ0+vSSMfoVvyFe2+GSEvnmZ2ezTup1SBse9+twCCeial6EEi3Nc2KFcf6+qz2FBPnjXsk8xhKSaPQ==}
    dependencies:
      call-bind: 1.0.2
    dev: true

  /is-windows@1.0.2:
    resolution: {integrity: sha512-eXK1UInq2bPmjyX6e3VHIzMLobc4J94i4AWn+Hpq3OU5KkrRC96OAcR3PRJ/pGu6m8TRnBHP9dkXQVsT/COVIA==}
    engines: {node: '>=0.10.0'}
    dev: true

  /isexe@2.0.0:
    resolution: {integrity: sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==}

  /jackspeak@2.2.1:
    resolution: {integrity: sha512-MXbxovZ/Pm42f6cDIDkl3xpwv1AGwObKwfmjs2nQePiy85tP3fatofl3FC1aBsOtP/6fq5SbtgHwWcMsLP+bDw==}
    engines: {node: '>=14'}
    dependencies:
      '@isaacs/cliui': 8.0.2
    optionalDependencies:
      '@pkgjs/parseargs': 0.11.0
    dev: false

  /js-tokens@4.0.0:
    resolution: {integrity: sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==}
    dev: true

  /js-tokens@8.0.3:
    resolution: {integrity: sha512-UfJMcSJc+SEXEl9lH/VLHSZbThQyLpw1vLO1Lb+j4RWDvG3N2f7yj3PVQA3cmkTBNldJ9eFnM+xEXxHIXrYiJw==}
    dev: true

  /js-xxhash@1.0.4:
    resolution: {integrity: sha512-S/6Oo7ruxx5k8m4qlMnbpwQdJjRsvvfcIhIk1dA9c5y5GNhYHKYKu9krEK3QgBax6CxJuf4gRL2opgLkdzWIKg==}
    engines: {node: '>=8.0.0'}
    dev: false

  /js-yaml@3.14.1:
    resolution: {integrity: sha512-okMH7OXXJ7YrN9Ok3/SXrnu4iX9yOk+25nqX4imS2npuvTYDmo/QEZoqwZkYaIDk3jVvBOTOIEgEhaLOynBS9g==}
    hasBin: true
    dependencies:
      argparse: 1.0.10
      esprima: 4.0.1
    dev: true

  /jsbi@4.3.0:
    resolution: {integrity: sha512-SnZNcinB4RIcnEyZqFPdGPVgrg2AcnykiBy0sHVJQKHYeaLUvi3Exj+iaPpLnFVkDPZIV4U0yvgC9/R4uEAZ9g==}
    dev: false

  /json-parse-even-better-errors@2.3.1:
    resolution: {integrity: sha512-xyFwyhro/JEof6Ghe2iz2NcXoj2sloNsWr/XsERDK/oiPCfaNhl5ONfp+jQdAZRQQ0IJWNzH9zIZF7li91kh2w==}
    dev: true

  /jsonc-parser@3.2.0:
    resolution: {integrity: sha512-gfFQZrcTc8CnKXp6Y4/CBT3fTc0OVuDofpre4aEeEpSBPV5X5v4+Vmx+8snU7RLPrNHPKSgLxGo9YuQzz20o+w==}
    dev: true

  /jsonfile@4.0.0:
    resolution: {integrity: sha512-m6F1R3z8jjlf2imQHS2Qez5sjKWQzbuuhuJ/FKYFRZvPE3PuHcSMVZzfsLhGVOkfd20obL5SWEBew5ShlquNxg==}
    optionalDependencies:
      graceful-fs: 4.2.11
    dev: true

  /kind-of@6.0.3:
    resolution: {integrity: sha512-dcS1ul+9tmeD95T+x28/ehLgd9mENa3LsvDTtzm3vyBEO7RPptvAD+t44WVXaUjTBRcrpFeFlC8WCruUR456hw==}
    engines: {node: '>=0.10.0'}
    dev: true

  /kleur@4.1.5:
    resolution: {integrity: sha512-o+NO+8WrRiQEE4/7nwRJhN1HWpVmJm511pBHUxPLtp0BUISzlBplORYSmTclCnJvQq2tKu/sgl3xVpkc7ZWuQQ==}
    engines: {node: '>=6'}
    dev: true

  /lilconfig@2.1.0:
    resolution: {integrity: sha512-utWOt/GHzuUxnLKxB6dk81RoOeoNeHgbrXiuGk4yyF5qlRz+iIVWu56E2fqGHFrXz0QNUhLB/8nKqvRH66JKGQ==}
    engines: {node: '>=10'}
    dev: true

  /lines-and-columns@1.2.4:
    resolution: {integrity: sha512-7ylylesZQ/PV29jhEDl3Ufjo6ZX7gCqJr5F7PKrqc93v7fzSymt1BpwEU8nAUXs8qzzvqhbjhK5QZg6Mt/HkBg==}
    dev: true

  /lint-staged@15.1.0:
    resolution: {integrity: sha512-ZPKXWHVlL7uwVpy8OZ7YQjYDAuO5X4kMh0XgZvPNxLcCCngd0PO5jKQyy3+s4TL2EnHoIXIzP1422f/l3nZKMw==}
    engines: {node: '>=18.12.0'}
    hasBin: true
    dependencies:
      chalk: 5.3.0
      commander: 11.1.0
      debug: 4.3.4
      execa: 8.0.1
      lilconfig: 2.1.0
      listr2: 7.0.2
      micromatch: 4.0.5
      pidtree: 0.6.0
      string-argv: 0.3.2
      yaml: 2.3.4
    transitivePeerDependencies:
      - supports-color
    dev: true

  /listr2@7.0.2:
    resolution: {integrity: sha512-rJysbR9GKIalhTbVL2tYbF2hVyDnrf7pFUZBwjPaMIdadYHmeT+EVi/Bu3qd7ETQPahTotg2WRCatXwRBW554g==}
    engines: {node: '>=16.0.0'}
    dependencies:
      cli-truncate: 3.1.0
      colorette: 2.0.20
      eventemitter3: 5.0.1
      log-update: 5.0.1
      rfdc: 1.3.0
      wrap-ansi: 8.1.0
    dev: true

  /load-yaml-file@0.2.0:
    resolution: {integrity: sha512-OfCBkGEw4nN6JLtgRidPX6QxjBQGQf72q3si2uvqyFEMbycSFFHwAZeXx6cJgFM9wmLrf9zBwCP3Ivqa+LLZPw==}
    engines: {node: '>=6'}
    dependencies:
      graceful-fs: 4.2.11
      js-yaml: 3.14.1
      pify: 4.0.1
      strip-bom: 3.0.0
    dev: true

  /local-pkg@0.5.0:
    resolution: {integrity: sha512-ok6z3qlYyCDS4ZEU27HaU6x/xZa9Whf8jD4ptH5UZTQYZVYeb9bnZ3ojVhiJNLiXK1Hfc0GNbLXcmZ5plLDDBg==}
    engines: {node: '>=14'}
    dependencies:
      mlly: 1.4.2
      pkg-types: 1.0.3
    dev: true

  /locate-path@5.0.0:
    resolution: {integrity: sha512-t7hw9pI+WvuwNJXwk5zVHpyhIqzg2qTlklJOf0mVxGSbe3Fp2VieZcduNYjaLDoy6p9uGpQEGWG87WpMKlNq8g==}
    engines: {node: '>=8'}
    dependencies:
      p-locate: 4.1.0
    dev: true

  /locate-path@6.0.0:
    resolution: {integrity: sha512-iPZK6eYjbxRu3uB4/WZ3EsEIMJFMqAoopl3R+zuq0UjcAm/MO6KCweDgPfP3elTztoKP3KtnVHxTn2NHBSDVUw==}
    engines: {node: '>=10'}
    dependencies:
      p-locate: 5.0.0
    dev: true

  /lodash.startcase@4.4.0:
    resolution: {integrity: sha512-+WKqsK294HMSc2jEbNgpHpd0JfIBhp7rEV4aqXWqFr6AlXov+SlcgB1Fv01y2kGe3Gc8nMW7VA0SrGuSkRfIEg==}
    dev: true

  /lodash@4.17.21:
    resolution: {integrity: sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==}
    dev: false

  /log-update@5.0.1:
    resolution: {integrity: sha512-5UtUDQ/6edw4ofyljDNcOVJQ4c7OjDro4h3y8e1GQL5iYElYclVHJ3zeWchylvMaKnDbDilC8irOVyexnA/Slw==}
    engines: {node: ^12.20.0 || ^14.13.1 || >=16.0.0}
    dependencies:
      ansi-escapes: 5.0.0
      cli-cursor: 4.0.0
      slice-ansi: 5.0.0
      strip-ansi: 7.1.0
      wrap-ansi: 8.1.0
    dev: true

  /loupe@2.3.7:
    resolution: {integrity: sha512-zSMINGVYkdpYSOBmLi0D1Uo7JU9nVdQKrHxC8eYlV+9YKK9WePqAlL7lSlorG/U2Fw1w0hTBmaa/jrQ3UbPHtA==}
    dependencies:
      get-func-name: 2.0.2
    dev: true

  /lru-cache@10.0.0:
    resolution: {integrity: sha512-svTf/fzsKHffP42sujkO/Rjs37BCIsQVRCeNYIm9WN8rgT7ffoUnRtZCqU+6BqcSBdv8gwJeTz8knJpgACeQMw==}
    engines: {node: 14 || >=16.14}
    dev: false

  /lru-cache@4.1.5:
    resolution: {integrity: sha512-sWZlbEP2OsHNkXrMl5GYk/jKk70MBng6UU4YI/qGDYbgf6YbP4EvmqISbXCoJiRKs+1bSpFHVgQxvJ17F2li5g==}
    dependencies:
      pseudomap: 1.0.2
      yallist: 2.1.2
    dev: true

  /lru-cache@6.0.0:
    resolution: {integrity: sha512-Jo6dJ04CmSjuznwJSS3pUeWmd/H0ffTlkXXgwZi+eq1UCmqQwCh+eLsYOYCwY991i2Fah4h1BEMCx4qThGbsiA==}
    engines: {node: '>=10'}
    dependencies:
      yallist: 4.0.0
    dev: true

  /magic-string@0.30.5:
    resolution: {integrity: sha512-7xlpfBaQaP/T6Vh8MO/EqXSW5En6INHEvEXQiuff7Gku0PWjU3uf6w/j9o7O+SpB5fOAkrI5HeoNgwjEO0pFsA==}
    engines: {node: '>=12'}
    dependencies:
      '@jridgewell/sourcemap-codec': 1.4.15
    dev: true

  /make-error@1.3.6:
    resolution: {integrity: sha512-s8UhlNe7vPKomQhC1qFelMokr/Sc3AgNbso3n74mVPA5LTZwkB9NlXf4XPamLxJE8h0gh73rM94xvwRT2CVInw==}

  /map-obj@1.0.1:
    resolution: {integrity: sha512-7N/q3lyZ+LVCp7PzuxrJr4KMbBE2hW7BT7YNia330OFxIf4d3r5zVpicP2650l7CPN6RM9zOJRl3NGpqSiw3Eg==}
    engines: {node: '>=0.10.0'}
    dev: true

  /map-obj@4.3.0:
    resolution: {integrity: sha512-hdN1wVrZbb29eBGiGjJbeP8JbKjq1urkHJ/LIP/NY48MZ1QVXUsQBV1G1zvYFHn1XE06cwjBsOI2K3Ulnj1YXQ==}
    engines: {node: '>=8'}
    dev: true

  /meow@6.1.1:
    resolution: {integrity: sha512-3YffViIt2QWgTy6Pale5QpopX/IvU3LPL03jOTqp6pGj3VjesdO/U8CuHMKpnQr4shCNCM5fd5XFFvIIl6JBHg==}
    engines: {node: '>=8'}
    dependencies:
      '@types/minimist': 1.2.2
      camelcase-keys: 6.2.2
      decamelize-keys: 1.1.1
      hard-rejection: 2.1.0
      minimist-options: 4.1.0
      normalize-package-data: 2.5.0
      read-pkg-up: 7.0.1
      redent: 3.0.0
      trim-newlines: 3.0.1
      type-fest: 0.13.1
      yargs-parser: 18.1.3
    dev: true

  /merge-stream@2.0.0:
    resolution: {integrity: sha512-abv/qOcuPfk3URPfDzmZU1LKmuw8kT+0nIHvKrKgFrwifol/doWcdA4ZqsWQ8ENrFKkd67Mfpo/LovbIUsbt3w==}
    dev: true

  /merge2@1.4.1:
    resolution: {integrity: sha512-8q7VEgMJW4J8tcfVPy8g09NcQwZdbwFEqhe/WZkoIzjn/3TGDwtOCYtXGxA3O8tPzpczCCDgv+P2P5y00ZJOOg==}
    engines: {node: '>= 8'}
    dev: true

  /micromatch@4.0.5:
    resolution: {integrity: sha512-DMy+ERcEW2q8Z2Po+WNXuw3c5YaUSFjAO5GsJqfEl7UjvtIuFKO6ZrKvcItdy98dwFI2N1tg3zNIdKaQT+aNdA==}
    engines: {node: '>=8.6'}
    dependencies:
      braces: 3.0.2
      picomatch: 2.3.1
    dev: true

  /mimic-fn@2.1.0:
    resolution: {integrity: sha512-OqbOk5oEQeAZ8WXWydlu9HJjz9WVdEIvamMCcXmuqUYjTknH/sqsWvhQ3vgwKFRR1HpjvNBKQ37nbJgYzGqGcg==}
    engines: {node: '>=6'}
    dev: true

  /mimic-fn@4.0.0:
    resolution: {integrity: sha512-vqiC06CuhBTUdZH+RYl8sFrL096vA45Ok5ISO6sE/Mr1jRbGH4Csnhi8f3wKVl7x8mO4Au7Ir9D3Oyv1VYMFJw==}
    engines: {node: '>=12'}
    dev: true

  /min-indent@1.0.1:
    resolution: {integrity: sha512-I9jwMn07Sy/IwOj3zVkVik2JTvgpaykDZEigL6Rx6N9LbMywwUSMtxET+7lVoDLLd3O3IXwJwvuuns8UB/HeAg==}
    engines: {node: '>=4'}
    dev: true

  /minimalistic-assert@1.0.1:
    resolution: {integrity: sha512-UtJcAD4yEaGtjPezWuO9wC4nwUnVH/8/Im3yEHQP4b67cXlD/Qr9hdITCU1xDbSEXg2XKNaP8jsReV7vQd00/A==}
    dev: false

  /minimalistic-crypto-utils@1.0.1:
    resolution: {integrity: sha512-JIYlbt6g8i5jKfJ3xz7rF0LXmv2TkDxBLUkiBeZ7bAx4GnnNMr8xFpGnOxn6GhTEHx3SjRrZEoU+j04prX1ktg==}
    dev: false

  /minimatch@9.0.3:
    resolution: {integrity: sha512-RHiac9mvaRw0x3AYRgDC1CxAP7HTcNrrECeA8YYJeWnpo+2Q5CegtZjaotWTWxDG3UeGA1coE05iH1mPjT/2mg==}
    engines: {node: '>=16 || 14 >=14.17'}
    dependencies:
      brace-expansion: 2.0.1
    dev: false

  /minimist-options@4.1.0:
    resolution: {integrity: sha512-Q4r8ghd80yhO/0j1O3B2BjweX3fiHg9cdOwjJd2J76Q135c+NDxGCqdYKQ1SKBuFfgWbAUzBfvYjPUEeNgqN1A==}
    engines: {node: '>= 6'}
    dependencies:
      arrify: 1.0.1
      is-plain-obj: 1.1.0
      kind-of: 6.0.3
    dev: true

  /minipass@7.0.1:
    resolution: {integrity: sha512-NQ8MCKimInjVlaIqx51RKJJB7mINVkLTJbsZKmto4UAAOC/CWXES8PGaOgoBZyqoUsUA/U3DToGK7GJkkHbjJw==}
    engines: {node: '>=16 || 14 >=14.17'}
    dev: false

  /mixme@0.5.9:
    resolution: {integrity: sha512-VC5fg6ySUscaWUpI4gxCBTQMH2RdUpNrk+MsbpCYtIvf9SBJdiUey4qE7BXviJsJR4nDQxCZ+3yaYNW3guz/Pw==}
    engines: {node: '>= 8.0.0'}
    dev: true

  /mlly@1.4.2:
    resolution: {integrity: sha512-i/Ykufi2t1EZ6NaPLdfnZk2AX8cs0d+mTzVKuPfqPKPatxLApaBoxJQ9x1/uckXtrS/U5oisPMDkNs0yQTaBRg==}
    dependencies:
      acorn: 8.10.0
      pathe: 1.1.1
      pkg-types: 1.0.3
      ufo: 1.3.2
    dev: true

  /ms@2.1.2:
    resolution: {integrity: sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w==}
    dev: true

  /nanoassert@2.0.0:
    resolution: {integrity: sha512-7vO7n28+aYO4J+8w96AzhmU8G+Y/xpPDJz/se19ICsqj/momRbb9mh9ZUtkoJ5X3nTnPdhEJyc0qnM6yAsHBaA==}
    dev: false

  /nanoid@3.3.7:
    resolution: {integrity: sha512-eSRppjcPIatRIMC1U6UngP8XFcz8MQWGQdt1MTBQ7NaAmvXDfvNxbvWV3x2y6CdEUciCSsDHDQZbhYaB8QEo2g==}
    engines: {node: ^10 || ^12 || ^13.7 || ^14 || >=15.0.1}
    hasBin: true
    dev: true

  /node-fetch@2.6.12:
    resolution: {integrity: sha512-C/fGU2E8ToujUivIO0H+tpQ6HWo4eEmchoPIoXtxCrVghxdKq+QOHqEZW7tuP3KlV3bC8FRMO5nMCC7Zm1VP6g==}
    engines: {node: 4.x || >=6.0.0}
    peerDependencies:
      encoding: ^0.1.0
    peerDependenciesMeta:
      encoding:
        optional: true
    dependencies:
      whatwg-url: 5.0.0
    dev: false

  /normalize-package-data@2.5.0:
    resolution: {integrity: sha512-/5CMN3T0R4XTj4DcGaexo+roZSdSFW/0AOOTROrjxzCG1wrWXEsGbRKevjlIL+ZDE4sZlJr5ED4YW0yqmkK+eA==}
    dependencies:
      hosted-git-info: 2.8.9
      resolve: 1.22.2
      semver: 5.7.1
      validate-npm-package-license: 3.0.4
    dev: true

  /npm-run-path@5.1.0:
    resolution: {integrity: sha512-sJOdmRGrY2sjNTRMbSvluQqg+8X7ZK61yvzBEIDhz4f8z1TZFYABsqjjCBd/0PUNE9M6QDgHJXQkGUEm7Q+l9Q==}
    engines: {node: ^12.20.0 || ^14.13.1 || >=16.0.0}
    dependencies:
      path-key: 4.0.0
    dev: true

  /object-inspect@1.12.3:
    resolution: {integrity: sha512-geUvdk7c+eizMNUDkRpW1wJwgfOiOeHbxBR/hLXK1aT6zmVSO0jsQcs7fj6MGw89jC/cjGfLcNOrtMYtGqm81g==}
    dev: true

  /object-keys@1.1.1:
    resolution: {integrity: sha512-NuAESUOUMrlIXOfHKzD6bpPu3tYt3xvjNdRIQ+FeT0lNb4K8WR70CaDxhuNguS2XG+GjkyMwOzsN5ZktImfhLA==}
    engines: {node: '>= 0.4'}
    dev: true

  /object.assign@4.1.4:
    resolution: {integrity: sha512-1mxKf0e58bvyjSCtKYY4sRe9itRk3PJpquJOjeIkz885CczcI4IvJJDLPS72oowuSh+pBxUFROpX+TU++hxhZQ==}
    engines: {node: '>= 0.4'}
    dependencies:
      call-bind: 1.0.2
      define-properties: 1.2.0
      has-symbols: 1.0.3
      object-keys: 1.1.1
    dev: true

  /onetime@5.1.2:
    resolution: {integrity: sha512-kbpaSSGJTWdAY5KPVeMOKXSrPtr8C8C7wodJbcsd51jRnmD+GZu8Y0VoU6Dm5Z4vWr0Ig/1NKuWRKf7j5aaYSg==}
    engines: {node: '>=6'}
    dependencies:
      mimic-fn: 2.1.0
    dev: true

  /onetime@6.0.0:
    resolution: {integrity: sha512-1FlR+gjXK7X+AsAHso35MnyN5KqGwJRi/31ft6x0M194ht7S+rWAvd7PHss9xSKMzE0asv1pyIHaJYq+BbacAQ==}
    engines: {node: '>=12'}
    dependencies:
      mimic-fn: 4.0.0
    dev: true

  /os-tmpdir@1.0.2:
    resolution: {integrity: sha512-D2FR03Vir7FIu45XBY20mTb+/ZSWB00sjU9jdQXt83gDrI4Ztz5Fs7/yy74g2N5SVQY4xY1qDr4rNddwYRVX0g==}
    engines: {node: '>=0.10.0'}
    dev: true

  /outdent@0.5.0:
    resolution: {integrity: sha512-/jHxFIzoMXdqPzTaCpFzAAWhpkSjZPF4Vsn6jAfNpmbH/ymsmd7Qc6VE9BGn0L6YMj6uwpQLxCECpus4ukKS9Q==}
    dev: true

  /p-filter@2.1.0:
    resolution: {integrity: sha512-ZBxxZ5sL2HghephhpGAQdoskxplTwr7ICaehZwLIlfL6acuVgZPm8yBNuRAFBGEqtD/hmUeq9eqLg2ys9Xr/yw==}
    engines: {node: '>=8'}
    dependencies:
      p-map: 2.1.0
    dev: true

  /p-limit@2.3.0:
    resolution: {integrity: sha512-//88mFWSJx8lxCzwdAABTJL2MyWB12+eIY7MDL2SqLmAkeKU9qxRvWuSyTjm3FUmpBEMuFfckAIqEaVGUDxb6w==}
    engines: {node: '>=6'}
    dependencies:
      p-try: 2.2.0
    dev: true

  /p-limit@3.1.0:
    resolution: {integrity: sha512-TYOanM3wGwNGsZN2cVTYPArw454xnXj5qmWF1bEoAc4+cU/ol7GVh7odevjp1FNHduHc3KZMcFduxU5Xc6uJRQ==}
    engines: {node: '>=10'}
    dependencies:
      yocto-queue: 0.1.0
    dev: true

  /p-limit@5.0.0:
    resolution: {integrity: sha512-/Eaoq+QyLSiXQ4lyYV23f14mZRQcXnxfHrN0vCai+ak9G0pp9iEQukIIZq5NccEvwRB8PUnZT0KsOoDCINS1qQ==}
    engines: {node: '>=18'}
    dependencies:
      yocto-queue: 1.0.0
    dev: true

  /p-locate@4.1.0:
    resolution: {integrity: sha512-R79ZZ/0wAxKGu3oYMlz8jy/kbhsNrS7SKZ7PxEHBgJ5+F2mtFW2fK2cOtBh1cHYkQsbzFV7I+EoRKe6Yt0oK7A==}
    engines: {node: '>=8'}
    dependencies:
      p-limit: 2.3.0
    dev: true

  /p-locate@5.0.0:
    resolution: {integrity: sha512-LaNjtRWUBY++zB5nE/NwcaoMylSPk+S+ZHNB1TzdbMJMny6dynpAGt7X/tl/QYq3TIeE6nxHppbo2LGymrG5Pw==}
    engines: {node: '>=10'}
    dependencies:
      p-limit: 3.1.0
    dev: true

  /p-map@2.1.0:
    resolution: {integrity: sha512-y3b8Kpd8OAN444hxfBbFfj1FY/RjtTd8tzYwhUqNYXx0fXx2iX4maP4Qr6qhIKbQXI02wTLAda4fYUbDagTUFw==}
    engines: {node: '>=6'}
    dev: true

  /p-try@2.2.0:
    resolution: {integrity: sha512-R4nPAVTAU0B9D35/Gk3uJf/7XYbQcyohSKdvAxIRSNghFl4e71hVoGnBNQz9cWaXxO2I10KTC+3jMdvvoKw6dQ==}
    engines: {node: '>=6'}
    dev: true

  /parse-json@5.2.0:
    resolution: {integrity: sha512-ayCKvm/phCGxOkYRSCM82iDwct8/EonSEgCSxWxD7ve6jHggsFl4fZVQBPRNgQoKiuV/odhFrGzQXZwbifC8Rg==}
    engines: {node: '>=8'}
    dependencies:
      '@babel/code-frame': 7.22.5
      error-ex: 1.3.2
      json-parse-even-better-errors: 2.3.1
      lines-and-columns: 1.2.4
    dev: true

  /path-exists@4.0.0:
    resolution: {integrity: sha512-ak9Qy5Q7jYb2Wwcey5Fpvg2KoAc/ZIhLSLOSBmRmygPsGwkVVt0fZa0qrtMz+m6tJTAHfZQ8FnmB4MG4LWy7/w==}
    engines: {node: '>=8'}
    dev: true

  /path-key@3.1.1:
    resolution: {integrity: sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==}
    engines: {node: '>=8'}

  /path-key@4.0.0:
    resolution: {integrity: sha512-haREypq7xkM7ErfgIyA0z+Bj4AGKlMSdlQE2jvJo6huWD1EdkKYV+G/T4nq0YEF2vgTT8kqMFKo1uHn950r4SQ==}
    engines: {node: '>=12'}
    dev: true

  /path-parse@1.0.7:
    resolution: {integrity: sha512-LDJzPVEEEPR+y48z93A0Ed0yXb8pAByGWo/k5YYdYgpY2/2EsOsksJrq7lOHxryrVOn1ejG6oAp8ahvOIQD8sw==}
    dev: true

  /path-scurry@1.10.1:
    resolution: {integrity: sha512-MkhCqzzBEpPvxxQ71Md0b1Kk51W01lrYvlMzSUaIzNsODdd7mqhiimSZlr+VegAz5Z6Vzt9Xg2ttE//XBhH3EQ==}
    engines: {node: '>=16 || 14 >=14.17'}
    dependencies:
      lru-cache: 10.0.0
      minipass: 7.0.1
    dev: false

  /path-type@4.0.0:
    resolution: {integrity: sha512-gDKb8aZMDeD/tZWs9P6+q0J9Mwkdl6xMV8TjnGP3qJVJ06bdMgkbBlLU8IdfOsIsFz2BW1rNVT3XuNEl8zPAvw==}
    engines: {node: '>=8'}
    dev: true

  /pathe@1.1.1:
    resolution: {integrity: sha512-d+RQGp0MAYTIaDBIMmOfMwz3E+LOZnxx1HZd5R18mmCZY0QBlK0LDZfPc8FW8Ed2DlvsuE6PRjroDY+wg4+j/Q==}
    dev: true

  /pathval@1.1.1:
    resolution: {integrity: sha512-Dp6zGqpTdETdR63lehJYPeIOqpiNBNtc7BpWSLrOje7UaIsE5aY92r/AunQA7rsXvet3lrJ3JnZX29UPTKXyKQ==}
    dev: true

  /picocolors@1.0.0:
    resolution: {integrity: sha512-1fygroTLlHu66zi26VoTDv8yRgm0Fccecssto+MhsZ0D/DGW2sm8E8AjW7NU5VVTRt5GxbeZ5qBuJr+HyLYkjQ==}
    dev: true

  /picomatch@2.3.1:
    resolution: {integrity: sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==}
    engines: {node: '>=8.6'}
    dev: true

  /pidtree@0.6.0:
    resolution: {integrity: sha512-eG2dWTVw5bzqGRztnHExczNxt5VGsE6OwTeCG3fdUf9KBsZzO3R5OIIIzWR+iZA0NtZ+RDVdaoE2dK1cn6jH4g==}
    engines: {node: '>=0.10'}
    hasBin: true
    dev: true

  /pify@4.0.1:
    resolution: {integrity: sha512-uB80kBFb/tfd68bVleG9T5GGsGPjJrLAUpR5PZIrhBnIaRTQRjqdJSsIKkOP6OAIFbj7GOrcudc5pNjZ+geV2g==}
    engines: {node: '>=6'}
    dev: true

  /pkg-dir@4.2.0:
    resolution: {integrity: sha512-HRDzbaKjC+AOWVXxAU/x54COGeIv9eb+6CkDSQoNTt4XyWoIJvuPsXizxu/Fr23EiekbtZwmh1IcIG/l/a10GQ==}
    engines: {node: '>=8'}
    dependencies:
      find-up: 4.1.0
    dev: true

  /pkg-types@1.0.3:
    resolution: {integrity: sha512-nN7pYi0AQqJnoLPC9eHFQ8AcyaixBUOwvqc5TDnIKCMEE6I0y8P7OKA7fPexsXGCGxQDl/cmrLAp26LhcwxZ4A==}
    dependencies:
      jsonc-parser: 3.2.0
      mlly: 1.4.2
      pathe: 1.1.1
    dev: true

  /postcss@8.4.32:
    resolution: {integrity: sha512-D/kj5JNu6oo2EIy+XL/26JEDTlIbB8hw85G8StOE6L74RQAVVP5rej6wxCNqyMbR4RkPfqvezVbPw81Ngd6Kcw==}
    engines: {node: ^10 || ^12 || >=14}
    dependencies:
      nanoid: 3.3.7
      picocolors: 1.0.0
      source-map-js: 1.0.2
    dev: true

  /preferred-pm@3.0.3:
    resolution: {integrity: sha512-+wZgbxNES/KlJs9q40F/1sfOd/j7f1O9JaHcW5Dsn3aUUOZg3L2bjpVUcKV2jvtElYfoTuQiNeMfQJ4kwUAhCQ==}
    engines: {node: '>=10'}
    dependencies:
      find-up: 5.0.0
      find-yarn-workspace-root2: 1.2.16
      path-exists: 4.0.0
      which-pm: 2.0.0
    dev: true

  /prettier@2.8.7:
    resolution: {integrity: sha512-yPngTo3aXUUmyuTjeTUT75txrf+aMh9FiD7q9ZE/i6r0bPb22g4FsE6Y338PQX1bmfy08i9QQCB7/rcUAVntfw==}
    engines: {node: '>=10.13.0'}
    hasBin: true
    dev: true

  /prettier@3.1.0:
    resolution: {integrity: sha512-TQLvXjq5IAibjh8EpBIkNKxO749UEWABoiIZehEPiY4GNpVdhaFKqSTu+QrlU6D2dPAfubRmtJTi4K4YkQ5eXw==}
    engines: {node: '>=14'}
    hasBin: true
    dev: true

  /pretty-format@29.7.0:
    resolution: {integrity: sha512-Pdlw/oPxN+aXdmM9R00JVC9WVFoCLTKJvDVLgmJ+qAffBMxsV85l/Lu7sNx4zSzPyoL2euImuEwHhOXdEgNFZQ==}
    engines: {node: ^14.15.0 || ^16.10.0 || >=18.0.0}
    dependencies:
      '@jest/schemas': 29.6.3
      ansi-styles: 5.2.0
      react-is: 18.2.0
    dev: true

  /pseudomap@1.0.2:
    resolution: {integrity: sha512-b/YwNhb8lk1Zz2+bXXpS/LK9OisiZZ1SNsSLxN1x2OXVEhW2Ckr/7mWE5vrC1ZTiJlD9g19jWszTmJsB+oEpFQ==}
    dev: true

  /queue-microtask@1.2.3:
    resolution: {integrity: sha512-NuaNSa6flKT5JaSYQzJok04JzTL1CA6aGhv5rfLW3PgqA+M2ChpZQnAC8h8i4ZFkBS8X5RqkDBHA7r4hej3K9A==}
    dev: true

  /quick-lru@4.0.1:
    resolution: {integrity: sha512-ARhCpm70fzdcvNQfPoy49IaanKkTlRWF2JMzqhcJbhSFRZv7nPTvZJdcY7301IPmvW+/p0RgIWnQDLJxifsQ7g==}
    engines: {node: '>=8'}
    dev: true

  /react-is@18.2.0:
    resolution: {integrity: sha512-xWGDIW6x921xtzPkhiULtthJHoJvBbF3q26fzloPCK0hsvxtPVelvftw3zjbHWSkR2km9Z+4uxbDDK/6Zw9B8w==}
    dev: true

  /read-pkg-up@7.0.1:
    resolution: {integrity: sha512-zK0TB7Xd6JpCLmlLmufqykGE+/TlOePD6qKClNW7hHDKFh/J7/7gCWGR7joEQEW1bKq3a3yUZSObOoWLFQ4ohg==}
    engines: {node: '>=8'}
    dependencies:
      find-up: 4.1.0
      read-pkg: 5.2.0
      type-fest: 0.8.1
    dev: true

  /read-pkg@5.2.0:
    resolution: {integrity: sha512-Ug69mNOpfvKDAc2Q8DRpMjjzdtrnv9HcSMX+4VsZxD1aZ6ZzrIE7rlzXBtWTyhULSMKg076AW6WR5iZpD0JiOg==}
    engines: {node: '>=8'}
    dependencies:
      '@types/normalize-package-data': 2.4.1
      normalize-package-data: 2.5.0
      parse-json: 5.2.0
      type-fest: 0.6.0
    dev: true

  /read-yaml-file@1.1.0:
    resolution: {integrity: sha512-VIMnQi/Z4HT2Fxuwg5KrY174U1VdUIASQVWXXyqtNRtxSr9IYkn1rsI6Tb6HsrHCmB7gVpNwX6JxPTHcH6IoTA==}
    engines: {node: '>=6'}
    dependencies:
      graceful-fs: 4.2.11
      js-yaml: 3.14.1
      pify: 4.0.1
      strip-bom: 3.0.0
    dev: true

  /redent@3.0.0:
    resolution: {integrity: sha512-6tDA8g98We0zd0GvVeMT9arEOnTw9qM03L9cJXaCjrip1OO764RDBLBfrB4cwzNGDj5OA5ioymC9GkizgWJDUg==}
    engines: {node: '>=8'}
    dependencies:
      indent-string: 4.0.0
      strip-indent: 3.0.0
    dev: true

  /regenerator-runtime@0.13.11:
    resolution: {integrity: sha512-kY1AZVr2Ra+t+piVaJ4gxaFaReZVH40AKNo7UCX6W+dEwBo/2oZJzqfuN1qLq1oL45o56cPaTXELwrTh8Fpggg==}
    dev: true

  /regexp.prototype.flags@1.5.0:
    resolution: {integrity: sha512-0SutC3pNudRKgquxGoRGIz946MZVHqbNfPjBdxeOhBrdgDKlRoXmYLQN9xRbrR09ZXWeGAdPuif7egofn6v5LA==}
    engines: {node: '>= 0.4'}
    dependencies:
      call-bind: 1.0.2
      define-properties: 1.2.0
      functions-have-names: 1.2.3
    dev: true

  /require-directory@2.1.1:
    resolution: {integrity: sha512-fGxEI7+wsG9xrvdjsrlmL22OMTTiHRwAMroiEeMgq8gzoLC/PQr7RsRDSTLUg/bZAZtF+TVIkHc6/4RIKrui+Q==}
    engines: {node: '>=0.10.0'}
    dev: true

  /require-main-filename@2.0.0:
    resolution: {integrity: sha512-NKN5kMDylKuldxYLSUfrbo5Tuzh4hd+2E8NPPX02mZtn1VuREQToYe/ZdlJy+J3uCpfaiGF05e7B8W0iXbQHmg==}
    dev: true

  /resolve-from@5.0.0:
    resolution: {integrity: sha512-qYg9KP24dD5qka9J47d0aVky0N+b4fTU89LN9iDnjB5waksiC49rvMB0PrUJQGoTmH50XPiqOvAjDfaijGxYZw==}
    engines: {node: '>=8'}
    dev: true

  /resolve@1.22.2:
    resolution: {integrity: sha512-Sb+mjNHOULsBv818T40qSPeRiuWLyaGMa5ewydRLFimneixmVy2zdivRl+AF6jaYPC8ERxGDmFSiqui6SfPd+g==}
    hasBin: true
    dependencies:
      is-core-module: 2.12.1
      path-parse: 1.0.7
      supports-preserve-symlinks-flag: 1.0.0
    dev: true

  /restore-cursor@4.0.0:
    resolution: {integrity: sha512-I9fPXU9geO9bHOt9pHHOhOkYerIMsmVaWB0rA2AI9ERh/+x/i7MV5HKBNrg+ljO5eoPVgCcnFuRjJ9uH6I/3eg==}
    engines: {node: ^12.20.0 || ^14.13.1 || >=16.0.0}
    dependencies:
      onetime: 5.1.2
      signal-exit: 3.0.7
    dev: true

  /reusify@1.0.4:
    resolution: {integrity: sha512-U9nH88a3fc/ekCF1l0/UP1IosiuIjyTh7hBvXVMHYgVcfGvt897Xguj2UOLDeI5BG2m7/uwyaLVT6fbtCwTyzw==}
    engines: {iojs: '>=1.0.0', node: '>=0.10.0'}
    dev: true

  /rfdc@1.3.0:
    resolution: {integrity: sha512-V2hovdzFbOi77/WajaSMXk2OLm+xNIeQdMMuB7icj7bk6zi2F8GGAxigcnDFpJHbNyNcgyJDiP+8nOrY5cZGrA==}
    dev: true

  /rimraf@5.0.0:
    resolution: {integrity: sha512-Jf9llaP+RvaEVS5nPShYFhtXIrb3LRKP281ib3So0KkeZKo2wIKyq0Re7TOSwanasA423PSr6CCIL4bP6T040g==}
    engines: {node: '>=14'}
    hasBin: true
    dependencies:
      glob: 10.3.3
    dev: false

  /rollup@4.9.2:
    resolution: {integrity: sha512-66RB8OtFKUTozmVEh3qyNfH+b+z2RXBVloqO2KCC/pjFaGaHtxP9fVfOQKPSGXg2mElmjmxjW/fZ7iKrEpMH5Q==}
    engines: {node: '>=18.0.0', npm: '>=8.0.0'}
    hasBin: true
    optionalDependencies:
      '@rollup/rollup-android-arm-eabi': 4.9.2
      '@rollup/rollup-android-arm64': 4.9.2
      '@rollup/rollup-darwin-arm64': 4.9.2
      '@rollup/rollup-darwin-x64': 4.9.2
      '@rollup/rollup-linux-arm-gnueabihf': 4.9.2
      '@rollup/rollup-linux-arm64-gnu': 4.9.2
      '@rollup/rollup-linux-arm64-musl': 4.9.2
      '@rollup/rollup-linux-riscv64-gnu': 4.9.2
      '@rollup/rollup-linux-x64-gnu': 4.9.2
      '@rollup/rollup-linux-x64-musl': 4.9.2
      '@rollup/rollup-win32-arm64-msvc': 4.9.2
      '@rollup/rollup-win32-ia32-msvc': 4.9.2
      '@rollup/rollup-win32-x64-msvc': 4.9.2
      fsevents: 2.3.3
    dev: true

  /run-parallel@1.2.0:
    resolution: {integrity: sha512-5l4VyZR86LZ/lDxZTR6jqL8AFE2S0IFLMP26AbjsLVADxHdhB/c0GUsH+y39UfCi3dzz8OlQuPmnaJOMoDHQBA==}
    dependencies:
      queue-microtask: 1.2.3
    dev: true

  /safe-regex-test@1.0.0:
    resolution: {integrity: sha512-JBUUzyOgEwXQY1NuPtvcj/qcBDbDmEvWufhlnXZIm75DEHp+afM1r1ujJpJsV/gSM4t59tpDyPi1sd6ZaPFfsA==}
    dependencies:
      call-bind: 1.0.2
      get-intrinsic: 1.2.1
      is-regex: 1.1.4
    dev: true

  /safer-buffer@2.1.2:
    resolution: {integrity: sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg==}
    dev: true

  /semver@5.7.1:
    resolution: {integrity: sha512-sauaDf/PZdVgrLTNYHRtpXa1iRiKcaebiKQ1BJdpQlWH2lCvexQdX55snPFyK7QzpudqbCI0qXFfOasHdyNDGQ==}
    hasBin: true
    dev: true

  /semver@7.5.4:
    resolution: {integrity: sha512-1bCSESV6Pv+i21Hvpxp3Dx+pSD8lIPt8uVjRrxAUt/nbswYc+tK6Y2btiULjd4+fnq15PX+nqQDC7Oft7WkwcA==}
    engines: {node: '>=10'}
    hasBin: true
    dependencies:
      lru-cache: 6.0.0
    dev: true

  /set-blocking@2.0.0:
    resolution: {integrity: sha512-KiKBS8AnWGEyLzofFfmvKwpdPzqiy16LvQfK3yv/fVH7Bj13/wl3JSR1J+rfgRE9q7xUJK4qvgS8raSOeLUehw==}
    dev: true

  /shebang-command@1.2.0:
    resolution: {integrity: sha512-EV3L1+UQWGor21OmnvojK36mhg+TyIKDh3iFBKBohr5xeXIhNBcx8oWdgkTEEQ+BEFFYdLRuqMfd5L84N1V5Vg==}
    engines: {node: '>=0.10.0'}
    dependencies:
      shebang-regex: 1.0.0
    dev: true

  /shebang-command@2.0.0:
    resolution: {integrity: sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==}
    engines: {node: '>=8'}
    dependencies:
      shebang-regex: 3.0.0

  /shebang-regex@1.0.0:
    resolution: {integrity: sha512-wpoSFAxys6b2a2wHZ1XpDSgD7N9iVjg29Ph9uV/uaP9Ex/KXlkTZTeddxDPSYQpgvzKLGJke2UU0AzoGCjNIvQ==}
    engines: {node: '>=0.10.0'}
    dev: true

  /shebang-regex@3.0.0:
    resolution: {integrity: sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==}
    engines: {node: '>=8'}

  /side-channel@1.0.4:
    resolution: {integrity: sha512-q5XPytqFEIKHkGdiMIrY10mvLRvnQh42/+GoBlFW3b2LXLE2xxJpZFdm94we0BaoV3RwJyGqg5wS7epxTv0Zvw==}
    dependencies:
      call-bind: 1.0.2
      get-intrinsic: 1.2.1
      object-inspect: 1.12.3
    dev: true

  /siginfo@2.0.0:
    resolution: {integrity: sha512-ybx0WO1/8bSBLEWXZvEd7gMW3Sn3JFlW3TvX1nREbDLRNQNaeNN8WK0meBwPdAaOI7TtRRRJn/Es1zhrrCHu7g==}
    dev: true

  /signal-exit@3.0.7:
    resolution: {integrity: sha512-wnD2ZE+l+SPC/uoS0vXeE9L1+0wuaMqKlfz9AMUo38JsyLSBWSFcHR1Rri62LZc12vLr1gb3jl7iwQhgwpAbGQ==}
    dev: true

  /signal-exit@4.0.2:
    resolution: {integrity: sha512-MY2/qGx4enyjprQnFaZsHib3Yadh3IXyV2C321GY0pjGfVBu4un0uDJkwgdxqO+Rdx8JMT8IfJIRwbYVz3Ob3Q==}
    engines: {node: '>=14'}
    dev: false

  /signal-exit@4.1.0:
    resolution: {integrity: sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==}
    engines: {node: '>=14'}
    dev: true

  /slash@3.0.0:
    resolution: {integrity: sha512-g9Q1haeby36OSStwb4ntCGGGaKsaVSjQ68fBxoQcutl5fS1vuY18H3wSt3jFyFtrkx+Kz0V1G85A4MyAdDMi2Q==}
    engines: {node: '>=8'}
    dev: true

  /slice-ansi@5.0.0:
    resolution: {integrity: sha512-FC+lgizVPfie0kkhqUScwRu1O/lF6NOgJmlCgK+/LYxDCTk8sGelYaHDhFcDN+Sn3Cv+3VSa4Byeo+IMCzpMgQ==}
    engines: {node: '>=12'}
    dependencies:
      ansi-styles: 6.2.1
      is-fullwidth-code-point: 4.0.0
    dev: true

  /smartwrap@2.0.2:
    resolution: {integrity: sha512-vCsKNQxb7PnCNd2wY1WClWifAc2lwqsG8OaswpJkVJsvMGcnEntdTCDajZCkk93Ay1U3t/9puJmb525Rg5MZBA==}
    engines: {node: '>=6'}
    hasBin: true
    dependencies:
      array.prototype.flat: 1.3.1
      breakword: 1.0.6
      grapheme-splitter: 1.0.4
      strip-ansi: 6.0.1
      wcwidth: 1.0.1
      yargs: 15.4.1
    dev: true

  /source-map-js@1.0.2:
    resolution: {integrity: sha512-R0XvVJ9WusLiqTCEiGCmICCMplcCkIwwR11mOSD9CR5u+IXYdiseeEuXCVAjS54zqwkLcPNnmU4OeJ6tUrWhDw==}
    engines: {node: '>=0.10.0'}
    dev: true

  /spawndamnit@2.0.0:
    resolution: {integrity: sha512-j4JKEcncSjFlqIwU5L/rp2N5SIPsdxaRsIv678+TZxZ0SRDJTm8JrxJMjE/XuiEZNEir3S8l0Fa3Ke339WI4qA==}
    dependencies:
      cross-spawn: 5.1.0
      signal-exit: 3.0.7
    dev: true

  /spdx-correct@3.2.0:
    resolution: {integrity: sha512-kN9dJbvnySHULIluDHy32WHRUu3Og7B9sbY7tsFLctQkIqnMh3hErYgdMjTYuqmcXX+lK5T1lnUt3G7zNswmZA==}
    dependencies:
      spdx-expression-parse: 3.0.1
      spdx-license-ids: 3.0.13
    dev: true

  /spdx-exceptions@2.3.0:
    resolution: {integrity: sha512-/tTrYOC7PPI1nUAgx34hUpqXuyJG+DTHJTnIULG4rDygi4xu/tfgmq1e1cIRwRzwZgo4NLySi+ricLkZkw4i5A==}
    dev: true

  /spdx-expression-parse@3.0.1:
    resolution: {integrity: sha512-cbqHunsQWnJNE6KhVSMsMeH5H/L9EpymbzqTQ3uLwNCLZ1Q481oWaofqH7nO6V07xlXwY6PhQdQ2IedWx/ZK4Q==}
    dependencies:
      spdx-exceptions: 2.3.0
      spdx-license-ids: 3.0.13
    dev: true

  /spdx-license-ids@3.0.13:
    resolution: {integrity: sha512-XkD+zwiqXHikFZm4AX/7JSCXA98U5Db4AFd5XUg/+9UNtnH75+Z9KxtpYiJZx36mUDVOwH83pl7yvCer6ewM3w==}
    dev: true

  /sprintf-js@1.0.3:
    resolution: {integrity: sha512-D9cPgkvLlV3t3IzL0D0YLvGA9Ahk4PcvVwUbN0dSGr1aP0Nrt4AEnTUbuGvquEC0mA64Gqt1fzirlRs5ibXx8g==}
    dev: true

  /stackback@0.0.2:
    resolution: {integrity: sha512-1XMJE5fQo1jGH6Y/7ebnwPOBEkIEnT4QF32d5R1+VXdXveM0IBMJt8zfaxX1P3QhVwrYe+576+jkANtSS2mBbw==}
    dev: true

  /std-env@3.7.0:
    resolution: {integrity: sha512-JPbdCEQLj1w5GilpiHAx3qJvFndqybBysA3qUOnznweH4QbNYUsW/ea8QzSrnh0vNsezMMw5bcVool8lM0gwzg==}
    dev: true

  /stream-transform@2.1.3:
    resolution: {integrity: sha512-9GHUiM5hMiCi6Y03jD2ARC1ettBXkQBoQAe7nJsPknnI0ow10aXjTnew8QtYQmLjzn974BnmWEAJgCY6ZP1DeQ==}
    dependencies:
      mixme: 0.5.9
    dev: true

  /string-argv@0.3.2:
    resolution: {integrity: sha512-aqD2Q0144Z+/RqG52NeHEkZauTAUWJO8c6yTftGJKO3Tja5tUgIfmIl6kExvhtxSDP7fXB6DvzkfMpCd/F3G+Q==}
    engines: {node: '>=0.6.19'}
    dev: true

  /string-width@4.2.3:
    resolution: {integrity: sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==}
    engines: {node: '>=8'}
    dependencies:
      emoji-regex: 8.0.0
      is-fullwidth-code-point: 3.0.0
      strip-ansi: 6.0.1

  /string-width@5.1.2:
    resolution: {integrity: sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==}
    engines: {node: '>=12'}
    dependencies:
      eastasianwidth: 0.2.0
      emoji-regex: 9.2.2
      strip-ansi: 7.1.0

  /string.prototype.trim@1.2.7:
    resolution: {integrity: sha512-p6TmeT1T3411M8Cgg9wBTMRtY2q9+PNy9EV1i2lIXUN/btt763oIfxwN3RR8VU6wHX8j/1CFy0L+YuThm6bgOg==}
    engines: {node: '>= 0.4'}
    dependencies:
      call-bind: 1.0.2
      define-properties: 1.2.0
      es-abstract: 1.21.2
    dev: true

  /string.prototype.trimend@1.0.6:
    resolution: {integrity: sha512-JySq+4mrPf9EsDBEDYMOb/lM7XQLulwg5R/m1r0PXEFqrV0qHvl58sdTilSXtKOflCsK2E8jxf+GKC0T07RWwQ==}
    dependencies:
      call-bind: 1.0.2
      define-properties: 1.2.0
      es-abstract: 1.21.2
    dev: true

  /string.prototype.trimstart@1.0.6:
    resolution: {integrity: sha512-omqjMDaY92pbn5HOX7f9IccLA+U1tA9GvtU4JrodiXFfYB7jPzzHpRzpglLAjtUV6bB557zwClJezTqnAiYnQA==}
    dependencies:
      call-bind: 1.0.2
      define-properties: 1.2.0
      es-abstract: 1.21.2
    dev: true

  /strip-ansi@6.0.1:
    resolution: {integrity: sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==}
    engines: {node: '>=8'}
    dependencies:
      ansi-regex: 5.0.1

  /strip-ansi@7.1.0:
    resolution: {integrity: sha512-iq6eVVI64nQQTRYq2KtEg2d2uU7LElhTJwsH4YzIHZshxlgZms/wIc4VoDQTlG/IvVIrBKG06CrZnp0qv7hkcQ==}
    engines: {node: '>=12'}
    dependencies:
      ansi-regex: 6.0.1

  /strip-bom@3.0.0:
    resolution: {integrity: sha512-vavAMRXOgBVNF6nyEEmL3DBK19iRpDcoIwW+swQ+CbGiu7lju6t+JklA1MHweoWtadgt4ISVUsXLyDq34ddcwA==}
    engines: {node: '>=4'}
    dev: true

  /strip-final-newline@3.0.0:
    resolution: {integrity: sha512-dOESqjYr96iWYylGObzd39EuNTa5VJxyvVAEm5Jnh7KGo75V43Hk1odPQkNDyXNmUR6k+gEiDVXnjB8HJ3crXw==}
    engines: {node: '>=12'}
    dev: true

  /strip-indent@3.0.0:
    resolution: {integrity: sha512-laJTa3Jb+VQpaC6DseHhF7dXVqHTfJPCRDaEbid/drOhgitgYku/letMUqOXFoWV0zIIUbjpdH2t+tYj4bQMRQ==}
    engines: {node: '>=8'}
    dependencies:
      min-indent: 1.0.1
    dev: true

  /strip-literal@2.0.0:
    resolution: {integrity: sha512-f9vHgsCWBq2ugHAkGMiiYY+AYG0D/cbloKKg0nhaaaSNsujdGIpVXCNsrJpCKr5M0f4aI31mr13UjY6GAuXCKA==}
    dependencies:
      js-tokens: 8.0.3
    dev: true

  /supports-color@5.5.0:
    resolution: {integrity: sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==}
    engines: {node: '>=4'}
    dependencies:
      has-flag: 3.0.0
    dev: true

  /supports-color@7.2.0:
    resolution: {integrity: sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==}
    engines: {node: '>=8'}
    dependencies:
      has-flag: 4.0.0
    dev: true

  /supports-preserve-symlinks-flag@1.0.0:
    resolution: {integrity: sha512-ot0WnXS9fgdkgIcePe6RHNk1WA8+muPa6cSjeR3V8K27q9BB1rTE3R1p7Hv0z1ZyAc8s6Vvv8DIyWf681MAt0w==}
    engines: {node: '>= 0.4'}
    dev: true

  /term-size@2.2.1:
    resolution: {integrity: sha512-wK0Ri4fOGjv/XPy8SBHZChl8CM7uMc5VML7SqiQ0zG7+J5Vr+RMQDoHa2CNT6KHUnTGIXH34UDMkPzAUyapBZg==}
    engines: {node: '>=8'}
    dev: true

  /tinybench@2.5.1:
    resolution: {integrity: sha512-65NKvSuAVDP/n4CqH+a9w2kTlLReS9vhsAP06MWx+/89nMinJyB2icyl58RIcqCmIggpojIGeuJGhjU1aGMBSg==}
    dev: true

  /tinypool@0.8.2:
    resolution: {integrity: sha512-SUszKYe5wgsxnNOVlBYO6IC+8VGWdVGZWAqUxp3UErNBtptZvWbwyUOyzNL59zigz2rCA92QiL3wvG+JDSdJdQ==}
    engines: {node: '>=14.0.0'}
    dev: true

  /tinyspy@2.2.0:
    resolution: {integrity: sha512-d2eda04AN/cPOR89F7Xv5bK/jrQEhmcLFe6HFldoeO9AJtps+fqEnh486vnT/8y4bw38pSyxDcTCAq+Ks2aJTg==}
    engines: {node: '>=14.0.0'}
    dev: true

  /tmp@0.0.33:
    resolution: {integrity: sha512-jRCJlojKnZ3addtTOjdIqoRuPEKBvNXcGYqzO6zWZX8KfKEpnGY5jfggJQ3EjKuu8D4bJRr0y+cYJFmYbImXGw==}
    engines: {node: '>=0.6.0'}
    dependencies:
      os-tmpdir: 1.0.2
    dev: true

  /to-regex-range@5.0.1:
    resolution: {integrity: sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==}
    engines: {node: '>=8.0'}
    dependencies:
      is-number: 7.0.0
    dev: true

  /tr46@0.0.3:
    resolution: {integrity: sha512-N3WMsuqV66lT30CrXNbEjx4GEwlow3v6rr4mCcv6prnfwhS01rkgyFdjPNBYd9br7LpXV1+Emh01fHnq2Gdgrw==}
    dev: false

  /trim-newlines@3.0.1:
    resolution: {integrity: sha512-c1PTsA3tYrIsLGkJkzHF+w9F2EyxfXGo4UyJc4pFL++FMjnq0HJS69T3M7d//gKrFKwy429bouPescbjecU+Zw==}
    engines: {node: '>=8'}
    dev: true

  /ts-node@10.9.0(@types/node@20.4.1)(typescript@5.3.2):
    resolution: {integrity: sha512-bunW18GUyaCSYRev4DPf4SQpom3pWH29wKl0sDk5zE7ze19RImEVhCW7K4v3hHKkUyfWotU08ToE2RS+Y49aug==}
    hasBin: true
    peerDependencies:
      '@swc/core': '>=1.2.50'
      '@swc/wasm': '>=1.2.50'
      '@types/node': '*'
      typescript: '>=2.7'
    peerDependenciesMeta:
      '@swc/core':
        optional: true
      '@swc/wasm':
        optional: true
    dependencies:
      '@cspotcode/source-map-support': 0.8.1
      '@tsconfig/node10': 1.0.9
      '@tsconfig/node12': 1.0.11
      '@tsconfig/node14': 1.0.3
      '@tsconfig/node16': 1.0.4
      '@types/node': 20.4.1
      acorn: 8.10.0
      acorn-walk: 8.2.0
      arg: 4.1.3
      create-require: 1.1.1
      diff: 4.0.2
      make-error: 1.3.6
      typescript: 5.3.2
      v8-compile-cache-lib: 3.0.1
      yn: 3.1.1
    dev: true

  /ts-node@10.9.1(@types/node@20.4.1)(typescript@5.3.2):
    resolution: {integrity: sha512-NtVysVPkxxrwFGUUxGYhfux8k78pQB3JqYBXlLRZgdGUqTO5wU/UyHop5p70iEbGhB7q5KmiZiU0Y3KlJrScEw==}
    hasBin: true
    peerDependencies:
      '@swc/core': '>=1.2.50'
      '@swc/wasm': '>=1.2.50'
      '@types/node': '*'
      typescript: '>=2.7'
    peerDependenciesMeta:
      '@swc/core':
        optional: true
      '@swc/wasm':
        optional: true
    dependencies:
      '@cspotcode/source-map-support': 0.8.1
      '@tsconfig/node10': 1.0.9
      '@tsconfig/node12': 1.0.11
      '@tsconfig/node14': 1.0.3
      '@tsconfig/node16': 1.0.4
      '@types/node': 20.4.1
      acorn: 8.10.0
      acorn-walk: 8.2.0
      arg: 4.1.3
      create-require: 1.1.1
      diff: 4.0.2
      make-error: 1.3.6
      typescript: 5.3.2
      v8-compile-cache-lib: 3.0.1
      yn: 3.1.1
    dev: false

  /tty-table@4.2.1:
    resolution: {integrity: sha512-xz0uKo+KakCQ+Dxj1D/tKn2FSyreSYWzdkL/BYhgN6oMW808g8QRMuh1atAV9fjTPbWBjfbkKQpI/5rEcnAc7g==}
    engines: {node: '>=8.0.0'}
    hasBin: true
    dependencies:
      chalk: 4.1.2
      csv: 5.5.3
      kleur: 4.1.5
      smartwrap: 2.0.2
      strip-ansi: 6.0.1
      wcwidth: 1.0.1
      yargs: 17.7.2
    dev: true

  /turbo-darwin-64@1.10.16:
    resolution: {integrity: sha512-+Jk91FNcp9e9NCLYlvDDlp2HwEDp14F9N42IoW3dmHI5ZkGSXzalbhVcrx3DOox3QfiNUHxzWg4d7CnVNCuuMg==}
    cpu: [x64]
    os: [darwin]
    requiresBuild: true
    dev: true
    optional: true

  /turbo-darwin-arm64@1.10.16:
    resolution: {integrity: sha512-jqGpFZipIivkRp/i+jnL8npX0VssE6IAVNKtu573LXtssZdV/S+fRGYA16tI46xJGxSAivrZ/IcgZrV6Jk80bw==}
    cpu: [arm64]
    os: [darwin]
    requiresBuild: true
    dev: true
    optional: true

  /turbo-linux-64@1.10.16:
    resolution: {integrity: sha512-PpqEZHwLoizQ6sTUvmImcRmACyRk9EWLXGlqceogPZsJ1jTRK3sfcF9fC2W56zkSIzuLEP07k5kl+ZxJd8JMcg==}
    cpu: [x64]
    os: [linux]
    requiresBuild: true
    dev: true
    optional: true

  /turbo-linux-arm64@1.10.16:
    resolution: {integrity: sha512-TMjFYz8to1QE0fKVXCIvG/4giyfnmqcQIwjdNfJvKjBxn22PpbjeuFuQ5kNXshUTRaTJihFbuuCcb5OYFNx4uw==}
    cpu: [arm64]
    os: [linux]
    requiresBuild: true
    dev: true
    optional: true

  /turbo-windows-64@1.10.16:
    resolution: {integrity: sha512-+jsf68krs0N66FfC4/zZvioUap/Tq3sPFumnMV+EBo8jFdqs4yehd6+MxIwYTjSQLIcpH8KoNMB0gQYhJRLZzw==}
    cpu: [x64]
    os: [win32]
    requiresBuild: true
    dev: true
    optional: true

  /turbo-windows-arm64@1.10.16:
    resolution: {integrity: sha512-sKm3hcMM1bl0B3PLG4ifidicOGfoJmOEacM5JtgBkYM48ncMHjkHfFY7HrJHZHUnXM4l05RQTpLFoOl/uIo2HQ==}
    cpu: [arm64]
    os: [win32]
    requiresBuild: true
    dev: true
    optional: true

  /turbo@1.10.16:
    resolution: {integrity: sha512-2CEaK4FIuSZiP83iFa9GqMTQhroW2QryckVqUydmg4tx78baftTOS0O+oDAhvo9r9Nit4xUEtC1RAHoqs6ZEtg==}
    hasBin: true
    optionalDependencies:
      turbo-darwin-64: 1.10.16
      turbo-darwin-arm64: 1.10.16
      turbo-linux-64: 1.10.16
      turbo-linux-arm64: 1.10.16
      turbo-windows-64: 1.10.16
      turbo-windows-arm64: 1.10.16
    dev: true

  /type-detect@4.0.8:
    resolution: {integrity: sha512-0fr/mIH1dlO+x7TlcMy+bIDqKPsw/70tVyeHW787goQjhmqaZe10uwLujubK9q9Lg6Fiho1KUKDYz0Z7k7g5/g==}
    engines: {node: '>=4'}
    dev: true

  /type-fest@0.13.1:
    resolution: {integrity: sha512-34R7HTnG0XIJcBSn5XhDd7nNFPRcXYRZrBB2O2jdKqYODldSzBAqzsWoZYYvduky73toYS/ESqxPvkDf/F0XMg==}
    engines: {node: '>=10'}
    dev: true

  /type-fest@0.6.0:
    resolution: {integrity: sha512-q+MB8nYR1KDLrgr4G5yemftpMC7/QLqVndBmEEdqzmNj5dcFOO4Oo8qlwZE3ULT3+Zim1F8Kq4cBnikNhlCMlg==}
    engines: {node: '>=8'}
    dev: true

  /type-fest@0.8.1:
    resolution: {integrity: sha512-4dbzIzqvjtgiM5rw1k5rEHtBANKmdudhGyBEajN01fEyhaAIhsoKNy6y7+IN93IfpFtwY9iqi7kD+xwKhQsNJA==}
    engines: {node: '>=8'}
    dev: true

  /type-fest@1.4.0:
    resolution: {integrity: sha512-yGSza74xk0UG8k+pLh5oeoYirvIiWo5t0/o3zHHAO2tRDiZcxWP7fywNlXhqb6/r6sWvwi+RsyQMWhVLe4BVuA==}
    engines: {node: '>=10'}
    dev: true

  /type-fest@3.8.0:
    resolution: {integrity: sha512-FVNSzGQz9Th+/9R6Lvv7WIAkstylfHN2/JYxkyhhmKFYh9At2DST8t6L6Lref9eYO8PXFTfG9Sg1Agg0K3vq3Q==}
    engines: {node: '>=14.16'}
    dev: true

  /typed-array-length@1.0.4:
    resolution: {integrity: sha512-KjZypGq+I/H7HI5HlOoGHkWUUGq+Q0TPhQurLbyrVrvnKTBgzLhIJ7j6J/XTQOi0d1RjyZ0wdas8bKs2p0x3Ng==}
    dependencies:
      call-bind: 1.0.2
      for-each: 0.3.3
      is-typed-array: 1.1.10
    dev: true

  /typescript@5.3.2:
    resolution: {integrity: sha512-6l+RyNy7oAHDfxC4FzSJcz9vnjTKxrLpDG5M2Vu4SHRVNg6xzqZp6LYSR9zjqQTu8DU/f5xwxUdADOkbrIX2gQ==}
    engines: {node: '>=14.17'}
    hasBin: true

  /ufo@1.3.2:
    resolution: {integrity: sha512-o+ORpgGwaYQXgqGDwd+hkS4PuZ3QnmqMMxRuajK/a38L6fTpcE5GPIfrf+L/KemFzfUpeUQc1rRS1iDBozvnFA==}
    dev: true

  /unbox-primitive@1.0.2:
    resolution: {integrity: sha512-61pPlCD9h51VoreyJ0BReideM3MDKMKnh6+V9L08331ipq6Q8OFXZYiqP6n/tbHx4s5I9uRhcye6BrbkizkBDw==}
    dependencies:
      call-bind: 1.0.2
      has-bigints: 1.0.2
      has-symbols: 1.0.3
      which-boxed-primitive: 1.0.2
    dev: true

  /universalify@0.1.2:
    resolution: {integrity: sha512-rBJeI5CXAlmy1pV+617WB9J63U6XcazHHF2f2dbJix4XzpUF0RS3Zbj0FGIOCAva5P/d/GBOYaACQ1w+0azUkg==}
    engines: {node: '>= 4.0.0'}
    dev: true

  /uuid@8.3.2:
    resolution: {integrity: sha512-+NYs2QeMWy+GWFOEm9xnn6HCDp0l7QBD7ml8zLUmJ+93Q5NF0NocErnwkTkXVFNiX3/fpC6afS8Dhb/gz7R7eg==}
    hasBin: true
    dev: false

  /v8-compile-cache-lib@3.0.1:
    resolution: {integrity: sha512-wa7YjyUGfNZngI/vtK0UHAN+lgDCxBPCylVXGp0zu59Fz5aiGtNXaq3DhIov063MorB+VfufLh3JlF2KdTK3xg==}

  /validate-npm-package-license@3.0.4:
    resolution: {integrity: sha512-DpKm2Ui/xN7/HQKCtpZxoRWBhZ9Z0kqtygG8XCgNQ8ZlDnxuQmWhj566j8fN4Cu3/JmbhsDo7fcAJq4s9h27Ew==}
    dependencies:
      spdx-correct: 3.2.0
      spdx-expression-parse: 3.0.1
    dev: true

  /vite-node@1.4.0(@types/node@20.4.1):
    resolution: {integrity: sha512-VZDAseqjrHgNd4Kh8icYHWzTKSCZMhia7GyHfhtzLW33fZlG9SwsB6CEhgyVOWkJfJ2pFLrp/Gj1FSfAiqH9Lw==}
    engines: {node: ^18.0.0 || >=20.0.0}
    hasBin: true
    dependencies:
      cac: 6.7.14
      debug: 4.3.4
      pathe: 1.1.1
      picocolors: 1.0.0
      vite: 5.0.10(@types/node@20.4.1)
    transitivePeerDependencies:
      - '@types/node'
      - less
      - lightningcss
      - sass
      - stylus
      - sugarss
      - supports-color
      - terser
    dev: true

  /vite@5.0.10(@types/node@20.4.1):
    resolution: {integrity: sha512-2P8J7WWgmc355HUMlFrwofacvr98DAjoE52BfdbwQtyLH06XKwaL/FMnmKM2crF0iX4MpmMKoDlNCB1ok7zHCw==}
    engines: {node: ^18.0.0 || >=20.0.0}
    hasBin: true
    peerDependencies:
      '@types/node': ^18.0.0 || >=20.0.0
      less: '*'
      lightningcss: ^1.21.0
      sass: '*'
      stylus: '*'
      sugarss: '*'
      terser: ^5.4.0
    peerDependenciesMeta:
      '@types/node':
        optional: true
      less:
        optional: true
      lightningcss:
        optional: true
      sass:
        optional: true
      stylus:
        optional: true
      sugarss:
        optional: true
      terser:
        optional: true
    dependencies:
      '@types/node': 20.4.1
      esbuild: 0.19.11
      postcss: 8.4.32
      rollup: 4.9.2
    optionalDependencies:
      fsevents: 2.3.3
    dev: true

  /vitest@1.4.0(@types/node@20.4.1):
    resolution: {integrity: sha512-gujzn0g7fmwf83/WzrDTnncZt2UiXP41mHuFYFrdwaLRVQ6JYQEiME2IfEjU3vcFL3VKa75XhI3lFgn+hfVsQw==}
    engines: {node: ^18.0.0 || >=20.0.0}
    hasBin: true
    peerDependencies:
      '@edge-runtime/vm': '*'
      '@types/node': ^18.0.0 || >=20.0.0
      '@vitest/browser': 1.4.0
      '@vitest/ui': 1.4.0
      happy-dom: '*'
      jsdom: '*'
    peerDependenciesMeta:
      '@edge-runtime/vm':
        optional: true
      '@types/node':
        optional: true
      '@vitest/browser':
        optional: true
      '@vitest/ui':
        optional: true
      happy-dom:
        optional: true
      jsdom:
        optional: true
    dependencies:
      '@types/node': 20.4.1
      '@vitest/expect': 1.4.0
      '@vitest/runner': 1.4.0
      '@vitest/snapshot': 1.4.0
      '@vitest/spy': 1.4.0
      '@vitest/utils': 1.4.0
      acorn-walk: 8.3.2
      chai: 4.3.10
      debug: 4.3.4
      execa: 8.0.1
      local-pkg: 0.5.0
      magic-string: 0.30.5
      pathe: 1.1.1
      picocolors: 1.0.0
      std-env: 3.7.0
      strip-literal: 2.0.0
      tinybench: 2.5.1
      tinypool: 0.8.2
      vite: 5.0.10(@types/node@20.4.1)
      vite-node: 1.4.0(@types/node@20.4.1)
      why-is-node-running: 2.2.2
    transitivePeerDependencies:
      - less
      - lightningcss
      - sass
      - stylus
      - sugarss
      - supports-color
      - terser
    dev: true

  /wcwidth@1.0.1:
    resolution: {integrity: sha512-XHPEwS0q6TaxcvG85+8EYkbiCux2XtWG2mkc47Ng2A77BQu9+DqIOJldST4HgPkuea7dvKSj5VgX3P1d4rW8Tg==}
    dependencies:
      defaults: 1.0.4
    dev: true

  /webidl-conversions@3.0.1:
    resolution: {integrity: sha512-2JAn3z8AR6rjK8Sm8orRC0h/bcl/DqL7tRPdGZ4I1CjdF+EaMLmYxBHyXuKL849eucPFhvBoxMsflfOb8kxaeQ==}
    dev: false

  /whatwg-url@5.0.0:
    resolution: {integrity: sha512-saE57nupxk6v3HY35+jzBwYa0rKSy0XR8JSxZPwgLr7ys0IBzhGviA1/TUGJLmSVqs8pb9AnvICXEuOHLprYTw==}
    dependencies:
      tr46: 0.0.3
      webidl-conversions: 3.0.1
    dev: false

  /which-boxed-primitive@1.0.2:
    resolution: {integrity: sha512-bwZdv0AKLpplFY2KZRX6TvyuN7ojjr7lwkg6ml0roIy9YeuSr7JS372qlNW18UQYzgYK9ziGcerWqZOmEn9VNg==}
    dependencies:
      is-bigint: 1.0.4
      is-boolean-object: 1.1.2
      is-number-object: 1.0.7
      is-string: 1.0.7
      is-symbol: 1.0.4
    dev: true

  /which-module@2.0.1:
    resolution: {integrity: sha512-iBdZ57RDvnOR9AGBhML2vFZf7h8vmBjhoaZqODJBFWHVtKkDmKuHai3cx5PgVMrX5YDNp27AofYbAwctSS+vhQ==}
    dev: true

  /which-pm@2.0.0:
    resolution: {integrity: sha512-Lhs9Pmyph0p5n5Z3mVnN0yWcbQYUAD7rbQUiMsQxOJ3T57k7RFe35SUwWMf7dsbDZks1uOmw4AecB/JMDj3v/w==}
    engines: {node: '>=8.15'}
    dependencies:
      load-yaml-file: 0.2.0
      path-exists: 4.0.0
    dev: true

  /which-typed-array@1.1.9:
    resolution: {integrity: sha512-w9c4xkx6mPidwp7180ckYWfMmvxpjlZuIudNtDf4N/tTAUB8VJbX25qZoAsrtGuYNnGw3pa0AXgbGKRB8/EceA==}
    engines: {node: '>= 0.4'}
    dependencies:
      available-typed-arrays: 1.0.5
      call-bind: 1.0.2
      for-each: 0.3.3
      gopd: 1.0.1
      has-tostringtag: 1.0.0
      is-typed-array: 1.1.10
    dev: true

  /which@1.3.1:
    resolution: {integrity: sha512-HxJdYWq1MTIQbJ3nw0cqssHoTNU267KlrDuGZ1WYlxDStUtKUhOaJmh112/TZmHxxUfuJqPXSOm7tDyas0OSIQ==}
    hasBin: true
    dependencies:
      isexe: 2.0.0
    dev: true

  /which@2.0.2:
    resolution: {integrity: sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==}
    engines: {node: '>= 8'}
    hasBin: true
    dependencies:
      isexe: 2.0.0

  /why-is-node-running@2.2.2:
    resolution: {integrity: sha512-6tSwToZxTOcotxHeA+qGCq1mVzKR3CwcJGmVcY+QE8SHy6TnpFnh8PAvPNHYr7EcuVeG0QSMxtYCuO1ta/G/oA==}
    engines: {node: '>=8'}
    hasBin: true
    dependencies:
      siginfo: 2.0.0
      stackback: 0.0.2
    dev: true

  /wrap-ansi@6.2.0:
    resolution: {integrity: sha512-r6lPcBGxZXlIcymEu7InxDMhdW0KDxpLgoFLcguasxCaJ/SOIZwINatK9KY/tf+ZrlywOKU0UDj3ATXUBfxJXA==}
    engines: {node: '>=8'}
    dependencies:
      ansi-styles: 4.3.0
      string-width: 4.2.3
      strip-ansi: 6.0.1
    dev: true

  /wrap-ansi@7.0.0:
    resolution: {integrity: sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==}
    engines: {node: '>=10'}
    dependencies:
      ansi-styles: 4.3.0
      string-width: 4.2.3
      strip-ansi: 6.0.1

  /wrap-ansi@8.1.0:
    resolution: {integrity: sha512-si7QWI6zUMq56bESFvagtmzMdGOtoxfR+Sez11Mobfc7tm+VkUckk9bW2UeffTGVUbOksxmSw0AA2gs8g71NCQ==}
    engines: {node: '>=12'}
    dependencies:
      ansi-styles: 6.2.1
      string-width: 5.1.2
      strip-ansi: 7.1.0

  /y18n@4.0.3:
    resolution: {integrity: sha512-JKhqTOwSrqNA1NY5lSztJ1GrBiUodLMmIZuLiDaMRJ+itFd+ABVE8XBjOvIWL+rSqNDC74LCSFmlb/U4UZ4hJQ==}
    dev: true

  /y18n@5.0.8:
    resolution: {integrity: sha512-0pfFzegeDWJHJIAmTLRP2DwHjdF5s7jo9tuztdQxAhINCdvS+3nGINqPd00AphqJR/0LhANUS6/+7SCb98YOfA==}
    engines: {node: '>=10'}
    dev: true

  /yallist@2.1.2:
    resolution: {integrity: sha512-ncTzHV7NvsQZkYe1DW7cbDLm0YpzHmZF5r/iyP3ZnQtMiJ+pjzisCiMNI+Sj+xQF5pXhSHxSB3uDbsBTzY/c2A==}
    dev: true

  /yallist@4.0.0:
    resolution: {integrity: sha512-3wdGidZyq5PB084XLES5TpOSRA3wjXAlIWMhum2kRcv/41Sn2emQ0dycQW4uZXLejwKvg6EsvbdlVL+FYEct7A==}
    dev: true

  /yaml@2.3.4:
    resolution: {integrity: sha512-8aAvwVUSHpfEqTQ4w/KMlf3HcRdt50E5ODIQJBw1fQ5RL34xabzxtUlzTXVqc4rkZsPbvrXKWnABCD7kWSmocA==}
    engines: {node: '>= 14'}
    dev: true

  /yargs-parser@18.1.3:
    resolution: {integrity: sha512-o50j0JeToy/4K6OZcaQmW6lyXXKhq7csREXcDwk2omFPJEwUNOVtJKvmDr9EI1fAJZUyZcRF7kxGBWmRXudrCQ==}
    engines: {node: '>=6'}
    dependencies:
      camelcase: 5.3.1
      decamelize: 1.2.0
    dev: true

  /yargs-parser@21.1.1:
    resolution: {integrity: sha512-tVpsJW7DdjecAiFpbIB1e3qxIQsE6NoPc5/eTdrbbIC4h0LVsWhnoa3g+m2HclBIujHzsxZ4VJVA+GUuc2/LBw==}
    engines: {node: '>=12'}
    dev: true

  /yargs@15.4.1:
    resolution: {integrity: sha512-aePbxDmcYW++PaqBsJ+HYUFwCdv4LVvdnhBy78E57PIor8/OVvhMrADFFEDh8DHDFRv/O9i3lPhsENjO7QX0+A==}
    engines: {node: '>=8'}
    dependencies:
      cliui: 6.0.0
      decamelize: 1.2.0
      find-up: 4.1.0
      get-caller-file: 2.0.5
      require-directory: 2.1.1
      require-main-filename: 2.0.0
      set-blocking: 2.0.0
      string-width: 4.2.3
      which-module: 2.0.1
      y18n: 4.0.3
      yargs-parser: 18.1.3
    dev: true

  /yargs@17.7.2:
    resolution: {integrity: sha512-7dSzzRQ++CKnNI/krKnYRV7JKKPUXMEh61soaHKg9mrWEhzFWhFnxPxGl+69cD1Ou63C13NUPCnmIcrvqCuM6w==}
    engines: {node: '>=12'}
    dependencies:
      cliui: 8.0.1
      escalade: 3.1.1
      get-caller-file: 2.0.5
      require-directory: 2.1.1
      string-width: 4.2.3
      y18n: 5.0.8
      yargs-parser: 21.1.1
    dev: true

  /yn@3.1.1:
    resolution: {integrity: sha512-Ux4ygGWsu2c7isFWe8Yu1YluJmqVhxqK2cLXNQA5AcC3QfbGNpM7fu0Y8b/z16pXLnFxZYvWhd3fhBY9DLmC6Q==}
    engines: {node: '>=6'}

  /yocto-queue@0.1.0:
    resolution: {integrity: sha512-rVksvsnNCdJ/ohGc6xgPwyN8eheCxsiLM8mxuE/t/mOVqJewPuO1miLpTHQiRgTKCLexL4MeAFVagts7HmNZ2Q==}
    engines: {node: '>=10'}
    dev: true

  /yocto-queue@1.0.0:
    resolution: {integrity: sha512-9bnSc/HEW2uRy67wc+T8UwauLuPJVn28jb+GtJY16iiKWyvmYJRXVT4UamsAEGQfPohgr2q4Tq0sQbQlxTfi1g==}
    engines: {node: '>=12.20'}
    dev: true


================================================
File: pnpm-workspace.yaml
================================================
packages:
  - "packages/*"
  - "examples/*"


================================================
File: tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "ESNext",
    "target": "ESNext",
    "lib": ["ES6", "DOM"],
    "strict": true,
    "allowJs": true,
    "sourceMap": true,
    "moduleResolution": "Node",
    "noImplicitReturns": true,
    "noImplicitThis": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "composite": true,
    "noEmit": true,
    "jsx": "react"
  },
  "exclude": [
    "**/node_modules",
    "**/dist"
  ]
}


================================================
File: turbo.json
================================================
{
  "$schema": "https://turbo.build/schema.json",
  "globalDependencies": ["**/.env.*local"],
  "pipeline": {
    "dev": {
      "cache": false,
      "persistent": true,
      "dependsOn": ["clean", "^build"]
    },
    "build": {
      "outputs": ["lib/**", "dist/**", ".next/**", "!.next/cache/**"],
      "dependsOn": ["^build"],
      "cache": false
    },
    "test": {
      "outputs": ["coverage/**"],
      "dependsOn": []
    },
    "lint:fix": {
      "cache": false
    },
    "clean": {
      "cache": false
    }
  }
}


================================================
File: .npmrc
================================================
auto-install-peers=true
node-linker=hoisted

================================================
File: .prettierignore
================================================
# editors
**/.git
**/.idea
**/.vscode

# dependencies
**/node_modules
**/.pnp.js
**/.pnp

# testing
**/coverage

# production
**/dist
**/build
**/tsconfig.tsbuildinfo

# misc
**/.DS_Store
**/.env.local
**/.env.development.local
**/.env.test.local
**/.env.production.local

**/npm-debug.log*
**/yarn-debug.log*
**/yarn-error.log*

# moleculec
**/*.mol

# generated typing
**/.next
**/next-env.d.ts
**/auto-imports.d.ts
**/vite-imports.d.ts


================================================
File: .prettierrc
================================================
{
  "semi": true,
  "tabWidth": 2,
  "useTabs": false,
  "singleQuote": true,
  "jsxSingleQuote": false,
  "trailingComma": "all",
  "endOfLine": "lf",
  "printWidth": 120
}


================================================
File: docs/core/composed-apis.md
================================================
# Composed API

<!-- TOC -->
* [Composed API](#composed-api)
  * [Spore](#spore)
    * [createSpore](#createspore)
      * [Examples](#examples)
    * [transferSpore](#transferspore)
      * [Example](#example)
    * [meltSpore](#meltspore)
      * [Example](#example-1)
  * [Cluster](#cluster)
    * [createCluster](#createcluster)
      * [Examples](#examples-1)
    * [transferCluster](#transfercluster)
      * [Example](#example-2)
  * [ClusterProxy](#clusterproxy)
    * [createClusterProxy](#createclusterproxy)
      * [Example](#example-3)
    * [transferClusterProxy](#transferclusterproxy)
      * [Example](#example-4)
    * [meltClusterProxy](#meltclusterproxy)
      * [Example](#example-5)
  * [ClusterAgent](#clusteragent)
    * [createClusterAgent](#createclusteragent)
      * [Example](#example-6)
    * [transferClusterAgent](#transferclusteragent)
      * [Example](#example-7)
    * [meltClusterAgent](#meltclusteragent)
      * [Example](#example-8)
<!-- TOC -->

## Spore

### createSpore

```typescript
declare function createSpore(props: {
  data: SporeDataProps;
  toLock: Script;
  fromInfos: FromInfo[];
  changeAddress?: Address;
  updateOutput?: (cell: Cell) => Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  cluster?: {
    updateOutput?: (cell: Cell) => Cell;
    capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
    updateWitness?: HexString | ((witness: HexString) => HexString);
  };
  clusterAgentOutPoint?: OutPoint;
  clusterAgent?: {
    updateOutput?: (cell: Cell) => Cell;
    capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
    updateWitness?: HexString | ((witness: HexString) => HexString);
  };
  maxTransactionSize?: number | false;
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  outputIndex: number;
  reference: {
    referenceTarget: 'cluster' | 'clusterAgent' | 'none';
    referenceType?: 'cell' | 'lockProxy';
    cluster?: {
      inputIndex: number;
      outputIndex: number;
    };
    clusterAgent?: {
      inputIndex: number;
      outputIndex: number;
    };
  };
}>;
```

#### Examples

- [examples/secp256k1/apis/createSpore.ts](../../examples/secp256k1/apis/createSpore.ts)
- [examples/secp256k1/apis/createSporeWithCluster.ts](../../examples/secp256k1/apis/createSporeWithCluster.ts)
- [examples/secp256k1/apis/createSporeWithClusterAgent.ts](../../examples/secp256k1/apis/createSporeWithClusterAgent.ts)
- [examples/acp/apis/createSporeWithAcpCluster.ts](../../examples/acp/apis/createSporeWithAcpCluster.ts)
- [examples/omnilock/acp/createSporeWithAcpCluster.ts](../../examples/omnilock/acp/createSporeWithAcpCluster.ts)

### transferSpore

```typescript
declare function transferSpore(props: {
  outPoint: OutPoint;
  toLock: Script;
  fromInfos?: FromInfo[];
  changeAddress?: Address;
  useCapacityMarginAsFee?: boolean;
  updateOutput?: (cell: Cell) => Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  updateWitness?: HexString | ((witness: HexString) => HexString);
  defaultWitness?: HexString;
  since?: PackedSince;
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
  outputIndex: number;
}>;
```

#### Example

- [examples/secp256k1/apis/transferSpore.ts](../../examples/secp256k1/apis/transferSpore.ts)

### meltSpore

```typescript
declare function meltSpore(props: {
  outPoint: OutPoint;
  changeAddress?: Address;
  updateWitness?: HexString | ((witness: HexString) => HexString);
  defaultWitness?: HexString;
  since?: PackedSince;
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
}>;
```

#### Example

- [examples/secp256k1/apis/meltSpore.ts](../../examples/secp256k1/apis/meltSpore.ts)

## Cluster

### createCluster

```typescript
declare function createCluster(props: {
  data: ClusterDataProps;
  toLock: Script;
  fromInfos: FromInfo[];
  changeAddress?: Address;
  updateOutput?: (cell: Cell) => Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  maxTransactionSize?: number | false;
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  outputIndex: number;
}>;

interface ClusterDataProps {
  name: string;
  description: string;
}
```

#### Examples

- [examples/secp256k1/apis/createCluster.ts](../../examples/secp256k1/apis/createCluster.ts)
- [examples/acp/apis/createAcpCluster.ts](../../examples/acp/apis/createAcpCluster.ts)
- [examples/omnilock/acp/createAcpCluster.ts](../../examples/omnilock/acp/createAcpCluster.ts)

### transferCluster

```typescript
declare function transferCluster(props: {
  outPoint: OutPoint;
  toLock: Script;
  fromInfos?: FromInfo[];
  changeAddress?: Address;
  useCapacityMarginAsFee?: boolean;
  updateOutput?: (cell: Cell) => Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  updateWitness?: HexString | ((witness: HexString) => HexString);
  defaultWitness?: HexString;
  since?: PackedSince;
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
  outputIndex: number;
}>;
```

#### Example

- [examples/secp256k1/apis/transferCluster.ts](../../examples/secp256k1/apis/transferCluster.ts)

## ClusterProxy

### createClusterProxy

```typescript
declare function createClusterProxy(props: {
  clusterOutPoint: OutPoint;
  minPayment?: BIish;
  toLock: Script;
  fromInfos: FromInfo[];
  changeAddress?: Address;
  updateOutput?(cell: Cell): Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  cluster?: {
    updateOutput?(cell: Cell): Cell;
    capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
    updateWitness?: HexString | ((witness: HexString) => HexString);
  };
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  outputIndex: number;
  reference: {
    referenceType: 'cell' | 'lockProxy';
    cluster?: {
      inputIndex: number;
      outputIndex: number;
    };
  };
}>;
```

#### Example

- [examples/secp256k1/apis/createClusterProxy.ts](../../examples/secp256k1/apis/createClusterProxy.ts) 

### transferClusterProxy

```typescript
declare function transferClusterProxy(props: {
  outPoint: OutPoint;
  toLock: Script;
  fromInfos?: FromInfo[];
  changeAddress?: Address;
  useCapacityMarginAsFee?: boolean;
  updateOutput?: (cell: Cell) => Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  updateWitness?: HexString | ((witness: HexString) => HexString);
  defaultWitness?: HexString;
  since?: PackedSince;
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
  outputIndex: number;
}>;
```

#### Example

- [examples/secp256k1/apis/transferClusterProxy.ts](../../examples/secp256k1/apis/transferClusterProxy.ts) 

### meltClusterProxy

```typescript
declare function meltClusterProxy(props: {
  outPoint: OutPoint;
  toLock: Script;
  minPayment?: BIish;
  fromInfos?: FromInfo[];
  changeAddress?: Address;
  useCapacityMarginAsFee?: boolean;
  updateOutput?: (cell: Cell) => Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  updateWitness?: HexString | ((witness: HexString) => HexString);
  defaultWitness?: HexString;
  since?: PackedSince;
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
  outputIndex: number;
}>;
```

#### Example

- [examples/secp256k1/apis/meltClusterProxy.ts](../../examples/secp256k1/apis/meltClusterProxy.ts) 

## ClusterAgent

### createClusterAgent

```typescript
declare function createClusterAgent(props: {
  clusterProxyOutPoint: OutPoint;
  referenceType: 'cell' | 'payment';
  paymentAmount?: BIish | ((minPayment: BI) => BIish);
  toLock: Script;
  fromInfos: FromInfo[];
  changeAddress?: Address;
  updateOutput?: (cell: Cell) => Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  clusterProxy?: {
    updateOutput?: (cell: Cell) => Cell;
    capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
    updateWitness?: HexString | ((witness: HexString) => HexString);
  };
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  outputIndex: number;
  reference: {
    referenceType: 'cell' | 'payment';
    clusterProxy?: {
      inputIndex: number;
      outputIndex: number;
    };
    payment?: {
      outputIndex: number;
    };
  };
}>;
```

#### Example

- [examples/secp256k1/apis/createClusterAgent.ts](../../examples/secp256k1/apis/createClusterAgent.ts)

### transferClusterAgent

```typescript
declare function transferClusterAgent(props: {
  outPoint: OutPoint;
  toLock: Script;
  fromInfos?: FromInfo[];
  changeAddress?: Address;
  useCapacityMarginAsFee?: boolean;
  updateOutput?: (cell: Cell) => Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  updateWitness?: HexString | ((witness: HexString) => HexString);
  defaultWitness?: HexString;
  since?: PackedSince;
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
  outputIndex: number;
}>;
```

#### Example

- [examples/secp256k1/apis/transferClusterAgent.ts](../../examples/secp256k1/apis/transferClusterAgent.ts)

### meltClusterAgent

```typescript
declare function meltClusterAgent(props: {
  outPoint: OutPoint;
  changeAddress?: Address;
  updateWitness?: HexString | ((witness: HexString) => HexString);
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
}>;
```

#### Example

- [examples/secp256k1/apis/meltClusterAgent.ts](../../examples/secp256k1/apis/meltClusterAgent.ts) 


================================================
File: docs/core/joint-apis.md
================================================
# Joint APIs

> This documentation is a work in progress.

================================================
File: docs/core/setup.md
================================================

# Start using Spore SDK

## Installation

Install `@spore-sdk/core` as a dependency using any package manager, such as `npm`:

```shell
npm install @spore-sdk/core
```

## Browser environment

Spore SDK is built on top of [Lumos](https://github.com/ckb-js/lumos), an open-source dapp framework for Nervos CKB. Lumos incorporates certain Node-polyfills into its implementation to provide specific functionalities, such as:

- `crypto-browserify` 
- `buffer`

If you wish to use the Spore SDK in a browser environment, it's important to manually add Node-polyfills to your application. This ensures that the Spore SDK functions properly in the browser. Visit: [CRA, Vite, Webpack or Other](https://lumos-website.vercel.app/recipes/cra-vite-webpack-or-other).


================================================
File: docs/core/utilities.md
================================================
# Utilities

<!-- TOC -->
* [Utilities](#utilities)
  * [SporeConfig](#sporeconfig)
    * [getSporeConfig](#getsporeconfig)
      * [Example](#example)
    * [setSporeConfig](#setsporeconfig)
      * [Example](#example-1)
    * [forkSporeConfig](#forksporeconfig)
      * [Example](#example-2)
  * [SporeScript](#sporescript)
    * [getSporeScript](#getsporescript)
      * [Example](#example-3)
    * [isSporeScriptSupported](#issporescriptsupported)
      * [Example](#example-4)
  * [RawString](#rawstring)
    * [bytifyRawString](#bytifyrawstring)
      * [Example](#example-5)
    * [bufferToRawString](#buffertorawstring)
      * [Example](#example-6)
  * [ContentType](#contenttype)
    * [encodeContentType](#encodecontenttype)
      * [Example](#example-7)
    * [decodeContentType](#decodecontenttype)
      * [Example](#example-8)
    * [isContentTypeValid](#iscontenttypevalid)
      * [Example](#example-9)
  * [Transaction](#transaction)
    * [waitForTransaction](#waitfortransaction)
      * [Example](#example-10)
<!-- TOC -->

## SporeConfig

### getSporeConfig

Get the global default SporeConfig.
The default config is "predefinedSporeConfigs.Aggron4".

```typescript
declare function getSporeConfig<T extends string = string>(): SporeConfig<T>;
```

#### Example

```typescript
const config = getSporeConfig();
```

### setSporeConfig

Set the global default SporeConfig.
The default config is "predefinedSporeConfigs.Aggron4".

```typescript
declare function setSporeConfig<T extends string = string>(config: SporeConfig<T>): void; 
```

#### Example

```typescript
setSporeConfig(predefinedSporeConfigs.Aggron4);
```

### forkSporeConfig

Clone and create a new SporeConfig.

```typescript
declare function forkSporeConfig<T1 extends string, T2 extends string>(
  origin: SporeConfig<T1>,
  change: Partial<SporeConfig<T2>>,
): SporeConfig<T1 | T2>;
```

#### Example

```typescript
const originalConfig = predefinedSporeConfigs.Aggron4;
const forkedConfig = forkSporeConfig(originalConfig, {
  maxTransactionSize: 100,
});
```

## SporeScript

### getSporeScript

Get a specific SporeScript from SporeConfig by "scriptName" with optional "scriptId" or "tags".
Throws an error if the script doesn't exist.

```typescript
declare function getSporeScript(config: SporeConfig, scriptName: string): SporeScript;
declare function getSporeScript(config: SporeConfig, scriptName: string, tags: string[]): SporeScript;
declare function getSporeScript(config: SporeConfig, scriptName: string, scriptId: ScriptId): SporeScript;
```

#### Example

Getting the latest version of the "Spore" script:

```typescript
const sporeScript = getSporeScript(config, 'Spore');
```

Getting the latest "Spore" script with the "latest" tag:

```typescript
const sporeScript = getSporeScript(config, 'Spore', ['latest']);
```

Getting the exact "Spore" script with the specified ScriptId:

```typescript
const sporeScript = getSporeScript(config, 'Spore', {
  codehash: '0xbbad126377d45f90a8ee120da988a2d7332c78ba8fd679aab478a19d6c133494',
  hashType: 'data1',
});
```

### isSporeScriptSupported

Returns a boolean indicating whether the target ScriptId exists in the SporeConfig.
If "scriptName" is passed, it also checks whether the name of the target script matches.

```typescript
declare function isSporeScriptSupported(config: SporeConfig, scriptId: ScriptId, scriptName?: string): boolean;
```

#### Example

Check if the target cell is a script supported by the SporeConfig:

```typescript
const cell: Cell = { ... };
const isSupported = isSporeScriptSupported(config, cell.cellOutput.type, 'Spore');
console.log(isSupported); // true or false
```

Check if the target cell is a Spore:

```typescript
const cell: Cell = { ... };
const isSupported = isSporeScriptSupported(config, cell.cellOutput.type, 'Spore');
console.log(isSupported); // true or false
```

## RawString

### bytifyRawString

Pack UTF-8 raw string to Uint8Array.

```typescript
declare function bytifyRawString(text: string): Uint8Array;
```

#### Example

```typescript
const bytes: Uint8Array = bytifyRawString('hello world');
console.log(bytes.hexify(bytes)); // 0x07000000636f6e74656e74
```

### bufferToRawString

Unpack Uint8Array to UTF-8 raw string.

```typescript
declare function bufferToRawString(source: BytesLike, options?: TextDecodeOptions): string;
```

#### Example

```typescript
const text: string = bufferToRawString('0x07000000636f6e74656e74');
console.log(text); // content
```

## ContentType

### encodeContentType

Convert ContentType object to string.

```typescript
declare function encodeContentType(encodable: EncodableContentType): string;
```

#### Example

```typescript
const contentType = encodeContentType({
  type: 'image',
  subtype: 'svg+xml',
  parameters: {
    immortal: true,
    q: 0.9,
  },
});
console.log(contentType); // 'image/svg+xml;immortal=true;q=0.9'
```

### decodeContentType

Convert string to ContentType object.

```typescript
declare function decodeContentType(contentType: string): DecodedContentType;
```

#### Example

```typescript
const decoded = decodeContentType('image/svg+xml;immortal=true;q=0.9');
console.log(decoded); // { type: 'image', subtype: 'svg+xml', mediaType: 'image/svg+xml', parameters: { immortal: true, q: 0.9 } }
```

### isContentTypeValid

Check if the target ContentType's format is valid.

```typescript
declare function isContentTypeValid(contentType: string): boolean;
```

#### Example

```typescript
const result1 = isContentTypeValid('image/svg+xml;immortal=true;q=0.9');
console.log(result1); // true

const result2 = isContentTypeValid('image/;test=1');
console.log(result2); // false
```

## Transaction

### waitForTransaction

Wait for a transaction to be committed on-chain.
Will throw an error if the transaction is not committed within approximately 2 minutes.

```typescript
declare function waitForTransaction(hash: Hash, rpc: RPC): Promise<TransactionWithStatus>;
```

#### Example

```typescript
import { RPC } from '@ckb-lumos/lumos';

const rpc = new RPC(predefinedSporeConfigs.Aggron4.ckbNodeUrl);
const tx = await waitForTransaction('0x...', rpc);
```


================================================
File: docs/recipes/capacity-margin.md
================================================
# Pay fee with capacity margin

## What is `capacity margin`

In a typical CKB transaction, the sender usually pays the transaction fee by collecting additional cells from the sender's address and deducting the fee from the collected cells. 

However, the Spore SDK provides a built-in support of adjusting the capacity margin of cluster/spore cells, which allows the sender to pay fees by a cluster/spore cell's capacity margin, instead of collecting additional cells while transaction's construction.

The usages of capacity margin for spores/clusters:

- **Adjusting capacity margin**

  The sender can put an additional amount of CKBytes as capacity margin into the target cell. For example, if creating a spore requires 200 CKBytes of capacity, the sender can put an extra 1 CKByte into the new spore when creating it.

- **Use capacity margin as fee**

  When transferring a spore/cluster, if the target cell's capacity has enough margins to pay for the transaction fee, the sender can decide whether to use capacity margin as the transaction fee or not.

## Use the feature

### When creating spores/clusters

When creating a spore/cluster, the sender can add additional CKBytes to the new cell's capacity as margin. 

For example, when creating a spore that requires 200 CKB of capacity to be declared in the cell, the sender can put 1 additional CKB into the cell's capacity, so the new spore cell will have 201 CKB of total capacity, and it has 1 CKB of capacity margin can be used in other transactions to pay for transaction fees.

By default, a new spore/cluster will have `1 CKB` (100,000,000 shannons) of additional capacity as margin, to adjust the margin for the new spore/cluster, set the `capacityMargin` prop:

```typescript
import { createSpore } from '@spore-sdk/core';
import { BI } from '@ckb-lumos/lumos';

const result = await createSpore({
  data: NEW_SPORE_DATA,
  toLock: OWNER_LOCK_SCRIPT,
  fromInfos: [OWNER_ADDRESS],
  capacityMargin: BI.from(2_0000_0000), // 2 CKB
});
```

Or set the `capacityMargin` to `0`, so the new spore/cluster will have no margin:

```typescript
import { createSpore } from '@spore-sdk/core';
import { BI } from '@ckb-lumos/lumos';

const result = await createSpore({
  data: NEW_SPORE_DATA,
  toLock: OWNER_LOCK_SCRIPT,
  fromInfos: [OWNER_ADDRESS],
  capacityMargin: BI.from(0), // No capacity margin will be added
});
```

Note that only spores/clusters with capacity margin can be used to pay fees. 
If the sender tries to transfer a spore/cluster with no margin in its capacity, 
the sender has to collect additional cells to pay for the fee.

### When transferring spores/clusters

By default, the Spore SDK will use capacity margin to pay fee when transferring a spore/cluster. As an example, the sender doesn't have to configure anything when transferring a spore:

```typescript
import { transferSpore } from '@spore-sdk/core';
import { BI } from '@ckb-lumos/lumos';

const result = await transferSpore({
  outPoint: LIVE_SPORE_OUTPOINT,
  toLock: RECEIVER_LOCK,
});
```

To disable the feature and use the general method to pay fee instead, set the `useCapacityMarginAsFee` to `false` in the props. Note that disabling the feature also requires the `fromInfos` to be included in the props:

```typescript
import { transferSpore } from '@spore-sdk/core';
import { BI } from '@ckb-lumos/lumos';

const result = await transferSpore({
  outPoint: LIVE_SPORE_OUTPOINT,
  toLock: RECEIVER_LOCK,
  fromInfos: [OWNER_ADDRESS],
  useCapacityMarginAsFee: false,
});
```

## Q & A

### How much capacity margin is enough?

By default, a new spore/cluster has `1 CKB` of additional capacity as margin. To visualize it, let's take this transaction as an example (you can open the link in the browser):

```
https://pudge.explorer.nervos.org/transaction/0x9beeba56006cb77a01d21373d8db9c9bd0371b229c7c8362c2b1b09c67aa9e6e
```

The above transaction transfers a spore from A to B, 
and the transaction fee was `0.00000955 CKB` (955 shannons), let's raise it as `0.00001 CKB` (1,000 shannons).

So if a spore has `1 CKB` (100,000,000 shannons) of additional capacity as margin, let's calculate:

```
100000000 / 1000 = 100,000
```

Based on the above calculation, we estimate that the margin of `1 CKB` is enough to cover the transaction fee by about `100,000` times, which is a lot. 

In conclusion, `1 CKB` is a decent amount of capacity margin, and most of the time you don't have to worry about paying fees.


### What happens if a cell's capacity margin runs out?

This can be seen as a rare condition as if the owner has put a reasonable amount of additional capacity into the cell as margin. However, if it happens, the transaction will fail because the cell has no enough capacity to pay fee, and then the owner should do the following to "fill up the gas":

1. Transfer the cell from the owner to itself
2. Set the `capacityMargin` to add additional capacity as margin
3. Pay the current transaction's fee without using capacity margin

Let's take `transferSpore` as an example:

```typescript
import { transferSpore } from '@spore-sdk/core';
import { BI } from '@ckb-lumos/lumos';

const result = await transferSpore({
  outPoint: LIVE_SPORE_OUTPOINT,
  toLock: OWNER_LOCK_SCRIPT,
  fromInfos: [OWNER_ADDRESS],
  capacityMargin: BI.from(1_0000_0000), // Add 1 CKB as margin, default to 0
  useCapacityMarginAsFee: false, // Disable the feature, default to true
});
```

> Note: When specifying `capacityMargin`, the `useCapacityMarginAsFee` prop cannot be `true` at the same time, otherwise it cannot pass the validation.

================================================
File: docs/recipes/configure-spore-config.md
================================================
# Configure Spore SDK with SporeConfig

## What is SporeConfig

To create a spore on-chain, the Spore SDK needs to know the `ScriptId`/`CellDep` of the `SporeType` script.
And when a transaction is ready to be sent on-chain, the Spore SDK needs to know the URL of the target RPC.
Everything required by the Spore SDK is designed to be stored in a SporeConfig, which is a context object that stores/passes information.

A SporeConfig object will have the following properties:

> For the original/detailed type definition of SporeConfig, 
> refer to: [@spore-sdk/core/src/config/types.ts](../../packages/core/src/config/types.ts).

- `lumos`: Config for lumos. Refer to: [@ckb-lumos/config-manager](https://github.com/ckb-js/lumos/tree/develop/packages/config-manager).
- `ckbNodeUrl`: CKB RPC node's URL, will be used when creating lumos/rpc instances. Refer to: [@ckb-lumos/rpc](https://github.com/ckb-js/lumos/tree/develop/packages/rpc).
- `ckbIndexerUrl`: CKB Indexer node's URL, will be used when creating lumos/ckb-indexer instances. Refer to: [@ckb-lumos/ckb-indexer](https://github.com/ckb-js/lumos/tree/develop/packages/ckb-indexer).
- `maxTransactionSize`: Specify the maximum size (in bytes) of single transactions, will be used in variants of APIs to prevent constructing oversize transactions.
- `scripts`: Define necessary script infos, etc. ScriptId, CellDep. For instance, the Spore SDK will use the script infos of Spore and Cluster.
- `extensions`: Define what SporeExtension(s) to be used in the Spore SDK. Note: this part is WIP (working in progress).

## Common usages

### Use the predefined configs

When using the Spore SDK, developers might want to specify a SporeConfig to make actions on a target environment. The Spore SDK provides a `predefinedSporeConfigs` with mainnet/testnet predefined configurations for developers to switch to these environments faster, which contains:

- `Testnet`: A SporeConfig object containing Spore Protocol infos on CKB Testnet.
- `Mainnet`: A SporeConfig object containing Spore Protocol infos on CKB Mainnet.

The Spore SDK uses `predefinedSporeConfigs.Testnet` as the default config.  
But for example, if you want to create a spore on mainnet instead of testnet, specify it like this:

```typescript
import { predefinedSporeConfigs, createSpore } from '@spore-sdk/core';

const result = await createSpore({
  data: {
    contentType: 'image/jpeg',
    content: JPEG_AS_BYTES,
  },
  fromInfos: [WALLET_ADDRESS],
  toLock: WALLET_LOCK,
  config: predefinedSporeConfigs.Lina, // using the mainnet config
});
```

### Set config globally

To use a SporeConfig without passing it everywhere:

```typescript
import { predefinedSporeConfigs, setSporeConfig, createSpore } from '@spore-sdk/core';

// Setting testnet config as the global default
setSporeConfig(predefinedSporeConfigs.Testnet);

// No need to pass the config object in the props
const result = await createSpore({
  data: {
    contentType: 'image/jpeg',
    content: JPEG_AS_BYTES,
  },
  fromInfos: [WALLET_ADDRESS],
  toLock: WALLET_LOCK,
});
```

### Fork a predefined config

When some properties in a predefined SporeConfig is not fit for a developer, the developer can fork the predefined config and create a new one. For example, if a developer can tune down the `maxTransactionSize` number in the testnet's config like this: 

```typescript
import { predefinedSporeConfigs, forkSporeConfig } from '@spore-sdk/core';

// The forked config is a deep clone of the original config 
const newConfig = forkSporeConfig(predefinedSporeConfigs.Testnet, {
  maxTransactionSize: 100,
});

// The two configs has different maxTransactionSize values
console.log(newConfig.maxTransactionSize === predefinedSporeConfigs.Testnet); // false
```




================================================
File: docs/recipes/construct-transaction.md
================================================

# Construct transactions with Spore SDK

## The Spore SDK

As an SDK designed to interact with the Spore Protocol, the primary mission of the Spore SDK is to provide developers with everything necessary to engage with the spores/clusters on-chain. 

Key functionalities of the Spore SDK:

1. Construct spores/clusters transactions
2. Encode and decode the cell data of spores/clusters
3. Simplify application and service development with helpful utilities

So, let's start by peeling off a corner of the Spore SDK. 
The following instructions will focus on the first functionality, demonstrating how to create a spore on-chain using Spore SDK by constructing a transaction.

## Create a transaction

Take the [@spore-examples/secp256k1](../../examples/secp256k1/apis/createSpore.ts) as an example to understand how to create an on-chain spore using `@spore-sdk/core`. The transaction process involves the following steps:

1. Construct a transaction by filling in the inputs and outputs
2. Sign the transaction using a connected wallet
3. Send the transaction via RPC

The SDK's responsibility is to handle the first step to construct a transaction. As a developer, you are expected to complete the remaining steps. With that said, let's see how to construct a transaction for creating a spore on-chain:

```typescript
import { createSpore, SporeConfig } from '@spore-sdk/core';

const createSporeResult = await createSpore({
  data: {
    contentType: 'image/jpeg',
    content: JPEG_AS_BYTES,
  },
  fromInfos: [WALLET_ADDRESS],
  toLock: WALLET_LOCK,
});
```

The above `createSpore` function constructs a TransactionSkeleton with inputs and outputs, along with filled placeholders for witnesses. The entire process can be briefly summarized as follows:

1. Create an empty TransactionSkeleton
2. Create a spore and add it to TransactionSkeleton.outputs
3. Collect CKBytes from `WALLET_ADDRESS` to TransactionSkeleton.inputs
4. Fill each input's corresponding witness with a placeholder (if necessary)
5. Add related cell deps to TransactionSkeleton.cellDeps
6. Update the spore and generate an ID for it

As a result, a `createSporeResult` object is returned, which contains:

- `txSkeleton`: A [TransactionSkeleton](https://github.com/ckb-js/lumos/blob/develop/packages/helpers/src/index.ts#L314-L339) is an immutable object representing the context of an unfinished transaction. You can continue updating its content until it is ready to be sent via RPC.
- `outputIndex`: The new spore's output index in the TransactionSkeleton.
- `cluster`: An object that specifies the input/output index of the new spore's dependent cluster in the TransactionSkeleton, if the latter exists.

The SDK's responsibility ends here. However, the TransactionSkeleton still needs to be signed before it can be sent via RPC.

## Sign a transaction

By signing a transaction, you provide ownership verification for all cells (inputs/outputs) that require it. In the case of the `createSpore` function, it typically only needs to validate the collected input cells associated with the `WALLET_ADDRESS`, as discussed earlier.

> For instructions on how to sign a transaction, refer to: [How to sign transaction](https://github.com/nervosnetwork/ckb-system-scripts/wiki/How-to-sign-transaction).

> For code example of signing Secp256k1Blake160 inputs, refer to: [examples/secp256k1/utils/wallet.ts](../../examples/secp256k1/utils/wallet.ts).

## Send a transaction

A signed TransactionSkeleton is considered complete.
Now, let's convert the TransactionSkeleton into a Transaction and send it via RPC.

```typescript
import { predefinedSporeConfigs } from '@spore-sdk/core';
import { helpers, RPC } from '@ckb-lumos/lumos';

// Get testnet config
const config = predefinedSporeConfigs.Testnet;

// Convert TransactionSkeleton to Transaction
const tx = helpers.createTransactionFromSkeleton(txSkeleton);

// Send the transaction
const rpc = new RPC(config.ckbNodeUrl);
const hash = await rpc.sendTransaction(tx, 'passthrough');
```

The `hash` variable at the end of the above code block is the outcome of the entire process. It represents the `Transaction Hash` of the transaction just sent. You can utilize this hash to query and review the transaction details.

Copy the `hash` and visit the [CKB Explorer (Testnet)](https://pudge.explorer.nervos.org/) website to search for the transaction. In the transaction's details, you should find a cell in the outputs representing the spore you just created on-chain.

> Additionally, if you want to decode the spores' data and verify its accuracy, you can copy the cell's data and follow the recipe provided to decode it: [Handle spore/cluster data](./handle-cell-data.md).


================================================
File: docs/recipes/create-immortal-spore.md
================================================
# Create immortal spores on-chain

## What is `immortal`

`Immortal` serves as a Spore Extension that offers the following rules:

1. Immortal extension is enabled for a spore if the spore has a `immortal=true` in its `SporeData.contentType`
2. An immortal spore lives on-chain forever, and cannot be melted under any circumstances

To create a spore with the immortal extension enabled, you need to pass the `immortal` parameter to the props of the `createSpore` API when calling it. 

Once an immortal spore is successfully created, any attempt from the owner to melt it will fail due to the verification by the `SporeType` script.

## Create immortal spores

There are two recommended ways to set the `immortal` parameters while creating a spore. Both approaches are equally valid and will successfully achieve the intended result. Feel free to choose the one you prefer.

### Specify in the `contentTypeParameters` object

```typescript
import { createSpore } from '@spore-sdk/core';

let { txSkeleton } = await createSpore({
  data: {
    content: JPEG_AS_BYTES,
    contentType: 'image/jpeg',
    contentTypeParameters: {
      immortal: true, // enabling the immortal extension
    },
  },
  fromInfos: [WALLET_ADDRESS],
  toLock: WALLET_LOCK_SCRIPT,
});
```

### Use the `setContentTypeParameters` function

```typescript
import { createSpore, setContentTypeParameters } from '@spore-sdk/core';

let { txSkeleton } = await createSpore({
  data: {
    content: JPEG_AS_BYTES,
    contentType: setContentTypeParameters(
      'image/jpeg', 
      {
        immortal: true, // enabling the immortal extension
      }
    ),
  },
  fromInfos: [WALLET_ADDRESS],
  toLock: WALLET_LOCK_SCRIPT,
});
```

================================================
File: docs/recipes/handle-cell-data.md
================================================
# Handle spore/cluster data

## ClusterData

An on-chain cluster's `Cell.data` is encoded by its molecule: ClusterData. 

To handle it manually would be a difficult thing to do, therefore `@spore-sdk/core` provides two helper functions: `ClusterData.pack` and `ClusterData.unpack`.  

Encoding ClusterData:

```typescript
import { ClusterData, bytifyRawString } from '@spore-sdk/core';
import { bytes } from '@ckb-lumos/codec';

const encodedClusterData = ClusterData.pack({
  name: bytifyRawString('cluster name'),
  description: bytifyRawString('description of the cluster'),
});

console.log(encodedClusterData); // Uint8Array [ ... ]
console.log(bytes.hexify(encodedClusterData)); // 0x3a0000000c0000001c0000000c000000636c7573746572206e616d651a0000006465736372697074696f6e206f662074686520636c7573746572
```

Decoding ClusterData:

```typescript
import { ClusterData, bufferToRawString } from '@spore-sdk/core';

const clusterDataHex = '0x3a0000000c0000001c0000000c000000636c7573746572206e616d651a0000006465736372697074696f6e206f662074686520636c7573746572';
const decodedClusterData = ClusterData.unpack(clusterDataHex);

console.log(decodedClusterData);
// {
//   name: '0x636c7573746572206e616d65',
//   description: '0x6465736372697074696f6e206f662074686520636c7573746572'
// }

console.log(bufferToRawString(decodedClusterData.name)); // cluster name
```

## SporeData

An on-chain spore's `Cell.data` is encoded by its molecule: SporeData.

To handle it manually would be a difficult thing to do, therefore `@spore-sdk/core` provides two helper functions: `SporeData.pack` and `SporeData.unpack`.

Encoding SporeData:

```typescript
import { SporeData, bytifyRawString } from '@spore-sdk/core';
import { bytes } from '@ckb-lumos/codec';

const encodedSporeData = SporeData.pack({
  // specifies the file type of the content
  contentType: bytifyRawString('image/jpeg'),
  // jpeg file as bytes or hex
  content: '0xffd8ffe000104a46494600010101004800480000ffdb0043000a07070807060a0808080b0a0a0b0e18100e0d0d0e1d15161118231f2524221f2221262b372f26293429212230413134393b3e3e3e252e4449433c48373d3e3bffdb0043010a0b0b0e0d0e1c10101c3b2822283b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3bffc0001108000a000a03012200021101031101ffc4001500010100000000000000000000000000000407ffc4001f1000030002020301010000000000000000010203040500110621314114ffc40014010100000000000000000000000000000000ffc40014110100000000000000000000000000000000ffda000c03010002110311003f0064773b5c2d6f9b6c2db3cc7c76ced8e1499eec7f8dd10b40a127a9a92ce9ebd9631007de50fc4ed5c9f0ed2def57ad6baf83d28ec599d8cd49249fa49fde29f4daaa62e462beb30db1f2aa6d91230529672412cc3ae99bb00f67dfa1c4c632c684e10924a5250939a28554503a0001f001f9c0ffd9',
});

console.log(encodedSporeData); // Uint8Array [ ... ]
console.log(bytes.hexify(encodedSporeData)); // 0x42020000100000001e000000420200000a000000696d6167652f6a706567200200002f396a2f34414151536b5a4a5267414241514541534142494141442f3277424441416f484277674842676f494341674c43676f4c446867514467304e44683056466845594978386c4a4349664969456d4b7a63764a696b304b5345694d4545784e446b37506a342b4a53354553554d3853446339506a762f3277424441516f4c4377344e44687751454277374b43496f4f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a762f774141524341414b41416f444153494141684542417845422f3851414651414241514141414141414141414141414141414141414241662f7841416645414144414149434177454241414141414141414141414241674d4542514152426945785152542f784141554151454141414141414141414141414141414141414141412f38514146424542414141414141414141414141414141414141414141502f61414177444151414345514d52414438415a486337584331766d327774733878386473375934556d6537482b4e305174416f53657071537a7036396c6a454166655550784f31636e773753337656363172723450536a73575a324d314a4a4a2b6b6e393470394e71715975526976724d4e73664b71625a456a42536c6e4a424c4d4f756d627341396e33364845786a4c47684f454a4a4b556c43546d69685652514f6741423841483577502f5a
```

Decoding SporeData:

```typescript
import { SporeData, bufferToRawString } from '@spore-sdk/core';

const sporeDataHex = '0x42020000100000001e000000420200000a000000696d6167652f6a706567200200002f396a2f34414151536b5a4a5267414241514541534142494141442f3277424441416f484277674842676f494341674c43676f4c446867514467304e44683056466845594978386c4a4349664969456d4b7a63764a696b304b5345694d4545784e446b37506a342b4a53354553554d3853446339506a762f3277424441516f4c4377344e44687751454277374b43496f4f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a762f774141524341414b41416f444153494141684542417845422f3851414651414241514141414141414141414141414141414141414241662f7841416645414144414149434177454241414141414141414141414241674d4542514152426945785152542f784141554151454141414141414141414141414141414141414141412f38514146424542414141414141414141414141414141414141414141502f61414177444151414345514d52414438415a486337584331766d327774733878386473375934556d6537482b4e305174416f53657071537a7036396c6a454166655550784f31636e773753337656363172723450536a73575a324d314a4a4a2b6b6e393470394e71715975526976724d4e73664b71625a456a42536c6e4a424c4d4f756d627341396e33364845786a4c47684f454a4a4b556c43546d69685652514f6741423841483577502f5a';
const decodedSporeData = SporeData.unpack(sporeDataHex);

console.log(decodedSporeData);
// {
//   contentType: '0x696d6167652f6a706567',
//   content: '0x2f396a2f34414151536b5a4a5267414241514541534142494141442f3277424441416f484277674842676f494341674c43676f4c446867514467304e44683056466845594978386c4a4349664969456d4b7a63764a696b304b5345694d4545784e446b37506a342b4a53354553554d3853446339506a762f3277424441516f4c4377344e44687751454277374b43496f4f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a73374f7a762f774141524341414b41416f444153494141684542417845422f3851414651414241514141414141414141414141414141414141414241662f7841416645414144414149434177454241414141414141414141414241674d4542514152426945785152542f784141554151454141414141414141414141414141414141414141412f38514146424542414141414141414141414141414141414141414141502f61414177444151414345514d52414438415a486337584331766d327774733878386473375934556d6537482b4e305174416f53657071537a7036396c6a454166655550784f31636e773753337656363172723450536a73575a324d314a4a4a2b6b6e393470394e71715975526976724d4e73664b71625a456a42536c6e4a424c4d4f756d627341396e33364845786a4c47684f454a4a4b556c43546d69685652514f6741423841483577502f5a',
//   clusterId: undefined
// }

console.log(bufferToRawString(decodedSporeData.contentType)); // image/jpeg
```

## SporeData.contentType

SporeData has a contentType property, which specifies the [MIME Type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types) of the spores' content (SporeData.content).

A typical SporeData.contentType: `image/jpeg;a=1;b=2`. We can see it is a string composed of two parts, `MediaType` (image/jpeg) and `Parameters` (a=1;b=2). 

Let's decode the above example to view the full structure:

- Type: "image"
- Subtype: "jpeg"
- MediaType: "image/jpeg"
- Parameters: { a: "1", b: "2" }

The full structure of the SporeData.contentType should be clear now. Encoding/decoding of SporeData.contentType manually is difficult, therefore `@spore-sdk/core` provides some helper functions, so developers can handle it without worries. 

Encoding SporeData.contentType:

```typescript
import { encodeContentType, decodeContentType } from '@spore-sdk/core';

const encoded = encodeContentType({
  type: 'image',
  subtype: 'jpeg',
  parameters: {
    a: 1,
  },
});

console.log(encoded); // image/jpeg;a=1
```

Decoding SporeData.contentType:

```typescript
import { encodeContentType, decodeContentType } from '@spore-sdk/core';

const decoded = decodeContentType('image/jpeg;a=1;a=2');

console.log(decoded);
// {
//   type: 'image',
//   subtype: 'jpeg',
//   mediaType: 'image/jpeg',
//   parameters: {
//     a: 1,
//   },
// }
```

Updating the parameters of SporeData.contentType:

```typescript
import { setContentTypeParameters } from '@spore-sdk/core';

const contentType = 'image/jpeg;a=1;b=3';
const modified = setContentTypeParameters(contentType, { 
  a: 2, 
});

console.log(modified); // image/jpeg;a=2;b=3
```

================================================
File: docs/resources/demos.md
================================================
---
sidebar_position: 3
sidebar_label: Demos
---

# Spore Demos

Spore Demos are web application demos that can be run in a browser environment.

The demos are more complete projects than the [Spore Examples](./examples.md), developers can study from the demos to understand how fully functional web applications are developed. 
For example, how to connect wallets like [MetaMask](https://metamask.io) or [JoyID](https://joy.id).

### The gallery app

A Spore Protocol Demo based on Next.js + React + Spore SDK, which implements basic functionalities, such as the creation and transfer of clusters, as well as minting, transferring, and melting of spores. 

The demo also shows how to connect with [MetaMask](https://metamask.io) and [JoyID](https://joy.id) wallets.

- [Online A-simple-demo app](https://a-simple-demo.spore.pro)
- [GitHub repository](https://github.com/sporeprotocol/spore-demo)

### Blog app with Spore

A demo from the step-by-step tutorial on creating simple on-chain Blog app with Spore Protocol. Learn how to connect wallet, create your own blog cluster and post blogs within it.

- [Follow the Create on-chain blog tutorial](https://docs.spore.pro/tutorials/create-on-chain-blog)
- [Online on-chain blog demo](https://spore-blog-tutorial.vercel.app)
- [GitHub repository](https://github.com/sporeprotocol/spore-blog-tutorial)


================================================
File: docs/resources/examples.md
================================================
# Spore Examples

Here we provide several examples which are minimum viable snippets designed for a Node environment, each showcasing a specific feature implemented using the [Spore SDK](../..).

These examples serve as practical guides for developers, demonstrating how to implement specific features in a straightforward manner, for instance, how to create a spore by a transaction with Spore SDK. And for those who are looking for documentation on how to develop a fully functional application, refer to: [Spore Demos](./demos).

## Scenario examples

### [Creating your first spore](https://docs.spore.pro/tutorials/create-first-spore)

[`spore-first-example`](https://github.com/sporeprotocol/spore-first-example) is a hello world example for Spore SDK, showing you how to upload an image file and create a spore on [Nervos CKB](https://www.nervos.org/) in a split second. This is a well-suited code example for beginners to learn the very basics of Spore Protocol.

- Follow the tutorial at [Creating your first spore](https://docs.spore.pro/tutorials/create-first-spore)
- Run the example on [StackBlitz](https://stackblitz.com/github/sporeprotocol/spore-first-example?file=src%2Findex.ts)
- [GitHub repository](https://github.com/sporeprotocol/spore-first-example)

## Lock script examples

### [CKB Default Lock](../../examples/secp256k1)

[CKB Default Lock](https://github.com/nervosnetwork/ckb-system-scripts/blob/master/c/secp256k1_blake160_sighash_all.c) is the most commonly used lock script on [Nervos CKB](https://www.nervos.org/), also a great starting point for beginners due to its simplicity. You can create private assets with the CKB Default Lock for safeguarding ownership of your private assets.

- [Check CKB Default Lock examples](../../examples/secp256k1)

### [Anyone-can-pay](../../examples/acp)

[Anyone-can-pay](https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0026-anyone-can-pay/0026-anyone-can-pay.md) (ACP) lock can be unlocked by anyone without signature verification and accepts any amount of CKB/UDT payment from the unlocker. You can create public clusters with the Anyone-can-pay lock and benefit from charging other users for creating spores within the public cluster.

- [Check ACP examples](../../examples/acp)

### [Omnilock](../../examples/omnilock)

[Omnilock](https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0042-omnilock/0042-omnilock.md) is a universal and interoperable lock script supporting various blockchains (Bitcoin, Ethereum, EOS, etc.) verification methods and extensible for future additions. Omnilock also supports a [compatible anyone-can-pay mode](https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0042-omnilock/0042-omnilock.md#anyone-can-pay-mode), which allows you to create public clusters using it. You can create private/public spores and clusters with the Omnilock.

- [Check Omnilock examples](../../examples/omnilock)


================================================
File: examples/acp/README.md
================================================
# Spore ACP Examples

## What is `Anyone-can-pay` lock

[Anyone-can-pay](https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0026-anyone-can-pay/0026-anyone-can-pay.md) (ACP) lock is designed to be unlocked by anyone without signature verification and accepts any amount of CKB/UDT payment from the unlocker.
You can create public Clusters with the Anyone-can-pay lock and benefit from charging other users for creating Spores that references the public Clusters.

Refer to the RFC for more detailed rules: [CKB RFC 0026: Anyone-can-pay Lock](https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0026-anyone-can-pay/0026-anyone-can-pay.md#script-structure).

## Featured examples

- [apis/createAcpCluster.ts](./apis/createAcpCluster.ts): Create a public Cluster that can be referenced by any Spore
- [apis/createSporeWithAcpCluster.ts](./apis/createSporeWithAcpCluster.ts): Create a private Spore that references a public Cluster

## Run examples

> Please make sure you've met the pre-requirements:  
> [`Node.js`](https://nodejs.org/) >= 18.0.0  
> [`PNPM`](https://pnpm.io/) >= 8.0.0  

### Setup environment

To set up the local environment, run the following command at the root of the Spore SDK:

```shell
pnpm i && pnpm run build:packages
```

### Run an example

Go to the current directory (`examples/acp`) and run an example:

```shell
ts-node apis/createAcpCluster.ts
```

### Review transaction

This example constructs and sends a transaction that creates a spore on-chain. Once the transaction is sent, a `hash` value should be returned. You can later review the transaction on [CKB Explorer](https://pudge.explorer.nervos.org/):

```shell
https://pudge.explorer.nervos.org/transaction/{hash}
```

## Customization

### Update configs

If you have your own testing accounts, or if you want to configure the SporeConfig of the examples, you can go to the [examples/acp/utils/config.ts](./utils/config.ts) file and update it. Inside the `utils/config.ts` file, you can:

- Replace the default testing accounts with your own
- Modify the default SporeConfig as needed

### Use your own accounts

If you want a clean startup environment for testing the functionality of the Spore SDK, you can replace the default testing accounts with your own accounts. Whether locally or in globally, there has two default testing accounts being used, `CHARLIE` and `ALICE`.

How to replace them:

- Replace locally: For replacing the testing accounts locally (only affects the secp256k1 examples), visit the [examples/acp/utils/config.ts](./utils/config.ts) file and edit the `accounts` variable.
- Replace globally: If you want to replace the testing accounts globally (affects all kinds of examples), you can visit the [examples/shared/index.ts](../shared/index.ts) file and edit the `accounts` variable.

### Generate testing accounts

For those who want to create new accounts for testing the examples, you can follow the steps below to create a new private key and claim some faucet CKBytes.

**1. Generate a new account:** 

1. Open the [Generator Tool](https://ckb.tools/generator) website
2. Click the refresh icon (ğŸ”„) on the page to generate a new account
3. Copy the new account's `Private Key (256-bit)` from the `Private/Public Key` block
4. Replace any of the default testing accounts with the new account

**2. Claim faucet CKBytes for the new account:**

1. Copy the new account's `Nervos CKB Address` from the `Default Lock (Secp256k1-Blake160) - Testnet` block
2. Open the [Nervos Faucet](https://faucet.nervos.org/) website
3. Paste the address into the address input, and click the `Claim` button
4. Wait for a while until the faucet process is completed


================================================
File: examples/acp/package.json
================================================
{
  "name": "@spore-examples/acp",
  "license": "MIT",
  "private": true,
  "scripts": {
    "lint": "prettier --check '{apis,utils}/**/*.{js,jsx,ts,tsx}'",
    "lint:fix": "prettier --write '{apis,utils}/**/*.{js,jsx,ts,tsx}'"
  },
  "dependencies": {
    "@ckb-lumos/lumos": "0.24.0-next.1",
    "@spore-examples/shared": "workspace:^",
    "@spore-sdk/core": "workspace:^",
    "ts-node": "^10.9.1"
  }
}


================================================
File: examples/acp/tsconfig.json
================================================
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "target": "ESNext",
    "module": "CommonJS",
    "skipLibCheck": true,
    "esModuleInterop": true
  }
}


================================================
File: examples/acp/apis/createAcpCluster.ts
================================================
import { createCluster } from '@spore-sdk/core';
import { accounts, config } from '../utils/config';

(async function main() {
  const { CHARLIE } = accounts;

  /**
   * Create an Anyone-can-pay lock from CHARLIE's CKB default lock, adding minimal payment requirement to the Cluster.
   * Anyone who references the lock cell without providing a signature to unlock it, will need to following:
   * - If minCkb is defined, pay at least 10^minCkb shannons to the lock cell as a fee.
   * - If minCkb is undefined, anyone can reference this Cluster without payment.
   *
   * Examples:
   * If minCkb = 10, anyone can pay 10,000,000,000 (10^10) shannons to the Cluster as a fee of referencing it.
   * If minCkb = 0, anyone can pay 1 (10^0) shannon to the Cluster as a fee of referencing it.
   * If minCkb = undefined, anyone can reference this Cluster without payment.
   */
  const CharlieAcpLock = CHARLIE.createAcpLock({
    minCkb: void 0,
  });

  const { txSkeleton, outputIndex } = await createCluster({
    data: {
      name: 'Test acp lock cluster',
      description: 'A public cluster with acp lock',
    },
    fromInfos: [CHARLIE.address],
    toLock: CharlieAcpLock,
    config,
  });

  const hash = await CHARLIE.signAndSendTransaction(txSkeleton);
  console.log('CreateAcpCluster transaction sent, hash:', hash);
  console.log('Cluster output index:', outputIndex);

  const clusterCell = txSkeleton.get('outputs').get(outputIndex)!;
  console.log('Cluster ID:', clusterCell.cellOutput.type!.args);
})();


================================================
File: examples/acp/apis/createSporeWithAcpCluster.ts
================================================
import { BI } from '@ckb-lumos/bi';
import { number } from '@ckb-lumos/codec';
import { createSpore } from '@spore-sdk/core';
import { accounts, config } from '../utils/config';

(async function main() {
  const { CHARLIE } = accounts;

  const { txSkeleton, outputIndex } = await createSpore({
    data: {
      contentType: 'text/plain',
      content: 'spore with public cluster referenced',
      /**
       * When referencing an ACP public Cluster, even if the Cluster doesn't belong to CHARLIE,
       * CHARLIE can still create Spores that reference the Cluster.
       */
      clusterId: '0x4bb8ccd6dc886da947cbe8ac4d51004c9d5335ae1216fda756ac39e4bf665c22',
    },
    toLock: CHARLIE.lock,
    fromInfos: [CHARLIE.address],
    cluster: {
      /**
       * When referencing an ACP public Cluster,
       * you may have to pay at least (10^minCKB) shannons to the Cluster cell as a fee.
       */
      capacityMargin: (clusterCell, margin) => {
        const argsMinCkb = clusterCell.cellOutput.lock.args.slice(42, 2);
        const minCkb = argsMinCkb.length === 2
          ? BI.from(10).pow(number.Uint8.unpack(`0x${argsMinCkb}`))
          : BI.from(0);

        return margin.add(minCkb);
      },
      /**
       * When referencing an ACP public Cluster,
       * the Cluster's corresponding witness should be set to "0x" (empty) and shouldn't be signed.
       */
      updateWitness: '0x',
    },
    config,
  });

  const hash = await CHARLIE.signAndSendTransaction(txSkeleton);
  console.log('CreateSporeWithAcpCluster transaction sent, hash:', hash);
  console.log('Spore output index:', outputIndex);

  const sporeCell = txSkeleton.get('outputs').get(outputIndex)!;
  console.log('Spore ID:', sporeCell.cellOutput.type!.args);
})();


================================================
File: examples/acp/utils/config.ts
================================================
import { sharedTestingPrivateKeys } from '@spore-examples/shared';
import { predefinedSporeConfigs } from '@spore-sdk/core';
import { createSecp256k1Wallet } from './wallet';

/**
 * SporeConfig provides spore/cluster's detailed info like ScriptIds and CellDeps.
 * It is a necessary part for constructing spore/cluster transactions.
 */
export const config = predefinedSporeConfigs.Testnet;

/**
 * Wallets with default testing accounts for running the examples,
 * feel free to replace them with your own testing accounts.
 */
export const accounts = {
  CHARLIE: createSecp256k1Wallet(sharedTestingPrivateKeys.CHARLIE, config),
  ALICE: createSecp256k1Wallet(sharedTestingPrivateKeys.ALICE, config),
};


================================================
File: examples/acp/utils/wallet.ts
================================================
import { SporeConfig, defaultEmptyWitnessArgs } from '@spore-sdk/core';
import { updateWitnessArgs, isScriptValueEquals, isScriptIdEquals } from '@spore-sdk/core';
import { anyoneCanPay, secp256k1Blake160 } from '@ckb-lumos/common-scripts';
import { hd, helpers, HexString, RPC } from '@ckb-lumos/lumos';
import { Address, Hash, Script } from '@ckb-lumos/base';
import { bytes, number } from '@ckb-lumos/codec';

export interface Secp256k1Wallet {
  lock: Script;
  address: Address;
  createAcpLock(props?: { minCkb?: number }): Script;
  signMessage(message: HexString): Hash;
  signTransaction(txSkeleton: helpers.TransactionSkeletonType): helpers.TransactionSkeletonType;
  signAndSendTransaction(txSkeleton: helpers.TransactionSkeletonType): Promise<Hash>;
}

/**
 * Create a Secp256k1Blake160 Sign-all Wallet by a private key and a SporeConfig,
 * providing lock/address, and functions sign message/transaction and send the transaction on-chain.
 *
 * Note: The generated wallet also supports ACP (Anyone-can-pay) lock,
 * since the ACP lock is designed/implemented based on the Secp256k1Blake160 Sign-all lock.
 */
export function createSecp256k1Wallet(privateKey: HexString, config: SporeConfig): Secp256k1Wallet {
  const Secp256k1Blake160 = config.lumos.SCRIPTS.SECP256K1_BLAKE160!;
  const AnyoneCanPay = config.lumos.SCRIPTS.ANYONE_CAN_PAY!;

  // Generate a lock script from the private key
  const blake160 = hd.key.privateKeyToBlake160(privateKey);
  const lock: Script = {
    codeHash: Secp256k1Blake160.CODE_HASH,
    hashType: Secp256k1Blake160.HASH_TYPE,
    args: blake160,
  };

  // Generate address from the lock script
  const address = helpers.encodeToAddress(lock, {
    config: config.lumos,
  });

  // Create an Anyone-can-pay lock script
  // minCkb: The minimal required digit of payment CKBytes.
  // Refer to: https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0026-anyone-can-pay/0026-anyone-can-pay.md
  function createAcpLock(props?: { minCkb?: number }): Script {
    const minCkb = props?.minCkb;
    const minimalCkb = minCkb !== void 0 ? bytes.hexify(number.Uint8.pack(minCkb as number)) : '';
    return {
      codeHash: AnyoneCanPay.CODE_HASH,
      hashType: AnyoneCanPay.HASH_TYPE,
      args: `${blake160}${removeHexPrefix(minimalCkb)}`,
    };
  }

  // Sign for a message
  function signMessage(message: HexString): Hash {
    return hd.key.signRecoverable(message, privateKey);
  }

  // Sign prepared signing entries,
  // and then fill signatures into Transaction.witnesses
  function signTransaction(txSkeleton: helpers.TransactionSkeletonType): helpers.TransactionSkeletonType {
    const signingEntries = txSkeleton.get('signingEntries');
    const signatures = new Map<HexString, Hash>();
    const inputs = txSkeleton.get('inputs');

    let witnesses = txSkeleton.get('witnesses');
    for (let i = 0; i < signingEntries.size; i++) {
      const entry = signingEntries.get(i)!;
      if (entry.type === 'witness_args_lock') {
        const input = inputs.get(entry.index);
        if (!input) {
          continue;
        }
        if (
          !isScriptValueEquals(input.cellOutput.lock, lock) &&
          !isAcpLockMatches(input.cellOutput.lock, blake160, config)
        ) {
          continue;
        }
        if (!signatures.has(entry.message)) {
          const newSignature = signMessage(entry.message);
          signatures.set(entry.message, newSignature);
        }

        const signature = signatures.get(entry.message)!;
        const witness = witnesses.get(entry.index, defaultEmptyWitnessArgs);
        witnesses = witnesses.set(entry.index, updateWitnessArgs(witness, 'lock', signature));
      }
    }

    return txSkeleton.set('witnesses', witnesses);
  }

  // Sign the transaction and send it via RPC
  async function signAndSendTransaction(txSkeleton: helpers.TransactionSkeletonType): Promise<Hash> {
    // Env
    const rpc = new RPC(config.ckbNodeUrl);

    // Sign transaction
    txSkeleton = secp256k1Blake160.prepareSigningEntries(txSkeleton, { config: config.lumos });
    txSkeleton = anyoneCanPay.prepareSigningEntries(txSkeleton, { config: config.lumos });
    txSkeleton = signTransaction(txSkeleton);

    // Convert to Transaction
    const tx = helpers.createTransactionFromSkeleton(txSkeleton);
    console.log(JSON.stringify(tx, null, 2));

    // Send transaction
    return await rpc.sendTransaction(tx, 'passthrough');
  }

  return {
    lock,
    address,
    signMessage,
    signTransaction,
    signAndSendTransaction,
    createAcpLock,
  };
}

export function isAcpLockMatches(lock: Script, blake160: Hash, config: SporeConfig): boolean {
  const AnyoneCanPay = config.lumos.SCRIPTS.ANYONE_CAN_PAY!;
  const acpScriptId = {
    codeHash: AnyoneCanPay.CODE_HASH,
    hashType: AnyoneCanPay.HASH_TYPE,
  };

  return isScriptIdEquals(lock, acpScriptId) && lock.args.startsWith(blake160);
}

function removeHexPrefix(str: string) {
  return str.startsWith('0x') ? str.slice(2) : str;
}


================================================
File: examples/omnilock/README.md
================================================
# Spore Omnilock Examples

## What is `Omnilock` lock

[Omnilock](https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0042-omnilock/0042-omnilock.md) is a universal and interoperable lock script supporting various blockchains' verification methods (Bitcoin, Ethereum, EOS, etc.) and extensible for future additions. You can create private spores and clusters with it for safeguarding ownership of your assets.

Omnilock also supports a [Compatible ACP Mode](https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0042-omnilock/0042-omnilock.md#anyone-can-pay-mode), which allows you to create public Clusters and benefit from charging other users for creating Spores that references the public Clusters. 

Please note that [Omnilock ACP](https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0042-omnilock/0042-omnilock.md#anyone-can-pay-mode) lock differs from the [Anyone-can-pay](https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0026-anyone-can-pay/0026-anyone-can-pay.md) lock in that it does not allow the minimal CKB or UDT (User-Defined Token) payment amount to be configured as `undefined`. This means that each transaction referencing an Omnilock ACP cell should receive a certain amount of payment.

## Featured examples

- [acp/createAcpCluster.ts](./acp/createAcpCluster.ts): Create a public Cluster that can be referenced by any Spore
- [acp/createSporeWithAcpCluster.ts](./acp/createSporeWithAcpCluster.ts): Create a private Spore that references a public Cluster

## Run examples

> Please make sure you've met the pre-requirements:  
> [`Node.js`](https://nodejs.org/) >= 18.0.0  
> [`PNPM`](https://pnpm.io/) >= 8.0.0

### Setup environment

To set up the local environment, run the following command at the root of the Spore SDK:

```shell
pnpm i && pnpm run build:packages
```

### Run an example

Go to the current directory (`examples/omnilock`) and run an example:

```shell
ts-node acp/createAcpCluster.ts
```

### Review transaction

This example constructs and sends a transaction that creates a spore on-chain. Once the transaction is sent, a `hash` value should be returned. You can later review the transaction on [CKB Explorer](https://pudge.explorer.nervos.org/):

```shell
https://pudge.explorer.nervos.org/transaction/{hash}
```

## Customization

### Update configs

If you have your own testing accounts, or if you want to configure the SporeConfig of the examples, you can go to the [examples/omnilock/utils/config.ts](./utils/config.ts) file and update it. Inside the `utils/config.ts` file, you can:

- Replace the default testing accounts with your own
- Modify the default SporeConfig as needed

### Use your own accounts

If you want a clean startup environment for testing the functionality of the Spore SDK, you can replace the default testing accounts with your own accounts. Whether locally or in globally, there has two default testing accounts being used, `CHARLIE` and `ALICE`.

How to replace them:

- Replace locally: For replacing the testing accounts locally (only affects the secp256k1 examples), visit the [examples/omnilock/utils/config.ts](./utils/config.ts) file and edit the `accounts` variable.
- Replace globally: If you want to replace the testing accounts globally (affects all kinds of examples), you can visit the [examples/shared/index.ts](../shared/index.ts) file and edit the `accounts` variable.

### Generate testing accounts

For those who want to create new accounts for testing the examples, you can follow the steps below to create a new private key and claim some faucet CKBytes.

**1. Generate a new account:**

1. Open the [Generator Tool](https://ckb.tools/generator) website
2. Click the refresh icon (ğŸ”„) on the page to generate a new account
3. Copy the new account's `Private Key (256-bit)` from the `Private/Public Key` block
4. Replace any of the default testing accounts with the new account

**2. Claim faucet CKBytes for the new account:**

1. Copy the new account's `Nervos CKB Address` from the `Omni Lock (Ethereum) - Testnet` block
2. Open the [Nervos Faucet](https://faucet.nervos.org/) website
3. Paste the address into the address input, and click the `Claim` button
4. Wait for a while until the faucet process is completed


================================================
File: examples/omnilock/package.json
================================================
{
  "name": "@spore-examples/omnilock",
  "private": true,
  "scripts": {
    "lint": "prettier --check '{acp,utils}/**/*.{js,jsx,ts,tsx}'",
    "lint:fix": "prettier --write '{acp,utils}/**/*.{js,jsx,ts,tsx}'"
  },
  "dependencies": {
    "@ckb-lumos/lumos": "0.24.0-next.1",
    "@spore-examples/shared": "workspace:^",
    "@spore-sdk/core": "workspace:^",
    "lodash": "^4.17.21",
    "ts-node": "^10.9.1"
  }
}


================================================
File: examples/omnilock/tsconfig.json
================================================
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "target": "ESNext",
    "module": "CommonJS",
    "skipLibCheck": true,
    "esModuleInterop": true
  }
}


================================================
File: examples/omnilock/acp/createAcpCluster.ts
================================================
import { createCluster } from '@spore-sdk/core';
import { accounts, config } from '../utils/config';
import { createOmnilockAcpArgs } from '../utils/wallet';

(async function main() {
  const { CHARLIE } = accounts;

  /**
   * Create an Omnilock from CHARLIE's original lock, adding minimal payment requirement to the Cluster.
   * Anyone who references the lock cell without providing a signature to unlock it,
   * will have to pay at least 10^minCkb shannons to the lock cell as a fee.
   *
   * Examples:
   * If minCkb = 10, anyone can pay 10,000,000,000 (10^10) shannons to the Cluster as a fee of referencing it.
   * If minCkb = 0, anyone can pay 1 (10^0) shannon to the Cluster as a fee of referencing it.
   */
  const CharlieOmniAcpLock = CHARLIE.createLock(
    createOmnilockAcpArgs({
      minCkb: 0,
    })
  );

  const { txSkeleton, outputIndex } = await createCluster({
    data: {
      name: 'Test omnilock acp cluster',
      description: 'An public cluster with omnilock',
    },
    fromInfos: [CHARLIE.address],
    toLock: CharlieOmniAcpLock,
    config,
  });

  const hash = await CHARLIE.signAndSendTransaction(txSkeleton);
  console.log('CreateAcpCluster transaction sent, hash:', hash);
  console.log('Cluster output index:', outputIndex);

  const clusterCell = txSkeleton.get('outputs').get(outputIndex)!;
  console.log('Cluster ID:', clusterCell.cellOutput.type!.args);
})();


================================================
File: examples/omnilock/acp/createSporeWithAcpCluster.ts
================================================
import { BI } from '@ckb-lumos/bi';
import { createSpore } from '@spore-sdk/core';
import { accounts, config } from '../utils/config';
import { getInfoFromOmnilockArgs } from '../utils/wallet';

(async function main() {
  const { CHARLIE } = accounts;

  const { txSkeleton, outputIndex } = await createSpore({
    data: {
      contentType: 'text/plain',
      content: 'spore with public cluster referenced',
      /**
       * When referencing an ACP public Cluster, even if the Cluster doesn't belong to CHARLIE,
       * CHARLIE can still create Spores that reference the Cluster.
       */
      clusterId: '0x6c7df3eee9af40d4e0f27356e7dcb02a54e33f7d81a40af57d0de1f3856ab750',
    },
    toLock: CHARLIE.lock,
    fromInfos: [CHARLIE.address],
    cluster: {
      /**
       * When referencing an Omnilock ACP public Cluster,
       * you must pay at least (10^minCKB) shannons to the Cluster cell as a fee.
       *
       * Every Omnilock ACP lock script has a minCkb value defined in its args.
       * The minimal viable minCkb is 0, which means the minimum payment is 1 (10^0) shannon.
       */
      capacityMargin: (clusterCell, margin) => {
        const args = getInfoFromOmnilockArgs(clusterCell.cellOutput.lock.args);
        const minCkb = args.minCkb !== void 0
          ? BI.from(10).pow(args.minCkb)
          : BI.from(0);

        return margin.add(minCkb);
      },
      /**
       * When referencing an ACP public Cluster,
       * the Cluster's corresponding witness should be set to "0x" (empty) and shouldn't be signed.
       */
      updateWitness: '0x',
    },
    config,
  });

  const hash = await CHARLIE.signAndSendTransaction(txSkeleton);
  console.log('CreateSporeWithAcpCluster transaction sent, hash:', hash);
  console.log('Spore output index:', outputIndex);

  const sporeCell = txSkeleton.get('outputs').get(outputIndex)!;
  console.log('Spore ID:', sporeCell.cellOutput.type!.args);
})();


================================================
File: examples/omnilock/utils/config.ts
================================================
import { sharedTestingPrivateKeys } from '@spore-examples/shared';
import { predefinedSporeConfigs } from '@spore-sdk/core';
import { createOmnilockSecp256k1Wallet } from './wallet';

/**
 * SporeConfig provides spore/cluster's detailed info like ScriptIds and CellDeps.
 * It is a necessary part for constructing spore/cluster transactions.
 */
export const config = predefinedSporeConfigs.Testnet;

/**
 * Wallets with default testing accounts for running the examples,
 * feel free to replace them with your own testing accounts.
 */
export const accounts = {
  CHARLIE: createOmnilockSecp256k1Wallet({
    privateKey: sharedTestingPrivateKeys.CHARLIE,
    config,
  }),
  ALICE: createOmnilockSecp256k1Wallet({
    privateKey: sharedTestingPrivateKeys.ALICE,
    config,
  }),
};


================================================
File: examples/omnilock/utils/wallet.ts
================================================
import { SporeConfig, getSporeConfig, isScriptIdEquals } from '@spore-sdk/core';
import { defaultEmptyWitnessArgs, updateWitnessArgs } from '@spore-sdk/core';
import { hd, helpers, HexString, RPC } from '@ckb-lumos/lumos';
import { Address, Hash, Script } from '@ckb-lumos/base';
import { omnilock } from '@ckb-lumos/common-scripts';
import { bytes, number } from '@ckb-lumos/codec';

export interface OmnilockWallet {
  lock: Script;
  address: Address;
  createLock(lockArgs?: HexString): Script;
  isLockAuthEquals(targetLock: Script): boolean;
  signMessage(message: Hash): Promise<Hash> | Hash;
  signTransaction(txSkeleton: helpers.TransactionSkeletonType): Promise<helpers.TransactionSkeletonType>;
  signAndSendTransaction(txSkeleton: helpers.TransactionSkeletonType): Promise<Hash>;
}

/**
 * Create an Omnilock Wallet.
 * This method can be seen as a meta function to create complex Omnilock Based Wallets.
 * Detailed instructions of the Omnilock: https://blog.cryptape.com/omnilock-a-universal-lock-that-powers-interoperability-1
 */
export function createOmnilockWallet(props: {
  lockAuth: HexString;
  lockArgs?: HexString;
  config?: SporeConfig;
  signMessage(message: Hash): Promise<Hash> | Hash;
}): OmnilockWallet {
  const config = props.config ?? getSporeConfig();

  // Generate a lock script from the private key
  const lock = createOmnilockLock(props);

  // Generate address from the lock script
  const address = helpers.encodeToAddress(lock, {
    config: config.lumos,
  });

  // Create an Omnilock lock script based on the current wallet's lock.
  function createLock(lockArgs?: HexString): Script {
    return createOmnilockLock({
      lockAuth: props.lockAuth,
      config: props.config,
      lockArgs,
    });
  }

  // Check if the target lock script has the same auth as the wallet's lock
  function isLockAuthEquals(targetLock: Script): boolean {
    return isScriptIdEquals(lock, targetLock) && targetLock.args.startsWith(props.lockAuth);
  }

  // Sign for a message
  async function signMessage(message: HexString): Promise<Hash> {
    return props.signMessage(message);
  }

  // Sign prepared signing entries,
  // and then fill signatures into Transaction.witnesses
  async function signTransaction(
    txSkeleton: helpers.TransactionSkeletonType,
  ): Promise<helpers.TransactionSkeletonType> {
    const signingEntries = txSkeleton.get('signingEntries');
    const signatures = new Map<HexString, Hash>();
    const inputs = txSkeleton.get('inputs');

    let witnesses = txSkeleton.get('witnesses');
    for (let i = 0; i < signingEntries.size; i++) {
      const entry = signingEntries.get(i)!;
      if (entry.type === 'witness_args_lock') {
        const input = inputs.get(entry.index);
        if (!input || !isLockAuthEquals(input.cellOutput.lock)) {
          continue;
        }
        if (!signatures.has(entry.message)) {
          const newSignature = await signMessage(entry.message);
          signatures.set(entry.message, newSignature);
        }

        const signature = signatures.get(entry.message)!;
        const witness = witnesses.get(entry.index, defaultEmptyWitnessArgs);
        witnesses = witnesses.set(entry.index, updateWitnessArgs(witness, 'lock', signature));
      }
    }

    return txSkeleton.set('witnesses', witnesses);
  }

  // Sign the transaction and send it via RPC
  async function signAndSendTransaction(txSkeleton: helpers.TransactionSkeletonType): Promise<Hash> {
    // Create an RPC instance from a node url defined in the SporeConfig
    const rpc = new RPC(config.ckbNodeUrl);

    // Sign transaction
    txSkeleton = omnilock.prepareSigningEntries(txSkeleton, { config: config.lumos });
    txSkeleton = await signTransaction(txSkeleton);

    // Convert to Transaction
    const tx = helpers.createTransactionFromSkeleton(txSkeleton);
    console.log(JSON.stringify(tx, null, 2));

    // Send transaction
    return await rpc.sendTransaction(tx, 'passthrough');
  }

  return {
    lock,
    address,
    createLock,
    isLockAuthEquals,
    signMessage,
    signTransaction,
    signAndSendTransaction,
  };
}

/**
 * Create an Omnilock wallet with the default auth info of Secp256k1Blake160 Sign-all.
 *
 * The Secp256k1Blake160 Sign-all is represented as 0x00.
 * Refer to: https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0042-omnilock/0042-omnilock.md#authentication
 */
export function createOmnilockSecp256k1Wallet(props: {
  privateKey: HexString;
  lockArgs?: HexString;
  config?: SporeConfig;
}): OmnilockWallet {
  const { privateKey, lockArgs, config } = props;

  function signMessage(message: HexString): Hash {
    const sig = hd.key.signRecoverable(message, privateKey);
    return bytes.hexify(
      omnilock.OmnilockWitnessLock.pack({
        signature: sig,
      }),
    );
  }

  const blake160 = hd.key.privateKeyToBlake160(privateKey);
  const lockAuth = `0x00${removeHexPrefix(blake160)}`;
  return createOmnilockWallet({
    signMessage,
    lockAuth,
    lockArgs,
    config,
  });
}

/**
 * Create an Omnilock lock script.
 */
export function createOmnilockLock(props: { lockAuth: HexString; lockArgs?: HexString; config?: SporeConfig }): Script {
  const config = props.config ?? getSporeConfig();
  const Omnilock = config.lumos.SCRIPTS.OMNILOCK!;
  const omnilockArgs = props.lockArgs ?? '0x00';

  return {
    codeHash: Omnilock.CODE_HASH,
    hashType: Omnilock.HASH_TYPE,
    args: `${props.lockAuth}${removeHexPrefix(omnilockArgs)}`,
  };
}

/**
 * Create ACP Omnilock args with minimalCkb and minimalUdt parameters.
 * minCkb: The minimal required digit of payment CKBytes.
 */
export function createOmnilockAcpArgs(props: {
  minCkb: number,
}): HexString {
  const minimalCkb = bytes.hexify(number.Uint8.pack(props.minCkb ?? 0));
  return `0x02${removeHexPrefix(minimalCkb)}00`;
}

export function getInfoFromOmnilockArgs(args: HexString) {
  args = removeHexPrefix(args);

  // Omnilock args
  const lockArgs = args.slice(42);

  // Function to cut lockArgs content
  let startIndex = 0;
  function getFromLockArgs(length: number) {
    const content = lockArgs.slice(startIndex, startIndex + length);
    startIndex += length;
    return content;
  }

  // Omnilock args flag
  const flag = number.Uint8.unpack(`0x${getFromLockArgs(2)}`);
  const flagArray: number[] = [];
  for (let i = 7; i >= 0; i--) {
    flagArray.push((flag >> i) & 1);
  }

  // Is "administrator mode" enabled
  let adminListCellTypeId: Hash | undefined;
  if (flagArray[7] === 1) {
    adminListCellTypeId = `0x${getFromLockArgs(64)}`;
  }

  // Is "anyone-can-pay mode" enabled
  let minCkb: number | undefined;
  let minUdt: number | undefined;
  if (flagArray[6] === 1) {
    const ckb = getFromLockArgs(2);
    const udt = getFromLockArgs(2);
    minCkb = number.Uint8.unpack(`0x${ckb}`);
    minUdt = number.Uint8.unpack(`0x${udt}`);
  }

  return {
    lockArgs,
    flag,
    flagArray,
    adminListCellTypeId,
    minCkb,
    minUdt,
  };
}

function removeHexPrefix(str: string): string {
  return str.startsWith('0x') ? str.slice(2) : str;
}


================================================
File: examples/secp256k1/README.md
================================================
# Spore Default Lock Examples

## What is `CKB Default Lock`

[CKB Default Lock](https://github.com/nervosnetwork/ckb-system-scripts/blob/master/c/secp256k1_blake160_sighash_all.c) is the most commonly used lock script on [Nervos CKB](https://www.nervos.org), also a great starting point for beginners due to its simplicity. You can create private assets with the CKB Default Lock for safeguarding ownership of your private assets.

CKB Default Lock is also known as the `Secp256k1Blake160 Sign-all` lock. 

## Featured examples

Spore:
- [apis/createSpore.ts](./apis/createSpore.ts): Create a Spore
- [apis/createSporeWithCluster.ts](./apis/createSporeWithCluster.ts): Create a Clustered Spore with a Cluster
- [apis/createSporeWithClusterAgent.ts](./apis/createSporeWithClusterAgent.ts): Create a Clustered Spore with a ClusterAgent
- [apis/transferSpore.ts](./apis/transferSpore.ts): Transfer a Spore to another account
- [apis/meltSpore.ts](./apis/meltSpore.ts): Melt a Spore and redeem the occupied CKBytes

Cluster:
- [apis/createCluster.ts](./apis/createCluster.ts): Create a Cluster
- [apis/transferCluster.ts](./apis/transferCluster.ts): Transfer a Cluster to another account

ClusterProxy:
- [apis/createClusterProxy.ts](./apis/createClusterProxy.ts): Create a ClusterProxy
- [apis/transferClusterProxy.ts](./apis/transferClusterProxy.ts): Transfer a ClusterProxy to another account
- [apis/meltClusterProxy.ts](./apis/meltClusterProxy.ts): Melt a ClusterProxy and redeem the occupied CKBytes

ClusterAgent:
- [apis/createClusterAgent.ts](./apis/createClusterAgent.ts): Create a ClusterAgent
- [apis/transferClusterAgent.ts](./apis/transferClusterAgent.ts): Transfer a ClusterAgent to another account
- [apis/meltClusterAgent.ts](./apis/meltClusterAgent.ts): Melt a ClusterAgent and redeem the occupied CKBytes

## Run examples

> Please make sure you've met the pre-requirements:  
> [`Node.js`](https://nodejs.org/) >= 18.0.0  
> [`PNPM`](https://pnpm.io/) >= 8.0.0  

### Setup environment

To set up the local environment, run the following command at the root of the Spore SDK:

```shell
pnpm i && pnpm run build:packages
```

### Run an example

Go to the current directory (`examples/secp256k1`) and run an example:

```shell
ts-node apis/createSpore.ts
```

### Review transaction

This example constructs and sends a transaction that creates a spore on-chain. Once the transaction is sent, a `hash` value should be returned. You can later review the transaction on [CKB Explorer](https://pudge.explorer.nervos.org/):

```shell
https://pudge.explorer.nervos.org/transaction/{hash}
```

## Customization

### Update configs

If you have your own testing accounts, or if you want to configure the SporeConfig of the examples, you can go to the [examples/secp256k1/utils/config.ts](./utils/config.ts) file and update it. Inside the `utils/config.ts` file, you can:

- Replace the default testing accounts with your own
- Modify the default SporeConfig as needed

### Use your own accounts

If you want a clean startup environment for testing the functionality of the spore-sdk, you can replace the default testing accounts with your own accounts. Whether locally or in globally, there has two default testing accounts being used, `CHARLIE` and `ALICE`.

How to replace them:

- Replace locally: For replacing the testing accounts locally (only affects the secp256k1 examples), visit the [examples/secp256k1/utils/config.ts](./utils/config.ts) file and edit the `accounts` variable.
- Replace globally: If you want to replace the testing accounts globally (affects all kinds of examples), you can visit the [examples/shared/index.ts](../shared/index.ts) file and edit the `accounts` variable.

### Generate testing accounts

For those who want to create new accounts for testing the examples, you can follow the steps below to create a new private key and claim some faucet CKBytes.

**1. Generate a new account:** 

1. Open the [Generator Tool](https://ckb.tools/generator) website
2. Click the refresh icon (ğŸ”„) on the page to generate a new account
3. Copy the new account's `Private Key (256-bit)` from the `Private/Public Key` block
4. Replace any of the default testing accounts with the new account

**2. Claim faucet CKBytes for the new account:**

1. Copy the new account's `Nervos CKB Address` from the `Default Lock (Secp256k1-Blake160) - Testnet` block
2. Open the [Nervos Faucet](https://faucet.nervos.org/) website
3. Paste the address into the address input, and click the `Claim` button
4. Wait for a while until the faucet process is completed


================================================
File: examples/secp256k1/package.json
================================================
{
  "name": "@spore-examples/secp256k1",
  "license": "MIT",
  "private": true,
  "scripts": {
    "lint": "prettier --check '{apis,utils}/**/*.{js,jsx,ts,tsx}'",
    "lint:fix": "prettier --write '{apis,utils}/**/*.{js,jsx,ts,tsx}'"
  },
  "dependencies": {
    "@ckb-lumos/lumos": "0.24.0-next.1",
    "@spore-examples/shared": "workspace:^",
    "@spore-sdk/core": "workspace:^",
    "ts-node": "^10.9.1"
  }
}


================================================
File: examples/secp256k1/tsconfig.json
================================================
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "target": "ESNext",
    "module": "CommonJS",
    "skipLibCheck": true,
    "esModuleInterop": true
  }
}


================================================
File: examples/secp256k1/apis/createCluster.ts
================================================
import { createCluster } from '@spore-sdk/core';
import { accounts, config } from '../utils/config';

(async function main() {
  const { CHARLIE } = accounts;

  const { txSkeleton, outputIndex } = await createCluster({
    data: {
      name: 'Test cluster',
      description: 'Description of the cluster',
    },
    fromInfos: [CHARLIE.address],
    toLock: CHARLIE.lock,
    config,
  });

  const hash = await CHARLIE.signAndSendTransaction(txSkeleton);
  console.log('CreateCluster transaction sent, hash:', hash);
  console.log('Cluster output index:', outputIndex);

  const clusterCell = txSkeleton.get('outputs').get(outputIndex)!;
  console.log('Cluster ID:', clusterCell.cellOutput.type!.args);
})();


================================================
File: examples/secp256k1/apis/createClusterAgent.ts
================================================
import { createClusterAgent, getClusterProxyById } from '@spore-sdk/core';
import { accounts, config } from '../utils/config';
import { BI } from '@ckb-lumos/bi';

(async function main() {
  const { ALICE } = accounts;

  /**
   * The target ClusterProxy's ID you want to create ClusterAgent from.
   *
   * Ensure that any of the following conditions can be fulfilled:
   * - You can unlock the ClusterProxy, or you can provide and unlock any LockProxy of the ClusterProxy
   * - If the ClusterProxy has minPayment defined, and you can pay the owner of the ClusterProxy a fee
   *
   * Example ClusterProxy "0x484a...e857":
   * - ClusterProxy ID: 0x484a439338ebe0ef6f953ead4273a59fc5972d31e67e7e51e7a9c01af810e857
   * - Ownership: CHARLIE
   */
  const clusterProxyCell = await getClusterProxyById('0x484a439338ebe0ef6f953ead4273a59fc5972d31e67e7e51e7a9c01af810e857', config);

  const { txSkeleton, outputIndex } = await createClusterAgent({
    clusterProxyOutPoint: clusterProxyCell.outPoint!,
    /**
     * Decide how to reference the target ClusterProxy:
     * - 'cell': Reference the ClusterProxy (Cell or LockProxy) directly
     * - 'payment': Pay the owner of the ClusterProxy a fee to use it without permission/signature
     */
    referenceType: 'payment',
    /**
     * If referenceType == 'payment', you can specify the payment amount (in shannons),
     * and the default amount is 10^ClusterProxyArgs.minPayment if not specified.
     */
    paymentAmount: BI.from(100_0000_0000),
    fromInfos: [ALICE.address],
    toLock: ALICE.lock,
    config,
  });

  const hash = await ALICE.signAndSendTransaction(txSkeleton);
  console.log('CreateClusterAgent transaction sent, hash:', hash);
  console.log('ClusterAgent output index:', outputIndex);
})();


================================================
File: examples/secp256k1/apis/createClusterProxy.ts
================================================
import { createClusterProxy, getClusterById, unpackToRawClusterProxyArgs } from '@spore-sdk/core';
import { accounts, config } from '../utils/config';

(async function main() {
  const { CHARLIE } = accounts;

  /**
   * The target Cluster's ID you want to create ClusterProxy from.
   *
   * Ensure that any of the following conditions can be fulfilled:
   * - You can provide a signature to unlock the Cluster
   * - You can provide and unlock any LockProxy of the Cluster
   *
   * Example Cluster "0x928e...8b27":
   * - Cluster ID: 0x928eb52ffeb8864154b2135d57ac57b70d97ba908c5a7205ed5e5dc022468b27
   * - Ownership: CHARLIE
   */
  const clusterCell = await getClusterById('0x928eb52ffeb8864154b2135d57ac57b70d97ba908c5a7205ed5e5dc022468b27', config);

  const { txSkeleton, outputIndex } = await createClusterProxy({
    clusterOutPoint: clusterCell.outPoint!,
    fromInfos: [CHARLIE.address],
    toLock: CHARLIE.lock,
    /**
     * Anyone who pays a minimum 10^minPayment shannons to toLock can use the ClusterProxy.
     * If undefined, the "pay to use" method will be disabled for others.
     */
    minPayment: 10,
    config,
  });

  const hash = await CHARLIE.signAndSendTransaction(txSkeleton);
  console.log('CreateClusterProxy transaction sent, hash:', hash);
  console.log('ClusterProxy output index:', outputIndex);

  const clusterProxyCell = txSkeleton.get('outputs').get(outputIndex)!;
  const clusterProxyArgs = unpackToRawClusterProxyArgs(clusterProxyCell.cellOutput.type!.args);
  console.log('ClusterProxy ID:', clusterProxyArgs.id);
})();


================================================
File: examples/secp256k1/apis/createSpore.ts
================================================
import { resolve } from 'path';
import { readFileSync } from 'fs';
import { createSpore } from '@spore-sdk/core';
import { accounts, config } from '../utils/config';

/**
 * Fetch local image file as Uint8Array in Node.
 * In browser, you can use fetch() to fetch remote image file as Uint8Array.
 */
export async function fetchLocalImage(src: string): Promise<Uint8Array> {
  const buffer = readFileSync(resolve(__dirname, src));
  return new Uint8Array(buffer);
}

(async function main() {
  const { CHARLIE } = accounts;

  const { txSkeleton, outputIndex } = await createSpore({
    data: {
      /**
       * The Spore's content type (MIME type), e.g. 'text/plain', 'image/jpeg', 'application/json', etc.
       * You can search for the full list of MIME types on the Internet:
       * https://www.iana.org/assignments/media-types/media-types.xhtml
       */
      contentType: 'image/jpeg',
      /**
       * The Spore's content, should be a BytesLike type object, e.g. Uint8Array, ArrayBuffer, etc.
       * You can use bytifyRawString() to convert a string to Uint8Array if needed.
       */
      content: await fetchLocalImage('../../shared/test.jpg'),
    },
    fromInfos: [CHARLIE.address],
    toLock: CHARLIE.lock,
    config,
  });

  const hash = await CHARLIE.signAndSendTransaction(txSkeleton);
  console.log('createSpore transaction sent, hash:', hash);
  console.log('Spore output index:', outputIndex);

  const sporeCell = txSkeleton.get('outputs').get(outputIndex)!;
  console.log('Spore ID:', sporeCell.cellOutput.type!.args);
})();


================================================
File: examples/secp256k1/apis/createSporeWithCluster.ts
================================================
import { bytifyRawString, createSpore } from '@spore-sdk/core';
import { accounts, config } from '../utils/config';

(async function main() {
  const { CHARLIE } = accounts;

  /**
   * The Cluster's ID you want to reference to the new Spore.
   *
   * Ensure that any of the following conditions can be fulfilled:
   * - You can provide a signature to unlock the Cluster
   * - You can provide and unlock any LockProxy of the Cluster
   *
   * The example Cluster "0x928e...8b27":
   * - Cluster ID: 0x928eb52ffeb8864154b2135d57ac57b70d97ba908c5a7205ed5e5dc022468b27
   * - Ownership: CHARLIE
   */
  const clusterId = '0x928eb52ffeb8864154b2135d57ac57b70d97ba908c5a7205ed5e5dc022468b27';

  const { txSkeleton, outputIndex } = await createSpore({
    data: {
      /**
       * When data.clusterId is specified, will reference the Cluster (Cell or LockProxy) in the transaction.
       * The Spore will be a Clustered Spore, referenced to the Cluster.
       */
      clusterId,
      contentType: 'text/plain',
      content: bytifyRawString('spore text content'),
    },
    fromInfos: [CHARLIE.address],
    toLock: CHARLIE.lock,
    config,
  });

  const hash = await CHARLIE.signAndSendTransaction(txSkeleton);
  console.log('CreateSporeWithCluster transaction sent, hash:', hash);
  console.log('Spore output index:', outputIndex);
})();


================================================
File: examples/secp256k1/apis/createSporeWithClusterAgent.ts
================================================
import { bytifyRawString, createSpore } from '@spore-sdk/core';
import { accounts, config } from '../utils/config';
import { OutPoint } from '@ckb-lumos/base';

(async function main() {
  const { ALICE } = accounts;

  /**
   * The Cluster's ID you want to reference to the new Spore.
   *
   * The example Cluster "0x928e...8b27":
   * - Cluster ID: 0x928eb52ffeb8864154b2135d57ac57b70d97ba908c5a7205ed5e5dc022468b27
   * - Ownership: CHARLIE
   */
  const clusterId = '0x928eb52ffeb8864154b2135d57ac57b70d97ba908c5a7205ed5e5dc022468b27';

  /**
   * The ClusterAgent you want to reference in the transaction.
   *
   * Example ClusterAgent "0xfca6...ae6b|0x1":
   * - Referenced Cluster: "0x928e...8b27"
   * - Ownership: ALICE
   *
   * ClusterAgent "0xfca6...ae6b|0x1" is owned by ALICE and is referenced to Cluster "0x928e...8b27".
   * It allows ALICE to reference the Cluster's ID in Spores.
   */
  const clusterAgentOutPoint: OutPoint = {
    txHash: '0xfca6e903083893b143863bf3256d40fee408dae11ae359a4637d46a815f7ae6b',
    index: '0x1',
  };

  const { txSkeleton, outputIndex } = await createSpore({
    data: {
      clusterId,
      contentType: 'text/plain',
      content: bytifyRawString('spore text content'),
    },
    /**
     * When clusterAgentOutpoint is specified, will reference the ClusterAgent (Cell or LockProxy) in the transaction,
     * instead of referencing the Cluster (Cell or LockProxy) directly.
     */
    clusterAgentOutPoint,
    fromInfos: [ALICE.address],
    toLock: ALICE.lock,
    config,
  });

  const hash = await ALICE.signAndSendTransaction(txSkeleton);
  console.log('CreateSporeWithClusterAgent transaction sent, hash:', hash);
  console.log('Spore output index:', outputIndex);
})();


================================================
File: examples/secp256k1/apis/meltClusterAgent.ts
================================================
import { meltClusterAgent } from '@spore-sdk/core';
import { accounts, config } from '../utils/config';

(async function main() {
  const { CHARLIE } = accounts;

  const { txSkeleton } = await meltClusterAgent({
    outPoint: {
      txHash: '0x<transaction_hash>',
      index: '0x<cluster_agent_output_index>',
    },
    changeAddress: CHARLIE.address,
    config,
  });

  const hash = await CHARLIE.signAndSendTransaction(txSkeleton);
  console.log('MeltClusterAgent transaction sent, hash:', hash);
})();


================================================
File: examples/secp256k1/apis/meltClusterProxy.ts
================================================
import { meltClusterProxy, getClusterProxyById } from '@spore-sdk/core';
import { accounts, config } from '../utils/config';

(async function main() {
  const { CHARLIE } = accounts;

  const clusterProxyCell = await getClusterProxyById('0x<cluster_proxy_id>', config);

  const { txSkeleton } = await meltClusterProxy({
    outPoint: clusterProxyCell.outPoint!,
    changeAddress: CHARLIE.address,
    config,
  });

  const hash = await CHARLIE.signAndSendTransaction(txSkeleton);
  console.log('MeltClusterProxy transaction sent, hash:', hash);
})();


================================================
File: examples/secp256k1/apis/meltSpore.ts
================================================
import { getSporeById, meltSpore } from '@spore-sdk/core';
import { accounts, config } from '../utils/config';

(async function main() {
  const { CHARLIE } = accounts;

  const sporeCell = await getSporeById('0x<spore_id>', config);

  const { txSkeleton } = await meltSpore({
    outPoint: sporeCell.outPoint!,
    changeAddress: CHARLIE.address,
    config,
  });

  const hash = await CHARLIE.signAndSendTransaction(txSkeleton);
  console.log('MeltSpore transaction sent, hash:', hash);
})();


================================================
File: examples/secp256k1/apis/transferCluster.ts
================================================
import { getClusterById, transferCluster } from '@spore-sdk/core';
import { accounts, config } from '../utils/config';

(async function main() {
  const { CHARLIE, ALICE } = accounts;

  const clusterCell = await getClusterById('0x<cluster_id>', config);

  const { txSkeleton, outputIndex } = await transferCluster({
    outPoint: clusterCell.outPoint!,
    fromInfos: [CHARLIE.address],
    toLock: ALICE.lock,
    config,
  });

  const hash = await CHARLIE.signAndSendTransaction(txSkeleton);
  console.log('TransferCluster transaction sent, hash:', hash);
  console.log('Cluster output index:', outputIndex);
})();


================================================
File: examples/secp256k1/apis/transferClusterAgent.ts
================================================
import { transferClusterAgent } from '@spore-sdk/core';
import { accounts, config } from '../utils/config';

(async function main() {
  const { CHARLIE, ALICE } = accounts;

  const { txSkeleton, outputIndex } = await transferClusterAgent({
    outPoint: {
      txHash: '0x<transaction_hash>',
      index: '<cluster_agent_output_index>',
    },
    fromInfos: [CHARLIE.address],
    toLock: ALICE.lock,
    config,
  });

  const hash = await CHARLIE.signAndSendTransaction(txSkeleton);
  console.log('TransferClusterAgent transaction sent, hash:', hash);
  console.log('ClusterAgent output index:', outputIndex);
})();


================================================
File: examples/secp256k1/apis/transferClusterProxy.ts
================================================
import { transferClusterProxy, getClusterProxyById } from '@spore-sdk/core';
import { accounts, config } from '../utils/config';

(async function main() {
  const { CHARLIE, ALICE } = accounts;

  const clusterProxyCell = await getClusterProxyById('0x<cluster_proxy_id>', config);

  const { txSkeleton, outputIndex } = await transferClusterProxy({
    outPoint: clusterProxyCell.outPoint!,
    fromInfos: [CHARLIE.address],
    toLock: ALICE.lock,
    /**
     * The ClusterProxyArgs.minPayment is modifiable during transfer
     */
    minPayment: 10,
    config,
  });

  const hash = await CHARLIE.signAndSendTransaction(txSkeleton);
  console.log('TransferClusterProxy transaction sent, hash:', hash);
  console.log('ClusterProxy output index:', outputIndex);
})();


================================================
File: examples/secp256k1/apis/transferSpore.ts
================================================
import { getSporeById, transferSpore } from '@spore-sdk/core';
import { accounts, config } from '../utils/config';

(async function main() {
  const { CHARLIE, ALICE } = accounts;

  const sporeCell = await getSporeById('0x<spore_id>', config);

  const { txSkeleton, outputIndex } = await transferSpore({
    outPoint: sporeCell.outPoint!,
    fromInfos: [CHARLIE.address],
    toLock: ALICE.lock,
    config,
  });

  const hash = await CHARLIE.signAndSendTransaction(txSkeleton);
  console.log('TransferSpore transaction sent, hash:', hash);
  console.log('Spore output index:', outputIndex);
})();


================================================
File: examples/secp256k1/utils/config.ts
================================================
import { sharedTestingPrivateKeys } from '@spore-examples/shared';
import { predefinedSporeConfigs } from '@spore-sdk/core';
import { createSecp256k1Wallet } from './wallet';

/**
 * SporeConfig provides spore/cluster's detailed info like ScriptIds and CellDeps.
 * It is a necessary part for constructing spore/cluster transactions.
 */
export const config = predefinedSporeConfigs.Testnet;

/**
 * Wallets with default testing accounts for running the examples,
 * feel free to replace them with your own testing accounts.
 */
export const accounts = {
  CHARLIE: createSecp256k1Wallet(sharedTestingPrivateKeys.CHARLIE, config),
  ALICE: createSecp256k1Wallet(sharedTestingPrivateKeys.ALICE, config),
};


================================================
File: examples/secp256k1/utils/wallet.ts
================================================
import { SporeConfig, defaultEmptyWitnessArgs, updateWitnessArgs, isScriptValueEquals } from '@spore-sdk/core';
import { hd, helpers, HexString, RPC } from '@ckb-lumos/lumos';
import { Address, Hash, Script } from '@ckb-lumos/base';
import { common } from '@ckb-lumos/common-scripts';

export interface Secp256k1Wallet {
  lock: Script;
  address: Address;
  signMessage(message: HexString): Hash;
  signTransaction(txSkeleton: helpers.TransactionSkeletonType): helpers.TransactionSkeletonType;
  signAndSendTransaction(txSkeleton: helpers.TransactionSkeletonType): Promise<Hash>;
}

/**
 * Create a Secp256k1Blake160 Sign-all Wallet by a private key and a SporeConfig,
 * providing lock/address, and functions sign message/transaction and send the transaction on-chain.
 */
export function createSecp256k1Wallet(privateKey: HexString, config: SporeConfig): Secp256k1Wallet {
  const Secp256k1Blake160 = config.lumos.SCRIPTS.SECP256K1_BLAKE160!;

  // Generate a lock script from the private key
  const lock: Script = {
    codeHash: Secp256k1Blake160.CODE_HASH,
    hashType: Secp256k1Blake160.HASH_TYPE,
    args: hd.key.privateKeyToBlake160(privateKey),
  };

  // Generate address from the lock script
  const address = helpers.encodeToAddress(lock, {
    config: config.lumos,
  });

  // Sign for a message
  function signMessage(message: HexString): Hash {
    return hd.key.signRecoverable(message, privateKey);
  }

  // Sign prepared signing entries,
  // and then fill signatures into Transaction.witnesses
  function signTransaction(txSkeleton: helpers.TransactionSkeletonType): helpers.TransactionSkeletonType {
    const signingEntries = txSkeleton.get('signingEntries');
    const signatures = new Map<HexString, Hash>();
    const inputs = txSkeleton.get('inputs');

    let witnesses = txSkeleton.get('witnesses');
    for (let i = 0; i < signingEntries.size; i++) {
      const entry = signingEntries.get(i)!;
      if (entry.type === 'witness_args_lock') {
        const input = inputs.get(entry.index);
        if (!input || !isScriptValueEquals(input.cellOutput.lock, lock)) {
          continue;
        }
        if (!signatures.has(entry.message)) {
          const sig = signMessage(entry.message);
          signatures.set(entry.message, sig);
        }

        const signature = signatures.get(entry.message)!;
        const witness = witnesses.get(entry.index, defaultEmptyWitnessArgs);
        witnesses = witnesses.set(entry.index, updateWitnessArgs(witness, 'lock', signature));
      }
    }

    return txSkeleton.set('witnesses', witnesses);
  }

  // Sign the transaction and send it via RPC
  async function signAndSendTransaction(txSkeleton: helpers.TransactionSkeletonType): Promise<Hash> {
    // Env
    const rpc = new RPC(config.ckbNodeUrl);

    // Sign transaction
    txSkeleton = common.prepareSigningEntries(txSkeleton, { config: config.lumos });
    txSkeleton = signTransaction(txSkeleton);

    // Convert to Transaction
    const tx = helpers.createTransactionFromSkeleton(txSkeleton);

    // Send transaction
    return await rpc.sendTransaction(tx, 'passthrough');
  }

  return {
    lock,
    address,
    signMessage,
    signTransaction,
    signAndSendTransaction,
  };
}


================================================
File: examples/shared/README.md
================================================
# Spore Examples Shared

Variables and files shared in all examples.

## Files

- [index.ts](./index.ts): Provides `CHARLIE` and `ALICE` as the default testing accounts.
- [test.jpg](./test.jpg): An `jpeg` image as the default content of the new spores in the examples.

================================================
File: examples/shared/index.ts
================================================
export const sharedTestingPrivateKeys = {
  CHARLIE: '0xc153ee57dc8ae3dac3495c828d6f8c3fef6b1d0c74fc31101c064137b3269d6d',
  ALICE: '0x49aa6d595ac46cc8e1a31b511754dd58f241a7d8a6ad29e83d6b0c1a82399f3d',
};


================================================
File: examples/shared/package.json
================================================
{
  "name": "@spore-examples/shared",
  "private": true,
  "scripts": {
    "lint": "prettier --check '*.{js,jsx,ts,tsx}'",
    "lint:fix": "prettier --write '*.{js,jsx,ts,tsx}'"
  },
  "main": "index.ts",
  "dependencies": {
    "@ckb-lumos/lumos": "0.24.0-next.1"
  }
}


================================================
File: examples/shared/tsconfig.json
================================================
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "target": "ESNext",
    "module": "CommonJS",
    "skipLibCheck": true,
    "esModuleInterop": true
  }
}


================================================
File: packages/core/README.md
================================================
# @spore-sdk/core

## About

<p>
  <a href="https://www.npmjs.com/package/@spore-sdk/core">
    <picture>
      <source media="(prefers-color-scheme: dark)" srcset="https://img.shields.io/npm/v/@spore-sdk/core?colorA=21262d&colorB=21262d&style=flat">
      <img src="https://img.shields.io/npm/v/@spore-sdk/core?colorA=f6f8fa&colorB=f6f8fa&style=flat" alt="Version">
    </picture>
  </a>
  <a href="https://github.com/sporeprotocol/spore-sdk/blob/main/LICENSE">
    <picture>
      <source media="(prefers-color-scheme: dark)" srcset="https://img.shields.io/npm/l/@spore-sdk/core?colorA=21262d&colorB=21262d&style=flat">
      <img src="https://img.shields.io/npm/l/@spore-sdk/core?colorA=f6f8fa&colorB=f6f8fa&style=flat" alt="MIT License">
    </picture>
  </a>
  <a href="https://www.npmjs.com/package/@spore-sdk/core">
    <picture>
      <source media="(prefers-color-scheme: dark)" srcset="https://img.shields.io/npm/dm/@spore-sdk/core?colorA=21262d&colorB=21262d&style=flat">
      <img src="https://img.shields.io/npm/dm/@spore-sdk/core?colorA=f6f8fa&colorB=f6f8fa&style=flat" alt="Downloads per month">
    </picture>
  </a>
</p>

The `@spore-sdk/core` package provides essential tools for constructing basic and advanced transactions on spores and clusters. Additionally, it offers convenient utilities for handling [serialization](https://github.com/nervosnetwork/molecule) of spores/clusters.

## Features

- âš¡ Composed APIs for efficient spores/clusters interactions with minimal time overhead
- ğŸ§© Joint APIs for building advanced transactions as a fun block-building process
- ğŸ› ï¸ Utilities for encoding/decoding data of spores/clusters
- ğŸ¹ Fully written in TypeScript

## Getting started

### Installation

Install `@spore-sdk/core` as a dependency using any package manager, such as `npm`:

```shell
npm install @spore-sdk/core
```

### Browser environment

Spore SDK is built on top of [Lumos](https://github.com/ckb-js/lumos), an open-source dapp framework for Nervos CKB. Lumos incorporates certain Node-polyfills into its implementation to provide specific functionalities, such as:

- `crypto-browserify`
- `buffer`

If you wish to use the Spore SDK in a browser environment, it's important to manually add Node-polyfills to your application. This ensures that the Spore SDK functions properly in the browser. Visit: [CRA, Vite, Webpack or Other](https://lumos-website.vercel.app/recipes/cra-vite-webpack-or-other).

### About the project

This package is a part of the Spore SDK monorepo.

For complete descriptions and instructions, visit: [Spore SDK](../../README.md).

## License

[MIT](../../LICENSE) License


================================================
File: packages/core/CHANGELOG.md
================================================
# @spore-sdk/core

## 0.2.2-alpha.2

### Patch Changes

- ef58c00: add feerate to createMultipleSpores

## 0.2.2-alpha.1

### Patch Changes

- 95b7a23: passing feeRate to payFeeByOutput method

## 0.2.2-alpha.0

### Patch Changes

- cfaef44: fix vulnerability in getSporeById interface
- fix: injectNeededCapacity rare border capacity issue (#133)

## 0.2.1

### Minor Changes

- 7f25b9f: feat: adds transferMultipleSpore and meltMultipleThenCreateSpore

# @spore-sdk/core

## 0.2.0

### Minor Changes

- 9b4983f: export co-build interfaces and able to skip checking content-type

## 0.2.0-beta.9

### Patch Changes

- 2bc5277: solve bigint comparasion bug

## 0.2.0-beta.8

### Patch Changes

- 4fe6a6d: fix a transaction fee calculation bug in `meltThenCreateSpore` method

## 0.2.0-beta.7

### Patch Changes

- a34515c: add `feerate` parameter to all of interfaces

## 0.2.0-beta.6

### Patch Changes

- 31ce36c: fix a bug for Cluster's `lockProxy` mode identification

## 0.2.0-beta.5

### Patch Changes

- 1fe201f: enable interface `createSpore` and `meltThenCreateSpore` to accept input cells pre-injection
- 8beb742: add `createMultipleSpores` interface to create multiple spores in one transaction

## 0.2.0-beta.4

### Patch Changes

- 6360d42: adapt for mutant functionality and add new method for spore migration
- 02c9861: support exact and power mode of min_payment

## 0.2.0-beta.3

### Patch Changes

- a605f5f: Fix duplicated capacity collection in the "createSpore" API
- 858c8fb: slipt co-build generation interfaces to export pure assembly functions

## 0.2.0-beta.2

### Patch Changes

- 8a42d58: Add predefined SporeConfig for Mainnet
- 16dfe4f: BREAKING CHANGE: Replaced v2 contracts with a v1-compatible preview version
- 216d357: Support selecting v1/v2 version when creating clusters

## 0.2.0-beta.1

### Patch Changes

- 22d062d: BREAKING CHANGE: Replaced v2 preview contracts

## 0.2.0-beta.0

### Minor Changes

- b89681c: Support basic Cobuild feature with legacy locks

### Patch Changes

- 68e7ed8: Support finding SporeScripts by predefined tags
- aa1895f: Remove minPayment prop from the transferClusterProxy API

## 0.1.1-beta.0

### Patch Changes

- 8801116: Fix typo of the "assertTransactionSkeletonSize" API
- 17fb34c: Support Mutant related features
- 347c225: Fix spore/cluster query logic, should validate target id before querying
- 7c9ee66: Support ClusterProxy and ClusterAgent type cells
- 7e64429: Remove "fromInfos" prop from the "meltSpore" API
- 3b06bcb: Add multipart content support
- c025b67: Add new spore type script version to support more contract features
- e807c5a: Fix and optimize the logic of capacity collection
- 2db9424: Support lock proxy in spore creation

## 0.1.0

### Minor Changes

- d7a42ca: Implementation and docs/examples of Spore Protocol V1

### Patch Changes

- 48a6506: Add Omnilock (ACP) and ACP related examples to show developers how to work with the public clusters
- d9e71ee: Remove esm build in sdk
- e88b8e3: Add recipe doc about how to use SporeConfig
- f352469: Update the script info of cluster/spore
- 24facd1: Fix sdk to build esm and cjs together
- bc37376: Rename term from "destroy" to "melt", etc. "meltSpore"
- 1a30c54: Adds a backup in codec tests
- bd7bfe8: Rename SporeData.cluster to SporeData.clusterId
- f9d2e61: Fix the utf-8 encoding issue, originally the lumos `bytes.bytifyRawString` method can only handle ascii strings
- ca1d6ae: Support capacity margin features in Composed APIs
- d382b0d: Support SporeScript with versions
- db8f7d0: Fix a turbo cache bug, now should clear turbo cache before releasing packages
- e509567: Add capacity margin and input witness relevant props to improve controllability of cells in the APIs
- 9a10284: Update the testnet predefined scripts
- 8a35bd3: Add transaction max size limit to createSpore/createCluster APIs
- 64f8dcd: Simplify api prop names, for example from "sporeData" to "data"
- e41e791: Fix wrong molecule used in transaction size calculation
- 9fce0be: Provide global SporeConfig apis, allow SporeConfig in composed apis to be optional
- 9f1d792: Rename Joint APIs, from "getXCellByY" to "getXByY", and from "injectXIds" to "injectNewXIds"

## 0.1.0-beta.14

### Patch Changes

- db8f7d0: Fix a turbo cache bug, now should clear turbo cache before releasing packages

## 0.1.0-beta.13

### Patch Changes

- bc37376: Rename term from "destroy" to "melt", etc. "meltSpore"
- 9f1d792: Rename Joint APIs, from "getXCellByY" to "getXByY", and from "injectXIds" to "injectNewXIds"

## 0.1.0-beta.12

### Patch Changes

- f9d2e61: Fix the utf-8 encoding issue, originally the lumos `bytes.bytifyRawString` method can only handle ascii strings

## 0.1.0-beta.11

### Patch Changes

- e41e791: Fix wrong molecule used in transaction size calculation

## 0.1.0-beta.10

### Patch Changes

- 48a6506: Add Omnilock (ACP) and ACP related examples to show developers how to work with the public clusters
- e88b8e3: Add recipe doc about how to use SporeConfig
- e509567: Add capacity margin and input witness relevant props to improve controllability of cells in the APIs
- 8a35bd3: Add transaction max size limit to createSpore/createCluster APIs

## 0.1.0-beta.9

### Patch Changes

- ca1d6ae: Support capacity margin features in Composed APIs

## 0.1.0-beta.8

### Patch Changes

- 9a10284: Update the testnet predefined scripts

## 0.1.0-beta.7

### Patch Changes

- d382b0d: Support SporeScript with versions

## 0.1.0-beta.6

### Patch Changes

- 64f8dcd: Simplify api prop names, for example from "sporeData" to "data"
- 9fce0be: Provide global SporeConfig apis, allow SporeConfig in composed apis to be optional

## 0.1.0-beta.5

### Patch Changes

- d9e71ee: Remove esm build in sdk

## 0.1.0-beta.4

### Patch Changes

- f352469: Update the script info of cluster/spore

## 0.1.0-beta.3

### Patch Changes

- 1a30c54: Adds a backup in codec tests

## 0.1.0-beta.2

### Patch Changes

- bd7bfe8: Rename SporeData.cluster to SporeData.clusterId

## 0.1.0-beta.1

### Patch Changes

- Fix sdk to build esm and cjs together

## 0.1.0-beta.0

### Minor Changes

- Implementation and docs/examples of Spore Protocol V1


================================================
File: packages/core/package.json
================================================
{
  "name": "@spore-sdk/core",
  "version": "0.2.2-alpha.2",
  "license": "MIT",
  "scripts": {
    "test": "vitest",
    "build": "tsc -p tsconfig.build.json",
    "lint": "prettier --check 'src/**/*.{js,jsx,ts,tsx}'",
    "lint:fix": "prettier --write 'src/**/*.{js,jsx,ts,tsx}'",
    "clean": "pnpm run clean:cache & pnpm run clean:build",
    "clean:build": "rimraf lib && pnpm run clean:buildinfo",
    "clean:buildinfo": "rimraf tsconfig.*tsbuildinfo",
    "clean:cache": "rimraf .turbo"
  },
  "main": "lib",
  "files": [
    "lib"
  ],
  "peerDependencies": {
    "@ckb-lumos/lumos": "0.24.0-next.1",
    "lodash": "^4.17.21"
  },
  "devDependencies": {
    "vitest": "^1.4.0",
    "@exact-realty/multipart-parser": "^1.0.13"
  },
  "publishConfig": {
    "access": "public"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/sporeprotocol/spore-sdk.git"
  },
  "bugs": {
    "url": "https://github.com/sporeprotocol/spore-sdk/issues"
  }
}


================================================
File: packages/core/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "lib",
    "module": "CommonJS"
  },
  "exclude": ["src/__tests__"]
}


================================================
File: packages/core/tsconfig.json
================================================
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "target": "ESNext",
    "outDir": "lib",
    "rootDir": "src",
    "composite": true,
    "noEmit": false,
    "lib": ["ESNext"]
  },
  "include": ["src/**/*"],
  "exclude": ["**/lib"]
}


================================================
File: packages/core/vitest.config.mts
================================================
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    watch: false,
    fileParallelism: false,
    poolOptions: {
      threads: {
        singleThread: true,
      },
    },
  },
});


================================================
File: packages/core/src/env.d.ts
================================================
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_NETWORK: string;
  readonly VITE_CONFIG_PATH: string;
  readonly VITE_TESTS_CLUSTER_V1: string;
  readonly VITE_ACCOUNT_CHARLIE: string;
  readonly VITE_ACCOUNT_ALICE: string;
  readonly VITE_ACCOUNT_BOB: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}


================================================
File: packages/core/src/index.ts
================================================
export * from './codec';
export * from './config';
export * from './helpers';
export * from './api';
export * from './cobuild';


================================================
File: packages/core/src/__tests__/Buffer.test.ts
================================================
import { bytes } from '@ckb-lumos/codec';
import { describe, expect, it } from 'vitest';
import { bufferToRawString, bytifyRawString } from '../helpers';

describe('Buffer', () => {
  it('Encode buffer from normal raw strings', () => {
    const strings = [
      { input: '\u0041', expected: 'A' },
      { input: '\u0100', expected: 'Ä€' },
      { input: '\u304B', expected: 'ã‹' },
      { input: '\uD800\uDF48', expected: 'ğˆ' },
      { input: '\uD83D\uDE0A', expected: 'ğŸ˜Š' },
    ];

    for (const raw of strings) {
      const decoded = bufferToRawString(bytifyRawString(raw.input));
      expect(decoded).toEqual(raw.expected);
    }
  });
  it('Encode buffer from special characters', () => {
    const strings = [
      { input: '\u0009', expected: '\t' },
      { input: '\u000A', expected: '\n' },
      { input: '\u0020', expected: ' ' },
    ];

    for (const raw of strings) {
      const decoded = bufferToRawString(bytifyRawString(raw.input));
      expect(decoded).toEqual(raw.expected);
    }
  });
  it('Encoded ascii & utf8 should be the same', () => {
    const raw = 'English';
    const utf8Encoded = bytes.hexify(bytifyRawString(raw));
    const asciiEncoded = bytes.hexify(bytes.bytifyRawString(raw));
    expect(utf8Encoded).toEqual(asciiEncoded);
  });
});


================================================
File: packages/core/src/__tests__/Capacity.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { Cell } from '@ckb-lumos/base';
import { BI, helpers } from '@ckb-lumos/lumos';
import { common } from '@ckb-lumos/common-scripts';
import { TEST_ACCOUNTS, TEST_ENV } from './shared';
import {
  getMinFeeRate,
  calculateFeeByTransactionSkeleton,
  createCapacitySnapshotFromTransactionSkeleton,
  injectCapacityAndPayFee,
  returnExceededCapacity,
  payFeeByOutput,
} from '../helpers';

describe(
  'Capacity',
  function () {
    const { config, rpc, indexer } = TEST_ENV;
    const { CHARLIE } = TEST_ACCOUNTS;

    it('Normal capacity collection', async () => {
      let txSkeleton = new helpers.TransactionSkeleton({
        cellProvider: indexer,
      });

      txSkeleton = txSkeleton.update('outputs', (outputs) => {
        return outputs.push({
          cellOutput: {
            capacity: BI.from(100_0000_0000).toHexString(),
            lock: CHARLIE.lock,
          },
          data: '0x',
        });
      });

      txSkeleton = txSkeleton.update('fixedEntries', (fixedEntries) => {
        return fixedEntries.push({
          field: 'outputs',
          index: 0,
        });
      });

      const injected = await injectCapacityAndPayFee({
        fromInfos: [CHARLIE.address],
        txSkeleton,
        config,
      });

      txSkeleton = injected.txSkeleton;
      const { before: beforeSnap, after: afterSnap } = injected;
      expect(afterSnap.inputsLength - beforeSnap.inputsLength).toBeGreaterThanOrEqual(1);
      expect(afterSnap.outputsLength - beforeSnap.outputsLength).toBeGreaterThanOrEqual(1);

      const feeRate = await getMinFeeRate(rpc);
      const fee = calculateFeeByTransactionSkeleton(txSkeleton, feeRate);
      expect(afterSnap.inputsRemainCapacity.eq(fee)).toEqual(true);
    }, 50000);
    it('No capacity collection, only returning exceeded capacity', async () => {
      let txSkeleton = new helpers.TransactionSkeleton({
        cellProvider: indexer,
      });

      const collector = indexer.collector({
        lock: CHARLIE.lock,
        outputDataLenRange: ['0x0', '0x1'],
      });

      let collectedCell: Cell | undefined;
      let collectedCapacity: BI | undefined;
      for await (const cell of collector.collect()) {
        let capacity = BI.from(cell.cellOutput.capacity);
        if (collectedCell === void 0) {
          collectedCapacity = capacity;
          collectedCell = cell;
        } else if (capacity > collectedCapacity!) {
          collectedCapacity = capacity;
          collectedCell = cell;
        }
      }
      expect(collectedCell).toBeDefined();
      expect(collectedCapacity).toBeDefined();

      // Add cell to inputs and outputs,
      // and then remove the cell from outputs because not needed
      txSkeleton = await common.setupInputCell(txSkeleton, collectedCell!, CHARLIE.address, {
        config: config.lumos,
      });
      txSkeleton = txSkeleton.update('outputs', (outputs) => {
        return outputs.remove(0);
      });
      expect(txSkeleton.get('inputs').size).toEqual(1);
      expect(txSkeleton.get('outputs').size).toEqual(0);

      const returned = returnExceededCapacity({
        changeAddress: CHARLIE.address,
        config: config.lumos,
        txSkeleton,
      });

      txSkeleton = returned.txSkeleton;
      expect(returned.returnedChange).toEqual(true);
      expect(returned.createdChangeCell).toEqual(true);
      expect(returned.changeCellOutputIndex).toEqual(0);

      const snapshot = createCapacitySnapshotFromTransactionSkeleton(txSkeleton);
      expect(snapshot.outputsCapacity.eq(collectedCapacity!)).toEqual(true);
      expect(snapshot.inputsRemainCapacity.eq(0)).toEqual(true);

      const feeRate = await getMinFeeRate(rpc);
      const fee = calculateFeeByTransactionSkeleton(txSkeleton, feeRate);
      txSkeleton = await payFeeByOutput({
        outputIndex: 0,
        txSkeleton,
        config,
      });

      const paidSnap = createCapacitySnapshotFromTransactionSkeleton(txSkeleton);
      expect(paidSnap.inputsRemainCapacity.eq(fee)).toEqual(true);
    }, 50000);
  },
  {
    concurrent: true,
  },
);


================================================
File: packages/core/src/__tests__/Cluster.test.ts
================================================
import { afterAll, describe, expect, it } from 'vitest';
import { BI } from '@ckb-lumos/lumos';
import { getSporeScript } from '../config';
import { bytifyRawString, waitForMilliseconds } from '../helpers';
import { expectTypeId, expectCellDep, expectTypeCell, expectLockCell } from './helpers';
import { signAndOrSendTransaction, popRecord, OutPointRecord, IdRecord } from './helpers';
import { retryQuery, getSporeOutput, getClusterOutput, expectCellLock } from './helpers';
import { createCluster, createSpore, getClusterById, getClusterByOutPoint, transferCluster } from '../api';
import {
  TEST_ENV,
  TEST_ACCOUNTS,
  TEST_VARIABLES,
  SPORE_OUTPOINT_RECORDS,
  CLUSTER_OUTPOINT_RECORDS,
  cleanupRecords,
} from './shared';

describe('Cluster', () => {
  const { rpc, config, v1Config } = TEST_ENV;
  const { CHARLIE, ALICE } = TEST_ACCOUNTS;

  let existingClusterRecord: OutPointRecord | undefined;

  afterAll(async () => {
    await cleanupRecords({
      name: 'Cluster',
    });
  }, 0);

  describe('Cluster basics', () => {
    it('Create a Cluster', async () => {
      const { txSkeleton, outputIndex } = await createCluster({
        data: {
          name: 'Testnet Spores',
          description: 'Testing only',
        },
        fromInfos: [CHARLIE.address],
        toLock: CHARLIE.lock,
        config,
      });

      const cluster = getClusterOutput(txSkeleton, outputIndex, config);
      expect(cluster.cell.cellOutput.lock).toEqual(CHARLIE.lock);
      expectTypeId(txSkeleton, outputIndex, cluster.id);
      expect(cluster.data.name).toEqual('Testnet Spores');
      expect(cluster.data.description).toEqual('Testing only');

      expectTypeCell(txSkeleton, 'output', cluster.cell.cellOutput.type!);
      expectCellDep(txSkeleton, cluster.script.cellDep);

      const { hash } = await signAndOrSendTransaction({
        account: CHARLIE,
        txSkeleton,
        config,
        rpc,
        send: true,
      });
      if (hash) {
        CLUSTER_OUTPOINT_RECORDS.push({
          outPoint: {
            txHash: hash,
            index: BI.from(outputIndex).toHexString(),
          },
          account: CHARLIE,
        });
      }
    }, 0);
    it('Transfer a Cluster', async () => {
      const clusterRecord = existingClusterRecord ?? popRecord(CLUSTER_OUTPOINT_RECORDS, true);
      const clusterCell = await retryQuery(() => getClusterByOutPoint(clusterRecord.outPoint, config));

      expectCellLock(clusterCell, [CHARLIE.lock, ALICE.lock]);
      const oppositeAccount = clusterRecord.account.address === ALICE.address ? CHARLIE : ALICE;

      const { txSkeleton, outputIndex } = await transferCluster({
        outPoint: clusterCell.outPoint!,
        fromInfos: [clusterRecord.account.address],
        toLock: oppositeAccount.lock,
        config,
      });

      const cluster = getClusterOutput(txSkeleton, outputIndex, config);
      expect(cluster.cell.cellOutput.lock).toEqual(oppositeAccount.lock);

      expectTypeCell(txSkeleton, 'both', cluster.cell.cellOutput.type!);
      expectCellDep(txSkeleton, cluster.script.cellDep);

      const { hash } = await signAndOrSendTransaction({
        account: clusterRecord.account,
        txSkeleton,
        config,
        rpc,
        send: true,
      });
      if (hash) {
        existingClusterRecord = void 0;
        CLUSTER_OUTPOINT_RECORDS.push({
          outPoint: {
            txHash: hash,
            index: BI.from(outputIndex).toHexString(),
          },
          account: oppositeAccount,
        });
      }
    }, 0);
  });

  describe('Spore with Cluster (latest)', () => {
    it('Create a Spore with Cluster (via lock proxy)', async () => {
      const clusterRecord = existingClusterRecord ?? popRecord(CLUSTER_OUTPOINT_RECORDS, true);
      const clusterCell = await retryQuery(() => getClusterByOutPoint(clusterRecord.outPoint, config));
      const clusterId = clusterCell.cellOutput.type!.args;

      const { txSkeleton, outputIndex, reference } = await createSpore({
        data: {
          clusterId,
          contentType: 'text/plain',
          content: bytifyRawString('content'),
        },
        fromInfos: [clusterRecord.account.address],
        toLock: CHARLIE.lock,
        config,
      });

      const spore = getSporeOutput(txSkeleton, outputIndex, config);
      expect(spore.data.clusterId).toEqual(clusterId);

      expect(reference).toBeDefined();
      expect(reference.referenceTarget).toEqual('cluster');
      expect(reference.referenceType).toEqual('lockProxy');

      expectLockCell(txSkeleton, 'both', clusterCell.cellOutput.lock);

      const clusterScript = getSporeScript(config, 'Cluster', clusterCell.cellOutput.type!);
      expectCellDep(txSkeleton, clusterScript.cellDep);
      expectCellDep(txSkeleton, {
        outPoint: clusterRecord.outPoint,
        depType: 'code',
      });

      const { hash } = await signAndOrSendTransaction({
        account: clusterRecord.account,
        txSkeleton,
        config,
        rpc,
        send: true,
      });
      if (hash) {
        existingClusterRecord = void 0;
        CLUSTER_OUTPOINT_RECORDS.push(clusterRecord);
        SPORE_OUTPOINT_RECORDS.push({
          outPoint: {
            txHash: hash,
            index: BI.from(outputIndex).toHexString(),
          },
          account: CHARLIE,
        });
      }
    }, 0);
    it('Create a Spore with Cluster (via cell reference)', async () => {
      const clusterRecord = existingClusterRecord ?? popRecord(CLUSTER_OUTPOINT_RECORDS, true);
      const clusterCell = await retryQuery(() => getClusterByOutPoint(clusterRecord.outPoint, config));
      const clusterId = clusterCell.cellOutput.type!.args;

      expectCellLock(clusterCell, [CHARLIE.lock, ALICE.lock]);
      const oppositeAccount = clusterRecord.account.address === ALICE.address ? CHARLIE : ALICE;

      const { txSkeleton, outputIndex, reference } = await createSpore({
        data: {
          clusterId,
          contentType: 'text/plain',
          content: bytifyRawString('content'),
        },
        toLock: clusterRecord.account.lock,
        fromInfos: [oppositeAccount.address],
        config,
      });

      const spore = getSporeOutput(txSkeleton, outputIndex, config);
      expect(spore.data.clusterId).toEqual(clusterId);

      expect(reference).toBeDefined();
      expect(reference.referenceTarget).toEqual('cluster');
      expect(reference.referenceType).toEqual('cell');

      expect(reference.cluster).toBeDefined();
      expect(reference.cluster).toHaveProperty('inputIndex');
      expect(reference.cluster).toHaveProperty('outputIndex');

      const cluster = getClusterOutput(txSkeleton, reference.cluster!.outputIndex, config);
      expectTypeCell(txSkeleton, 'both', cluster.cell.cellOutput.type!);
      expect(cluster.id).toEqual(clusterId);

      const clusterScript = getSporeScript(config, 'Cluster', clusterCell.cellOutput.type!);
      expectCellDep(txSkeleton, clusterScript.cellDep);
      expectCellDep(txSkeleton, {
        outPoint: clusterRecord.outPoint,
        depType: 'code',
      });

      const { hash } = await signAndOrSendTransaction({
        account: [oppositeAccount, clusterRecord.account],
        txSkeleton,
        config,
        rpc,
        send: true,
      });
      if (hash) {
        existingClusterRecord = void 0;
        CLUSTER_OUTPOINT_RECORDS.push({
          outPoint: {
            txHash: hash,
            index: BI.from(reference.cluster!.outputIndex).toHexString(),
          },
          account: clusterRecord.account,
        });
        SPORE_OUTPOINT_RECORDS.push({
          outPoint: {
            txHash: hash,
            index: BI.from(outputIndex).toHexString(),
          },
          account: clusterRecord.account,
        });
      }
    }, 0);
  });

  describe.runIf(TEST_VARIABLES.tests.clusterV1)('Spore with Cluster (v1)', () => {
    let clusterV1OutPointRecord: OutPointRecord | undefined;
    const clusterV1IdRecord: IdRecord = {
      id: '0x8b9f893397310a3bbd925cd1c9ab606555675bb2d03f3c5cb934f2ba4ef97e93',
      account: CHARLIE,
    };

    async function getClusterV1Record() {
      if (TEST_VARIABLES.network === 'devnet') {
        expect(clusterV1OutPointRecord).toBeDefined();
        return {
          cell: await getClusterByOutPoint(clusterV1OutPointRecord!.outPoint, config),
          account: clusterV1OutPointRecord!.account,
        };
      } else {
        expect(clusterV1IdRecord).toBeDefined();
        const cell = await getClusterById(clusterV1IdRecord.id, config);
        return {
          cell: await getClusterByOutPoint(cell.outPoint!, config),
          account: clusterV1IdRecord.account,
        };
      }
    }

    it.runIf(TEST_VARIABLES.network === 'devnet')(
      'Create a Cluster (v1) if necessary',
      async () => {
        // Wait some time for the indexer to be updated
        await waitForMilliseconds(1500);

        const { txSkeleton, outputIndex } = await createCluster({
          data: {
            name: 'Testnet Spores',
            description: 'Testing only',
          },
          fromInfos: [CHARLIE.address],
          toLock: CHARLIE.lock,
          config: v1Config,
        });

        const clusterOutput = getClusterOutput(txSkeleton, outputIndex, v1Config);
        const clusterScript = clusterOutput.script;

        expect(clusterScript).toHaveProperty('tags');
        expect(clusterScript.tags).toContain('v1');

        const { hash } = await signAndOrSendTransaction({
          account: CHARLIE,
          txSkeleton,
          rpc,
          send: true,
          config: v1Config,
        });

        if (hash) {
          clusterV1OutPointRecord = {
            outPoint: {
              txHash: hash,
              index: BI.from(outputIndex).toHexString(),
            },
            account: CHARLIE,
          };
        }
      },
      0,
    );
    it('Create a Spore with Cluster (via lock proxy)', async () => {
      const { cell: clusterCell, account: recordAccount } = await retryQuery(getClusterV1Record);

      expectCellLock(clusterCell, [CHARLIE.lock, ALICE.lock]);
      const clusterId = clusterCell.cellOutput.type!.args;

      await expect(() =>
        createSpore({
          data: {
            clusterId: clusterId,
            contentType: 'text/plain',
            content: bytifyRawString('content'),
          },
          toLock: recordAccount.lock,
          fromInfos: [recordAccount.address],
          config,
        }),
      ).rejects.toThrowError('Cannot reference Cluster because target Cluster does not supported lockProxy');
    }, 0);
    it('Create a Spore with Cluster (via cell reference)', async () => {
      const { cell: clusterCell, account: recordAccount } = await retryQuery(getClusterV1Record);

      expectCellLock(clusterCell, [CHARLIE.lock, ALICE.lock]);

      const clusterId = clusterCell.cellOutput.type!.args;
      const oppositeAccount = recordAccount.address === ALICE.address ? CHARLIE : ALICE;

      if (TEST_VARIABLES.network !== 'devnet') {
        // TODO: Wait for some block times to prevent double-spend, should resolve issue#25
        await waitForMilliseconds(20000);
      }

      const { txSkeleton, outputIndex, reference } = await createSpore({
        data: {
          clusterId: clusterId,
          contentType: 'text/plain',
          content: bytifyRawString('content'),
        },
        toLock: recordAccount.lock,
        fromInfos: [oppositeAccount.address],
        config,
      });

      const spore = getSporeOutput(txSkeleton, outputIndex, config);
      expect(spore.data.clusterId).toEqual(clusterId);

      expect(reference).toBeDefined();
      expect(reference.referenceTarget).toEqual('cluster');
      expect(reference.referenceType).toEqual('cell');

      expect(reference.cluster).toBeDefined();
      expect(reference.cluster).toHaveProperty('inputIndex');
      expect(reference.cluster).toHaveProperty('outputIndex');

      const cluster = getClusterOutput(txSkeleton, reference.cluster!.outputIndex, config);
      expectTypeCell(txSkeleton, 'both', cluster.cell.cellOutput.type!);
      expect(cluster.id).toEqual(clusterId);

      const clusterScript = getSporeScript(config, 'Cluster', cluster.cell.cellOutput.type!);
      expectCellDep(txSkeleton, clusterScript.cellDep);
      expectCellDep(txSkeleton, {
        outPoint: clusterCell.outPoint!,
        depType: 'code',
      });

      const { hash } = await signAndOrSendTransaction({
        account: [oppositeAccount, recordAccount],
        txSkeleton,
        config,
        rpc,
        send: true,
      });
      if (hash) {
        clusterV1OutPointRecord = {
          outPoint: {
            txHash: hash,
            index: BI.from(reference.cluster!.outputIndex).toHexString(),
          },
          account: recordAccount,
        };
        SPORE_OUTPOINT_RECORDS.push({
          outPoint: {
            txHash: hash,
            index: BI.from(outputIndex).toHexString(),
          },
          account: recordAccount,
        });
      }
    }, 0);
  });
});


================================================
File: packages/core/src/__tests__/ClusterProxyAgent.test.ts
================================================
import { afterAll, describe, expect, it } from 'vitest';
import { BI, utils } from '@ckb-lumos/lumos';
import { getSporeScript } from '../config';
import { bytifyRawString, minimalCellCapacityByLock, waitForMilliseconds } from '../helpers';
import { packRawClusterAgentDataToHash, unpackToRawClusterProxyArgs } from '../codec';
import { createSpore, createCluster, getClusterByOutPoint, getClusterById } from '../api';
import { createClusterProxy, transferClusterProxy, meltClusterProxy, getClusterProxyByOutPoint } from '../api';
import { createClusterAgent, transferClusterAgent, meltClusterAgent, getClusterAgentByOutPoint } from '../api';
import { expectCellDep, expectLockCell, expectTypeCell, expectTypeId, expectCellLock } from './helpers';
import { getClusterAgentOutput, getSporeOutput, getClusterProxyOutput, IdRecord } from './helpers';
import { signAndOrSendTransaction, retryQuery, popRecord, OutPointRecord } from './helpers';
import { getClusterOutput, getActionsFromCobuildWitnessLayout } from './helpers';
import { createSporeScriptInfoFromTemplate, ScriptInfo } from '../cobuild';
import {
  TEST_ENV,
  TEST_ACCOUNTS,
  TEST_VARIABLES,
  SPORE_OUTPOINT_RECORDS,
  CLUSTER_OUTPOINT_RECORDS,
  CLUSTER_PROXY_OUTPOINT_RECORDS,
  CLUSTER_AGENT_OUTPOINT_RECORDS,
  cleanupRecords,
} from './shared';

describe('ClusterProxy and ClusterAgent', () => {
  const { rpc, config, v1Config } = TEST_ENV;
  const { CHARLIE, ALICE } = TEST_ACCOUNTS;

  let existingClusterRecord: OutPointRecord | undefined;
  let existingClusterProxyRecord: OutPointRecord | undefined;
  let existingClusterAgentRecord: OutPointRecord | undefined;

  afterAll(async () => {
    await cleanupRecords({
      name: 'ClusterProxyAgent',
    });
  }, 0);

  describe('ClusterProxy basics', () => {
    it.skipIf(existingClusterRecord !== void 0 || CLUSTER_OUTPOINT_RECORDS.length > 0)(
      'Create a Cluster (if necessary)',
      async ({ skip }) => {
        if (existingClusterRecord !== void 0 || CLUSTER_OUTPOINT_RECORDS.length > 0) {
          console.log('skipping test');
          return skip();
        }

        const { txSkeleton, outputIndex } = await createCluster({
          data: {
            name: 'Testnet Spores',
            description: 'Testing only',
          },
          fromInfos: [CHARLIE.address],
          toLock: CHARLIE.lock,
          config,
        });
        const { hash } = await signAndOrSendTransaction({
          account: CHARLIE,
          txSkeleton,
          config,
          rpc,
          send: true,
        });
        if (hash) {
          CLUSTER_OUTPOINT_RECORDS.push({
            outPoint: {
              txHash: hash,
              index: BI.from(outputIndex).toHexString(),
            },
            account: CHARLIE,
          });
        }
      },
      0,
    );
    it('Create a ClusterProxy with Cluster (via lock proxy)', async () => {
      const clusterRecord = existingClusterRecord ?? popRecord(CLUSTER_OUTPOINT_RECORDS, true);
      const clusterCell = await retryQuery(() => getClusterByOutPoint(clusterRecord.outPoint, config));
      const clusterId = clusterCell.cellOutput.type!.args;

      const { txSkeleton, outputIndex, reference } = await createClusterProxy({
        clusterOutPoint: clusterCell.outPoint!,
        minPayment: 10,
        toLock: clusterRecord.account.lock,
        fromInfos: [clusterRecord.account.address],
        config,
      });

      const clusterProxy = getClusterProxyOutput(txSkeleton, outputIndex, config);
      expect(clusterProxy.cell.cellOutput.lock).toEqual(clusterRecord.account.lock);
      expectTypeId(txSkeleton, outputIndex, clusterProxy.id);
      expect(clusterProxy.data).toEqual(clusterId);
      expect(clusterProxy.args.minPayment).toBeDefined();
      expect(clusterProxy.args.minPayment!.toNumber()).toEqual(10);

      expectTypeCell(txSkeleton, 'output', clusterProxy.cell.cellOutput.type!);
      expectCellDep(txSkeleton, clusterProxy.script.cellDep);

      expect(reference).toBeDefined();
      expect(reference.referenceType).toEqual('lockProxy');
      expectLockCell(txSkeleton, 'both', clusterRecord.account.lock);
      expectCellDep(txSkeleton, {
        outPoint: clusterRecord.outPoint,
        depType: 'code',
      });

      const { hash } = await signAndOrSendTransaction({
        account: clusterRecord.account,
        txSkeleton,
        config,
        rpc,
        send: true,
      });
      if (hash) {
        existingClusterRecord = void 0;
        CLUSTER_OUTPOINT_RECORDS.push(clusterRecord);
        CLUSTER_PROXY_OUTPOINT_RECORDS.push({
          outPoint: {
            txHash: hash,
            index: BI.from(outputIndex).toHexString(),
          },
          account: clusterRecord.account,
        });
      }
    }, 0);
    it('Create a ClusterProxy with Cluster (via cell reference)', async () => {
      const clusterRecord = existingClusterRecord ?? popRecord(CLUSTER_OUTPOINT_RECORDS, true);
      const clusterCell = await retryQuery(() => getClusterByOutPoint(clusterRecord.outPoint, config));
      const clusterId = clusterCell.cellOutput.type!.args;

      expectCellLock(clusterCell, [CHARLIE.lock, ALICE.lock]);
      const oppositeAccount = clusterRecord.account.address === CHARLIE.address ? ALICE : CHARLIE;

      const { txSkeleton, outputIndex, reference } = await createClusterProxy({
        clusterOutPoint: clusterCell.outPoint!,
        minPayment: 10,
        toLock: clusterRecord.account.lock,
        fromInfos: [oppositeAccount.address],
        config,
      });

      const clusterProxy = getClusterProxyOutput(txSkeleton, outputIndex, config);
      expect(clusterProxy.cell.cellOutput.lock).toEqual(clusterRecord.account.lock);
      expectTypeId(txSkeleton, outputIndex, clusterProxy.id);
      expect(clusterProxy.data).toEqual(clusterId);
      expect(clusterProxy.args.minPayment).toBeDefined();
      expect(clusterProxy.args.minPayment!.toNumber()).toEqual(10);

      expectTypeCell(txSkeleton, 'output', clusterProxy.cell.cellOutput.type!);
      expectCellDep(txSkeleton, clusterProxy.script.cellDep);

      expect(reference).toBeDefined();
      expect(reference.referenceType).toEqual('cell');
      expect(reference.cluster).toBeDefined();
      expect(reference.cluster).toHaveProperty('inputIndex');
      expect(reference.cluster).toHaveProperty('outputIndex');

      expectTypeCell(txSkeleton, 'both', clusterCell.cellOutput.type!);

      const clusterScript = getSporeScript(config, 'Cluster', clusterCell.cellOutput.type!);
      expectCellDep(txSkeleton, clusterScript.cellDep);
      expectCellDep(txSkeleton, {
        outPoint: clusterRecord.outPoint,
        depType: 'code',
      });

      const { hash } = await signAndOrSendTransaction({
        account: [clusterRecord.account, oppositeAccount],
        txSkeleton,
        config,
        rpc,
        send: true,
      });
      if (hash) {
        existingClusterRecord = void 0;
        CLUSTER_OUTPOINT_RECORDS.push({
          outPoint: {
            txHash: hash,
            index: BI.from(reference.cluster!.outputIndex).toHexString(),
          },
          account: clusterRecord.account,
        });
        CLUSTER_PROXY_OUTPOINT_RECORDS.push({
          outPoint: {
            txHash: hash,
            index: BI.from(outputIndex).toHexString(),
          },
          account: clusterRecord.account,
        });
      }
    }, 0);
    it('Transfer a ClusterProxy', async () => {
      const clusterProxyRecord = existingClusterProxyRecord ?? popRecord(CLUSTER_PROXY_OUTPOINT_RECORDS, true);
      const clusterProxyCell = await retryQuery(() => getClusterProxyByOutPoint(clusterProxyRecord.outPoint, config));

      expectCellLock(clusterProxyCell, [CHARLIE.lock, ALICE.lock]);
      const oppositeAccount = clusterProxyRecord.account.address === CHARLIE.address ? ALICE : CHARLIE;

      const { txSkeleton, outputIndex } = await transferClusterProxy({
        outPoint: clusterProxyCell.outPoint!,
        fromInfos: [clusterProxyRecord.account.address],
        toLock: oppositeAccount.lock,
        config,
      });

      const clusterProxy = getClusterProxyOutput(txSkeleton, outputIndex, config);
      expect(clusterProxy.cell.cellOutput.lock).toEqual(oppositeAccount.lock);
      expect(clusterProxy.args.minPayment).toBeDefined();
      expect(clusterProxy.args.minPayment!.toNumber()).toEqual(10);

      expectTypeCell(txSkeleton, 'both', clusterProxy.cell.cellOutput.type!);
      expectCellDep(txSkeleton, clusterProxy.script.cellDep);

      const witness = txSkeleton.get('witnesses').last();
      expect(witness).toBeDefined();
      const actions = getActionsFromCobuildWitnessLayout(witness!);
      expect(actions[0]).toBeDefined();
      expect(actions[0]).toHaveProperty('sporeActionData');
      expect(actions[0].sporeActionData).toHaveProperty('type', 'TransferClusterProxy');

      const clusterProxyType = clusterProxy.cell.cellOutput.type!;
      const clusterProxyTypeHash = utils.computeScriptHash(clusterProxyType);
      const scriptInfo = createSporeScriptInfoFromTemplate({
        scriptHash: clusterProxyTypeHash,
      });
      const scriptInfoHash = utils.ckbHash(ScriptInfo.pack(scriptInfo));
      expect(actions[0].scriptHash).toEqual(clusterProxyTypeHash);
      expect(actions[0].scriptInfoHash).toEqual(scriptInfoHash);

      const sporeActionData = actions[0].sporeActionData;
      expect(sporeActionData).toHaveProperty('type');
      expect(sporeActionData).toHaveProperty('type', 'TransferClusterProxy');
      expect(sporeActionData).toHaveProperty('value');
      expect(sporeActionData.value).toHaveProperty('clusterId', clusterProxy.data);
      expect(sporeActionData.value).toHaveProperty('clusterProxyId', clusterProxy.id);
      expect(sporeActionData.value).toHaveProperty('from', {
        type: 'Script',
        value: clusterProxyRecord.account.lock,
      });
      expect(sporeActionData.value).toHaveProperty('to', {
        type: 'Script',
        value: clusterProxy.cell.cellOutput.lock,
      });

      const { hash } = await signAndOrSendTransaction({
        account: clusterProxyRecord.account,
        txSkeleton,
        config,
        rpc,
        send: true,
      });
      if (hash) {
        existingClusterProxyRecord = void 0;
        CLUSTER_PROXY_OUTPOINT_RECORDS.push({
          outPoint: {
            txHash: hash,
            index: BI.from(outputIndex).toHexString(),
          },
          account: oppositeAccount,
        });
      }
    }, 0);
    it('Melt a ClusterProxy', async () => {
      const clusterProxyRecord = existingClusterProxyRecord ?? popRecord(CLUSTER_PROXY_OUTPOINT_RECORDS, true);
      const clusterProxyCell = await retryQuery(() => getClusterProxyByOutPoint(clusterProxyRecord.outPoint, config));
      const clusterProxyType = clusterProxyCell.cellOutput.type;

      const { txSkeleton } = await meltClusterProxy({
        outPoint: clusterProxyCell.outPoint!,
        changeAddress: clusterProxyRecord.account.address,
        config,
      });

      expectTypeCell(txSkeleton, 'input', clusterProxyCell.cellOutput.type!);

      const clusterProxyScript = getSporeScript(config, 'ClusterProxy', clusterProxyType!);
      expectCellDep(txSkeleton, clusterProxyScript.cellDep);

      const { hash } = await signAndOrSendTransaction({
        account: clusterProxyRecord.account,
        txSkeleton,
        config,
        rpc,
        send: true,
      });
      if (hash) {
        existingClusterProxyRecord = void 0;
      }
    }, 0);
  });

  describe('ClusterAgent basics', () => {
    it('Create a ClusterAgent with ClusterProxy (via payment)', async () => {
      const clusterProxyRecord = existingClusterProxyRecord ?? popRecord(CLUSTER_PROXY_OUTPOINT_RECORDS, true);
      const clusterProxyCell = await retryQuery(() => getClusterProxyByOutPoint(clusterProxyRecord.outPoint, config));
      const clusterProxyArgs = unpackToRawClusterProxyArgs(clusterProxyCell.cellOutput.type!.args);
      const minPayment = clusterProxyArgs.minPayment;
      expect(minPayment).toBeDefined();

      expectCellLock(clusterProxyCell, [CHARLIE.lock, ALICE.lock]);
      const oppositeAccount = clusterProxyRecord.account.address === CHARLIE.address ? ALICE : CHARLIE;

      const { txSkeleton, outputIndex, reference } = await createClusterAgent({
        clusterProxyOutPoint: clusterProxyRecord.outPoint!,
        referenceType: 'payment',
        toLock: oppositeAccount.lock,
        fromInfos: [oppositeAccount.address],
        config,
      });

      const clusterAgent = getClusterAgentOutput(txSkeleton, outputIndex, config);
      expect(clusterAgent.cell.cellOutput.lock).toEqual(oppositeAccount.lock);
      expect(clusterAgent.cell.cellOutput.type!.args).toEqual(clusterProxyCell.data);
      expect(clusterAgent.data).toEqual(packRawClusterAgentDataToHash(clusterProxyCell.cellOutput.type!));

      expectCellDep(txSkeleton, clusterAgent.script.cellDep);

      expect(reference.referenceType).toEqual('payment');
      expect(reference.payment).toBeDefined();
      expect(reference.payment).toHaveProperty('outputIndex');

      const paymentCell = txSkeleton.get('outputs').get(reference.payment!.outputIndex!);
      expect(paymentCell).toBeDefined();
      expect(paymentCell!.cellOutput.lock).toEqual(clusterProxyCell.cellOutput.lock);

      const minimalPayment = BI.from(minPayment!);
      const lockRequiredCapacity = minimalCellCapacityByLock(clusterProxyCell.cellOutput.lock);
      const expectedPayment = lockRequiredCapacity.gt(minimalPayment) ? lockRequiredCapacity : minimalPayment;
      expect(BI.from(paymentCell!.cellOutput.capacity).gte(expectedPayment)).toEqual(true);

      const clusterProxyScript = getSporeScript(config, 'ClusterProxy', clusterProxyCell.cellOutput.type!);
      expectCellDep(txSkeleton, clusterProxyScript.cellDep);
      expectCellDep(txSkeleton, {
        outPoint: clusterProxyRecord.outPoint,
        depType: 'code',
      });

      const { hash } = await signAndOrSendTransaction({
        account: oppositeAccount,
        txSkeleton,
        config,
        rpc,
        send: true,
      });
      if (hash) {
        existingClusterProxyRecord = void 0;
        CLUSTER_PROXY_OUTPOINT_RECORDS.push(clusterProxyRecord);
        CLUSTER_AGENT_OUTPOINT_RECORDS.push({
          outPoint: {
            txHash: hash,
            index: BI.from(outputIndex).toHexString(),
          },
          account: oppositeAccount,
        });
      }
    }, 0);
    it('Create a ClusterAgent with ClusterProxy (via cell reference)', async () => {
      const clusterProxyRecord = existingClusterProxyRecord ?? popRecord(CLUSTER_PROXY_OUTPOINT_RECORDS, true);
      const clusterProxyCell = await retryQuery(() => getClusterProxyByOutPoint(clusterProxyRecord.outPoint, config));

      expectCellLock(clusterProxyCell, [CHARLIE.lock, ALICE.lock]);
      const oppositeAccount = clusterProxyRecord.account.address === CHARLIE.address ? ALICE : CHARLIE;

      const { txSkeleton, outputIndex, reference } = await createClusterAgent({
        clusterProxyOutPoint: clusterProxyRecord.outPoint!,
        referenceType: 'cell',
        toLock: oppositeAccount.lock,
        fromInfos: [clusterProxyRecord.account.address],
        config,
      });

      const clusterAgent = getClusterAgentOutput(txSkeleton, outputIndex, config);
      expect(clusterAgent.cell.cellOutput.lock).toEqual(oppositeAccount.lock);
      expect(clusterAgent.cell.cellOutput.type!.args).toEqual(clusterProxyCell.data);
      expect(clusterAgent.data).toEqual(packRawClusterAgentDataToHash(clusterProxyCell.cellOutput.type!));

      expectCellDep(txSkeleton, clusterAgent.script.cellDep);

      expect(reference.referenceType).toEqual('cell');
      expect(reference.clusterProxy).toBeDefined();
      expect(reference.clusterProxy).toHaveProperty('inputIndex');
      expect(reference.clusterProxy).toHaveProperty('outputIndex');

      expectTypeCell(txSkeleton, 'both', clusterProxyCell.cellOutput.type!);

      const clusterProxyScript = getSporeScript(config, 'ClusterProxy', clusterProxyCell.cellOutput.type!);
      expectCellDep(txSkeleton, clusterProxyScript.cellDep);
      expectCellDep(txSkeleton, {
        outPoint: clusterProxyRecord.outPoint,
        depType: 'code',
      });

      const { hash } = await signAndOrSendTransaction({
        account: clusterProxyRecord.account,
        txSkeleton,
        config,
        rpc,
        send: true,
      });
      if (hash) {
        existingClusterProxyRecord = void 0;
        CLUSTER_PROXY_OUTPOINT_RECORDS.push({
          outPoint: {
            txHash: hash,
            index: BI.from(reference.clusterProxy!.outputIndex).toHexString(),
          },
          account: clusterProxyRecord.account,
        });
        CLUSTER_AGENT_OUTPOINT_RECORDS.push({
          outPoint: {
            txHash: hash,
            index: BI.from(outputIndex).toHexString(),
          },
          account: oppositeAccount,
        });
      }
    }, 0);
    it('Transfer a ClusterAgent', async () => {
      const clusterAgentRecord = existingClusterAgentRecord ?? popRecord(CLUSTER_AGENT_OUTPOINT_RECORDS, true);
      const clusterAgentCell = await retryQuery(() => getClusterAgentByOutPoint(clusterAgentRecord.outPoint, config));

      expectCellLock(clusterAgentCell, [CHARLIE.lock, ALICE.lock]);
      const oppositeAccount = clusterAgentRecord.account.address === CHARLIE.address ? ALICE : CHARLIE;

      const { txSkeleton, outputIndex } = await transferClusterAgent({
        outPoint: clusterAgentCell.outPoint!,
        fromInfos: [clusterAgentRecord.account.address],
        toLock: oppositeAccount.lock,
        config,
      });

      const clusterAgent = getClusterAgentOutput(txSkeleton, outputIndex, config);
      expect(clusterAgent.cell.cellOutput.lock).toEqual(oppositeAccount.lock);

      expectTypeCell(txSkeleton, 'both', clusterAgent.cell.cellOutput.type!);
      expectCellDep(txSkeleton, clusterAgent.script.cellDep);

      const { hash } = await signAndOrSendTransaction({
        account: [clusterAgentRecord.account, oppositeAccount],
        txSkeleton,
        config,
        rpc,
        send: true,
      });
      if (hash) {
        existingClusterAgentRecord = void 0;
        CLUSTER_AGENT_OUTPOINT_RECORDS.push({
          outPoint: {
            txHash: hash,
            index: BI.from(outputIndex).toHexString(),
          },
          account: oppositeAccount,
        });
      }
    }, 0);
    it('Melt a ClusterAgent', async () => {
      const clusterAgentRecord = existingClusterAgentRecord ?? popRecord(CLUSTER_AGENT_OUTPOINT_RECORDS, true);
      const clusterAgentCell = await retryQuery(() => getClusterAgentByOutPoint(clusterAgentRecord.outPoint, config));
      const clusterAgentType = clusterAgentCell.cellOutput.type!;

      const { txSkeleton } = await meltClusterAgent({
        outPoint: clusterAgentCell.outPoint!,
        changeAddress: clusterAgentRecord.account.address,
        config,
      });

      expectTypeCell(txSkeleton, 'input', clusterAgentCell.cellOutput.type!);

      const clusterAgentScript = getSporeScript(config, 'ClusterAgent', clusterAgentType);
      expectCellDep(txSkeleton, clusterAgentScript.cellDep);

      const { hash } = await signAndOrSendTransaction({
        account: clusterAgentRecord.account,
        txSkeleton,
        config,
        rpc,
        send: true,
      });
      if (hash) {
        existingClusterAgentRecord = void 0;
      }
    }, 0);
  });

  describe('Spore with ClusterAgent', () => {
    it('Create a Spore with ClusterAgent (via lock proxy)', async () => {
      const clusterAgentRecord = existingClusterAgentRecord ?? popRecord(CLUSTER_AGENT_OUTPOINT_RECORDS, true);
      const clusterAgentCell = await retryQuery(() => getClusterAgentByOutPoint(clusterAgentRecord.outPoint, config));
      const clusterId = clusterAgentCell.cellOutput.type!.args;

      const { txSkeleton, outputIndex, reference } = await createSpore({
        data: {
          clusterId,
          contentType: 'text/plain',
          content: bytifyRawString('content'),
        },
        clusterAgentOutPoint: clusterAgentCell.outPoint!,
        fromInfos: [clusterAgentRecord.account.address],
        toLock: clusterAgentRecord.account.lock,
        config,
      });

      const spore = getSporeOutput(txSkeleton, outputIndex, config);
      expect(spore.data.clusterId).toEqual(clusterId);

      expect(reference.referenceTarget).toEqual('clusterAgent');
      expect(reference.referenceType).toEqual('lockProxy');
      expectLockCell(txSkeleton, 'both', clusterAgentCell.cellOutput.lock);

      const clusterScript = getSporeScript(config, 'ClusterAgent', clusterAgentCell.cellOutput.type!);
      expectCellDep(txSkeleton, clusterScript.cellDep);
      expectCellDep(txSkeleton, {
        outPoint: clusterAgentRecord.outPoint,
        depType: 'code',
      });

      const { hash } = await signAndOrSendTransaction({
        account: clusterAgentRecord.account,
        txSkeleton,
        config,
        rpc,
        send: true,
      });
      if (hash) {
        existingClusterAgentRecord = void 0;
        CLUSTER_AGENT_OUTPOINT_RECORDS.push(clusterAgentRecord);
        SPORE_OUTPOINT_RECORDS.push({
          outPoint: {
            txHash: hash,
            index: BI.from(outputIndex).toHexString(),
          },
          account: clusterAgentRecord.account,
        });
      }
    }, 0);
    it('Create a Spore with ClusterAgent (via cell reference)', async () => {
      const clusterAgentRecord = existingClusterAgentRecord ?? popRecord(CLUSTER_AGENT_OUTPOINT_RECORDS, true);
      const clusterAgentCell = await retryQuery(() => getClusterAgentByOutPoint(clusterAgentRecord.outPoint, config));
      const clusterId = clusterAgentCell.cellOutput.type!.args;

      expectCellLock(clusterAgentCell, [CHARLIE.lock, ALICE.lock]);
      const oppositeAccount = clusterAgentRecord.account.address === CHARLIE.address ? ALICE : CHARLIE;

      const { txSkeleton, outputIndex, reference } = await createSpore({
        data: {
          clusterId,
          contentType: 'text/plain',
          content: bytifyRawString('content'),
        },
        clusterAgentOutPoint: clusterAgentCell.outPoint!,
        toLock: clusterAgentRecord.account.lock,
        fromInfos: [oppositeAccount.address],
        config,
      });

      const spore = getSporeOutput(txSkeleton, outputIndex, config);
      expect(spore.data.clusterId).toEqual(clusterId);

      expect(reference.referenceTarget).toEqual('clusterAgent');
      expect(reference.referenceType).toEqual('cell');
      expect(reference.clusterAgent).toBeDefined();
      expect(reference.clusterAgent).toHaveProperty('inputIndex');
      expect(reference.clusterAgent).toHaveProperty('outputIndex');

      const clusterAgentType = clusterAgentCell.cellOutput.type!;
      expectTypeCell(txSkeleton, 'both', clusterAgentType);

      const clusterScript = getSporeScript(config, 'ClusterAgent', clusterAgentType);
      expectCellDep(txSkeleton, clusterScript.cellDep);
      expectCellDep(txSkeleton, {
        outPoint: clusterAgentRecord.outPoint,
        depType: 'code',
      });

      const { hash } = await signAndOrSendTransaction({
        account: [oppositeAccount, clusterAgentRecord.account],
        txSkeleton,
        config,
        rpc,
        send: true,
      });
      if (hash) {
        existingClusterAgentRecord = void 0;
        CLUSTER_AGENT_OUTPOINT_RECORDS.push({
          outPoint: {
            txHash: hash,
            index: BI.from(reference.clusterAgent!.outputIndex).toHexString(),
          },
          account: clusterAgentRecord.account,
        });
        SPORE_OUTPOINT_RECORDS.push({
          outPoint: {
            txHash: hash,
            index: BI.from(outputIndex).toHexString(),
          },
          account: clusterAgentRecord.account,
        });
      }
    }, 0);
  });

  describe.runIf(TEST_VARIABLES.tests.clusterV1)('ClusterAgent with Cluster (v1)', () => {
    let clusterV1OutPointRecord: OutPointRecord | undefined;
    const clusterV1IdRecord: IdRecord = {
      id: '0x8b9f893397310a3bbd925cd1c9ab606555675bb2d03f3c5cb934f2ba4ef97e93',
      account: CHARLIE,
    };

    async function getClusterV1Record() {
      if (TEST_VARIABLES.network === 'devnet') {
        expect(clusterV1OutPointRecord).toBeDefined();
        return {
          cell: await getClusterByOutPoint(clusterV1OutPointRecord!.outPoint, config),
          account: clusterV1OutPointRecord!.account,
        };
      } else {
        expect(clusterV1IdRecord).toBeDefined();
        const cell = await getClusterById(clusterV1IdRecord.id, config);
        return {
          cell: await getClusterByOutPoint(cell.outPoint!, config),
          account: clusterV1IdRecord.account,
        };
      }
    }

    it.runIf(TEST_VARIABLES.network === 'devnet')(
      'Create a Cluster (v1) if necessary',
      async () => {
        // Wait some time for the indexer to be updated
        await waitForMilliseconds(1500);

        const { txSkeleton, outputIndex } = await createCluster({
          data: {
            name: 'Testnet Spores',
            description: 'Testing only',
          },
          fromInfos: [CHARLIE.address],
          toLock: CHARLIE.lock,
          config: v1Config,
        });

        const clusterOutput = getClusterOutput(txSkeleton, outputIndex, v1Config);
        const clusterScript = clusterOutput.script;

        expect(clusterScript).toHaveProperty('tags');
        expect(clusterScript.tags).toContain('v1');

        const { hash } = await signAndOrSendTransaction({
          account: CHARLIE,
          txSkeleton,
          rpc,
          send: true,
          config: v1Config,
        });
        if (hash) {
          clusterV1OutPointRecord = {
            outPoint: {
              txHash: hash,
              index: BI.from(outputIndex).toHexString(),
            },
            account: CHARLIE,
          };
        }
      },
      0,
    );
    it('Create a ClusterProxy with Cluster (via lock proxy)', async () => {
      const { cell: clusterCell, account: recordAccount } = await retryQuery(getClusterV1Record);

      expectCellLock(clusterCell, [CHARLIE.lock, ALICE.lock]);

      await expect(() =>
        createClusterProxy({
          clusterOutPoint: clusterCell.outPoint!,
          minPayment: 10,
          toLock: recordAccount.lock,
          fromInfos: [recordAccount.address],
          config,
        }),
      ).rejects.toThrowError('Cannot reference Cluster because target Cluster does not supported lockProxy');
    }, 0);
    it('Create a ClusterProxy with Cluster (via cell reference)', async () => {
      const { cell: clusterCell, account: recordAccount } = await retryQuery(getClusterV1Record);

      expectCellLock(clusterCell, [CHARLIE.lock, ALICE.lock]);
      const oppositeAccount = recordAccount.address === CHARLIE.address ? ALICE : CHARLIE;

      const clusterId = clusterCell.cellOutput.type!.args;

      const { txSkeleton, outputIndex, reference } = await createClusterProxy({
        clusterOutPoint: clusterCell.outPoint!,
        minPayment: 10,
        toLock: recordAccount.lock,
        fromInfos: [oppositeAccount.address],
        config,
      });

      const clusterProxy = getClusterProxyOutput(txSkeleton, outputIndex, config);
      expect(clusterProxy.cell.cellOutput.lock).toEqual(recordAccount.lock);
      expectTypeId(txSkeleton, outputIndex, clusterProxy.id);
      expect(clusterProxy.data).toEqual(clusterId);
      expect(clusterProxy.args.minPayment).toBeDefined();
      expect(clusterProxy.args.minPayment!.toNumber()).toEqual(10);

      expectTypeCell(txSkeleton, 'output', clusterProxy.cell.cellOutput.type!);
      expectCellDep(txSkeleton, clusterProxy.script.cellDep);

      expect(reference).toBeDefined();
      expect(reference.referenceType).toEqual('cell');
      expect(reference.cluster).toBeDefined();
      expect(reference.cluster).toHaveProperty('inputIndex');
      expect(reference.cluster).toHaveProperty('outputIndex');

      expectTypeCell(txSkeleton, 'both', clusterCell.cellOutput.type!);

      const clusterScript = getSporeScript(config, 'Cluster', clusterCell.cellOutput.type!);
      expectCellDep(txSkeleton, clusterScript.cellDep);
      expectCellDep(txSkeleton, {
        outPoint: clusterCell.outPoint!,
        depType: 'code',
      });

      const { hash } = await signAndOrSendTransaction({
        account: [recordAccount, oppositeAccount],
        txSkeleton,
        config,
        rpc,
        send: true,
      });
      if (hash) {
        clusterV1OutPointRecord = {
          outPoint: {
            txHash: hash,
            index: BI.from(reference.cluster!.outputIndex).toHexString(),
          },
          account: recordAccount,
        };
        CLUSTER_OUTPOINT_RECORDS.push({
          outPoint: {
            txHash: hash,
            index: BI.from(reference.cluster!.outputIndex).toHexString(),
          },
          account: recordAccount,
        });
        CLUSTER_PROXY_OUTPOINT_RECORDS.push({
          outPoint: {
            txHash: hash,
            index: BI.from(outputIndex).toHexString(),
          },
          account: recordAccount,
        });
      }
    }, 0);
  });
});


================================================
File: packages/core/src/__tests__/Codec.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { bytes } from '@ckb-lumos/codec';
import { BI, HexString } from '@ckb-lumos/lumos';
import { bytifyRawString } from '../helpers';
import { packRawSporeData, unpackToRawSporeData, RawSporeData, RawString } from '../codec';
import { packRawClusterData, unpackToRawClusterData, RawClusterData } from '../codec';
import { packRawClusterProxyArgs, unpackToRawClusterProxyArgs, RawClusterProxyArgs } from '../codec';
import { packRawClusterAgentDataToHash, RawClusterAgentData } from '../codec';

interface PackableTest<T> {
  packable: T;
  packed: HexString;
}

describe('Codec', function () {
  /**
   * RawString
   */
  it('Encode via RawString codec', () => {
    expect(RawString.pack('content')).toEqual(bytes.bytify('0x07000000636f6e74656e74'));
    expect(RawString.unpack('0x07000000636f6e74656e74')).toEqual('content');
  });

  /**
   * SporeData
   */
  const sporeDataTests: PackableTest<RawSporeData>[] = [
    {
      packable: {
        contentType: 'text/plain',
        content: bytifyRawString('testing plain text'),
        clusterId: '0x21a30f2b2f4927dbd6fd3917990af0dbb868438f44184e84d515f9af84ae4861',
      },
      packed:
        '0x58000000100000001e000000340000000a000000746578742f706c61696e1200000074657374696e6720706c61696e20746578742000000021a30f2b2f4927dbd6fd3917990af0dbb868438f44184e84d515f9af84ae4861',
    },
    {
      packable: {
        contentType: 'text/plain',
        content: bytifyRawString('testing plain text'),
      },
      packed:
        '0x34000000100000001e000000340000000a000000746578742f706c61696e1200000074657374696e6720706c61696e2074657874',
    },
  ];
  it('Pack SporeData', function () {
    for (let i = 0; i < sporeDataTests.length; i++) {
      const test = sporeDataTests[i];
      const packed = packRawSporeData(test.packable);
      const packedHex = bytes.hexify(packed);
      expect(packedHex).eq(test.packed, `SporeData in test #${i} should be packable`);
    }
  });
  it('Unpack SporeData', function () {
    for (let i = 0; i < sporeDataTests.length; i++) {
      const test = sporeDataTests[i];
      const unpacked = unpackToRawSporeData(test.packed);

      // SporeData.content
      expect(bytes.equal(unpacked.content, test.packable.content)).eq(
        true,
        `SporeData.content in test #${i} should be unpackable`,
      );

      // SporeData.contentType
      expect(unpacked.contentType).eq(
        test.packable.contentType,
        `SporeData.contentType in test #${i} should be unpackable`,
      );

      // SporeData.clusterId
      if (test.packable.clusterId !== void 0) {
        expect(unpacked.clusterId).toBeDefined();

        const unpackedClusterId = bytes.bytify(unpacked.clusterId!);
        const packableClusterId = bytes.bytify(test.packable.clusterId!);
        expect(bytes.equal(unpackedClusterId, packableClusterId)).eq(
          true,
          `SporeData.clusterId in test #${i} should be unpackable`,
        );
      } else {
        expect(unpacked.clusterId).toBeUndefined();
      }
    }
  });

  /**
   * ClusterData
   */
  const clusterDataTests: PackableTest<RawClusterData>[] = [
    {
      packable: {
        name: 'cluster name',
        description: 'description of the cluster',
      },
      packed:
        '0x3e00000010000000200000003e0000000c000000636c7573746572206e616d651a0000006465736372697074696f6e206f662074686520636c7573746572',
    },
    {
      packable: {
        name: 'cluster name',
        description: 'description of the cluster',
        mutantId: '0x000000000000000000000000000000000000000000000000000000000000000a',
      },
      packed:
        '0x6200000010000000200000003e0000000c000000636c7573746572206e616d651a0000006465736372697074696f6e206f662074686520636c757374657220000000000000000000000000000000000000000000000000000000000000000000000a',
    },
  ];
  it('Pack ClusterData', function () {
    for (let i = 0; i < clusterDataTests.length; i++) {
      const test = clusterDataTests[i];
      const packed = packRawClusterData(test.packable);
      const packedHex = bytes.hexify(packed);
      expect(packedHex).eq(test.packed, `ClusterData in test #${i} should be packable`);
    }
  });
  it('Unpack ClusterData', function () {
    for (let i = 0; i < clusterDataTests.length; i++) {
      const test = clusterDataTests[i];
      const unpacked = unpackToRawClusterData(test.packed);

      // ClusterData.name
      expect(unpacked.name).eq(test.packable.name, `ClusterData.name in test #${i} should be unpackable`);

      // ClusterData.description
      expect(unpacked.description).eq(
        test.packable.description,
        `ClusterData.description in test #${i} should be unpackable`,
      );
    }
  });
  const clusterDataV1Tests: PackableTest<RawClusterData>[] = [
    {
      packable: {
        name: 'cluster name',
        description: 'description of the cluster',
      },
      packed:
        '0x3a0000000c0000001c0000000c000000636c7573746572206e616d651a0000006465736372697074696f6e206f662074686520636c7573746572',
    },
  ];
  it('Pack ClusterDataV1', function () {
    for (let i = 0; i < clusterDataV1Tests.length; i++) {
      const test = clusterDataV1Tests[i];
      const packed = packRawClusterData(test.packable, 'v1');
      const packedHex = bytes.hexify(packed);
      expect(packedHex).eq(test.packed, `ClusterDataV1 in test #${i} should be packable`);
    }
  });
  it('Unpack ClusterDataV1', function () {
    for (let i = 0; i < clusterDataV1Tests.length; i++) {
      const test = clusterDataV1Tests[i];
      const unpacked = unpackToRawClusterData(test.packed);
      const unpackedV1 = unpackToRawClusterData(test.packed, 'v1');

      // Cluster unpacked with/without version specified should be the same
      expect(unpacked).toEqual(unpackedV1);

      // ClusterData.name
      expect(unpacked.name).eq(test.packable.name, `ClusterDataV1.name in test #${i} should be unpackable`);

      // ClusterData.description
      expect(unpacked.description).eq(
        test.packable.description,
        `ClusterDataV1.description in test #${i} should be unpackable`,
      );
    }
  });

  /**
   * ClusterProxyArgs
   */
  const clusterProxyArgsTests: PackableTest<RawClusterProxyArgs>[] = [
    {
      packable: {
        id: '0x8e005ff187895a0ae9288462299b6e43ee349fafdf3bca4a3886285b5439d7b9',
        minPayment: void 0,
      },
      packed: '0x8e005ff187895a0ae9288462299b6e43ee349fafdf3bca4a3886285b5439d7b9',
    },
    {
      packable: {
        id: '0x8e005ff187895a0ae9288462299b6e43ee349fafdf3bca4a3886285b5439d7b9',
        minPayment: BI.from(1),
      },
      packed: '0x8e005ff187895a0ae9288462299b6e43ee349fafdf3bca4a3886285b5439d7b90100000000000000',
    },
    {
      packable: {
        id: '0x8e005ff187895a0ae9288462299b6e43ee349fafdf3bca4a3886285b5439d7b9',
        minPayment: BI.from(255),
      },
      packed: '0x8e005ff187895a0ae9288462299b6e43ee349fafdf3bca4a3886285b5439d7b9ff00000000000000',
    },
  ];
  it('Pack ClusterProxyArgs', function () {
    for (let i = 0; i < clusterProxyArgsTests.length; i++) {
      const test = clusterProxyArgsTests[i];
      const packed = packRawClusterProxyArgs(test.packable);
      const packedHex = bytes.hexify(packed);
      expect(packedHex).eq(test.packed, `ClusterProxyArgs in test #${i} should be packable`);
    }
  });
  it('Unpack ClusterProxyArgs', function () {
    for (let i = 0; i < clusterProxyArgsTests.length; i++) {
      const test = clusterProxyArgsTests[i];
      const unpacked = unpackToRawClusterProxyArgs(test.packed);

      // ClusterProxyArgs.id
      expect(unpacked.id).eq(test.packable.id, `ClusterProxyArgs.id in test #${i} should be unpackable`);

      // ClusterProxyArgs.minPayment
      if (test.packable.minPayment !== void 0) {
        expect(unpacked.minPayment).toBeDefined();
        const minPayment = unpacked.minPayment!.toHexString();
        const expectMinPayment = test.packable.minPayment!.toHexString();
        expect(minPayment).eq(expectMinPayment, `ClusterProxyArgs.minPayment in test #${i} should be unpackable`);
      } else {
        expect(unpacked.minPayment).toBeUndefined();
      }
    }
  });
  const clusterProxyArgsFailTests: RawClusterProxyArgs[] = [
    {
      id: '0x8e005ff187895a0ae9288462299b6e43ee349fafdf3bca4a3886285b5439d7b9ff',
      minPayment: void 0,
    },
    {
      id: '0x8e005ff187895a0ae9288462299b6e43ee349fafdf3bca4a3886285b5439d7b9',
      minPayment: BI.from(256),
    },
  ];
  it('Pack unpackable ClusterProxyArgs', function () {
    for (const test of clusterProxyArgsFailTests) {
      expect(() => packRawClusterProxyArgs(test, 'power')).toThrow();
    }
  });

  /**
   * ClusterAgentData
   */
  const clusterAgentDataTests: PackableTest<RawClusterAgentData>[] = [
    {
      packable: {
        codeHash: '0x0000000000000000000000000000000000000000000000000000000000000000',
        hashType: 'type',
        args: '0x8e005ff187895a0ae9288462299b6e43ee349fafdf3bca4a3886285b5439d7b9',
      },
      packed: '0xbd18dfa7db881ee319740db006d7495d96074fbbffc7a4fab5e5adb176305357',
    },
  ];
  it('Pack ClusterAgentData', function () {
    for (let i = 0; i < clusterAgentDataTests.length; i++) {
      const test = clusterAgentDataTests[i];
      const packedHex = packRawClusterAgentDataToHash(test.packable);
      expect(packedHex).eq(test.packed, `ClusterAgentData in test #${i} should be packable`);
    }
  });
});


================================================
File: packages/core/src/__tests__/ContentType.test.ts
================================================
import { describe, it, expect } from 'vitest';
import { encodeContentType, decodeContentType, isContentTypeValid, setContentTypeParameters } from '../helpers';

describe('ContentType', function () {
  /**
   * Decode SporeData.contentType
   */
  it('Decode valid MIME', function () {
    const mimes: string[] = [
      'image/png',
      'image/png;immortal=true',
      'text/plain;mutant[]=000000000000000000000000000000000000000000000000000000000000000a',
      'text/plain;mutant[]="000000000000000000000000000000000000000000000000000000000000000a,000000000000000000000000000000000000000000000000000000000000000b"',
    ];

    for (const mime of mimes) {
      const isValid = isContentTypeValid(mime);
      expect(isValid).eq(true, `"${mime}" should be valid`);
    }
  });
  it('Decode invalid MIME', function () {
    const mimes: string[] = [
      'plain/;',
      'text',
      ';',
      '-',
      'plain/',
      'plain/test;;test=;',
      'plain/test;a=;;b=2',
      'text/plain;mutant[]=0xa,0xb',
      'text/plain;mutant[]="0xa,0xb"',
    ];

    for (const mime of mimes) {
      const isValid = isContentTypeValid(mime);
      expect(isValid).eq(false, `"${mime}" should be invalid`);
    }
  });
  it('Decode MIME with redundant parameters', function () {
    const t = decodeContentType('image/svg+xml;q=";";q=0.8');
    expect(t.parameters).toHaveProperty('q', ';');
  });
  it('Decode MIME with array but without quoted-string', function () {
    const t = decodeContentType(
      'text/plain;mutant[]=000000000000000000000000000000000000000000000000000000000000000a,000000000000000000000000000000000000000000000000000000000000000b',
    );
    expect(t.parameters).toHaveProperty('mutant', [
      '0x000000000000000000000000000000000000000000000000000000000000000a',
      '0x000000000000000000000000000000000000000000000000000000000000000b',
    ]);
  });

  /**
   * Encode SporeData.contentType
   */
  it('Encode normal MIME', function () {
    const t = encodeContentType({
      type: 'image',
      subtype: 'svg+xml',
      parameters: {
        immortal: true,
        q: 0.9,
      },
    });
    expect(t).toEqual('image/svg+xml;immortal=true;q=0.9');
  });
  it('Encode MIME with an array of mutants', function () {
    const t = encodeContentType({
      type: 'text',
      subtype: 'plain',
      parameters: {
        mutant: [
          '000000000000000000000000000000000000000000000000000000000000000a',
          '0x000000000000000000000000000000000000000000000000000000000000000b',
        ],
      },
    });
    expect(t).toEqual(
      'text/plain;mutant[]="000000000000000000000000000000000000000000000000000000000000000a,000000000000000000000000000000000000000000000000000000000000000b"',
    );
  });
  it('Encode MIME with non-array mutant', function () {
    const event = () =>
      encodeContentType({
        type: 'text',
        subtype: 'plain',
        parameters: {
          mutant: '0x000000000000000000000000000000000000000000000000000000000000000b',
        },
      });
    expect(event).toThrow();
  });
  it('Encode MIME with mutant, key name with []', function () {
    const t = encodeContentType({
      type: 'text',
      subtype: 'plain',
      parameters: {
        'mutant[]': ['0x000000000000000000000000000000000000000000000000000000000000000a'],
      },
    });
    expect(t).eq('text/plain;mutant[]=000000000000000000000000000000000000000000000000000000000000000a');
  });
  it('Update existing ContentType', () => {
    const type = setContentTypeParameters('text/plain;immortal=true', {
      mutant: [
        '000000000000000000000000000000000000000000000000000000000000000a',
        '0x000000000000000000000000000000000000000000000000000000000000000b',
      ],
    });
    expect(type).eq(
      'text/plain;immortal=true;mutant[]="000000000000000000000000000000000000000000000000000000000000000a,000000000000000000000000000000000000000000000000000000000000000b"',
    );
  });
});


================================================
File: packages/core/src/__tests__/MimeType.test.ts
================================================
import { describe, it, expect } from 'vitest';
import { parseMimeType, serializeMimeType } from '../helpers';

describe('ContentType', function () {
  /**
   * Parse MIME
   */
  it('Parse normal MIME', function () {
    const decoded = parseMimeType('image/png;immortal=true;ipfs="0x010aff15"');

    expect(decoded).not.toBeNull();
    expect(decoded!.parameters.get('immortal')).eq('true');
    expect(decoded!.parameters.get('ipfs')).eq('0x010aff15');
  });
  it('Parse MIME with unsupported array parameter', function () {
    const decoded = parseMimeType('image/png;mutant[]="a,b,c"');

    expect(decoded).not.toBeNull();
    expect(decoded!.parameters.has('mutant')).eq(false, 'mutant should not be in parameters');
  });
  it('Parse MIME with supported array parameter', function () {
    const decoded = parseMimeType('image/png;mutant[]="a,b,c"', {
      arrayParameters: true,
    });

    expect(decoded).not.toBeNull();
    expect(decoded!.parameters.get('mutant')).toEqual(['a', 'b', 'c']);
  });

  /**
   * Serialize MIME
   */
  it('Serialize normal MIME', function () {
    const serialized = serializeMimeType({
      type: 'image',
      subtype: 'svg+xml',
      parameters: new Map([
        ['immortal', 'true'],
        ['q', '0.9'],
      ]),
    });

    expect(serialized).toEqual('image/svg+xml;immortal=true;q=0.9');
  });
  it('Serialize MIME with unsupported array parameter', function () {
    expect(() =>
      serializeMimeType({
        type: 'text',
        subtype: 'plain',
        parameters: new Map([['mutant', ['a', 'b', 'c']]]),
      }),
    ).toThrow('Array parameter value is not supported');
  });
  it('Serialize MIME with supported array parameter', function () {
    const serialized = serializeMimeType(
      {
        type: 'image',
        subtype: 'svg+xml',
        parameters: new Map([['mutant', ['a', 'b', 'c']]]),
      },
      {
        arrayParameters: true,
      },
    );

    expect(serialized).toEqual('image/svg+xml;mutant[]="a,b,c"');
  });
});


================================================
File: packages/core/src/__tests__/MultipartContent.test.ts
================================================
import { describe, it, expect } from 'vitest';
import { TTypedArray } from '@exact-realty/multipart-parser/dist/types';
import { TDecodedMultipartMessage } from '@exact-realty/multipart-parser/dist/encodeMultipartMessage';
import {
  bytifyRawString,
  decodeMultipartContent,
  encodeMultipartContent,
  isMultipartContentValid,
  readArrayBufferStream,
} from '../helpers';
import { AsyncableIterable, ResolvedMultipartContent } from '../helpers';
import { fetchLocalImage } from './helpers';

describe('Multipart SporeData.content', async function () {
  const parseTests: MultipartTestCase[] = [
    {
      raw: `
--boundary
content-type: text/plain

a message containing an image

--boundary
content-disposition: attachment, filename="test.jpg"
content-transfer-encoding: base64
content-type: image/jpg

/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KCIoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/wAARCAAKAAoDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAABAf/xAAfEAADAAICAwEBAAAAAAAAAAABAgMEBQARBiExQRT/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/8QAFBEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEQMRAD8AZHc7XC1vm2wts8x8ds7Y4Ume7H+N0QtAoSepqSzp69ljEAfeUPxO1cnw7S3vV61rr4PSjsWZ2M1JJJ+kn94p9NqqYuRivrMNsfKqbZEjBSlnJBLMOumbsA9n36HExjLGhOEJJKUlCTmihVRQOgAB8AH5wP/Z
--boundary--
`,
      message: [
        'boundary',
        [
          {
            headers: new Headers({ 'Content-Type': 'text/plain' }),
            body: bytifyRawString('a message containing an image\r\n'),
          },
          {
            headers: new Headers({
              'content-type': 'image/jpg',
              'content-transfer-encoding': 'base64',
              'content-disposition': 'attachment, filename="test.jpg"',
            }),
            body: bytifyRawString((await fetchLocalImage('./resources/test.jpg', __dirname)).base64),
          },
        ],
      ],
    },
    {
      raw: `
--boundary_1
content-type: multipart/mixed; boundary=boundary_2

--boundary_2
content-type: multipart/alternative; boundary=boundary_3

--boundary_3
content-type: text/plain; charset=UTF-8

Hello,

This is a plain text message.

Best regards,
Sender

--boundary_3
content-type: text/html; charset=UTF-8

<html>
  <body>
    <p>Hello,</p>
    <p>This is an HTML message.</p>
    <p>Best regards,<br>Sender</p>
  </body>
</html>

--boundary_3--
--boundary_2
content-disposition: attachment; filename="example.dat"
content-type: image/example

<binary data>

--boundary_2--
--boundary_1--
`,
      message: [
        'boundary_1',
        [
          {
            headers: new Headers({
              ['content-type']: 'multipart/mixed; boundary=boundary_2',
            }),
            parts: [
              {
                headers: new Headers({
                  'content-type': 'multipart/alternative; boundary=boundary_3',
                }),
                parts: [
                  {
                    headers: new Headers({
                      'content-type': 'text/plain; charset=UTF-8',
                    }),
                    body: bytifyRawString(
                      'Hello,\r\n' +
                        '\r\n' +
                        'This is a plain text message.\r\n' +
                        '\r\n' +
                        'Best regards,\r\n' +
                        'Sender\r\n',
                    ),
                  },
                  {
                    headers: new Headers({
                      'content-type': 'text/html; charset=UTF-8',
                    }),
                    body: bytifyRawString(
                      '<html>\r\n' +
                        '  <body>\r\n' +
                        '    <p>Hello,</p>\r\n' +
                        '    <p>This is an HTML message.</p>\r\n' +
                        '    <p>Best regards,<br>Sender</p>\r\n' +
                        '  </body>\r\n' +
                        '</html>\r\n',
                    ),
                  },
                ],
              },
              {
                headers: new Headers({
                  'content-disposition': 'attachment; filename="example.dat"',
                  'content-type': 'image/example',
                }),
                body: bytifyRawString('<binary data>\r\n'),
              },
            ],
          },
        ],
      ],
    },
  ];

  const validityTests: MultipartValidityTestCase[] = [
    ...parseTests.map((r) => {
      return {
        expect: true,
        message: r.raw,
        boundary: r.message[0],
      };
    }),

    {
      message: 'test without boundary',
      boundary: 'boundary',
      expect: false,
    },
    {
      message: `
--boundary
test without closing boundary
`,
      boundary: 'boundary',
      expect: false,
    },
    {
      message: `
--boundary
minimal viable multipart message, ending without CRLF
--boundary--`,
      boundary: 'boundary',
      expect: false,
    },
    {
      message: `
--boundary
minimal viable multipart message
--boundary--
`,
      boundary: 'boundary',
      expect: true,
    },
    {
      message: `--boundary
test with opening boundary that does not start with CRLF
--boundary--
`,
      boundary: 'boundary',
      expect: true,
    },
  ];

  it('Encode', async () => {
    for (let i = 0; i < parseTests.length; i++) {
      const test = parseTests[i];
      const testString = replaceNewLineToCRLF(test.raw);

      const encoded = await encodeMultipartContent(...test.message);
      const resultStringChunks = encoded.rawStringChunks;

      expect(testString.length).eq(encoded.codeUnitLength);

      let startIndex = 0;
      for (let j = 0; j < resultStringChunks.length; j++) {
        const resultStringChunk = replaceNewLineToCRLF(resultStringChunks[j]);
        const testStringChunk = testString.slice(startIndex, startIndex + resultStringChunk.length);
        expect(testStringChunk).eq(resultStringChunk);
        startIndex += resultStringChunk.length;
      }
    }
  });

  it('Decode', async () => {
    async function testDecoded(
      msgs: ResolvedMultipartContent[],
      iterableRefs: AsyncableIterable<TDecodedMultipartMessage>,
    ) {
      const refs: TDecodedMultipartMessage[] = [];
      for await (const ref of iterableRefs) {
        refs.push(ref);
      }

      expect(msgs.length).eq(refs.length);
      for (let i = 0; i < msgs.length; i++) {
        const msg = msgs[i];
        const ref = refs[i];

        // Headers
        for (const key of (ref.headers as any).keys()) {
          expect(msg.headers.get(key)).eq(ref.headers.get(key));
        }
        // Body
        if (ref.body) {
          expect(msg).toHaveProperty('body');
          const msgBody = await transformMultipartBody(msg.body);
          const refBody = await transformMultipartBody(ref.body);

          expect(msgBody.byteLength).eq(refBody.byteLength);
          expect(Buffer.from(msgBody).compare(Buffer.from(refBody))).eq(0);
        }
        // Parts
        if (ref.parts) {
          expect(msg).toHaveProperty('parts');
          await testDecoded(msg.parts!, ref.parts);
        } else {
          expect(msg.parts).toBeUndefined();
        }
      }
    }

    for (let i = 0; i < parseTests.length; i++) {
      const test = parseTests[i];
      const messages = await decodeMultipartContent(test.raw, test.message[0]);
      await testDecoded(messages, test.message[1]);
    }
  });
  // TODO
  // it('Validity', async () => {
  //   for (let i = 0; i < validityTests.length; i++) {
  //     const test = validityTests[i];
  //     const result = await isMultipartContentValid(test.message, test.boundary);
  //     console.log(test.expect, result);
  //     expect(result).eq(test.expect, `the #${i} validity test should match the expectation`);
  //   }
  // });
});

interface MultipartTestCase {
  raw: string;
  message: Parameters<typeof encodeMultipartContent>;
}

interface MultipartValidityTestCase {
  expect: boolean;
  message: string;
  boundary: string;
}

async function transformMultipartBody(body: TDecodedMultipartMessage['body']): Promise<ArrayBuffer> {
  if (body instanceof ArrayBuffer) {
    return body;
  } else if (body instanceof Blob) {
    return await body.arrayBuffer();
  } else if (body instanceof ReadableStream) {
    const loaded = await readArrayBufferStream(body);
    return loaded.buffer;
  } else if (body?.buffer && (body.buffer as TTypedArray) instanceof ArrayBuffer) {
    return body.buffer.slice(body.byteOffset, body.byteOffset + body.length);
  } else {
    throw new Error('Invalid body type');
  }
}

function replaceNewLineToCRLF(str: string) {
  return str.replace(/\r\n/g, '\n').replace(/\n/g, '\r\n');
}


================================================
File: packages/core/src/__tests__/Multiple.test.ts
================================================
import { BI } from '@ckb-lumos/lumos';
import { describe, it } from 'vitest';
import { createMultipleSpores, getSporeById, meltMultipleThenCreateSpore, transferMultipleSpore } from '../api';
import { predefinedSporeConfigs } from '../config';
import { bytifyRawString } from '../helpers';
import { signAndOrSendTransaction } from './helpers';
import { MultipleTestSPORE_OUTPOINT_RECORDS, TEST_ACCOUNTS, TEST_ENV } from './shared';

const options = {
  timeout: 10000000,
};
describe('Multiple', options, () => {
  const { rpc, config } = TEST_ENV;
  const { ALICE, BOB, CHARLIE } = TEST_ACCOUNTS;

  it('Create Multiple First', async () => {
    const createAmount = 2;
    const { txSkeleton, outputIndices } = await createMultipleSpores({
      sporeInfos: Array(createAmount).fill({
        data: {
          contentType: 'text/plain',
          content: bytifyRawString('content'),
        },
        toLock: CHARLIE.lock,
      }),
      fromInfos: [CHARLIE.address],
      config,
    });
    const { hash } = await signAndOrSendTransaction({
      account: CHARLIE,
      txSkeleton,
      config,
      rpc,
      send: true,
    });

    if (hash) {
      for (const index of outputIndices) {
        MultipleTestSPORE_OUTPOINT_RECORDS.push({
          outPoint: {
            txHash: hash,
            index: BI.from(index).toHexString(),
          },
          account: CHARLIE,
          sporeId: txSkeleton.get('outputs').get(index)!.cellOutput.type!.args,
        });
      }
    }
  });
  it('Multiple Transfer', async () => {
    // wait for transaction success
    // dirty but works
    await new Promise((f) => setTimeout(f, 20000));
    const spore_cells = MultipleTestSPORE_OUTPOINT_RECORDS.map((spore) => spore.outPoint);
    const { txSkeleton, inputIndecies, outputIndecies } = await transferMultipleSpore({
      outPoints: spore_cells,
      fromInfos: [CHARLIE.address],
      toLock: ALICE.lock,
      config: predefinedSporeConfigs.Testnet,
    });

    const hash = await signAndOrSendTransaction({ account: CHARLIE, txSkeleton, config, rpc, send: true });
    console.log(`Spore Multiple Transfer at: https://pudge.explorer.nervos.org/transaction/${hash.hash}`);
    //console.log(`Spore ID: ${txSkeleton.get('outputs').get(outputIndex)!.cellOutput.type!.args}`);
  }),
    it('Multiple Melt Then Create One', async () => {
      // wait for transaction success
      // dirty but works
      await new Promise((f) => setTimeout(f, 20000));
      const sporeIds = MultipleTestSPORE_OUTPOINT_RECORDS.map((spore) => spore.sporeId);
      const sporeCells = (
        await Promise.all(
          sporeIds.map(async (spore_id) => {
            const sporeData = await getSporeById(spore_id, predefinedSporeConfigs.Testnet);
            return sporeData?.outPoint;
          }),
        )
      ).filter((outPoint) => outPoint !== undefined);

      const { txSkeleton } = await meltMultipleThenCreateSpore({
        outPoints: sporeCells,
        fromInfos: [ALICE.address],
        toLock: BOB.lock,
        config: predefinedSporeConfigs.Testnet,
        data: {
          contentType: 'text/plain',
          content: bytifyRawString('content'),
        },
      });
      const hash = await signAndOrSendTransaction({ account: ALICE, txSkeleton, config, rpc, send: true });
      console.log(`Spore created at: https://pudge.explorer.nervos.org/transaction/${hash.hash}`);
      //console.log(`Spore ID: ${txSkeleton.get('outputs').get(outputIndex)!.cellOutput.type!.args}`);
    });
});


================================================
File: packages/core/src/__tests__/Mutant.test.ts
================================================
import { afterAll, describe, expect, it } from 'vitest';
import { bytifyRawString } from '../helpers';
import {
  createCluster,
  createMutant,
  createSpore,
  getClusterByOutPoint,
  getMutantByOutPoint,
  transferMutant,
} from '../api';
import { OutPointRecord, fetchLocalFile, getSporeOutput, retryQuery, signAndOrSendTransaction } from './helpers';
import { SPORE_OUTPOINT_RECORDS, TEST_ACCOUNTS, TEST_ENV, cleanupRecords } from './shared';
import { BI } from '@ckb-lumos/bi';
import { unpackToRawMutantArgs } from '../codec';

describe('Mutant', function () {
  const { rpc, config } = TEST_ENV;
  const { CHARLIE, ALICE, BOB } = TEST_ACCOUNTS;
  let existingMutantRecord: OutPointRecord | undefined;
  let existingClusterRecord: OutPointRecord | undefined;

  afterAll(async () => {
    await cleanupRecords({
      name: 'Mutant',
    });
  }, 0);

  it('Create a Mutant', async function () {
    /**
     * [#1] Immortal Mutant can apply rules to the Spore:
     * - Spore with this Mutant applied cannot be melted from the blockchain
     * - Function exactly like the internal immortal feature, but throws a different error code
     * - Check logic: if (spore_ext_mode == 3) throw error(86)
     */
    const code = await fetchLocalFile('./resources/immortalMutant.lua', __dirname);
    /**
     * [#2] No Transfer Mutant can apply rules to make the Spore:
     * - Spore with this Mutant applied, cannot be transferred.
     * - Check logic: if (spore_ext_mode == 2) throw error(88)
     */
    // const code = await fetchLocalFile('./resources/noTransferMutant.lua', __dirname);
    /**
     * [#3] Must Transfer Mutant can apply rules to make the Spore:
     * - Spore with this Mutant applied, when transferring, cannot be transferred to the original owner
     * - Check logic: if (spore_ext_mode == 2 and spore_input_lock_hash == spore_output_lock_hash) throw error(87)
     */
    // const code = await fetchLocalFile('./resources/mustTransferMutant.lua', __dirname);
    /**
     * [#4] Second Output Mutant can apply rules to the Spore:
     * - Spore with this Mutant applied, the output's index must be zero (0x0)
     * - Check logic: if (spore_output_index > 0) throw error(89)
     */
    // const code = await fetchLocalFile('./resources/firstOutputMutant.lua', __dirname);

    const { txSkeleton, outputIndex } = await createMutant({
      data: code.bytes,
      minPayment: 1000,
      toLock: ALICE.lock,
      fromInfos: [ALICE.address],
      config,
    });

    // Sign and send transaction
    const { hash } = await signAndOrSendTransaction({
      account: ALICE,
      txSkeleton,
      config,
      rpc,
      send: true,
    });
    if (hash) {
      existingMutantRecord = {
        outPoint: {
          txHash: hash,
          index: BI.from(outputIndex).toHexString(),
        },
        account: ALICE,
      };
    }
  }, 30000);

  it('Transfer a Mutant', async function () {
    expect(existingMutantRecord).toBeDefined();
    const mutantRecord = existingMutantRecord!;
    const mutantCell = await retryQuery(() => getMutantByOutPoint(mutantRecord!.outPoint, config));

    const { txSkeleton, outputIndex } = await transferMutant({
      outPoint: mutantCell.outPoint!,
      minPayment: 1000,
      toLock: CHARLIE.lock,
      config,
    });

    // Sign and send transaction
    const { hash } = await signAndOrSendTransaction({
      account: ALICE,
      txSkeleton,
      config,
      rpc,
      send: true,
    });
    if (hash) {
      existingMutantRecord = {
        outPoint: {
          txHash: hash,
          index: BI.from(outputIndex).toHexString(),
        },
        account: CHARLIE,
      };
    }
  }, 60000);

  describe('Spore with Mutant', () => {
    it('Create a Spore with Mutant', async () => {
      expect(existingMutantRecord).toBeDefined();
      const mutantRecord = existingMutantRecord!;
      const mutantCell = await retryQuery(() => getMutantByOutPoint(mutantRecord!.outPoint, config));
      const mutantArgs = unpackToRawMutantArgs(mutantCell.cellOutput.type!.args);
      const mutantId = mutantArgs.id;
      console.log('mutant id:', mutantId);
      console.log('mutant payment:', mutantArgs.minPayment ?? 0);

      const { txSkeleton, outputIndex, reference, mutantReference } = await createSpore({
        data: {
          contentType: 'text/plain',
          content: bytifyRawString('content'),
          contentTypeParameters: {
            mutant: [mutantId],
          },
        },
        fromInfos: [BOB.address],
        toLock: BOB.lock,
        config,
      });

      const spore = getSporeOutput(txSkeleton, outputIndex, config);
      expect(spore.data.contentType).toEqual(`text/plain;mutant[]=${mutantId.slice(2)}`);

      expect(reference).toBeDefined();
      expect(reference.referenceTarget).toEqual('none');

      expect(mutantReference).toBeDefined();
      if (mutantArgs.minPayment !== void 0) {
        expect(mutantReference!.referenceType).toEqual('payment');
        expect(mutantReference!.payment).toBeDefined();
        expect(mutantReference!.payment!.outputIndices.length).toEqual(1);
        const paymentCell = txSkeleton.get('outputs').get(mutantReference!.payment!.outputIndices[0]);
        expect(BI.from(paymentCell!.cellOutput.capacity).gte(BI.from(mutantArgs.minPayment))).toEqual(true);
        expect(paymentCell!.cellOutput.lock).toEqual(mutantCell.cellOutput.lock);
      } else {
        expect(mutantReference!.referenceType).toEqual('none');
      }

      const { hash } = await signAndOrSendTransaction({
        account: BOB,
        txSkeleton,
        config,
        rpc,
        send: true,
      });
      if (hash) {
        SPORE_OUTPOINT_RECORDS.push({
          outPoint: {
            txHash: hash,
            index: BI.from(outputIndex).toHexString(),
          },
          account: BOB,
        });
      }
    }, 60000);

    it('Create a Cluster (if necessary)', async () => {
      const { txSkeleton, outputIndex } = await createCluster({
        data: {
          name: 'Testnet Spores',
          description: 'Testing only',
        },
        fromInfos: [ALICE.address],
        toLock: ALICE.lock,
        config,
      });
      const { hash } = await signAndOrSendTransaction({
        account: ALICE,
        txSkeleton,
        config,
        rpc,
        send: true,
      });
      if (hash) {
        existingClusterRecord = {
          outPoint: {
            txHash: hash,
            index: BI.from(outputIndex).toHexString(),
          },
          account: ALICE,
        };
      }
    }, 30000);

    it('Create a Spore with Mutant required Cluster', async () => {
      console.log('request mutant cell');
      expect(existingMutantRecord).toBeDefined();
      const mutantRecord = existingMutantRecord!;
      const mutantCell = await retryQuery(() => getMutantByOutPoint(mutantRecord!.outPoint, config));
      const mutantArgs = unpackToRawMutantArgs(mutantCell.cellOutput.type!.args);
      const mutantId = mutantArgs.id;

      console.log('request cluster cell');
      expect(existingClusterRecord).toBeDefined();
      const clusterRecord = existingClusterRecord!;
      const clusterCell = await retryQuery(() => getClusterByOutPoint(clusterRecord!.outPoint, config));
      const clusterId = clusterCell.cellOutput.type!.args;

      console.log('create spore');
      const { txSkeleton, reference, mutantReference } = await createSpore({
        data: {
          contentType: 'text/plain',
          content: bytifyRawString('content'),
          clusterId,
          contentTypeParameters: {
            mutant: [mutantId],
          },
        },
        fromInfos: [ALICE.address],
        toLock: ALICE.lock,
        config,
      });

      console.log('Spore Reference:', reference);
      console.log('Spore MutantReference:', mutantReference);

      console.log('ALICE address:', ALICE.address);
      console.log('CHARLIE address:', CHARLIE.address);
      await signAndOrSendTransaction({
        account: ALICE,
        txSkeleton,
        config,
        rpc,
        send: true,
      });
    }, 60000);
  });
});


================================================
File: packages/core/src/__tests__/RetryWork.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { retryWork, waitForMilliseconds } from '../helpers';

describe('RetryWork', () => {
  it('Return 1', async () => {
    const work = await retryWork({
      getter: async () => {
        await waitForMilliseconds(1);
        return 1;
      },
    });

    expect(work.success).eq(true);
    expect(work.retries).eq(0);
    expect(work.result).eq(1);
  });
  it('Return 1 after 3 retries', async () => {
    let retries = 0;
    const work = await retryWork({
      getter: async () => {
        await waitForMilliseconds(1);
        if (retries < 3) {
          retries++;
          throw new Error('Should retry 3 times');
        }
        return 1;
      },
      retry: 10,
    });

    expect(work.success).eq(true);
    expect(work.retries).eq(retries);
    expect(work.result).eq(1);
  });
  it('Fail after 3 retries', async () => {
    const work = await retryWork({
      getter: async () => {
        await waitForMilliseconds(1);
        throw new Error('Failed');
      },
      retry: 3,
      interval: 1000,
    });

    expect(work.success).eq(false);
    expect(work.result).eq(void 0);
    expect(work.retries).eq(3);
  });
  it('Return 1 but fail', async () => {
    const work = await retryWork({
      getter: async () => {
        await waitForMilliseconds(1);
        return 1;
      },
      onComplete() {
        return false;
      },
    });

    expect(work.success).eq(false);
    expect(work.result).eq(void 0);
  });
  it('Return 1 but stop', async () => {
    const work = await retryWork({
      getter: async () => {
        await waitForMilliseconds(1);
        return 1;
      },
      onComplete() {
        throw new Error('Should stop');
      },
      onError() {
        return false;
      },
    });

    expect(work.success).eq(false);
    expect(work.result).eq(void 0);
    expect(work.retries).eq(0);
  });
  it('Fail and stop', async () => {
    const work = await retryWork({
      getter: async () => {
        await waitForMilliseconds(1);
        throw new Error('Failed');
      },
      onError() {
        return false;
      },
    });

    expect(work.success).eq(false);
    expect(work.result).eq(void 0);
    expect(work.retries).eq(0);
  });
});


================================================
File: packages/core/src/__tests__/Spore.test.ts
================================================
import { describe, expect, it, afterAll } from 'vitest';
import { BI, Cell, Indexer, helpers } from '@ckb-lumos/lumos';
import { ParamsFormatter } from '@ckb-lumos/rpc';
import { getSporeScript } from '../config';
import {
  bufferToRawString,
  bytifyRawString,
  createCapacitySnapshotFromTransactionSkeleton,
  getCellByLock,
} from '../helpers';
import {
  createSpore,
  transferSpore,
  meltSpore,
  getSporeByOutPoint,
  createCluster,
  getClusterByOutPoint,
  createMultipleSpores,
} from '../api';
import { expectCellDep, expectTypeId, expectTypeCell, expectCellLock, Account, expectCell } from './helpers';
import { getSporeOutput, popRecord, retryQuery, signAndOrSendTransaction, OutPointRecord } from './helpers';
import { TEST_ACCOUNTS, TEST_ENV, SPORE_OUTPOINT_RECORDS, cleanupRecords } from './shared';
import { meltThenCreateSpore } from '../api/composed/spore/meltThenCreateSpore';
import { SporeAction, WitnessLayout } from '../cobuild';
import { common } from '@ckb-lumos/lumos/common-scripts';

describe('Spore', () => {
  const { rpc, config } = TEST_ENV;
  const { CHARLIE, ALICE, BOB } = TEST_ACCOUNTS;

  async function getLiveCell(account: Account, nullable: boolean): Promise<Cell | undefined> {
    const indexer = new Indexer(config.ckbIndexerUrl);
    const cell = getCellByLock({
      lock: account.lock,
      indexer,
      has_type: false,
    });
    if (!nullable && !cell) {
      throw new Error(`live cell not found in ${account}`);
    }
    return cell;
  }

  afterAll(async () => {
    await cleanupRecords({
      name: 'Spore',
    });
  }, 0);

  describe('Spore basics', () => {
    let existingSporeRecord: OutPointRecord | undefined;
    it('Create a Spore', async () => {
      const capacityCell = await getLiveCell(CHARLIE, true);
      const { txSkeleton, outputIndex, reference } = await createSpore({
        data: {
          contentType: 'text/plain',
          content: bytifyRawString('content'),
        },
        toLock: CHARLIE.lock,
        fromInfos: [],
        prefixInputs: [capacityCell!],
        config,
      });

      const spore = getSporeOutput(txSkeleton, outputIndex, config);
      expect(spore.cell!.cellOutput.lock).toEqual(CHARLIE.lock);
      expectTypeId(txSkeleton, outputIndex, spore.id);
      expect(spore.data.contentType).toEqual('text/plain');
      expect(bufferToRawString(spore.data.content)).toEqual('content');

      expectTypeCell(txSkeleton, 'output', spore.cell.cellOutput.type!);
      expectCellDep(txSkeleton, spore.script.cellDep);

      expect(reference).toBeDefined();
      expect(reference.referenceTarget).toEqual('none');

      const { hash } = await signAndOrSendTransaction({
        account: CHARLIE,
        txSkeleton,
        config,
        rpc,
        send: true,
      });

      if (hash) {
        SPORE_OUTPOINT_RECORDS.push({
          outPoint: {
            txHash: hash,
            index: BI.from(outputIndex).toHexString(),
          },
          account: CHARLIE,
        });
      }
    }, 0);
    it('Transfer a Spore', async () => {
      const sporeRecord = existingSporeRecord ?? popRecord(SPORE_OUTPOINT_RECORDS, true);
      const sporeCell = await retryQuery(() => getSporeByOutPoint(sporeRecord.outPoint, config));

      expectCellLock(sporeCell, [CHARLIE.lock, ALICE.lock]);
      const oppositeAccount = sporeRecord.account.address === ALICE.address ? CHARLIE : ALICE;

      const { txSkeleton, outputIndex } = await transferSpore({
        outPoint: sporeCell.outPoint!,
        fromInfos: [sporeRecord.account.address],
        toLock: oppositeAccount.lock,
        config,
      });

      const spore = getSporeOutput(txSkeleton, outputIndex, config);
      expect(spore.cell.cellOutput.lock).toEqual(oppositeAccount.lock);

      expectTypeCell(txSkeleton, 'both', spore.cell.cellOutput.type!);
      expectCellDep(txSkeleton, spore.script.cellDep);

      const { hash } = await signAndOrSendTransaction({
        account: sporeRecord.account,
        txSkeleton,
        config,
        rpc,
        send: true,
      });
      if (hash) {
        existingSporeRecord = void 0;
        SPORE_OUTPOINT_RECORDS.push({
          outPoint: {
            txHash: hash,
            index: BI.from(outputIndex).toHexString(),
          },
          account: ALICE,
        });
      }
    }, 0);
    it('Melt a Spore', async () => {
      const sporeRecord = existingSporeRecord ?? popRecord(SPORE_OUTPOINT_RECORDS, true);
      const sporeCell = await retryQuery(() => getSporeByOutPoint(sporeRecord.outPoint, config));

      const { txSkeleton } = await meltSpore({
        outPoint: sporeCell.outPoint!,
        changeAddress: CHARLIE.address,
        config,
      });

      expectTypeCell(txSkeleton, 'input', sporeCell.cellOutput.type!);

      const changeCell = txSkeleton.get('outputs').get(0);
      expect(changeCell).toBeDefined();
      expect(changeCell!.cellOutput.lock).toEqual(CHARLIE.lock);

      const sporeScript = getSporeScript(config, 'Spore', sporeCell.cellOutput.type!);
      expectCellDep(txSkeleton, sporeScript.cellDep);

      const { hash } = await signAndOrSendTransaction({
        account: sporeRecord.account,
        txSkeleton,
        config,
        rpc,
        send: true,
      });
      if (hash) {
        existingSporeRecord = void 0;
      }
    }, 0);
    it('Create multiple Spores', async () => {
      const { txSkeleton, outputIndices } = await createMultipleSpores({
        sporeInfos: [
          {
            data: {
              contentType: 'text/plain',
              content: bytifyRawString('content-1'),
            },
            toLock: CHARLIE.lock,
          },
          {
            data: {
              contentType: 'text/plain',
              content: bytifyRawString('content-2'),
            },
            toLock: CHARLIE.lock,
          },
        ],
        fromInfos: [BOB.address],
        config,
      });

      // debug print witness layout
      const lastWitness = txSkeleton.get('witnesses').last();
      const witnessLayout = WitnessLayout.unpack(lastWitness!);
      if (witnessLayout.type === 'SighashAll') {
        const actions = witnessLayout.value.message!.actions;
        const actionsData = actions.map((action) => SporeAction.unpack(action.data));
        console.log(JSON.stringify(actionsData, null, 2));
      }

      const { hash } = await signAndOrSendTransaction({
        account: BOB,
        txSkeleton,
        config,
        rpc,
        send: true,
      });
      if (hash) {
        for (const outputIndex of outputIndices) {
          SPORE_OUTPOINT_RECORDS.push({
            outPoint: {
              txHash: hash,
              index: BI.from(outputIndex).toHexString(),
            },
            account: CHARLIE,
          });
        }
      }
    });
  }, 0);

  describe('Spore with immortal mutant', () => {
    let existingSporeRecord: OutPointRecord | undefined;
    it('Create an immortal Spore', async () => {
      const { txSkeleton, outputIndex } = await createSpore({
        data: {
          contentType: 'text/plain',
          content: bytifyRawString('immortal'),
          contentTypeParameters: {
            immortal: true,
          },
        },
        toLock: CHARLIE.lock,
        fromInfos: [CHARLIE.address],
        config,
      });

      const spore = getSporeOutput(txSkeleton, outputIndex, config);
      expect(spore.cell!.cellOutput.lock).toEqual(CHARLIE.lock);
      expect(spore.data.contentType).toEqual('text/plain;immortal=true');
      expect(bufferToRawString(spore.data.content)).toEqual('immortal');

      const { hash } = await signAndOrSendTransaction({
        account: CHARLIE,
        txSkeleton,
        config,
        rpc,
        send: true,
      });
      if (hash) {
        existingSporeRecord = {
          outPoint: {
            txHash: hash,
            index: BI.from(outputIndex).toHexString(),
          },
          account: CHARLIE,
        };
      }
    }, 0);
    it('Transfer an immortal Spore', async () => {
      expect(existingSporeRecord).toBeDefined();
      const sporeRecord = existingSporeRecord!;
      const sporeCell = await retryQuery(() => getSporeByOutPoint(sporeRecord!.outPoint, config));

      expectCellLock(sporeCell, [CHARLIE.lock, ALICE.lock]);
      const oppositeAccount = sporeRecord.account.address === ALICE.address ? CHARLIE : ALICE;

      const { txSkeleton, outputIndex } = await transferSpore({
        outPoint: sporeCell.outPoint!,
        fromInfos: [sporeRecord.account.address],
        toLock: oppositeAccount.lock,
        config,
      });

      const { hash } = await signAndOrSendTransaction({
        account: sporeRecord.account,
        txSkeleton,
        config,
        rpc,
        send: true,
      });
      if (hash) {
        existingSporeRecord = {
          outPoint: {
            txHash: hash,
            index: BI.from(outputIndex).toHexString(),
          },
          account: oppositeAccount,
        };
      }
    }, 0);
    it('Try melt an immortal Spore', async () => {
      expect(existingSporeRecord).toBeDefined();
      const sporeRecord = existingSporeRecord!;
      const sporeCell = await retryQuery(() => getSporeByOutPoint(sporeRecord!.outPoint, config));

      const { txSkeleton } = await meltSpore({
        outPoint: sporeCell.outPoint!,
        changeAddress: CHARLIE.address,
        config,
      });

      await expect(
        signAndOrSendTransaction({
          account: sporeRecord.account,
          txSkeleton,
          config,
          rpc,
          send: true,
        }),
      ).rejects.toThrow();
    }, 0);
  });

  describe('Spore melt and mint in one transaction', () => {
    let existingSporeRecord: OutPointRecord | undefined;
    let existingClusterRecord: OutPointRecord | undefined;

    it('Create a Cluster', async () => {
      const { txSkeleton, outputIndex } = await createCluster({
        data: {
          name: 'dob cluster',
          description: 'Testing only',
        },
        fromInfos: [BOB.address],
        toLock: BOB.lock,
        config,
      });

      const { hash } = await signAndOrSendTransaction({
        account: BOB,
        txSkeleton,
        config,
        rpc,
        send: true,
      });

      if (hash) {
        existingClusterRecord = {
          outPoint: {
            txHash: hash,
            index: BI.from(outputIndex).toHexString(),
          },
          account: BOB,
        };
      }
    }, 60000);

    it('Create a Spore', async () => {
      const aliceWalletCell = await retryQuery(() => getLiveCell(ALICE, false));
      const { txSkeleton, outputIndex, reference } = await createSpore({
        data: {
          contentType: 'text/plain',
          content: bytifyRawString('blind box spore with bigger capacity than opened one'),
        },
        toLock: ALICE.lock,
        fromInfos: [ALICE.address],
        prefixInputs: [aliceWalletCell!],
        config,
      });

      const spore = getSporeOutput(txSkeleton, outputIndex, config);
      expect(spore.cell!.cellOutput.lock).toEqual(ALICE.lock);
      expectTypeId(txSkeleton, outputIndex, spore.id);
      expectCellDep(txSkeleton, spore.script.cellDep);
      expectTypeCell(txSkeleton, 'output', spore.cell.cellOutput.type!);

      expect(reference).toBeDefined();
      expect(reference.referenceTarget).toEqual('none');

      const { hash } = await signAndOrSendTransaction({
        account: ALICE,
        txSkeleton,
        config,
        rpc,
        send: true,
      });

      if (hash) {
        existingSporeRecord = {
          outPoint: {
            txHash: hash,
            index: BI.from(outputIndex).toHexString(),
          },
          account: ALICE,
        };
      }
    }, 60000);

    it('Melt and Create a Spore', async () => {
      expect(existingSporeRecord).toBeDefined();
      const sporeRecord = existingSporeRecord!;
      const sporeCell = await retryQuery(() => getSporeByOutPoint(sporeRecord.outPoint, config));
      const sporeOwner = sporeRecord.account;

      expect(existingClusterRecord).toBeDefined();
      const clusterRecord = existingClusterRecord!;
      const clusterCell = await retryQuery(() => getClusterByOutPoint(clusterRecord.outPoint, config));
      const clusterId = clusterCell.cellOutput.type!.args;
      const clsuterOwner = clusterRecord.account;

      const clusterOwnerCell = await retryQuery(() => getLiveCell(clsuterOwner, false));
      expect(clusterOwnerCell).toBeDefined();
      const { txSkeleton, outputIndex } = await meltThenCreateSpore({
        data: {
          contentType: 'dob/0',
          content: bytifyRawString('opened dob spore'),
          clusterId,
        },
        toLock: sporeOwner.lock,
        fromInfos: [sporeOwner.address, clsuterOwner.address],
        postInputs: [clusterOwnerCell!],
        prefixOutputs: [clusterOwnerCell!],
        outPoint: sporeCell.outPoint!,
        changeAddress: sporeOwner.address,
        config,
        feeRate: 3000,
      });

      txSkeleton.get('inputs').forEach((cell) => {
        expect(cell == clusterCell).toBeFalsy();
      });
      expect(txSkeleton.get('outputs').size).toEqual(3);
      let snapshot = createCapacitySnapshotFromTransactionSkeleton(txSkeleton);
      expect(snapshot.inputsRemainCapacity.toNumber()).gt(0).lt(100000000);

      // const { hash } = await signAndOrSendTransaction({
      //   account: [sporeOwner, clsuterOwner],
      //   txSkeleton,
      //   config,
      //   rpc,
      //   send: true,
      // });

      // use another proper method to interactively sign message
      let signedTxSkeleton = common.prepareSigningEntries(txSkeleton, { config: config.lumos });
      // sign from client (seralize and send the result skeleton to the backend server)
      signedTxSkeleton = sporeOwner.signTransaction(signedTxSkeleton);
      // sign from server
      signedTxSkeleton = clsuterOwner.signTransaction(signedTxSkeleton);
      // send message
      const tx = helpers.createTransactionFromSkeleton(signedTxSkeleton);
      console.log('RPC Transaction:', JSON.stringify(ParamsFormatter.toRawTransaction(tx), null, 2));
      const hash = await rpc.sendTransaction(tx, 'passthrough');
      if (hash) {
        console.log('TransactionHash:', hash);
        SPORE_OUTPOINT_RECORDS.push({
          outPoint: {
            txHash: hash,
            index: BI.from(outputIndex).toHexString(),
          },
          account: sporeRecord.account,
        });
      }
    }, 90000);
  });
});


================================================
File: packages/core/src/__tests__/SporeConfig.test.ts
================================================
import cloneDeep from 'lodash/cloneDeep';
import { describe, expect, it } from 'vitest';
import { TEST_ENV } from './shared';
import {
  SporeConfig,
  getSporeScript,
  forkSporeConfig,
  getSporeConfigHash,
  isSporeScriptCategorySupported,
} from '../config';

describe('SporeConfig', function () {
  const { config } = TEST_ENV;
  it('Hash a SporeConfig', () => {
    const config = cloneDeep(TEST_ENV.config);
    const hash1 = getSporeConfigHash(config);

    config.maxTransactionSize = Math.random() * 1000;
    const hash2 = getSporeConfigHash(config);
    expect(hash1).not.toEqual(hash2);
  });
  it('Fork a SporeConfig', () => {
    const newConfig = forkSporeConfig(config, {
      scripts: {
        Some: {
          versions: [
            {
              tags: ['latest'],
              script: {
                codeHash: '0x00',
                hashType: 'type',
              },
              cellDep: {
                outPoint: {
                  txHash: '0x00',
                  index: '0x',
                },
                depType: 'code',
              },
            },
          ],
        },
      },
    });

    const categoryExistsInOldConfig = isSporeScriptCategorySupported(config, 'Some');
    expect(categoryExistsInOldConfig).eq(false, 'Old SporeConfig should not have "Some" script');

    const categoryExistsInNewConfig = isSporeScriptCategorySupported(newConfig, 'Some');
    expect(categoryExistsInNewConfig).eq(true, 'New SporeConfig should have "Some" script');
  });
  it('Get SporeScript by ScriptId', () => {
    const newConfig = forkSporeConfig(config, {
      scripts: {
        Some: {
          versions: [
            {
              tags: ['v2'],
              script: {
                codeHash: '0x00',
                hashType: 'type',
              },
              cellDep: {
                outPoint: {
                  txHash: '0x00',
                  index: '0x0',
                },
                depType: 'code',
              },
            },
            {
              tags: ['v1'],
              script: {
                codeHash: '0x01',
                hashType: 'type',
              },
              cellDep: {
                outPoint: {
                  txHash: '0x01',
                  index: '0x0',
                },
                depType: 'code',
              },
            },
          ],
        },
      },
    });

    const script = getSporeScript(newConfig, 'Some', {
      codeHash: '0x01',
      hashType: 'type',
    });
    expect(script).toHaveProperty('tags', ['v1']);
    expect(script.script).toHaveProperty('codeHash');
    expect(script.script).toHaveProperty('codeHash', '0x01');
  });
  it('Match tags', () => {
    const cases = [
      {
        tags: ['v2'],
        fullTags: ['v2'],
        result: true,
      },
      {
        tags: ['v2'],
        fullTags: ['v1'],
        result: false,
      },
      {
        tags: ['v2'],
        fullTags: ['v1', 'v2'],
        result: true,
      },
      {
        tags: ['v2'],
        fullTags: ['v1', 'v2', 'v3'],
        result: true,
      },
      {
        tags: ['v2'],
        fullTags: ['v1', 'v3'],
        result: false,
      },
      {
        tags: ['v2', 'preview'],
        fullTags: ['v1', 'v2'],
        result: false,
      },
      {
        tags: ['v2', 'preview'],
        fullTags: ['v1', 'v2', 'v3'],
        result: false,
      },
      {
        tags: ['v2', 'preview'],
        fullTags: ['v1', 'v2', 'preview'],
        result: true,
      },
      {
        tags: ['v2', 'preview'],
        fullTags: ['v1', 'preview', 'v2'],
        result: true,
      },
      {
        tags: ['v2', 'preview'],
        fullTags: ['v1', 'v2', 'preview', 'v3'],
        result: true,
      },
      {
        tags: ['v2', 'preview'],
        fullTags: ['v1', 'v2', 'preview', 'v3', 'v4'],
        result: true,
      },
    ];

    function generateRegex(tags: string[]) {
      const patterns = tags.sort().join(',.*');
      return new RegExp(`${patterns}.*`, 'g');
    }
    function match(tags: string[], patterns: string[]) {
      const regex = generateRegex(patterns);
      return regex.test(tags.sort().join(','));
    }
    for (let i = 0; i < cases.length; i++) {
      const { tags, fullTags, result } = cases[i];
      expect(match(fullTags, tags)).eq(result, `Match case #${i}`);
    }
  });
  it('Get SporeScript by tags', () => {
    const newConfig: SporeConfig = {
      defaultTags: ['latest'],
      lumos: config.lumos,
      ckbNodeUrl: '',
      ckbIndexerUrl: '',
      maxTransactionSize: 1,
      scripts: {
        Spore: {
          versions: [
            {
              tags: ['v2', 'preview'],
              script: {
                codeHash: '0x00',
                hashType: 'data1',
              },
              cellDep: {
                outPoint: {
                  txHash: '0x01',
                  index: '0x0',
                },
                depType: 'code',
              },
            },
            {
              tags: ['v1', 'latest'],
              script: {
                codeHash: '0x02',
                hashType: 'data1',
              },
              cellDep: {
                outPoint: {
                  txHash: '0x03',
                  index: '0x0',
                },
                depType: 'code',
              },
            },
          ],
        },
        Cluster: {
          versions: [
            {
              tags: ['v2', 'preview'],
              script: {
                codeHash: '0x04',
                hashType: 'data1',
              },
              cellDep: {
                outPoint: {
                  txHash: '0x05',
                  index: '0x0',
                },
                depType: 'code',
              },
            },
            {
              tags: ['v1', 'latest'],
              script: {
                codeHash: '0x598d793defef36e2eeba54a9b45130e4ca92822e1d193671f490950c3b856080',
                hashType: 'data1',
              },
              cellDep: {
                outPoint: {
                  txHash: '0x49551a20dfe39231e7db49431d26c9c08ceec96a29024eef3acc936deeb2ca76',
                  index: '0x0',
                },
                depType: 'code',
              },
            },
          ],
        },
      },
    };

    const script = getSporeScript(newConfig, 'Spore', ['v2']);
    expect(script).toBeDefined();
    expect(script!.tags).toBeDefined();
    expect(script!.tags.includes('v2')).toEqual(true);
  });
});


================================================
File: packages/core/src/__tests__/Vitest.test.ts
================================================
import { describe, it, expect } from 'vitest';
import { waitForMilliseconds } from '../helpers';

describe('Vitest', () => {
  describe('Sequential works', () => {
    let result: number | null = null;
    it('Finish after 1 sec', async () => {
      await waitForMilliseconds(1000);
      if (result === null) {
        result = 1;
      }
    });
    it('Finish immediately', () => {
      if (result === null) {
        result = 2;
      }
    });
    it('The result should be 1', () => {
      expect(result).toEqual(1);
    });
  });
  describe('Concurrent works', () => {
    let result: number | null = null;
    describe.concurrent('Run works at the same time', () => {
      it('Finish after 1 sec', async () => {
        await waitForMilliseconds(1000);
        if (result === null) {
          result = 1;
        }
      });
      it('Finish immediately', () => {
        if (result === null) {
          result = 2;
        }
      });
    });
    it('The result should be 2', () => {
      expect(result).toEqual(2);
    });
  });
});


================================================
File: packages/core/src/__tests__/helpers/account.ts
================================================
import { ParamsFormatter } from '@ckb-lumos/rpc';
import { common } from '@ckb-lumos/common-scripts';
import { Address, Hash, Script } from '@ckb-lumos/base';
import { hd, helpers, HexString, RPC } from '@ckb-lumos/lumos';
import { getSporeConfig, SporeConfig } from '../../config';
import { isScriptValueEquals, updateWitnessArgs, defaultEmptyWitnessArgs } from '../../helpers';

export interface Account {
  lock: Script;
  address: Address;
  signMessage(message: HexString): Hash;
  signTransaction(txSkeleton: helpers.TransactionSkeletonType): helpers.TransactionSkeletonType;
}

export function createDefaultLockAccount(privateKey: HexString, config?: SporeConfig): Account {
  if (!config) {
    config = getSporeConfig();
  }
  const defaultLockScript = config.lumos.SCRIPTS.SECP256K1_BLAKE160!;
  const lock: Script = {
    codeHash: defaultLockScript.CODE_HASH,
    hashType: defaultLockScript.HASH_TYPE,
    args: hd.key.privateKeyToBlake160(privateKey),
  };

  const address = helpers.encodeToAddress(lock, {
    config: config.lumos,
  });

  function signMessage(message: HexString): Hash {
    return hd.key.signRecoverable(message, privateKey);
  }

  function signTransaction(txSkeleton: helpers.TransactionSkeletonType): helpers.TransactionSkeletonType {
    const signingEntries = txSkeleton.get('signingEntries');
    const signatures = new Map<HexString, Hash>();

    let witnesses = txSkeleton.get('witnesses');
    for (let i = 0; i < signingEntries.size; i++) {
      const entry = signingEntries.get(i)!;
      if (entry.type === 'witness_args_lock') {
        const input = txSkeleton.get('inputs').get(entry.index);
        if (!input || !isScriptValueEquals(input.cellOutput.lock, lock)) {
          continue;
        }
        if (!signatures.has(entry.message)) {
          const sig = signMessage(entry.message);
          signatures.set(entry.message, sig);
        }

        const witness = witnesses.get(entry.index, defaultEmptyWitnessArgs);

        const signature = signatures.get(entry.message)!;
        const newWitness = updateWitnessArgs(witness, 'lock', signature);
        witnesses = witnesses.set(entry.index, newWitness);
      }
    }

    return txSkeleton.set('witnesses', witnesses);
  }

  return {
    lock,
    address,
    signMessage,
    signTransaction,
  };
}

export async function signAndOrSendTransaction(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  account: Account | Account[];
  config: SporeConfig;
  debug?: boolean;
  send?: boolean;
  rpc?: RPC;
}): Promise<{
  hash: Hash | undefined;
  txSkeleton: helpers.TransactionSkeletonType;
}> {
  // Env
  const { account, config } = props;
  const rpc = props.rpc ?? new RPC(config.ckbNodeUrl);
  const debug = props.debug ?? true;
  const send = props.send ?? false;

  // Get TransactionSkeleton
  let txSkeleton = props.txSkeleton;

  // Prepare unsigned messages
  txSkeleton = common.prepareSigningEntries(txSkeleton, { config: config.lumos });

  // Sign transaction
  const accounts = Array.isArray(account) ? account : [account];
  for (const currentAccount of accounts) {
    txSkeleton = currentAccount.signTransaction(txSkeleton);
  }

  // Convert to Transaction
  const tx = helpers.createTransactionFromSkeleton(txSkeleton);
  if (debug) {
    console.log('RPC Transaction:', JSON.stringify(ParamsFormatter.toRawTransaction(tx), null, 2));
  }

  // Send transaction
  let hash: Hash | undefined;
  if (send) {
    hash = await rpc.sendTransaction(tx, 'passthrough');
    if (debug) {
      console.log('TransactionHash:', hash);
    }
  }

  return {
    hash,
    txSkeleton,
  };
}


================================================
File: packages/core/src/__tests__/helpers/check.ts
================================================
import { expect } from 'vitest';
import { helpers, HexString } from '@ckb-lumos/lumos';
import { Cell, CellDep, Hash, Script } from '@ckb-lumos/base';
import { getSporeScript, isSporeScriptSupported, SporeConfig, SporeScript } from '../../config';
import { unpackToRawSporeData, RawSporeData } from '../../codec';
import { unpackToRawClusterData, RawClusterData } from '../../codec';
import { unpackToRawClusterProxyArgs, RawClusterProxyArgs } from '../../codec';
import { generateTypeId, isScriptValueEquals } from '../../helpers';
import { getWitnessType, SighashAll, SporeAction, WitnessLayout } from '../../cobuild';
import { UnpackResult } from '@ckb-lumos/codec';

export function getSporeOutput(
  txSkeleton: helpers.TransactionSkeletonType,
  outputIndex: number,
  config: SporeConfig,
): {
  id: Hash;
  cell: Cell;
  data: RawSporeData;
  script: SporeScript;
} {
  const cell = txSkeleton.get('outputs').get(outputIndex);
  expect(cell).toBeDefined();

  const type = cell!.cellOutput.type;
  expect(type).toBeDefined();

  expect(isSporeScriptSupported(config, type!, 'Spore')).toEqual(true);
  const script = getSporeScript(config, 'Spore', type!);

  const id = cell!.cellOutput.type!.args;
  expect(id.length).toBeGreaterThanOrEqual(66);
  expect(id).not.toEqual('0x0000000000000000000000000000000000000000000000000000000000000000');

  const data = unpackToRawSporeData(cell!.data);

  return {
    cell: cell!,
    script,
    data,
    id,
  };
}

export function getClusterOutput(
  txSkeleton: helpers.TransactionSkeletonType,
  outputIndex: number,
  config: SporeConfig,
): {
  id: Hash;
  cell: Cell;
  data: RawClusterData;
  script: SporeScript;
} {
  const cell = txSkeleton.get('outputs').get(outputIndex);
  expect(cell).toBeDefined();

  const type = cell!.cellOutput.type;
  expect(type).toBeDefined();

  expect(isSporeScriptSupported(config, type!, 'Cluster')).toEqual(true);
  const script = getSporeScript(config, 'Cluster', type!);

  const id = cell!.cellOutput.type!.args;
  expect(id.length).toBeGreaterThanOrEqual(66);
  expect(id).not.toEqual('0x0000000000000000000000000000000000000000000000000000000000000000');

  const data = unpackToRawClusterData(cell!.data);

  return {
    cell: cell!,
    script,
    data,
    id,
  };
}

export function getClusterProxyOutput(
  txSkeleton: helpers.TransactionSkeletonType,
  outputIndex: number,
  config: SporeConfig,
): {
  id: Hash;
  cell: Cell;
  data: Hash;
  args: RawClusterProxyArgs;
  script: SporeScript;
} {
  const cell = txSkeleton.get('outputs').get(outputIndex);
  expect(cell).toBeDefined();

  const type = cell!.cellOutput.type;
  expect(type).toBeDefined();

  expect(isSporeScriptSupported(config, type!, 'ClusterProxy')).toEqual(true);
  const script = getSporeScript(config, 'ClusterProxy', type!);

  const args = unpackToRawClusterProxyArgs(type!.args);
  const id = args.id;
  expect(id.length).toBeGreaterThanOrEqual(66);
  expect(id).not.toEqual('0x0000000000000000000000000000000000000000000000000000000000000000');

  const data = cell!.data;
  expect(data.length).toBeGreaterThanOrEqual(66);

  return {
    cell: cell!,
    script,
    data,
    args,
    id,
  };
}

export function getClusterAgentOutput(
  txSkeleton: helpers.TransactionSkeletonType,
  outputIndex: number,
  config: SporeConfig,
): {
  id: Hash;
  cell: Cell;
  data: Hash;
  script: SporeScript;
} {
  const cell = txSkeleton.get('outputs').get(outputIndex);
  expect(cell).toBeDefined();

  const type = cell!.cellOutput.type;
  expect(type).toBeDefined();

  expect(isSporeScriptSupported(config, type!, 'ClusterAgent')).toEqual(true);
  const script = getSporeScript(config, 'ClusterAgent', type!);

  const id = type!.args;
  expect(id.length).toBeGreaterThanOrEqual(66);
  expect(id).not.toEqual('0x0000000000000000000000000000000000000000000000000000000000000000');

  const data = cell!.data;
  expect(data.length).toBeGreaterThanOrEqual(66);

  return {
    cell: cell!,
    script,
    data,
    id,
  };
}

export function expectTypeId(txSkeleton: helpers.TransactionSkeletonType, outputIndex: number, expectId: Hash) {
  const firstInput = txSkeleton.get('inputs').get(0);
  expect(firstInput).toBeDefined();

  const generatedTypeId = generateTypeId(firstInput!, outputIndex);
  expect(expectId).toEqual(generatedTypeId);
}

export function expectCell(
  txSkeleton: helpers.TransactionSkeletonType,
  source: 'input' | 'output' | 'both',
  find: (cell: Cell) => boolean,
) {
  const input = txSkeleton.get('inputs').find(find);
  const output = txSkeleton.get('outputs').find(find);
  if (source === 'input') {
    expect(input).toBeDefined();
    expect(output).not.toBeDefined();
  }
  if (source === 'output') {
    expect(input).not.toBeDefined();
    expect(output).toBeDefined();
  }
  if (source === 'both') {
    expect(input).toBeDefined();
    expect(output).toBeDefined();
  }
}

export function expectLockCell(
  txSkeleton: helpers.TransactionSkeletonType,
  source: 'input' | 'output' | 'both',
  lock: Script,
) {
  expectCell(txSkeleton, source, findCellByLock(lock));
}

export function expectTypeCell(
  txSkeleton: helpers.TransactionSkeletonType,
  source: 'input' | 'output' | 'both',
  type: Script,
) {
  expectCell(txSkeleton, source, findCellByType(type));
}

export function expectCellDep(txSkeleton: helpers.TransactionSkeletonType, cellDep: CellDep) {
  const cellDeps = txSkeleton.get('cellDeps');
  const cellDepIndex = cellDeps.findIndex((dep) => {
    return (
      dep.outPoint.txHash === cellDep.outPoint.txHash &&
      dep.outPoint.index === cellDep.outPoint.index &&
      dep.depType === cellDep.depType
    );
  });

  expect(cellDepIndex).toBeGreaterThanOrEqual(0);
}

export function expectCellLock(cell: Cell, locks: Script[]) {
  const anyMatch = locks.some((lock) => isScriptValueEquals(cell.cellOutput.lock, lock));
  expect(anyMatch).toEqual(true);
}

export function findCellByLock(lock: Script) {
  return (cell: Cell) => isScriptValueEquals(lock, cell.cellOutput.lock);
}

export function findCellByType(type: Script) {
  return (cell: Cell) => !!cell.cellOutput.type && isScriptValueEquals(type, cell.cellOutput.type);
}

export function getActionsFromCobuildWitnessLayout(witness: HexString) {
  const witnessType = getWitnessType(witness);
  expect(witnessType).toEqual('SighashAll');

  const witnessLayout = WitnessLayout.unpack(witness);
  return (witnessLayout.value as UnpackResult<typeof SighashAll>).message.actions.map((action) => {
    return {
      scriptInfoHash: action.scriptInfoHash,
      scriptHash: action.scriptHash,
      data: action.data,
      sporeActionData: SporeAction.unpack(action.data),
    };
  });
}


================================================
File: packages/core/src/__tests__/helpers/combine.ts
================================================
import { helpers } from '@ckb-lumos/lumos';
/**
 * åˆå¹¶ä¸¤ä¸ªå¯¹è±¡ä¸­çš„ç‰¹å®šæ•°ç»„å±æ€§ï¼Œå¹¶å»é‡ã€‚
 *
 * @param obj1 ç¬¬ä¸€ä¸ªå¯¹è±¡
 * @param obj2 ç¬¬äºŒä¸ªå¯¹è±¡
 * @param keys éœ€è¦åˆå¹¶å’Œå»é‡çš„å±æ€§åæ•°ç»„
 * @returns è¿”å›åˆå¹¶åçš„æ–°å¯¹è±¡
 */
function mergeObjectsWithUniqueArrays(
  obj1: helpers.TransactionSkeletonType,
  obj2: helpers.TransactionSkeletonType,
): helpers.TransactionSkeletonType {
  let keys = [
    'inputs',
    'outputs',
    'cellDeps',
    'headerDeps',
    'witnesses',
    'fixedEntries',
    'signingEntries',
    'inputSinces',
  ];
  const result: helpers.TransactionSkeletonType = { ...obj1 };

  keys.forEach((key: string) => {
    const array1 = Array.isArray(obj1[key]) ? obj1[key] : [];
    const array2 = Array.isArray(obj2[key]) ? obj2[key] : [];
    const mergedArray = [...array1, ...array2];
    const uniqueArray = Array.from(new Set(mergedArray.map((item) => JSON.stringify(item)))).map((str) =>
      JSON.parse(str),
    );
    result[key] = uniqueArray;
  });

  return result;
}


================================================
File: packages/core/src/__tests__/helpers/config.ts
================================================
import { readFileSync } from 'fs';
import { BI, HexString } from '@ckb-lumos/lumos';
import { Config } from '@ckb-lumos/config-manager';
import { predefinedSporeConfigs, SporeConfig } from '../../config';

export function generateTestConfig(network: string, configPath?: string): SporeConfig {
  if (network === 'devnet') {
    try {
      const jsonData = JSON.parse(readFileSync(configPath!, 'utf-8'));
      return generateDevnetSporeConfig(jsonData);
    } catch {
      throw new Error(`Cannot generate devnet config from: "${configPath}"`);
    }
  }

  return predefinedSporeConfigs.Aggron4;
}

export function generateDevnetSporeConfig(config: Record<any, any>): SporeConfig {
  return {
    lumos: config as Config,
    ckbNodeUrl: 'http://127.0.0.1:8114',
    ckbIndexerUrl: 'http://127.0.0.1:8114',
    maxTransactionSize: 500 * 1024, // 500 KB
    scripts: {
      Spore: {
        versions: [
          {
            tags: ['v2', 'preview'],
            script: {
              codeHash: config.SCRIPTS.SPORE.CODE_HASH,
              hashType: config.SCRIPTS.SPORE.HASH_TYPE,
            },
            cellDep: {
              outPoint: {
                txHash: config.SCRIPTS.SPORE.TX_HASH,
                index: config.SCRIPTS.SPORE.INDEX,
              },
              depType: config.SCRIPTS.SPORE.DEP_TYPE,
            },
            behaviors: {
              lockProxy: true,
              cobuild: true,
            },
          },
          {
            tags: ['v1', 'latest'],
            script: {
              codeHash: config.SCRIPTS.SPORE_V1.CODE_HASH,
              hashType: config.SCRIPTS.SPORE_V1.HASH_TYPE,
            },
            cellDep: {
              outPoint: {
                txHash: config.SCRIPTS.SPORE_V1.TX_HASH,
                index: config.SCRIPTS.SPORE_V1.INDEX,
              },
              depType: config.SCRIPTS.SPORE_V1.DEP_TYPE,
            },
          },
        ],
      },
      Cluster: {
        versions: [
          {
            tags: ['v2', 'preview'],
            script: {
              codeHash: config.SCRIPTS.CLUSTER.CODE_HASH,
              hashType: config.SCRIPTS.CLUSTER.HASH_TYPE,
            },
            cellDep: {
              outPoint: {
                txHash: config.SCRIPTS.CLUSTER.TX_HASH,
                index: config.SCRIPTS.CLUSTER.INDEX,
              },
              depType: config.SCRIPTS.CLUSTER.DEP_TYPE,
            },
            behaviors: {
              lockProxy: true,
              cobuild: true,
            },
          },
          {
            tags: ['v1', 'latest'],
            script: {
              codeHash: config.SCRIPTS.CLUSTER_V1.CODE_HASH,
              hashType: config.SCRIPTS.CLUSTER_V1.HASH_TYPE,
            },
            cellDep: {
              outPoint: {
                txHash: config.SCRIPTS.CLUSTER_V1.TX_HASH,
                index: config.SCRIPTS.CLUSTER_V1.INDEX,
              },
              depType: config.SCRIPTS.CLUSTER_V1.DEP_TYPE,
            },
            behaviors: {
              clusterDataVersion: 'v1',
            },
          },
        ],
      },
      ClusterProxy: {
        versions: [
          {
            tags: ['v2', 'preview'],
            script: {
              codeHash: config.SCRIPTS.CLUSTER_PROXY.CODE_HASH,
              hashType: config.SCRIPTS.CLUSTER_PROXY.HASH_TYPE,
            },
            cellDep: {
              outPoint: {
                txHash: config.SCRIPTS.CLUSTER_PROXY.TX_HASH,
                index: config.SCRIPTS.CLUSTER_PROXY.INDEX,
              },
              depType: config.SCRIPTS.CLUSTER_PROXY.DEP_TYPE,
            },
            behaviors: {
              lockProxy: true,
              cobuild: true,
            },
          },
        ],
      },
      ClusterAgent: {
        versions: [
          {
            tags: ['v2', 'preview'],
            script: {
              codeHash: config.SCRIPTS.CLUSTER_AGENT.CODE_HASH,
              hashType: config.SCRIPTS.CLUSTER_AGENT.HASH_TYPE,
            },
            cellDep: {
              outPoint: {
                txHash: config.SCRIPTS.CLUSTER_AGENT.TX_HASH,
                index: config.SCRIPTS.CLUSTER_AGENT.INDEX,
              },
              depType: config.SCRIPTS.CLUSTER_AGENT.DEP_TYPE,
            },
            behaviors: {
              lockProxy: true,
              cobuild: true,
            },
          },
        ],
      },
      Mutant: {
        versions: [
          {
            tags: ['v2', 'preview'],
            script: {
              codeHash: config.SCRIPTS.SPORE_EXTENSION_LUA.CODE_HASH,
              hashType: config.SCRIPTS.SPORE_EXTENSION_LUA.HASH_TYPE,
            },
            cellDep: {
              outPoint: {
                txHash: config.SCRIPTS.SPORE_EXTENSION_LUA.TX_HASH,
                index: config.SCRIPTS.SPORE_EXTENSION_LUA.INDEX,
              },
              depType: config.SCRIPTS.SPORE_EXTENSION_LUA.DEP_TYPE,
            },
            behaviors: {
              lockProxy: true,
              cobuild: true,
            },
          },
        ],
      },
      Lua: {
        versions: [
          {
            tags: ['v2', 'preview'],
            script: {
              codeHash: config.SCRIPTS.LUA_LIB.CODE_HASH,
              hashType: config.SCRIPTS.LUA_LIB.HASH_TYPE,
            },
            cellDep: {
              outPoint: {
                txHash: config.SCRIPTS.LUA_LIB.TX_HASH,
                index: config.SCRIPTS.LUA_LIB.INDEX,
              },
              depType: config.SCRIPTS.LUA_LIB.DEP_TYPE,
            },
          },
        ],
      },
    },
  };
}

export function getEnvVariable(name: string, type: 'number'): number | undefined;
export function getEnvVariable(name: string, type: 'string'): string | undefined;
export function getEnvVariable(name: string, type: 'boolean'): boolean | undefined;
export function getEnvVariable(name: string, type: 'json'): Record<any, any> | undefined;
export function getEnvVariable(name: string, type: 'number', defaultValue: number): number;
export function getEnvVariable(name: string, type: 'string', defaultValue: string): string;
export function getEnvVariable(name: string, type: 'boolean', defaultValue: boolean): boolean;
export function getEnvVariable<T extends Record<any, any>>(name: string, type: 'json', defaultValue: T): T;
export function getEnvVariable(name: string, type: unknown, defaultValue?: unknown): unknown {
  const value = import.meta.env[name];
  if (type === 'json') {
    try {
      return JSON.parse(value);
    } catch {
      return defaultValue;
    }
  }
  if (type === 'boolean') {
    if (value === 'true' || value === 'false') {
      return value === 'true';
    } else {
      return defaultValue;
    }
  }
  if (type === 'number') {
    try {
      return BI.from(value).toNumber();
    } catch {
      return defaultValue;
    }
  }
  if (value && value.trim().length <= 0) {
    return defaultValue;
  }
  if (value === void 0) {
    return defaultValue;
  }

  return value;
}


================================================
File: packages/core/src/__tests__/helpers/file.ts
================================================
import { resolve } from 'path';
import { readFileSync } from 'fs';
import { bytes } from '@ckb-lumos/codec';
import { HexString } from '@ckb-lumos/lumos';
import { bytifyRawString } from '../../helpers';

export async function fetchLocalFile(
  src: string,
  relativePath?: string,
): Promise<{
  bytes: ArrayBuffer;
  hex: HexString;
}> {
  const buffer = readFileSync(resolve(relativePath ?? __dirname, src));
  const uint8Array = new Uint8Array(buffer);
  return {
    bytes: uint8Array,
    hex: bytes.hexify(uint8Array),
  };
}

export async function fetchLocalImage(
  src: string,
  relativePath?: string,
): Promise<{
  arrayBuffer: ArrayBuffer;
  arrayBufferHex: HexString;
  base64: string;
  base64Hex: HexString;
}> {
  const buffer = readFileSync(resolve(relativePath ?? __dirname, src));
  const arrayBuffer = new Uint8Array(buffer).buffer;
  const base64 = buffer.toString('base64');
  return {
    base64,
    arrayBuffer,
    arrayBufferHex: bytes.hexify(arrayBuffer),
    base64Hex: bytes.hexify(bytifyRawString(base64)),
  };
}


================================================
File: packages/core/src/__tests__/helpers/index.ts
================================================
export * from './account';
export * from './record';
export * from './check';
export * from './retry';
export * from './file';
export * from './config';
export * from './wallet';


================================================
File: packages/core/src/__tests__/helpers/record.ts
================================================
import { expect } from 'vitest';
import { Hash, OutPoint } from '@ckb-lumos/base';
import { Account } from './account';

export interface TestRecord {
  account: Account;
}
export interface IdRecord extends TestRecord {
  id: Hash;
}
export interface OutPointRecord extends TestRecord {
  outPoint: OutPoint;
}

export function popRecord<T>(records: T[], strict: true): T;
export function popRecord<T>(records: T[], strict?: false): T | undefined;
export function popRecord<T>(records: T[], strict?: unknown): T | undefined {
  const [record] = records.splice(records.length - 1, 1);
  if (strict) {
    expect(record).toBeDefined();
  }

  return record;
}

export function unshiftRecord<T>(records: T[], strict: true): T;
export function unshiftRecord<T>(records: T[], strict?: false): T | undefined;
export function unshiftRecord<T>(records: T[], strict?: unknown): T | undefined {
  const [record] = records.splice(0, 1);
  if (strict) {
    expect(record).toBeDefined();
  }

  return record;
}


================================================
File: packages/core/src/__tests__/helpers/retry.ts
================================================
import { retryWork } from '../../helpers';

export async function retryQuery<T>(getter: () => T | Promise<T>): Promise<T> {
  const work = await retryWork({
    getter,
    retry: 8,
    interval: 10000,
  });

  if (!work.success) {
    if (work.errors.length > 0) {
      throw new Error(`RetryWork failed for ${work.retries} times`, {
        cause: work.errors.pop(),
      });
    } else {
      throw new Error(`RetryWork failed with no error for ${work.retries} times`);
    }
  }

  return work.result as T;
}


================================================
File: packages/core/src/__tests__/helpers/wallet.ts
================================================
import { defaultEmptyWitnessArgs, updateWitnessArgs, isScriptValueEquals, getSporeConfig } from '../..';
import { hd, helpers, RPC, Address, Hash, Script, HexString } from '@ckb-lumos/lumos';
import { secp256k1Blake160 } from '@ckb-lumos/lumos/common-scripts';

export interface Wallet {
  lock: Script;
  address: Address;
  signMessage(message: HexString): Hash;
  signTransaction(txSkeleton: helpers.TransactionSkeletonType): helpers.TransactionSkeletonType;
  signAndSendTransaction(txSkeleton: helpers.TransactionSkeletonType): Promise<Hash>;
}

/**
 * Create a CKB Default Lock (Secp256k1Blake160 Sign-all) Wallet by a private-key and a SporeConfig,
 * providing lock/address, and functions to sign message/transaction and send the transaction on-chain.
 */
export function createDefaultLockWallet(privateKey: HexString): Wallet {
  const config = getSporeConfig();

  // Generate a lock script from the private key
  const defaultLock = config.lumos.SCRIPTS.SECP256K1_BLAKE160!;
  const lock: Script = {
    codeHash: defaultLock.CODE_HASH,
    hashType: defaultLock.HASH_TYPE,
    args: hd.key.privateKeyToBlake160(privateKey),
  };

  // Generate address from the lock script
  const address = helpers.encodeToAddress(lock, {
    config: config.lumos,
  });

  // Sign for a message
  function signMessage(message: HexString): Hash {
    return hd.key.signRecoverable(message, privateKey);
  }

  // Sign prepared signing entries,
  // and then fill signatures into Transaction.witnesses
  function signTransaction(txSkeleton: helpers.TransactionSkeletonType): helpers.TransactionSkeletonType {
    const signingEntries = txSkeleton.get('signingEntries');
    const signatures = new Map<HexString, Hash>();
    const inputs = txSkeleton.get('inputs');

    let witnesses = txSkeleton.get('witnesses');
    for (let i = 0; i < signingEntries.size; i++) {
      const entry = signingEntries.get(i)!;
      if (entry.type === 'witness_args_lock') {
        // Skip if the input's lock does not match to the wallet's lock
        const input = inputs.get(entry.index);
        if (!input || !isScriptValueEquals(input.cellOutput.lock, lock)) {
          continue;
        }

        // Sign message
        if (!signatures.has(entry.message)) {
          const sig = signMessage(entry.message);
          signatures.set(entry.message, sig);
        }

        // Update signature to Transaction.witnesses
        const signature = signatures.get(entry.message)!;
        const witness = witnesses.get(entry.index, defaultEmptyWitnessArgs);
        witnesses = witnesses.set(entry.index, updateWitnessArgs(witness, 'lock', signature));
      }
    }

    return txSkeleton.set('witnesses', witnesses);
  }

  // Sign the transaction and send it via RPC
  async function signAndSendTransaction(txSkeleton: helpers.TransactionSkeletonType): Promise<Hash> {
    // 1. Sign transaction
    txSkeleton = secp256k1Blake160.prepareSigningEntries(txSkeleton, { config: config.lumos });
    txSkeleton = signTransaction(txSkeleton);

    // 2. Convert TransactionSkeleton to Transaction
    const tx = helpers.createTransactionFromSkeleton(txSkeleton);

    // 3. Send transaction
    const rpc = new RPC(config.ckbNodeUrl);
    return await rpc.sendTransaction(tx, 'passthrough');
  }

  return {
    lock,
    address,
    signMessage,
    signTransaction,
    signAndSendTransaction,
  };
}


================================================
File: packages/core/src/__tests__/resources/firstOutputMutant.lua
================================================
if spore_ext_mode == 1 and spore_output_index > 0 then
  ckb.exit_script(89)
end


================================================
File: packages/core/src/__tests__/resources/immortalMutant.lua
================================================
-- Melt a Spore denied
if spore_ext_mode == 3 then
  ckb.exit_script("99")
end


================================================
File: packages/core/src/__tests__/resources/mustTransferMutant.lua
================================================
if spore_ext_mode == 2 then
  local input_lock_hash, err = ckb.load_cell_by_field(spore_input_index, ckb.SOURCE_INPUT, ckb.CELL_FIELD_LOCK_HASH)
  local output_lock_hash, err = ckb.load_cell_by_field(spore_output_index, ckb.SOURCE_OUTPUT, ckb.CELL_FIELD_LOCK_HASH)
  if input_lock_hash == output_lock_hash then
    ckb.exit_script(87)
  end
end


================================================
File: packages/core/src/__tests__/resources/noTransferMutant.lua
================================================
if spore_ext_mode == 2 then
  ckb.exit_script(88)
end


================================================
File: packages/core/src/__tests__/shared/env.ts
================================================
import { resolve } from 'path';
import { RPC, Indexer } from '@ckb-lumos/lumos';
import { getEnvVariable, generateTestConfig, createDefaultLockAccount } from '../helpers';
import { forkSporeConfig } from '../../config';

export const TEST_VARIABLES = {
  network: getEnvVariable('VITE_NETWORK', 'string', 'testnet'),
  configPath: getEnvVariable('VITE_CONFIG_PATH', 'string', '../tmp/config.json'),
  tests: {
    clusterV1: getEnvVariable('VITE_TEST_CLUSTER_V1', 'boolean', false),
  },
  accounts: {
    charlie: getEnvVariable(
      'VITE_ACCOUNT_CHARLIE',
      'string',
      '0xd6013cd867d286ef84cc300ac6546013837df2b06c9f53c83b4c33c2417f6a07',
    ),
    alice: getEnvVariable(
      'VITE_ACCOUNT_ALICE',
      'string',
      '0x49aa6d595ac46cc8e1a31b511754dd58f241a7d8a6ad29e83d6b0c1a82399f3d',
    ),
    bob: getEnvVariable(
      'VITE_ACCOUNT_BOB',
      'string',
      '0xee638e49a61bdc7fda63c412c29d5185eec2913f1122ab59b5d362ee9ef9bb50',
    ),
  },
};

const config = generateTestConfig(TEST_VARIABLES.network, resolve(__dirname, TEST_VARIABLES.configPath));
export const TEST_ENV = {
  config,
  v1Config: forkSporeConfig(config, {
    defaultTags: ['v1'],
  }),
  rpc: new RPC(config.ckbNodeUrl),
  indexer: new Indexer(config.ckbIndexerUrl, config.ckbNodeUrl),
};

export const TEST_ACCOUNTS = {
  CHARLIE: createDefaultLockAccount(TEST_VARIABLES.accounts.charlie, config),
  ALICE: createDefaultLockAccount(TEST_VARIABLES.accounts.alice, config),
  BOB: createDefaultLockAccount(TEST_VARIABLES.accounts.bob, config),
};


================================================
File: packages/core/src/__tests__/shared/index.ts
================================================
export * from './env';
export * from './record';


================================================
File: packages/core/src/__tests__/shared/record.ts
================================================
import { resolve } from 'path';
import { existsSync, mkdirSync, writeFileSync } from 'fs';
import { retryWork } from '../../helpers';
import { meltClusterAgent, meltClusterProxy, meltSpore } from '../../api';
import { getClusterAgentByOutPoint, getClusterProxyByOutPoint, getSporeByOutPoint } from '../../api';
import { retryQuery, signAndOrSendTransaction, OutPointRecord } from '../helpers';
import { TEST_ENV } from './env';

export const SPORE_OUTPOINT_RECORDS: OutPointRecord[] = [];
export const CLUSTER_OUTPOINT_RECORDS: OutPointRecord[] = [];
export const CLUSTER_PROXY_OUTPOINT_RECORDS: OutPointRecord[] = [];
export const CLUSTER_AGENT_OUTPOINT_RECORDS: OutPointRecord[] = [];

export interface OutpointWithSporeIdRecord extends OutPointRecord {
  sporeId: string;
}

export const MultipleTestSPORE_OUTPOINT_RECORDS: OutpointWithSporeIdRecord[] = [];

export async function cleanupRecords(props: { name: string }) {
  const [sporeCleanupResults, clusterProxyCleanupResults, clusterAgentCleanupResults] = await Promise.all([
    cleanupSporeRecords(),
    cleanupClusterProxyRecords(),
    cleanupClusterAgentRecords(),
  ]);

  const result = {
    sporeCleanupResults,
    clusterProxyCleanupResults,
    clusterAgentCleanupResults,
  };

  const path = resolve(__dirname, '../tmp');
  if (!existsSync(path)) {
    mkdirSync(path);
  }

  const json = JSON.stringify(result, null, 2);
  writeFileSync(resolve(path, `${props.name}-cleanup-${Date.now()}.json`), json);
}

const { config, rpc } = TEST_ENV;

export async function cleanupSporeRecords() {
  const promises = SPORE_OUTPOINT_RECORDS.map((record) => {
    return retryWork({
      getter: async () => {
        const sporeCell = await retryQuery(() => getSporeByOutPoint(record.outPoint, config));
        const { txSkeleton } = await meltSpore({
          outPoint: sporeCell.outPoint!,
          changeAddress: record.account.address,
          config,
        });

        return signAndOrSendTransaction({
          account: record.account,
          txSkeleton,
          config,
          rpc,
          send: true,
        });
      },
      retry: 2,
      interval: 5000,
    });
  });
  const works = await Promise.all(promises);
  return SPORE_OUTPOINT_RECORDS.map((record, index) => {
    const work = works[index];
    return {
      success: work.success,
      outPoint: record.outPoint,
      txHash: work.success ? work.result : void 0,
    };
  });
}

export async function cleanupClusterProxyRecords() {
  const promises = CLUSTER_PROXY_OUTPOINT_RECORDS.map((record) => {
    return retryWork({
      getter: async () => {
        const clusterProxyCell = await retryQuery(() => getClusterProxyByOutPoint(record.outPoint, config));
        const { txSkeleton } = await meltClusterProxy({
          outPoint: clusterProxyCell.outPoint!,
          changeAddress: record.account.address,
          config,
        });

        return signAndOrSendTransaction({
          account: record.account,
          txSkeleton,
          config,
          rpc,
          send: true,
        });
      },
      retry: 2,
      interval: 5000,
    });
  });
  const works = await Promise.all(promises);
  return CLUSTER_PROXY_OUTPOINT_RECORDS.map((record, index) => {
    const work = works[index];
    return {
      success: work.success,
      outPoint: record.outPoint,
      txHash: work.success ? work.result : void 0,
    };
  });
}

export async function cleanupClusterAgentRecords() {
  const promises = CLUSTER_AGENT_OUTPOINT_RECORDS.map((record) => {
    return retryWork({
      getter: async () => {
        const clusterAgentCell = await retryQuery(() => getClusterAgentByOutPoint(record.outPoint, config));
        const { txSkeleton } = await meltClusterAgent({
          outPoint: clusterAgentCell.outPoint!,
          changeAddress: record.account.address,
          config,
        });

        return signAndOrSendTransaction({
          account: record.account,
          txSkeleton,
          config,
          rpc,
          send: true,
        });
      },
      retry: 2,
      interval: 5000,
    });
  });
  const works = await Promise.all(promises);
  return CLUSTER_AGENT_OUTPOINT_RECORDS.map((record, index) => {
    const work = works[index];
    return {
      success: work.success,
      outPoint: record.outPoint,
      txHash: work.success ? work.result : void 0,
    };
  });
}


================================================
File: packages/core/src/api/index.ts
================================================
/**
 * Composed APIs
 */

// Cluster
export * from './composed/cluster/createCluster';
export * from './composed/cluster/transferCluster';

// Spore
export * from './composed/spore/createSpore';
export * from './composed/spore/transferSpore';
export * from './composed/spore/meltSpore';
export * from './composed/spore/meltThenCreateSpore';

// ClusterProxy
export * from './composed/clusterProxy/createClusterProxy';
export * from './composed/clusterProxy/transferClusterProxy';
export * from './composed/clusterProxy/meltClusterProxy';

// ClusterAgent
export * from './composed/clusterAgent/createClusterAgent';
export * from './composed/clusterAgent/transferClusterAgent';
export * from './composed/clusterAgent/meltClusterAgent';

// Mutant
export * from './composed/mutant/createMutant';
export * from './composed/mutant/transferMutant';

/**
 * Joint APIs
 */

// Cluster
export * from './joints/cluster/injectNewClusterOutput';
export * from './joints/cluster/injectNewClusterIds';
export * from './joints/cluster/injectLiveClusterCell';
export * from './joints/cluster/injectLiveClusterReference';
export * from './joints/cluster/getCluster';

// Spore
export * from './joints/spore/injectNewSporeOutput';
export * from './joints/spore/injectLiveSporeCell';
export * from './joints/spore/injectNewSporeIds';
export * from './joints/spore/getSpore';

// ClusterProxy
export * from './joints/clusterProxy/injectNewClusterProxyOutput';
export * from './joints/clusterProxy/injectNewClusterProxyIds';
export * from './joints/clusterProxy/injectLiveClusterProxyCell';
export * from './joints/clusterProxy/injectLiveClusterProxyReference';
export * from './joints/clusterProxy/getClusterProxy';

// ClusterAgent
export * from './joints/clusterAgent/injectNewClusterAgentOutput';
export * from './joints/clusterAgent/injectLiveClusterAgentCell';
export * from './joints/clusterAgent/injectLiveClusterAgentReference';
export * from './joints/clusterAgent/getClusterAgent';

// Mutant
export * from './joints/mutant/injectNewMutantOutput';
export * from './joints/mutant/injectNewMutantIds';
export * from './joints/mutant/injectLiveMutantCell';
export * from './joints/mutant/injectLiveMutantReferences';
export * from './joints/mutant/getMutant';


================================================
File: packages/core/src/api/composed/cluster/createCluster.ts
================================================
import { BIish } from '@ckb-lumos/bi';
import { Address, Script } from '@ckb-lumos/base';
import { FromInfo } from '@ckb-lumos/lumos/common-scripts';
import { BI, Indexer, helpers, Cell } from '@ckb-lumos/lumos';
import { getSporeConfig, getSporeScript, SporeConfig } from '../../../config';
import { assertTransactionSkeletonSize, injectCapacityAndPayFee } from '../../../helpers';
import { injectNewClusterIds, injectNewClusterOutput } from '../..';
import { RawClusterData } from '../../../codec';
import { generateCreateClusterAction } from '../../../cobuild/action/cluster/createCluster';
import { injectCommonCobuildProof } from '../../../cobuild/base/witnessLayout';

export async function createCluster(props: {
  data: RawClusterData;
  toLock: Script;
  fromInfos: FromInfo[];
  changeAddress?: Address;
  updateOutput?: (cell: Cell) => Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  maxTransactionSize?: number | false;
  feeRate?: BIish | undefined;
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  outputIndex: number;
}> {
  // Env
  const config = props.config ?? getSporeConfig();
  const indexer = new Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);
  const capacityMargin = BI.from(props.capacityMargin ?? 1_0000_0000);
  const maxTransactionSize = props.maxTransactionSize ?? config.maxTransactionSize ?? false;

  // TransactionSkeleton
  let txSkeleton = helpers.TransactionSkeleton({
    cellProvider: indexer,
  });

  // Generate and inject Cluster cell
  const injectNewClusterResult = injectNewClusterOutput({
    txSkeleton,
    data: props.data,
    toLock: props.toLock,
    updateOutput: props.updateOutput,
    capacityMargin,
    config,
  });
  txSkeleton = injectNewClusterResult.txSkeleton;

  // Inject needed capacity and pay fee
  const injectCapacityAndPayFeeResult = await injectCapacityAndPayFee({
    txSkeleton,
    fromInfos: props.fromInfos,
    changeAddress: props.changeAddress,
    feeRate: props.feeRate,
    updateTxSkeletonAfterCollection(_txSkeleton) {
      // Generate ID for the new Cluster (if possible)
      _txSkeleton = injectNewClusterIds({
        txSkeleton: _txSkeleton,
        outputIndices: [injectNewClusterResult.outputIndex],
        config,
      });

      // Inject CobuildProof
      const clusterCell = txSkeleton.get('outputs').get(injectNewClusterResult.outputIndex)!;
      const clusterScript = getSporeScript(config, 'Cluster', clusterCell.cellOutput.type!);
      if (clusterScript.behaviors?.cobuild) {
        const actionResult = generateCreateClusterAction({
          txSkeleton: _txSkeleton,
          outputIndex: injectNewClusterResult.outputIndex,
        });
        const injectCobuildProofResult = injectCommonCobuildProof({
          txSkeleton: _txSkeleton,
          actions: actionResult.actions,
        });
        _txSkeleton = injectCobuildProofResult.txSkeleton;
      }

      return _txSkeleton;
    },
    config,
  });
  txSkeleton = injectCapacityAndPayFeeResult.txSkeleton;

  // Make sure the tx size is in range (if needed)
  if (typeof maxTransactionSize === 'number') {
    assertTransactionSkeletonSize(txSkeleton, void 0, maxTransactionSize);
  }

  return {
    txSkeleton,
    outputIndex: injectNewClusterResult.outputIndex,
  };
}


================================================
File: packages/core/src/api/composed/cluster/transferCluster.ts
================================================
import { BIish } from '@ckb-lumos/bi';
import { FromInfo } from '@ckb-lumos/lumos/common-scripts';
import { Address, Script, OutPoint } from '@ckb-lumos/base';
import { BI, Cell, helpers, HexString, Indexer, PackedSince } from '@ckb-lumos/lumos';
import { injectCapacityAndPayFee, payFeeByOutput } from '../../../helpers';
import { getSporeConfig, getSporeScript, SporeConfig } from '../../../config';
import { generateTransferClusterAction, injectCommonCobuildProof } from '../../../cobuild';
import { getClusterByOutPoint, injectLiveClusterCell } from '../..';

export async function transferCluster(props: {
  outPoint: OutPoint;
  toLock: Script;
  fromInfos?: FromInfo[];
  changeAddress?: Address;
  useCapacityMarginAsFee?: boolean;
  updateOutput?: (cell: Cell) => Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  updateWitness?: HexString | ((witness: HexString) => HexString);
  defaultWitness?: HexString;
  since?: PackedSince;
  feeRate?: BIish | undefined;
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
  outputIndex: number;
}> {
  // Env
  const config = props.config ?? getSporeConfig();
  const indexer = new Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);
  const useCapacityMarginAsFee = props.useCapacityMarginAsFee ?? true;

  // Check capacity margin related props
  if (!useCapacityMarginAsFee && !props.fromInfos?.length) {
    throw new Error('When useCapacityMarginAsFee is enabled, fromInfos is also required');
  }
  if (useCapacityMarginAsFee && props.capacityMargin !== void 0) {
    throw new Error('When useCapacityMarginAsFee is enabled, cannot set capacityMargin of the cluster');
  }

  // TransactionSkeleton
  let txSkeleton = helpers.TransactionSkeleton({
    cellProvider: indexer,
  });

  // Find Cluster by OutPoint
  const clusterCell = await getClusterByOutPoint(props.outPoint, config);
  const clusterScript = getSporeScript(config, 'Cluster', clusterCell.cellOutput.type!);

  // Add Cluster to inputs and outputs of the Transaction
  const injectLiveClusterCellResult = await injectLiveClusterCell({
    txSkeleton,
    cell: clusterCell,
    addOutput: true,
    updateOutput(cell) {
      cell.cellOutput.lock = props.toLock;
      if (props.updateOutput instanceof Function) {
        cell = props.updateOutput(cell);
      }
      return cell;
    },
    capacityMargin: props.capacityMargin,
    defaultWitness: props.defaultWitness,
    updateWitness: props.updateWitness,
    since: props.since,
    config,
  });
  txSkeleton = injectLiveClusterCellResult.txSkeleton;

  // Generate TransferSpore actions
  const actionResult = generateTransferClusterAction({
    txSkeleton,
    inputIndex: injectLiveClusterCellResult.inputIndex,
    outputIndex: injectLiveClusterCellResult.outputIndex,
  });

  if (!useCapacityMarginAsFee) {
    // Inject needed capacity and pay fee
    const injectCapacityAndPayFeeResult = await injectCapacityAndPayFee({
      txSkeleton,
      fromInfos: props.fromInfos!,
      changeAddress: props.changeAddress,
      feeRate: props.feeRate,
      updateTxSkeletonAfterCollection(_txSkeleton) {
        // Inject CobuildProof
        if (clusterScript.behaviors?.cobuild) {
          const injectCobuildProofResult = injectCommonCobuildProof({
            txSkeleton: _txSkeleton,
            actions: actionResult.actions,
          });
          _txSkeleton = injectCobuildProofResult.txSkeleton;
        }
        return _txSkeleton;
      },
      config,
    });
    txSkeleton = injectCapacityAndPayFeeResult.txSkeleton;
  } else {
    // Inject CobuildProof
    if (clusterScript.behaviors?.cobuild) {
      const injectCobuildProofResult = injectCommonCobuildProof({
        txSkeleton: txSkeleton,
        actions: actionResult.actions,
      });
      txSkeleton = injectCobuildProofResult.txSkeleton;
    }

    // Pay fee by the cluster cell's capacity margin
    txSkeleton = await payFeeByOutput({
      outputIndex: injectLiveClusterCellResult.outputIndex,
      feeRate: props.feeRate,
      txSkeleton,
      config,
    });
  }

  return {
    txSkeleton,
    inputIndex: injectLiveClusterCellResult.inputIndex,
    outputIndex: injectLiveClusterCellResult.outputIndex,
  };
}


================================================
File: packages/core/src/api/composed/clusterAgent/createClusterAgent.ts
================================================
import { BIish } from '@ckb-lumos/bi';
import { FromInfo } from '@ckb-lumos/common-scripts';
import { Address, OutPoint, Script } from '@ckb-lumos/base';
import { BI, Cell, helpers, HexString, Indexer } from '@ckb-lumos/lumos';
import { injectCapacityAndPayFee } from '../../../helpers';
import { getSporeConfig, getSporeScript, SporeConfig } from '../../../config';
import { generateCreateClusterAgentAction, injectCommonCobuildProof } from '../../../cobuild';
import { getClusterProxyByOutPoint, injectNewClusterAgentOutput } from '../..';
import { unpackToRawClusterProxyArgs } from '../../../codec';

export async function createClusterAgent(props: {
  clusterProxyOutPoint: OutPoint;
  referenceType: 'cell' | 'payment';
  paymentAmount?: BIish | ((minPayment: BI) => BIish);
  toLock: Script;
  fromInfos: FromInfo[];
  changeAddress?: Address;
  updateOutput?: (cell: Cell) => Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  clusterProxy?: {
    updateOutput?: (cell: Cell) => Cell;
    capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
    updateWitness?: HexString | ((witness: HexString) => HexString);
  };
  feeRate?: BIish | undefined;
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  outputIndex: number;
  reference: Awaited<ReturnType<typeof injectNewClusterAgentOutput>>['reference'];
}> {
  // Env
  const config = props.config ?? getSporeConfig();
  const indexer = new Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);
  const capacityMargin = BI.from(props.capacityMargin ?? 1_0000_0000);

  // TransactionSkeleton
  let txSkeleton = helpers.TransactionSkeleton({
    cellProvider: indexer,
  });

  // Get referenced Cluster
  const clusterProxyCell = await getClusterProxyByOutPoint(props.clusterProxyOutPoint, config);

  // Create and inject a new ClusterProxy cell,
  // also inject the referenced Cluster or its LockProxy to the transaction
  const injectNewClusterAgentOutputResult = await injectNewClusterAgentOutput({
    txSkeleton,
    clusterProxyCell,
    referenceType: props.referenceType,
    paymentAmount: props.paymentAmount,
    toLock: props.toLock,
    fromInfos: props.fromInfos,
    changeAddress: props.changeAddress,
    updateOutput: props.updateOutput,
    clusterProxy: props.clusterProxy,
    capacityMargin,
    config,
  });
  txSkeleton = injectNewClusterAgentOutputResult.txSkeleton;

  // Inject needed capacity and pay fee
  const injectCapacityAndPayFeeResult = await injectCapacityAndPayFee({
    txSkeleton,
    fromInfos: props.fromInfos,
    changeAddress: props.changeAddress,
    feeRate: props.feeRate,
    updateTxSkeletonAfterCollection(_txSkeleton) {
      // Inject CobuildProof
      const clusterAgentCell = txSkeleton.get('outputs').get(injectNewClusterAgentOutputResult.outputIndex)!;
      const clusterAgentScript = getSporeScript(config, 'ClusterAgent', clusterAgentCell.cellOutput.type!);
      if (clusterAgentScript.behaviors?.cobuild) {
        const actionResult = generateCreateClusterAgentAction({
          txSkeleton: _txSkeleton,
          clusterProxyId: unpackToRawClusterProxyArgs(clusterProxyCell.cellOutput.type!.args).id,
          outputIndex: injectNewClusterAgentOutputResult.outputIndex,
          reference: injectNewClusterAgentOutputResult.reference,
        });
        const injectCobuildProofResult = injectCommonCobuildProof({
          txSkeleton: _txSkeleton,
          actions: actionResult.actions,
        });
        _txSkeleton = injectCobuildProofResult.txSkeleton;
      }

      return _txSkeleton;
    },
    config,
  });
  txSkeleton = injectCapacityAndPayFeeResult.txSkeleton;

  // TODO: validate the referenced ClusterProxy/Payment

  return {
    txSkeleton,
    outputIndex: injectNewClusterAgentOutputResult.outputIndex,
    reference: injectNewClusterAgentOutputResult.reference,
  };
}


================================================
File: packages/core/src/api/composed/clusterAgent/meltClusterAgent.ts
================================================
import { Address, OutPoint } from '@ckb-lumos/base';
import { helpers, HexString, Indexer } from '@ckb-lumos/lumos';
import { returnExceededCapacityAndPayFee } from '../../../helpers';
import { getSporeConfig, getSporeScript, SporeConfig } from '../../../config';
import { generateMeltClusterAgentAction, injectCommonCobuildProof } from '../../../cobuild';
import { getClusterAgentByOutPoint, injectLiveClusterAgentCell } from '../..';

export async function meltClusterAgent(props: {
  outPoint: OutPoint;
  changeAddress?: Address;
  updateWitness?: HexString | ((witness: HexString) => HexString);
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
}> {
  // Env
  const config = props.config ?? getSporeConfig();
  const indexer = new Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);

  // TransactionSkeleton
  let txSkeleton = helpers.TransactionSkeleton({
    cellProvider: indexer,
  });

  // Get ClusterAgent cell
  const clusterAgentCell = await getClusterAgentByOutPoint(props.outPoint, config);
  const clusterAgentScript = getSporeScript(config, 'ClusterAgent', clusterAgentCell.cellOutput.type!);

  // Inject target cell to Transaction.inputs
  const injectLiveClusterAgentCellResult = await injectLiveClusterAgentCell({
    txSkeleton,
    cell: clusterAgentCell,
    updateWitness: props.updateWitness,
    config,
  });
  txSkeleton = injectLiveClusterAgentCellResult.txSkeleton;

  // Inject CobuildProof
  if (clusterAgentScript.behaviors?.cobuild) {
    const actionResult = generateMeltClusterAgentAction({
      txSkeleton,
      inputIndex: injectLiveClusterAgentCellResult.inputIndex,
    });
    const injectCobuildProofResult = injectCommonCobuildProof({
      txSkeleton,
      actions: actionResult.actions,
    });
    txSkeleton = injectCobuildProofResult.txSkeleton;
  }

  // Redeem occupied capacity from the melted cell
  const targetCellAddress = helpers.encodeToAddress(clusterAgentCell.cellOutput.lock, { config: config.lumos });
  const returnExceededCapacityAndPayFeeResult = await returnExceededCapacityAndPayFee({
    changeAddress: props.changeAddress ?? targetCellAddress,
    txSkeleton,
    config,
  });
  txSkeleton = returnExceededCapacityAndPayFeeResult.txSkeleton;

  return {
    txSkeleton,
    inputIndex: injectLiveClusterAgentCellResult.inputIndex,
  };
}


================================================
File: packages/core/src/api/composed/clusterAgent/transferClusterAgent.ts
================================================
import { BIish } from '@ckb-lumos/bi';
import { FromInfo } from '@ckb-lumos/common-scripts';
import { Address, OutPoint, PackedSince, Script } from '@ckb-lumos/base';
import { BI, Cell, helpers, HexString, Indexer } from '@ckb-lumos/lumos';
import { injectCapacityAndPayFee, payFeeByOutput } from '../../../helpers';
import { getSporeConfig, getSporeScript, SporeConfig } from '../../../config';
import { generateTransferClusterAgentAction, injectCommonCobuildProof } from '../../../cobuild';
import { getClusterAgentByOutPoint, injectLiveClusterAgentCell } from '../..';

export async function transferClusterAgent(props: {
  outPoint: OutPoint;
  toLock: Script;
  fromInfos?: FromInfo[];
  changeAddress?: Address;
  useCapacityMarginAsFee?: boolean;
  updateOutput?: (cell: Cell) => Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  updateWitness?: HexString | ((witness: HexString) => HexString);
  defaultWitness?: HexString;
  since?: PackedSince;
  feeRate?: BIish | undefined;
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
  outputIndex: number;
}> {
  // Env
  const config = props.config ?? getSporeConfig();
  const indexer = new Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);
  const useCapacityMarginAsFee = props.useCapacityMarginAsFee ?? true;

  // Check capacity margin related props
  if (!useCapacityMarginAsFee && !props.fromInfos) {
    throw new Error('When useCapacityMarginAsFee is enabled, fromInfos is also required');
  }
  if (useCapacityMarginAsFee && props.capacityMargin !== void 0) {
    throw new Error('When useCapacityMarginAsFee is enabled, cannot update capacityMargin of the cell');
  }

  // Get TransactionSkeleton
  let txSkeleton = helpers.TransactionSkeleton({
    cellProvider: indexer,
  });

  // Get target ClusterAgent cell
  const clusterAgentCell = await getClusterAgentByOutPoint(props.outPoint, config);
  const clusterAgentScript = getSporeScript(config, 'ClusterAgent', clusterAgentCell.cellOutput.type!);

  // Inject live ClusterProxy cell to inputs/outputs of the Transaction
  const injectLiveClusterAgentCellResult = await injectLiveClusterAgentCell({
    txSkeleton,
    cell: clusterAgentCell,
    addOutput: true,
    updateOutput(cell) {
      cell.cellOutput.lock = props.toLock;
      if (props.updateOutput instanceof Function) {
        cell = props.updateOutput(cell);
      }
      return cell;
    },
    capacityMargin: props.capacityMargin,
    updateWitness: props.updateWitness,
    defaultWitness: props.defaultWitness,
    since: props.since,
    config,
  });
  txSkeleton = injectLiveClusterAgentCellResult.txSkeleton;

  // Generate TransferClusterAgent actions
  const actionResult = generateTransferClusterAgentAction({
    txSkeleton,
    inputIndex: injectLiveClusterAgentCellResult.inputIndex,
    outputIndex: injectLiveClusterAgentCellResult.outputIndex,
  });

  if (!useCapacityMarginAsFee) {
    // Inject needed capacity from fromInfos and pay fee
    const injectCapacityAndPayFeeResult = await injectCapacityAndPayFee({
      txSkeleton,
      fromInfos: props.fromInfos!,
      changeAddress: props.changeAddress,
      feeRate: props.feeRate,
      updateTxSkeletonAfterCollection(_txSkeleton) {
        // Inject CobuildProof
        if (clusterAgentScript.behaviors?.cobuild) {
          const injectCobuildProofResult = injectCommonCobuildProof({
            txSkeleton: _txSkeleton,
            actions: actionResult.actions,
          });
          _txSkeleton = injectCobuildProofResult.txSkeleton;
        }

        return _txSkeleton;
      },
      config,
    });
    txSkeleton = injectCapacityAndPayFeeResult.txSkeleton;
  } else {
    // Inject CobuildProof
    if (clusterAgentScript.behaviors?.cobuild) {
      const injectCobuildProofResult = injectCommonCobuildProof({
        txSkeleton,
        actions: actionResult.actions,
      });
      txSkeleton = injectCobuildProofResult.txSkeleton;
    }
    // Pay fee by the target cell's capacity margin
    txSkeleton = await payFeeByOutput({
      txSkeleton,
      feeRate: props.feeRate,
      outputIndex: injectLiveClusterAgentCellResult.outputIndex,
      config,
    });
  }

  return {
    txSkeleton,
    inputIndex: injectLiveClusterAgentCellResult.inputIndex,
    outputIndex: injectLiveClusterAgentCellResult.outputIndex,
  };
}


================================================
File: packages/core/src/api/composed/clusterProxy/createClusterProxy.ts
================================================
import { BIish } from '@ckb-lumos/bi';
import { FromInfo } from '@ckb-lumos/common-scripts';
import { Address, OutPoint, Script } from '@ckb-lumos/base';
import { BI, Cell, helpers, HexString, Indexer } from '@ckb-lumos/lumos';
import { injectCapacityAndPayFee } from '../../../helpers';
import { getSporeConfig, getSporeScript, SporeConfig } from '../../../config';
import { generateCreateClusterProxyAction, injectCommonCobuildProof } from '../../../cobuild';
import { getClusterByOutPoint, injectNewClusterProxyOutput, injectNewClusterProxyIds } from '../..';

export async function createClusterProxy(props: {
  clusterOutPoint: OutPoint;
  minPayment?: BIish;
  toLock: Script;
  fromInfos: FromInfo[];
  changeAddress?: Address;
  updateOutput?(cell: Cell): Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  cluster?: {
    updateOutput?(cell: Cell): Cell;
    capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
    updateWitness?: HexString | ((witness: HexString) => HexString);
  };
  feeRate?: BIish | undefined;
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  outputIndex: number;
  reference: Awaited<ReturnType<typeof injectNewClusterProxyOutput>>['reference'];
}> {
  // Env
  const config = props.config ?? getSporeConfig();
  const indexer = new Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);
  const capacityMargin = BI.from(props.capacityMargin ?? 1_0000_0000);

  // TransactionSkeleton
  let txSkeleton = helpers.TransactionSkeleton({
    cellProvider: indexer,
  });

  // Get referenced Cluster
  const clusterCell = await getClusterByOutPoint(props.clusterOutPoint, config);

  // Create and inject a new ClusterProxy cell,
  // also inject the referenced Cluster or its LockProxy to the transaction
  const injectNewClusterProxyResult = await injectNewClusterProxyOutput({
    txSkeleton,
    clusterCell,
    toLock: props.toLock,
    fromInfos: props.fromInfos,
    minPayment: props.minPayment,
    changeAddress: props.changeAddress,
    updateOutput: props.updateOutput,
    cluster: props.cluster,
    capacityMargin,
    config,
  });
  txSkeleton = injectNewClusterProxyResult.txSkeleton;

  // Inject needed capacity and pay fee
  const injectCapacityAndPayFeeResult = await injectCapacityAndPayFee({
    txSkeleton,
    fromInfos: props.fromInfos,
    changeAddress: props.changeAddress,
    feeRate: props.feeRate,
    updateTxSkeletonAfterCollection(_txSkeleton) {
      // Generate and inject ID for the new ClusterProxy
      _txSkeleton = injectNewClusterProxyIds({
        outputIndices: [injectNewClusterProxyResult.outputIndex],
        txSkeleton: _txSkeleton,
        config,
      });

      // Inject CobuildProof
      const clusterProxyCell = txSkeleton.get('outputs').get(injectNewClusterProxyResult.outputIndex)!;
      const clusterProxyScript = getSporeScript(config, 'ClusterProxy', clusterProxyCell.cellOutput.type!);
      if (clusterProxyScript.behaviors?.cobuild) {
        const actionResult = generateCreateClusterProxyAction({
          txSkeleton: _txSkeleton,
          outputIndex: injectNewClusterProxyResult.outputIndex,
          reference: injectNewClusterProxyResult.reference,
        });
        const injectCobuildProofResult = injectCommonCobuildProof({
          txSkeleton: _txSkeleton,
          actions: actionResult.actions,
        });
        _txSkeleton = injectCobuildProofResult.txSkeleton;
      }

      return _txSkeleton;
    },
    config,
  });
  txSkeleton = injectCapacityAndPayFeeResult.txSkeleton;

  // TODO: Validate the referenced Cluster/LockProxy

  return {
    txSkeleton,
    outputIndex: injectNewClusterProxyResult.outputIndex,
    reference: injectNewClusterProxyResult.reference,
  };
}


================================================
File: packages/core/src/api/composed/clusterProxy/meltClusterProxy.ts
================================================
import { Address, OutPoint } from '@ckb-lumos/base';
import { helpers, HexString, Indexer } from '@ckb-lumos/lumos';
import { returnExceededCapacityAndPayFee } from '../../../helpers';
import { getSporeConfig, getSporeScript, SporeConfig } from '../../../config';
import { generateMeltClusterProxyAction, injectCommonCobuildProof } from '../../../cobuild';
import { getClusterProxyByOutPoint, injectLiveClusterProxyCell } from '../..';

export async function meltClusterProxy(props: {
  outPoint: OutPoint;
  changeAddress?: Address;
  updateWitness?: HexString | ((witness: HexString) => HexString);
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
}> {
  // Env
  const config = props.config ?? getSporeConfig();
  const indexer = new Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);

  // TransactionSkeleton
  let txSkeleton = helpers.TransactionSkeleton({
    cellProvider: indexer,
  });

  // Get ClusterProxy cell
  const clusterProxyCell = await getClusterProxyByOutPoint(props.outPoint, config);
  const clusterProxyScript = getSporeScript(config, 'ClusterProxy', clusterProxyCell.cellOutput.type!);

  // Inject live spore to Transaction.inputs
  const injectLiveClusterProxyCellResult = await injectLiveClusterProxyCell({
    txSkeleton,
    cell: clusterProxyCell,
    updateWitness: props.updateWitness,
    config,
  });
  txSkeleton = injectLiveClusterProxyCellResult.txSkeleton;

  // Inject CobuildProof
  if (clusterProxyScript.behaviors?.cobuild) {
    const actionResult = generateMeltClusterProxyAction({
      txSkeleton,
      inputIndex: injectLiveClusterProxyCellResult.inputIndex,
    });
    const injectCobuildProofResult = injectCommonCobuildProof({
      txSkeleton,
      actions: actionResult.actions,
    });
    txSkeleton = injectCobuildProofResult.txSkeleton;
  }

  // Redeem occupied capacity from the melted cell
  const targetCellAddress = helpers.encodeToAddress(clusterProxyCell.cellOutput.lock, { config: config.lumos });
  const returnExceededCapacityAndPayFeeResult = await returnExceededCapacityAndPayFee({
    changeAddress: props.changeAddress ?? targetCellAddress,
    txSkeleton,
    config,
  });
  txSkeleton = returnExceededCapacityAndPayFeeResult.txSkeleton;

  return {
    txSkeleton,
    inputIndex: injectLiveClusterProxyCellResult.inputIndex,
  };
}


================================================
File: packages/core/src/api/composed/clusterProxy/transferClusterProxy.ts
================================================
import { BIish } from '@ckb-lumos/bi';
import { FromInfo } from '@ckb-lumos/common-scripts';
import { Address, OutPoint, PackedSince, Script } from '@ckb-lumos/base';
import { BI, Cell, helpers, HexString, Indexer } from '@ckb-lumos/lumos';
import { injectCapacityAndPayFee, payFeeByOutput } from '../../../helpers';
import { getSporeConfig, getSporeScript, SporeConfig } from '../../../config';
import { generateTransferClusterProxyAction, injectCommonCobuildProof } from '../../../cobuild';
import { getClusterProxyByOutPoint } from '../../joints/clusterProxy/getClusterProxy';
import { injectLiveClusterProxyCell } from '../../joints/clusterProxy/injectLiveClusterProxyCell';

export async function transferClusterProxy(props: {
  outPoint: OutPoint;
  toLock: Script;
  fromInfos?: FromInfo[];
  changeAddress?: Address;
  useCapacityMarginAsFee?: boolean;
  updateOutput?: (cell: Cell) => Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  updateWitness?: HexString | ((witness: HexString) => HexString);
  defaultWitness?: HexString;
  since?: PackedSince;
  feeRate?: BIish | undefined;
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
  outputIndex: number;
}> {
  // Env
  const config = props.config ?? getSporeConfig();
  const indexer = new Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);
  const useCapacityMarginAsFee = props.useCapacityMarginAsFee ?? true;

  // Check capacity margin related props
  if (!useCapacityMarginAsFee && !props.fromInfos) {
    throw new Error('When useCapacityMarginAsFee is enabled, fromInfos is also required');
  }
  if (useCapacityMarginAsFee && props.capacityMargin !== void 0) {
    throw new Error('When useCapacityMarginAsFee is enabled, cannot update capacityMargin of the cell');
  }

  // TransactionSkeleton
  let txSkeleton = helpers.TransactionSkeleton({
    cellProvider: indexer,
  });

  // Get target ClusterProxy cell
  const clusterProxyCell = await getClusterProxyByOutPoint(props.outPoint, config);
  const clusterProxyScript = getSporeScript(config, 'ClusterProxy', clusterProxyCell.cellOutput.type!);

  // Inject live ClusterProxy cell to inputs/outputs of the Transaction
  const injectLiveClusterProxyCellResult = await injectLiveClusterProxyCell({
    txSkeleton,
    cell: clusterProxyCell,
    addOutput: true,
    updateOutput(cell) {
      cell.cellOutput.lock = props.toLock;
      if (props.updateOutput instanceof Function) {
        cell = props.updateOutput(cell);
      }
      return cell;
    },
    capacityMargin: props.capacityMargin,
    updateWitness: props.updateWitness,
    defaultWitness: props.defaultWitness,
    since: props.since,
    config,
  });
  txSkeleton = injectLiveClusterProxyCellResult.txSkeleton;

  // Generate TransferClusterProxy actions
  const actionResult = generateTransferClusterProxyAction({
    txSkeleton,
    inputIndex: injectLiveClusterProxyCellResult.inputIndex,
    outputIndex: injectLiveClusterProxyCellResult.outputIndex,
  });

  if (!useCapacityMarginAsFee) {
    // Inject needed capacity from fromInfos and pay fee
    const injectCapacityAndPayFeeResult = await injectCapacityAndPayFee({
      txSkeleton,
      fromInfos: props.fromInfos!,
      changeAddress: props.changeAddress,
      feeRate: props.feeRate,
      updateTxSkeletonAfterCollection(_txSkeleton) {
        // Inject CobuildProof
        if (clusterProxyScript.behaviors?.cobuild) {
          const injectCobuildProofResult = injectCommonCobuildProof({
            txSkeleton: _txSkeleton,
            actions: actionResult.actions,
          });
          _txSkeleton = injectCobuildProofResult.txSkeleton;
        }

        return _txSkeleton;
      },
      config,
    });
    txSkeleton = injectCapacityAndPayFeeResult.txSkeleton;
  } else {
    // Inject CobuildProof
    if (clusterProxyScript.behaviors?.cobuild) {
      const injectCobuildProofResult = injectCommonCobuildProof({
        txSkeleton,
        actions: actionResult.actions,
      });
      txSkeleton = injectCobuildProofResult.txSkeleton;
    }

    // Pay fee by the spore cell's capacity margin
    txSkeleton = await payFeeByOutput({
      outputIndex: injectLiveClusterProxyCellResult.outputIndex,
      feeRate: props.feeRate,
      txSkeleton,
      config,
    });
  }

  return {
    txSkeleton,
    inputIndex: injectLiveClusterProxyCellResult.inputIndex,
    outputIndex: injectLiveClusterProxyCellResult.outputIndex,
  };
}


================================================
File: packages/core/src/api/composed/mutant/createMutant.ts
================================================
import { BIish } from '@ckb-lumos/bi';
import { BytesLike } from '@ckb-lumos/codec';
import { Address, Script } from '@ckb-lumos/base';
import { FromInfo } from '@ckb-lumos/common-scripts';
import { BI, Cell, helpers, Indexer } from '@ckb-lumos/lumos';
import { getSporeConfig, SporeConfig } from '../../../config';
import { assertTransactionSkeletonSize, injectCapacityAndPayFee } from '../../../helpers';
import { injectNewMutantOutput, injectNewMutantIds } from '../..';

export async function createMutant(props: {
  data: BytesLike;
  minPayment?: BIish;
  toLock: Script;
  fromInfos: FromInfo[];
  changeAddress?: Address;
  updateOutput?(cell: Cell): Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  maxTransactionSize?: number | false;
  feeRate?: BIish | undefined;
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  outputIndex: number;
}> {
  // Env
  const config = props.config ?? getSporeConfig();
  const indexer = new Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);
  const capacityMargin = BI.from(props.capacityMargin ?? 1_0000_0000);
  const maxTransactionSize = props.maxTransactionSize ?? config.maxTransactionSize ?? false;

  // TransactionSkeleton
  let txSkeleton = helpers.TransactionSkeleton({
    cellProvider: indexer,
  });

  // Create and inject a new Mutant cell
  const injectNewMutantResult = injectNewMutantOutput({
    txSkeleton,
    data: props.data,
    toLock: props.toLock,
    minPayment: props.minPayment,
    updateOutput: props.updateOutput,
    capacityMargin,
    config,
  });
  txSkeleton = injectNewMutantResult.txSkeleton;

  // Inject needed capacity and pay fee
  const injectCapacityAndPayFeeResult = await injectCapacityAndPayFee({
    txSkeleton,
    fromInfos: props.fromInfos,
    changeAddress: props.changeAddress,
    feeRate: props.feeRate,
    config,
  });
  txSkeleton = injectCapacityAndPayFeeResult.txSkeleton;

  // Generate and inject ID for the new Mutant
  txSkeleton = injectNewMutantIds({
    outputIndices: [injectNewMutantResult.outputIndex],
    txSkeleton,
    config,
  });

  // Make sure the tx size is in range (if needed)
  if (typeof maxTransactionSize === 'number') {
    assertTransactionSkeletonSize(txSkeleton, void 0, maxTransactionSize);
  }

  return {
    txSkeleton,
    outputIndex: injectNewMutantResult.outputIndex,
  };
}


================================================
File: packages/core/src/api/composed/mutant/transferMutant.ts
================================================
import { BIish } from '@ckb-lumos/bi';
import { FromInfo } from '@ckb-lumos/common-scripts';
import { Address, OutPoint, PackedSince, Script } from '@ckb-lumos/base';
import { BI, Cell, helpers, HexString, Indexer } from '@ckb-lumos/lumos';
import { getSporeConfig, SporeConfig } from '../../../config';
import { injectCapacityAndPayFee, payFeeByOutput } from '../../../helpers';
import { getMutantByOutPoint, injectLiveMutantCell } from '../..';

export async function transferMutant(props: {
  outPoint: OutPoint;
  toLock: Script;
  minPayment?: BIish;
  fromInfos?: FromInfo[];
  changeAddress?: Address;
  useCapacityMarginAsFee?: boolean;
  updateOutput?: (cell: Cell) => Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  updateWitness?: HexString | ((witness: HexString) => HexString);
  defaultWitness?: HexString;
  since?: PackedSince;
  feeRate?: BIish | undefined;
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
  outputIndex: number;
}> {
  // Env
  const config = props.config ?? getSporeConfig();
  const indexer = new Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);
  const useCapacityMarginAsFee = props.useCapacityMarginAsFee ?? true;

  // Check capacity margin related props
  if (!useCapacityMarginAsFee && !props.fromInfos?.length) {
    throw new Error('When useCapacityMarginAsFee is enabled, fromInfos is also required');
  }
  if (useCapacityMarginAsFee && props.capacityMargin !== void 0) {
    throw new Error('When useCapacityMarginAsFee is enabled, cannot set capacityMargin of the cell');
  }

  // TransactionSkeleton
  let txSkeleton = helpers.TransactionSkeleton({
    cellProvider: indexer,
  });

  // Find Mutant by OutPoint
  const mutantCell = await getMutantByOutPoint(props.outPoint, config);

  // Add Mutant to inputs and outputs of the Transaction
  const injectLiveMutantCellResult = await injectLiveMutantCell({
    txSkeleton,
    cell: mutantCell,
    addOutput: true,
    updateOutput(cell) {
      cell.cellOutput.lock = props.toLock;
      if (props.updateOutput instanceof Function) {
        cell = props.updateOutput(cell);
      }
      return cell;
    },
    minPayment: props.minPayment,
    capacityMargin: props.capacityMargin,
    defaultWitness: props.defaultWitness,
    updateWitness: props.updateWitness,
    since: props.since,
    config,
  });
  txSkeleton = injectLiveMutantCellResult.txSkeleton;

  if (!useCapacityMarginAsFee) {
    // Inject needed capacity and pay fee
    const injectCapacityAndPayFeeResult = await injectCapacityAndPayFee({
      txSkeleton,
      changeAddress: props.changeAddress,
      fromInfos: props.fromInfos!,
      feeRate: props.feeRate,
      config,
    });
    txSkeleton = injectCapacityAndPayFeeResult.txSkeleton;
  } else {
    // Pay fee by the target cell's capacity margin
    txSkeleton = await payFeeByOutput({
      outputIndex: injectLiveMutantCellResult.outputIndex,
      feeRate: props.feeRate,
      txSkeleton,
      config,
    });
  }

  return {
    txSkeleton,
    inputIndex: injectLiveMutantCellResult.inputIndex,
    outputIndex: injectLiveMutantCellResult.outputIndex,
  };
}


================================================
File: packages/core/src/api/composed/spore/createSpore.ts
================================================
import { BIish } from '@ckb-lumos/bi';
import { Address, Script } from '@ckb-lumos/base';
import { FromInfo, parseFromInfo } from '@ckb-lumos/lumos/common-scripts';
import { BI, Indexer, helpers, Cell, HexString, OutPoint } from '@ckb-lumos/lumos';
import { getSporeConfig, getSporeScript, SporeConfig } from '../../../config';
import {
  assertTransactionSkeletonSize,
  createCapacitySnapshotFromTransactionSkeleton,
  injectCapacityAndPayFee,
  returnExceededCapacityAndPayFee,
  setupCell,
} from '../../../helpers';
import { injectNewSporeOutput, injectNewSporeIds, SporeDataProps, getClusterAgentByOutPoint } from '../..';
import { generateCreateSporeAction } from '../../../cobuild/action/spore/createSpore';
import { injectCommonCobuildProof } from '../../../cobuild/base/witnessLayout';
import { encodeToAddress } from '@ckb-lumos/lumos/helpers';
import _ from 'lodash';

export async function createSpore(props: {
  data: SporeDataProps;
  toLock: Script;
  fromInfos: FromInfo[];
  prefixInputs?: Cell[];
  prefixOutputs?: Cell[];
  updateWitness?: HexString | ((witness: HexString) => HexString);
  defaultWitness?: HexString;
  changeAddress?: Address;
  updateOutput?: (cell: Cell) => Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  cluster?: {
    updateOutput?: (cell: Cell) => Cell;
    capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
    updateWitness?: HexString | ((witness: HexString) => HexString);
  };
  clusterAgentOutPoint?: OutPoint;
  clusterAgent?: {
    updateOutput?: (cell: Cell) => Cell;
    capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
    updateWitness?: HexString | ((witness: HexString) => HexString);
  };
  mutant?: {
    paymentAmount?: (minPayment: BI, lock: Script, cell: Cell) => BIish;
  };
  skipCheckContentType?: boolean;
  maxTransactionSize?: number | false;
  feeRate?: BIish | undefined;
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  outputIndex: number;
  reference: Awaited<ReturnType<typeof injectNewSporeOutput>>['reference'];
  mutantReference: Awaited<ReturnType<typeof injectNewSporeOutput>>['mutantReference'];
}> {
  // Env
  const config = props.config ?? getSporeConfig();
  const indexer = new Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);
  const capacityMargin = BI.from(props.capacityMargin ?? 1_0000_0000);
  const maxTransactionSize = props.maxTransactionSize ?? config.maxTransactionSize ?? false;

  // TransactionSkeleton
  let txSkeleton = helpers.TransactionSkeleton({
    cellProvider: indexer,
  });

  // Insert input cells in advance for particular purpose
  if (props.prefixInputs) {
    for (const cell of props.prefixInputs!) {
      const address = encodeToAddress(cell.cellOutput.lock, { config: config.lumos });
      const customScript = {
        script: cell.cellOutput.lock,
      };
      const customScriptExists = props.fromInfos.some((fromInfo) => {
        const parsedInfo = parseFromInfo(fromInfo, { config: config.lumos });
        return _.isEqual(customScript, parsedInfo.fromScript);
      });
      if (!customScriptExists) {
        props.fromInfos.push(address);
      }
      const setupCellResult = await setupCell({
        txSkeleton,
        input: cell,
        updateWitness: props.updateWitness,
        defaultWitness: props.defaultWitness,
        config: config.lumos,
      });
      txSkeleton = setupCellResult.txSkeleton;
    }
  }

  // Insert output cells in advance for particular purpose
  if (props.prefixOutputs) {
    txSkeleton.update('outputs', (outputs) => {
      props.prefixOutputs!.forEach((cell) => outputs.push(cell));
      return outputs;
    });
  }

  // If referencing a ClusterAgent, get it from the OutPoint
  let clusterAgentCell: Cell | undefined;
  if (props.clusterAgentOutPoint) {
    clusterAgentCell = await getClusterAgentByOutPoint(props.clusterAgentOutPoint, config);
  }

  // Create and inject a new spore cell, also inject cluster if exists
  const injectNewSporeResult = await injectNewSporeOutput({
    txSkeleton,
    data: props.data,
    toLock: props.toLock,
    fromInfos: props.fromInfos,
    extraOutputLocks: props.prefixOutputs?.map((cell) => cell.cellOutput.lock),
    changeAddress: props.changeAddress,
    updateOutput: props.updateOutput,
    clusterAgent: props.clusterAgent,
    cluster: props.cluster,
    mutant: props.mutant,
    skipCheckContentType: props.skipCheckContentType,
    clusterAgentCell,
    capacityMargin,
    config,
  });
  txSkeleton = injectNewSporeResult.txSkeleton;

  const snapshot = createCapacitySnapshotFromTransactionSkeleton(txSkeleton);
  if (snapshot.inputsCapacity.gt(snapshot.outputsCapacity)) {
    // Generate new Spore Id
    txSkeleton = injectNewSporeIds({
      outputIndices: [injectNewSporeResult.outputIndex],
      txSkeleton,
      config,
    });

    // Inject CobuildProof
    const sporeCell = txSkeleton.get('outputs').get(injectNewSporeResult.outputIndex)!;
    const sporeScript = getSporeScript(config, 'Spore', sporeCell.cellOutput.type!);
    if (sporeScript.behaviors?.cobuild) {
      const actionResult = generateCreateSporeAction({
        txSkeleton,
        reference: injectNewSporeResult.reference,
        outputIndex: injectNewSporeResult.outputIndex,
      });
      const injectCobuildProofResult = injectCommonCobuildProof({
        txSkeleton,
        actions: actionResult.actions,
      });
      txSkeleton = injectCobuildProofResult.txSkeleton;
    }

    // Redeem extra capacity
    const sporeAddress = helpers.encodeToAddress(sporeCell.cellOutput.lock, { config: config.lumos });
    const returnExceededCapacityAndPayFeeResult = await returnExceededCapacityAndPayFee({
      txSkeleton,
      changeAddress: props.changeAddress ?? sporeAddress,
      feeRate: props.feeRate,
      fromInfos: props.fromInfos,
      config,
    });
    txSkeleton = returnExceededCapacityAndPayFeeResult.txSkeleton;
  } else {
    // Inject needed capacity and pay fee
    const injectCapacityAndPayFeeResult = await injectCapacityAndPayFee({
      txSkeleton,
      fromInfos: props.fromInfos,
      changeAddress: props.changeAddress,
      feeRate: props.feeRate,
      updateTxSkeletonAfterCollection(_txSkeleton) {
        // Generate and inject SporeID
        _txSkeleton = injectNewSporeIds({
          outputIndices: [injectNewSporeResult.outputIndex],
          txSkeleton: _txSkeleton,
          config,
        });

        // Inject CobuildProof
        const sporeCell = txSkeleton.get('outputs').get(injectNewSporeResult.outputIndex)!;
        const sporeScript = getSporeScript(config, 'Spore', sporeCell.cellOutput.type!);
        if (sporeScript.behaviors?.cobuild) {
          const actionResult = generateCreateSporeAction({
            txSkeleton: _txSkeleton,
            reference: injectNewSporeResult.reference,
            outputIndex: injectNewSporeResult.outputIndex,
          });
          const injectCobuildProofResult = injectCommonCobuildProof({
            txSkeleton: _txSkeleton,
            actions: actionResult.actions,
          });
          _txSkeleton = injectCobuildProofResult.txSkeleton;
        }

        return _txSkeleton;
      },
      config,
    });
    txSkeleton = injectCapacityAndPayFeeResult.txSkeleton;
  }

  // Make sure the tx size is in range (if needed)
  if (typeof maxTransactionSize === 'number') {
    assertTransactionSkeletonSize(txSkeleton, void 0, maxTransactionSize);
  }

  return {
    txSkeleton,
    outputIndex: injectNewSporeResult.outputIndex,
    reference: injectNewSporeResult.reference,
    mutantReference: injectNewSporeResult.mutantReference,
  };
}

export async function createMultipleSpores(props: {
  sporeInfos: {
    data: SporeDataProps;
    toLock: Script;
  }[];
  fromInfos: FromInfo[];
  fromCells?: Cell[];
  changeAddress?: Address;
  updateOutput?: (cell: Cell) => Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  cluster?: {
    updateOutput?: (cell: Cell) => Cell;
    capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
    updateWitness?: HexString | ((witness: HexString) => HexString);
  };
  clusterAgentOutPoint?: OutPoint;
  clusterAgent?: {
    updateOutput?: (cell: Cell) => Cell;
    capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
    updateWitness?: HexString | ((witness: HexString) => HexString);
  };
  mutant?: {
    paymentAmount?: (minPayment: BI, lock: Script, cell: Cell) => BIish;
  };
  maxTransactionSize?: number | false;
  feeRate?: BIish | undefined;
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  outputIndices: number[];
}> {
  // Env
  const config = props.config ?? getSporeConfig();
  const indexer = new Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);
  const capacityMargin = BI.from(props.capacityMargin ?? 1_0000_0000);

  // TransactionSkeleton
  let txSkeleton = helpers.TransactionSkeleton({
    cellProvider: indexer,
  });

  // Insert input cells in advance for particular purpose
  if (props.fromCells) {
    txSkeleton.update('inputs', (inputs) => {
      for (const cell of props.fromCells!) {
        const address = encodeToAddress(cell.cellOutput.lock, { config: config.lumos });
        const customScript = {
          script: cell.cellOutput.lock,
        };
        const customScriptExists = props.fromInfos.some((fromInfo) => {
          const parsedInfo = parseFromInfo(fromInfo, { config: config.lumos });
          return _.isEqual(customScript, parsedInfo.fromScript);
        });
        if (!customScriptExists) {
          props.fromInfos.push(address);
        }
        inputs = inputs.push(cell);
      }
      return inputs;
    });
  }

  // If referencing a ClusterAgent, get it from the OutPoint
  let clusterAgentCell: Cell | undefined;
  if (props.clusterAgentOutPoint) {
    clusterAgentCell = await getClusterAgentByOutPoint(props.clusterAgentOutPoint, config);
  }

  // Create and inject Spores to Transaction.outputs
  const injectNewSporeResults: Awaited<ReturnType<typeof injectNewSporeOutput>>[] = [];
  for (const sporeInfo of props.sporeInfos) {
    const result = await injectNewSporeOutput({
      txSkeleton,
      data: sporeInfo.data,
      toLock: sporeInfo.toLock,
      fromInfos: props.fromInfos,
      changeAddress: props.changeAddress,
      updateOutput: props.updateOutput,
      clusterAgent: props.clusterAgent,
      cluster: props.cluster,
      mutant: props.mutant,
      clusterAgentCell,
      capacityMargin,
      config,
    });

    txSkeleton = result.txSkeleton;
    injectNewSporeResults.push(result);
  }

  // Inject needed capacity and pay fee
  const sporeOutputIndices = injectNewSporeResults.map((r) => r.outputIndex);
  const injectCapacityAndPayFeeResult = await injectCapacityAndPayFee({
    txSkeleton,
    fromInfos: props.fromInfos,
    changeAddress: props.changeAddress,
    feeRate: props.feeRate,
    updateTxSkeletonAfterCollection(_txSkeleton) {
      // Generate and inject SporeID
      _txSkeleton = injectNewSporeIds({
        txSkeleton: _txSkeleton,
        outputIndices: sporeOutputIndices,
        config,
      });

      // Inject CobuildProof
      const actions = [];
      for (const injectNewSporeResult of injectNewSporeResults) {
        const sporeCell = txSkeleton.get('outputs').get(injectNewSporeResult.outputIndex)!;
        const sporeScript = getSporeScript(config, 'Spore', sporeCell.cellOutput.type!);
        if (sporeScript.behaviors?.cobuild) {
          const actionResult = generateCreateSporeAction({
            txSkeleton: _txSkeleton,
            reference: injectNewSporeResult.reference,
            outputIndex: injectNewSporeResult.outputIndex,
          });
          actions.push(...actionResult.actions);
        }
      }
      if (actions.length) {
        const injectCobuildProofResult = injectCommonCobuildProof({
          txSkeleton: _txSkeleton,
          actions,
        });
        _txSkeleton = injectCobuildProofResult.txSkeleton;
      }

      return _txSkeleton;
    },
    config,
  });
  txSkeleton = injectCapacityAndPayFeeResult.txSkeleton;

  return {
    txSkeleton,
    outputIndices: sporeOutputIndices,
  };
}


================================================
File: packages/core/src/api/composed/spore/meltSpore.ts
================================================
import { BIish } from '@ckb-lumos/bi';
import { Address, OutPoint } from '@ckb-lumos/base';
import { Indexer, helpers, HexString, PackedSince } from '@ckb-lumos/lumos';
import { returnExceededCapacityAndPayFee } from '../../../helpers';
import { getSporeConfig, getSporeScript, SporeConfig } from '../../../config';
import { getSporeByOutPoint, injectLiveSporeCell } from '../..';
import { generateMeltSporeAction, injectCommonCobuildProof } from '../../../cobuild';

export async function meltSpore(props: {
  outPoint: OutPoint;
  changeAddress?: Address;
  updateWitness?: HexString | ((witness: HexString) => HexString);
  defaultWitness?: HexString;
  since?: PackedSince;
  config?: SporeConfig;
  feeRate?: BIish | undefined;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
}> {
  // Env
  const config = props.config ?? getSporeConfig();
  const indexer = new Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);

  // TransactionSkeleton
  let txSkeleton = helpers.TransactionSkeleton({
    cellProvider: indexer,
  });

  // Inject live spore to Transaction.inputs
  const sporeCell = await getSporeByOutPoint(props.outPoint, config);
  const injectLiveSporeCellResult = await injectLiveSporeCell({
    txSkeleton,
    cell: sporeCell,
    updateWitness: props.updateWitness,
    defaultWitness: props.defaultWitness,
    since: props.since,
    config,
  });
  txSkeleton = injectLiveSporeCellResult.txSkeleton;

  // Inject CobuildProof
  const sporeScript = getSporeScript(config, 'Spore', sporeCell.cellOutput.type!);
  if (sporeScript.behaviors?.cobuild) {
    const actionResult = generateMeltSporeAction({
      txSkeleton: txSkeleton,
      inputIndex: injectLiveSporeCellResult.inputIndex,
    });
    const injectCobuildProofResult = injectCommonCobuildProof({
      txSkeleton: txSkeleton,
      actions: actionResult.actions,
    });
    txSkeleton = injectCobuildProofResult.txSkeleton;
  }

  // Redeem capacity from the melted spore
  const sporeAddress = helpers.encodeToAddress(sporeCell.cellOutput.lock, { config: config.lumos });
  const returnExceededCapacityAndPayFeeResult = await returnExceededCapacityAndPayFee({
    changeAddress: props.changeAddress ?? sporeAddress,
    txSkeleton,
    config,
    feeRate: props.feeRate,
  });
  txSkeleton = returnExceededCapacityAndPayFeeResult.txSkeleton;

  return {
    txSkeleton,
    inputIndex: injectLiveSporeCellResult.inputIndex,
  };
}


================================================
File: packages/core/src/api/composed/spore/meltThenCreateSpore.ts
================================================
import { Address, OutPoint, PackedSince, Script } from '@ckb-lumos/base';
import { FromInfo } from '@ckb-lumos/common-scripts';
import { BI, BIish, Cell, helpers, HexString, Indexer } from '@ckb-lumos/lumos';
import { encodeToAddress, TransactionSkeletonType } from '@ckb-lumos/lumos/helpers';
import { parseUnit } from '@ckb-lumos/lumos/utils';
import {
  getClusterAgentByOutPoint,
  getSporeByOutPoint,
  injectLiveSporeCell,
  injectNewSporeIds,
  injectNewSporeOutput,
  SporeDataProps,
} from '../..';
import { generateCreateSporeAction, generateMeltSporeAction, injectCommonCobuildProof } from '../../../cobuild';
import { getSporeConfig, getSporeScript, SporeConfig } from '../../../config';
import {
  assertTransactionSkeletonSize,
  createCapacitySnapshotFromTransactionSkeleton,
  getMinFeeRate,
  injectCapacityAndPayFee,
  returnExceededCapacityAndPayFee,
  setupCell,
} from '../../../helpers';

function InjectCobuildForMeltThenCreateSpore(
  meltSporeInputIndexs: number[],
  mintSporeCell: Cell,
  mintSporeReference: Awaited<ReturnType<typeof injectNewSporeOutput>>['reference'],
  mintSporeOutputIndex: number,
  txSkeleton: TransactionSkeletonType,
  config: SporeConfig,
): TransactionSkeletonType {
  const sporeScript = getSporeScript(config, 'Spore', mintSporeCell.cellOutput.type!);
  if (sporeScript.behaviors?.cobuild) {
    const actions = [];
    for (const meltIndex of meltSporeInputIndexs) {
      const meltActionResults = generateMeltSporeAction({ txSkeleton, inputIndex: meltIndex });
      actions.push(...meltActionResults.actions);
    }
    const mintActionResult = generateCreateSporeAction({
      txSkeleton,
      reference: mintSporeReference,
      outputIndex: mintSporeOutputIndex,
    });
    actions.push(...mintActionResult.actions);
    const injectCobuildProofResult = injectCommonCobuildProof({
      txSkeleton,
      actions,
    });
    txSkeleton = injectCobuildProofResult.txSkeleton;
  }
  return txSkeleton;
}

export async function meltThenCreateSpore(props: {
  outPoint: OutPoint;
  changeAddress?: Address;
  updateWitness?: HexString | ((witness: HexString) => HexString);
  defaultWitness?: HexString;
  since?: PackedSince;
  config?: SporeConfig;
  data: SporeDataProps;
  toLock: Script;
  fromInfos: FromInfo[];
  prefixInputs?: Cell[];
  prefixOutputs?: Cell[];
  postInputs?: Cell[];
  postOutputs?: Cell[];
  feeRate?: BIish | undefined;
  updateOutput?: (cell: Cell) => Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  cluster?: {
    updateOutput?: (cell: Cell) => Cell;
    capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
    updateWitness?: HexString | ((witness: HexString) => HexString);
  };
  clusterAgentOutPoint?: OutPoint;
  clusterAgent?: {
    updateOutput?: (cell: Cell) => Cell;
    capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
    updateWitness?: HexString | ((witness: HexString) => HexString);
  };
  mutant?: {
    paymentAmount?: (minPayment: BI, lock: Script, cell: Cell) => BIish;
  };
  maxTransactionSize?: number | false;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
  outputIndex: number;
  reference: Awaited<ReturnType<typeof injectNewSporeOutput>>['reference'];
  mutantReference: Awaited<ReturnType<typeof injectNewSporeOutput>>['mutantReference'];
}> {
  /**
   * Melt Spore with Spore Outputpoint
   */

  // Env
  const config = props.config ?? getSporeConfig();
  const indexer = new Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);
  const capacityMargin = BI.from(props.capacityMargin ?? 1_0000_0000);
  const maxTransactionSize = props.maxTransactionSize ?? config.maxTransactionSize ?? false;

  // MeltTransactionSkeleton
  let txSkeleton = helpers.TransactionSkeleton({
    cellProvider: indexer,
  });

  // Insert input cells in advance for particular purpose
  if (props.prefixInputs) {
    for (const cell of props.prefixInputs!) {
      const address = encodeToAddress(cell.cellOutput.lock, { config: config.lumos });
      const customScript = {
        script: cell.cellOutput.lock,
        customData: cell.data,
      };
      if (props.fromInfos.indexOf(address) < 0 && props.fromInfos.indexOf(customScript) < 0) {
        props.fromInfos.push(address);
      }
      const setupCellResult = await setupCell({
        txSkeleton,
        input: cell,
        updateWitness: props.updateWitness,
        defaultWitness: props.defaultWitness,
        config: config.lumos,
      });
      txSkeleton = setupCellResult.txSkeleton;
    }
  }

  // Insert output cells in advance for particular purpose
  if (props.prefixOutputs) {
    txSkeleton = txSkeleton.update('outputs', (outputs) => {
      props.prefixOutputs!.forEach((cell) => (outputs = outputs.push(cell)));
      return outputs;
    });
  }

  // Apply `fromInfos` in advance if `postInputs` is provided
  if (props.postInputs) {
    for (const cell of props.postInputs!) {
      const address = encodeToAddress(cell.cellOutput.lock, { config: config.lumos });
      const customScript = {
        script: cell.cellOutput.lock,
        customData: cell.data,
      };
      if (props.fromInfos.indexOf(address) < 0 && props.fromInfos.indexOf(customScript) < 0) {
        props.fromInfos.push(address);
      }
    }
  }

  // Inject live spore to Transaction.inputs
  const meltSporeCell = await getSporeByOutPoint(props.outPoint, config);
  const injectLiveSporeCellResult = await injectLiveSporeCell({
    txSkeleton,
    cell: meltSporeCell,
    updateWitness: props.updateWitness,
    defaultWitness: props.defaultWitness,
    since: props.since,
    config,
  });
  txSkeleton = injectLiveSporeCellResult.txSkeleton;

  /**
   * Create Spore
   */

  // If referencing a ClusterAgent, get it from the OutPoint
  let clusterAgentCell: Cell | undefined;
  if (props.clusterAgentOutPoint) {
    clusterAgentCell = await getClusterAgentByOutPoint(props.clusterAgentOutPoint, config);
  }

  const prefixOutputLocks = props.prefixOutputs ? props.prefixOutputs.map((cell) => cell.cellOutput.lock) : [];
  const postOutputLocks = props.postOutputs ? props.postOutputs.map((cell) => cell.cellOutput.lock) : [];
  const injectNewSporeResult = await injectNewSporeOutput({
    txSkeleton,
    data: props.data,
    toLock: props.toLock,
    fromInfos: props.fromInfos,
    extraOutputLocks: prefixOutputLocks.concat(postOutputLocks),
    changeAddress: props.changeAddress,
    updateOutput: props.updateOutput,
    clusterAgent: props.clusterAgent,
    cluster: props.cluster,
    mutant: props.mutant,
    clusterAgentCell,
    capacityMargin,
    config,
  });
  txSkeleton = injectNewSporeResult.txSkeleton;

  // Insert input cells in the end for particular purpose
  if (props.postInputs) {
    for (const cell of props.postInputs!) {
      const setupCellResult = await setupCell({
        txSkeleton,
        input: cell,
        updateWitness: props.updateWitness,
        defaultWitness: props.defaultWitness,
        config: config.lumos,
      });
      txSkeleton = setupCellResult.txSkeleton;
    }
  }

  // Insert output cells in the end for particular purpose
  if (props.postOutputs) {
    txSkeleton = txSkeleton.update('outputs', (outputs) => {
      props.postOutputs!.forEach((cell) => (outputs = outputs.push(cell)));
      return outputs;
    });
  }

  /**
   * check wether Redeem or Inject Capacity and then Pay fee
   */
  const snapshot = createCapacitySnapshotFromTransactionSkeleton(txSkeleton);
  if (snapshot.inputsCapacity.gt(snapshot.outputsCapacity)) {
    /**
     * Complete Co-Build WitnessLayout
     */
    txSkeleton = injectNewSporeIds({
      outputIndices: [injectNewSporeResult.outputIndex],
      txSkeleton,
      config,
    });
    const mintSporeCell = txSkeleton.get('outputs').get(injectNewSporeResult.outputIndex)!;
    txSkeleton = InjectCobuildForMeltThenCreateSpore(
      [injectLiveSporeCellResult.inputIndex],
      mintSporeCell,
      injectNewSporeResult.reference,
      injectNewSporeResult.outputIndex,
      txSkeleton,
      config,
    );

    // Redeem capacity from the exceeded capacity
    const sporeAddress = helpers.encodeToAddress(mintSporeCell.cellOutput.lock, { config: config.lumos });
    const returnExceededCapacityAndPayFeeResult = await returnExceededCapacityAndPayFee({
      txSkeleton,
      changeAddress: props.changeAddress ?? sporeAddress,
      feeRate: props.feeRate,
      fromInfos: props.fromInfos,
      config,
    });
    txSkeleton = returnExceededCapacityAndPayFeeResult.txSkeleton;
  } else {
    /**
     * Inject Capacity and Pay fee
     */
    const injectCapacityAndPayFeeResult = await injectCapacityAndPayFee({
      txSkeleton,
      fromInfos: props.fromInfos,
      changeAddress: props.changeAddress,
      config,
      feeRate: props.feeRate,
      updateTxSkeletonAfterCollection(_txSkeleton) {
        // Generate and inject SporeID
        _txSkeleton = injectNewSporeIds({
          outputIndices: [injectNewSporeResult.outputIndex],
          txSkeleton: _txSkeleton,
          config,
        });

        /**
         * Complete Co-Build WitnessLayout
         */

        const mintSporeCell = txSkeleton.get('outputs').get(injectNewSporeResult.outputIndex)!;
        _txSkeleton = InjectCobuildForMeltThenCreateSpore(
          [injectLiveSporeCellResult.inputIndex],
          mintSporeCell,
          injectNewSporeResult.reference,
          injectNewSporeResult.outputIndex,
          _txSkeleton,
          config,
        );

        return _txSkeleton;
      },
    });
    txSkeleton = injectCapacityAndPayFeeResult.txSkeleton;
  }

  // Make sure the tx size is in range (if needed)
  if (typeof maxTransactionSize === 'number') {
    assertTransactionSkeletonSize(txSkeleton, void 0, maxTransactionSize);
  }

  return {
    txSkeleton,
    inputIndex: injectLiveSporeCellResult.inputIndex,
    outputIndex: injectNewSporeResult.outputIndex,
    reference: injectNewSporeResult.reference,
    mutantReference: injectNewSporeResult.mutantReference,
  };
}

export async function meltMultipleThenCreateSpore(props: {
  outPoints: OutPoint[];
  changeAddress?: Address;
  updateWitness?: HexString | ((witness: HexString) => HexString);
  defaultWitness?: HexString;
  since?: PackedSince;
  config?: SporeConfig;
  data: SporeDataProps;
  toLock: Script;
  fromInfos: FromInfo[];
  prefixInputs?: Cell[];
  prefixOutputs?: Cell[];
  postInputs?: Cell[];
  postOutputs?: Cell[];
  feeRate?: BIish | undefined;
  updateOutput?: (cell: Cell) => Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  cluster?: {
    updateOutput?: (cell: Cell) => Cell;
    capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
    updateWitness?: HexString | ((witness: HexString) => HexString);
  };
  clusterAgentOutPoint?: OutPoint;
  clusterAgent?: {
    updateOutput?: (cell: Cell) => Cell;
    capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
    updateWitness?: HexString | ((witness: HexString) => HexString);
  };
  mutant?: {
    paymentAmount?: (minPayment: BI, lock: Script, cell: Cell) => BIish;
  };
  maxTransactionSize?: number | false;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndexs: number[];
  outputIndex: number;
  reference: Awaited<ReturnType<typeof injectNewSporeOutput>>['reference'];
  mutantReference: Awaited<ReturnType<typeof injectNewSporeOutput>>['mutantReference'];
}> {
  /**
   * Melt Spore with Spore Outputpoint
   */

  // Env
  const config = props.config ?? getSporeConfig();
  const indexer = new Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);
  const capacityMargin = BI.from(props.capacityMargin ?? 1_0000_0000);
  const maxTransactionSize = props.maxTransactionSize ?? config.maxTransactionSize ?? false;

  // MeltTransactionSkeleton
  let txSkeleton = helpers.TransactionSkeleton({
    cellProvider: indexer,
  });

  // Insert input cells in advance for particular purpose
  if (props.prefixInputs) {
    for (const cell of props.prefixInputs!) {
      const address = encodeToAddress(cell.cellOutput.lock, { config: config.lumos });
      const customScript = {
        script: cell.cellOutput.lock,
        customData: cell.data,
      };
      if (props.fromInfos.indexOf(address) < 0 && props.fromInfos.indexOf(customScript) < 0) {
        props.fromInfos.push(address);
      }
      const setupCellResult = await setupCell({
        txSkeleton,
        input: cell,
        updateWitness: props.updateWitness,
        defaultWitness: props.defaultWitness,
        config: config.lumos,
      });
      txSkeleton = setupCellResult.txSkeleton;
    }
  }

  // Insert output cells in advance for particular purpose
  if (props.prefixOutputs) {
    txSkeleton = txSkeleton.update('outputs', (outputs) => {
      props.prefixOutputs!.forEach((cell) => (outputs = outputs.push(cell)));
      return outputs;
    });
  }

  // Apply `fromInfos` in advance if `postInputs` is provided
  if (props.postInputs) {
    for (const cell of props.postInputs!) {
      const address = encodeToAddress(cell.cellOutput.lock, { config: config.lumos });
      const customScript = {
        script: cell.cellOutput.lock,
        customData: cell.data,
      };
      if (props.fromInfos.indexOf(address) < 0 && props.fromInfos.indexOf(customScript) < 0) {
        props.fromInfos.push(address);
      }
    }
  }

  // Inject live spore to Transaction.inputs
  let injectLiveSporeCellResults: {
    txSkeleton: helpers.TransactionSkeletonType;
    inputIndex: number;
    outputIndex: number;
  }[] = [];
  for (const outPoint of props.outPoints) {
    const meltSporeCell = await getSporeByOutPoint(outPoint, config);
    const injectLiveSporeCellResult = await injectLiveSporeCell({
      txSkeleton,
      cell: meltSporeCell,
      updateWitness: props.updateWitness,
      defaultWitness: props.defaultWitness,
      since: props.since,
      config,
    });
    injectLiveSporeCellResults.push(injectLiveSporeCellResult);
    txSkeleton = injectLiveSporeCellResult.txSkeleton;
  }
  /**
   * Create Spore
   */

  // If referencing a ClusterAgent, get it from the OutPoint
  let clusterAgentCell: Cell | undefined;
  if (props.clusterAgentOutPoint) {
    clusterAgentCell = await getClusterAgentByOutPoint(props.clusterAgentOutPoint, config);
  }

  const prefixOutputLocks = props.prefixOutputs ? props.prefixOutputs.map((cell) => cell.cellOutput.lock) : [];
  const postOutputLocks = props.postOutputs ? props.postOutputs.map((cell) => cell.cellOutput.lock) : [];
  const injectNewSporeResult = await injectNewSporeOutput({
    txSkeleton,
    data: props.data,
    toLock: props.toLock,
    fromInfos: props.fromInfos,
    extraOutputLocks: prefixOutputLocks.concat(postOutputLocks),
    changeAddress: props.changeAddress,
    updateOutput: props.updateOutput,
    clusterAgent: props.clusterAgent,
    cluster: props.cluster,
    mutant: props.mutant,
    clusterAgentCell,
    capacityMargin,
    config,
  });
  txSkeleton = injectNewSporeResult.txSkeleton;

  // Insert input cells in the end for particular purpose
  if (props.postInputs) {
    for (const cell of props.postInputs!) {
      const setupCellResult = await setupCell({
        txSkeleton,
        input: cell,
        updateWitness: props.updateWitness,
        defaultWitness: props.defaultWitness,
        config: config.lumos,
      });
      txSkeleton = setupCellResult.txSkeleton;
    }
  }

  // Insert output cells in the end for particular purpose
  if (props.postOutputs) {
    txSkeleton = txSkeleton.update('outputs', (outputs) => {
      props.postOutputs!.forEach((cell) => (outputs = outputs.push(cell)));
      return outputs;
    });
  }

  /**
   * check wether Redeem or Inject Capacity and then Pay fee
   */
  const snapshot = createCapacitySnapshotFromTransactionSkeleton(txSkeleton);
  const feeRate = props.feeRate ?? (await getMinFeeRate(config.ckbNodeUrl));
  if (
    snapshot.inputsCapacity.gt(snapshot.outputsCapacity) &&
    snapshot.inputsCapacity.sub(snapshot.outputsCapacity).gt(parseUnit(feeRate.toString(), 'ckb'))
  ) {
    /**
     * Complete Co-Build WitnessLayout
     */
    txSkeleton = injectNewSporeIds({
      outputIndices: [injectNewSporeResult.outputIndex],
      txSkeleton,
      config,
    });
    const mintSporeCell = txSkeleton.get('outputs').get(injectNewSporeResult.outputIndex)!;

    // Redeem capacity from the exceeded capacity
    const sporeAddress = helpers.encodeToAddress(mintSporeCell.cellOutput.lock, { config: config.lumos });
    const returnExceededCapacityAndPayFeeResult = await returnExceededCapacityAndPayFee({
      txSkeleton,
      changeAddress: props.changeAddress ?? sporeAddress,
      feeRate: props.feeRate,
      fromInfos: props.fromInfos,
      config,
    });

    txSkeleton = returnExceededCapacityAndPayFeeResult.txSkeleton;
    txSkeleton = InjectCobuildForMeltThenCreateSpore(
      injectLiveSporeCellResults.map((result) => result.inputIndex),
      mintSporeCell,
      injectNewSporeResult.reference,
      injectNewSporeResult.outputIndex,
      returnExceededCapacityAndPayFeeResult.txSkeleton,
      config,
    );
  } else {
    /**
     * Inject Capacity and Pay fee
     */
    const injectCapacityAndPayFeeResult = await injectCapacityAndPayFee({
      txSkeleton,
      fromInfos: props.fromInfos,
      changeAddress: props.changeAddress,
      config,
      feeRate: props.feeRate,
      updateTxSkeletonAfterCollection(_txSkeleton) {
        // Generate and inject SporeID
        _txSkeleton = injectNewSporeIds({
          outputIndices: [injectNewSporeResult.outputIndex],
          txSkeleton: _txSkeleton,
          config,
        });

        /**
         * Complete Co-Build WitnessLayout
         */

        const mintSporeCell = txSkeleton.get('outputs').get(injectNewSporeResult.outputIndex)!;
        _txSkeleton = InjectCobuildForMeltThenCreateSpore(
          injectLiveSporeCellResults.map((result) => result.inputIndex),
          mintSporeCell,
          injectNewSporeResult.reference,
          injectNewSporeResult.outputIndex,
          _txSkeleton,
          config,
        );

        return _txSkeleton;
      },
    });
    txSkeleton = injectCapacityAndPayFeeResult.txSkeleton;
  }

  // Make sure the tx size is in range (if needed)
  if (typeof maxTransactionSize === 'number') {
    assertTransactionSkeletonSize(txSkeleton, void 0, maxTransactionSize);
  }

  return {
    txSkeleton,
    inputIndexs: injectLiveSporeCellResults.map((item) => item.inputIndex),
    outputIndex: injectNewSporeResult.outputIndex,
    reference: injectNewSporeResult.reference,
    mutantReference: injectNewSporeResult.mutantReference,
  };
}


================================================
File: packages/core/src/api/composed/spore/transferSpore.ts
================================================
import { Address, OutPoint, Script } from '@ckb-lumos/base';
import { BIish } from '@ckb-lumos/bi';
import { BI, Cell, helpers, HexString, Indexer, PackedSince } from '@ckb-lumos/lumos';
import { FromInfo } from '@ckb-lumos/lumos/common-scripts';
import { getSporeByOutPoint, injectLiveSporeCell } from '../..';
import { generateTransferSporeAction, injectCommonCobuildProof } from '../../../cobuild';
import { getSporeConfig, getSporeScript, SporeConfig } from '../../../config';
import { injectCapacityAndPayFee, payFeeByOutput } from '../../../helpers';

export async function transferSpore(props: {
  outPoint: OutPoint;
  toLock: Script;
  fromInfos?: FromInfo[];
  changeAddress?: Address;
  useCapacityMarginAsFee?: boolean;
  updateOutput?: (cell: Cell) => Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  updateWitness?: HexString | ((witness: HexString) => HexString);
  defaultWitness?: HexString;
  since?: PackedSince;
  feeRate?: BIish | undefined;
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
  outputIndex: number;
}> {
  // Env
  const config = props.config ?? getSporeConfig();
  const indexer = new Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);
  const useCapacityMarginAsFee = props.useCapacityMarginAsFee ?? true;

  // Check capacity margin related props
  if (!useCapacityMarginAsFee && !props.fromInfos) {
    throw new Error('When useCapacityMarginAsFee is enabled, fromInfos is also required');
  }
  if (useCapacityMarginAsFee && props.capacityMargin !== void 0) {
    throw new Error('When useCapacityMarginAsFee is enabled, cannot set capacity margin of the spore');
  }

  // TransactionSkeleton
  let txSkeleton = helpers.TransactionSkeleton({
    cellProvider: indexer,
  });

  // Inject live spore to Transaction.inputs and Transaction.outputs
  const sporeCell = await getSporeByOutPoint(props.outPoint, config);
  const sporeScript = getSporeScript(config, 'Spore', sporeCell.cellOutput.type!);
  const injectLiveSporeCellResult = await injectLiveSporeCell({
    txSkeleton,
    cell: sporeCell,
    addOutput: true,
    updateOutput(cell) {
      cell.cellOutput.lock = props.toLock;
      if (props.updateOutput instanceof Function) {
        cell = props.updateOutput(cell);
      }
      return cell;
    },
    capacityMargin: props.capacityMargin,
    defaultWitness: props.defaultWitness,
    updateWitness: props.updateWitness,
    since: props.since,
    config,
  });
  txSkeleton = injectLiveSporeCellResult.txSkeleton;

  // Generate TransferSpore actions
  const actionResult = generateTransferSporeAction({
    txSkeleton,
    inputIndex: injectLiveSporeCellResult.inputIndex,
    outputIndex: injectLiveSporeCellResult.outputIndex,
  });

  if (!useCapacityMarginAsFee) {
    // Inject needed capacity from fromInfos and pay fee
    const injectCapacityAndPayFeeResult = await injectCapacityAndPayFee({
      txSkeleton,
      fromInfos: props.fromInfos!,
      changeAddress: props.changeAddress,
      feeRate: props.feeRate,
      updateTxSkeletonAfterCollection(_txSkeleton) {
        // Inject CobuildProof
        if (sporeScript.behaviors?.cobuild) {
          const injectCobuildProofResult = injectCommonCobuildProof({
            txSkeleton: _txSkeleton,
            actions: actionResult.actions,
          });
          _txSkeleton = injectCobuildProofResult.txSkeleton;
        }

        return _txSkeleton;
      },
      config,
    });
    txSkeleton = injectCapacityAndPayFeeResult.txSkeleton;
  } else {
    // Inject CobuildProof
    if (sporeScript.behaviors?.cobuild) {
      const injectCobuildProofResult = injectCommonCobuildProof({
        txSkeleton: txSkeleton,
        actions: actionResult.actions,
      });
      txSkeleton = injectCobuildProofResult.txSkeleton;
    }

    // Pay fee by the spore cell's capacity margin
    txSkeleton = await payFeeByOutput({
      outputIndex: injectLiveSporeCellResult.outputIndex,
      feeRate: props.feeRate,
      txSkeleton,
      config,
    });
  }

  return {
    txSkeleton,
    inputIndex: injectLiveSporeCellResult.inputIndex,
    outputIndex: injectLiveSporeCellResult.outputIndex,
  };
}

// Transfer multiple Spore at once
export async function transferMultipleSpore(props: {
  outPoints: OutPoint[];
  toLock: Script;
  fromInfos?: FromInfo[];
  changeAddress?: Address;
  useCapacityMarginAsFee?: boolean;
  updateOutput?: (cell: Cell) => Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  updateWitness?: HexString | ((witness: HexString) => HexString);
  defaultWitness?: HexString;
  since?: PackedSince;
  feeRate?: BIish | undefined;
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndecies: number[];
  outputIndecies: number[];
}> {
  // Env
  const config = props.config ?? getSporeConfig();
  const indexer = new Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);
  const useCapacityMarginAsFee = props.useCapacityMarginAsFee ?? true;

  // Check capacity margin related props
  if (!useCapacityMarginAsFee && !props.fromInfos) {
    throw new Error('When useCapacityMarginAsFee is enabled, fromInfos is also required');
  }
  if (useCapacityMarginAsFee && props.capacityMargin !== void 0) {
    throw new Error('When useCapacityMarginAsFee is enabled, cannot set capacity margin of the spore');
  }

  // TransactionSkeleton
  let txSkeleton = helpers.TransactionSkeleton({
    cellProvider: indexer,
  });
  const injectLiveSporeCellResults: Awaited<ReturnType<typeof injectLiveSporeCell>>[] = [];

  // Inject live spore to Transaction.inputs and Transaction.outputs
  for (const outPoint of props.outPoints) {
    const sporeCell = await getSporeByOutPoint(outPoint, config);
    const sporeScript = getSporeScript(config, 'Spore', sporeCell.cellOutput.type!);
    const injectLiveSporeCellResult = await injectLiveSporeCell({
      txSkeleton,
      cell: sporeCell,
      addOutput: true,
      updateOutput(cell) {
        cell.cellOutput.lock = props.toLock;
        if (props.updateOutput instanceof Function) {
          cell = props.updateOutput(cell);
        }
        return cell;
      },
      capacityMargin: props.capacityMargin,
      defaultWitness: props.defaultWitness,
      updateWitness: props.updateWitness,
      since: props.since,
      config,
    });
    txSkeleton = injectLiveSporeCellResult.txSkeleton;
    injectLiveSporeCellResults.push(injectLiveSporeCellResult);
  }

  // Generate TransferSpore actions
  const actions: (Partial<Pick<{ scriptInfoHash: string; scriptHash: string; data: string }, never>> &
    Pick<{ scriptInfoHash: string; scriptHash: string; data: string }, 'data' | 'scriptInfoHash' | 'scriptHash'>)[] =
    [];
  for (const injectLiveSporeCellResult of injectLiveSporeCellResults) {
    const actionResult = generateTransferSporeAction({
      txSkeleton,
      inputIndex: injectLiveSporeCellResult.inputIndex,
      outputIndex: injectLiveSporeCellResult.outputIndex,
    });
    actions.push(...actionResult.actions);
  }

  if (!useCapacityMarginAsFee) {
    // Inject needed capacity from fromInfos and pay fee
    const injectCapacityAndPayFeeResult = await injectCapacityAndPayFee({
      txSkeleton,
      fromInfos: props.fromInfos!,
      changeAddress: props.changeAddress,
      feeRate: props.feeRate,
      updateTxSkeletonAfterCollection(_txSkeleton) {
        // Inject CobuildProof
        const injectCobuildProofResult = injectCommonCobuildProof({
          txSkeleton: _txSkeleton,
          actions: actions,
        });
        _txSkeleton = injectCobuildProofResult.txSkeleton;

        return _txSkeleton;
      },
      config,
    });
    txSkeleton = injectCapacityAndPayFeeResult.txSkeleton;
  } else {
    // Inject CobuildProof
    const injectCobuildProofResult = injectCommonCobuildProof({
      txSkeleton: txSkeleton,
      actions: actions,
    });
    txSkeleton = injectCobuildProofResult.txSkeleton;

    // choose an output to pay the fee
    for (const item of injectLiveSporeCellResults) {
      // Pay fee by the spore cell's capacity margin
      try {
        const tkSkeletonNew = await payFeeByOutput({
          outputIndex: item.outputIndex,
          feeRate: props.feeRate,
          txSkeleton,
          config,
        });
        txSkeleton = tkSkeletonNew;
        break;
      } catch {
        // if an error throwed, try next one, until it loops out
        continue;
      }
    }
  }

  return {
    txSkeleton,
    inputIndecies: injectLiveSporeCellResults.map((cell) => cell.inputIndex),
    outputIndecies: injectLiveSporeCellResults.map((cell) => cell.outputIndex),
  };
}


================================================
File: packages/core/src/api/joints/cluster/getCluster.ts
================================================
import { OutPoint, Script } from '@ckb-lumos/base';
import { Cell, HexString, Indexer, RPC } from '@ckb-lumos/lumos';
import { getCellByType, getCellWithStatusByOutPoint, isTypeId } from '../../../helpers';
import { getSporeConfig, getSporeScriptCategory, isSporeScriptSupported, SporeConfig } from '../../../config';

export async function getClusterByType(type: Script, config?: SporeConfig): Promise<Cell> {
  // Env
  config = config ?? getSporeConfig();
  const indexer = new Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);

  // Check if the cluster's id is TypeID
  if (!isTypeId(type.args)) {
    throw new Error(`Target Cluster Id is invalid: ${type.args}`);
  }

  // Get cell by type
  const cell = await getCellByType({ type, indexer });
  if (cell === void 0) {
    throw new Error('Cannot find Cluster by Type because target cell does not exist');
  }

  // Check target cell's type script
  const cellType = cell.cellOutput.type;
  if (!cellType || !isSporeScriptSupported(config, cellType, 'Cluster')) {
    throw new Error('Cannot find Cluster by Type because target cell is not a supported version of Cluster');
  }

  return cell;
}

export async function getClusterByOutPoint(outPoint: OutPoint, config?: SporeConfig): Promise<Cell> {
  // Env
  config = config ?? getSporeConfig();
  const rpc = new RPC(config.ckbNodeUrl);

  // Get cell from rpc
  const cellWithStatus = await getCellWithStatusByOutPoint({
    outPoint,
    rpc,
  });
  if (!cellWithStatus.cell) {
    throw new Error('Cannot find Cluster by OutPoint because target cell was not found');
  }
  if (cellWithStatus.status !== 'live') {
    throw new Error('Cannot find Cluster by OutPoint because target cell is not lived');
  }

  // Check target cell's type script
  const cellType = cellWithStatus.cell.cellOutput.type;
  if (!cellType || !isSporeScriptSupported(config, cellType, 'Cluster')) {
    throw new Error('Cannot find Cluster by OutPoint because target cell is not a supported version of Cluster');
  }

  return cellWithStatus.cell;
}

export async function getClusterById(id: HexString, config?: SporeConfig): Promise<Cell> {
  // Env
  config = config ?? getSporeConfig();

  // Check if the cluster's id is TypeID
  if (!isTypeId(id)) {
    throw new Error(`Target ClusterId is invalid: ${id}`);
  }

  // Get cluster script
  const clusterScript = getSporeScriptCategory(config, 'Cluster');
  const scripts = (clusterScript.versions ?? []).map((r) => r.script);

  // Search target cluster from the latest version to the oldest
  for (const script of scripts) {
    try {
      return await getClusterByType(
        {
          ...script,
          args: id,
        },
        config,
      );
    } catch (e) {
      // Not found in the script, don't have to do anything
      console.error('getClusterById error:', e);
    }
  }

  throw new Error(
    `Cannot find Cluster by Id because target cell does not exist or it's not a supported version of Cluster`,
  );
}


================================================
File: packages/core/src/api/joints/cluster/injectLiveClusterCell.ts
================================================
import { BIish } from '@ckb-lumos/bi';
import { PackedSince } from '@ckb-lumos/base';
import { BI, Cell, helpers, HexString } from '@ckb-lumos/lumos';
import { addCellDep } from '@ckb-lumos/lumos/helpers';
import { getSporeConfig, getSporeScript, SporeConfig } from '../../../config';
import { assetCellMinimalCapacity, setAbsoluteCapacityMargin, setupCell } from '../../../helpers';

export async function injectLiveClusterCell(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  cell: Cell;
  addOutput?: boolean;
  updateOutput?: (cell: Cell) => Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  updateWitness?: HexString | ((witness: HexString) => HexString);
  defaultWitness?: HexString;
  since?: PackedSince;
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
  outputIndex: number;
}> {
  // Env
  const clusterCell = props.cell;
  const config = props.config ?? getSporeConfig();

  // Get TransactionSkeleton
  let txSkeleton = props.txSkeleton;

  // Check target cell's type
  const clusterCellType = clusterCell.cellOutput.type;
  const clusterScript = getSporeScript(config, 'Cluster', clusterCellType!);
  if (!clusterCellType || !clusterScript) {
    throw new Error('Cannot inject Cluster because target cell is not a supported version of Cluster');
  }

  // Add cluster cell to Transaction.inputs
  const setupCellResult = await setupCell({
    txSkeleton,
    input: props.cell,
    config: config.lumos,
    addOutput: props.addOutput,
    updateOutput(cell) {
      if (props.capacityMargin !== void 0) {
        cell = setAbsoluteCapacityMargin(cell, props.capacityMargin);
      }
      if (props.updateOutput instanceof Function) {
        cell = props.updateOutput(cell);
      }
      return cell;
    },
    defaultWitness: props.defaultWitness,
    updateWitness: props.updateWitness,
    since: props.since,
  });
  txSkeleton = setupCellResult.txSkeleton;

  // If the cluster is added to Transaction.outputs
  if (props.addOutput) {
    // Make sure the cell's output has declared enough capacity
    const output = txSkeleton.get('outputs').get(setupCellResult.outputIndex)!;
    assetCellMinimalCapacity(output);

    // Fix the cell's output index
    txSkeleton = txSkeleton.update('fixedEntries', (fixedEntries) => {
      return fixedEntries.push({
        field: 'outputs',
        index: setupCellResult.outputIndex,
      });
    });
  }

  // Add cluster required cellDeps
  txSkeleton = addCellDep(txSkeleton, clusterScript.cellDep);

  return {
    txSkeleton,
    inputIndex: setupCellResult.inputIndex,
    outputIndex: setupCellResult.outputIndex,
  };
}


================================================
File: packages/core/src/api/joints/cluster/injectLiveClusterReference.ts
================================================
import { BIish } from '@ckb-lumos/bi';
import { Cell, PackedSince, Script } from '@ckb-lumos/base';
import { BI, helpers, HexString } from '@ckb-lumos/lumos';
import { addCellDep } from '@ckb-lumos/common-scripts/lib/helper';
import { getSporeConfig, getSporeScript, SporeConfig } from '../../../config';
import { referenceCellOrLockProxy } from '../../../helpers';
import { injectLiveClusterCell } from './injectLiveClusterCell';

export async function injectLiveClusterReference(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  cell: Cell;
  inputLocks: Script[];
  outputLocks: Script[];
  updateOutput?: (cell: Cell) => Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  updateWitness?: HexString | ((witness: HexString) => HexString);
  defaultWitness?: HexString;
  since?: PackedSince;
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  referenceType: 'cell' | 'lockProxy';
  cluster?: {
    inputIndex: number;
    outputIndex: number;
  };
}> {
  // Env
  const config = props.config ?? getSporeConfig();
  const clusterCell = props.cell;

  // TransactionSkeleton
  let txSkeleton = props.txSkeleton;

  // Injection status & hooks
  let injectLiveClusterResult: Awaited<ReturnType<typeof injectLiveClusterCell>> | undefined;

  // Inject referenced cluster directly or inject LockProxy only
  const referenceResult = await referenceCellOrLockProxy({
    txSkeleton,
    cell: clusterCell,
    inputLocks: props.inputLocks,
    outputLocks: props.outputLocks,
    async referenceCell(tx) {
      injectLiveClusterResult = await injectLiveClusterCell({
        txSkeleton: tx,
        cell: clusterCell,
        addOutput: true,
        updateOutput: props.updateOutput,
        updateWitness: props.updateWitness,
        capacityMargin: props.capacityMargin,
        defaultWitness: props.defaultWitness,
        since: props.since,
        config,
      });

      return injectLiveClusterResult.txSkeleton;
    },
    async referenceLockProxy(tx) {
      const clusterType = clusterCell.cellOutput.type;
      const clusterScript = getSporeScript(config, 'Cluster', clusterType!);
      if (!clusterScript.behaviors?.lockProxy) {
        throw new Error('Cannot reference Cluster because target Cluster does not supported lockProxy');
      }

      tx = addCellDep(tx, clusterScript.cellDep);

      return tx;
    },
  });
  txSkeleton = referenceResult.txSkeleton;

  return {
    txSkeleton,
    referenceType: referenceResult.referencedCell ? 'cell' : 'lockProxy',
    cluster:
      referenceResult.referencedCell && injectLiveClusterResult !== void 0
        ? {
            inputIndex: injectLiveClusterResult.inputIndex,
            outputIndex: injectLiveClusterResult.outputIndex,
          }
        : void 0,
  };
}


================================================
File: packages/core/src/api/joints/cluster/injectNewClusterIds.ts
================================================
import { helpers } from '@ckb-lumos/lumos';
import { generateTypeIdsByOutputs } from '../../../helpers';
import { getSporeConfig, isSporeScriptSupported, SporeConfig } from '../../../config';

export function injectNewClusterIds(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  outputIndices?: number[];
  config?: SporeConfig;
}): helpers.TransactionSkeletonType {
  // Env
  const config = props.config ?? getSporeConfig();

  // Get TransactionSkeleton
  let txSkeleton = props.txSkeleton;

  // Get the first input
  const inputs = txSkeleton.get('inputs');
  const firstInput = inputs.get(0);
  if (!firstInput) {
    throw new Error('Cannot generate Cluster Id because Transaction.inputs[0] does not exist');
  }

  // Calculates TypeIds by the outputs' indices
  let outputs = txSkeleton.get('outputs');
  let typeIdGroup = generateTypeIdsByOutputs(firstInput, outputs.toArray(), (cell) => {
    return !!cell.cellOutput.type && isSporeScriptSupported(config, cell.cellOutput.type, 'Cluster');
  });

  // If `clusterOutputIndices` is provided, filter the result
  if (props.outputIndices) {
    typeIdGroup = typeIdGroup.filter(([outputIndex]) => {
      const index = props.outputIndices!.findIndex((index) => index === outputIndex);
      return index >= 0;
    });
    if (typeIdGroup.length !== props.outputIndices.length) {
      throw new Error('Cannot generate Cluster Id because clusterOutputIndices cannot be fully handled');
    }
  }

  // Update results
  for (const [index, typeId] of typeIdGroup) {
    const output = outputs.get(index);
    if (!output) {
      throw new Error(`Cannot generate Cluster Id because Transaction.outputs[${index}] does not exist`);
    }

    output.cellOutput.type!.args = typeId;
    outputs = outputs.set(index, output);
  }

  return txSkeleton.set('outputs', outputs);
}


================================================
File: packages/core/src/api/joints/cluster/injectNewClusterOutput.ts
================================================
import { BIish } from '@ckb-lumos/bi';
import { bytes } from '@ckb-lumos/codec';
import { Script } from '@ckb-lumos/base';
import { BI, Cell, helpers } from '@ckb-lumos/lumos';
import { addCellDep } from '@ckb-lumos/lumos/helpers';
import { RawClusterData, packRawClusterData } from '../../../codec';
import { getSporeConfig, getSporeScript, SporeConfig } from '../../../config';
import { correctCellMinimalCapacity, setAbsoluteCapacityMargin } from '../../../helpers';
import { injectNewClusterIds } from './injectNewClusterIds';

export function injectNewClusterOutput(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  data: RawClusterData;
  toLock: Script;
  config?: SporeConfig;
  updateOutput?(cell: Cell): Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
}): {
  txSkeleton: helpers.TransactionSkeletonType;
  outputIndex: number;
  hasId: boolean;
} {
  // Env
  const config = props.config ?? getSporeConfig();

  // Get TransactionSkeleton
  let txSkeleton = props.txSkeleton;

  // Check the referenced Mutant's ID format
  if (props.data.mutantId !== void 0) {
    const packedMutantId = bytes.bytify(props.data.mutantId!);
    if (packedMutantId.byteLength !== 32) {
      throw new Error(`Invalid Mutant Id length, expected 32, actually: ${packedMutantId.byteLength}`);
    }
  }

  // Create Cluster cell (the latest version)
  const clusterScript = getSporeScript(config, 'Cluster');
  const clusterData = packRawClusterData(props.data, clusterScript.behaviors?.clusterDataVersion as any);
  let clusterCell: Cell = correctCellMinimalCapacity({
    cellOutput: {
      capacity: '0x0',
      lock: props.toLock,
      type: {
        ...clusterScript.script,
        args: '0x' + '0'.repeat(64), // Fill 32-byte TypeId placeholder
      },
    },
    data: bytes.hexify(clusterData),
  });

  // Add to Transaction.outputs
  const outputIndex = txSkeleton.get('outputs').size;
  txSkeleton = txSkeleton.update('outputs', (outputs) => {
    if (props.capacityMargin !== void 0) {
      clusterCell = setAbsoluteCapacityMargin(clusterCell, props.capacityMargin);
    }
    if (props.updateOutput instanceof Function) {
      clusterCell = props.updateOutput(clusterCell);
    }
    return outputs.push(clusterCell);
  });

  // Fix the output's index to prevent it from future reduction
  txSkeleton = txSkeleton.update('fixedEntries', (fixedEntries) => {
    return fixedEntries.push({
      field: 'outputs',
      index: outputIndex,
    });
  });

  // Generate ID for the new Cluster if possible
  const firstInput = txSkeleton.get('inputs').first();
  if (firstInput) {
    txSkeleton = injectNewClusterIds({
      outputIndices: [outputIndex],
      txSkeleton,
      config,
    });
  }

  // Add Cluster required cellDeps
  txSkeleton = addCellDep(txSkeleton, clusterScript.cellDep);
  // Add Mutant cellDeps if ClusterData.mutantId is specified
  if (props.data.mutantId !== void 0) {
    const mutantScript = getSporeScript(config, 'Mutant');
    txSkeleton = addCellDep(txSkeleton, mutantScript.cellDep);
  }

  return {
    txSkeleton,
    outputIndex,
    hasId: firstInput !== void 0,
  };
}


================================================
File: packages/core/src/api/joints/clusterAgent/getClusterAgent.ts
================================================
import { OutPoint } from '@ckb-lumos/base';
import { Cell, RPC } from '@ckb-lumos/lumos';
import { getCellWithStatusByOutPoint } from '../../../helpers';
import { SporeConfig, getSporeConfig, isSporeScriptSupported } from '../../../config';

export async function getClusterAgentByOutPoint(outPoint: OutPoint, config?: SporeConfig): Promise<Cell> {
  // Env
  config = config ?? getSporeConfig();
  const rpc = new RPC(config.ckbNodeUrl);

  // Get cell from rpc
  const cellWithStatus = await getCellWithStatusByOutPoint({
    outPoint,
    rpc,
  });
  if (!cellWithStatus.cell) {
    throw new Error('Cannot find ClusterAgent by OutPoint because target cell was not found');
  }
  if (cellWithStatus.status !== 'live') {
    throw new Error('Cannot find ClusterAgent by OutPoint because target cell is not lived');
  }

  // Check target cell's type script
  const cellType = cellWithStatus.cell.cellOutput.type;
  if (!cellType || !isSporeScriptSupported(config, cellType, 'ClusterAgent')) {
    throw new Error(
      'Cannot find ClusterAgent by OutPoint because target cell is not a supported version of ClusterAgent',
    );
  }

  return cellWithStatus.cell;
}


================================================
File: packages/core/src/api/joints/clusterAgent/injectLiveClusterAgentCell.ts
================================================
import { BIish } from '@ckb-lumos/bi';
import { PackedSince } from '@ckb-lumos/base';
import { BI, Cell, helpers, HexString } from '@ckb-lumos/lumos';
import { addCellDep } from '@ckb-lumos/common-scripts/lib/helper';
import { getSporeConfig, getSporeScript, SporeConfig } from '../../../config';
import { assetCellMinimalCapacity, setAbsoluteCapacityMargin, setupCell } from '../../../helpers';

export async function injectLiveClusterAgentCell(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  cell: Cell;
  addOutput?: boolean;
  config?: SporeConfig;
  updateOutput?(cell: Cell): Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  updateWitness?: HexString | ((witness: HexString) => HexString);
  defaultWitness?: HexString;
  since?: PackedSince;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
  outputIndex: number;
}> {
  // Env
  const config = props.config ?? getSporeConfig();
  const clusterAgentCell = props.cell;

  // TransactionSkeleton
  let txSkeleton = props.txSkeleton;

  // Check the target cell's type
  const cellType = clusterAgentCell.cellOutput.type;
  const clusterAgentScript = getSporeScript(config, 'ClusterAgent', cellType!);
  if (!cellType || !clusterAgentScript) {
    throw new Error('Cannot inject ClusterAgent because target cell is not a supported version of ClusterAgent');
  }

  // Add the target cell to Transaction.inputs (and outputs if needed)
  const setupCellResult = await setupCell({
    txSkeleton,
    input: clusterAgentCell,
    config: config.lumos,
    addOutput: props.addOutput,
    updateOutput(cell) {
      if (props.capacityMargin !== void 0) {
        cell = setAbsoluteCapacityMargin(cell, props.capacityMargin);
      }
      if (props.updateOutput instanceof Function) {
        cell = props.updateOutput(cell);
      }
      return cell;
    },
    defaultWitness: props.defaultWitness,
    updateWitness: props.updateWitness,
    since: props.since,
  });
  txSkeleton = setupCellResult.txSkeleton;

  // If the target cell has been added to Transaction.outputs
  if (props.addOutput) {
    // Make sure the cell's output has declared enough capacity
    const output = txSkeleton.get('outputs').get(setupCellResult.outputIndex)!;
    assetCellMinimalCapacity(output);

    // Fix the cell's output index
    txSkeleton = txSkeleton.update('fixedEntries', (fixedEntries) => {
      return fixedEntries.push({
        field: 'outputs',
        index: setupCellResult.outputIndex,
      });
    });
  }

  // Add ClusterAgent required cellDeps
  txSkeleton = addCellDep(txSkeleton, clusterAgentScript.cellDep);

  return {
    txSkeleton,
    inputIndex: setupCellResult.inputIndex,
    outputIndex: setupCellResult.outputIndex,
  };
}


================================================
File: packages/core/src/api/joints/clusterAgent/injectLiveClusterAgentReference.ts
================================================
import { BIish } from '@ckb-lumos/bi';
import { PackedSince, Script } from '@ckb-lumos/base';
import { BI, Cell, helpers, HexString } from '@ckb-lumos/lumos';
import { addCellDep } from '@ckb-lumos/common-scripts/lib/helper';
import { referenceCellOrLockProxy } from '../../../helpers';
import { getSporeConfig, getSporeScript, SporeConfig } from '../../../config';
import { injectLiveClusterAgentCell } from './injectLiveClusterAgentCell';

export async function injectLiveClusterAgentReference(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  cell: Cell;
  inputLocks: Script[];
  outputLocks: Script[];
  updateOutput?: (cell: Cell) => Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  updateWitness?: HexString | ((witness: HexString) => HexString);
  defaultWitness?: HexString;
  since?: PackedSince;
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  referenceType: 'cell' | 'lockProxy';
  clusterAgent?: {
    inputIndex: number;
    outputIndex: number;
  };
}> {
  // Env
  const config = props.config ?? getSporeConfig();
  let txSkeleton = props.txSkeleton;

  // Get ClusterAgent cell
  const clusterAgentCell = props.cell;
  if (!clusterAgentCell.outPoint) {
    throw new Error(`Cannot inject ClusterAgent as reference because target cell has no OutPoint`);
  }

  // Inject reference cell or LockProxy
  let injectLiveClusterAgentResult: Awaited<ReturnType<typeof injectLiveClusterAgentCell>> | undefined;
  const referenceResult = await referenceCellOrLockProxy({
    txSkeleton,
    cell: clusterAgentCell,
    inputLocks: props.inputLocks,
    outputLocks: props.outputLocks,
    async referenceCell(tx) {
      injectLiveClusterAgentResult = await injectLiveClusterAgentCell({
        txSkeleton: tx,
        cell: clusterAgentCell,
        addOutput: true,
        updateOutput: props.updateOutput,
        updateWitness: props.updateWitness,
        capacityMargin: props.capacityMargin,
        defaultWitness: props.defaultWitness,
        since: props.since,
        config,
      });

      return injectLiveClusterAgentResult.txSkeleton;
    },
    referenceLockProxy(tx) {
      const cellType = clusterAgentCell.cellOutput.type;
      const clusterAgentScript = getSporeScript(config, 'ClusterAgent', cellType!);
      if (!clusterAgentScript.behaviors?.lockProxy) {
        throw new Error('Cannot reference ClusterAgent because target cell does not supported lockProxy');
      }

      // Add ClusterAgent required cellDeps
      tx = addCellDep(tx, clusterAgentScript.cellDep);

      return tx;
    },
  });
  txSkeleton = referenceResult.txSkeleton;

  return {
    txSkeleton,
    referenceType: referenceResult.referencedCell ? 'cell' : 'lockProxy',
    clusterAgent:
      referenceResult.referencedCell && injectLiveClusterAgentResult !== void 0
        ? {
            inputIndex: injectLiveClusterAgentResult.inputIndex,
            outputIndex: injectLiveClusterAgentResult.outputIndex,
          }
        : void 0,
  };
}


================================================
File: packages/core/src/api/joints/clusterAgent/injectNewClusterAgentOutput.ts
================================================
import { BIish } from '@ckb-lumos/bi';
import { Address, Script } from '@ckb-lumos/base';
import { FromInfo } from '@ckb-lumos/common-scripts';
import { BI, Cell, helpers, HexString } from '@ckb-lumos/lumos';
import { addCellDep } from '@ckb-lumos/common-scripts/lib/helper';
import { packRawClusterAgentDataToHash } from '../../../codec';
import { correctCellMinimalCapacity, setAbsoluteCapacityMargin } from '../../../helpers';
import { getSporeConfig, getSporeScript, isSporeScriptSupported, SporeConfig } from '../../../config';
import { injectLiveClusterProxyReference } from '../clusterProxy/injectLiveClusterProxyReference';

export async function injectNewClusterAgentOutput(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  clusterProxyCell: Cell;
  referenceType: 'cell' | 'payment';
  paymentAmount?: BIish | ((minPayment: BI) => BIish);
  toLock: Script;
  fromInfos: FromInfo[];
  changeAddress?: Address;
  updateOutput?: (cell: Cell) => Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  clusterProxy?: {
    updateOutput?: (cell: Cell) => Cell;
    capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
    updateWitness?: HexString | ((witness: HexString) => HexString);
  };
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  outputIndex: number;
  reference: {
    referenceType: 'cell' | 'payment';
    clusterProxy?: {
      inputIndex: number;
      outputIndex: number;
    };
    payment?: {
      outputIndex: number;
    };
  };
}> {
  // Env
  const config = props.config ?? getSporeConfig();

  // TransactionSkeleton
  let txSkeleton = props.txSkeleton;

  // Get the referenced ClusterProxy
  const clusterProxyCell = props.clusterProxyCell;
  const clusterProxyType = clusterProxyCell.cellOutput.type;
  if (!clusterProxyType || !isSporeScriptSupported(config, clusterProxyType, 'ClusterProxy')) {
    throw new Error('Cannot reference ClusterProxy because target cell is not a supported version of ClusterProxy');
  }

  // Reference the ClusterProxy directly or through a payment cell
  const injectLiveClusterProxyReferenceResult = await injectLiveClusterProxyReference({
    txSkeleton,
    cell: clusterProxyCell,
    referenceType: props.referenceType,
    paymentAmount: props.paymentAmount,
    capacityMargin: props.clusterProxy?.capacityMargin,
    updateWitness: props.clusterProxy?.updateWitness,
    updateOutput: props.clusterProxy?.updateOutput,
    config,
  });
  txSkeleton = injectLiveClusterProxyReferenceResult.txSkeleton;

  // Create ClusterAgent cell (the latest version)
  const clusterAgentScript = getSporeScript(config, 'ClusterAgent');
  const referencedClusterId = clusterProxyCell.data;
  let clusterAgentCell: Cell = correctCellMinimalCapacity({
    cellOutput: {
      capacity: '0x0',
      lock: props.toLock,
      type: {
        ...clusterAgentScript.script,
        args: referencedClusterId,
      },
    },
    data: packRawClusterAgentDataToHash(clusterProxyType),
  });

  // Add to Transaction.outputs
  const outputIndex = txSkeleton.get('outputs').size;
  txSkeleton = txSkeleton.update('outputs', (outputs) => {
    if (props.capacityMargin !== void 0) {
      clusterAgentCell = setAbsoluteCapacityMargin(clusterAgentCell, props.capacityMargin);
    }
    if (props.updateOutput instanceof Function) {
      clusterAgentCell = props.updateOutput(clusterAgentCell);
    }
    return outputs.push(clusterAgentCell);
  });

  // Fix the index of the ClusterAgent in outputs to prevent it from future reduction
  txSkeleton = txSkeleton.update('fixedEntries', (fixedEntries) => {
    return fixedEntries.push({
      field: 'outputs',
      index: outputIndex,
    });
  });

  // Add ClusterAgent required cellDeps
  txSkeleton = addCellDep(txSkeleton, clusterAgentScript.cellDep);

  return {
    txSkeleton,
    outputIndex,
    reference: {
      referenceType: injectLiveClusterProxyReferenceResult.referenceType,
      clusterProxy: injectLiveClusterProxyReferenceResult.clusterProxy,
      payment: injectLiveClusterProxyReferenceResult.payment,
    },
  };
}


================================================
File: packages/core/src/api/joints/clusterProxy/getClusterProxy.ts
================================================
import { bytes } from '@ckb-lumos/codec';
import { Cell, Indexer, RPC } from '@ckb-lumos/lumos';
import { Hash, OutPoint, Script } from '@ckb-lumos/base';
import { getCellByType, getCellWithStatusByOutPoint } from '../../../helpers';
import { getSporeConfig, getSporeScriptCategory, isSporeScriptSupported, SporeConfig } from '../../../config';
import { packRawClusterProxyArgs } from '../../../codec';

export async function getClusterProxyByType(type: Script, config?: SporeConfig): Promise<Cell> {
  // Env
  config = config ?? getSporeConfig();
  const indexer = new Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);

  // Get cell by type
  const cell = await getCellByType({ type, indexer });
  if (cell === void 0) {
    throw new Error('Cannot find ClusterProxy by Type because target cell does not exist');
  }

  // Check target cell's type script
  const cellType = cell.cellOutput.type;
  if (!cellType || !isSporeScriptSupported(config, cellType, 'ClusterProxy')) {
    throw new Error('Cannot find ClusterProxy by Type because target cell is not a supported version of ClusterProxy');
  }

  return cell;
}

export async function getClusterProxyByOutPoint(outPoint: OutPoint, config?: SporeConfig): Promise<Cell> {
  // Env
  config = config ?? getSporeConfig();
  const rpc = new RPC(config.ckbNodeUrl);

  // Get cell from rpc
  const cellWithStatus = await getCellWithStatusByOutPoint({
    outPoint,
    rpc,
  });
  if (!cellWithStatus.cell) {
    throw new Error('Cannot find ClusterProxy by OutPoint because target cell was not found');
  }
  if (cellWithStatus.status !== 'live') {
    throw new Error('Cannot find ClusterProxy by OutPoint because target cell is not lived');
  }

  // Check target cell's type script
  const cellType = cellWithStatus.cell.cellOutput.type;
  if (!cellType || !isSporeScriptSupported(config, cellType, 'ClusterProxy')) {
    throw new Error(
      'Cannot find ClusterProxy by OutPoint because target cell is not a supported version of ClusterProxy',
    );
  }

  return cellWithStatus.cell;
}

export async function getClusterProxyById(id: Hash, config?: SporeConfig): Promise<Cell> {
  // Env
  config = config ?? getSporeConfig();

  // Get ClusterProxy script
  const clusterProxyScript = getSporeScriptCategory(config, 'ClusterProxy');
  const scripts = (clusterProxyScript.versions ?? []).map((r) => r.script);

  // Search target cluster proxy from the latest version to the oldest
  const args = bytes.hexify(
    packRawClusterProxyArgs({
      id,
    }),
  );
  for (const script of scripts) {
    try {
      return await getClusterProxyByType(
        {
          ...script,
          args,
        },
        config,
      );
    } catch (e) {
      // Not found in the script, don't have to do anything
      console.error('getClusterProxyById error:', e);
    }
  }

  throw new Error(
    `Cannot find ClusterProxy by ID because target cell does not exist or it's not a supported version of ClusterProxy`,
  );
}


================================================
File: packages/core/src/api/joints/clusterProxy/injectLiveClusterProxyCell.ts
================================================
import { BIish } from '@ckb-lumos/bi';
import { PackedSince } from '@ckb-lumos/base';
import { BI, Cell, helpers, HexString } from '@ckb-lumos/lumos';
import { addCellDep } from '@ckb-lumos/common-scripts/lib/helper';
import { getSporeConfig, getSporeScript, SporeConfig } from '../../../config';
import { assetCellMinimalCapacity, setAbsoluteCapacityMargin, setupCell } from '../../../helpers';

export async function injectLiveClusterProxyCell(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  cell: Cell;
  addOutput?: boolean;
  updateOutput?: (cell: Cell) => Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  updateWitness?: HexString | ((witness: HexString) => HexString);
  defaultWitness?: HexString;
  since?: PackedSince;
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
  outputIndex: number;
}> {
  // Env
  const config = props.config ?? getSporeConfig();
  const clusterProxyCell = props.cell;

  // TransactionSkeleton
  let txSkeleton = props.txSkeleton;

  // Check target cell's type
  const cellType = clusterProxyCell.cellOutput.type;
  const clusterProxyScript = getSporeScript(config, 'ClusterProxy', cellType!);
  if (!cellType || !clusterProxyScript) {
    throw new Error('Cannot inject ClusterProxy because target cell is not a supported version of ClusterProxy');
  }

  // Add target cell to Transaction.inputs (and outputs if needed)
  const setupCellResult = await setupCell({
    txSkeleton,
    input: clusterProxyCell,
    addOutput: props.addOutput,
    updateOutput(cell) {
      if (props.capacityMargin !== void 0) {
        cell = setAbsoluteCapacityMargin(cell, props.capacityMargin);
      }
      if (props.updateOutput instanceof Function) {
        cell = props.updateOutput(cell);
      }
      return cell;
    },
    defaultWitness: props.defaultWitness,
    updateWitness: props.updateWitness,
    since: props.since,
    config: config.lumos,
  });
  txSkeleton = setupCellResult.txSkeleton;

  // If the target cell is added to Transaction.outputs
  if (props.addOutput) {
    // Make sure the cell's output has declared enough capacity
    const output = txSkeleton.get('outputs').get(setupCellResult.outputIndex)!;
    assetCellMinimalCapacity(output);

    // Fix the cell's output index
    txSkeleton = txSkeleton.update('fixedEntries', (fixedEntries) => {
      return fixedEntries.push({
        field: 'outputs',
        index: setupCellResult.outputIndex,
      });
    });
  }

  // Add ClusterProxy required cellDeps
  txSkeleton = addCellDep(txSkeleton, clusterProxyScript.cellDep);

  return {
    txSkeleton,
    inputIndex: setupCellResult.inputIndex,
    outputIndex: setupCellResult.outputIndex,
  };
}


================================================
File: packages/core/src/api/joints/clusterProxy/injectLiveClusterProxyReference.ts
================================================
import { BIish } from '@ckb-lumos/bi';
import { BI, Cell, helpers, HexString } from '@ckb-lumos/lumos';
import { addCellDep } from '@ckb-lumos/common-scripts/lib/helper';
import { assetCellMinimalCapacity, minimalCellCapacityByLock } from '../../../helpers';
import { getSporeConfig, getSporeScript, SporeConfig } from '../../../config';
import { injectLiveClusterProxyCell } from './injectLiveClusterProxyCell';
import { unpackToRawClusterProxyArgs } from '../../../codec';

export async function injectLiveClusterProxyReference(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  cell: Cell;
  referenceType: 'cell' | 'payment';
  paymentAmount?: BIish | ((minPayment: BI) => BIish);
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  updateWitness?: HexString | ((witness: HexString) => HexString);
  updateOutput?: (cell: Cell) => Cell;
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  referenceType: 'cell' | 'payment';
  clusterProxy?: {
    inputIndex: number;
    outputIndex: number;
  };
  payment?: {
    outputIndex: number;
  };
}> {
  // Env
  const config = props.config ?? getSporeConfig();
  const isPaying = props.referenceType === 'payment';

  // TransactionSkeleton
  let txSkeleton = props.txSkeleton;

  // Get ClusterProxy cell
  const clusterProxyCell = props.cell;
  if (!clusterProxyCell.outPoint) {
    throw new Error(`Cannot inject ClusterProxy as reference because target cell has no OutPoint`);
  }

  // Get ClusterProxy's type script
  const clusterProxyType = clusterProxyCell.cellOutput.type;
  const clusterProxyScript = getSporeScript(config, 'ClusterProxy', clusterProxyType!);
  if (!clusterProxyType || !clusterProxyScript) {
    throw new Error('Cannot inject ClusterProxy because target cell is not a supported version of ClusterProxy');
  }

  // Method #1: Paying capacity to the owner of the referenced ClusterProxy
  let paymentCellOutputIndex: number | undefined;
  if (isPaying) {
    const clusterProxyArgs = unpackToRawClusterProxyArgs(clusterProxyType.args);
    const minPayment = clusterProxyArgs.minPayment !== void 0 ? clusterProxyArgs.minPayment : BI.from(0);
    if (minPayment.lte(0)) {
      throw new Error('Cannot pay to reference ClusterProxy because minPayment is undefined');
    }

    const minCellCapacity = minimalCellCapacityByLock(clusterProxyCell.cellOutput.lock);
    const requiredPayment = minPayment.gt(minCellCapacity) ? minPayment : minCellCapacity;
    const paymentAmount = BI.from(
      props.paymentAmount
        ? props.paymentAmount instanceof Function
          ? props.paymentAmount(requiredPayment)
          : props.paymentAmount
        : requiredPayment,
    );
    if (paymentAmount.lt(requiredPayment)) {
      throw new Error(
        `Cannot pay to reference ClusterProxy because paymentAmount is too low, required: ${requiredPayment.toString()}, actual: ${paymentAmount.toString()}`,
      );
    }

    const paymentCell: Cell = {
      cellOutput: {
        capacity: paymentAmount.toHexString(),
        lock: clusterProxyCell.cellOutput.lock,
      },
      data: '0x',
    };

    // Make sure the declared capacity is enough
    assetCellMinimalCapacity(paymentCell);

    // Add the payment cell to outputs
    txSkeleton = txSkeleton.update('outputs', (outputs) => {
      paymentCellOutputIndex = outputs.size;
      return outputs.push(paymentCell);
    });

    // Fix the payment cell's output index to prevent it from future reduction
    txSkeleton = txSkeleton.update('fixedEntries', (fixedEntries) => {
      return fixedEntries.push({
        field: 'outputs',
        index: paymentCellOutputIndex!,
      });
    });
  }

  // Method #2: Reference the ClusterProxy directly into inputs/outputs
  let injectLiveClusterResult: Awaited<ReturnType<typeof injectLiveClusterProxyCell>> | undefined;
  if (!isPaying) {
    injectLiveClusterResult = await injectLiveClusterProxyCell({
      txSkeleton: txSkeleton,
      cell: clusterProxyCell,
      updateOutput: props.updateOutput,
      updateWitness: props.updateWitness,
      capacityMargin: props.capacityMargin,
      addOutput: true,
      config,
    });
    txSkeleton = injectLiveClusterResult.txSkeleton;

    // Fix the referenced cell's output index to prevent it from future reduction
    txSkeleton = txSkeleton.update('fixedEntries', (fixedEntries) => {
      return fixedEntries.push({
        field: 'outputs',
        index: injectLiveClusterResult!.outputIndex,
      });
    });
  }

  // Add ClusterProxy relevant cellDeps
  txSkeleton = addCellDep(txSkeleton, clusterProxyScript.cellDep);
  txSkeleton = addCellDep(txSkeleton, {
    outPoint: clusterProxyCell.outPoint!,
    depType: 'code',
  });

  return {
    txSkeleton,
    referenceType: isPaying ? 'payment' : 'cell',
    clusterProxy:
      !isPaying && injectLiveClusterResult
        ? {
            inputIndex: injectLiveClusterResult.inputIndex,
            outputIndex: injectLiveClusterResult.outputIndex,
          }
        : void 0,
    payment: isPaying
      ? {
          outputIndex: paymentCellOutputIndex!,
        }
      : void 0,
  };
}


================================================
File: packages/core/src/api/joints/clusterProxy/injectNewClusterProxyIds.ts
================================================
import { bytes } from '@ckb-lumos/codec';
import { helpers } from '@ckb-lumos/lumos';
import { generateTypeIdsByOutputs } from '../../../helpers';
import { packRawClusterProxyArgs, unpackToRawClusterProxyArgs } from '../../../codec';
import { getSporeConfig, isSporeScriptSupported, SporeConfig } from '../../../config';

export function injectNewClusterProxyIds(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  outputIndices?: number[];
  config?: SporeConfig;
}): helpers.TransactionSkeletonType {
  // Env
  const config = props.config ?? getSporeConfig();

  // TransactionSkeleton
  let txSkeleton = props.txSkeleton;

  // Get the Transaction.inputs[0]
  const firstInput = txSkeleton.get('inputs').get(0);
  if (!firstInput) {
    throw new Error('Cannot generate ClusterProxy Id because Transaction.inputs[0] does not exist');
  }

  // Generate TypeIds by the output indices
  let outputs = txSkeleton.get('outputs');
  let typeIdGroup = generateTypeIdsByOutputs(firstInput, outputs.toArray(), (cell) => {
    return !!cell.cellOutput.type && isSporeScriptSupported(config, cell.cellOutput.type, 'ClusterProxy');
  });

  // Only keep the TypeIDs corresponding to the specified output indices
  if (props.outputIndices) {
    typeIdGroup = typeIdGroup.filter(([outputIndex]) => {
      const index = props.outputIndices!.findIndex((index) => index === outputIndex);
      return index >= 0;
    });
    if (typeIdGroup.length !== props.outputIndices.length) {
      throw new Error('Cannot generate ClusterProxy Id because outputIndices cannot be fully handled');
    }
  }

  // Update results
  for (const [index, typeId] of typeIdGroup) {
    const output = outputs.get(index);
    if (!output) {
      throw new Error(`Cannot generate ClusterProxy Id because Transaction.outputs[${index}] does not exist`);
    }

    const unpackedArgs = unpackToRawClusterProxyArgs(output.cellOutput.type!.args);
    const packedNewArgs = packRawClusterProxyArgs({
      id: typeId,
      minPayment: unpackedArgs.minPayment,
    });

    output.cellOutput.type!.args = bytes.hexify(packedNewArgs);
    outputs = outputs.set(index, output);
  }

  return txSkeleton.set('outputs', outputs);
}


================================================
File: packages/core/src/api/joints/clusterProxy/injectNewClusterProxyOutput.ts
================================================
import { BIish } from '@ckb-lumos/bi';
import { bytes } from '@ckb-lumos/codec';
import { Address, Script } from '@ckb-lumos/base';
import { FromInfo } from '@ckb-lumos/common-scripts';
import { BI, Cell, helpers, HexString } from '@ckb-lumos/lumos';
import { addCellDep } from '@ckb-lumos/common-scripts/lib/helper';
import { packRawClusterProxyArgs } from '../../../codec';
import { composeInputLocks, composeOutputLocks } from '../../../helpers';
import { correctCellMinimalCapacity, setAbsoluteCapacityMargin } from '../../../helpers';
import { getSporeConfig, getSporeScript, isSporeScriptSupported, SporeConfig } from '../../../config';
import { injectLiveClusterReference } from '../cluster/injectLiveClusterReference';
import { injectNewClusterProxyIds } from './injectNewClusterProxyIds';

export async function injectNewClusterProxyOutput(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  clusterCell: Cell;
  minPayment?: BIish;
  toLock: Script;
  fromInfos: FromInfo[];
  changeAddress?: Address;
  updateOutput?: (cell: Cell) => Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  cluster?: {
    updateOutput?: (cell: Cell) => Cell;
    capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
    updateWitness?: HexString | ((witness: HexString) => HexString);
  };
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  outputIndex: number;
  hasId: boolean;
  reference: {
    referenceType: 'cell' | 'lockProxy';
    cluster?: {
      inputIndex: number;
      outputIndex: number;
    };
  };
}> {
  // Env
  const config = props.config ?? getSporeConfig();

  // TransactionSkeleton
  let txSkeleton = props.txSkeleton;

  // Get Referenced cluster cell
  const referencedClusterCell = props.clusterCell;
  const referencedClusterType = referencedClusterCell.cellOutput.type;
  if (!referencedClusterType || !isSporeScriptSupported(config, referencedClusterType, 'Cluster')) {
    throw new Error('Cannot reference Cluster because target cell is not a supported version of Cluster');
  }

  // Inject referenced cluster or its LockProxy
  const injectLiveClusterReferenceResult = await injectLiveClusterReference({
    txSkeleton,
    cell: referencedClusterCell,
    inputLocks: composeInputLocks({
      fromInfos: props.fromInfos,
      config: config.lumos,
    }),
    outputLocks: composeOutputLocks({
      outputLocks: [props.toLock],
      fromInfos: props.fromInfos,
      changeAddress: props.changeAddress,
      config: config.lumos,
    }),
    updateOutput: props.cluster?.updateOutput,
    updateWitness: props.cluster?.updateWitness,
    capacityMargin: props.cluster?.capacityMargin,
    config,
  });
  txSkeleton = injectLiveClusterReferenceResult.txSkeleton;

  // Create ClusterProxy cell (the latest version)
  const clusterProxyScript = getSporeScript(config, 'ClusterProxy');
  let clusterProxyCell: Cell = correctCellMinimalCapacity({
    cellOutput: {
      capacity: '0x0',
      lock: props.toLock,
      type: {
        ...clusterProxyScript.script,
        args: bytes.hexify(
          packRawClusterProxyArgs({
            id: '0x' + '0'.repeat(64), // Fill 32-byte TypeId placeholder
            minPayment: props.minPayment,
          }),
        ),
      },
    },
    data: referencedClusterType.args,
  });

  // Add to Transaction.outputs
  const outputIndex = txSkeleton.get('outputs').size;
  txSkeleton = txSkeleton.update('outputs', (outputs) => {
    if (props.capacityMargin !== void 0) {
      clusterProxyCell = setAbsoluteCapacityMargin(clusterProxyCell, props.capacityMargin);
    }
    if (props.updateOutput instanceof Function) {
      clusterProxyCell = props.updateOutput(clusterProxyCell);
    }
    return outputs.push(clusterProxyCell);
  });

  // Fix the index of the ClusterProxy in outputs to prevent it from future reduction
  txSkeleton = txSkeleton.update('fixedEntries', (fixedEntries) => {
    return fixedEntries.push({
      field: 'outputs',
      index: outputIndex,
    });
  });

  // Generate ID for the new ClusterProxy if possible
  const firstInput = txSkeleton.get('inputs').first();
  if (firstInput) {
    txSkeleton = injectNewClusterProxyIds({
      outputIndices: [outputIndex],
      txSkeleton,
      config,
    });
  }

  // Add ClusterProxy required dependencies
  txSkeleton = addCellDep(txSkeleton, clusterProxyScript.cellDep);

  return {
    txSkeleton,
    outputIndex,
    hasId: firstInput !== void 0,
    reference: {
      referenceType: injectLiveClusterReferenceResult.referenceType,
      cluster: injectLiveClusterReferenceResult.cluster,
    },
  };
}


================================================
File: packages/core/src/api/joints/mutant/getMutant.ts
================================================
import { bytes } from '@ckb-lumos/codec';
import { Cell, Indexer, RPC } from '@ckb-lumos/lumos';
import { Hash, OutPoint, Script } from '@ckb-lumos/base';
import { packRawMutantArgs } from '../../../codec';
import { getCellByType, getCellWithStatusByOutPoint } from '../../../helpers';
import { getSporeConfig, getSporeScriptCategory, isSporeScriptSupported, SporeConfig } from '../../../config';

export async function getMutantByType(type: Script, config?: SporeConfig): Promise<Cell> {
  // Env
  config = config ?? getSporeConfig();
  const indexer = new Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);

  // Get cell by type
  const cell = await getCellByType({ type, indexer });
  if (cell === void 0) {
    throw new Error('Cannot find Mutant by Type because target cell does not exist');
  }

  // Check target cell's type script
  const cellType = cell.cellOutput.type;
  if (!cellType || !isSporeScriptSupported(config, cellType, 'Mutant')) {
    throw new Error('Cannot find Mutant by Type because target cell is not a supported version of Mutant');
  }

  return cell;
}

export async function getMutantByOutPoint(outPoint: OutPoint, config?: SporeConfig): Promise<Cell> {
  // Env
  config = config ?? getSporeConfig();
  const rpc = new RPC(config.ckbNodeUrl);

  // Get cell from rpc
  const cellWithStatus = await getCellWithStatusByOutPoint({
    outPoint,
    rpc,
  });
  if (!cellWithStatus.cell) {
    throw new Error('Cannot find Mutant by OutPoint because target cell was not found');
  }
  if (cellWithStatus.status !== 'live') {
    throw new Error('Cannot find Mutant by OutPoint because target cell is not lived');
  }

  // Check target cell's type script
  const cellType = cellWithStatus.cell.cellOutput.type;
  if (!cellType || !isSporeScriptSupported(config, cellType, 'Mutant')) {
    throw new Error('Cannot find Mutant by OutPoint because target cell is not a supported version of Mutant');
  }

  return cellWithStatus.cell;
}

export async function getMutantById(id: Hash, config?: SporeConfig): Promise<Cell> {
  // Env
  config = config ?? getSporeConfig();

  // Get Mutant script
  const mutantScript = getSporeScriptCategory(config, 'Mutant');
  const scripts = (mutantScript.versions ?? []).map((r) => r.script);

  // Search target cluster proxy from the latest version to the oldest
  const args = bytes.hexify(
    packRawMutantArgs({
      id,
    }),
  );
  for (const script of scripts) {
    try {
      return await getMutantByType(
        {
          ...script,
          args,
        },
        config,
      );
    } catch (e) {
      // Not found in the script, don't have to do anything
      console.error('getMutantById error:', e);
    }
  }

  throw new Error(
    `Cannot find Mutant by ID because target cell does not exist or it's not a supported version of Mutant`,
  );
}


================================================
File: packages/core/src/api/joints/mutant/injectLiveMutantCell.ts
================================================
import { BIish } from '@ckb-lumos/bi';
import { bytes } from '@ckb-lumos/codec';
import { PackedSince } from '@ckb-lumos/base';
import { BI, Cell, helpers, HexString } from '@ckb-lumos/lumos';
import { addCellDep } from '@ckb-lumos/common-scripts/lib/helper';
import { getSporeConfig, getSporeScript, SporeConfig } from '../../../config';
import { assetCellMinimalCapacity, setAbsoluteCapacityMargin, setupCell } from '../../../helpers';
import { packRawMutantArgs, unpackToRawMutantArgs } from '../../../codec';

export async function injectLiveMutantCell(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  cell: Cell;
  minPayment?: BIish;
  addOutput?: boolean;
  updateOutput?: (cell: Cell) => Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  updateWitness?: HexString | ((witness: HexString) => HexString);
  defaultWitness?: HexString;
  since?: PackedSince;
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
  outputIndex: number;
}> {
  // Env
  const mutantCell = props.cell;
  const config = props.config ?? getSporeConfig();

  // Get TransactionSkeleton
  let txSkeleton = props.txSkeleton;

  // Check target cell's type
  const mutantCellType = mutantCell.cellOutput.type;
  const mutantScript = getSporeScript(config, 'Mutant', mutantCellType!);
  if (!mutantCellType || !mutantScript) {
    throw new Error('Cannot inject Mutant because target cell is not a supported version of Mutant');
  }

  // Add Mutant cell to Transaction.inputs
  const setupCellResult = await setupCell({
    txSkeleton,
    input: props.cell,
    config: config.lumos,
    addOutput: props.addOutput,
    updateOutput(cell) {
      if (props.minPayment !== void 0) {
        const unpackedArgs = unpackToRawMutantArgs(cell.cellOutput.type!.args!);
        const newArgs = packRawMutantArgs({
          ...unpackedArgs,
          minPayment: BI.from(props.minPayment),
        });
        cell.cellOutput.type!.args = bytes.hexify(newArgs);
      }
      if (props.capacityMargin !== void 0) {
        cell = setAbsoluteCapacityMargin(cell, props.capacityMargin);
      }
      if (props.updateOutput instanceof Function) {
        cell = props.updateOutput(cell);
      }
      return cell;
    },
    defaultWitness: props.defaultWitness,
    updateWitness: props.updateWitness,
    since: props.since,
  });
  txSkeleton = setupCellResult.txSkeleton;

  // If the Mutant is added to Transaction.outputs
  if (props.addOutput) {
    // Make sure the cell's output has declared enough capacity
    const output = txSkeleton.get('outputs').get(setupCellResult.outputIndex)!;
    assetCellMinimalCapacity(output);

    // Fix the cell's output index
    txSkeleton = txSkeleton.update('fixedEntries', (fixedEntries) => {
      return fixedEntries.push({
        field: 'outputs',
        index: setupCellResult.outputIndex,
      });
    });
  }

  // Add Mutant required cellDeps
  txSkeleton = addCellDep(txSkeleton, mutantScript.cellDep);

  return {
    txSkeleton,
    inputIndex: setupCellResult.inputIndex,
    outputIndex: setupCellResult.outputIndex,
  };
}


================================================
File: packages/core/src/api/joints/mutant/injectLiveMutantReferences.ts
================================================
import { BIish } from '@ckb-lumos/bi';
import { Hash, Script, Cell } from '@ckb-lumos/base';
import { BI, helpers, utils } from '@ckb-lumos/lumos';
import { addCellDep } from '@ckb-lumos/common-scripts/lib/helper';
import { unpackToRawMutantArgs } from '../../../codec';
import { minimalCellCapacityByLock } from '../../../helpers';
import { getSporeConfig, getSporeScript, SporeConfig } from '../../../config';
import { getMutantById } from './getMutant';

export async function injectLiveMutantReferences(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  mutantIds: Hash[] | Hash;
  paymentAmount?: (minPayment: BI, lock: Script, cell: Cell) => BIish;
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  referenceType: 'payment' | 'none';
  payment?: {
    outputIndices: number[];
  };
}> {
  // Env
  const config = props.config ?? getSporeConfig();
  let txSkeleton = props.txSkeleton;

  // Mutant Ids/Cells
  const mutantIds = Array.isArray(props.mutantIds) ? props.mutantIds : [props.mutantIds];
  const mutantCells = await Promise.all(mutantIds.map((id) => getMutantById(id, config)));

  // Payment cell output indices
  const outputIndices: number[] = [];

  /**
   * Minimal payment amounts to each Mutant's lock script
   *
   * Note that this version of "minimalPaymentsMap" logic could need some notes, take an example:
   * - Creating a Spore that references Mutant 1 and Mutant 2
   * - Mutant 1, lock = A, minPayment = 100 CKB
   * - Mutant 2, lock = A, minPayment = 1000 CKB
   * Normally you would expect to pay A 1100 CKB in this transaction:
   * - Minimal payment to A = 100 + 1000 = 1100 CKB
   */
  const minimalPaymentsMap = mutantCells.reduce(
    (sum, mutantCell) => {
      const mutantLock = mutantCell.cellOutput.lock;
      const mutantLockHash = utils.computeScriptHash(mutantLock);
      if (sum[mutantLockHash] === void 0) {
        sum[mutantLockHash] = {
          cell: mutantCell,
          lock: mutantLock,
          minPayment: BI.from(0),
          minLockCapacity: minimalCellCapacityByLock(mutantLock),
        };
      }

      const args = unpackToRawMutantArgs(mutantCell.cellOutput.type!.args);
      const minPayment = args.minPayment !== void 0 ? args.minPayment : BI.from(0);

      // Current logic: max(minPayment1, minPayment2, ...)
      // sum[mutantLockHash].minPayment = sum[mutantLockHash].minPayment.gt(minPayment)
      //   ? sum[mutantLockHash].minPayment
      //   : minPayment;

      // Alternative logic: sum(minPayment1, minPayment2, ...)
      sum[mutantLockHash].minPayment = sum[mutantLockHash].minPayment.add(minPayment);

      return sum;
    },
    {} as Record<
      Hash,
      {
        cell: Cell;
        lock: Script;
        minPayment: BI;
        minLockCapacity: BI;
      }
    >,
  );

  // Create payment cells for referencing the Mutants
  for (const info of Object.values(minimalPaymentsMap)) {
    // If no payment required, skip the Mutant
    if (info.minPayment.eq(0)) {
      continue;
    }

    // Calculate how much to pay to the owner of the Mutant
    const requiredPayment = info.minPayment.gt(info.minLockCapacity) ? info.minPayment : info.minLockCapacity;
    const paymentAmount = BI.from(
      props.paymentAmount ? props.paymentAmount(requiredPayment, info.lock, info.cell) : requiredPayment,
    );
    if (paymentAmount.lt(requiredPayment)) {
      throw new Error(
        `Cannot pay to reference Mutant because paymentAmount is too low, required: ${requiredPayment.toString()}, actual: ${paymentAmount.toString()}`,
      );
    }

    // Generate payment cell to the owner of the Mutant
    const outputIndex = txSkeleton.get('outputs').size;
    txSkeleton = txSkeleton.update('outputs', (outputs) => {
      outputIndices.push(outputIndex);
      return outputs.push({
        cellOutput: {
          capacity: paymentAmount.toHexString(),
          lock: info.lock,
        },
        data: '0x',
      });
    });
    // Fix the payment cell's output index to prevent it from future reduction
    txSkeleton = txSkeleton.update('fixedEntries', (fixedEntries) => {
      return fixedEntries.push({
        field: 'outputs',
        index: outputIndex,
      });
    });
  }

  // Add Mutant's type as cellDep
  const mutantScript = getSporeScript(config, 'Mutant');
  txSkeleton = addCellDep(txSkeleton, mutantScript.cellDep);
  const luaScript = getSporeScript(config, 'Lua');
  txSkeleton = addCellDep(txSkeleton, luaScript.cellDep);

  // Add Mutant cells as cellDeps
  for (const mutantCell of mutantCells) {
    txSkeleton = addCellDep(txSkeleton, {
      outPoint: mutantCell.outPoint!,
      depType: 'code',
    });
  }

  return {
    txSkeleton,
    referenceType: outputIndices.length > 0 ? 'payment' : 'none',
    payment: outputIndices.length > 0 ? { outputIndices } : void 0,
  };
}


================================================
File: packages/core/src/api/joints/mutant/injectNewMutantIds.ts
================================================
import { bytes } from '@ckb-lumos/codec';
import { helpers } from '@ckb-lumos/lumos';
import { generateTypeIdsByOutputs } from '../../../helpers';
import { packRawMutantArgs, unpackToRawMutantArgs } from '../../../codec';
import { getSporeConfig, isSporeScriptSupported, SporeConfig } from '../../../config';

export function injectNewMutantIds(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  outputIndices?: number[];
  config?: SporeConfig;
}): helpers.TransactionSkeletonType {
  // Env
  const config = props.config ?? getSporeConfig();

  // TransactionSkeleton
  let txSkeleton = props.txSkeleton;

  // Get the Transaction.inputs[0]
  const firstInput = txSkeleton.get('inputs').get(0);
  if (!firstInput) {
    throw new Error('Cannot generate Mutant Id because Transaction.inputs[0] does not exist');
  }

  // Generate TypeIds by the output indices
  let outputs = txSkeleton.get('outputs');
  let typeIdGroup = generateTypeIdsByOutputs(firstInput, outputs.toArray(), (cell) => {
    return !!cell.cellOutput.type && isSporeScriptSupported(config, cell.cellOutput.type, 'Mutant');
  });

  // Only keep the TypeIDs corresponding to the specified output indices
  if (props.outputIndices) {
    typeIdGroup = typeIdGroup.filter(([outputIndex]) => {
      const index = props.outputIndices!.findIndex((index) => index === outputIndex);
      return index >= 0;
    });
    if (typeIdGroup.length !== props.outputIndices.length) {
      throw new Error('Cannot generate Mutant Id because outputIndices cannot be fully handled');
    }
  }

  // Update results
  for (const [index, typeId] of typeIdGroup) {
    const output = outputs.get(index);
    if (!output) {
      throw new Error(`Cannot generate Mutant Id because Transaction.outputs[${index}] does not exist`);
    }

    const unpackedArgs = unpackToRawMutantArgs(output.cellOutput.type!.args);
    const packedNewArgs = packRawMutantArgs({
      id: typeId,
      minPayment: unpackedArgs.minPayment,
    });

    output.cellOutput.type!.args = bytes.hexify(packedNewArgs);
    outputs = outputs.set(index, output);
  }

  return txSkeleton.set('outputs', outputs);
}


================================================
File: packages/core/src/api/joints/mutant/injectNewMutantOutput.ts
================================================
import { BIish } from '@ckb-lumos/bi';
import { Script } from '@ckb-lumos/base';
import { bytes, BytesLike } from '@ckb-lumos/codec';
import { BI, Cell, helpers } from '@ckb-lumos/lumos';
import { addCellDep } from '@ckb-lumos/common-scripts/lib/helper';
import { packRawMutantArgs } from '../../../codec';
import { getSporeConfig, getSporeScript, SporeConfig } from '../../../config';
import { correctCellMinimalCapacity, setAbsoluteCapacityMargin } from '../../../helpers';
import { injectNewMutantIds } from './injectNewMutantIds';

export function injectNewMutantOutput(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  minPayment?: BIish;
  data: BytesLike;
  toLock: Script;
  config?: SporeConfig;
  updateOutput?(cell: Cell): Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
}): {
  txSkeleton: helpers.TransactionSkeletonType;
  outputIndex: number;
  hasId: boolean;
} {
  // Env
  const config = props.config ?? getSporeConfig();

  // Get TransactionSkeleton
  let txSkeleton = props.txSkeleton;

  // Create Mutant cell (the latest version)
  const mutantScript = getSporeScript(config, 'Mutant');
  let mutantCell: Cell = correctCellMinimalCapacity({
    cellOutput: {
      capacity: '0x0',
      lock: props.toLock,
      type: {
        ...mutantScript.script,
        args: bytes.hexify(
          packRawMutantArgs({
            id: '0x' + '0'.repeat(64), // Fill 32-byte TypeId placeholder
            minPayment: props.minPayment !== void 0 ? BI.from(props.minPayment) : void 0,
          }),
        ),
      },
    },
    data: bytes.hexify(props.data),
  });

  // Add to Transaction.outputs
  const outputIndex = txSkeleton.get('outputs').size;
  txSkeleton = txSkeleton.update('outputs', (outputs) => {
    if (props.capacityMargin !== void 0) {
      mutantCell = setAbsoluteCapacityMargin(mutantCell, props.capacityMargin);
    }
    if (props.updateOutput instanceof Function) {
      mutantCell = props.updateOutput(mutantCell);
    }
    return outputs.push(mutantCell);
  });

  // Fix the output's index to prevent it from future reduction
  txSkeleton = txSkeleton.update('fixedEntries', (fixedEntries) => {
    return fixedEntries.push({
      field: 'outputs',
      index: outputIndex,
    });
  });

  // Generate ID for the new Mutant if possible
  const firstInput = txSkeleton.get('inputs').first();
  if (firstInput) {
    txSkeleton = injectNewMutantIds({
      outputIndices: [outputIndex],
      txSkeleton,
      config,
    });
  }

  // Add Lua lib script as cellDep
  const luaScript = getSporeScript(config, 'Lua');
  txSkeleton = addCellDep(txSkeleton, luaScript.cellDep);
  // Add Mutant script as cellDep
  txSkeleton = addCellDep(txSkeleton, mutantScript.cellDep);

  return {
    txSkeleton,
    outputIndex,
    hasId: firstInput !== void 0,
  };
}


================================================
File: packages/core/src/api/joints/spore/getSpore.ts
================================================
import { OutPoint, Script } from '@ckb-lumos/base';
import { Cell, HexString, Indexer, RPC } from '@ckb-lumos/lumos';
import { getCellByType, getCellWithStatusByOutPoint, isTypeId } from '../../../helpers';
import { getSporeConfig, getSporeScriptCategory, isSporeScriptSupported, SporeConfig } from '../../../config';

export async function getSporeByType(type: Script, config?: SporeConfig): Promise<Cell> {
  // Env
  config = config ?? getSporeConfig();
  const indexer = new Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);

  // Check if the spore's id is TypeID
  if (!isTypeId(type.args)) {
    throw new Error(`Target Spore ID is invalid: ${type.args}`);
  }

  // Get cell by type
  const cell = await getCellByType({ type, indexer });
  if (cell === void 0) {
    throw new Error('Cannot find Spore by Type because target cell does not exist');
  }

  // Check target cell's type script
  const cellType = cell.cellOutput.type;
  if (!cellType || !isSporeScriptSupported(config, cellType, 'Spore')) {
    throw new Error('Cannot find spore by Type because target cell type is not a supported version of Spore');
  }

  return cell;
}

export async function getSporeByOutPoint(outPoint: OutPoint, config?: SporeConfig): Promise<Cell> {
  // Env
  config = config ?? getSporeConfig();
  const rpc = new RPC(config.ckbNodeUrl);

  // Get cell from rpc
  const cellWithStatus = await getCellWithStatusByOutPoint({ outPoint, rpc });
  if (!cellWithStatus.cell) {
    throw new Error('Cannot find spore by OutPoint because target cell was not found');
  }
  if (cellWithStatus.status !== 'live') {
    throw new Error('Cannot find spore by OutPoint because target cell is not lived');
  }

  // Check target cell's type script
  const cellType = cellWithStatus.cell.cellOutput.type;
  if (!cellType || !isSporeScriptSupported(config, cellType, 'Spore')) {
    throw new Error('Cannot find spore by OutPoint because target cell type is not a supported version of Spore');
  }

  return cellWithStatus.cell;
}

export async function getSporeById(id: HexString, config?: SporeConfig): Promise<Cell> {
  // Env
  config = config ?? getSporeConfig();

  // Check if the spore's id is TypeID
  if (!isTypeId(id)) {
    throw new Error('Cannot find spore because target SporeId is not valid');
  }

  // Get SporeType script
  const sporeScript = getSporeScriptCategory(config, 'Spore');
  const scripts = (sporeScript.versions ?? []).map((r) => r.script);
  const indexer = new Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);

  // Search target spore from the latest version to the oldest
  for (const script of scripts) {
    const cell = await getCellByType({ type: { ...script, args: id }, indexer });
    if (cell !== void 0) {
      return cell;
    }
  }

  throw new Error(
    `Cannot find spore by SporeId because target cell does not exist or it's not a supported version of Spore`,
  );
}


================================================
File: packages/core/src/api/joints/spore/injectLiveSporeCell.ts
================================================
import { BIish } from '@ckb-lumos/bi';
import { PackedSince } from '@ckb-lumos/base';
import { BI, Cell, helpers, HexString, Indexer, Script } from '@ckb-lumos/lumos';
import { addCellDep, parseAddress } from '@ckb-lumos/lumos/helpers';
import {
  decodeContentType,
  getCellByType,
  isContentTypeValid,
  setAbsoluteCapacityMargin,
  setupCell,
} from '../../../helpers';
import { getSporeConfig, getSporeScript, SporeConfig } from '../../../config';
import { unpackToRawSporeData } from '../../../codec';
import { getMutantById } from '../mutant/getMutant';

export async function injectLiveSporeCell(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  cell: Cell;
  addOutput?: boolean;
  updateOutput?: (cell: Cell) => Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  updateWitness?: HexString | ((witness: HexString) => HexString);
  defaultWitness?: HexString;
  since?: PackedSince;
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
  outputIndex: number;
}> {
  // Env
  const config = props.config ?? getSporeConfig();
  const sporeCell = props.cell;

  // Get TransactionSkeleton
  let txSkeleton = props.txSkeleton;

  // Check target cell's type script id
  const sporeType = sporeCell.cellOutput.type;
  const sporeScript = getSporeScript(config, 'Spore', sporeType!);
  if (!sporeType || !sporeScript) {
    throw new Error('Cannot inject live spore because target cell type is not a supported version of Spore');
  }

  // Add spore to Transaction.inputs
  const setupCellResult = await setupCell({
    txSkeleton,
    input: sporeCell,
    addOutput: props.addOutput,
    updateOutput(cell) {
      // May contain code about changing scripts, which causes the change of cell's occupied capacity,
      // so here should be processed at first
      if (props.updateOutput instanceof Function) {
        cell = props.updateOutput(cell);
      }
      if (props.capacityMargin !== void 0) {
        cell = setAbsoluteCapacityMargin(cell, props.capacityMargin);
      }
      return cell;
    },
    defaultWitness: props.defaultWitness,
    updateWitness: props.updateWitness,
    config: config.lumos,
    since: props.since,
  });
  txSkeleton = setupCellResult.txSkeleton;

  // If added to outputs, fix the cell's output index
  if (props.addOutput) {
    txSkeleton = txSkeleton.update('fixedEntries', (fixedEntries) => {
      return fixedEntries.push({
        field: 'outputs',
        index: setupCellResult.outputIndex,
      });
    });
  }

  // Add Spore script as cellDep
  let sporeCelldep = sporeScript.cellDep;
  if (sporeScript.behaviors?.dynamicCelldep) {
    const scriptCell = await getCellByType({
      type: sporeScript.behaviors?.dynamicCelldep,
      indexer: new Indexer(config.ckbIndexerUrl, config.ckbNodeUrl),
    });
    if (scriptCell) {
      sporeCelldep = {
        outPoint: scriptCell.outPoint!,
        depType: 'code',
      };
    }
  }
  txSkeleton = addCellDep(txSkeleton, sporeCelldep);

  // Validate SporeData.contentType
  const sporeData = unpackToRawSporeData(sporeCell.data);
  // note: consider the compatibility of custom spore-like scripts, skip content-type check is allowed
  if (isContentTypeValid(sporeData.contentType)) {
    // Add Mutant cells as cellDeps
    const decodedContentType = decodeContentType(sporeData.contentType);
    if (decodedContentType.parameters.mutant !== void 0) {
      const mutantScript = getSporeScript(config, 'Mutant');
      txSkeleton = addCellDep(txSkeleton, mutantScript.cellDep);

      const mutantParameter = decodedContentType.parameters.mutant;
      const mutantIds = Array.isArray(mutantParameter) ? mutantParameter : [mutantParameter];
      const mutantCells = await Promise.all(mutantIds.map((id) => getMutantById(id, config)));

      for (const mutantCell of mutantCells) {
        txSkeleton = addCellDep(txSkeleton, {
          outPoint: mutantCell.outPoint!,
          depType: 'code',
        });
      }
    }
  }

  return {
    txSkeleton,
    inputIndex: setupCellResult.inputIndex,
    outputIndex: setupCellResult.outputIndex,
  };
}


================================================
File: packages/core/src/api/joints/spore/injectNewSporeIds.ts
================================================
import { helpers } from '@ckb-lumos/lumos';
import { generateTypeIdsByOutputs } from '../../../helpers';
import { getSporeConfig, isSporeScriptSupported, SporeConfig } from '../../../config';

export function injectNewSporeIds(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  outputIndices: number[];
  config?: SporeConfig;
}): helpers.TransactionSkeletonType {
  // Env
  const config = props.config ?? getSporeConfig();

  // Get TransactionSkeleton
  let txSkeleton = props.txSkeleton;

  // Get the first input
  const inputs = txSkeleton.get('inputs');
  const firstInput = inputs.get(0);
  if (!firstInput) {
    throw new Error('Cannot generate Spore Id because Transaction.inputs[0] does not exist');
  }

  // Calculates TypeIds by the outputs' indices
  let outputs = txSkeleton.get('outputs');
  let typeIdGroup = generateTypeIdsByOutputs(firstInput, outputs.toArray(), (cell) => {
    return !!cell.cellOutput.type && isSporeScriptSupported(config, cell.cellOutput.type, 'Spore');
  });

  // If `sporeOutputIndices` is provided, filter the result
  if (props.outputIndices) {
    typeIdGroup = typeIdGroup.filter(([outputIndex]) => {
      const index = props.outputIndices!.findIndex((index) => index === outputIndex);
      return index >= 0;
    });
    if (typeIdGroup.length !== props.outputIndices.length) {
      throw new Error('Cannot generate Spore Id because sporeOutputIndices cannot be fully handled');
    }
  }

  for (const [index, typeId] of typeIdGroup) {
    const output = outputs.get(index);
    if (!output) {
      throw new Error(`Cannot generate Spore Id because Transaction.outputs[${index}] does not exist`);
    }

    output.cellOutput.type!.args = typeId;
    outputs = outputs.set(index, output);
  }

  return txSkeleton.set('outputs', outputs);
}


================================================
File: packages/core/src/api/joints/spore/injectNewSporeOutput.ts
================================================
import { BIish } from '@ckb-lumos/bi';
import { Script } from '@ckb-lumos/base';
import { bytes, BytesLike } from '@ckb-lumos/codec';
import { Address, BI, Cell, Hash, helpers, HexString, Indexer, PackedSince } from '@ckb-lumos/lumos';
import { addCellDep } from '@ckb-lumos/lumos/helpers';
import { packRawSporeData } from '../../../codec';
import { getSporeConfig, getSporeScript, SporeConfig } from '../../../config';
import { EncodableContentType, getCellByType, setContentTypeParameters } from '../../../helpers';
import { correctCellMinimalCapacity, setAbsoluteCapacityMargin } from '../../../helpers';
import { composeInputLocks, composeOutputLocks, decodeContentType, isContentTypeValid } from '../../../helpers';
import { getClusterById } from '../cluster/getCluster';
import { injectLiveClusterReference } from '../cluster/injectLiveClusterReference';
import { injectLiveClusterAgentReference } from '../clusterAgent/injectLiveClusterAgentReference';
import { injectLiveMutantReferences } from '../mutant/injectLiveMutantReferences';
import { injectNewSporeIds } from './injectNewSporeIds';
import { FromInfo } from '@ckb-lumos/lumos/common-scripts';

export interface SporeDataProps {
  contentType: string;
  contentTypeParameters?: EncodableContentType['parameters'];
  content: BytesLike;
  clusterId?: Hash;
}

export async function injectNewSporeOutput(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  data: SporeDataProps;
  toLock: Script;
  fromInfos: FromInfo[];
  extraOutputLocks?: Script[];
  changeAddress?: Address;
  updateOutput?: (cell: Cell) => Cell;
  capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
  cluster?: {
    updateOutput?: (cell: Cell) => Cell;
    capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
    updateWitness?: HexString | ((witness: HexString) => HexString);
    defaultWitness?: HexString;
    since?: PackedSince;
  };
  clusterAgentCell?: Cell;
  clusterAgent?: {
    updateOutput?: (cell: Cell) => Cell;
    capacityMargin?: BIish | ((cell: Cell, margin: BI) => BIish);
    updateWitness?: HexString | ((witness: HexString) => HexString);
    defaultWitness?: HexString;
    since?: PackedSince;
  };
  skipCheckContentType?: boolean;
  mutant?: {
    paymentAmount?: (minPayment: BI, lock: Script, cell: Cell) => BIish;
  };
  config?: SporeConfig;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  outputIndex: number;
  hasId: boolean;
  reference: {
    referenceTarget: 'cluster' | 'clusterAgent' | 'none';
    referenceType?: 'cell' | 'lockProxy';
    cluster?: {
      inputIndex: number;
      outputIndex: number;
    };
    clusterAgent?: {
      inputIndex: number;
      outputIndex: number;
    };
  };
  mutantReference?: {
    referenceType: 'payment' | 'none';
    payment?: {
      outputIndices: number[];
    };
  };
}> {
  // Env
  const config = props.config ?? getSporeConfig();
  const sporeData = props.data;

  // TransactionSkeleton
  let txSkeleton = props.txSkeleton;

  // Check should reference Cluster/ClusterAgent to the transaction
  const referencingCluster = !!sporeData.clusterId && !props.clusterAgentCell;
  const referencingClusterAgent = !!sporeData.clusterId && !!props.clusterAgentCell;

  // If referencing a Cluster, inject the Cluster or its LockProxy as reference
  let injectLiveClusterReferenceResult: Awaited<ReturnType<typeof injectLiveClusterReference>> | undefined;
  const clusterCell = sporeData.clusterId ? await getClusterById(sporeData.clusterId!, config) : void 0;
  if (referencingCluster) {
    injectLiveClusterReferenceResult = await injectLiveClusterReference({
      txSkeleton,
      cell: clusterCell!,
      inputLocks: composeInputLocks({
        fromInfos: props.fromInfos,
        config: config.lumos,
      }),
      outputLocks: composeOutputLocks({
        outputLocks: props.extraOutputLocks ? props.extraOutputLocks!.concat([props.toLock]) : [props.toLock],
        fromInfos: props.fromInfos,
        changeAddress: props.changeAddress,
        config: config.lumos,
      }),
      capacityMargin: props.cluster?.capacityMargin,
      updateOutput: props.cluster?.updateOutput,
      updateWitness: props.cluster?.updateWitness,
      defaultWitness: props.cluster?.defaultWitness,
      since: props.cluster?.since,
      config,
    });
    txSkeleton = injectLiveClusterReferenceResult.txSkeleton;
  }

  // If ClusterAgent is provided, inject the ClusterAgent or its LockProxy as reference
  let injectLiveClusterAgentReferenceResult: Awaited<ReturnType<typeof injectLiveClusterAgentReference>> | undefined;
  if (referencingClusterAgent) {
    injectLiveClusterAgentReferenceResult = await injectLiveClusterAgentReference({
      txSkeleton,
      cell: props.clusterAgentCell!,
      inputLocks: composeInputLocks({
        fromInfos: props.fromInfos,
        config: config.lumos,
      }),
      outputLocks: composeOutputLocks({
        outputLocks: [props.toLock],
        fromInfos: props.fromInfos,
        changeAddress: props.changeAddress,
        config: config.lumos,
      }),
      capacityMargin: props.clusterAgent?.capacityMargin,
      updateOutput: props.clusterAgent?.updateOutput,
      updateWitness: props.clusterAgent?.updateWitness,
      defaultWitness: props.clusterAgent?.defaultWitness,
      since: props.clusterAgent?.since,
      config,
    });
    txSkeleton = injectLiveClusterAgentReferenceResult.txSkeleton;

    // Even if not referencing Cluster, still make sure Cluster related cellDeps are added
    const clusterType = clusterCell!.cellOutput.type;
    const clusterScript = getSporeScript(config, 'Cluster', clusterType!);
    if (!clusterType || !clusterScript) {
      throw new Error('Cannot reference Cluster because target cell is not a supported version of Cluster');
    }
    txSkeleton = addCellDep(txSkeleton, clusterScript.cellDep);
    txSkeleton = addCellDep(txSkeleton, {
      outPoint: clusterCell!.outPoint!,
      depType: 'code',
    });
  }

  // Validate SporeData.contentType
  const contentType = setContentTypeParameters(sporeData.contentType, sporeData.contentTypeParameters ?? {});
  const skipCheckContentType = props.skipCheckContentType ?? false;
  if (!skipCheckContentType && !isContentTypeValid(contentType)) {
    throw new Error(`Spore has specified an invalid data.contentType: ${contentType}`);
  }

  // Create Spore cell (the latest version)
  const sporeScript = getSporeScript(config, 'Spore');
  let sporeCell: Cell = correctCellMinimalCapacity({
    cellOutput: {
      capacity: '0x0',
      lock: props.toLock,
      type: {
        ...sporeScript.script,
        args: '0x' + '0'.repeat(64), // Fill 32-byte TypeId placeholder
      },
    },
    data: bytes.hexify(
      packRawSporeData({
        contentType,
        content: sporeData.content,
        clusterId: sporeData.clusterId,
      }),
    ),
  });

  // Add to Transaction.outputs
  const outputIndex = txSkeleton.get('outputs').size;
  txSkeleton = txSkeleton.update('outputs', (outputs) => {
    if (props.capacityMargin !== void 0) {
      sporeCell = setAbsoluteCapacityMargin(sporeCell, props.capacityMargin);
    }
    if (props.updateOutput instanceof Function) {
      sporeCell = props.updateOutput(sporeCell);
    }
    return outputs.push(sporeCell);
  });

  // Fix the cell's output index to prevent it from future reduction
  txSkeleton = txSkeleton.update('fixedEntries', (fixedEntries) => {
    return fixedEntries.push({
      field: 'outputs',
      index: outputIndex,
    });
  });

  // Generate ID for the new Spore if possible
  const firstInput = txSkeleton.get('inputs').first();
  if (firstInput !== void 0) {
    txSkeleton = injectNewSporeIds({
      outputIndices: [outputIndex],
      txSkeleton,
      config,
    });
  }

  // Inject Mutants as cellDeps, and inject payments if needed
  let injectLiveMutantReferencesResult: Awaited<ReturnType<typeof injectLiveMutantReferences>> | undefined;
  if (!skipCheckContentType) {
    const decodedContentType = decodeContentType(contentType);
    if (decodedContentType.parameters.mutant !== void 0) {
      injectLiveMutantReferencesResult = await injectLiveMutantReferences({
        txSkeleton,
        mutantIds: decodedContentType.parameters.mutant,
        paymentAmount: props.mutant?.paymentAmount,
        config,
      });
      txSkeleton = injectLiveMutantReferencesResult.txSkeleton;
    }
  }

  // Add Spore relevant cellDeps
  let sporeCelldep = sporeScript.cellDep;
  if (sporeScript.behaviors?.dynamicCelldep) {
    const scriptCell = await getCellByType({
      type: sporeScript.behaviors?.dynamicCelldep,
      indexer: new Indexer(config.ckbIndexerUrl, config.ckbNodeUrl),
    });
    if (scriptCell) {
      sporeCelldep = {
        outPoint: scriptCell.outPoint!,
        depType: 'code',
      };
    }
  }
  txSkeleton = addCellDep(txSkeleton, sporeCelldep);

  return {
    txSkeleton,
    outputIndex,
    hasId: firstInput !== void 0,
    reference: {
      referenceTarget: referencingCluster ? 'cluster' : referencingClusterAgent ? 'clusterAgent' : 'none',
      referenceType: referencingCluster
        ? injectLiveClusterReferenceResult!.referenceType
        : referencingClusterAgent
          ? injectLiveClusterAgentReferenceResult!.referenceType
          : void 0,
      cluster: injectLiveClusterReferenceResult?.cluster,
      clusterAgent: injectLiveClusterAgentReferenceResult?.clusterAgent,
    },
    mutantReference: injectLiveMutantReferencesResult
      ? {
          referenceType: injectLiveMutantReferencesResult.referenceType,
          payment: injectLiveMutantReferencesResult.payment,
        }
      : void 0,
  };
}


================================================
File: packages/core/src/cobuild/index.ts
================================================
export * from './base/buildingPacket';
export * from './base/resolvedInputs';
export * from './base/sporeScriptInfo';
export * from './base/witnessLayout';

export * from './codec/buildingPacket';
export * from './codec/witnessLayout';
export * from './codec/sporeAction';

export * from './action/spore/createSpore';
export * from './action/spore/transferSpore';
export * from './action/spore/meltSpore';
export * from './action/cluster/createCluster';
export * from './action/cluster/transferCluster';
export * from './action/cluster/referenceCluster';
export * from './action/clusterProxy/createClusterProxy';
export * from './action/clusterProxy/transferClusterProxy';
export * from './action/clusterProxy/referenceClusterProxy';
export * from './action/clusterProxy/meltClusterProxy';
export * from './action/clusterAgent/createClusterAgent';
export * from './action/clusterAgent/transferClusterAgent';
export * from './action/clusterAgent/referenceClusterAgent';
export * from './action/clusterAgent/meltClusterAgent';


================================================
File: packages/core/src/cobuild/action/cluster/createCluster.ts
================================================
import { Cell, helpers, utils } from '@ckb-lumos/lumos';
import { bytes, UnpackResult } from '@ckb-lumos/codec';
import { SporeAction } from '../../codec/sporeAction';
import { Action, ScriptInfo } from '../../codec/buildingPacket';
import { createRawBuildingPacket } from '../../base/buildingPacket';
import { createSporeScriptInfoFromTemplate } from '../../base/sporeScriptInfo';

export function assembleCreateClusterAction(clusterOutput: Cell | undefined): {
  actions: UnpackResult<typeof Action>[];
  scriptInfos: UnpackResult<typeof ScriptInfo>[];
} {
  const actions: UnpackResult<typeof Action>[] = [];
  const scriptInfos: UnpackResult<typeof ScriptInfo>[] = [];

  const clusterType = clusterOutput!.cellOutput.type!;
  const clusterTypeHash = utils.computeScriptHash(clusterType);
  const scriptInfo = createSporeScriptInfoFromTemplate({
    scriptHash: clusterTypeHash,
  });
  scriptInfos.push(scriptInfo);

  const actionData = SporeAction.pack({
    type: 'CreateCluster',
    value: {
      clusterId: clusterType.args,
      dataHash: utils.ckbHash(clusterOutput!.data),
      to: {
        type: 'Script',
        value: clusterOutput!.cellOutput.lock,
      },
    },
  });
  actions.push({
    scriptInfoHash: utils.ckbHash(ScriptInfo.pack(scriptInfo)),
    scriptHash: clusterTypeHash,
    data: bytes.hexify(actionData),
  });

  return {
    actions,
    scriptInfos,
  };
}

export function generateCreateClusterAction(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  outputIndex: number;
}): {
  actions: UnpackResult<typeof Action>[];
  scriptInfos: UnpackResult<typeof ScriptInfo>[];
} {
  let txSkeleton = props.txSkeleton;
  const clusterOutput = txSkeleton.get('outputs').get(props.outputIndex);
  return assembleCreateClusterAction(clusterOutput);
}

export function generateCreateClusterBuildingPacket(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  outputIndex: number;
}) {
  let txSkeleton = props.txSkeleton;

  const action = generateCreateClusterAction(props);
  return createRawBuildingPacket({
    txSkeleton,
    actions: action.actions,
    scriptInfos: action.scriptInfos,
    changeOutput: txSkeleton.get('outputs').size - 1,
  });
}


================================================
File: packages/core/src/cobuild/action/cluster/referenceCluster.ts
================================================
import { helpers } from '@ckb-lumos/lumos';
import { Action, ScriptInfo } from '../../codec/buildingPacket';
import { generateTransferClusterAction } from './transferCluster';
import { UnpackResult } from '@ckb-lumos/codec';

export function generateReferenceClusterAction(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  referenceType: 'cell' | 'lockProxy';
  cluster?: {
    inputIndex: number;
    outputIndex: number;
  };
}): {
  actions: UnpackResult<typeof Action>[];
  scriptInfos: UnpackResult<typeof ScriptInfo>[];
} {
  if (props.referenceType === 'lockProxy') {
    return {
      actions: [],
      scriptInfos: [],
    };
  }
  if (!props.cluster) {
    throw new Error('Cannot generate TransferCluster Action without cluster info');
  }

  return generateTransferClusterAction({
    txSkeleton: props.txSkeleton,
    inputIndex: props.cluster.inputIndex,
    outputIndex: props.cluster.outputIndex,
  });
}


================================================
File: packages/core/src/cobuild/action/cluster/transferCluster.ts
================================================
import { Cell, helpers, utils } from '@ckb-lumos/lumos';
import { bytes, UnpackResult } from '@ckb-lumos/codec';
import { SporeAction } from '../../codec/sporeAction';
import { Action, ScriptInfo } from '../../codec/buildingPacket';
import { createRawBuildingPacket } from '../../base/buildingPacket';
import { createSporeScriptInfoFromTemplate } from '../../base/sporeScriptInfo';

export function assembleTransferClusterAction(
  clusterInput: Cell | undefined,
  clusterOutput: Cell | undefined,
): {
  actions: UnpackResult<typeof Action>[];
  scriptInfos: UnpackResult<typeof ScriptInfo>[];
} {
  const actions: UnpackResult<typeof Action>[] = [];
  const scriptInfos: UnpackResult<typeof ScriptInfo>[] = [];

  const clusterType = clusterOutput!.cellOutput.type!;
  const clusterTypeHash = utils.computeScriptHash(clusterType);
  const scriptInfo = createSporeScriptInfoFromTemplate({
    scriptHash: clusterTypeHash,
  });
  scriptInfos.push(scriptInfo);

  const actionData = SporeAction.pack({
    type: 'TransferCluster',
    value: {
      clusterId: clusterType.args,
      from: {
        type: 'Script',
        value: clusterInput!.cellOutput.lock,
      },
      to: {
        type: 'Script',
        value: clusterOutput!.cellOutput.lock,
      },
    },
  });
  actions.push({
    scriptInfoHash: utils.ckbHash(ScriptInfo.pack(scriptInfo)),
    scriptHash: clusterTypeHash,
    data: bytes.hexify(actionData),
  });

  return {
    actions,
    scriptInfos,
  };
}

export function generateTransferClusterAction(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
  outputIndex: number;
}): {
  actions: UnpackResult<typeof Action>[];
  scriptInfos: UnpackResult<typeof ScriptInfo>[];
} {
  let txSkeleton = props.txSkeleton;
  const clusterInput = txSkeleton.get('inputs').get(props.inputIndex);
  const clusterOutput = txSkeleton.get('outputs').get(props.outputIndex);
  return assembleTransferClusterAction(clusterInput, clusterOutput);
}

export function generateTransferClusterBuildingPacket(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
  outputIndex: number;
  useCapacityMarginAsFee: boolean;
}) {
  let txSkeleton = props.txSkeleton;

  const action = generateTransferClusterAction(props);
  return createRawBuildingPacket({
    txSkeleton,
    actions: action.actions,
    scriptInfos: action.scriptInfos,
    changeOutput: props.useCapacityMarginAsFee ? props.outputIndex : txSkeleton.get('outputs').size - 1,
  });
}


================================================
File: packages/core/src/cobuild/action/clusterAgent/createClusterAgent.ts
================================================
import { helpers, utils } from '@ckb-lumos/lumos';
import { bytes, UnpackResult } from '@ckb-lumos/codec';
import { SporeAction } from '../../codec/sporeAction';
import { injectNewClusterAgentOutput } from '../../../api';
import { Action, ScriptInfo } from '../../codec/buildingPacket';
import { createRawBuildingPacket } from '../../base/buildingPacket';
import { createSporeScriptInfoFromTemplate } from '../../base/sporeScriptInfo';
import { generateReferenceClusterProxyAction } from '../clusterProxy/referenceClusterProxy';
import { Hash } from '@ckb-lumos/base';

export function generateCreateClusterAgentAction(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  outputIndex: number;
  clusterProxyId: Hash;
  reference: Awaited<ReturnType<typeof injectNewClusterAgentOutput>>['reference'];
}): {
  actions: UnpackResult<typeof Action>[];
  scriptInfos: UnpackResult<typeof ScriptInfo>[];
} {
  const actions: UnpackResult<typeof Action>[] = [];
  const scriptInfos: UnpackResult<typeof ScriptInfo>[] = [];

  let txSkeleton = props.txSkeleton;
  const clusterOutput = txSkeleton.get('outputs').get(props.outputIndex);

  const clusterAgentType = clusterOutput!.cellOutput.type!;
  const clusterAgentTypeHash = utils.computeScriptHash(clusterAgentType);
  const scriptInfo = createSporeScriptInfoFromTemplate({
    scriptHash: clusterAgentTypeHash,
  });
  scriptInfos.push(scriptInfo);

  const actionData = SporeAction.pack({
    type: 'CreateClusterAgent',
    value: {
      clusterId: clusterAgentType.args,
      clusterProxyId: props.clusterProxyId,
      to: {
        type: 'Script',
        value: clusterOutput!.cellOutput.lock,
      },
    },
  });
  actions.push({
    scriptInfoHash: utils.ckbHash(ScriptInfo.pack(scriptInfo)),
    scriptHash: clusterAgentTypeHash,
    data: bytes.hexify(actionData),
  });

  const clusterAction = generateReferenceClusterProxyAction({
    txSkeleton,
    referenceType: props.reference.referenceType,
    clusterProxy: props.reference.clusterProxy,
  });
  actions.push(...clusterAction.actions);
  scriptInfos.push(...clusterAction.scriptInfos);

  return {
    actions,
    scriptInfos,
  };
}

export function generateCreateClusterAgentBuildingPacket(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  outputIndex: number;
  clusterProxyId: Hash;
  reference: Awaited<ReturnType<typeof injectNewClusterAgentOutput>>['reference'];
}) {
  let txSkeleton = props.txSkeleton;

  const action = generateCreateClusterAgentAction(props);
  return createRawBuildingPacket({
    txSkeleton,
    actions: action.actions,
    scriptInfos: action.scriptInfos,
    changeOutput: txSkeleton.get('outputs').size - 1,
  });
}


================================================
File: packages/core/src/cobuild/action/clusterAgent/meltClusterAgent.ts
================================================
import { helpers, utils } from '@ckb-lumos/lumos';
import { bytes, UnpackResult } from '@ckb-lumos/codec';
import { SporeAction } from '../../codec/sporeAction';
import { Action, ScriptInfo } from '../../codec/buildingPacket';
import { createRawBuildingPacket } from '../../base/buildingPacket';
import { createSporeScriptInfoFromTemplate } from '../../base/sporeScriptInfo';

export function generateMeltClusterAgentAction(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
}): {
  actions: UnpackResult<typeof Action>[];
  scriptInfos: UnpackResult<typeof ScriptInfo>[];
} {
  const actions: UnpackResult<typeof Action>[] = [];
  const scriptInfos: UnpackResult<typeof ScriptInfo>[] = [];

  let txSkeleton = props.txSkeleton;
  const clusterAgentInput = txSkeleton.get('inputs').get(props.inputIndex);

  const clusterAgentType = clusterAgentInput!.cellOutput.type!;
  const clusterAgentTypeHash = utils.computeScriptHash(clusterAgentType);
  const scriptInfo = createSporeScriptInfoFromTemplate({
    scriptHash: clusterAgentTypeHash,
  });
  scriptInfos.push(scriptInfo);

  const actionData = SporeAction.pack({
    type: 'MeltClusterAgent',
    value: {
      clusterId: clusterAgentInput!.cellOutput.type!.args,
      from: {
        type: 'Script',
        value: clusterAgentInput!.cellOutput.lock,
      },
    },
  });
  actions.push({
    scriptInfoHash: utils.ckbHash(ScriptInfo.pack(scriptInfo)),
    scriptHash: clusterAgentTypeHash,
    data: bytes.hexify(actionData),
  });

  return {
    actions,
    scriptInfos,
  };
}

export function generateMeltClusterAgentBuildingPacket(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
}) {
  let txSkeleton = props.txSkeleton;

  const action = generateMeltClusterAgentAction(props);
  return createRawBuildingPacket({
    txSkeleton,
    actions: action.actions,
    scriptInfos: action.scriptInfos,
    changeOutput: txSkeleton.get('outputs').size - 1,
  });
}


================================================
File: packages/core/src/cobuild/action/clusterAgent/referenceClusterAgent.ts
================================================
import { helpers } from '@ckb-lumos/lumos';
import { UnpackResult } from '@ckb-lumos/codec';
import { Action, ScriptInfo } from '../../codec/buildingPacket';
import { generateTransferClusterAgentAction } from './transferClusterAgent';

export function generateReferenceClusterAgentAction(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  referenceType: 'cell' | 'lockProxy';
  clusterAgent?: {
    inputIndex: number;
    outputIndex: number;
  };
}): {
  actions: UnpackResult<typeof Action>[];
  scriptInfos: UnpackResult<typeof ScriptInfo>[];
} {
  if (props.referenceType === 'lockProxy') {
    return {
      actions: [],
      scriptInfos: [],
    };
  }
  if (!props.clusterAgent) {
    throw new Error('Cannot generate TransferClusterAgent Action without clusterAgent info');
  }

  return generateTransferClusterAgentAction({
    txSkeleton: props.txSkeleton,
    inputIndex: props.clusterAgent.inputIndex,
    outputIndex: props.clusterAgent.outputIndex,
  });
}


================================================
File: packages/core/src/cobuild/action/clusterAgent/transferClusterAgent.ts
================================================
import { helpers, utils } from '@ckb-lumos/lumos';
import { bytes, UnpackResult } from '@ckb-lumos/codec';
import { SporeAction } from '../../codec/sporeAction';
import { Action, ScriptInfo } from '../../codec/buildingPacket';
import { createRawBuildingPacket } from '../../base/buildingPacket';
import { createSporeScriptInfoFromTemplate } from '../../base/sporeScriptInfo';

export function generateTransferClusterAgentAction(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
  outputIndex: number;
}): {
  actions: UnpackResult<typeof Action>[];
  scriptInfos: UnpackResult<typeof ScriptInfo>[];
} {
  const actions: UnpackResult<typeof Action>[] = [];
  const scriptInfos: UnpackResult<typeof ScriptInfo>[] = [];

  let txSkeleton = props.txSkeleton;
  const clusterAgentInput = txSkeleton.get('inputs').get(props.inputIndex);
  const clusterAgentOutput = txSkeleton.get('outputs').get(props.outputIndex);

  const clusterAgentType = clusterAgentOutput!.cellOutput.type!;
  const clusterAgentTypeHash = utils.computeScriptHash(clusterAgentType);
  const scriptInfo = createSporeScriptInfoFromTemplate({
    scriptHash: clusterAgentTypeHash,
  });
  scriptInfos.push(scriptInfo);

  const actionData = SporeAction.pack({
    type: 'TransferClusterAgent',
    value: {
      clusterId: clusterAgentType.args.slice(0, 66),
      from: {
        type: 'Script',
        value: clusterAgentInput!.cellOutput.lock,
      },
      to: {
        type: 'Script',
        value: clusterAgentOutput!.cellOutput.lock,
      },
    },
  });
  actions.push({
    scriptInfoHash: utils.ckbHash(ScriptInfo.pack(scriptInfo)),
    scriptHash: clusterAgentTypeHash,
    data: bytes.hexify(actionData),
  });

  return {
    actions,
    scriptInfos,
  };
}

export function generateTransferClusterAgentBuildingPacket(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
  outputIndex: number;
  useCapacityMarginAsFee: boolean;
}) {
  let txSkeleton = props.txSkeleton;

  const action = generateTransferClusterAgentAction(props);
  return createRawBuildingPacket({
    txSkeleton,
    actions: action.actions,
    scriptInfos: action.scriptInfos,
    changeOutput: props.useCapacityMarginAsFee ? props.outputIndex : txSkeleton.get('outputs').size - 1,
  });
}


================================================
File: packages/core/src/cobuild/action/clusterProxy/createClusterProxy.ts
================================================
import { helpers, utils } from '@ckb-lumos/lumos';
import { bytes, UnpackResult } from '@ckb-lumos/codec';
import { injectNewClusterProxyOutput } from '../../../api';
import { SporeAction } from '../../codec/sporeAction';
import { Action, ScriptInfo } from '../../codec/buildingPacket';
import { createRawBuildingPacket } from '../../base/buildingPacket';
import { createSporeScriptInfoFromTemplate } from '../../base/sporeScriptInfo';
import { generateReferenceClusterAction } from '../cluster/referenceCluster';
import { unpackToRawClusterProxyArgs } from '../../../codec';

export function generateCreateClusterProxyAction(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  outputIndex: number;
  reference: Awaited<ReturnType<typeof injectNewClusterProxyOutput>>['reference'];
}): {
  actions: UnpackResult<typeof Action>[];
  scriptInfos: UnpackResult<typeof ScriptInfo>[];
} {
  const actions: UnpackResult<typeof Action>[] = [];
  const scriptInfos: UnpackResult<typeof ScriptInfo>[] = [];

  let txSkeleton = props.txSkeleton;
  const clusterProxyOutput = txSkeleton.get('outputs').get(props.outputIndex);

  const clusterProxyType = clusterProxyOutput!.cellOutput.type!;
  const clusterProxyTypeHash = utils.computeScriptHash(clusterProxyType);
  const scriptInfo = createSporeScriptInfoFromTemplate({
    scriptHash: clusterProxyTypeHash,
  });
  scriptInfos.push(scriptInfo);

  const actionData = SporeAction.pack({
    type: 'CreateClusterProxy',
    value: {
      clusterId: clusterProxyOutput!.data,
      clusterProxyId: unpackToRawClusterProxyArgs(clusterProxyType.args).id,
      to: {
        type: 'Script',
        value: clusterProxyOutput!.cellOutput.lock,
      },
    },
  });
  actions.push({
    scriptInfoHash: utils.ckbHash(ScriptInfo.pack(scriptInfo)),
    scriptHash: clusterProxyTypeHash,
    data: bytes.hexify(actionData),
  });

  const clusterAction = generateReferenceClusterAction({
    txSkeleton,
    referenceType: props.reference.referenceType,
    cluster: props.reference.cluster,
  });
  actions.push(...clusterAction.actions);
  scriptInfos.push(...clusterAction.scriptInfos);

  return {
    actions,
    scriptInfos,
  };
}

export function generateCreateClusterProxyBuildingPacket(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  outputIndex: number;
  reference: Awaited<ReturnType<typeof injectNewClusterProxyOutput>>['reference'];
}) {
  let txSkeleton = props.txSkeleton;

  const action = generateCreateClusterProxyAction(props);
  return createRawBuildingPacket({
    txSkeleton,
    actions: action.actions,
    scriptInfos: action.scriptInfos,
    changeOutput: txSkeleton.get('outputs').size - 1,
  });
}


================================================
File: packages/core/src/cobuild/action/clusterProxy/meltClusterProxy.ts
================================================
import { helpers, utils } from '@ckb-lumos/lumos';
import { bytes, UnpackResult } from '@ckb-lumos/codec';
import { SporeAction } from '../../codec/sporeAction';
import { Action, ScriptInfo } from '../../codec/buildingPacket';
import { createRawBuildingPacket } from '../../base/buildingPacket';
import { createSporeScriptInfoFromTemplate } from '../../base/sporeScriptInfo';
import { unpackToRawClusterProxyArgs } from '../../../codec';

export function generateMeltClusterProxyAction(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
}): {
  actions: UnpackResult<typeof Action>[];
  scriptInfos: UnpackResult<typeof ScriptInfo>[];
} {
  const actions: UnpackResult<typeof Action>[] = [];
  const scriptInfos: UnpackResult<typeof ScriptInfo>[] = [];

  let txSkeleton = props.txSkeleton;
  const clusterProxyInput = txSkeleton.get('inputs').get(props.inputIndex);

  const clusterProxyType = clusterProxyInput!.cellOutput.type!;
  const clusterProxyTypeHash = utils.computeScriptHash(clusterProxyType);
  const scriptInfo = createSporeScriptInfoFromTemplate({
    scriptHash: clusterProxyTypeHash,
  });
  scriptInfos.push(scriptInfo);

  const actionData = SporeAction.pack({
    type: 'MeltClusterProxy',
    value: {
      clusterId: clusterProxyInput!.data,
      clusterProxyId: unpackToRawClusterProxyArgs(clusterProxyType.args).id,
      from: {
        type: 'Script',
        value: clusterProxyInput!.cellOutput.lock,
      },
    },
  });
  actions.push({
    scriptInfoHash: utils.ckbHash(ScriptInfo.pack(scriptInfo)),
    scriptHash: clusterProxyTypeHash,
    data: bytes.hexify(actionData),
  });

  return {
    actions,
    scriptInfos,
  };
}

export function generateMeltClusterProxyBuildingPacket(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
}) {
  let txSkeleton = props.txSkeleton;

  const action = generateMeltClusterProxyAction(props);
  return createRawBuildingPacket({
    txSkeleton,
    actions: action.actions,
    scriptInfos: action.scriptInfos,
    changeOutput: txSkeleton.get('outputs').size - 1,
  });
}


================================================
File: packages/core/src/cobuild/action/clusterProxy/referenceClusterProxy.ts
================================================
import { helpers } from '@ckb-lumos/lumos';
import { UnpackResult } from '@ckb-lumos/codec';
import { Action, ScriptInfo } from '../../codec/buildingPacket';
import { generateTransferClusterProxyAction } from './transferClusterProxy';

export function generateReferenceClusterProxyAction(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  referenceType: 'payment' | 'cell';
  clusterProxy?: {
    inputIndex: number;
    outputIndex: number;
  };
}): {
  actions: UnpackResult<typeof Action>[];
  scriptInfos: UnpackResult<typeof ScriptInfo>[];
} {
  if (props.referenceType === 'payment') {
    return {
      actions: [],
      scriptInfos: [],
    };
  }
  if (!props.clusterProxy) {
    throw new Error('Cannot generate TransferClusterProxy Action without clusterProxy info');
  }

  return generateTransferClusterProxyAction({
    txSkeleton: props.txSkeleton,
    inputIndex: props.clusterProxy.inputIndex,
    outputIndex: props.clusterProxy.outputIndex,
  });
}


================================================
File: packages/core/src/cobuild/action/clusterProxy/transferClusterProxy.ts
================================================
import { helpers, utils } from '@ckb-lumos/lumos';
import { bytes, UnpackResult } from '@ckb-lumos/codec';
import { SporeAction } from '../../codec/sporeAction';
import { Action, ScriptInfo } from '../../codec/buildingPacket';
import { createRawBuildingPacket } from '../../base/buildingPacket';
import { createSporeScriptInfoFromTemplate } from '../../base/sporeScriptInfo';
import { unpackToRawClusterProxyArgs } from '../../../codec';

export function generateTransferClusterProxyAction(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
  outputIndex: number;
}): {
  actions: UnpackResult<typeof Action>[];
  scriptInfos: UnpackResult<typeof ScriptInfo>[];
} {
  const actions: UnpackResult<typeof Action>[] = [];
  const scriptInfos: UnpackResult<typeof ScriptInfo>[] = [];

  let txSkeleton = props.txSkeleton;
  const clusterProxyInput = txSkeleton.get('inputs').get(props.inputIndex);
  const clusterProxyOutput = txSkeleton.get('outputs').get(props.outputIndex);

  const clusterProxyType = clusterProxyOutput!.cellOutput.type!;
  const clusterProxyTypeHash = utils.computeScriptHash(clusterProxyType);
  const scriptInfo = createSporeScriptInfoFromTemplate({
    scriptHash: clusterProxyTypeHash,
  });
  scriptInfos.push(scriptInfo);

  const actionData = SporeAction.pack({
    type: 'TransferClusterProxy',
    value: {
      clusterId: clusterProxyOutput!.data,
      clusterProxyId: unpackToRawClusterProxyArgs(clusterProxyType.args).id,
      from: {
        type: 'Script',
        value: clusterProxyInput!.cellOutput.lock,
      },
      to: {
        type: 'Script',
        value: clusterProxyOutput!.cellOutput.lock,
      },
    },
  });
  actions.push({
    scriptInfoHash: utils.ckbHash(ScriptInfo.pack(scriptInfo)),
    scriptHash: clusterProxyTypeHash,
    data: bytes.hexify(actionData),
  });

  return {
    actions,
    scriptInfos,
  };
}

export function generateTransferClusterProxyBuildingPacket(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
  outputIndex: number;
  useCapacityMarginAsFee: boolean;
}) {
  let txSkeleton = props.txSkeleton;

  const action = generateTransferClusterProxyAction(props);
  return createRawBuildingPacket({
    txSkeleton,
    actions: action.actions,
    scriptInfos: action.scriptInfos,
    changeOutput: props.useCapacityMarginAsFee ? props.outputIndex : txSkeleton.get('outputs').size - 1,
  });
}


================================================
File: packages/core/src/cobuild/action/spore/createSpore.ts
================================================
import { Cell, helpers, utils } from '@ckb-lumos/lumos';
import { bytes, UnpackResult } from '@ckb-lumos/codec';
import { injectNewSporeOutput } from '../../../api';
import { SporeAction } from '../../codec/sporeAction';
import { Action, ScriptInfo } from '../../codec/buildingPacket';
import { createRawBuildingPacket } from '../../base/buildingPacket';
import { createSporeScriptInfoFromTemplate } from '../../base/sporeScriptInfo';
import { generateReferenceClusterAction } from '../cluster/referenceCluster';
import { generateReferenceClusterAgentAction } from '../clusterAgent/referenceClusterAgent';

export function assembleCreateSporeAction(sporeOutput: Cell | undefined): {
  actions: UnpackResult<typeof Action>[];
  scriptInfos: UnpackResult<typeof ScriptInfo>[];
} {
  const actions: UnpackResult<typeof Action>[] = [];
  const scriptInfos: UnpackResult<typeof ScriptInfo>[] = [];

  const sporeType = sporeOutput!.cellOutput.type!;
  const sporeTypeHash = utils.computeScriptHash(sporeType);
  const scriptInfo = createSporeScriptInfoFromTemplate({
    scriptHash: sporeTypeHash,
  });
  scriptInfos.push(scriptInfo);

  const actionData = SporeAction.pack({
    type: 'CreateSpore',
    value: {
      sporeId: sporeType.args,
      dataHash: utils.ckbHash(sporeOutput!.data),
      to: {
        type: 'Script',
        value: sporeOutput!.cellOutput.lock,
      },
    },
  });
  actions.push({
    scriptInfoHash: utils.ckbHash(ScriptInfo.pack(scriptInfo)),
    scriptHash: sporeTypeHash,
    data: bytes.hexify(actionData),
  });

  return {
    actions,
    scriptInfos,
  };
}

export function generateCreateSporeAction(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  outputIndex: number;
  reference: Awaited<ReturnType<typeof injectNewSporeOutput>>['reference'];
}): {
  actions: UnpackResult<typeof Action>[];
  scriptInfos: UnpackResult<typeof ScriptInfo>[];
} {
  let txSkeleton = props.txSkeleton;
  const sporeOutput = txSkeleton.get('outputs').get(props.outputIndex);
  let { actions, scriptInfos } = assembleCreateSporeAction(sporeOutput);

  if (props.reference.referenceTarget === 'clusterAgent') {
    const clusterAction = generateReferenceClusterAgentAction({
      txSkeleton,
      referenceType: props.reference.referenceType!,
      clusterAgent: props.reference.clusterAgent,
    });

    actions.push(...clusterAction.actions);
    scriptInfos.push(...clusterAction.scriptInfos);
  }
  if (props.reference.referenceTarget === 'cluster') {
    const clusterAction = generateReferenceClusterAction({
      txSkeleton,
      referenceType: props.reference.referenceType!,
      cluster: props.reference.cluster,
    });

    actions.push(...clusterAction.actions);
    scriptInfos.push(...clusterAction.scriptInfos);
  }

  return {
    actions,
    scriptInfos,
  };
}

export function generateCreateSporeBuildingPacket(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  outputIndex: number;
  reference: Awaited<ReturnType<typeof injectNewSporeOutput>>['reference'];
}) {
  let txSkeleton = props.txSkeleton;

  const action = generateCreateSporeAction(props);
  return createRawBuildingPacket({
    txSkeleton,
    actions: action.actions,
    scriptInfos: action.scriptInfos,
    changeOutput: txSkeleton.get('outputs').size - 1,
  });
}


================================================
File: packages/core/src/cobuild/action/spore/meltSpore.ts
================================================
import { Cell, helpers, utils } from '@ckb-lumos/lumos';
import { bytes, UnpackResult } from '@ckb-lumos/codec';
import { SporeAction } from '../../codec/sporeAction';
import { Action, ScriptInfo } from '../../codec/buildingPacket';
import { createRawBuildingPacket } from '../../base/buildingPacket';
import { createSporeScriptInfoFromTemplate } from '../../base/sporeScriptInfo';

export function assembleMeltSporeAction(sporeInput: Cell | undefined): {
  actions: UnpackResult<typeof Action>[];
  scriptInfos: UnpackResult<typeof ScriptInfo>[];
} {
  const actions: UnpackResult<typeof Action>[] = [];
  const scriptInfos: UnpackResult<typeof ScriptInfo>[] = [];

  const sporeType = sporeInput!.cellOutput.type!;
  const sporeTypeHash = utils.computeScriptHash(sporeType);
  const scriptInfo = createSporeScriptInfoFromTemplate({
    scriptHash: sporeTypeHash,
  });
  scriptInfos.push(scriptInfo);

  const actionData = SporeAction.pack({
    type: 'MeltSpore',
    value: {
      sporeId: sporeType.args,
      from: {
        type: 'Script',
        value: sporeInput!.cellOutput.lock,
      },
    },
  });
  actions.push({
    scriptInfoHash: utils.ckbHash(ScriptInfo.pack(scriptInfo)),
    scriptHash: sporeTypeHash,
    data: bytes.hexify(actionData),
  });

  return {
    actions,
    scriptInfos,
  };
}

export function generateMeltSporeAction(props: { txSkeleton: helpers.TransactionSkeletonType; inputIndex: number }): {
  actions: UnpackResult<typeof Action>[];
  scriptInfos: UnpackResult<typeof ScriptInfo>[];
} {
  let txSkeleton = props.txSkeleton;
  const sporeInput = txSkeleton.get('inputs').get(props.inputIndex);
  return assembleMeltSporeAction(sporeInput);
}

export function generateMeltSporeBuildingPacket(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
}) {
  let txSkeleton = props.txSkeleton;

  const action = generateMeltSporeAction(props);
  return createRawBuildingPacket({
    txSkeleton,
    actions: action.actions,
    scriptInfos: action.scriptInfos,
    changeOutput: txSkeleton.get('outputs').size - 1,
  });
}


================================================
File: packages/core/src/cobuild/action/spore/transferSpore.ts
================================================
import { Cell, helpers, utils } from '@ckb-lumos/lumos';
import { bytes, UnpackResult } from '@ckb-lumos/codec';
import { SporeAction } from '../../codec/sporeAction';
import { Action, ScriptInfo } from '../../codec/buildingPacket';
import { createRawBuildingPacket } from '../../base/buildingPacket';
import { createSporeScriptInfoFromTemplate } from '../../base/sporeScriptInfo';

export function assembleTransferSporeAction(
  sporeInput: Cell | undefined,
  sporeOutput: Cell | undefined,
): {
  actions: UnpackResult<typeof Action>[];
  scriptInfos: UnpackResult<typeof ScriptInfo>[];
} {
  const actions: UnpackResult<typeof Action>[] = [];
  const scriptInfos: UnpackResult<typeof ScriptInfo>[] = [];

  const sporeType = sporeOutput!.cellOutput.type!;
  const sporeTypeHash = utils.computeScriptHash(sporeType);
  const scriptInfo = createSporeScriptInfoFromTemplate({
    scriptHash: sporeTypeHash,
  });
  scriptInfos.push(scriptInfo);

  const actionData = SporeAction.pack({
    type: 'TransferSpore',
    value: {
      sporeId: sporeType.args,
      from: {
        type: 'Script',
        value: sporeInput!.cellOutput.lock,
      },
      to: {
        type: 'Script',
        value: sporeOutput!.cellOutput.lock,
      },
    },
  });
  actions.push({
    scriptInfoHash: utils.ckbHash(ScriptInfo.pack(scriptInfo)),
    scriptHash: sporeTypeHash,
    data: bytes.hexify(actionData),
  });

  return {
    actions,
    scriptInfos,
  };
}

export function generateTransferSporeAction(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
  outputIndex: number;
}): {
  actions: UnpackResult<typeof Action>[];
  scriptInfos: UnpackResult<typeof ScriptInfo>[];
} {
  let txSkeleton = props.txSkeleton;
  const sporeInput = txSkeleton.get('inputs').get(props.inputIndex);
  const sporeOutput = txSkeleton.get('outputs').get(props.outputIndex);
  return assembleTransferSporeAction(sporeInput, sporeOutput);
}

export function generateTransferSporeBuildingPacket(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
  outputIndex: number;
  useCapacityMarginAsFee: boolean;
}) {
  let txSkeleton = props.txSkeleton;

  const action = generateTransferSporeAction(props);
  return createRawBuildingPacket({
    txSkeleton,
    actions: action.actions,
    scriptInfos: action.scriptInfos,
    changeOutput: props.useCapacityMarginAsFee ? props.outputIndex : txSkeleton.get('outputs').size - 1,
  });
}


================================================
File: packages/core/src/cobuild/base/buildingPacket.ts
================================================
import { helpers } from '@ckb-lumos/lumos';
import { UnpackResult } from '@ckb-lumos/codec';
import { ActionVec, BuildingPacket, ScriptInfoVec } from '../codec/buildingPacket';
import { inputCellsToResolvedInputs } from './resolvedInputs';

export function createRawBuildingPacket(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  scriptInfos?: UnpackResult<typeof ScriptInfoVec>;
  actions?: UnpackResult<typeof ActionVec>;
  changeOutput?: number;
}): UnpackResult<typeof BuildingPacket> {
  const txSkeleton = props.txSkeleton;
  return {
    type: 'BuildingPacketV1',
    value: {
      message: {
        actions: props.actions ?? [],
      },
      payload: helpers.createTransactionFromSkeleton(txSkeleton),
      resolvedInputs: inputCellsToResolvedInputs(txSkeleton.get('inputs')),
      changeOutput: props.changeOutput ?? txSkeleton.get('outputs').size - 1,
      scriptInfos: props.scriptInfos ?? [],
      lockActions: [],
    },
  };
}


================================================
File: packages/core/src/cobuild/base/resolvedInputs.ts
================================================
import { List } from 'immutable';
import { Cell, Input } from '@ckb-lumos/lumos';
import { UnpackResult } from '@ckb-lumos/codec';
import { ResolvedInputs } from '../codec/buildingPacket';

export function inputCellsToResolvedInputs(
  inputs: List<Cell>,
  filter?: (value: Cell, index: number, iter: List<Cell>) => boolean,
): UnpackResult<typeof ResolvedInputs> {
  if (filter instanceof Function) {
    inputs = inputs.filter(filter);
  }

  return inputs.reduce<UnpackResult<typeof ResolvedInputs>>(
    (sum, input) => {
      sum.outputs.push(input.cellOutput);
      sum.outputsData.push(input.data);
      return sum;
    },
    {
      outputs: [],
      outputsData: [],
    },
  );
}

export function resolvedInputsToInputCells(
  inputs: Input[],
  resolvedInputs: UnpackResult<typeof ResolvedInputs>,
): Cell[] {
  return inputs.map((input, index) => {
    return {
      cellOutput: resolvedInputs.outputs[index],
      data: resolvedInputs.outputsData[index],
      outPoint: input.previousOutput,
    };
  });
}


================================================
File: packages/core/src/cobuild/base/sporeScriptInfo.ts
================================================
import { Hash } from '@ckb-lumos/base';
import { UnpackResult } from '@ckb-lumos/codec';
import { PackParam } from '@ckb-lumos/codec/src/base';
import { ScriptInfo } from '../codec/buildingPacket';

export const sporeScriptInfoMessageType = 'SporeAction';

export const sporeScriptInfoSchema = `
array Byte32 [byte; 32];
vector Bytes <byte>;

table Script {
    code_hash: Byte32,
    hash_type: byte,
    args: Bytes,
}

union Address {
    Script,
}

/* Actions for Spore */

table MintSpore {
    spore_id: Byte32,
    to: Address,
    data_hash: Byte32,
}

table TransferSpore {
    spore_id: Byte32,
    from: Address,
    to: Address,
}

table BurnSpore {
    spore_id: Byte32,
    from: Address,
}

/* Actions for Cluster */

table MintCluster {
    cluster_id: Byte32,
    to: Address,
    data_hash: Byte32,
}

table TransferCluster {
    cluster_id: Byte32,
    from: Address,
    to: Address,
}

/* Actions for Cluster/Proxy */

table MintProxy {
    cluster_id: Byte32,
    proxy_id: Byte32,
    to: Address,
}

table TransferProxy {
    cluster_id: Byte32,
    proxy_id: Byte32,
    from: Address,
    to: Address,
}

table BurnProxy {
    cluster_id: Byte32,
    proxy_id: Byte32,
    from: Address,
}

/* Actions for Cluster/Agent */

table MintAgent {
    cluster_id: Byte32,
    proxy_id: Byte32,
    to: Address,
}

table TransferAgent {
    cluster_id: Byte32,
    from: Address,
    to: Address,
}

table BurnAgent {
    cluster_id: Byte32,
    from: Address,
}

/* Action in ScriptInfo */

union SporeAction {
    MintSpore,
    TransferSpore,
    BurnSpore,

    MintCluster,
    TransferCluster,

    MintProxy,
    TransferProxy,
    BurnProxy,

    MintAgent,
    TransferAgent,
    BurnAgent,
}
`;

export const sporeScriptInfoTemplate: Omit<PackParam<typeof ScriptInfo>, 'scriptHash'> = {
  name: 'spore',
  url: 'https://spore.pro',
  schema: sporeScriptInfoSchema,
  messageType: sporeScriptInfoMessageType,
};

export function createSporeScriptInfoFromTemplate(props: { scriptHash: Hash }): UnpackResult<typeof ScriptInfo> {
  return {
    ...sporeScriptInfoTemplate,
    scriptHash: props.scriptHash,
  };
}


================================================
File: packages/core/src/cobuild/base/witnessLayout.ts
================================================
import { helpers } from '@ckb-lumos/lumos';
import { blockchain } from '@ckb-lumos/base';
import { bytes, BytesLike, number, UnpackResult } from '@ckb-lumos/codec';
import { WitnessLayout, WitnessLayoutFieldTags } from '../codec/witnessLayout';
import { ActionVec } from '../codec/buildingPacket';

export function getWitnessType(witness?: BytesLike) {
  const buf = bytes.bytify(witness ?? []);
  if (buf.length > 4) {
    const typeIndex = number.Uint32LE.unpack(buf.slice(0, 4));
    if (typeIndex >= WitnessLayoutFieldTags.SighashAll) {
      for (const [name, index] of Object.entries(WitnessLayoutFieldTags)) {
        if (index === typeIndex) {
          return name;
        }
      }
    } else {
      return 'WitnessArgs';
    }
  }

  throw new Error('Unknown witness format');
}

export function unpackWitness(witness?: BytesLike) {
  const buf = bytes.bytify(witness ?? []);
  if (buf.length > 4) {
    const typeIndex = number.Uint32LE.unpack(buf.slice(0, 4));
    try {
      if (typeIndex >= WitnessLayoutFieldTags.SighashAll) {
        return WitnessLayout.unpack(buf);
      } else {
        return {
          type: 'WitnessArgs',
          value: blockchain.WitnessArgs.unpack(buf),
        };
      }
    } catch (_err) {
      // passthrough
    }
  }

  throw new Error('Unknown witness format');
}

export function assembleCobuildWitnessLayout(actions: UnpackResult<typeof ActionVec>): string {
  const witness = bytes.hexify(
    WitnessLayout.pack({
      type: 'SighashAll',
      value: {
        seal: '0x',
        message: {
          actions,
        },
      },
    }),
  );
  return witness;
}

export function injectCommonCobuildProof(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  actions: UnpackResult<typeof ActionVec>;
}): {
  txSkeleton: helpers.TransactionSkeletonType;
  witnessIndex: number;
} {
  let txSkeleton = props.txSkeleton;

  // TODO: add Cobuild witness-check: If it's in legacy mode, manually add WitnessLayout
  if (txSkeleton.get('inputs').size > 0) {
    // Generate WitnessLayout

    // Append the witness to the end of the witnesses
    let witnessIndex: number | undefined;
    txSkeleton = txSkeleton.update('witnesses', (witnesses) => {
      witnessIndex = witnesses.size;
      const witness = assembleCobuildWitnessLayout(props.actions);
      return witnesses.push(witness);
    });

    return {
      txSkeleton,
      witnessIndex: witnessIndex!,
    };
  }

  throw new Error('Cannot inject CobuildProof into a Transaction without witnesses');
}


================================================
File: packages/core/src/cobuild/codec/buildingPacket.ts
================================================
import { molecule } from '@ckb-lumos/codec';
import { blockchain } from '@ckb-lumos/base';
import { Hash, RawString, Uint32Opt } from '../../codec';

export const Action = molecule.table(
  {
    scriptInfoHash: Hash,
    scriptHash: Hash,
    data: blockchain.Bytes,
  },
  ['scriptInfoHash', 'scriptHash', 'data'],
);

export const ActionVec = molecule.vector(Action);

export const Message = molecule.table(
  {
    actions: ActionVec,
  },
  ['actions'],
);

export const ResolvedInputs = molecule.table(
  {
    outputs: blockchain.CellOutputVec,
    outputsData: blockchain.BytesVec,
  },
  ['outputs', 'outputsData'],
);

export const ScriptInfo = molecule.table(
  {
    name: RawString,
    url: RawString,
    scriptHash: Hash,
    schema: RawString,
    messageType: RawString,
  },
  ['name', 'url', 'scriptHash', 'schema', 'messageType'],
);

export const ScriptInfoVec = molecule.vector(ScriptInfo);

export const BuildingPacketV1 = molecule.table(
  {
    message: Message,
    payload: blockchain.Transaction,
    resolvedInputs: ResolvedInputs,
    changeOutput: Uint32Opt,
    scriptInfos: ScriptInfoVec,
    lockActions: ActionVec,
  },
  ['message', 'payload', 'resolvedInputs', 'changeOutput', 'scriptInfos', 'lockActions'],
);

export const BuildingPacket = molecule.union(
  {
    BuildingPacketV1,
  },
  ['BuildingPacketV1'],
);


================================================
File: packages/core/src/cobuild/codec/sporeAction.ts
================================================
import { molecule } from '@ckb-lumos/codec';
import { blockchain } from '@ckb-lumos/base';
import { Hash } from '../../codec';

export const Address = molecule.union(
  {
    Script: blockchain.Script,
  },
  ['Script'],
);

/**
 * Spore
 */
export const CreateSpore = molecule.table(
  {
    sporeId: Hash,
    to: Address,
    dataHash: Hash,
  },
  ['sporeId', 'to', 'dataHash'],
);
export const TransferSpore = molecule.table(
  {
    sporeId: Hash,
    from: Address,
    to: Address,
  },
  ['sporeId', 'from', 'to'],
);
export const MeltSpore = molecule.table(
  {
    sporeId: Hash,
    from: Address,
  },
  ['sporeId', 'from'],
);

/**
 * Cluster
 */
export const CreateCluster = molecule.table(
  {
    clusterId: Hash,
    to: Address,
    dataHash: Hash,
  },
  ['clusterId', 'to', 'dataHash'],
);
export const TransferCluster = molecule.table(
  {
    clusterId: Hash,
    from: Address,
    to: Address,
  },
  ['clusterId', 'from', 'to'],
);

/**
 * ClusterProxy
 */
export const CreateClusterProxy = molecule.table(
  {
    clusterId: Hash,
    clusterProxyId: Hash,
    to: Address,
  },
  ['clusterId', 'clusterProxyId', 'to'],
);
export const TransferClusterProxy = molecule.table(
  {
    clusterId: Hash,
    clusterProxyId: Hash,
    from: Address,
    to: Address,
  },
  ['clusterId', 'clusterProxyId', 'from', 'to'],
);
export const MeltClusterProxy = molecule.table(
  {
    clusterId: Hash,
    clusterProxyId: Hash,
    from: Address,
  },
  ['clusterId', 'clusterProxyId', 'from'],
);

/**
 * ClusterAgent
 */
export const CreateClusterAgent = molecule.table(
  {
    clusterId: Hash,
    clusterProxyId: Hash,
    to: Address,
  },
  ['clusterId', 'clusterProxyId', 'to'],
);
export const TransferClusterAgent = molecule.table(
  {
    clusterId: Hash,
    from: Address,
    to: Address,
  },
  ['clusterId', 'from', 'to'],
);
export const MeltClusterAgent = molecule.table(
  {
    clusterId: Hash,
    from: Address,
  },
  ['clusterId', 'from'],
);

/**
 * Spore ScriptInfo Actions
 */
export const SporeAction = molecule.union(
  {
    // Spore
    CreateSpore,
    TransferSpore,
    MeltSpore,

    // Cluster
    CreateCluster,
    TransferCluster,

    // ClusterProxy
    CreateClusterProxy,
    TransferClusterProxy,
    MeltClusterProxy,

    // ClusterAgent
    CreateClusterAgent,
    TransferClusterAgent,
    MeltClusterAgent,
  },
  [
    'CreateSpore',
    'TransferSpore',
    'MeltSpore',
    'CreateCluster',
    'TransferCluster',
    'CreateClusterProxy',
    'TransferClusterProxy',
    'MeltClusterProxy',
    'CreateClusterAgent',
    'TransferClusterAgent',
    'MeltClusterAgent',
  ],
);


================================================
File: packages/core/src/cobuild/codec/witnessLayout.ts
================================================
import { blockchain } from '@ckb-lumos/base';
import { molecule } from '@ckb-lumos/codec';
import { Message } from './buildingPacket';

export const SighashAll = molecule.table(
  {
    seal: blockchain.Bytes,
    message: Message,
  },
  ['seal', 'message'],
);
export const SighashAllOnly = molecule.table(
  {
    seal: blockchain.Bytes,
  },
  ['seal'],
);

/**
 * Otx related are not implemented yet, so just placeholders.
 */
export const Otx = molecule.table({}, []);
export const OtxStart = molecule.table({}, []);

export const WitnessLayoutFieldTags = {
  SighashAll: 4278190081,
  SighashAllOnly: 4278190082,
  Otx: 4278190083,
  OtxStart: 4278190084,
} as const;

export const WitnessLayout = molecule.union(
  {
    SighashAll,
    SighashAllOnly,
    Otx,
    OtxStart,
  },
  WitnessLayoutFieldTags,
);


================================================
File: packages/core/src/codec/cluster.ts
================================================
import { blockchain } from '@ckb-lumos/base';
import { BytesLike, molecule } from '@ckb-lumos/codec';
import { bytifyRawString, bufferToRawString } from '../helpers';
import { Hash } from '@ckb-lumos/lumos';
import { bytes } from '@ckb-lumos/codec';

export const ClusterDataV1 = molecule.table(
  {
    name: blockchain.Bytes,
    description: blockchain.Bytes,
  },
  ['name', 'description'],
);
export const ClusterDataV2 = molecule.table(
  {
    name: blockchain.Bytes,
    description: blockchain.Bytes,
    mutantId: blockchain.BytesOpt,
  },
  ['name', 'description', 'mutantId'],
);

export interface RawClusterDataV1 {
  name: string;
  description: string;
}
export interface RawClusterDataV2 {
  name: string;
  description: string;
  mutantId?: Hash;
}
export type RawClusterData = RawClusterDataV2;

export type ClusterDataVersion = 'v1' | 'v2';

/**
 * Pack RawClusterData to Uint8Array.
 * Pass an optional "version" field to select a specific packing version.
 */
export function packRawClusterData(packable: RawClusterData): Uint8Array;
export function packRawClusterData(packable: RawClusterDataV1, version: 'v1'): Uint8Array;
export function packRawClusterData(packable: RawClusterDataV2, version: 'v2'): Uint8Array;
export function packRawClusterData(packable: RawClusterDataV1 | RawClusterDataV2, version?: unknown): Uint8Array {
  if (!version) {
    return packRawClusterDataV2(packable);
  }

  switch (version) {
    case 'v1':
      return packRawClusterDataV1(packable);
    case 'v2':
      return packRawClusterDataV2(packable);
    default:
      throw new Error(`Unsupported ClusterData version: ${version}`);
  }
}
export function packRawClusterDataV1(packable: RawClusterDataV1): Uint8Array {
  return ClusterDataV1.pack({
    name: bytifyRawString(packable.name),
    description: bytifyRawString(packable.description),
  });
}
export function packRawClusterDataV2(packable: RawClusterDataV2): Uint8Array {
  return ClusterDataV2.pack({
    name: bytifyRawString(packable.name),
    description: bytifyRawString(packable.description),
    mutantId: packable.mutantId,
  });
}

/**
 * Unpack Hex/Bytes to RawClusterData.
 * Pass an optional "version" field to select a specific unpacking version.
 */
export function unpackToRawClusterData(unpackable: BytesLike): RawClusterData;
export function unpackToRawClusterData(unpackable: BytesLike, version: 'v1'): RawClusterDataV1;
export function unpackToRawClusterData(unpackable: BytesLike, version: 'v2'): RawClusterDataV2;
export function unpackToRawClusterData(unpackable: BytesLike, version?: unknown): unknown {
  if (version) {
    switch (version) {
      case 'v1':
        return unpackToRawClusterDataV1(unpackable);
      case 'v2':
        return unpackToRawClusterDataV2(unpackable);
      default:
        throw new Error(`Unsupported ClusterData version: ${version}`);
    }
  }

  try {
    return unpackToRawClusterDataV2(unpackable);
  } catch {
    try {
      return unpackToRawClusterDataV1(unpackable);
    } catch {
      throw new Error(`Cannot unpack ClusterData, no matching molecule: ${bytes.hexify(unpackable)}`);
    }
  }
}
export function unpackToRawClusterDataV1(unpackable: BytesLike): RawClusterDataV1 {
  const decoded = ClusterDataV1.unpack(unpackable);
  return {
    name: bufferToRawString(decoded.name),
    description: bufferToRawString(decoded.description),
  };
}
export function unpackToRawClusterDataV2(unpackable: BytesLike): RawClusterDataV2 {
  const decoded = ClusterDataV2.unpack(unpackable);
  return {
    name: bufferToRawString(decoded.name),
    description: bufferToRawString(decoded.description),
    mutantId: decoded.mutantId,
  };
}


================================================
File: packages/core/src/codec/clusterAgent.ts
================================================
import { utils } from '@ckb-lumos/lumos';
import { bytes } from '@ckb-lumos/codec';
import { Hash, Script } from '@ckb-lumos/base';

export type RawClusterAgentData = Script;

export function packRawClusterAgentDataToHash(packable: RawClusterAgentData): Hash {
  return utils.computeScriptHash(packable);
}

export function packRawClusterAgentData(packable: RawClusterAgentData): Uint8Array {
  const hash = packRawClusterAgentDataToHash(packable);
  return bytes.bytify(hash);
}


================================================
File: packages/core/src/codec/clusterProxy.ts
================================================
import { BIish, BI } from '@ckb-lumos/bi';
import { blockchain, Hash } from '@ckb-lumos/base';
import { BytesLike, createBytesCodec } from '@ckb-lumos/codec';
import { Uint64Opt, Uint8Opt } from './utils';

export interface PackableClusterProxyArgs {
  id: BytesLike;
  minPayment?: BIish;
}

export interface RawClusterProxyArgs {
  id: Hash;
  minPayment?: BI;
}

export const ClusterProxyArgsPower = createBytesCodec({
  pack(packable: PackableClusterProxyArgs): Uint8Array {
    const id = blockchain.Byte32.pack(packable.id);
    const minPayment = Uint8Opt.pack(packable.minPayment);

    const composed = new Uint8Array(id.length + minPayment.length);
    composed.set(id, 0);
    composed.set(minPayment, id.length);

    return composed;
  },
  unpack(unpackable: Uint8Array): RawClusterProxyArgs {
    const id = blockchain.Byte32.unpack(unpackable.slice(0, 32));
    const minPayment = Uint8Opt.unpack(unpackable.slice(32, 33));
    return {
      id,
      minPayment: typeof minPayment === 'number' ? BI.from(minPayment) : void 0,
    };
  },
});

export const ClusterProxyArgsExact = createBytesCodec({
  pack(packable: PackableClusterProxyArgs): Uint8Array {
    const id = blockchain.Byte32.pack(packable.id);
    const minPayment = Uint64Opt.pack(packable.minPayment);

    const composed = new Uint8Array(id.length + minPayment.length);
    composed.set(id, 0);
    composed.set(minPayment, id.length);

    return composed;
  },
  unpack(unpackable: Uint8Array): RawClusterProxyArgs {
    const id = blockchain.Byte32.unpack(unpackable.slice(0, 32));
    const minPayment = Uint64Opt.unpack(unpackable.slice(32, 40));
    return {
      id,
      minPayment: typeof BI.isBI(minPayment) ? minPayment : void 0,
    };
  },
});

export function packRawClusterProxyArgs(packable: PackableClusterProxyArgs): Uint8Array;
export function packRawClusterProxyArgs(packable: PackableClusterProxyArgs, version: 'power'): Uint8Array;
export function packRawClusterProxyArgs(packable: PackableClusterProxyArgs, version: 'exact'): Uint8Array;
export function packRawClusterProxyArgs(packable: PackableClusterProxyArgs, version?: unknown): unknown {
  switch (version) {
    case 'power':
      return ClusterProxyArgsPower.pack(packable);
    case 'exact':
    case void 0:
      return ClusterProxyArgsExact.pack(packable);
    default:
      throw new Error(`Unsupported ClusterProxy version: ${version}`);
  }
}

export function unpackToRawClusterProxyArgs(unpackable: BytesLike): RawClusterProxyArgs;
export function unpackToRawClusterProxyArgs(unpackable: BytesLike, version: 'power'): RawClusterProxyArgs;
export function unpackToRawClusterProxyArgs(unpackable: BytesLike, version: 'exact'): RawClusterProxyArgs;
export function unpackToRawClusterProxyArgs(unpackable: BytesLike, version?: unknown): unknown {
  switch (version) {
    case 'power':
      return ClusterProxyArgsPower.unpack(unpackable);
    case 'exact':
    case void 0:
      return ClusterProxyArgsExact.unpack(unpackable);
    default:
      throw new Error(`Unsupported ClusterProxy version: ${version}`);
  }
}


================================================
File: packages/core/src/codec/index.ts
================================================
export * from './utils';

export * from './spore';
export * from './cluster';
export * from './clusterProxy';
export * from './clusterAgent';
export * from './mutant';


================================================
File: packages/core/src/codec/mutant.ts
================================================
import { BIish, BI } from '@ckb-lumos/bi';
import { blockchain, Hash } from '@ckb-lumos/base';
import { BytesLike, createBytesCodec } from '@ckb-lumos/codec';
import { Uint64Opt, Uint8Opt } from './utils';

export interface PackableMutantArgs {
  id: BytesLike;
  minPayment?: BIish;
}

export interface RawMutantArgs {
  id: Hash;
  minPayment?: BI;
}

export const MutantArgsPower = createBytesCodec({
  pack(packable: PackableMutantArgs): Uint8Array {
    const id = blockchain.Byte32.pack(packable.id);
    const minPayment = Uint8Opt.pack(packable.minPayment);

    const composed = new Uint8Array(id.length + minPayment.length);
    composed.set(id, 0);
    composed.set(minPayment, id.length);

    return composed;
  },
  unpack(unpackable: Uint8Array): RawMutantArgs {
    const id = blockchain.Byte32.unpack(unpackable.slice(0, 32));
    const minPayment = Uint8Opt.unpack(unpackable.slice(32, 33));
    return {
      id,
      minPayment: typeof minPayment === 'number' ? BI.from(minPayment) : void 0,
    };
  },
});

export const MutantArgsExact = createBytesCodec({
  pack(packable: PackableMutantArgs): Uint8Array {
    const id = blockchain.Byte32.pack(packable.id);
    const minPayment = Uint64Opt.pack(packable.minPayment);

    const composed = new Uint8Array(id.length + minPayment.length);
    composed.set(id, 0);
    composed.set(minPayment, id.length);

    return composed;
  },
  unpack(unpackable: Uint8Array): RawMutantArgs {
    const id = blockchain.Byte32.unpack(unpackable.slice(0, 32));
    const minPayment = Uint64Opt.unpack(unpackable.slice(32, 40));
    return {
      id,
      minPayment: typeof BI.isBI(minPayment) ? minPayment : void 0,
    };
  },
});

export function packRawMutantArgs(packable: PackableMutantArgs): Uint8Array;
export function packRawMutantArgs(packable: PackableMutantArgs, version: 'power'): Uint8Array;
export function packRawMutantArgs(packable: PackableMutantArgs, version: 'exact'): Uint8Array;
export function packRawMutantArgs(packable: PackableMutantArgs, version?: unknown): unknown {
  switch (version) {
    case 'power':
      return MutantArgsPower.pack(packable);
    case 'exact':
    case void 0:
      return MutantArgsExact.pack(packable);
    default:
      throw new Error(`Unsupported Mutant version: ${version}`);
  }
}

export function unpackToRawMutantArgs(unpackable: BytesLike): RawMutantArgs;
export function unpackToRawMutantArgs(unpackable: BytesLike, version: 'power'): RawMutantArgs;
export function unpackToRawMutantArgs(unpackable: BytesLike, version: 'exact'): RawMutantArgs;
export function unpackToRawMutantArgs(unpackable: BytesLike, version?: unknown): unknown {
  switch (version) {
    case 'power':
      return MutantArgsPower.unpack(unpackable);
    case 'exact':
    case void 0:
      return MutantArgsExact.unpack(unpackable);
    default:
      throw new Error(`Unsupported Mutant version: ${version}`);
  }
}


================================================
File: packages/core/src/codec/spore.ts
================================================
import { blockchain } from '@ckb-lumos/base';
import { BytesLike, molecule } from '@ckb-lumos/codec';
import { bufferToRawString, bytifyRawString } from '../helpers';
import { Hash } from '@ckb-lumos/lumos';

export const SporeData = molecule.table(
  {
    contentType: blockchain.Bytes,
    content: blockchain.Bytes,
    clusterId: blockchain.BytesOpt,
  },
  ['contentType', 'content', 'clusterId'],
);

export interface RawSporeData {
  contentType: string;
  content: BytesLike;
  clusterId?: Hash;
}

export function packRawSporeData(packable: RawSporeData): Uint8Array {
  return SporeData.pack({
    contentType: bytifyRawString(packable.contentType),
    content: packable.content,
    clusterId: packable.clusterId,
  });
}

export function unpackToRawSporeData(unpackable: BytesLike): RawSporeData {
  const unpacked = SporeData.unpack(unpackable);
  return {
    contentType: bufferToRawString(unpacked.contentType),
    content: unpacked.content,
    clusterId: unpacked.clusterId,
  };
}


================================================
File: packages/core/src/codec/utils.ts
================================================
import { blockchain } from '@ckb-lumos/base';
import { BytesLike, molecule, number } from '@ckb-lumos/codec';
import { bufferToRawString, bytifyRawString } from '../helpers';

export const ScriptId = molecule.struct(
  {
    codeHash: blockchain.Byte32,
    hashType: blockchain.HashType,
  },
  ['codeHash', 'hashType'],
);

export const Uint8Opt = molecule.option(number.Uint8);
export const Uint32Opt = molecule.option(number.Uint32LE);
export const Uint64Opt = molecule.option(number.Uint64LE);

export const Hash = blockchain.Byte32;

/**
 * The codec for packing/unpacking UTF-8 raw strings.
 * Should be packed like so: String.pack('something')
 */
export const RawString = molecule.byteVecOf({
  pack: (packable: string) => bytifyRawString(packable),
  unpack: (unpackable: BytesLike) => bufferToRawString(unpackable),
});


================================================
File: packages/core/src/config/cache.ts
================================================
import cloneDeep from 'lodash/cloneDeep';
import { Hash } from '@ckb-lumos/base';
import { getSporeConfigHash } from './hash';
import { SporeConfig, SporeScript } from './types';

const cacheStore: Map<Hash, SporeConfigCache> = new Map();

export interface SporeConfigCache<T extends string = string> {
  hash: Hash;
  config: SporeConfig<T>;
  scriptsByCodeHash: Record<Hash, SporeCategorizedScript>;
  scriptsByTag: Record<T, Record<string, SporeCategorizedScript[]>>;
  scriptsByTags: Record<T, Record<string, SporeCategorizedScript[]>>;
  queryRecordsByTags: Record<T, Record<string, SporeCategorizedScript[]>>;
}

export interface SporeCategorizedScript extends SporeScript {
  name: string;
}

/**
 * Create a SporeCache from SporeConfig and store in cache.
 */
export function setSporeConfigCache<T extends string>(config: SporeConfig<T>): void {
  const cache = createSporeConfigCache<T>(config);
  cacheStore.set(cache.hash, cache);
}

/**
 * Get a SporeConfig's corresponding SporeCache.
 * If not exists, create one and store in cache, and then return the new SporeCache.
 */
export function getSporeConfigCache<T extends string>(config: SporeConfig<T>): SporeConfigCache<T> {
  const hash = getSporeConfigHash(config);
  if (cacheStore.has(hash)) {
    return cacheStore.get(hash) as SporeConfigCache<T>;
  }

  setSporeConfigCache(config);
  return cacheStore.get(hash) as SporeConfigCache<T>;
}

/**
 * Create a SporeConfigCache from SporeConfig.
 * Will generate mapping info for the scripts to save time when searching.
 */
export function createSporeConfigCache<T extends string>(config: SporeConfig<T>): SporeConfigCache<T> {
  const hash = getSporeConfigHash(config);

  const scriptsByCodeHash = {} as Record<Hash, SporeCategorizedScript>;
  const scriptsByTag = {} as Record<T, Record<string, SporeCategorizedScript[]>>;
  const scriptsByTags = {} as Record<T, Record<string, SporeCategorizedScript[]>>;
  const queryRecordsByTags = {} as Record<T, Record<string, SporeCategorizedScript[]>>;

  for (const scriptName in config.scripts) {
    const scriptCategory = config.scripts[scriptName];
    const scriptTagMap = {} as Record<string, SporeCategorizedScript[]>;
    const scriptTagsMap = {} as Record<string, SporeCategorizedScript[]>;

    for (const script of scriptCategory.versions) {
      const categorizedScript: SporeCategorizedScript = {
        name: scriptName,
        ...cloneDeep(script),
      };
      scriptsByCodeHash[script.script.codeHash] = categorizedScript;
      const tags = script.tags.sort();
      for (const tag of tags) {
        if (scriptTagMap[tag] === void 0) {
          scriptTagMap[tag] = [];
        }
        scriptTagMap[tag].push(categorizedScript);
      }
      const combinedTags = tags.join(',');
      if (!scriptTagsMap[combinedTags]) {
        scriptTagsMap[combinedTags] = [];
      }
      scriptTagsMap[combinedTags].push(categorizedScript);
    }

    scriptsByTag[scriptName] = scriptTagMap;
    scriptsByTags[scriptName] = scriptTagsMap;
    queryRecordsByTags[scriptName] = {};
  }

  return {
    hash,
    config,
    scriptsByTag,
    scriptsByTags,
    scriptsByCodeHash,
    queryRecordsByTags,
  };
}

/**
 * Search for a specific list of SporeScripts by "scriptName" and "tag" in a SporeConfigCache.
 */
export function getSporeCacheScriptsByTag<T extends string>(
  cache: SporeConfigCache<T>,
  scriptName: T,
  tag: string,
): SporeCategorizedScript[] | undefined {
  const scripts = cache.scriptsByTag[scriptName]?.[tag];
  if (!Array.isArray(scripts)) {
    return void 0;
  }

  return scripts;
}

/**
 * Search SporeConfig by "scriptName" and "tags" in a SporeConfigCache.
 */
export function getSporeCacheScriptsByTags<T extends string>(
  cache: SporeConfigCache<T>,
  scriptName: T,
  tags: string[],
): SporeCategorizedScript[] | undefined {
  if (tags.length === 1) {
    return getSporeCacheScriptsByTag(cache, scriptName, tags[0]);
  }

  const recordsMap: Record<string, SporeCategorizedScript[]> = cache.queryRecordsByTags[scriptName];
  const sortedTags = tags.sort();
  const key = sortedTags.join(',');
  if (recordsMap && key in recordsMap) {
    return recordsMap[key];
  }

  const scriptsMap = cache.scriptsByTags[scriptName];
  if (!scriptsMap) {
    return void 0;
  }

  const patterns = sortedTags.join(',.*');
  const regex = new RegExp(`${patterns}.*`, 'g');
  const match = Object.entries(scriptsMap).filter(([_tags]) => {
    return regex.test(_tags);
  });
  if (match) {
    const matchScripts = match.reduce((matches, [_, scripts]) => {
      matches.push(...scripts);
      return matches;
    }, [] as SporeCategorizedScript[]);
    recordsMap[key] = matchScripts;
    return matchScripts;
  }

  return void 0;
}

/**
 * Search for a specific SporeScript by "codeHash" in a SporeCache.
 * If "scriptName" is passed, it also checks whether the name of the target script matches.
 */
export function getSporeCacheScriptByCodeHash<T extends string>(
  cache: SporeConfigCache<T>,
  codeHash: Hash,
  scriptName?: T,
) {
  const script = cache.scriptsByCodeHash[codeHash];
  if (scriptName && script.name !== scriptName) {
    return void 0;
  }

  return script;
}


================================================
File: packages/core/src/config/config.ts
================================================
import cloneDeep from 'lodash/cloneDeep';
import { predefinedSporeConfigs } from './predefined';
import { SporeConfig, SporeScriptCategories } from './types';

let configStore: SporeConfig = predefinedSporeConfigs.Aggron4;

/**
 * Set the global default SporeConfig.
 * The default config is "predefinedSporeConfigs.Aggron4".
 */
export function setSporeConfig<T extends string = string>(config: SporeConfig<T>): void {
  configStore = config;
}

/**
 * Get the global default SporeConfig.
 * The default config is "predefinedSporeConfigs.Aggron4".
 */
export function getSporeConfig<T extends string = string>(): SporeConfig<T> {
  return configStore as SporeConfig<T>;
}

/**
 * Clone and create a new SporeConfig.
 */
export function forkSporeConfig<T1 extends string, T2 extends string>(
  origin: SporeConfig<T1>,
  change: Partial<SporeConfig<T2>>,
): SporeConfig<T1 | T2> {
  origin = cloneDeep(origin);

  const scripts = {
    ...origin.scripts,
    ...change.scripts,
  } as SporeScriptCategories<T1 | T2>;

  return {
    ...origin,
    ...change,
    scripts,
  };
}


================================================
File: packages/core/src/config/hash.ts
================================================
import { Hash, utils } from '@ckb-lumos/base';
import { bytifyRawString } from '../helpers';
import { SporeConfig } from './types';

const configHashStore: Map<string, Hash> = new Map();

/**
 * Get the hash of a SporeConfig, calculated by the JSON string of the config.
 * Generated hashes will be stored in cache to save time for later searching.
 */
export function getSporeConfigHash(config: SporeConfig): Hash {
  const string = JSON.stringify(config, null, 0);
  if (configHashStore.has(string)) {
    return configHashStore.get(string)!;
  }

  const hash = utils.ckbHash(bytifyRawString(string));
  configHashStore.set(string, hash);
  return hash;
}


================================================
File: packages/core/src/config/index.ts
================================================
export * from './types';

export * from './hash';
export * from './cache';
export * from './config';
export * from './script';

export * from './predefined';


================================================
File: packages/core/src/config/predefined.ts
================================================
import { predefined } from '@ckb-lumos/config-manager';
import { SporeConfig } from './types';

export type PredefinedTestnetSporeScriptName = 'Spore' | 'Cluster' | 'ClusterProxy' | 'ClusterAgent' | 'Mutant' | 'Lua';

const TESTNET_SPORE_CONFIG: SporeConfig<PredefinedTestnetSporeScriptName> = {
  lumos: predefined.AGGRON4,
  ckbNodeUrl: 'https://testnet.ckb.dev/rpc',
  ckbIndexerUrl: 'https://testnet.ckb.dev/indexer',
  maxTransactionSize: 500 * 1024, // 500 KB
  defaultTags: ['preview'],
  scripts: {
    Spore: {
      versions: [
        // see: https://github.com/dotbitHQ/did-contracts/blob/docs/docs/Deployed-Scripts.md#testnet
        {
          tags: ['v2', 'did'],
          script: {
            codeHash: '0x0b1f412fbae26853ff7d082d422c2bdd9e2ff94ee8aaec11240a5b34cc6e890f',
            hashType: 'type',
          },
          cellDep: {
            outPoint: {
              txHash: '0x29d0123dda05cb92452a46df609e9bd08e066d62f0c3953fe34935dc10edfdcc',
              index: '0x0',
            },
            depType: 'code',
          },
          behaviors: {
            lockProxy: true,
            dynamicCelldep: {
              codeHash: '0x00000000000000000000000000000000000000000000000000545950455f4944',
              hashType: 'type',
              args: '0x80f0d4bf6b3951911aa6b98cc609d477a8a10b903b35cfd528d098e95c36f680',
            },
          },
        },
        {
          tags: ['v2', 'preview'],
          script: {
            codeHash: '0x685a60219309029d01310311dba953d67029170ca4848a4ff638e57002130a0d',
            hashType: 'data1',
          },
          cellDep: {
            outPoint: {
              txHash: '0x5e8d2a517d50fd4bb4d01737a7952a1f1d35c8afc77240695bb569cd7d9d5a1f',
              index: '0x0',
            },
            depType: 'code',
          },
          behaviors: {
            lockProxy: true,
            cobuild: true,
          },
        },
        {
          tags: ['v1', 'latest'],
          script: {
            codeHash: '0xbbad126377d45f90a8ee120da988a2d7332c78ba8fd679aab478a19d6c133494',
            hashType: 'data1',
          },
          cellDep: {
            outPoint: {
              txHash: '0xfd694382e621f175ddf81ce91ce2ecf8bfc027d53d7d31b8438f7d26fc37fd19',
              index: '0x0',
            },
            depType: 'code',
          },
        },
      ],
    },
    Cluster: {
      versions: [
        {
          tags: ['v2', 'preview'],
          script: {
            codeHash: '0x0bbe768b519d8ea7b96d58f1182eb7e6ef96c541fbd9526975077ee09f049058',
            hashType: 'data1',
          },
          cellDep: {
            outPoint: {
              txHash: '0xcebb174d6e300e26074aea2f5dbd7f694bb4fe3de52b6dfe205e54f90164510a',
              index: '0x0',
            },
            depType: 'code',
          },
          behaviors: {
            lockProxy: true,
            cobuild: true,
          },
        },
        {
          tags: ['v1', 'latest'],
          script: {
            codeHash: '0x598d793defef36e2eeba54a9b45130e4ca92822e1d193671f490950c3b856080',
            hashType: 'data1',
          },
          cellDep: {
            outPoint: {
              txHash: '0x49551a20dfe39231e7db49431d26c9c08ceec96a29024eef3acc936deeb2ca76',
              index: '0x0',
            },
            depType: 'code',
          },
        },
      ],
    },
    ClusterProxy: {
      versions: [
        {
          tags: ['v2', 'preview'],
          script: {
            codeHash: '0x4349889bda064adab8f49f7dd8810d217917f7df28e9b2a1df0b74442399670a',
            hashType: 'data1',
          },
          cellDep: {
            outPoint: {
              txHash: '0xc5a41d58155b11ecd87a5a49fdcb6e83bd6684d3b72b2f3686f081945461c156',
              index: '0x0',
            },
            depType: 'code',
          },
          behaviors: {
            lockProxy: true,
            cobuild: true,
          },
        },
      ],
    },
    ClusterAgent: {
      versions: [
        {
          tags: ['v2', 'preview'],
          script: {
            codeHash: '0x923e997654b2697ee3f77052cb884e98f28799a4270fd412c3edb8f3987ca622',
            hashType: 'data1',
          },
          cellDep: {
            outPoint: {
              txHash: '0x52210232292d10c51b48e72a2cea60d8f0a08c2680a97a8ee7ca0a39379f0036',
              index: '0x0',
            },
            depType: 'code',
          },
          behaviors: {
            lockProxy: true,
            cobuild: true,
          },
        },
      ],
    },
    Mutant: {
      versions: [
        {
          tags: ['v2', 'preview'],
          script: {
            codeHash: '0x5ff1a403458b436ea4b2ceb72f1fa70a6507968493315b646f5302661cb68e57',
            hashType: 'data1',
          },
          cellDep: {
            outPoint: {
              txHash: '0x9b2098e5b6f575b2fd34ffd0212bc1c96e1f9e86fcdb146511849c174dfe0d02',
              index: '0x0',
            },
            depType: 'code',
          },
          behaviors: {
            lockProxy: true,
            cobuild: true,
          },
        },
      ],
    },
    Lua: {
      versions: [
        {
          tags: ['v2', 'preview'],
          script: {
            codeHash: '0xed08faee8c29b7a7c29bd9d495b4b93cc207bd70ca93f7b356f39c677e7ab0fc',
            hashType: 'data1',
          },
          cellDep: {
            outPoint: {
              txHash: '0x8fb7170a58d631250dabd0f323a833f4ad2cfdd0189f45497e62beb8409e7a0c',
              index: '0x0',
            },
            depType: 'code',
          },
        },
      ],
    },
  },
};

export type PredefinedMainnetSporeScriptName = 'Spore' | 'Cluster';

const MAINNET_SPORE_CONFIG: SporeConfig<PredefinedMainnetSporeScriptName> = {
  lumos: predefined.LINA,
  ckbNodeUrl: 'https://mainnet.ckb.dev/rpc',
  ckbIndexerUrl: 'https://mainnet.ckb.dev/indexer',
  maxTransactionSize: 500 * 1024, // 500 KB
  defaultTags: ['latest'],
  scripts: {
    Spore: {
      versions: [
        // see: https://github.com/dotbitHQ/did-contracts/blob/docs/docs/Deployed-Scripts.md#mainnet
        {
          tags: ['v2', 'did'],
          script: {
            codeHash: '0xcfba73b58b6f30e70caed8a999748781b164ef9a1e218424a6fb55ebf641cb33',
            hashType: 'type',
          },
          cellDep: {
            outPoint: {
              txHash: '0x18dda0f02036305b423b85cce276a40417faed044b2ee9220284215f38734daa',
              index: '0x0',
            },
            depType: 'code',
          },
          behaviors: {
            lockProxy: true,
            dynamicCelldep: {
              codeHash: '0x00000000000000000000000000000000000000000000000000545950455f4944',
              hashType: 'type',
              args: '0x62312cd846659e188b05da11dc3f080b083c27371ea701d6026e11e713e0e3de',
            },
          },
        },
        {
          tags: ['v2', 'latest'],
          script: {
            codeHash: '0x4a4dce1df3dffff7f8b2cd7dff7303df3b6150c9788cb75dcf6747247132b9f5',
            hashType: 'data1',
          },
          cellDep: {
            outPoint: {
              txHash: '0x96b198fb5ddbd1eed57ed667068f1f1e55d07907b4c0dbd38675a69ea1b69824',
              index: '0x0',
            },
            depType: 'code',
          },
          behaviors: {
            lockProxy: true,
            cobuild: true,
          },
        },
      ],
    },
    Cluster: {
      versions: [
        {
          tags: ['v2', 'latest'],
          script: {
            codeHash: '0x7366a61534fa7c7e6225ecc0d828ea3b5366adec2b58206f2ee84995fe030075',
            hashType: 'data1',
          },
          cellDep: {
            outPoint: {
              txHash: '0xe464b7fb9311c5e2820e61c99afc615d6b98bdefbe318c34868c010cbd0dc938',
              index: '0x0',
            },
            depType: 'code',
          },
          behaviors: {
            lockProxy: true,
            cobuild: true,
          },
        },
      ],
    },
  },
};

export const predefinedSporeConfigs = {
  /**
   * @deprecated Use `Testnet` instead.
   */
  Aggron4: TESTNET_SPORE_CONFIG,
  Testnet: TESTNET_SPORE_CONFIG,
  Mainnet: MAINNET_SPORE_CONFIG,
};


================================================
File: packages/core/src/config/script.ts
================================================
import { ScriptId } from '../types';
import { SporeConfig, SporeScript, SporeScriptCategory } from './types';
import { getSporeConfigCache, getSporeCacheScriptByCodeHash, getSporeCacheScriptsByTags } from './cache';

/**
 * Get a specific SporeScriptCategory from SporeConfig by "scriptName".
 * Throws an error if the script doesn't exist.
 */
export function getSporeScriptCategory(config: SporeConfig, scriptName: string): SporeScriptCategory {
  const category = config.scripts[scriptName];
  if (!category) {
    throw new Error(`"${scriptName}" script is not defined in the SporeConfig`);
  }

  return category;
}

/**
 * Get a specific SporeScript from SporeConfig by "scriptName" with optional "scriptId" or "tags".
 * Throws an error if the script doesn't exist.
 */
export function getSporeScript(config: SporeConfig, scriptName: string): SporeScript;
export function getSporeScript(config: SporeConfig, scriptName: string, tags: string[]): SporeScript;
export function getSporeScript(config: SporeConfig, scriptName: string, scriptId: ScriptId): SporeScript;
export function getSporeScript(config: SporeConfig, scriptName: string, extraArg?: unknown): SporeScript {
  if (extraArg && typeof extraArg === 'object' && 'codeHash' in extraArg && 'hashType' in extraArg) {
    return getSporeScriptByScriptId(config, scriptName, extraArg as ScriptId);
  }
  if (extraArg && Array.isArray(extraArg)) {
    return getSporeScriptByTags(config, scriptName, extraArg as string[]);
  }
  if (config.defaultTags) {
    return getSporeScriptByTags(config, scriptName, config.defaultTags);
  }

  return getLatestSporeScript(config, scriptName);
}

/**
 * Get a specific SporeScript from SporeConfig by "scriptName".
 * Throws an error if the script doesn't exist.
 */
export function getLatestSporeScript(config: SporeConfig, scriptName: string): SporeScript {
  const scriptCategory = config.scripts[scriptName];
  if (!scriptCategory || !scriptCategory.versions.length) {
    throw new Error(`"${scriptName}" script is not defined in the SporeConfig`);
  }

  return scriptCategory.versions[0];
}

/**
 * Get a specific SporeScript from SporeConfig by "scriptName" and "scriptId".
 * Throws an error if the script doesn't exist.
 */
export function getSporeScriptByScriptId(config: SporeConfig, scriptName: string, scriptId: ScriptId) {
  const scriptCategory = config.scripts[scriptName];
  if (!scriptCategory || !scriptCategory.versions.length) {
    throw new Error(`"${scriptName}" script is not defined in the SporeConfig`);
  }

  const cache = getSporeConfigCache(config);
  const script = getSporeCacheScriptByCodeHash(cache, scriptId.codeHash, scriptName);
  if (!script) {
    throw new Error(
      `Specific "${scriptName}" script is not defined in the SporeConfig, codeHash: ${scriptId.codeHash}`,
    );
  }

  return script;
}

/**
 * Get a specific SporeScript from SporeConfig by "scriptName" and "scriptId".
 * Throws an error if the script doesn't exist.
 */
export function getSporeScriptByTags(config: SporeConfig, scriptName: string, tags: string[]): SporeScript {
  const scriptCategory = config.scripts[scriptName];
  if (!scriptCategory || !scriptCategory.versions.length) {
    throw new Error(`"${scriptName}" script is not defined in the SporeConfig`);
  }

  const cache = getSporeConfigCache(config);
  const scripts = getSporeCacheScriptsByTags(cache, scriptName, tags);
  if (!scripts || !scripts.length) {
    throw new Error(
      `Specific tags of the "${scriptName}" script is not defined in the SporeConfig: [${tags.join(', ')}]`,
    );
  }

  // Returns the latest version of the script (the first one in the list)
  return scripts[0];
}

/**
 * Returns a boolean indicating weather if the target ScriptName exists in the SporeConfig.
 */
export function isSporeScriptCategorySupported(config: SporeConfig, scriptName: string): boolean {
  return config.scripts[scriptName] !== void 0;
}

/**
 * Returns a boolean indicating weather if the target ScriptId exists in the SporeConfig.
 * If "scriptName" is passed, it also checks whether the name of the target script matches.
 */
export function isSporeScriptSupported(config: SporeConfig, scriptId: ScriptId, scriptName?: string): boolean {
  const cache = getSporeConfigCache(config);
  const script = getSporeCacheScriptByCodeHash(cache, scriptId.codeHash, scriptName);
  return script !== void 0;
}


================================================
File: packages/core/src/config/types.ts
================================================
import { Config } from '@ckb-lumos/config-manager';
import { CellDep } from '@ckb-lumos/base';
import { ScriptId } from '../types';
import { ClusterDataVersion } from '../codec';
import { HexString, Script } from '@ckb-lumos/lumos';

export interface SporeConfig<T extends string = string> {
  lumos: Config;
  ckbNodeUrl: string;
  ckbIndexerUrl: string;
  maxTransactionSize?: number;
  defaultTags?: string[];
  scripts: SporeScriptCategories<T>;
}

export type SporeScriptCategories<T extends string> = Record<T, SporeScriptCategory>;

export interface SporeScriptCategory {
  versions: SporeScript[];
}

export interface SporeVersionedScript extends SporeScript {
  versions?: SporeScript[];
}

export type SporeScripts<T extends string> = Record<T, SporeScript>;

export interface SporeScript {
  tags: string[];
  script: ScriptId;
  cellDep: CellDep;
  behaviors?: SporeScriptBehaviors;
}

export interface SporeScriptBehaviors {
  lockProxy?: boolean;
  cobuild?: boolean;
  clusterDataVersion?: ClusterDataVersion;
  dynamicCelldep?: Script;
}


================================================
File: packages/core/src/helpers/address.ts
================================================
import { Address } from '@ckb-lumos/base';
import { helpers } from '@ckb-lumos/lumos';
import { Config } from '@ckb-lumos/config-manager';
import { FromInfo, parseFromInfo } from '@ckb-lumos/common-scripts';

/**
 * Check if the target address is valid.
 */
export function isAddressValid(address: Address, config?: Config) {
  try {
    helpers.parseAddress(address, { config });
    return true;
  } catch {
    return false;
  }
}

/**
 * Convert a FromInfo to a CKB address.
 */
export function fromInfoToAddress(fromInfo: FromInfo, config?: Config): Address {
  if (typeof fromInfo === 'string' && isAddressValid(fromInfo)) {
    return fromInfo as Address;
  }

  const parsed = parseFromInfo(fromInfo, { config });
  return helpers.encodeToAddress(parsed.fromScript, { config });
}


================================================
File: packages/core/src/helpers/buffer.ts
================================================
import { bytes, BytesLike } from '@ckb-lumos/codec';

const encoder = new TextEncoder();
const decoder = new TextDecoder();

export function bytifyRawString(text: string): Uint8Array {
  return encoder.encode(text);
}

export function bufferToRawString(source: BytesLike, options?: TextDecodeOptions): string {
  const buffer = bytes.bytify(source);
  return decoder.decode(buffer, options);
}


================================================
File: packages/core/src/helpers/capacity.ts
================================================
import cloneDeep from 'lodash/cloneDeep';
import { BIish } from '@ckb-lumos/bi/lib';
import { BI, helpers } from '@ckb-lumos/lumos';
import { Config } from '@ckb-lumos/config-manager/lib';
import { Address, Script, Cell } from '@ckb-lumos/base/lib';
import { common, FromInfo } from '@ckb-lumos/common-scripts/lib';
import { fromInfoToAddress } from './address';
import { isScriptValueEquals } from './script';

/**
 * Calculate target cell's minimal occupied capacity by lock script.
 */
export function minimalCellCapacityByLock(lock: Script): BI {
  return helpers.minimalCellCapacityCompatible({
    cellOutput: {
      capacity: '0x0',
      lock,
    },
    data: '0x',
  });
}

/**
 * Fix cell's minimal occupied capacity by 'helpers.minimalCellCapacityCompatible' API.
 * Note: this function will modify the original cell object.
 */
export function correctCellMinimalCapacity(cell: Cell): Cell {
  const occupiedCapacity = helpers.minimalCellCapacityCompatible(cell);
  if (!occupiedCapacity.eq(cell.cellOutput.capacity)) {
    cell.cellOutput.capacity = occupiedCapacity.toHexString();
  }

  return cell;
}

/**
 * Make sure the target cell has declared enough amount of capacity.
 */
export function assetCellMinimalCapacity(cell: Cell): void {
  const minimalCapacity = helpers.minimalCellCapacityCompatible(cell);
  if (minimalCapacity.gt(cell.cellOutput.capacity)) {
    const minimal = minimalCapacity.toString();
    const declared = BI.from(cell.cellOutput.capacity).toString();
    throw new Error(`Target cell required capacity of ${minimal}, but declared ${declared}`);
  }
}

/**
 * Calculate the target cell's capacity margin.
 * Could be negative if the cell's declared capacity is not enough.
 */
export function getCellCapacityMargin(cell: Cell): BI {
  const minimalCapacity = helpers.minimalCellCapacityCompatible(cell);
  return BI.from(cell.cellOutput.capacity).sub(minimalCapacity);
}

/**
 * Set absolute capacity margin for a cell.
 * The term 'absolute' means the cell's capacity will be: 'minimal capacity' + 'capacity margin'.
 */
export function setAbsoluteCapacityMargin(
  cell: Cell,
  capacityMargin: BIish | ((cell: Cell, margin: BI) => BIish),
): Cell {
  cell = cloneDeep(cell);

  const currentMargin = getCellCapacityMargin(cell);
  const margin: BIish = capacityMargin instanceof Function ? capacityMargin(cell, currentMargin) : capacityMargin;

  const minimalCapacity = helpers.minimalCellCapacityCompatible(cell);
  cell.cellOutput.capacity = minimalCapacity.add(margin).toHexString();
  return cell;
}

/**
 * Count the total declared capacity in a List<Cell>.
 */
export function getCellsTotalCapacity(cells: Cell[]): BI {
  return cells.reduce((sum, cell) => sum.add(cell.cellOutput.capacity), BI.from(0));
}

/**
 * The snapshot result of inputs/outputs from a Transaction.
 * Note that both inputsRemainCapacity/outputsRemainCapacity can be negative.
 */
export interface CapacitySnapshot {
  inputsLength: number;
  outputsLength: number;
  inputsCapacity: BI;
  outputsCapacity: BI;
  inputsRemainCapacity: BI;
  outputsRemainCapacity: BI;
}

/**
 * Summarize the capacity/length difference between inputs/outputs of a TransactionSkeleton.
 * This is a sugar function of 'createCapacitySnapshot'.
 */
export function createCapacitySnapshotFromTransactionSkeleton(
  txSkeleton: helpers.TransactionSkeletonType,
): CapacitySnapshot {
  return createCapacitySnapshot(txSkeleton.get('inputs').toArray(), txSkeleton.get('outputs').toArray());
}

/**
 * Summarize the capacity/length difference between inputs/outputs of a Transaction.
 */
export function createCapacitySnapshot(inputs: Cell[], outputs: Cell[]): CapacitySnapshot {
  const inputsCapacity = getCellsTotalCapacity(inputs);
  const outputsCapacity = getCellsTotalCapacity(outputs);
  const inputsRemainCapacity = inputsCapacity.sub(outputsCapacity);
  const outputsRemainCapacity = outputsCapacity.sub(inputsCapacity);

  return {
    inputsLength: inputs.length,
    outputsLength: outputs.length,
    inputsCapacity,
    outputsCapacity,
    inputsRemainCapacity,
    outputsRemainCapacity,
  };
}

/**
 * Calculates the capacity different in inputs/outputs of a Transaction,
 * then fix the change cell's containing capacity if inputs' total capacity has any left.
 *
 * Note: normally the change cell is the last cell in Transaction.outputs,
 * but if things are different, you can also provide the change cell's output index.
 */
export function correctChangeCellCapacity(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  changeOutputIndex?: number;
}): helpers.TransactionSkeletonType {
  let txSkeleton = props.txSkeleton;

  const snapshot = createCapacitySnapshotFromTransactionSkeleton(txSkeleton);

  if (snapshot.inputsRemainCapacity.gt(0)) {
    const outputIndex = props.changeOutputIndex ?? txSkeleton.get('outputs').size - 1;
    txSkeleton = txSkeleton.update('outputs', (outputs) => {
      const output = outputs.get(outputIndex);
      if (!output) {
        throw new Error('Cannot correct change cell capacity because Transaction.outputs is empty');
      }

      const oldCapacity = BI.from(output.cellOutput.capacity);
      output.cellOutput.capacity = oldCapacity.add(snapshot.inputsRemainCapacity).toHexString();
      return outputs;
    });
  }

  return txSkeleton;
}

/**
 * Calculate the capacity difference between inputs/outputs of a Transaction,
 * and see how much capacity is needed for the transaction to be constructed.
 */
export function calculateNeededCapacity(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  changeAddress: Address;
  extraCapacity?: BIish;
  config?: Config;
}): {
  snapshot: CapacitySnapshot;
  neededCapacity: BI;
  exceedCapacity: BI;
} {
  let txSkeleton = props.txSkeleton;

  const snapshot = createCapacitySnapshotFromTransactionSkeleton(txSkeleton);
  // const changeLock = helpers.parseAddress(props.changeAddress, { config: props.config });

  const extraCapacity = BI.from(props.extraCapacity ?? 0);
  // const minChangeCapacity = minimalCellCapacityByLock(changeLock).add(extraCapacity);

  let exceedCapacity = snapshot.inputsRemainCapacity;
  let neededCapacity = snapshot.outputsRemainCapacity.add(extraCapacity);

  // // Collect one more cell if:
  // // 1. Has sufficient capacity for transaction construction
  // // 2. Has insufficient capacity for adding a change cell to Transaction.outputs
  // const sufficientForTransaction = neededCapacity.lte(0) && exceedCapacity.gt(0);
  // const insufficientForChangeCell = exceedCapacity.lt(minChangeCapacity);
  // if (sufficientForTransaction && insufficientForChangeCell) {
  //   neededCapacity = minChangeCapacity.sub(exceedCapacity);
  //   exceedCapacity = BI.from(0);
  // }

  if (neededCapacity.lt(0)) {
    neededCapacity = BI.from(0);
  }
  if (exceedCapacity.lt(0)) {
    exceedCapacity = BI.from(0);
  }

  return {
    snapshot,
    neededCapacity,
    exceedCapacity,
  };
}

/**
 * Calculate the minimal required capacity for the transaction to be constructed,
 * and then collect cells to inputs, it also fills cellDeps and witnesses.
 * After collecting, it will generate an output to return unused ckb.
 */
export async function injectNeededCapacity(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  fromInfos: FromInfo[];
  config?: Config;
  extraCapacity?: BIish;
  changeAddress?: Address;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  before: CapacitySnapshot;
  after?: CapacitySnapshot;
}> {
  let txSkeleton = props.txSkeleton;

  const config = props.config;
  const changeAddress = fromInfoToAddress(props.changeAddress ?? props.fromInfos[0], config);

  // Calculate needed or exceeded capacity
  const calculated = calculateNeededCapacity({
    extraCapacity: props.extraCapacity,
    changeAddress,
    txSkeleton,
    config,
  });

  const before: CapacitySnapshot = calculated.snapshot;
  let after: CapacitySnapshot | undefined;

  // Collect needed capacity using `common.injectCapacity` API from lumos
  if (calculated.neededCapacity.gt(0)) {
    txSkeleton = await common.injectCapacity(
      txSkeleton,
      props.fromInfos,
      calculated.neededCapacity,
      props.changeAddress,
      void 0,
      {
        enableDeductCapacity: true, // Set adding extra capacity to the last output cell as a default option
        config: props.config,
      },
    );

    after = createCapacitySnapshotFromTransactionSkeleton(txSkeleton);
  }

  // If no needed capacity, and has exceeded capacity to be return as change
  if (calculated.neededCapacity.lte(0) && calculated.exceedCapacity.gt(0)) {
    const returnResult = returnExceededCapacity({
      txSkeleton,
      changeAddress,
      config,
    });

    if (returnResult.returnedChange) {
      txSkeleton = returnResult.txSkeleton;
    }
  }

  return {
    txSkeleton,
    before,
    after,
  };
}

/**
 * Return exceeded capacity in Transaction.inputs to Transaction.outputs as change.
 * The strategy is:
 * - If there is an unfixed last output with the same lock as change lock, then add the exceeded capacity to it.
 * - If no unfixed output with the same lock as change lock was found, generate a change cell to Transaction.outputs.
 */
export function returnExceededCapacity(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  changeAddress: Address;
  config?: Config;
}): {
  txSkeleton: helpers.TransactionSkeletonType;
  returnedChange: boolean;
  createdChangeCell: boolean;
  changeCellOutputIndex: number;
  unreturnedCapacity: BI;
} {
  // Summary inputs/outputs capacity status
  let txSkeleton = props.txSkeleton;
  const snapshot = createCapacitySnapshotFromTransactionSkeleton(txSkeleton);

  // Status
  let returnedChange: boolean = false;
  let createdChangeCell: boolean = false;
  let changeCellOutputIndex: number = -1;
  let unreturnedCapacity: BI = BI.from(0);

  // If no exceeded capacity, simply end the process
  if (snapshot.inputsRemainCapacity.lte(0)) {
    return {
      txSkeleton,
      returnedChange,
      createdChangeCell,
      changeCellOutputIndex,
      unreturnedCapacity,
    };
  }

  // If found any exceeded capacity
  returnedChange = true;

  const changeLock = helpers.parseAddress(props.changeAddress, {
    config: props.config,
  });

  // Find the last unfixed output with the same lock as change lock
  const fixedOutputs = txSkeleton
    .get('fixedEntries')
    .filter(({ field }) => field === 'outputs')
    .map(({ index }) => index);
  const matchLastOutputIndex = txSkeleton.get('outputs').findLastIndex((r, index) => {
    if (fixedOutputs.includes(index)) {
      return false;
    } else {
      return isScriptValueEquals(r.cellOutput.lock, changeLock) && r.cellOutput.type === void 0;
    }
  });

  if (matchLastOutputIndex > -1) {
    // If an unfixed output exists and its lock is the same as change lock,
    // then add the exceeded capacity to it.
    changeCellOutputIndex = matchLastOutputIndex;
    txSkeleton = txSkeleton.update('outputs', (outputs) => {
      const output = outputs.get(matchLastOutputIndex)!;
      output.cellOutput.capacity = BI.from(output.cellOutput.capacity).add(snapshot.inputsRemainCapacity).toHexString();

      return outputs.set(matchLastOutputIndex, output);
    });
  } else {
    // If no unfixed output with the same lock found in the outputs,
    // generate a change cell to Transaction.outputs.
    const changeCell: Cell = {
      cellOutput: {
        capacity: snapshot.inputsRemainCapacity.toHexString(),
        lock: changeLock,
      },
      data: '0x',
    };
    const minimalCapacity = helpers.minimalCellCapacityCompatible(changeCell);
    if (snapshot.inputsRemainCapacity.lt(minimalCapacity)) {
      unreturnedCapacity = snapshot.inputsRemainCapacity;
    } else {
      createdChangeCell = true;
      txSkeleton = txSkeleton.update('outputs', (outputs) => {
        changeCellOutputIndex = outputs.size;
        return outputs.push(changeCell);
      });
    }
  }

  return {
    txSkeleton,
    returnedChange,
    createdChangeCell,
    changeCellOutputIndex,
    unreturnedCapacity,
  };
}


================================================
File: packages/core/src/helpers/cell.ts
================================================
import { bytes } from '@ckb-lumos/codec';
import { Config } from '@ckb-lumos/config-manager';
import { common, FromInfo } from '@ckb-lumos/common-scripts';
import { Hash, OutPoint, PackedSince, Script } from '@ckb-lumos/base';
import { Cell, helpers, HexString, Indexer, RPC } from '@ckb-lumos/lumos';
import { CKBComponents } from '@ckb-lumos/rpc/lib/types/api';
import { ScriptId } from '../codec';
import { isScriptValueEquals } from './script';

export async function getCellByLock(props: { lock: Script; indexer: Indexer; has_type: boolean }) {
  const collector = props.indexer.collector({
    lock: props.lock,
  });

  for await (const cell of collector.collect()) {
    if (props.has_type && cell.cellOutput.type) {
      return cell;
    } else if (!props.has_type && !cell.cellOutput.type) return cell;
  }
  return void 0;
}

/**
 * Find and return the first cell of target type script from CKB Indexer.
 */
export async function getCellByType(props: { type: Script; indexer: Indexer }) {
  const collector = props.indexer.collector({
    type: props.type,
  });

  for await (const cell of collector.collect()) {
    return cell;
  }

  return void 0;
}

/**
 * A wrapper function, to get a Cell structure from RPC.getLiveCell() method.
 */
export async function getCellWithStatusByOutPoint(props: { outPoint: OutPoint; rpc: RPC }): Promise<{
  cell?: Cell;
  status: CKBComponents.CellStatus;
}> {
  const liveCell = await props.rpc.getLiveCell(props.outPoint, true);
  const cell: Cell | undefined = liveCell.cell
    ? {
        cellOutput: liveCell.cell.output,
        data: liveCell.cell.data.content,
        outPoint: props.outPoint,
      }
    : void 0;

  return {
    cell,
    status: liveCell.status,
  };
}

/**
 * Inject a cell to Transaction.inputs, and to Transaction.outputs if needed.
 * The function also adds needed/supported witness placeholders and cellDeps.
 */
export async function setupCell(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  input: Cell;
  fromInfo?: FromInfo;
  addOutput?: boolean;
  updateOutput?(cell: Cell): Cell;
  defaultWitness?: HexString;
  updateWitness?: HexString | ((witness: HexString) => HexString);
  since?: PackedSince;
  config?: Config;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  inputIndex: number;
  outputIndex: number;
}> {
  // Env
  const addOutput = props.addOutput ?? false;

  // Get TransactionSkeleton
  let txSkeleton = props.txSkeleton;

  // Add target cell to inputs and outputs,
  // the function also handles witnesses and cellDeps
  txSkeleton = await common.setupInputCell(txSkeleton, props.input, props.fromInfo, {
    defaultWitness: props.defaultWitness,
    config: props.config,
    since: props.since,
  });

  // Remove it from outputs if not needed
  if (!addOutput) {
    txSkeleton = txSkeleton.update('outputs', (outputs) => {
      return outputs.remove(outputs.size - 1);
    });
  }

  // Indices
  const inputIndex = txSkeleton.get('inputs').size - 1;
  const outputIndex = addOutput ? txSkeleton.get('outputs').size - 1 : -1;

  // If added output, and need to update the added output
  if (addOutput && props.updateOutput instanceof Function) {
    txSkeleton = txSkeleton.update('outputs', (outputs) => {
      const output = outputs.last();
      if (!output) {
        throw new Error('Cannot update output because the added output could not be found');
      }

      return outputs.set(outputIndex, props.updateOutput!(output));
    });
  }

  // If required to update the resulting witness placeholder
  if (props.updateWitness) {
    txSkeleton = txSkeleton.update('witnesses', (witnesses) => {
      if (props.updateWitness instanceof Function) {
        const witness = witnesses.get(inputIndex);
        if (!witness) {
          throw new Error(`Cannot update Transaction.witnesses[${inputIndex}] because it's undefined`);
        }
        return witnesses.set(inputIndex, props.updateWitness(witness));
      }
      if (typeof props.updateWitness === 'string') {
        return witnesses.set(inputIndex, props.updateWitness);
      }
      return witnesses;
    });
  }

  return {
    txSkeleton,
    inputIndex,
    outputIndex,
  };
}

/**
 * Group cells by TypeScriptID.
 */
export function groupCells(cells: Cell[]): Record<Hash | 'null', { index: number; cell: Cell }[]> {
  const groups: Record<Hash | 'null', { index: number; cell: Cell }[]> = {};
  for (let i = 0; i < cells.length; i++) {
    const cell = cells[i];
    const scriptIdHash = cell.cellOutput.type ? bytes.hexify(ScriptId.pack(cell.cellOutput.type)) : 'null';
    if (groups[scriptIdHash] === void 0) {
      groups[scriptIdHash] = [];
    }
    groups[scriptIdHash].push({
      index: i,
      cell,
    });
  }

  return groups;
}

export function findCellIndexByScriptFromTransactionSkeleton(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  source: 'inputs' | 'outputs';
  scriptName: 'lock' | 'type';
  script: Script;
}): number {
  if (!['inputs', 'outputs'].includes(props.source)) {
    throw new Error('Can only find cell from the following source: "inputs" | "outputs"');
  }
  if (!['lock', 'type'].includes(props.scriptName)) {
    throw new Error('Can only find cell from the following scriptType: "lock" | "type"');
  }

  const list = props.txSkeleton.get(props.source);
  return list.findIndex((cell) => {
    return !!cell.cellOutput[props.scriptName] && isScriptValueEquals(cell.cellOutput[props.scriptName]!, props.script);
  });
}


================================================
File: packages/core/src/helpers/cellDep.ts
================================================
import { Script } from '@ckb-lumos/base';
import { helpers, RPC } from '@ckb-lumos/lumos';
import { getSporeConfig, SporeConfig } from '../config';
import { getCellWithStatusByOutPoint } from './cell';
import { isScriptValueEquals } from './script';

export async function findCellDepIndexByTypeFromTransactionSkeleton(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  type: Script;
  config?: SporeConfig;
}) {
  const config = props.config ?? getSporeConfig();

  const rpc = new RPC(config.ckbNodeUrl);
  const cellDeps = props.txSkeleton.get('cellDeps');

  for await (const [index, cellDep] of cellDeps.toArray().entries()) {
    const target = await getCellWithStatusByOutPoint({
      outPoint: cellDep.outPoint,
      rpc,
    });

    if (target.cell?.cellOutput.type && isScriptValueEquals(target.cell.cellOutput.type, props.type)) {
      return index;
    }
  }

  return -1;
}


================================================
File: packages/core/src/helpers/contentType.ts
================================================
import { MimeType, parseMimeType, serializeMimeType } from './mimeType';

export interface EncodableContentType {
  type: string;
  subtype: string;
  parameters?: Record<string, any>;
}

export interface DecodedContentType {
  type: string;
  subtype: string;
  mediaType: string;
  parameters: Record<string, string | string[]>;
}

/**
 * Check if the target ContentType's format is valid.
 * - A typical MIME example: "image/jpeg".
 * - A more complex example: "image/svg+xml;q=0.9,/;q=0.8".
 */
export function isContentTypeValid(contentType: string): boolean {
  try {
    const decoded = decodeContentType(contentType);
    const encoded = encodeContentType(decoded);
    return encoded === contentType;
  } catch {
    return false;
  }
}

/**
 * Convert ContentType object to string.
 *
 * @example
 * encodeContentType({
 *   type: 'image',
 *   subtype: 'svg+xml',
 *   parameters: {
 *     a: 1,
 *     b: 2,
 *   },
 * })
 * // image/svg+xml;a=1;b=2
 */
export function encodeContentType(encodable: EncodableContentType): string {
  const originalParameters = Object.entries(encodable.parameters || {});
  const parameters: [string, string | string[]][] = originalParameters.map(([key, value]) => {
    if (key === 'mutant' || key === 'mutant[]') {
      [key, value] = encodeMutantParameter(key, value);
    }
    if (Array.isArray(value)) {
      value = value.map((row, index) => {
        if (typeof row !== 'string') {
          if (!(row['toString'] instanceof Function)) {
            throw new Error(`ContentType parameter "${key}" has a property that cannot be converted to string`);
          }
          row = row.toString();
        }
        return row;
      });
    }
    if (!Array.isArray(value) && typeof value !== 'string') {
      if (!(value['toString'] instanceof Function)) {
        throw new Error(`ContentType parameter "${key}" cannot be converted to string`);
      }
      value = value.toString();
    }

    return [key, value];
  });

  return serializeMimeType(
    {
      type: encodable.type,
      subtype: encodable.subtype,
      parameters: new Map(parameters),
    },
    {
      arrayParameters: true,
    },
  );
}

/**
 * Convert ContentType from string to object.
 *
 * @example
 * decodeContentType('image/svg+xml;a=1;b=2')
 * // {
 * //  type: 'image',
 * //  subtype: 'svg+xml',
 * //  mediaType: 'image/svg+xml',
 * //  parameters: { a: '1', b: '2' },
 * // }
 */
export function decodeContentType(contentType: string): DecodedContentType {
  let decoded: MimeType | null = null;
  try {
    decoded = parseMimeType(contentType, {
      arrayParameters: true,
    });
  } catch {
    // The error will be handled later
  }
  if (!decoded) {
    throw new Error(`Cannot decode ContentType: ${contentType}`);
  }

  const parameters = Object.fromEntries(decoded.parameters);
  if (parameters.mutant && Array.isArray(parameters.mutant)) {
    parameters.mutant = parameters.mutant.map((row: string) => {
      return !row.startsWith('0x') ? '0x' + row : row;
    });
  }

  return {
    type: decoded.type,
    subtype: decoded.subtype,
    mediaType: `${decoded.type}/${decoded.subtype}`,
    parameters,
  };
}

/**
 * Update the parameters of a content type string.
 * Note the function may change the order of the provided content type.
 *
 * @example
 * setContentTypeParameters('image/jpeg;a=1;b=2', { a: '3' });
 * // image/jpeg;a=3;b=2
 */
export function setContentTypeParameters(contentType: string, parameters: Record<string, any>): string {
  const decoded = decodeContentType(contentType);
  for (const [key, value] of Object.entries(parameters)) {
    decoded.parameters[key] = value;
  }

  return encodeContentType(decoded);
}

/**
 * Validate and convert parameters['mutant'] of ContentType to acceptable format.
 */
export function encodeMutantParameter(key: string, value: any[]): [string, string[]] {
  if (key === 'mutant[]') {
    key = 'mutant';
  }

  if (!Array.isArray(value)) {
    throw new Error(`ContentType parameter mutant should be an array`);
  }
  value = value.map((row, index) => {
    if (typeof row !== 'string') {
      if (!(row['toString'] instanceof Function)) {
        throw new Error(`ContentType parameter "${key}" has a property that cannot be converted to string`);
      }
      row = row.toString();
    }
    if (row.startsWith('0x')) {
      row = row.slice(2);
    }
    if (row.length !== 64) {
      throw new Error(`ContentType parameter mutant[${index}] should have a length of 32 bytes: ${row}`);
    }

    return row;
  });

  return [key, value];
}


================================================
File: packages/core/src/helpers/fee.ts
================================================
import { common, FromInfo } from '@ckb-lumos/common-scripts';
import { Address, Transaction } from '@ckb-lumos/base';
import { BI, Header, helpers, RPC } from '@ckb-lumos/lumos';
import { BIish } from '@ckb-lumos/bi';
import { getSporeConfig, SporeConfig } from '../config';
import { injectNeededCapacity, minimalCellCapacityByLock, returnExceededCapacity } from './capacity';
import { CapacitySnapshot, createCapacitySnapshotFromTransactionSkeleton } from './capacity';
import { getTransactionSize, getTransactionSkeletonSize } from './transaction';
import { fromInfoToAddress } from './address';

/**
 * Get minimal acceptable fee rate from RPC.
 */
export async function getMinFeeRate(rpc: RPC | string): Promise<BI> {
  rpc = typeof rpc === 'string' ? new RPC(rpc) : rpc;
  const info = await rpc.txPoolInfo();
  return BI.from(info.minFeeRate);
}

/**
 * Calculate transaction fee by transaction's byte size and feeRate.
 */
export function calculateFee(size: number, feeRate: BIish): BI {
  const ratio = BI.from(1000);
  const base = BI.from(size).mul(feeRate);
  const fee = base.div(ratio);
  if (fee.mul(ratio).lt(base)) {
    return fee.add(1);
  }
  return BI.from(fee);
}

/**
 * Calculate transaction fee by Transaction and a specific feeRate.
 */
export function calculateFeeByTransaction(tx: Transaction, feeRate: BIish): BI {
  const size = getTransactionSize(tx);
  return calculateFee(size, feeRate);
}

/**
 * Calculate transaction fee by TransactionSkeleton and a specific feeRate.
 */
export function calculateFeeByTransactionSkeleton(txSkeleton: helpers.TransactionSkeletonType, feeRate: BIish): BI {
  const tx = helpers.createTransactionFromSkeleton(txSkeleton);
  return calculateFeeByTransaction(tx, feeRate);
}

/**
 * Pay transaction fee via a capacity collection process,
 * using the minimal acceptable fee rate from the RPC.
 */
export async function payFeeThroughCollection(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  fromInfos: FromInfo[];
  changeAddress?: Address;
  feeRate?: BIish;
  tipHeader?: Header;
  enableDeductCapacity?: boolean;
  useLocktimeCellsFirst?: boolean;
  updateTxSkeletonAfterCollection?: (
    txSkeleton: helpers.TransactionSkeletonType,
  ) => Promise<helpers.TransactionSkeletonType> | helpers.TransactionSkeletonType;
  config?: SporeConfig;
}): Promise<helpers.TransactionSkeletonType> {
  // Env
  const config = props.config ?? getSporeConfig();
  const feeRate = props.feeRate ?? (await getMinFeeRate(config.ckbNodeUrl));

  let size = 0;
  let newTxSkeleton = props.txSkeleton;

  /**
   * Loop the collection process until the transaction size is no longer increasing.
   * This is to ensure that the transaction size is as small as possible.
   */
  let currentTransactionSize = getTransactionSkeletonSize(newTxSkeleton);
  while (currentTransactionSize > size) {
    size = currentTransactionSize;
    const fee = calculateFee(size, feeRate);

    newTxSkeleton = await common.injectCapacity(
      props.txSkeleton,
      props.fromInfos,
      fee,
      props.changeAddress,
      props.tipHeader,
      {
        config: config.lumos,
        enableDeductCapacity: props.enableDeductCapacity,
        useLocktimeCellsFirst: props.useLocktimeCellsFirst,
      },
    );

    /**
     * When injection is made and has passed the "updateTxSkeletonUpdateCollection" function,
     * the function will be called to update the TransactionSkeleton as needed.
     */
    if (props.updateTxSkeletonAfterCollection) {
      newTxSkeleton = await props.updateTxSkeletonAfterCollection(newTxSkeleton);
    }

    currentTransactionSize = getTransactionSkeletonSize(newTxSkeleton);
  }

  return newTxSkeleton;
}

/**
 * Specify an output to pay transaction fee.
 */
export async function payFeeByOutput(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  outputIndex: number;
  feeRate?: BIish;
  config?: SporeConfig;
}): Promise<helpers.TransactionSkeletonType> {
  // Env
  const config = props.config ?? getSporeConfig();
  const feeRate = props.feeRate ?? (await getMinFeeRate(config.ckbNodeUrl));

  // Get TransactionSkeleton
  let txSkeleton = props.txSkeleton;

  // Get target output cell
  let outputs = txSkeleton.get('outputs');
  const output = outputs.get(props.outputIndex);
  if (!output) {
    throw new Error(`Cannot pay fee by Transaction.outputs[${props.outputIndex}] because it does not exist`);
  }

  // Check can pay fee with capacity margin
  const minimalCellCapacity = helpers.minimalCellCapacityCompatible(output);
  const outputCapacity = BI.from(output.cellOutput.capacity);
  const capacityMargin = outputCapacity.sub(minimalCellCapacity);
  const fee = calculateFeeByTransactionSkeleton(txSkeleton, feeRate);
  if (capacityMargin.lt(fee)) {
    throw new Error(`Cannot pay fee by Transaction.outputs[${props.outputIndex}] due to insufficient capacity`);
  }

  // Pay fee and update capacity
  output.cellOutput.capacity = outputCapacity.sub(fee).toHexString();
  outputs = outputs.set(props.outputIndex, output);
  return txSkeleton.set('outputs', outputs);
}

/**
 * Inject the needed amount of capacity,
 * and then pay the transaction fee via a capacity collection process.
 */
export async function injectCapacityAndPayFee(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  fromInfos: FromInfo[];
  config?: SporeConfig;
  feeRate?: BIish;
  extraCapacity?: BIish;
  changeAddress?: Address;
  updateTxSkeletonAfterCollection?: (
    txSkeleton: helpers.TransactionSkeletonType,
  ) => Promise<helpers.TransactionSkeletonType> | helpers.TransactionSkeletonType;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  before: CapacitySnapshot;
  after: CapacitySnapshot;
}> {
  // Env
  const config = props.config ?? getSporeConfig();

  // Add a new change cell for receiving change capacity as default
  const changeAddress = fromInfoToAddress(props.changeAddress ?? props.fromInfos[0], config.lumos);
  const changeLock = helpers.addressToScript(changeAddress, { config: config.lumos });
  props.txSkeleton = props.txSkeleton.update('outputs', (outputs) => {
    return outputs.push({
      cellOutput: {
        capacity: minimalCellCapacityByLock(changeLock).toHexString(),
        lock: changeLock,
      },
      data: '0x',
    });
  });

  // Collect capacity
  const injectNeededCapacityResult = await injectNeededCapacity({
    ...props,
    config: config.lumos,
  });

  // Pay fee
  const txSkeleton = await payFeeThroughCollection({
    ...props,
    txSkeleton: injectNeededCapacityResult.txSkeleton,
  });

  return {
    txSkeleton,
    before: injectNeededCapacityResult.before,
    after: createCapacitySnapshotFromTransactionSkeleton(txSkeleton),
  };
}

/**
 * Return exceeded capacity (change) to the outputs and then pay fee by the change cell.
 */
export async function returnExceededCapacityAndPayFee(props: {
  txSkeleton: helpers.TransactionSkeletonType;
  changeAddress: Address;
  fromInfos?: FromInfo[];
  config?: SporeConfig;
  feeRate?: BIish;
}): Promise<{
  txSkeleton: helpers.TransactionSkeletonType;
  changeCellOutputIndex: number;
  createdChangeCell: boolean;
}> {
  let txSkeleton = props.txSkeleton;
  const config = props.config ?? getSporeConfig();

  // Return exceeded (change) capacity
  const returnExceededCapacityResult = returnExceededCapacity({
    txSkeleton,
    config: config.lumos,
    changeAddress: props.changeAddress,
  });
  txSkeleton = returnExceededCapacityResult.txSkeleton;

  // If no change was returned, throw error as it is unexpected
  if (!returnExceededCapacityResult.returnedChange) {
    throw new Error(`Cannot pay fee with change cell because no change was returned`);
  }

  if (returnExceededCapacityResult.unreturnedCapacity.gt(0)) {
    if (props.fromInfos === void 0) {
      throw new Error(`Cannot pay fee with change cell because fromInfos is required`);
    }
    // Pay fee by capacity collection
    const feeRate = props.feeRate ?? (await getMinFeeRate(config.ckbNodeUrl));
    const fee = calculateFeeByTransactionSkeleton(txSkeleton, feeRate);
    txSkeleton = await common.injectCapacity(txSkeleton, props.fromInfos, 1, props.changeAddress, void 0, {
      enableDeductCapacity: false,
      config: props.config?.lumos,
    });
    txSkeleton = txSkeleton.update('outputs', (outputs) => {
      outputs.update(-1, (output) => {
        if (output) {
          const capacity = BI.from(output.cellOutput.capacity);
          output.cellOutput.capacity = capacity
            .add(returnExceededCapacityResult.unreturnedCapacity)
            .sub(fee)
            .toHexString();
        }
        return output;
      });
      return outputs;
    });
  } else {
    // Pay fee by change cell in outputs
    txSkeleton = await payFeeByOutput({
      outputIndex: returnExceededCapacityResult.changeCellOutputIndex,
      txSkeleton,
      feeRate: props.feeRate,
      config,
    });
  }

  return {
    txSkeleton,
    createdChangeCell: returnExceededCapacityResult.createdChangeCell,
    changeCellOutputIndex: returnExceededCapacityResult.changeCellOutputIndex,
  };
}


================================================
File: packages/core/src/helpers/index.ts
================================================
// Bytes
export * from './buffer';

// Utils
export * from './retryWork';

// Blockchain
export * from './cell';
export * from './cellDep';
export * from './script';
export * from './address';
export * from './typeId';
export * from './capacity';
export * from './transaction';
export * from './witness';
export * from './fee';

// Core
export * from './mimeType';
export * from './contentType';
export * from './multipartContent';
export * from './lockProxy';


================================================
File: packages/core/src/helpers/lockProxy.ts
================================================
import { Cell, Script } from '@ckb-lumos/base';
import { TransactionSkeletonType } from '@ckb-lumos/helpers';
import { addCellDep } from '@ckb-lumos/common-scripts/lib/helper';
import { isScriptValueEquals } from './script';
import { PromiseOr } from '../types';

export async function referenceCellOrLockProxy(props: {
  txSkeleton: TransactionSkeletonType;
  cell: Cell;
  inputLocks: Script[];
  outputLocks: Script[];
  referenceCell: (txSkeleton: TransactionSkeletonType) => PromiseOr<TransactionSkeletonType>;
  referenceLockProxy: (txSkeleton: TransactionSkeletonType) => PromiseOr<TransactionSkeletonType>;
  addCellToCellDeps?: boolean;
}): Promise<{
  txSkeleton: TransactionSkeletonType;
  referencedCell: boolean;
  referencedLockProxy: boolean;
}> {
  // Env
  const addCellToCellDeps = props.addCellToCellDeps ?? true;

  // TransactionSkeleton
  let txSkeleton = props.txSkeleton;

  // The reference cell
  const cell = props.cell;
  const cellLock = cell.cellOutput.lock;
  if (!cell.outPoint) {
    throw new Error('Cannot reference cell because target cell has no OutPoint');
  }

  // Inputs/Outputs conditions
  const hasTargetLockInInputs = props.inputLocks.some((script) => {
    return isScriptValueEquals(cellLock, script);
  });
  const hasTargetLockInOutputs = props.outputLocks.some((script) => {
    return isScriptValueEquals(cellLock, script);
  });

  // Summarize conditions
  const referencedLockProxy = hasTargetLockInInputs && hasTargetLockInOutputs;
  const referencedCell = !hasTargetLockInInputs || !hasTargetLockInOutputs;
  console.log('referencedLockProxy = ', referencedLockProxy);

  // Inject the target cell's LockProxy to the transaction
  if (referencedLockProxy) {
    txSkeleton = await props.referenceLockProxy(txSkeleton);
  }

  // Inject the target cell directly to inputs & outputs
  if (referencedCell) {
    txSkeleton = await props.referenceCell(txSkeleton);
  }

  // Add the target cell as cell dep to cellDeps
  if (addCellToCellDeps) {
    txSkeleton = addCellDep(txSkeleton, {
      outPoint: cell.outPoint!,
      depType: 'code',
    });
  }

  return {
    txSkeleton,
    referencedCell,
    referencedLockProxy,
  };
}


================================================
File: packages/core/src/helpers/mimeType.ts
================================================
/**
 * Copyright Â© Domenic Denicola <d@domenic.me>
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
/**
 * A MIME parser/serializer module, extended from the @jsdom/whatwg-mimetype library.
 * Visit source code on GitHub: https://github.com/jsdom/whatwg-mimetype
 */

export interface MimeType {
  type: string;
  subtype: string;
  parameters: Map<string, string | string[]>;
}

export interface MimeTypeOptions {
  arrayParameters?: boolean;
}

/**
 * Convert MIME string to MimeType object.
 * @example
 * parseMimeType('image/svg+xml;q=";";q=0.8')
 * // {
 * //  type: 'image',
 * //  subtype: 'svg+xml',
 * //  parameters: Map(1) { 'q' => ';' },
 * // }
 */
export function parseMimeType(input: string, options?: MimeTypeOptions): MimeType | null {
  const supportArray = options?.arrayParameters ?? false;

  input = removeLeadingAndTrailingHTTPWhitespace(input);

  let position = 0;
  let type = '';
  while (position < input.length && input[position] !== '/') {
    type += input[position];
    ++position;
  }

  if (type.length === 0 || !solelyContainsHTTPTokenCodePoints(type)) {
    return null;
  }

  if (position >= input.length) {
    return null;
  }

  // Skips past "/"
  ++position;

  let subtype = '';
  while (position < input.length && input[position] !== ';') {
    subtype += input[position];
    ++position;
  }

  subtype = removeTrailingHTTPWhitespace(subtype);

  if (subtype.length === 0 || !solelyContainsHTTPTokenCodePoints(subtype)) {
    return null;
  }

  const mimeType = {
    type: asciiLowercase(type),
    subtype: asciiLowercase(subtype),
    parameters: new Map<string, string | string[]>(),
  };

  while (position < input.length) {
    // Skip past ";"
    ++position;

    while (isHTTPWhitespaceChar(input[position])) {
      ++position;
    }

    let parameterName = '';
    while (position < input.length && input[position] !== ';' && input[position] !== '=') {
      parameterName += input[position];
      ++position;
    }
    parameterName = asciiLowercase(parameterName);

    if (position < input.length) {
      if (input[position] === ';') {
        continue;
      }

      // Skip past "="
      ++position;
    }

    let parameterValue = null;
    if (input[position] === '"') {
      [parameterValue, position] = collectAnHTTPQuotedString(input, position);

      while (position < input.length && input[position] !== ';') {
        ++position;
      }
    } else {
      parameterValue = '';
      while (position < input.length && input[position] !== ';') {
        parameterValue += input[position];
        ++position;
      }

      parameterValue = removeTrailingHTTPWhitespace(parameterValue);

      if (parameterValue === '') {
        continue;
      }
    }

    const parameterNameNotEmpty = parameterName.length > 0;
    const parameterNameSuggestArray = parameterName.endsWith('[]');
    if (!parameterNameNotEmpty || (parameterNameSuggestArray && !supportArray)) {
      continue;
    }

    // Remove the sign of Array types.
    // For example, "a[]" -> "a".
    const performArrayMode = parameterNameNotEmpty && parameterNameSuggestArray && supportArray;
    if (performArrayMode) {
      parameterName = parameterName.slice(0, -2);
    }

    const parameterIsNew = !mimeType.parameters.has(parameterName);
    const parameterNameInRange = solelyContainsHTTPTokenCodePoints(parameterName);
    const parameterValueInRange = solelyContainsHTTPQuotedStringTokenCodePoints(parameterValue);
    if (parameterNameNotEmpty && parameterNameInRange && parameterValueInRange && parameterIsNew) {
      // Convert String type parameter value to Array.
      // For example, "1,2,3" -> ['1', '2', '3'].
      if (performArrayMode) {
        parameterValue = parameterValue.split(',');
      }

      mimeType.parameters.set(parameterName, parameterValue);
    }
  }

  return mimeType;
}

/**
 * Convert MIME string to MimeType object.
 * @example
 * parseMimeType({
 *   type: 'image',
 *   subtype: 'svg+xml',
 *   parameters: new Map([
 *     ['a', '1'],
 *     ['b', '2'],
 *   ]),
 * })
 * // image/svg+xml;a=1;b=2
 */
export function serializeMimeType(mimeType: MimeType, options?: MimeTypeOptions): string {
  const supportArray = options?.arrayParameters ?? false;

  let serialization = `${mimeType.type}/${mimeType.subtype}`;

  if (mimeType.parameters.size === 0) {
    return serialization;
  }

  for (let [name, value] of mimeType.parameters) {
    if (!supportArray && Array.isArray(value)) {
      throw new Error('Array parameter value is not supported');
    }
    if (Array.isArray(value)) {
      name = !name.endsWith('[]') ? `${name}[]` : name;
      value = (value as string[]).join(',');
    }

    serialization += ';';
    serialization += name;
    serialization += '=';

    if (!solelyContainsHTTPTokenCodePoints(value) || value.length === 0) {
      value = value.replace(/(["\\])/gu, '\\$1');
      value = `"${value}"`;
    }

    serialization += value;
  }

  return serialization;
}

export function removeLeadingAndTrailingHTTPWhitespace(string: string): string {
  return string.replace(/^[ \t\n\r]+/u, '').replace(/[ \t\n\r]+$/u, '');
}

export function removeTrailingHTTPWhitespace(string: string): string {
  return string.replace(/[ \t\n\r]+$/u, '');
}

export function isHTTPWhitespaceChar(char: string): boolean {
  return char === ' ' || char === '\t' || char === '\n' || char === '\r';
}

export function solelyContainsHTTPTokenCodePoints(string: string): boolean {
  return /^[-!#$%&'*+.^_`|~A-Za-z0-9]*$/u.test(string);
}

// Extends from the "solelyContainsHTTPTokenCodePoints()" function.
// Supports additional "[]" characters.
export function solelyContainsExtendedHTTPTokenCodePoints(string: string): boolean {
  return /^[-!#$%&'*+.^_`|~\[\]A-Za-z0-9]*$/u.test(string);
}

export function solelyContainsHTTPQuotedStringTokenCodePoints(string: string): boolean {
  return /^[\t\u0020-\u007E\u0080-\u00FF]*$/u.test(string);
}

export function asciiLowercase(string: string) {
  return string.replace(/[A-Z]/gu, (l) => l.toLowerCase());
}

// This variant only implements it with the extract-value flag set.
export function collectAnHTTPQuotedString(input: string, position: number): [string, number] {
  let value = '';

  position++;

  while (true) {
    while (position < input.length && input[position] !== '"' && input[position] !== '\\') {
      value += input[position];
      ++position;
    }

    if (position >= input.length) {
      break;
    }

    const quoteOrBackslash = input[position];
    ++position;

    if (quoteOrBackslash === '\\') {
      if (position >= input.length) {
        value += '\\';
        break;
      }

      value += input[position];
      ++position;
    } else {
      break;
    }
  }

  return [value, position];
}


================================================
File: packages/core/src/helpers/multipartContent.ts
================================================
import { bytes, BytesLike } from '@ckb-lumos/codec';
import parseMultipartMessage, { encodeMultipartMessage } from '@exact-realty/multipart-parser';
import { TDecodedMultipartMessage } from '@exact-realty/multipart-parser/dist/encodeMultipartMessage';
import { TMultipartMessageGenerator } from '@exact-realty/multipart-parser/dist/parseMultipartMessage';
import { TTypedArray } from '@exact-realty/multipart-parser/dist/types';
import { bufferToRawString, bytifyRawString } from './buffer';

export type AsyncableIterable<T> = AsyncIterable<T> | Iterable<T>;

export type ResolvedMultipartContent = {
  headers: Headers;
  body?: Uint8Array | null;
  parts?: ResolvedMultipartContent[] | null;
};

export async function decodeMultipartContent(message: string, boundary: string): Promise<ResolvedMultipartContent[]> {
  const buf = bytifyRawString(replaceNewLineToCRLF(message));
  return decodeMultipartContentFromBytes(buf, boundary);
}

export async function decodeMultipartContentFromBytes(
  buf: BytesLike,
  boundary: string,
): Promise<ResolvedMultipartContent[]> {
  const stream = new Blob([bytes.bytify(buf)]).stream();
  return decodeMultipartContentFromStream(stream, boundary);
}

export async function decodeMultipartContentFromStream<T extends TTypedArray>(
  stream: ReadableStream<T>,
  boundary: string,
): Promise<ResolvedMultipartContent[]> {
  async function parseMimeRecursively(messages: TMultipartMessageGenerator): Promise<ResolvedMultipartContent[]> {
    const chunks: ResolvedMultipartContent[] = [];
    for await (const chunk of messages) {
      if (chunk.parts) {
        const parts = await parseMimeRecursively(chunk.parts);
        chunks.push({
          ...chunk,
          parts,
        });
      } else {
        chunks.push({
          headers: chunk.headers,
          body: chunk.body,
        });
      }
    }

    return chunks;
  }

  const firstLayer = parseMultipartMessage(stream, boundary);
  return parseMimeRecursively(firstLayer);
}

export async function encodeMultipartContent(
  boundary: string,
  message: AsyncableIterable<TDecodedMultipartMessage>,
): Promise<{
  stream: ReadableStream<ArrayBuffer>;
  buffer: ArrayBuffer;
  bufferChunks: ArrayBuffer[];
  rawStringChunks: string[];
  byteLength: number;
  codeUnitLength: number;
}> {
  const stream = encodeMultipartMessage(boundary, message);
  const result = await readArrayBufferStream(stream);

  return {
    stream,
    ...result,
  };
}

export async function readArrayBufferStream(stream: ReadableStream<ArrayBuffer>): Promise<{
  buffer: ArrayBuffer;
  bufferChunks: ArrayBuffer[];
  rawStringChunks: string[];
  byteLength: number;
  codeUnitLength: number;
}> {
  const reader = stream.getReader();

  const bufferChunks: ArrayBuffer[] = [];
  const rawStringChunks: string[] = [];
  let codeUnitLength = 0;

  while (true) {
    const chunk = await reader.read();
    if (chunk.done) {
      break;
    }

    bufferChunks.push(chunk.value);

    const rawString = bufferToRawString(chunk.value);
    codeUnitLength += rawString.length;
    rawStringChunks.push(rawString);
  }

  const buffer = await new Blob(bufferChunks).arrayBuffer();
  const byteLength = buffer.byteLength;

  return {
    buffer,
    bufferChunks,
    rawStringChunks,
    byteLength,
    codeUnitLength,
  };
}

export async function isMultipartContentValid(message: string, boundary: string): Promise<boolean> {
  try {
    await decodeMultipartContent(message, boundary);
    return true;
  } catch {
    return false;
  }
}

export async function isMultipartContentAsBytesValid(buf: BytesLike, boundary: string): Promise<boolean> {
  try {
    await decodeMultipartContentFromBytes(buf, boundary);
    return true;
  } catch {
    return false;
  }
}

function replaceNewLineToCRLF(str: string) {
  return str.replace(/\r\n/g, '\n').replace(/\n/g, '\r\n');
}


================================================
File: packages/core/src/helpers/retryWork.ts
================================================
export interface RetryWorkResult<T, E = any> {
  result: T | undefined;
  success: boolean;
  errors: E[];
  retries: number;
  duration: number;
}

export interface RetryWorkIntervalContext {
  retries: number;
}

/**
 * A util function to run a getter code and retry if it fails.
 * This is useful when you're fetching changes from the internet.
 */
export function retryWork<T, E = any>(props: {
  getter: () => T | Promise<T>;
  retry?: number;
  delay?: number;
  interval?: number | ((context: RetryWorkIntervalContext) => number);
  onError?: (e: E) => boolean | Promise<boolean>;
  onComplete?: (value: T) => boolean | Promise<boolean>;
}): Promise<RetryWorkResult<T, E>> {
  const isDynamicInterval = props.interval instanceof Function;
  const staticInterval = isDynamicInterval ? 100 : (props.interval as number | undefined) ?? 100;

  const delay = props.delay ?? 0;
  const maxRetry = props.retry ?? 3;
  const onError = props.onError ?? (() => true);
  const onComplete = props.onComplete ?? (() => true);

  return new Promise<RetryWorkResult<T, E>>(async (resolve) => {
    // Record
    const startTime = Date.now();
    const errors: E[] = [];

    // Status
    let retries = 0;
    let result: T | undefined;
    let isRejected = false;
    let isCompleted = false;

    function dynamicInterval() {
      return (props.interval as (context: RetryWorkIntervalContext) => number)({
        retries,
      });
    }
    async function event(): Promise<void> {
      try {
        result = await props.getter();
        if (onComplete(result)) {
          isCompleted = true;
        } else {
          retries++;
        }
      } catch (e: any) {
        errors.push(e);
        if (await onError(e)) {
          retries++;
        } else {
          isRejected = true;
        }
      }

      if (isCompleted) {
        return resolve({
          success: true,
          result,
          errors,
          retries,
          duration: Date.now() - startTime,
        });
      }
      if (isRejected || retries >= maxRetry) {
        return resolve({
          success: false,
          result: void 0,
          errors,
          retries,
          duration: Date.now() - startTime,
        });
      }

      const interval = isDynamicInterval ? dynamicInterval() : staticInterval;
      setTimeout(() => event(), interval);
    }

    if (delay > 0) {
      await waitForMilliseconds(delay);
    }
    await event();
  });
}

export function waitForMilliseconds(ms: number): Promise<void> {
  return new Promise((resolve) => {
    setTimeout(() => resolve(), ms);
  });
}


================================================
File: packages/core/src/helpers/script.ts
================================================
import cloneDeep from 'lodash/cloneDeep';
import { helpers } from '@ckb-lumos/lumos';
import { Config } from '@ckb-lumos/config-manager';
import { Address, Script, values } from '@ckb-lumos/base';
import { FromInfo, parseFromInfo } from '@ckb-lumos/common-scripts';
import { ScriptId } from '../types';

/**
 * Compare two scripts to see if they are identical.
 */
export function isScriptValueEquals(a: Script, b: Script) {
  return a.codeHash === b.codeHash && a.hashType === b.hashType && a.args === b.args;
}

/**
 * Compare two scripts to see if their 'codeHash' and 'hashType' are the same.
 */
export function isScriptIdEquals(a: ScriptId, b: ScriptId) {
  return a.codeHash === b.codeHash && a.hashType === b.hashType;
}

/**
 * Get change lock of a transaction.
 */
export function getChangeLock(fromInfos: FromInfo[], changeAddress?: Address, config?: Config): Script {
  const firstFromInfo = parseFromInfo(fromInfos[0], { config });
  const changeAddressLock = changeAddress ? helpers.parseAddress(changeAddress, { config }) : void 0;

  return changeAddressLock ?? firstFromInfo.fromScript;
}

/**
 * Assemble locks of Transaction.inputs.
 */
export function composeInputLocks(props: { fromInfos: FromInfo[]; inputLocks?: Script[]; config?: Config }): Script[] {
  const config = props.config;
  const inputLocks = Array.isArray(props.inputLocks) ? cloneDeep(props.inputLocks) : [];

  const fromInfoLocks = props.fromInfos.map((fromInfo) => {
    return parseFromInfo(fromInfo, { config }).fromScript;
  });

  return [...inputLocks, ...fromInfoLocks];
}

/**
 * Assemble possible locks of Transaction.outputs.
 */
export function composeOutputLocks(props: {
  fromInfos: FromInfo[];
  outputLocks?: Script[];
  changeAddress?: Address;
  config?: Config;
}): Script[] {
  const config = props.config;
  const outputLocks = Array.isArray(props.outputLocks) ? cloneDeep(props.outputLocks) : [];

  let changeLock: Script;
  if (props.changeAddress) {
    changeLock = helpers.parseAddress(props.changeAddress, { config });
  } else {
    changeLock = parseFromInfo(props.fromInfos[0], { config }).fromScript;
  }

  const foundIndex = outputLocks.findIndex((script) => isScriptValueEquals(script, changeLock));
  if (foundIndex < 0) {
    outputLocks.push(changeLock);
  }

  return outputLocks;
}


================================================
File: packages/core/src/helpers/transaction.ts
================================================
import { Transaction, blockchain, Hash, TransactionWithStatus } from '@ckb-lumos/base';
import { helpers, RPC } from '@ckb-lumos/lumos';
import { retryWork, RetryWorkResult } from './retryWork';

/**
 * Calculates the size of a transaction.
 *
 * Note: Why adding 4 bytes to the size of transaction:
 * [Calculate transaction fee](https://github.com/nervosnetwork/ckb/wiki/Transaction-%C2%BB-Transaction-Fee#calculate-transaction-fee)
 */
export function getTransactionSize(tx: Transaction): number {
  const serializedTx = blockchain.Transaction.pack(tx);
  return 4 + serializedTx.buffer.byteLength;
}

/**
 * Calculates the size of a TransactionSkeleton.
 */
export function getTransactionSkeletonSize(txSkeleton: helpers.TransactionSkeletonType): number {
  const tx = helpers.createTransactionFromSkeleton(txSkeleton);
  return getTransactionSize(tx);
}

/**
 * Check if the Transaction's size (in bytes) is as expected.
 * Expected: min < size <= max.
 */
export function isTransactionSizeInRange(tx: Transaction, min?: number, max?: number): boolean {
  const size = getTransactionSize(tx);
  return size <= (min ?? 0) || size > (max ?? Infinity);
}

/**
 * Check if the TransactionSkeleton's size (in bytes) is as expected.
 * Expected: min < size <= max.
 */
export function isTransactionSkeletonSizeInRange(
  txSkeleton: helpers.TransactionSkeletonType,
  min?: number,
  max?: number,
): boolean {
  const tx = helpers.createTransactionFromSkeleton(txSkeleton);
  return isTransactionSizeInRange(tx, min, max);
}

/**
 * Throw an error if the Transaction's size (in bytes) is not as expected.
 * Expected: min < size <= max.
 */
export function assetTransactionSize(tx: Transaction, min?: number, max?: number): void {
  min = min ?? 0;
  max = max ?? Infinity;

  const size = getTransactionSize(tx);
  if (size <= min) {
    throw new Error(`Expected the transaction size to be > ${min}, actual size: ${size}`);
  }
  if (size > max) {
    throw new Error(`Expected the transaction size to be <= ${max}, actual size: ${size}`);
  }
}

/**
 * Throw an error if the TransactionSkeleton's size (in bytes) is not as expected.
 * Expected: min < size <= max.
 */
export function assertTransactionSkeletonSize(
  txSkeleton: helpers.TransactionSkeletonType,
  min?: number,
  max?: number,
): void {
  const tx = helpers.createTransactionFromSkeleton(txSkeleton);
  assetTransactionSize(tx, min, max);
}

/**
 * Wait for a transaction to be committed on the blockchain.
 * This function returns a RetryWorkResult, including detailed info like the duration of the process.
 */
export async function waitForTransactionRetryWork(
  hash: Hash,
  rpc: RPC,
): Promise<RetryWorkResult<TransactionWithStatus>> {
  return await retryWork({
    getter: () => rpc.getTransaction(hash),
    retry: 6,
    interval({ retries }) {
      return 1000 * Math.pow(2, retries);
    },
    onComplete(tx) {
      switch (tx.txStatus.status) {
        case 'rejected':
          throw new Error(`Transaction rejected: ${hash}, reason: ${tx.txStatus.reason}`);
        case 'committed':
          return true;
        default:
          return false;
      }
    },
  });
}

/**
 * Wait for a transaction to be committed on the blockchain.
 * If waited too long or the transaction is rejected, throw an error.
 */
export async function waitForTransaction(hash: Hash, rpc: RPC): Promise<TransactionWithStatus> {
  const fetched = await waitForTransactionRetryWork(hash, rpc);
  if (fetched.success) {
    return fetched.result!;
  } else {
    throw new Error(`Failed to wait for transaction: ${hash}, reason: ${fetched.errors[fetched.errors.length - 1]}`);
  }
}


================================================
File: packages/core/src/helpers/typeId.ts
================================================
import { BI, Cell, utils } from '@ckb-lumos/lumos';
import { BIish } from '@ckb-lumos/bi';
import { Hash } from '@ckb-lumos/base';
import { BytesLike } from '@ckb-lumos/codec';
import { bytes } from '@ckb-lumos/codec';

/**
 * Generate a TypeId based on the first input in Transaction.inputs,
 * and the index of the target cell in Transaction.outputs.
 */
export function generateTypeId(firstInput: Cell, outputIndex: BIish): Hash {
  if (!firstInput.outPoint) {
    throw new Error('Cannot generate TypeId because Transaction.inputs[0] has no OutPoint');
  }

  const script = utils.generateTypeIdScript(
    {
      previousOutput: firstInput.outPoint,
      since: '0x0',
    },
    BI.from(outputIndex).toHexString(),
  );

  return script.args;
}

/**
 * Generate TypeIds for a group of cells in Transaction.outputs.
 */
export function generateTypeIdGroup(
  firstInput: Cell,
  outputs: Cell[],
  filter: (cell: Cell) => boolean,
): [number, Hash][] {
  const group: [number, Hash][] = [];

  for (let i = 0; i < outputs.length; i++) {
    const isTarget = filter(outputs[i]);
    if (isTarget) {
      const groupIndex = group.length;
      group.push([i, generateTypeId(firstInput, groupIndex)]);
    }
  }

  return group;
}

/**
 * Generate TypeIds from a Transaction.outputs.
 *
 * This function is different from the `generateTypeIdGroup` function,
 * because this function generates TypeIds based on each output's original index in the list,
 * instead of generating them by each output's index in a group.
 */
export function generateTypeIdsByOutputs(
  firstInput: Cell,
  outputs: Cell[],
  filter?: (cell: Cell) => boolean,
): [number, Hash][] {
  function filterOutput(cell: Cell): boolean {
    return filter instanceof Function ? filter(cell) : true;
  }

  const result: [number, Hash][] = [];
  for (let i = 0; i < outputs.length; i++) {
    if (filterOutput(outputs[i])) {
      result.push([i, generateTypeId(firstInput, i)]);
    }
  }

  return result;
}

/**
 * Check if the target string is a Type ID
 */
export function isTypeId(target: BytesLike): boolean {
  try {
    const buf = bytes.bytify(target);
    return buf.byteLength === 32;
  } catch {
    return false;
  }
}

/**
 * Check if the target string at least contains is a Type ID
 */
export function isTypeIdLengthMatch(target: BytesLike): boolean {
  try {
    const buf = bytes.bytify(target);
    return buf.byteLength >= 32;
  } catch {
    return false;
  }
}


================================================
File: packages/core/src/helpers/witness.ts
================================================
import { bytes, BytesLike } from '@ckb-lumos/codec';
import { blockchain } from '@ckb-lumos/base';

type WitnessArgsObject = Parameters<(typeof blockchain.WitnessArgs)['pack']>[0];
type WitnessArgsKey = keyof WitnessArgsObject;

export const defaultEmptyWitnessArgs = bytes.hexify(blockchain.WitnessArgs.pack({}));

/**
 * Update a property value of a WitnessArgs (in hex).
 */
export function updateWitnessArgs(witness: string | undefined, key: WitnessArgsKey, value: BytesLike) {
  witness = witness && witness !== '0x' ? witness : defaultEmptyWitnessArgs;
  return bytes.hexify(
    blockchain.WitnessArgs.pack({
      ...blockchain.WitnessArgs.unpack(witness),
      [key]: value,
    }),
  );
}


================================================
File: packages/core/src/types/async.ts
================================================
export type PromiseOr<T> = T | Promise<T>;


================================================
File: packages/core/src/types/blockchain.ts
================================================
import { Script } from '@ckb-lumos/base';

export type ScriptId = Omit<Script, 'args'>;


================================================
File: packages/core/src/types/index.ts
================================================
export * from './blockchain';
export * from './async';


================================================
File: .changeset/README.md
================================================
# Changesets

Hello and welcome! This folder has been automatically generated by `@changesets/cli`, a build tool that works
with multi-package repos, or single-package repos to help you version and publish your code. You can
find the full documentation for it [in our repository](https://github.com/changesets/changesets)

We have a quick list of common questions to get you started engaging with this project in
[our documentation](https://github.com/changesets/changesets/blob/main/docs/common-questions.md)


================================================
File: .changeset/beige-penguins-melt.md
================================================
---
'@spore-sdk/core': patch
---

passing feeRate to payFeeByOutput method


================================================
File: .changeset/brown-carpets-learn.md
================================================
---
'@spore-sdk/core': patch
---

add feerate to createMultipleSpores


================================================
File: .changeset/config.json
================================================
{
  "$schema": "https://unpkg.com/@changesets/config@2.3.1/schema.json",
  "changelog": "@changesets/cli/changelog",
  "commit": false,
  "fixed": [["@spore-sdk/*"]],
  "linked": [],
  "access": "restricted",
  "baseBranch": "main",
  "updateInternalDependencies": "patch",
  "ignore": []
}


================================================
File: .changeset/early-snakes-tan.md
================================================
---
'@spore-sdk/core': patch
---

Fix typo of the "assertTransactionSkeletonSize" API


================================================
File: .changeset/eleven-dots-own.md
================================================
---
'@spore-sdk/core': patch
---

Support Mutant related features


================================================
File: .changeset/grumpy-schools-learn.md
================================================
---
'@spore-sdk/core': patch
---

fix a transaction fee calculation bug in `meltThenCreateSpore` method


================================================
File: .changeset/heavy-falcons-wink.md
================================================
---
'@spore-sdk/core': patch
---

adapt for mutant functionality and add new method for spore migration


================================================
File: .changeset/honest-rice-vanish.md
================================================
---
'@spore-sdk/core': patch
---

enable interface `createSpore` and `meltThenCreateSpore` to accept input cells pre-injection
add `createMultipleSpores` interface to create multiple spores in one transaction


================================================
File: .changeset/itchy-goats-beam.md
================================================
---
'@spore-sdk/core': patch
---

BREAKING CHANGE: Replaced v2 preview contracts


================================================
File: .changeset/itchy-plants-kick.md
================================================
---
'@spore-sdk/core': patch
---

Fix spore/cluster query logic, should validate target id before querying


================================================
File: .changeset/khaki-elephants-behave.md
================================================
---
'@spore-sdk/core': patch
---

fix vulnerability in getSporeById interface


================================================
File: .changeset/kind-donkeys-lick.md
================================================
---
'@spore-sdk/core': patch
---

Support ClusterProxy and ClusterAgent type cells


================================================
File: .changeset/long-lobsters-walk.md
================================================
---
'@spore-sdk/core': patch
---

solve bigint comparasion bug


================================================
File: .changeset/nine-bottles-report.md
================================================
---
'@spore-sdk/core': patch
---

Support finding SporeScripts by predefined tags


================================================
File: .changeset/old-oranges-invite.md
================================================
---
'@spore-sdk/core': patch
---

Remove "fromInfos" prop from the "meltSpore" API


================================================
File: .changeset/polite-donuts-begin.md
================================================
---
'@spore-sdk/core': patch
---

Add multipart content support


================================================
File: .changeset/poor-pumpkins-learn.md
================================================
---
'@spore-sdk/core': patch
---

fix: injectNeededCapacity rare border capacity issue (#133)


================================================
File: .changeset/pre.json
================================================
{
  "mode": "pre",
  "tag": "alpha",
  "initialVersions": {
    "@spore-sdk/core": "0.2.1"
  },
  "changesets": [
    "beige-penguins-melt",
    "brown-carpets-learn",
    "early-snakes-tan",
    "eleven-dots-own",
    "grumpy-schools-learn",
    "heavy-falcons-wink",
    "honest-rice-vanish",
    "itchy-goats-beam",
    "itchy-plants-kick",
    "khaki-elephants-behave",
    "kind-donkeys-lick",
    "long-lobsters-walk",
    "nine-bottles-report",
    "old-oranges-invite",
    "polite-donuts-begin",
    "poor-pumpkins-learn",
    "pretty-lobsters-count",
    "proud-phones-camp",
    "rare-coins-notice",
    "shaggy-snakes-collect",
    "slimy-peas-share",
    "slow-tools-flow",
    "small-lobsters-jam",
    "spotty-islands-sort",
    "stale-ghosts-lie",
    "strange-forks-brake",
    "ten-knives-join",
    "thirty-bugs-applaud",
    "three-cows-unite",
    "twenty-planets-rest"
  ]
}


================================================
File: .changeset/pretty-lobsters-count.md
================================================
---
'@spore-sdk/core': patch
---

support exact and power mode of min_payment


================================================
File: .changeset/proud-phones-camp.md
================================================
---
'@spore-sdk/core': patch
---

Fix duplicated capacity collection in the "createSpore" API


================================================
File: .changeset/rare-coins-notice.md
================================================
---
'@spore-sdk/core': patch
---

fix a bug for Cluster's `lockProxy` mode identification


================================================
File: .changeset/shaggy-snakes-collect.md
================================================
---
'@spore-sdk/core': patch
---

add `feerate` parameter to all of interfaces


================================================
File: .changeset/slimy-peas-share.md
================================================
---
'@spore-sdk/core': patch
---

Add predefined SporeConfig for Mainnet


================================================
File: .changeset/slow-tools-flow.md
================================================
---
'@spore-sdk/core': patch
---

Remove minPayment prop from the transferClusterProxy API


================================================
File: .changeset/small-lobsters-jam.md
================================================
---
'@spore-sdk/core': patch
---

Add new spore type script version to support more contract features


================================================
File: .changeset/spotty-islands-sort.md
================================================
---
'@spore-sdk/core': minor
---

export co-build interfaces and able to skip checking content-type


================================================
File: .changeset/stale-ghosts-lie.md
================================================
---
'@spore-sdk/core': patch
---

Fix and optimize the logic of capacity collection


================================================
File: .changeset/strange-forks-brake.md
================================================
---
'@spore-sdk/core': patch
---

BREAKING CHANGE: Replaced v2 contracts with a v1-compatible preview version


================================================
File: .changeset/ten-knives-join.md
================================================
---
'@spore-sdk/core': patch
---

slipt co-build generation interfaces to export pure assembly functions


================================================
File: .changeset/thirty-bugs-applaud.md
================================================
---
'@spore-sdk/core': patch
---

Support selecting v1/v2 version when creating clusters


================================================
File: .changeset/three-cows-unite.md
================================================
---
'@spore-sdk/core': patch
---

Support lock proxy in spore creation


================================================
File: .changeset/twenty-planets-rest.md
================================================
---
'@spore-sdk/core': minor
---

Support basic Cobuild feature with legacy locks


================================================
File: .github/workflows/release.yml
================================================
# Release packages to NPM and GitHub.

name: Release

on:
  workflow_dispatch:

concurrency: ${{ github.workflow }}-${{ github.ref }}

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18

      - uses: pnpm/action-setup@v3
        name: Install pnpm
        with:
          version: 8
          run_install: false

      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - uses: actions/cache@v3
        name: Setup pnpm cache
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        run: pnpm i --no-frozen-lockfile

      - name: Create Release Pull Request or Publish to npm
        id: changesets
        uses: changesets/action@v1
        with:
          publish: pnpm run release:packages
        env:
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}


================================================
File: .github/workflows/test.yaml
================================================
# Test the functionality of the spore-sdk packages.

name: Test

on:
  workflow_dispatch:
  pull_request:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}

jobs:
  devnet:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout spore-sdk
        uses: actions/checkout@v4
        with:
          path: spore-sdk

      - name: Checkout spore-devenv
        uses: actions/checkout@v4
        with:
          repository: sporeprotocol/spore-devenv
          path: spore-devenv

      - name: Install Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 20.x

      - uses: pnpm/action-setup@v3
        name: Install pnpm
        with:
          version: 8
          run_install: false

      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - uses: actions/cache@v3
        name: Setup pnpm cache
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Prepare spore-devenv (contracts and stuff)
        working-directory: spore-devenv
        run: sh prepare.sh

      - name: Start devenv services
        working-directory: spore-devenv
        run: npm run test:start

      - name: Move generated config file to spore-sdk
        working-directory: spore-devenv
        run: |
          mkdir -p ../spore-sdk/packages/core/src/__tests__/tmp
          cp config.json ../spore-sdk/packages/core/src/__tests__/tmp

      - name: Recharge capacity for accounts
        working-directory: spore-devenv
        run: npm run test:e2e
        env:
          VITE_ACCOUNT_CHARLIE: ${{ secrets.ACCOUNT_CHARLIE }}
          VITE_ACCOUNT_ALICE: ${{ secrets.ACCOUNT_ALICE }}
          VITE_ACCOUNT_BOB: ${{ secrets.ACCOUNT_BOB }}

      - name: Prepare spore-sdk
        working-directory: spore-sdk
        run: pnpm install --no-frozen-lockfile

      - name: Run tests for @spore-sdk/core
        working-directory: spore-sdk/packages/core
        run: pnpm run test
        env:
          VITE_ACCOUNT_CHARLIE: ${{ secrets.ACCOUNT_CHARLIE }}
          VITE_ACCOUNT_ALICE: ${{ secrets.ACCOUNT_ALICE }}
          VITE_ACCOUNT_BOB: ${{ secrets.ACCOUNT_BOB }}
          VITE_TEST_CLUSTER_V1: true
          VITE_NETWORK: devnet


================================================
File: .husky/pre-commit
================================================
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

npx lint-staged


