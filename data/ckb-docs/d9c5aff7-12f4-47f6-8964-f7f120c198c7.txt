Directory structure:
└── ckb-devrel-ckb-proxy-locks/
    ├── README.md
    ├── Cargo.toml
    ├── Makefile
    ├── checksums.txt
    ├── deployment.toml
    ├── contracts/
    │   ├── always-success/
    │   │   ├── README.md
    │   │   ├── Cargo.toml
    │   │   ├── Makefile
    │   │   ├── .gitignore
    │   │   └── src/
    │   │       └── main.rs
    │   ├── easy-to-discover-type/
    │   │   ├── README.md
    │   │   ├── Cargo.toml
    │   │   ├── Makefile
    │   │   ├── .gitignore
    │   │   └── src/
    │   │       ├── entry.rs
    │   │       ├── error.rs
    │   │       └── main.rs
    │   ├── input-type-proxy-lock/
    │   │   ├── README.md
    │   │   ├── Cargo.toml
    │   │   ├── Makefile
    │   │   ├── .gitignore
    │   │   └── src/
    │   │       ├── entry.rs
    │   │       ├── error.rs
    │   │       └── main.rs
    │   ├── lock-proxy-lock/
    │   │   ├── README.md
    │   │   ├── Cargo.toml
    │   │   ├── Makefile
    │   │   ├── .gitignore
    │   │   └── src/
    │   │       ├── entry.rs
    │   │       ├── error.rs
    │   │       └── main.rs
    │   ├── output-type-proxy-lock/
    │   │   ├── README.md
    │   │   ├── Cargo.toml
    │   │   ├── Makefile
    │   │   ├── .gitignore
    │   │   └── src/
    │   │       ├── entry.rs
    │   │       ├── error.rs
    │   │       └── main.rs
    │   ├── single-use-lock/
    │   │   ├── README.md
    │   │   ├── Cargo.toml
    │   │   ├── Makefile
    │   │   ├── .gitignore
    │   │   └── src/
    │   │       ├── entry.rs
    │   │       ├── error.rs
    │   │       └── main.rs
    │   ├── time-lock/
    │   │   ├── README.md
    │   │   ├── Cargo.toml
    │   │   ├── Makefile
    │   │   ├── .gitignore
    │   │   └── src/
    │   │       ├── entry.rs
    │   │       ├── error.rs
    │   │       └── main.rs
    │   └── type-burn-lock/
    │       ├── README.md
    │       ├── Cargo.toml
    │       ├── Makefile
    │       ├── .gitignore
    │       └── src/
    │           ├── entry.rs
    │           ├── error.rs
    │           └── main.rs
    ├── migrations/
    │   ├── mainnet/
    │   │   ├── 2024-07-25-111505.json
    │   │   └── 2024-10-08-042549.json
    │   └── testnet/
    │       ├── 2024-07-09-155812.json
    │       ├── 2024-07-25-112426.json
    │       └── 2024-10-08-042300.json
    ├── scripts/
    │   ├── find_clang
    │   └── reproducible_build_docker
    └── tests/
        ├── Cargo.toml
        └── src/
            ├── lib.rs
            ├── tests.rs
            └── tests/
                ├── input_type_owner.rs
                ├── lock_owner.rs
                ├── output_type_owner.rs
                ├── single_use_lock.rs
                └── time_lock.rs

================================================
File: README.md
================================================
# ckb-proxy-locks

TODO: Write this readme

*This project was bootstrapped with [ckb-script-templates].*

[ckb-script-templates]: https://github.com/cryptape/ckb-script-templates


================================================
File: Cargo.toml
================================================
[workspace]
resolver = "2"

members = [
  # Please don't remove the following line, we use it to automatically
  # detect insertion point for newly generated crates.
  # @@INSERTION_POINT@@
  "contracts/time-lock",
  "contracts/always-success",
  "contracts/lock-proxy-lock",
  "contracts/input-type-proxy-lock",
  "contracts/output-type-proxy-lock",
  "contracts/single-use-lock",
  "contracts/type-burn-lock",
  "contracts/easy-to-discover-type",
  "tests",
]

[profile.release]
overflow-checks = true
strip = true
codegen-units = 1


================================================
File: Makefile
================================================
# We cannot use $(shell pwd), which will return unix path format on Windows,
# making it hard to use.
cur_dir = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))

TOP := $(cur_dir)
# RUSTFLAGS that are likely to be tweaked by developers. For example,
# while we enable debug logs by default here, some might want to strip them
# for minimal code size / consumed cycles.
CUSTOM_RUSTFLAGS := --cfg debug_assertions
# Additional cargo args to append here. For example, one can use
# make test CARGO_ARGS="-- --nocapture" so as to inspect data emitted to
# stdout in unit tests
CARGO_ARGS :=
MODE := release
# Tweak this to change the clang version to use for building C code. By default
# we use a bash script with somes heuristics to find clang in current system.
CLANG := $(shell $(TOP)/scripts/find_clang)
# When this is set, a single contract will be built instead of all contracts
CONTRACT :=
# By default, we would clean build/{release,debug} folder first, in case old
# contracts are mixed together with new ones, if for some reason you want to
# revert this behavior, you can change this to anything other than true
CLEAN_BUILD_DIR_FIRST := true
BUILD_DIR := build/$(MODE)

# Pass setups to child make processes
export CUSTOM_RUSTFLAGS
export TOP
export CARGO_ARGS
export MODE
export CLANG
export BUILD_DIR

default: build test

build:
	@if [ "x$(CLEAN_BUILD_DIR_FIRST)" = "xtrue" ]; then \
		echo "Cleaning $(BUILD_DIR) directory..."; \
		rm -rf $(BUILD_DIR); \
	fi
	mkdir -p $(BUILD_DIR)
	@set -eu; \
	if [ "x$(CONTRACT)" = "x" ]; then \
		for contract in $(wildcard contracts/*); do \
			$(MAKE) -e -C $$contract build; \
		done; \
	else \
		$(MAKE) -e -C contracts/$(CONTRACT) build; \
	fi

# Run a single make task for a specific contract. For example:
#
# make run CONTRACT=stack-reorder TASK=adjust_stack_size STACK_SIZE=0x200000
TASK :=
run:
	$(MAKE) -e -C contracts/$(CONTRACT) $(TASK)

# test, check, clippy and fmt here are provided for completeness,
# there is nothing wrong invoking cargo directly instead of make.
test:
	cargo test $(CARGO_ARGS)

check:
	cargo check $(CARGO_ARGS)

clippy:
	cargo clippy $(CARGO_ARGS)

fmt:
	cargo fmt $(CARGO_ARGS)

# Arbitrary cargo command is supported here. For example:
#
# make cargo CARGO_CMD=expand CARGO_ARGS="--ugly"
#
# Invokes:
# cargo expand --ugly
CARGO_CMD :=
cargo:
	cargo $(CARGO_CMD) $(CARGO_ARGS)

clean:
	rm -rf build
	cargo clean

TEMPLATE_TYPE := --git
TEMPLATE_REPO := https://github.com/cryptape/ckb-script-templates
CRATE :=
TEMPLATE := contract
DESTINATION := contracts
generate:
	@set -eu; \
	if [ "x$(CRATE)" = "x" ]; then \
		cargo generate $(TEMPLATE_TYPE) $(TEMPLATE_REPO) $(TEMPLATE) \
			--destination $(DESTINATION); \
		GENERATED_DIR=$$(ls -dt $(DESTINATION)/* | head -n 1); \
		sed "s,@@INSERTION_POINT@@,@@INSERTION_POINT@@\n  \"$$GENERATED_DIR\"\,," Cargo.toml > Cargo.toml.new; \
		mv Cargo.toml.new Cargo.toml; \
	else \
		cargo generate $(TEMPLATE_TYPE) $(TEMPLATE_REPO) $(TEMPLATE) \
			--destination $(DESTINATION) \
			--name $(CRATE); \
		sed '/@@INSERTION_POINT@@/s/$$/\n  "$(DESTINATION)\/$(CRATE)",/' Cargo.toml > Cargo.toml.new; \
		mv Cargo.toml.new Cargo.toml; \
	fi

prepare:
	rustup target add riscv64imac-unknown-none-elf

# Generate checksum info for reproducible build
CHECKSUM_FILE := build/checksums-$(MODE).txt
checksum: build
	shasum -a 256 build/$(MODE)/* > $(CHECKSUM_FILE)

.PHONY: build test check clippy fmt cargo clean prepare checksum


================================================
File: checksums.txt
================================================
f4ba47fa9a540a74efcee48829dc0cf8b5b9dbba6950ea118aa5d47c42e60d30  build/release/always-success
47a5a67d77a9e923c2ee0a005f77faf0035071aa6cf46fe086f37c81efe58bcf  build/release/easy-to-discover-type
672b6d8bf809cbcf8e2ec440da4d6aae92241b7c298c3c45a33c3f179a032dba  build/release/input-type-proxy-lock
ef80394006628ff95480f3c7a4071db9921b47dc17bfed1faa32eb0cc0a4b736  build/release/lock-proxy-lock
fae3014e7b50fbde03c7642c3cd15cee0d83e4b485960a91ea3d10c0e78d32d0  build/release/output-type-proxy-lock
a34fcf4459fd1822c835119b2f23d1586d00540da154e9c21b52a0f3b3a659d5  build/release/single-use-lock
9a09b389f6be16b67b286523fbf285346f519ec53694f60623351f7ba5dbbbc5  build/release/time-lock
25e04bcac7f1013470a30af81afaf559553517ce1d7ce97f6438ca02a8f5c921  build/release/type-burn-lock


================================================
File: deployment.toml
================================================
[[cells]]
name = "always-success"
enable_type_id = false
location = { file = "build/release/always-success" }

[[cells]]
name = "input-type-proxy-lock"
enable_type_id = false
location = { file = "build/release/input-type-proxy-lock" }

[[cells]]
name = "output-type-proxy-lock"
enable_type_id = false
location = { file = "build/release/output-type-proxy-lock" }

[[cells]]
name = "lock-proxy-lock"
enable_type_id = false
location = { file = "build/release/lock-proxy-lock" }

[[cells]]
name = "single-use-lock"
enable_type_id = false
location = { file = "build/release/single-use-lock" }

[[cells]]
name = "type-burn-lock"
enable_type_id = false
location = { file = "build/release/type-burn-lock" }

[[cells]]
name = "easy-to-discover-type"
enable_type_id = false
location = { file = "build/release/easy-to-discover-type" }

[[cells]]
name = "time-lock"
enable_type_id = false
location = { file = "build/release/time-lock" }

# The lock script set to output cells
[lock]
code_hash = "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8"
args = "0xdc7a30c57e8bef48b1f3d26fb0aac10cd65edf30"
hash_type = "type"


================================================
File: contracts/always-success/README.md
================================================
# always-success

TODO: Write this readme

*This contract was bootstrapped with [ckb-script-templates].*

[ckb-script-templates]: https://github.com/cryptape/ckb-script-templates


================================================
File: contracts/always-success/Cargo.toml
================================================
[package]
name = "always-success"
version = "0.1.0"
edition = "2021"

[dependencies]
ckb-std = "0.15.1"


================================================
File: contracts/always-success/Makefile
================================================
# We cannot use $(shell pwd), which will return unix path format on Windows,
# making it hard to use.
cur_dir = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))

TOP := $(cur_dir)
# RUSTFLAGS that are likely to be tweaked by developers. For example,
# while we enable debug logs by default here, some might want to strip them
# for minimal code size / consumed cycles.
CUSTOM_RUSTFLAGS := --cfg debug_assertions
# RUSTFLAGS that are less likely to be tweaked by developers. Most likely
# one would want to keep the default values here.
FULL_RUSTFLAGS := -C target-feature=+zba,+zbb,+zbc,+zbs $(CUSTOM_RUSTFLAGS)
# Additional cargo args to append here. For example, one can use
# make test CARGO_ARGS="-- --nocapture" so as to inspect data emitted to
# stdout in unit tests
CARGO_ARGS :=
MODE := release
# Tweak this to change the clang version to use for building C code. By default
# we use a bash script with somes heuristics to find clang in current system.
CLANG := $(shell $(TOP)/scripts/find_clang)
# When this is set to some value, the generated binaries will be copied over
BUILD_DIR :=
# Generated binaries to copy. By convention, a Rust crate's directory name will
# likely match the crate name, which is also the name of the final binary.
# However if this is not the case, you can tweak this variable. As the name hints,
# more than one binary is supported here.
BINARIES := $(notdir $(shell pwd))

ifeq (release,$(MODE))
	MODE_ARGS := --release
endif

default: build test

build:
	RUSTFLAGS="$(FULL_RUSTFLAGS)" TARGET_CC="$(CLANG)" \
		cargo build --target=riscv64imac-unknown-none-elf $(MODE_ARGS) $(CARGO_ARGS)
	@set -eu; \
	if [ "x$(BUILD_DIR)" != "x" ]; then \
		for binary in $(BINARIES); do \
			echo "Copying binary $$binary to build directory"; \
			cp $(TOP)/target/riscv64imac-unknown-none-elf/$(MODE)/$$binary $(TOP)/$(BUILD_DIR); \
		done \
	fi

# test, check, clippy and fmt here are provided for completeness,
# there is nothing wrong invoking cargo directly instead of make.
test:
	cargo test $(CARGO_ARGS)

check:
	cargo check $(CARGO_ARGS)

clippy:
	cargo clippy $(CARGO_ARGS)

fmt:
	cargo fmt $(CARGO_ARGS)

# Arbitrary cargo command is supported here. For example:
#
# make cargo CARGO_CMD=expand CARGO_ARGS="--ugly"
# 
# Invokes:
# cargo expand --ugly
CARGO_CMD :=
cargo:
	cargo $(CARGO_CMD) $(CARGO_ARGS)

clean:
	cargo clean

prepare:
	rustup target add riscv64imac-unknown-none-elf

.PHONY: build test check clippy fmt cargo clean prepare


================================================
File: contracts/always-success/.gitignore
================================================
/build
/target


================================================
File: contracts/always-success/src/main.rs
================================================
#![no_std]
#![cfg_attr(not(test), no_main)]

#[cfg(test)]
extern crate alloc;

#[cfg(not(test))]
use ckb_std::default_alloc;
#[cfg(not(test))]
ckb_std::entry!(program_entry);
#[cfg(not(test))]
default_alloc!();

pub fn program_entry() -> i8 {
    0
}


================================================
File: contracts/easy-to-discover-type/README.md
================================================
# easy-to-discover-type

Reveal cells' data with their type script args

*This contract was bootstrapped with [ckb-script-templates].*

[ckb-script-templates]: https://github.com/cryptape/ckb-script-templates


================================================
File: contracts/easy-to-discover-type/Cargo.toml
================================================
[package]
name = "easy-to-discover-type"
version = "0.1.0"
edition = "2021"

[dependencies]
ckb-std = "0.15.1"


================================================
File: contracts/easy-to-discover-type/Makefile
================================================
# We cannot use $(shell pwd), which will return unix path format on Windows,
# making it hard to use.
cur_dir = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))

TOP := $(cur_dir)
# RUSTFLAGS that are likely to be tweaked by developers. For example,
# while we enable debug logs by default here, some might want to strip them
# for minimal code size / consumed cycles.
CUSTOM_RUSTFLAGS := --cfg debug_assertions
# RUSTFLAGS that are less likely to be tweaked by developers. Most likely
# one would want to keep the default values here.
FULL_RUSTFLAGS := -C target-feature=+zba,+zbb,+zbc,+zbs $(CUSTOM_RUSTFLAGS)
# Additional cargo args to append here. For example, one can use
# make test CARGO_ARGS="-- --nocapture" so as to inspect data emitted to
# stdout in unit tests
CARGO_ARGS :=
MODE := release
# Tweak this to change the clang version to use for building C code. By default
# we use a bash script with somes heuristics to find clang in current system.
CLANG := $(shell $(TOP)/scripts/find_clang)
# When this is set to some value, the generated binaries will be copied over
BUILD_DIR :=
# Generated binaries to copy. By convention, a Rust crate's directory name will
# likely match the crate name, which is also the name of the final binary.
# However if this is not the case, you can tweak this variable. As the name hints,
# more than one binary is supported here.
BINARIES := $(notdir $(shell pwd))

ifeq (release,$(MODE))
	MODE_ARGS := --release
endif

default: build test

build:
	RUSTFLAGS="$(FULL_RUSTFLAGS)" TARGET_CC="$(CLANG)" \
		cargo build --target=riscv64imac-unknown-none-elf $(MODE_ARGS) $(CARGO_ARGS)
	@set -eu; \
	if [ "x$(BUILD_DIR)" != "x" ]; then \
		for binary in $(BINARIES); do \
			echo "Copying binary $$binary to build directory"; \
			cp $(TOP)/target/riscv64imac-unknown-none-elf/$(MODE)/$$binary $(TOP)/$(BUILD_DIR); \
		done \
	fi

# test, check, clippy and fmt here are provided for completeness,
# there is nothing wrong invoking cargo directly instead of make.
test:
	cargo test $(CARGO_ARGS)

check:
	cargo check $(CARGO_ARGS)

clippy:
	cargo clippy $(CARGO_ARGS)

fmt:
	cargo fmt $(CARGO_ARGS)

# Arbitrary cargo command is supported here. For example:
#
# make cargo CARGO_CMD=expand CARGO_ARGS="--ugly"
# 
# Invokes:
# cargo expand --ugly
CARGO_CMD :=
cargo:
	cargo $(CARGO_CMD) $(CARGO_ARGS)

clean:
	cargo clean

prepare:
	rustup target add riscv64imac-unknown-none-elf

.PHONY: build test check clippy fmt cargo clean prepare


================================================
File: contracts/easy-to-discover-type/.gitignore
================================================
/build
/target


================================================
File: contracts/easy-to-discover-type/src/entry.rs
================================================
use alloc::vec::Vec;
use ckb_std::{
    ckb_constants::Source,
    ckb_types::prelude::Unpack,
    high_level::{load_cell_data_hash, load_script, QueryIter},
};

use crate::error::Error;

pub fn main() -> Result<(), Error> {
    let script = load_script()?;
    let args: Vec<u8> = script.args().unpack();
    if args.len() < 32 {
        return Err(Error::InsufficientArgsLength);
    }

    let data_hash = &args[0..32];

    if QueryIter::new(load_cell_data_hash, Source::GroupOutput).any(|hash| data_hash != hash) {
        return Err(Error::DataHashNotMatch);
    }

    Ok(())
}


================================================
File: contracts/easy-to-discover-type/src/error.rs
================================================
use ckb_std::error::SysError;

/// Error
#[repr(i8)]
#[derive(Debug)]
pub enum Error {
    IndexOutOfBound = 1,
    ItemMissing,
    LengthNotEnough,
    Encoding,
    InsufficientArgsLength,
    DataHashNotMatch,
}

impl From<SysError> for Error {
    fn from(err: SysError) -> Self {
        use SysError::*;
        match err {
            IndexOutOfBound => Self::IndexOutOfBound,
            ItemMissing => Self::ItemMissing,
            LengthNotEnough(_) => Self::LengthNotEnough,
            Encoding => Self::Encoding,
            Unknown(err_code) => panic!("unexpected sys error {}", err_code),
        }
    }
}


================================================
File: contracts/easy-to-discover-type/src/main.rs
================================================
#![no_std]
#![cfg_attr(not(test), no_main)]

mod entry;
mod error;

#[cfg(test)]
extern crate alloc;

#[cfg(not(test))]
use ckb_std::default_alloc;
#[cfg(not(test))]
ckb_std::entry!(program_entry);
#[cfg(not(test))]
default_alloc!();

pub fn program_entry() -> i8 {
    match entry::main() {
        Ok(_) => 0,
        Err(err) => err as i8,
    }
}


================================================
File: contracts/input-type-proxy-lock/README.md
================================================
# proxy-lock

TODO: Write this readme

*This contract was bootstrapped with [ckb-script-templates].*

[ckb-script-templates]: https://github.com/cryptape/ckb-script-templates


================================================
File: contracts/input-type-proxy-lock/Cargo.toml
================================================
[package]
name = "input-type-proxy-lock"
version = "0.1.0"
edition = "2021"

[dependencies]
ckb-std = "0.15.1"


================================================
File: contracts/input-type-proxy-lock/Makefile
================================================
# We cannot use $(shell pwd), which will return unix path format on Windows,
# making it hard to use.
cur_dir = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))

TOP := $(cur_dir)
# RUSTFLAGS that are likely to be tweaked by developers. For example,
# while we enable debug logs by default here, some might want to strip them
# for minimal code size / consumed cycles.
CUSTOM_RUSTFLAGS := --cfg debug_assertions
# RUSTFLAGS that are less likely to be tweaked by developers. Most likely
# one would want to keep the default values here.
FULL_RUSTFLAGS := -C target-feature=+zba,+zbb,+zbc,+zbs $(CUSTOM_RUSTFLAGS)
# Additional cargo args to append here. For example, one can use
# make test CARGO_ARGS="-- --nocapture" so as to inspect data emitted to
# stdout in unit tests
CARGO_ARGS :=
MODE := release
# Tweak this to change the clang version to use for building C code. By default
# we use a bash script with somes heuristics to find clang in current system.
CLANG := $(shell $(TOP)/scripts/find_clang)
# When this is set to some value, the generated binaries will be copied over
BUILD_DIR :=
# Generated binaries to copy. By convention, a Rust crate's directory name will
# likely match the crate name, which is also the name of the final binary.
# However if this is not the case, you can tweak this variable. As the name hints,
# more than one binary is supported here.
BINARIES := $(notdir $(shell pwd))

ifeq (release,$(MODE))
	MODE_ARGS := --release
endif

default: build test

build:
	RUSTFLAGS="$(FULL_RUSTFLAGS)" TARGET_CC="$(CLANG)" \
		cargo build --target=riscv64imac-unknown-none-elf $(MODE_ARGS) $(CARGO_ARGS)
	@set -eu; \
	if [ "x$(BUILD_DIR)" != "x" ]; then \
		for binary in $(BINARIES); do \
			echo "Copying binary $$binary to build directory"; \
			cp $(TOP)/target/riscv64imac-unknown-none-elf/$(MODE)/$$binary $(TOP)/$(BUILD_DIR); \
		done \
	fi

# test, check, clippy and fmt here are provided for completeness,
# there is nothing wrong invoking cargo directly instead of make.
test:
	cargo test $(CARGO_ARGS)

check:
	cargo check $(CARGO_ARGS)

clippy:
	cargo clippy $(CARGO_ARGS)

fmt:
	cargo fmt $(CARGO_ARGS)

# Arbitrary cargo command is supported here. For example:
#
# make cargo CARGO_CMD=expand CARGO_ARGS="--ugly"
# 
# Invokes:
# cargo expand --ugly
CARGO_CMD :=
cargo:
	cargo $(CARGO_CMD) $(CARGO_ARGS)

clean:
	cargo clean

prepare:
	rustup target add riscv64imac-unknown-none-elf

.PHONY: build test check clippy fmt cargo clean prepare


================================================
File: contracts/input-type-proxy-lock/.gitignore
================================================
/build
/target


================================================
File: contracts/input-type-proxy-lock/src/entry.rs
================================================
use alloc::vec::Vec;
use ckb_std::{
    ckb_constants::Source,
    ckb_types::prelude::Unpack,
    high_level::{load_cell_type_hash, load_script, QueryIter},
};

use crate::error::Error;

pub fn check_owner_input_type(owner_input_type_hash: &[u8]) -> bool {
    let is_owner_mode = QueryIter::new(load_cell_type_hash, Source::Input).any(|cell_type_hash| {
        if let Some(cell_type_hash) = cell_type_hash {
            owner_input_type_hash[..] == cell_type_hash[..]
        } else {
            false
        }
    });
    is_owner_mode
}

pub fn main() -> Result<(), Error> {
    let script = load_script()?;
    let args: Vec<u8> = script.args().unpack();
    if args.len() < 32 {
        return Err(Error::Encoding);
    }

    let owner_script_hash = &args[0..32];
    if check_owner_input_type(owner_script_hash) {
        return Ok(());
    }

    return Err(Error::InvalidUnlock);
}


================================================
File: contracts/input-type-proxy-lock/src/error.rs
================================================
use ckb_std::error::SysError;

/// Error
#[repr(i8)]
#[derive(Debug)]
pub enum Error {
    IndexOutOfBound = 1,
    ItemMissing,
    LengthNotEnough,
    Encoding,
    Overflow,

    InvalidUnlock,
}

impl From<SysError> for Error {
    fn from(err: SysError) -> Self {
        use SysError::*;
        match err {
            IndexOutOfBound => Self::IndexOutOfBound,
            ItemMissing => Self::ItemMissing,
            LengthNotEnough(_) => Self::LengthNotEnough,
            Encoding => Self::Encoding,
            Unknown(err_code) => panic!("unexpected sys error {}", err_code),
        }
    }
}

================================================
File: contracts/input-type-proxy-lock/src/main.rs
================================================
#![no_std]
#![cfg_attr(not(test), no_main)]

mod entry;
mod error;

#[cfg(test)]
extern crate alloc;

#[cfg(not(test))]
use ckb_std::default_alloc;
#[cfg(not(test))]
ckb_std::entry!(program_entry);
#[cfg(not(test))]
default_alloc!();

pub fn program_entry() -> i8 {
    match entry::main() {
        Ok(_) => 0,
        Err(err) => err as i8,
    }
}


================================================
File: contracts/lock-proxy-lock/README.md
================================================
# proxy-lock

TODO: Write this readme

*This contract was bootstrapped with [ckb-script-templates].*

[ckb-script-templates]: https://github.com/cryptape/ckb-script-templates


================================================
File: contracts/lock-proxy-lock/Cargo.toml
================================================
[package]
name = "lock-proxy-lock"
version = "0.1.0"
edition = "2021"

[dependencies]
ckb-std = "0.15.1"


================================================
File: contracts/lock-proxy-lock/Makefile
================================================
# We cannot use $(shell pwd), which will return unix path format on Windows,
# making it hard to use.
cur_dir = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))

TOP := $(cur_dir)
# RUSTFLAGS that are likely to be tweaked by developers. For example,
# while we enable debug logs by default here, some might want to strip them
# for minimal code size / consumed cycles.
CUSTOM_RUSTFLAGS := --cfg debug_assertions
# RUSTFLAGS that are less likely to be tweaked by developers. Most likely
# one would want to keep the default values here.
FULL_RUSTFLAGS := -C target-feature=+zba,+zbb,+zbc,+zbs $(CUSTOM_RUSTFLAGS)
# Additional cargo args to append here. For example, one can use
# make test CARGO_ARGS="-- --nocapture" so as to inspect data emitted to
# stdout in unit tests
CARGO_ARGS :=
MODE := release
# Tweak this to change the clang version to use for building C code. By default
# we use a bash script with somes heuristics to find clang in current system.
CLANG := $(shell $(TOP)/scripts/find_clang)
# When this is set to some value, the generated binaries will be copied over
BUILD_DIR :=
# Generated binaries to copy. By convention, a Rust crate's directory name will
# likely match the crate name, which is also the name of the final binary.
# However if this is not the case, you can tweak this variable. As the name hints,
# more than one binary is supported here.
BINARIES := $(notdir $(shell pwd))

ifeq (release,$(MODE))
	MODE_ARGS := --release
endif

default: build test

build:
	RUSTFLAGS="$(FULL_RUSTFLAGS)" TARGET_CC="$(CLANG)" \
		cargo build --target=riscv64imac-unknown-none-elf $(MODE_ARGS) $(CARGO_ARGS)
	@set -eu; \
	if [ "x$(BUILD_DIR)" != "x" ]; then \
		for binary in $(BINARIES); do \
			echo "Copying binary $$binary to build directory"; \
			cp $(TOP)/target/riscv64imac-unknown-none-elf/$(MODE)/$$binary $(TOP)/$(BUILD_DIR); \
		done \
	fi

# test, check, clippy and fmt here are provided for completeness,
# there is nothing wrong invoking cargo directly instead of make.
test:
	cargo test $(CARGO_ARGS)

check:
	cargo check $(CARGO_ARGS)

clippy:
	cargo clippy $(CARGO_ARGS)

fmt:
	cargo fmt $(CARGO_ARGS)

# Arbitrary cargo command is supported here. For example:
#
# make cargo CARGO_CMD=expand CARGO_ARGS="--ugly"
# 
# Invokes:
# cargo expand --ugly
CARGO_CMD :=
cargo:
	cargo $(CARGO_CMD) $(CARGO_ARGS)

clean:
	cargo clean

prepare:
	rustup target add riscv64imac-unknown-none-elf

.PHONY: build test check clippy fmt cargo clean prepare


================================================
File: contracts/lock-proxy-lock/.gitignore
================================================
/build
/target


================================================
File: contracts/lock-proxy-lock/src/entry.rs
================================================
use alloc::vec::Vec;
use ckb_std::{
    ckb_constants::Source,
    ckb_types::prelude::Unpack,
    high_level::{load_cell_lock_hash, load_script, QueryIter},
};

use crate::error::Error;

pub fn check_owner_lock(owner_lock_hash: &[u8]) -> bool {
    let is_owner_mode = QueryIter::new(load_cell_lock_hash, Source::Input)
        .any(|cell_lock_hash| owner_lock_hash[..] == cell_lock_hash[..]);
    is_owner_mode
}

pub fn main() -> Result<(), Error> {
    let script = load_script()?;
    let args: Vec<u8> = script.args().unpack();
    if args.len() < 32 {
        return Err(Error::Encoding);
    }

    let owner_script_hash = &args[0..32];
    if check_owner_lock(owner_script_hash) {
        return Ok(());
    }

    return Err(Error::InvalidUnlock);
}


================================================
File: contracts/lock-proxy-lock/src/error.rs
================================================
use ckb_std::error::SysError;

/// Error
#[repr(i8)]
#[derive(Debug)]
pub enum Error {
    IndexOutOfBound = 1,
    ItemMissing,
    LengthNotEnough,
    Encoding,
    Overflow,

    InvalidUnlock,
}

impl From<SysError> for Error {
    fn from(err: SysError) -> Self {
        use SysError::*;
        match err {
            IndexOutOfBound => Self::IndexOutOfBound,
            ItemMissing => Self::ItemMissing,
            LengthNotEnough(_) => Self::LengthNotEnough,
            Encoding => Self::Encoding,
            Unknown(err_code) => panic!("unexpected sys error {}", err_code),
        }
    }
}

================================================
File: contracts/lock-proxy-lock/src/main.rs
================================================
#![no_std]
#![cfg_attr(not(test), no_main)]

mod entry;
mod error;

#[cfg(test)]
extern crate alloc;

#[cfg(not(test))]
use ckb_std::default_alloc;
#[cfg(not(test))]
ckb_std::entry!(program_entry);
#[cfg(not(test))]
default_alloc!();

pub fn program_entry() -> i8 {
    match entry::main() {
        Ok(_) => 0,
        Err(err) => err as i8,
    }
}


================================================
File: contracts/output-type-proxy-lock/README.md
================================================
# proxy-lock

TODO: Write this readme

*This contract was bootstrapped with [ckb-script-templates].*

[ckb-script-templates]: https://github.com/cryptape/ckb-script-templates


================================================
File: contracts/output-type-proxy-lock/Cargo.toml
================================================
[package]
name = "output-type-proxy-lock"
version = "0.1.0"
edition = "2021"

[dependencies]
ckb-std = "0.15.1"


================================================
File: contracts/output-type-proxy-lock/Makefile
================================================
# We cannot use $(shell pwd), which will return unix path format on Windows,
# making it hard to use.
cur_dir = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))

TOP := $(cur_dir)
# RUSTFLAGS that are likely to be tweaked by developers. For example,
# while we enable debug logs by default here, some might want to strip them
# for minimal code size / consumed cycles.
CUSTOM_RUSTFLAGS := --cfg debug_assertions
# RUSTFLAGS that are less likely to be tweaked by developers. Most likely
# one would want to keep the default values here.
FULL_RUSTFLAGS := -C target-feature=+zba,+zbb,+zbc,+zbs $(CUSTOM_RUSTFLAGS)
# Additional cargo args to append here. For example, one can use
# make test CARGO_ARGS="-- --nocapture" so as to inspect data emitted to
# stdout in unit tests
CARGO_ARGS :=
MODE := release
# Tweak this to change the clang version to use for building C code. By default
# we use a bash script with somes heuristics to find clang in current system.
CLANG := $(shell $(TOP)/scripts/find_clang)
# When this is set to some value, the generated binaries will be copied over
BUILD_DIR :=
# Generated binaries to copy. By convention, a Rust crate's directory name will
# likely match the crate name, which is also the name of the final binary.
# However if this is not the case, you can tweak this variable. As the name hints,
# more than one binary is supported here.
BINARIES := $(notdir $(shell pwd))

ifeq (release,$(MODE))
	MODE_ARGS := --release
endif

default: build test

build:
	RUSTFLAGS="$(FULL_RUSTFLAGS)" TARGET_CC="$(CLANG)" \
		cargo build --target=riscv64imac-unknown-none-elf $(MODE_ARGS) $(CARGO_ARGS)
	@set -eu; \
	if [ "x$(BUILD_DIR)" != "x" ]; then \
		for binary in $(BINARIES); do \
			echo "Copying binary $$binary to build directory"; \
			cp $(TOP)/target/riscv64imac-unknown-none-elf/$(MODE)/$$binary $(TOP)/$(BUILD_DIR); \
		done \
	fi

# test, check, clippy and fmt here are provided for completeness,
# there is nothing wrong invoking cargo directly instead of make.
test:
	cargo test $(CARGO_ARGS)

check:
	cargo check $(CARGO_ARGS)

clippy:
	cargo clippy $(CARGO_ARGS)

fmt:
	cargo fmt $(CARGO_ARGS)

# Arbitrary cargo command is supported here. For example:
#
# make cargo CARGO_CMD=expand CARGO_ARGS="--ugly"
# 
# Invokes:
# cargo expand --ugly
CARGO_CMD :=
cargo:
	cargo $(CARGO_CMD) $(CARGO_ARGS)

clean:
	cargo clean

prepare:
	rustup target add riscv64imac-unknown-none-elf

.PHONY: build test check clippy fmt cargo clean prepare


================================================
File: contracts/output-type-proxy-lock/.gitignore
================================================
/build
/target


================================================
File: contracts/output-type-proxy-lock/src/entry.rs
================================================
use alloc::vec::Vec;
use ckb_std::{
    ckb_constants::Source,
    ckb_types::prelude::Unpack,
    high_level::{load_cell_type_hash, load_script, QueryIter},
};

use crate::error::Error;

pub fn check_owner_output_type(owner_input_type_hash: &[u8]) -> bool {
    let is_owner_mode = QueryIter::new(load_cell_type_hash, Source::Output).any(|cell_type_hash| {
        if let Some(cell_type_hash) = cell_type_hash {
            owner_input_type_hash[..] == cell_type_hash[..]
        } else {
            false
        }
    });
    is_owner_mode
}

pub fn main() -> Result<(), Error> {
    let script = load_script()?;
    let args: Vec<u8> = script.args().unpack();
    if args.len() < 32 {
        return Err(Error::Encoding);
    }

    let owner_script_hash = &args[0..32];
    if check_owner_output_type(owner_script_hash) {
        return Ok(());
    }

    return Err(Error::InvalidUnlock);
}


================================================
File: contracts/output-type-proxy-lock/src/error.rs
================================================
use ckb_std::error::SysError;

/// Error
#[repr(i8)]
#[derive(Debug)]
pub enum Error {
    IndexOutOfBound = 1,
    ItemMissing,
    LengthNotEnough,
    Encoding,
    Overflow,

    InvalidUnlock,
}

impl From<SysError> for Error {
    fn from(err: SysError) -> Self {
        use SysError::*;
        match err {
            IndexOutOfBound => Self::IndexOutOfBound,
            ItemMissing => Self::ItemMissing,
            LengthNotEnough(_) => Self::LengthNotEnough,
            Encoding => Self::Encoding,
            Unknown(err_code) => panic!("unexpected sys error {}", err_code),
        }
    }
}

================================================
File: contracts/output-type-proxy-lock/src/main.rs
================================================
#![no_std]
#![cfg_attr(not(test), no_main)]

mod entry;
mod error;

#[cfg(test)]
extern crate alloc;

#[cfg(not(test))]
use ckb_std::default_alloc;
#[cfg(not(test))]
ckb_std::entry!(program_entry);
#[cfg(not(test))]
default_alloc!();

pub fn program_entry() -> i8 {
    match entry::main() {
        Ok(_) => 0,
        Err(err) => err as i8,
    }
}


================================================
File: contracts/single-use-lock/README.md
================================================
# single-use-lock

TODO: Write this readme

*This contract was bootstrapped with [ckb-script-templates].*

[ckb-script-templates]: https://github.com/cryptape/ckb-script-templates


================================================
File: contracts/single-use-lock/Cargo.toml
================================================
[package]
name = "single-use-lock"
version = "0.1.0"
edition = "2021"

[dependencies]
ckb-std = "0.15.1"
molecule = { version = "0.7.5", default-features = false }


================================================
File: contracts/single-use-lock/Makefile
================================================
# We cannot use $(shell pwd), which will return unix path format on Windows,
# making it hard to use.
cur_dir = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))

TOP := $(cur_dir)
# RUSTFLAGS that are likely to be tweaked by developers. For example,
# while we enable debug logs by default here, some might want to strip them
# for minimal code size / consumed cycles.
CUSTOM_RUSTFLAGS := --cfg debug_assertions
# RUSTFLAGS that are less likely to be tweaked by developers. Most likely
# one would want to keep the default values here.
FULL_RUSTFLAGS := -C target-feature=+zba,+zbb,+zbc,+zbs $(CUSTOM_RUSTFLAGS)
# Additional cargo args to append here. For example, one can use
# make test CARGO_ARGS="-- --nocapture" so as to inspect data emitted to
# stdout in unit tests
CARGO_ARGS :=
MODE := release
# Tweak this to change the clang version to use for building C code. By default
# we use a bash script with somes heuristics to find clang in current system.
CLANG := $(shell $(TOP)/scripts/find_clang)
# When this is set to some value, the generated binaries will be copied over
BUILD_DIR :=
# Generated binaries to copy. By convention, a Rust crate's directory name will
# likely match the crate name, which is also the name of the final binary.
# However if this is not the case, you can tweak this variable. As the name hints,
# more than one binary is supported here.
BINARIES := $(notdir $(shell pwd))

ifeq (release,$(MODE))
	MODE_ARGS := --release
endif

default: build test

build:
	RUSTFLAGS="$(FULL_RUSTFLAGS)" TARGET_CC="$(CLANG)" \
		cargo build --target=riscv64imac-unknown-none-elf $(MODE_ARGS) $(CARGO_ARGS)
	@set -eu; \
	if [ "x$(BUILD_DIR)" != "x" ]; then \
		for binary in $(BINARIES); do \
			echo "Copying binary $$binary to build directory"; \
			cp $(TOP)/target/riscv64imac-unknown-none-elf/$(MODE)/$$binary $(TOP)/$(BUILD_DIR); \
		done \
	fi

# test, check, clippy and fmt here are provided for completeness,
# there is nothing wrong invoking cargo directly instead of make.
test:
	cargo test $(CARGO_ARGS)

check:
	cargo check $(CARGO_ARGS)

clippy:
	cargo clippy $(CARGO_ARGS)

fmt:
	cargo fmt $(CARGO_ARGS)

# Arbitrary cargo command is supported here. For example:
#
# make cargo CARGO_CMD=expand CARGO_ARGS="--ugly"
# 
# Invokes:
# cargo expand --ugly
CARGO_CMD :=
cargo:
	cargo $(CARGO_CMD) $(CARGO_ARGS)

clean:
	cargo clean

prepare:
	rustup target add riscv64imac-unknown-none-elf

.PHONY: build test check clippy fmt cargo clean prepare


================================================
File: contracts/single-use-lock/.gitignore
================================================
/build
/target


================================================
File: contracts/single-use-lock/src/entry.rs
================================================
use alloc::vec::Vec;
use ckb_std::{
    ckb_constants::Source,
    ckb_types::{
        packed::OutPoint,
        prelude::{Entity, Unpack},
    },
    high_level::{load_input, load_script, QueryIter},
};

use crate::error::Error;

pub fn check_outpoint(outpoint: OutPoint) -> bool {
    let is_owner_mode = QueryIter::new(load_input, Source::Input).any(|cell_input| {
        if cell_input.previous_output() == outpoint {
            return true;
        }

        false
    });

    is_owner_mode
}

pub fn main() -> Result<(), Error> {
    let script = load_script()?;
    let args: Vec<u8> = script.args().unpack();
    if args.len() < OutPoint::TOTAL_SIZE {
        return Err(Error::Encoding);
    }

    let owner_outpoint = OutPoint::from_slice(&args[0..OutPoint::TOTAL_SIZE])?;
    if !check_outpoint(owner_outpoint) {
        return Err(Error::OutpointNotFound);
    }

    Ok(())
}


================================================
File: contracts/single-use-lock/src/error.rs
================================================
use ckb_std::error::SysError;

/// Error
#[repr(i8)]
#[derive(Debug)]
pub enum Error {
    IndexOutOfBound = 1,
    ItemMissing,
    LengthNotEnough,
    Encoding,
    Overflow,
    MoleculeVerification,
    OutpointNotFound,
}

impl From<SysError> for Error {
    fn from(err: SysError) -> Self {
        use SysError::*;
        match err {
            IndexOutOfBound => Self::IndexOutOfBound,
            ItemMissing => Self::ItemMissing,
            LengthNotEnough(_) => Self::LengthNotEnough,
            Encoding => Self::Encoding,
            Unknown(err_code) => panic!("unexpected sys error {}", err_code),
        }
    }
}

impl From<molecule::error::VerificationError> for Error {
    fn from(_err: molecule::error::VerificationError) -> Self {
        Self::MoleculeVerification
    }
}

================================================
File: contracts/single-use-lock/src/main.rs
================================================
#![no_std]
#![cfg_attr(not(test), no_main)]

mod entry;
mod error;

#[cfg(test)]
extern crate alloc;

#[cfg(not(test))]
use ckb_std::default_alloc;
#[cfg(not(test))]
ckb_std::entry!(program_entry);
#[cfg(not(test))]
default_alloc!();

pub fn program_entry() -> i8 {
    match entry::main() {
        Ok(_) => 0,
        Err(err) => err as i8,
    }
}


================================================
File: contracts/time-lock/README.md
================================================
# Time-Locked Script

## Overview

This script implements a time-lock Script on the Nervos CKB blockchain, ensuring that cells locked by this Script can only be unlocked after a specified time has passed and certain lock script hash is validated.

## Features

- **Time-Locking**: Assets are restricted from movement until a specified timestamp has passed.
- **Lock Script Verification**: Ensures transaction processing involves a specific lock script hash.

## Usage

**Steps to lock**:
1. Include the Script as a lock script in the outputs of a transaction.
2. Pass the hash of the lock script that must be present in the inputs of the transaction as the first 32 bytes of the script arguments.
3. Pass the timestamp until which the assets should remain locked as the remaining 8 bytes of the script arguments.
4. Send the transaction to the blockchain.

**Steps to unlock**:
1. Include a cell output locked by the Script as one of the cell inputs in a transaction.
2. Include a cell output that is locked by the lock script, whose hash is specified in the time-lock Script's arguments, as another cell input in the transaction.
3. Set the [`since` field](https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0017-tx-valid-since/0017-tx-valid-since.md) of each of the cell input.
4. Send the transaction to the blockchain.


================================================
File: contracts/time-lock/Cargo.toml
================================================
[package]
name = "time-lock"
version = "0.1.0"
edition = "2021"

[dependencies]
ckb-std = "0.15.1"


================================================
File: contracts/time-lock/Makefile
================================================
# We cannot use $(shell pwd), which will return unix path format on Windows,
# making it hard to use.
cur_dir = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))

TOP := $(cur_dir)
# RUSTFLAGS that are likely to be tweaked by developers. For example,
# while we enable debug logs by default here, some might want to strip them
# for minimal code size / consumed cycles.
CUSTOM_RUSTFLAGS := --cfg debug_assertions
# RUSTFLAGS that are less likely to be tweaked by developers. Most likely
# one would want to keep the default values here.
FULL_RUSTFLAGS := -C target-feature=+zba,+zbb,+zbc,+zbs $(CUSTOM_RUSTFLAGS)
# Additional cargo args to append here. For example, one can use
# make test CARGO_ARGS="-- --nocapture" so as to inspect data emitted to
# stdout in unit tests
CARGO_ARGS :=
MODE := release
# Tweak this to change the clang version to use for building C code. By default
# we use a bash script with somes heuristics to find clang in current system.
CLANG := $(shell $(TOP)/scripts/find_clang)
AR := $(subst clang,llvm-ar,$(CLANG))
# When this is set to some value, the generated binaries will be copied over
BUILD_DIR :=
# Generated binaries to copy. By convention, a Rust crate's directory name will
# likely match the crate name, which is also the name of the final binary.
# However if this is not the case, you can tweak this variable. As the name hints,
# more than one binary is supported here.
BINARIES := $(notdir $(shell pwd))

ifeq (release,$(MODE))
	MODE_ARGS := --release
endif

default: build test

build:
	RUSTFLAGS="$(FULL_RUSTFLAGS)" TARGET_CC="$(CLANG)" TARGET_AR="$(AR)" \
		cargo build --target=riscv64imac-unknown-none-elf $(MODE_ARGS) $(CARGO_ARGS)
	@set -eu; \
	if [ "x$(BUILD_DIR)" != "x" ]; then \
		for binary in $(BINARIES); do \
			echo "Copying binary $$binary to build directory"; \
			cp $(TOP)/target/riscv64imac-unknown-none-elf/$(MODE)/$$binary $(TOP)/$(BUILD_DIR); \
		done \
	fi

# test, check, clippy and fmt here are provided for completeness,
# there is nothing wrong invoking cargo directly instead of make.
test:
	cargo test $(CARGO_ARGS)

check:
	cargo check $(CARGO_ARGS)

clippy:
	cargo clippy $(CARGO_ARGS)

fmt:
	cargo fmt $(CARGO_ARGS)

# Arbitrary cargo command is supported here. For example:
#
# make cargo CARGO_CMD=expand CARGO_ARGS="--ugly"
# 
# Invokes:
# cargo expand --ugly
CARGO_CMD :=
cargo:
	cargo $(CARGO_CMD) $(CARGO_ARGS)

clean:
	cargo clean

prepare:
	rustup target add riscv64imac-unknown-none-elf

.PHONY: build test check clippy fmt cargo clean prepare


================================================
File: contracts/time-lock/.gitignore
================================================
/build
/target


================================================
File: contracts/time-lock/src/entry.rs
================================================
use alloc::vec::Vec;
use ckb_std::{
    ckb_constants::Source,
    ckb_types::prelude::Unpack,
    // debug,
    high_level::{load_cell_lock_hash, load_input_since, load_script, QueryIter},
    since::Since,
};

use crate::error::Error;

pub fn main() -> Result<(), Error> {
    let script = load_script()?;
    let args: Vec<u8> = script.args().unpack();

    if args.len() < 40 {
        return Err(Error::InvalidArguments);
    }

    let required_lock_script_hash = &args[..32];

    if !required_lock_script_exists(required_lock_script_hash) {
        return Err(Error::RequiredLockScriptNotFound);
    }

    let locked_until = &args[32..40];
    // convert locked_until to Since
    if !has_lock_time_passed(locked_until) {
        return Err(Error::LockTimeNotPassed);
    }

    Ok(())
}

pub fn has_lock_time_passed(locked_until: &[u8]) -> bool {
    let locked_until = Since::new(u64::from_le_bytes(locked_until.try_into().unwrap()));
    // all cell inputs must have a since value greater than locked_until
    for since in QueryIter::new(load_input_since, Source::GroupInput) {
        let since = Since::new(since);
        if since.lt(&locked_until) {
            return false;
        }
    }
    true
}

pub fn required_lock_script_exists(required_lock_script_hash: &[u8]) -> bool {
    QueryIter::new(load_cell_lock_hash, Source::Input)
        .any(|cell_lock_hash| required_lock_script_hash[..] == cell_lock_hash[..])
}


================================================
File: contracts/time-lock/src/error.rs
================================================
use ckb_std::error::SysError;

/// Error
#[repr(i8)]
#[derive(Debug)]
pub enum Error {
    IndexOutOfBound = 1,
    ItemMissing,
    LengthNotEnough,
    Encoding,
    InvalidArguments,
    LockTimeNotPassed,
    RequiredLockScriptNotFound,
}

impl From<SysError> for Error {
    fn from(err: SysError) -> Self {
        use SysError::*;
        match err {
            IndexOutOfBound => Self::IndexOutOfBound,
            ItemMissing => Self::ItemMissing,
            LengthNotEnough(_) => Self::LengthNotEnough,
            Encoding => Self::Encoding,
            Unknown(err_code) => panic!("unexpected sys error {}", err_code),
        }
    }
}


================================================
File: contracts/time-lock/src/main.rs
================================================
#![no_std]
#![cfg_attr(not(test), no_main)]

mod entry;
mod error;

#[cfg(test)]
extern crate alloc;

#[cfg(not(test))]
use ckb_std::default_alloc;
#[cfg(not(test))]
ckb_std::entry!(program_entry);
#[cfg(not(test))]
default_alloc!();

pub fn program_entry() -> i8 {
    match entry::main() {
        Ok(_) => 0,
        Err(err) => err as i8,
    }
}


================================================
File: contracts/type-burn-lock/README.md
================================================
# type-burn-lock

keep cell unlockable until specified type script appeared inside `inputs` field of ckb transaction

*This contract was bootstrapped with [ckb-script-templates].*

[ckb-script-templates]: https://github.com/cryptape/ckb-script-templates


================================================
File: contracts/type-burn-lock/Cargo.toml
================================================
[package]
name = "type-burn-lock"
version = "0.1.0"
edition = "2021"

[dependencies]
ckb-std = "0.15.1"


================================================
File: contracts/type-burn-lock/Makefile
================================================
# We cannot use $(shell pwd), which will return unix path format on Windows,
# making it hard to use.
cur_dir = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))

TOP := $(cur_dir)
# RUSTFLAGS that are likely to be tweaked by developers. For example,
# while we enable debug logs by default here, some might want to strip them
# for minimal code size / consumed cycles.
CUSTOM_RUSTFLAGS := --cfg debug_assertions
# RUSTFLAGS that are less likely to be tweaked by developers. Most likely
# one would want to keep the default values here.
FULL_RUSTFLAGS := -C target-feature=+zba,+zbb,+zbc,+zbs $(CUSTOM_RUSTFLAGS)
# Additional cargo args to append here. For example, one can use
# make test CARGO_ARGS="-- --nocapture" so as to inspect data emitted to
# stdout in unit tests
CARGO_ARGS :=
MODE := release
# Tweak this to change the clang version to use for building C code. By default
# we use a bash script with somes heuristics to find clang in current system.
CLANG := $(shell $(TOP)/scripts/find_clang)
# When this is set to some value, the generated binaries will be copied over
BUILD_DIR :=
# Generated binaries to copy. By convention, a Rust crate's directory name will
# likely match the crate name, which is also the name of the final binary.
# However if this is not the case, you can tweak this variable. As the name hints,
# more than one binary is supported here.
BINARIES := $(notdir $(shell pwd))

ifeq (release,$(MODE))
	MODE_ARGS := --release
endif

default: build test

build:
	RUSTFLAGS="$(FULL_RUSTFLAGS)" TARGET_CC="$(CLANG)" \
		cargo build --target=riscv64imac-unknown-none-elf $(MODE_ARGS) $(CARGO_ARGS)
	@set -eu; \
	if [ "x$(BUILD_DIR)" != "x" ]; then \
		for binary in $(BINARIES); do \
			echo "Copying binary $$binary to build directory"; \
			cp $(TOP)/target/riscv64imac-unknown-none-elf/$(MODE)/$$binary $(TOP)/$(BUILD_DIR); \
		done \
	fi

# test, check, clippy and fmt here are provided for completeness,
# there is nothing wrong invoking cargo directly instead of make.
test:
	cargo test $(CARGO_ARGS)

check:
	cargo check $(CARGO_ARGS)

clippy:
	cargo clippy $(CARGO_ARGS)

fmt:
	cargo fmt $(CARGO_ARGS)

# Arbitrary cargo command is supported here. For example:
#
# make cargo CARGO_CMD=expand CARGO_ARGS="--ugly"
# 
# Invokes:
# cargo expand --ugly
CARGO_CMD :=
cargo:
	cargo $(CARGO_CMD) $(CARGO_ARGS)

clean:
	cargo clean

prepare:
	rustup target add riscv64imac-unknown-none-elf

.PHONY: build test check clippy fmt cargo clean prepare


================================================
File: contracts/type-burn-lock/.gitignore
================================================
/build
/target


================================================
File: contracts/type-burn-lock/src/entry.rs
================================================
use alloc::vec::Vec;
use ckb_std::{
    ckb_constants::Source,
    ckb_types::prelude::Unpack,
    high_level::{load_cell_type_hash, load_script, QueryIter},
};

use crate::error::Error;

pub fn main() -> Result<(), Error> {
    let script = load_script()?;
    let args: Vec<u8> = script.args().unpack();
    if args.len() < 32 {
        return Err(Error::Encoding);
    }

    let expected_type_hash = &args[..32];
    let find_input = QueryIter::new(load_cell_type_hash, Source::Input).any(|type_hash| {
        if let Some(hash) = type_hash {
            hash == expected_type_hash
        } else {
            false
        }
    });
    let find_output = QueryIter::new(load_cell_type_hash, Source::Output).any(|type_hash| {
        if let Some(hash) = type_hash {
            hash == expected_type_hash
        } else {
            false
        }
    });

    if !find_input || find_output {
        return Err(Error::TypeScriptNotBurnt);
    }

    Ok(())
}


================================================
File: contracts/type-burn-lock/src/error.rs
================================================
use ckb_std::error::SysError;

/// Error
#[repr(i8)]
#[derive(Debug)]
pub enum Error {
    IndexOutOfBound = 1,
    ItemMissing,
    LengthNotEnough,
    Encoding,
    Overflow,
    TypeScriptNotBurnt,
}

impl From<SysError> for Error {
    fn from(err: SysError) -> Self {
        use SysError::*;
        match err {
            IndexOutOfBound => Self::IndexOutOfBound,
            ItemMissing => Self::ItemMissing,
            LengthNotEnough(_) => Self::LengthNotEnough,
            Encoding => Self::Encoding,
            Unknown(err_code) => panic!("unexpected sys error {}", err_code),
        }
    }
}


================================================
File: contracts/type-burn-lock/src/main.rs
================================================
#![no_std]
#![cfg_attr(not(test), no_main)]

mod entry;
mod error;

#[cfg(test)]
extern crate alloc;

#[cfg(not(test))]
use ckb_std::default_alloc;
#[cfg(not(test))]
ckb_std::entry!(program_entry);
#[cfg(not(test))]
default_alloc!();

pub fn program_entry() -> i8 {
    match entry::main() {
        Ok(_) => 0,
        Err(err) => err as i8,
    }
}


================================================
File: migrations/mainnet/2024-07-25-111505.json
================================================
{
  "cell_recipes": [
    {
      "name": "always-success",
      "tx_hash": "0x10d63a996157d32c01078058000052674ca58d15f921bec7f1dcdac2160eb66b",
      "index": 0,
      "occupied_capacity": 127700000000,
      "data_hash": "0x3b521cc4b552f109d092d8cc468a8048acb53c5952dbe769d2b2f9cf6e47f7f1",
      "type_id": null
    },
    {
      "name": "input-type-proxy-lock",
      "tx_hash": "0x10d63a996157d32c01078058000052674ca58d15f921bec7f1dcdac2160eb66b",
      "index": 1,
      "occupied_capacity": 2742100000000,
      "data_hash": "0x5123908965c711b0ffd8aec642f1ede329649bda1ebdca6bd24124d3796f768a",
      "type_id": null
    },
    {
      "name": "output-type-proxy-lock",
      "tx_hash": "0x10d63a996157d32c01078058000052674ca58d15f921bec7f1dcdac2160eb66b",
      "index": 2,
      "occupied_capacity": 2742100000000,
      "data_hash": "0x2df53b592db3ae3685b7787adcfef0332a611edb83ca3feca435809964c3aff2",
      "type_id": null
    },
    {
      "name": "lock-proxy-lock",
      "tx_hash": "0x10d63a996157d32c01078058000052674ca58d15f921bec7f1dcdac2160eb66b",
      "index": 3,
      "occupied_capacity": 2750900000000,
      "data_hash": "0x5d41e32e224c15f152b7e6529100ebeac83b162f5f692a5365774dad2c1a1d02",
      "type_id": null
    },
    {
      "name": "single-use-lock",
      "tx_hash": "0x10d63a996157d32c01078058000052674ca58d15f921bec7f1dcdac2160eb66b",
      "index": 4,
      "occupied_capacity": 2783700000000,
      "data_hash": "0x8290467a512e5b9a6b816469b0edabba1f4ac474e28ffdd604c2a7c76446bbaf",
      "type_id": null
    },
    {
      "name": "type-burn-lock",
      "tx_hash": "0x10d63a996157d32c01078058000052674ca58d15f921bec7f1dcdac2160eb66b",
      "index": 5,
      "occupied_capacity": 2785300000000,
      "data_hash": "0xff78bae0abf17d7a404c0be0f9ad9c9185b3f88dcc60403453d5ba8e1f22f53a",
      "type_id": null
    }
  ],
  "dep_group_recipes": []
}

================================================
File: migrations/mainnet/2024-10-08-042549.json
================================================
{
  "cell_recipes": [
    {
      "name": "always-success",
      "tx_hash": "0x10d63a996157d32c01078058000052674ca58d15f921bec7f1dcdac2160eb66b",
      "index": 0,
      "occupied_capacity": 127700000000,
      "data_hash": "0x3b521cc4b552f109d092d8cc468a8048acb53c5952dbe769d2b2f9cf6e47f7f1",
      "type_id": null
    },
    {
      "name": "input-type-proxy-lock",
      "tx_hash": "0x10d63a996157d32c01078058000052674ca58d15f921bec7f1dcdac2160eb66b",
      "index": 1,
      "occupied_capacity": 2742100000000,
      "data_hash": "0x5123908965c711b0ffd8aec642f1ede329649bda1ebdca6bd24124d3796f768a",
      "type_id": null
    },
    {
      "name": "output-type-proxy-lock",
      "tx_hash": "0x10d63a996157d32c01078058000052674ca58d15f921bec7f1dcdac2160eb66b",
      "index": 2,
      "occupied_capacity": 2742100000000,
      "data_hash": "0x2df53b592db3ae3685b7787adcfef0332a611edb83ca3feca435809964c3aff2",
      "type_id": null
    },
    {
      "name": "lock-proxy-lock",
      "tx_hash": "0x10d63a996157d32c01078058000052674ca58d15f921bec7f1dcdac2160eb66b",
      "index": 3,
      "occupied_capacity": 2750900000000,
      "data_hash": "0x5d41e32e224c15f152b7e6529100ebeac83b162f5f692a5365774dad2c1a1d02",
      "type_id": null
    },
    {
      "name": "single-use-lock",
      "tx_hash": "0x10d63a996157d32c01078058000052674ca58d15f921bec7f1dcdac2160eb66b",
      "index": 4,
      "occupied_capacity": 2783700000000,
      "data_hash": "0x8290467a512e5b9a6b816469b0edabba1f4ac474e28ffdd604c2a7c76446bbaf",
      "type_id": null
    },
    {
      "name": "type-burn-lock",
      "tx_hash": "0x10d63a996157d32c01078058000052674ca58d15f921bec7f1dcdac2160eb66b",
      "index": 5,
      "occupied_capacity": 2785300000000,
      "data_hash": "0xff78bae0abf17d7a404c0be0f9ad9c9185b3f88dcc60403453d5ba8e1f22f53a",
      "type_id": null
    },
    {
      "name": "easy-to-discover-type",
      "tx_hash": "0xb0ed754fb27d67fd8388c97fed914fb7998eceaa01f3e6f967e498de1ba0ac9b",
      "index": 0,
      "occupied_capacity": 2756500000000,
      "data_hash": "0xaba4430cc7110d699007095430a1faa72973edf2322ddbfd4d1d219cacf237af",
      "type_id": null
    },
    {
      "name": "time-lock",
      "tx_hash": "0xb0ed754fb27d67fd8388c97fed914fb7998eceaa01f3e6f967e498de1ba0ac9b",
      "index": 1,
      "occupied_capacity": 2850100000000,
      "data_hash": "0x6fac4b2e89360a1e692efcddcb3a28656d8446549fb83da6d896db8b714f4451",
      "type_id": null
    }
  ],
  "dep_group_recipes": []
}

================================================
File: migrations/testnet/2024-07-09-155812.json
================================================
{
  "cell_recipes": [
    {
      "name": "always-success",
      "tx_hash": "0x968c326f7a418f07a128f30d9a415251beaa2ec8bd6bbfda65780c94bebb2a85",
      "index": 0,
      "occupied_capacity": 127700000000,
      "data_hash": "0x3b521cc4b552f109d092d8cc468a8048acb53c5952dbe769d2b2f9cf6e47f7f1",
      "type_id": null
    },
    {
      "name": "input-type-proxy-lock",
      "tx_hash": "0x968c326f7a418f07a128f30d9a415251beaa2ec8bd6bbfda65780c94bebb2a85",
      "index": 1,
      "occupied_capacity": 2742100000000,
      "data_hash": "0x5123908965c711b0ffd8aec642f1ede329649bda1ebdca6bd24124d3796f768a",
      "type_id": null
    },
    {
      "name": "output-type-proxy-lock",
      "tx_hash": "0x968c326f7a418f07a128f30d9a415251beaa2ec8bd6bbfda65780c94bebb2a85",
      "index": 2,
      "occupied_capacity": 2742100000000,
      "data_hash": "0xc0382e4109cff68a4f536441c0266d2e22f2808e61573129c9289ee0e5e5ed43",
      "type_id": null
    },
    {
      "name": "lock-proxy-lock",
      "tx_hash": "0x968c326f7a418f07a128f30d9a415251beaa2ec8bd6bbfda65780c94bebb2a85",
      "index": 3,
      "occupied_capacity": 2750900000000,
      "data_hash": "0x5d41e32e224c15f152b7e6529100ebeac83b162f5f692a5365774dad2c1a1d02",
      "type_id": null
    },
    {
      "name": "single-use-lock",
      "tx_hash": "0x968c326f7a418f07a128f30d9a415251beaa2ec8bd6bbfda65780c94bebb2a85",
      "index": 4,
      "occupied_capacity": 2783700000000,
      "data_hash": "0x8290467a512e5b9a6b816469b0edabba1f4ac474e28ffdd604c2a7c76446bbaf",
      "type_id": null
    }
  ],
  "dep_group_recipes": []
}

================================================
File: migrations/testnet/2024-07-25-112426.json
================================================
{
  "cell_recipes": [
    {
      "name": "always-success",
      "tx_hash": "0xb4f171c9c9caf7401f54a8e56225ae21d95032150a87a4678eac3f66a3137b93",
      "index": 0,
      "occupied_capacity": 127700000000,
      "data_hash": "0x3b521cc4b552f109d092d8cc468a8048acb53c5952dbe769d2b2f9cf6e47f7f1",
      "type_id": null
    },
    {
      "name": "input-type-proxy-lock",
      "tx_hash": "0xb4f171c9c9caf7401f54a8e56225ae21d95032150a87a4678eac3f66a3137b93",
      "index": 1,
      "occupied_capacity": 2742100000000,
      "data_hash": "0x5123908965c711b0ffd8aec642f1ede329649bda1ebdca6bd24124d3796f768a",
      "type_id": null
    },
    {
      "name": "output-type-proxy-lock",
      "tx_hash": "0xb4f171c9c9caf7401f54a8e56225ae21d95032150a87a4678eac3f66a3137b93",
      "index": 2,
      "occupied_capacity": 2742100000000,
      "data_hash": "0x2df53b592db3ae3685b7787adcfef0332a611edb83ca3feca435809964c3aff2",
      "type_id": null
    },
    {
      "name": "lock-proxy-lock",
      "tx_hash": "0xb4f171c9c9caf7401f54a8e56225ae21d95032150a87a4678eac3f66a3137b93",
      "index": 3,
      "occupied_capacity": 2750900000000,
      "data_hash": "0x5d41e32e224c15f152b7e6529100ebeac83b162f5f692a5365774dad2c1a1d02",
      "type_id": null
    },
    {
      "name": "single-use-lock",
      "tx_hash": "0xb4f171c9c9caf7401f54a8e56225ae21d95032150a87a4678eac3f66a3137b93",
      "index": 4,
      "occupied_capacity": 2783700000000,
      "data_hash": "0x8290467a512e5b9a6b816469b0edabba1f4ac474e28ffdd604c2a7c76446bbaf",
      "type_id": null
    },
    {
      "name": "type-burn-lock",
      "tx_hash": "0xb4f171c9c9caf7401f54a8e56225ae21d95032150a87a4678eac3f66a3137b93",
      "index": 5,
      "occupied_capacity": 2785300000000,
      "data_hash": "0xff78bae0abf17d7a404c0be0f9ad9c9185b3f88dcc60403453d5ba8e1f22f53a",
      "type_id": null
    }
  ],
  "dep_group_recipes": []
}

================================================
File: migrations/testnet/2024-10-08-042300.json
================================================
{
  "cell_recipes": [
    {
      "name": "always-success",
      "tx_hash": "0xb4f171c9c9caf7401f54a8e56225ae21d95032150a87a4678eac3f66a3137b93",
      "index": 0,
      "occupied_capacity": 127700000000,
      "data_hash": "0x3b521cc4b552f109d092d8cc468a8048acb53c5952dbe769d2b2f9cf6e47f7f1",
      "type_id": null
    },
    {
      "name": "input-type-proxy-lock",
      "tx_hash": "0xb4f171c9c9caf7401f54a8e56225ae21d95032150a87a4678eac3f66a3137b93",
      "index": 1,
      "occupied_capacity": 2742100000000,
      "data_hash": "0x5123908965c711b0ffd8aec642f1ede329649bda1ebdca6bd24124d3796f768a",
      "type_id": null
    },
    {
      "name": "output-type-proxy-lock",
      "tx_hash": "0xb4f171c9c9caf7401f54a8e56225ae21d95032150a87a4678eac3f66a3137b93",
      "index": 2,
      "occupied_capacity": 2742100000000,
      "data_hash": "0x2df53b592db3ae3685b7787adcfef0332a611edb83ca3feca435809964c3aff2",
      "type_id": null
    },
    {
      "name": "lock-proxy-lock",
      "tx_hash": "0xb4f171c9c9caf7401f54a8e56225ae21d95032150a87a4678eac3f66a3137b93",
      "index": 3,
      "occupied_capacity": 2750900000000,
      "data_hash": "0x5d41e32e224c15f152b7e6529100ebeac83b162f5f692a5365774dad2c1a1d02",
      "type_id": null
    },
    {
      "name": "single-use-lock",
      "tx_hash": "0xb4f171c9c9caf7401f54a8e56225ae21d95032150a87a4678eac3f66a3137b93",
      "index": 4,
      "occupied_capacity": 2783700000000,
      "data_hash": "0x8290467a512e5b9a6b816469b0edabba1f4ac474e28ffdd604c2a7c76446bbaf",
      "type_id": null
    },
    {
      "name": "type-burn-lock",
      "tx_hash": "0xb4f171c9c9caf7401f54a8e56225ae21d95032150a87a4678eac3f66a3137b93",
      "index": 5,
      "occupied_capacity": 2785300000000,
      "data_hash": "0xff78bae0abf17d7a404c0be0f9ad9c9185b3f88dcc60403453d5ba8e1f22f53a",
      "type_id": null
    },
    {
      "name": "easy-to-discover-type",
      "tx_hash": "0x1b4ffcad55ecd36ffb2715b6816b83da73851f1a24fe594f263c4f34dad90792",
      "index": 0,
      "occupied_capacity": 2756500000000,
      "data_hash": "0xaba4430cc7110d699007095430a1faa72973edf2322ddbfd4d1d219cacf237af",
      "type_id": null
    },
    {
      "name": "time-lock",
      "tx_hash": "0x1b4ffcad55ecd36ffb2715b6816b83da73851f1a24fe594f263c4f34dad90792",
      "index": 1,
      "occupied_capacity": 2850100000000,
      "data_hash": "0x6fac4b2e89360a1e692efcddcb3a28656d8446549fb83da6d896db8b714f4451",
      "type_id": null
    }
  ],
  "dep_group_recipes": []
}

================================================
File: scripts/find_clang
================================================
#!/usr/bin/env bash
#
# An utility script used to find a binary of clang 16+

if [[ -n "${CLANG}" ]]; then
  echo "${CLANG}"
  exit 0
fi

CANDIDATES=("clang" "clang-16" "clang-17")

BREW_PREFIX=$(brew --prefix 2> /dev/null)
if [[ -n "${BREW_PREFIX}" ]]; then
  CANDIDATES+=(
    "${BREW_PREFIX}/opt/llvm/bin/clang"
    "${BREW_PREFIX}/opt/llvm@16/bin/clang"
    "${BREW_PREFIX}/opt/llvm@17/bin/clang"
  )
fi

for candidate in ${CANDIDATES[@]}; do
  OUTPUT=$($candidate -dumpversion 2> /dev/null | cut -d'.' -f 1)

  if [[ $((OUTPUT)) -ge 16 ]]; then
    echo "$candidate"
    exit 0
  fi
done

>&2 echo "Cannot find clang of version 16+!"
exit 1


================================================
File: scripts/reproducible_build_docker
================================================
#!/usr/bin/env bash
#
# An utility script helping with reproducible script builds via docker.
# Note that this utility serves only as one example, docker is not
# necessarily THE way to do reproducible build, nor is it the best way
# to do reproducible build.
set -ex

DOCKER="${DOCKER:-docker}"
# docker pull docker.io/cryptape/llvm-n-rust:20240630
DOCKER_IMAGE="${DOCKER_IMAGE:-docker.io/cryptape/llvm-n-rust@sha256:bafaf76d4f342a69b8691c08e77a330b7740631f3d1d9c9bee4ead521b29ee55}"
CHECKSUM_FILE_PATH="${CHECKSUM_FILE_PATH:-checksums.txt}"

# We are parsing command line arguments based on tips from:
# https://stackoverflow.com/a/14203146

while [[ $# -gt 0 ]]; do
  case $1 in
    -p|--proxy)
      PROXY="$2"
      shift # past argument
      shift # past value
      ;;
    -u|--update)
      UPDATE="yes"
      shift # past argument
      ;;
    --no-clean)
      NOCLEAN="yes"
      shift # past argument
      ;;
    -*|--*)
      echo "Unknown option $1"
      exit 1
      ;;
    *)
      echo "Unknown argument $1"
      exit 1
      ;;
  esac
done

if [[ -n "${PROXY}" ]]; then
  DOCKER_RUN_ARGS="-e ALL_PROXY=${PROXY} -e HTTPS_PROXY=${PROXY} -e HTTP_PROXY=${PROXY} ${DOCKER_RUN_ARGS}"
fi

TASKS=""
if [[ "${NOCLEAN}" != "yes" ]]; then
  TASKS+=" clean "
fi

if [[ "${UPDATE}" = "yes" ]]; then
  TASKS+=" checksum CHECKSUM_FILE=${CHECKSUM_FILE_PATH} "
else
  TASKS+=" build "
fi

$DOCKER run --rm $DOCKER_RUN_ARGS -v `pwd`:/code $DOCKER_IMAGE make $TASKS
# Reset file ownerships for all files docker might touch
$DOCKER run --rm $DOCKER_RUN_ARGS -e UID=`id -u` -e GID=`id -g` -v `pwd`:/code $DOCKER_IMAGE bash -c 'chown -R -f $UID:$GID checksums.txt build target'

if [[ "${UPDATE}" = "yes" ]]; then
  echo "${CHECKSUM_FILE_PATH} file is updated with latest binary hashes!"
else
  shasum -a 256 -c ${CHECKSUM_FILE_PATH}
fi


================================================
File: tests/Cargo.toml
================================================
[package]
name = "tests"
version = "0.1.0"
edition = "2021"

[dependencies]
ckb-testtool = "0.10.2"
serde_json = "1.0"
ckb-std = "0.15.1"


================================================
File: tests/src/lib.rs
================================================
use ckb_testtool::{
    ckb_error::Error,
    ckb_types::{
        bytes::Bytes,
        core::{Cycle, TransactionView},
    },
    context::Context,
};
use std::env;
use std::fs;
use std::path::PathBuf;
use std::str::FromStr;

#[cfg(test)]
mod tests;

// The exact same Loader code from capsule's template, except that
// now we use MODE as the environment variable
const TEST_ENV_VAR: &str = "MODE";

pub enum TestEnv {
    Debug,
    Release,
}

impl FromStr for TestEnv {
    type Err = &'static str;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "debug" => Ok(TestEnv::Debug),
            "release" => Ok(TestEnv::Release),
            _ => Err("no match"),
        }
    }
}

pub struct Loader(PathBuf);

impl Default for Loader {
    fn default() -> Self {
        let test_env = match env::var(TEST_ENV_VAR) {
            Ok(val) => val.parse().expect("test env"),
            Err(_) => TestEnv::Release,
        };
        Self::with_test_env(test_env)
    }
}

impl Loader {
    fn with_test_env(env: TestEnv) -> Self {
        let load_prefix = match env {
            TestEnv::Debug => "debug",
            TestEnv::Release => "release",
        };
        let mut base_path = match env::var("TOP") {
            Ok(val) => {
                let mut base_path: PathBuf = val.into();
                base_path.push("build");
                base_path
            }
            Err(_) => {
                let mut base_path = PathBuf::new();
                // cargo may use a different cwd when running tests, for example:
                // when running debug in vscode, it will use workspace root as cwd by default,
                // when running test by `cargo test`, it will use tests directory as cwd,
                // so we need a fallback path
                base_path.push("build");
                if !base_path.exists() {
                    base_path.pop();
                    base_path.push("..");
                    base_path.push("build");
                }
                base_path
            }
        };

        base_path.push(load_prefix);
        Loader(base_path)
    }

    pub fn load_binary(&self, name: &str) -> Bytes {
        let mut path = self.0.clone();
        path.push(name);
        let result = fs::read(&path);
        if result.is_err() {
            panic!("Binary {:?} is missing!", path);
        }
        result.unwrap().into()
    }
}

// This helper method runs Context::verify_tx, but in case error happens,
// it also dumps current transaction to failed_txs folder.
pub fn verify_and_dump_failed_tx(
    context: &Context,
    tx: &TransactionView,
    max_cycles: u64,
) -> Result<Cycle, Error> {
    let result = context.verify_tx(tx, max_cycles);
    if result.is_err() {
        let mut path = env::current_dir().expect("current dir");
        path.push("failed_txs");
        std::fs::create_dir_all(&path).expect("create failed_txs dir");
        let mock_tx = context.dump_tx(tx).expect("dump failed tx");
        let json = serde_json::to_string_pretty(&mock_tx).expect("json");
        path.push(format!("0x{:x}.json", tx.hash()));
        println!("Failed tx written to {:?}", path);
        std::fs::write(path, json).expect("write");
    }
    result
}


================================================
File: tests/src/tests.rs
================================================
// Include your tests here
// See https://github.com/xxuejie/ckb-native-build-sample/blob/main/tests/src/tests.rs for examples

mod input_type_owner;
mod lock_owner;
mod output_type_owner;
mod single_use_lock;
mod time_lock;


================================================
File: tests/src/tests/time_lock.rs
================================================
use crate::Loader;
use ckb_std::since::Since;
use ckb_testtool::{
    builtin::ALWAYS_SUCCESS,
    ckb_types::{bytes::Bytes, core::TransactionBuilder, packed::*, prelude::*},
    context::Context,
};

const MAX_CYCLES: u64 = 10_000_000;

// Include your tests here
// See https://github.com/xxuejie/ckb-native-build-sample/blob/main/tests/src/tests.rs for more examples

#[test]
fn test_time_lock() {
    let mut context = Context::default();

    // * bin => out_point => Script, cell_dep
    let required_lock_script_out_point = context.deploy_cell(ALWAYS_SUCCESS.clone());

    let required_lock_script = context
        .build_script(&required_lock_script_out_point.clone(), Default::default())
        .expect("script");
    let required_lock_script_cell_dep = CellDep::new_builder()
        .out_point(required_lock_script_out_point.clone())
        .build();

    let required_script_hash_bytes32 = required_lock_script.calc_script_hash();
    let locked_until_abs_blk_num_4 = Since::from_block_number(4, true).expect("error");
    // convert locked_until_blk_num to bytes
    let locked_until_bytes: [u8; 8] = locked_until_abs_blk_num_4.as_u64().to_le_bytes();

    // concat lock_until and required_lock_script_hash
    let mut time_lock_script_args_vec: Vec<u8> = Vec::new();
    time_lock_script_args_vec.extend_from_slice(&required_script_hash_bytes32.as_bytes());
    time_lock_script_args_vec.extend_from_slice(&locked_until_bytes);
    let time_lock_script_args: Bytes = Bytes::from(time_lock_script_args_vec);
    let time_lock_bin: Bytes = Loader::default().load_binary("time-lock");
    let time_lock_bin_out_point = context.deploy_cell(time_lock_bin);
    let time_lock_script = context
        .build_script(&time_lock_bin_out_point.clone(), time_lock_script_args)
        .expect("script");
    let time_lock_cell_dep = CellDep::new_builder()
        .out_point(time_lock_bin_out_point.clone())
        .build();

    let cell_deps: Vec<CellDep> = vec![required_lock_script_cell_dep, time_lock_cell_dep];

    // prepare cells
    let cannot_unlock_abs_blk_num_2 = Since::from_block_number(2, true).expect("error");
    let can_unlock_abs_blk_num_233 = Since::from_block_number(233, true).expect("error");
    let out_point_0 = context.create_cell(
        CellOutput::new_builder()
            .capacity(500u64.pack())
            .lock(time_lock_script.clone())
            .build(),
        Bytes::new(),
    );
    let cell_input_0 = CellInput::new_builder()
        .previous_output(out_point_0.clone())
        .since(can_unlock_abs_blk_num_233.as_u64().pack())
        .build();
    let cell_input_1 = CellInput::new_builder()
        .previous_output(out_point_0.clone())
        .since(cannot_unlock_abs_blk_num_2.as_u64().pack())
        .build();
    let out_point_1 = context.create_cell(
        CellOutput::new_builder()
            .capacity(500u64.pack())
            .lock(required_lock_script.clone())
            .build(),
        Bytes::new(),
    );
    let cell_input_2 = CellInput::new_builder()
        .previous_output(out_point_1.clone())
        .since(cannot_unlock_abs_blk_num_2.as_u64().pack())
        .build();

    let outputs = vec![
        CellOutput::new_builder().capacity(500u64.pack()).build(),
        CellOutput::new_builder().capacity(500u64.pack()).build(),
    ];

    let outputs_data = vec![Bytes::new(); 2];

    let cell_inputs_missing_required_lock: Vec<CellInput> = vec![cell_input_0.clone()];
    let cell_inputs_cannot_unlock_yet: Vec<CellInput> =
        vec![cell_input_1.clone(), cell_input_2.clone()];
    let cell_inputs_ok: Vec<CellInput> = vec![cell_input_0.clone(), cell_input_2.clone()];

    // build transaction
    let tx_missing_required_lock = TransactionBuilder::default()
        .cell_deps(cell_deps.clone())
        .inputs(cell_inputs_missing_required_lock)
        .outputs(outputs.clone())
        .outputs_data(outputs_data.clone().pack())
        .build();
    let tx_missing_required_lock = tx_missing_required_lock.as_advanced_builder().build();
    context
        .verify_tx(&tx_missing_required_lock, MAX_CYCLES)
        .expect_err("cannot unlock without required lock script");

    let tx_cannot_unlock_yet = TransactionBuilder::default()
        .cell_deps(cell_deps.clone())
        .inputs(cell_inputs_cannot_unlock_yet)
        .outputs(outputs.clone())
        .outputs_data(outputs_data.clone().pack())
        .build();
    let tx_cannot_unlock_yet = tx_cannot_unlock_yet.as_advanced_builder().build();
    context
        .verify_tx(&tx_cannot_unlock_yet, MAX_CYCLES)
        .expect_err("cannot unlock yet");

    let tx_ok = TransactionBuilder::default()
        .cell_deps(cell_deps)
        .inputs(cell_inputs_ok)
        .outputs(outputs)
        .outputs_data(outputs_data.pack())
        .build();

    let tx_ok = tx_ok.as_advanced_builder().build();
    let cycles = context
        .verify_tx(&tx_ok, MAX_CYCLES)
        .expect("pass verification");
    println!("consume cycles: {}", cycles);
}


