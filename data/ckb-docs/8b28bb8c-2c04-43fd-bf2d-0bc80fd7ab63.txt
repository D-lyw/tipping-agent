Directory structure:
└── sporeprotocol-spore-contract/
    ├── README.md
    ├── Cargo.toml
    ├── Cross.toml
    ├── LICENSE
    ├── capsule.toml
    ├── rust-toolchain
    ├── contracts/
    │   ├── cluster/
    │   │   ├── Cargo.toml
    │   │   ├── build.rs
    │   │   └── src/
    │   │       ├── entry.rs
    │   │       └── main.rs
    │   ├── cluster_agent/
    │   │   ├── Cargo.toml
    │   │   ├── build.rs
    │   │   └── src/
    │   │       ├── entry.rs
    │   │       └── main.rs
    │   ├── cluster_proxy/
    │   │   ├── Cargo.toml
    │   │   ├── build.rs
    │   │   └── src/
    │   │       ├── entry.rs
    │   │       └── main.rs
    │   ├── spore/
    │   │   ├── Cargo.toml
    │   │   ├── build.rs
    │   │   └── src/
    │   │       ├── entry.rs
    │   │       └── main.rs
    │   └── spore_extension_lua/
    │       ├── Cargo.toml
    │       ├── build.rs
    │       ├── lua/
    │       │   └── README.md
    │       └── src/
    │           ├── entry.rs
    │           ├── error.rs
    │           └── main.rs
    ├── deployment/
    │   ├── README.md
    │   ├── deploy.sh
    │   ├── frozen/
    │   │   ├── mainnet.toml
    │   │   └── testnet.toml
    │   ├── migration/
    │   │   ├── mainnet/
    │   │   │   ├── cluster/
    │   │   │   │   └── 2024-01-23-0.2.2-beta.1.json
    │   │   │   └── spore/
    │   │   │       └── 2024-01-25-0.2.2-beta.1.json
    │   │   └── testnet/
    │   │       ├── cluster/
    │   │       │   ├── 2024-01-19-0.2.1.json
    │   │       │   └── 2024-03-16-0.2.2-beta.2.json
    │   │       ├── cluster_agent/
    │   │       │   ├── 2024-01-19-0.2.1.json
    │   │       │   └── 2024-03-16-0.2.2-beta.2.json
    │   │       ├── cluster_proxy/
    │   │       │   ├── 2024-01-19-0.2.1.json
    │   │       │   └── 2024-03-16-0.2.2-beta.2.json
    │   │       ├── spore/
    │   │       │   ├── 2024-01-19-0.2.1.json
    │   │       │   └── 2024-03-16-0.2.2-beta.2.json
    │   │       └── spore_extension_lua/
    │   │           ├── 2024-01-19-0.2.1.json
    │   │           └── 2024-03-16-0.2.2-beta.2.json
    │   └── toml/
    │       ├── mainnet/
    │       │   ├── cluster.toml
    │       │   ├── cluster_agent.toml
    │       │   ├── cluster_proxy.toml
    │       │   ├── spore.toml
    │       │   └── spore_extension_lua.toml
    │       └── testnet/
    │           ├── cluster.toml
    │           ├── cluster_agent.toml
    │           ├── cluster_proxy.toml
    │           ├── spore.toml
    │           └── spore_extension_lua.toml
    ├── docs/
    │   ├── MUTANT.md
    │   ├── RFC.md
    │   ├── RFC_PROXY_AGENT.md
    │   └── VERSIONS.md
    ├── lib/
    │   ├── build/
    │   │   ├── Cargo.toml
    │   │   └── src/
    │   │       └── lib.rs
    │   ├── errors/
    │   │   ├── Cargo.toml
    │   │   └── src/
    │   │       ├── error.rs
    │   │       └── lib.rs
    │   ├── types/
    │   │   ├── Cargo.toml
    │   │   ├── schemas/
    │   │   │   ├── action.mol
    │   │   │   ├── spore_v1.mol
    │   │   │   └── spore_v2.mol
    │   │   └── src/
    │   │       ├── lib.rs
    │   │       └── generated/
    │   │           ├── action.rs
    │   │           ├── mod.rs
    │   │           ├── spore_v1.rs
    │   │           └── spore_v2.rs
    │   └── utils/
    │       ├── Cargo.toml
    │       └── src/
    │           ├── lib.rs
    │           └── mime.rs
    ├── tests/
    │   ├── Cargo.lock
    │   ├── Cargo.toml
    │   ├── resource/
    │   │   ├── spore_raw.nft
    │   │   └── spore_with_cluster.nft
    │   └── src/
    │       ├── lib.rs
    │       ├── tests.rs
    │       ├── tests/
    │       │   ├── cluster.rs
    │       │   ├── mutant.rs
    │       │   ├── spore.rs
    │       │   └── utils.rs
    │       └── utils/
    │           ├── co_build.rs
    │           ├── internal.rs
    │           └── mod.rs
    └── .github/
        └── workflows/
            ├── capsule.yaml
            └── devnet.yaml

================================================
File: README.md
================================================
# <p align="center"> Spore Protocol</p>
<p align="center">
  A protocol for valuing on-chain contents, build on top of <a href="https://github.com/nervosnetwork/ckb">CKB</a>. Check <a href="https://docs.spore.pro">Spore Docs</a> for a quick start.
</p>

Developers are recommended to use the [Spore SDK](https://github.com/sporeprotocol/spore-sdk) for building applications with Spore, instead of directly interacting with the contracts. If you're interested in testing, extending the contracts, or deploying them on a local blockchain, feel free to explore the [Development](#⚙️-development) section for guidance.

## About

Spore is an on-chain protocol to power digital asset ownership, distribution, and value capture. For more, check out https://spore.pro

This repo contains the [Spore RFC](./docs/RFC.md), [Spore Mutant RFC](./docs/MUTANT.md), [Spore Cluster Proxy/Agent RFC](./docs/RFC_PROXY_AGENT.md), protocol types [schema definition](./lib/types/schemas/spore.mol) and [implementation](./contracts/) of Spore contracts written in Rust.


## ⚙️ Development
Before development, basic dependencies are required:

- [Rust](https://www.rust-lang.org/tools/install)
- [Cross](https://github.com/cross-rs/cross)
- [Capsule](https://github.com/nervosnetwork/capsule)

To build contracts, please run one of below commands:

```bash
$ capsule build # build in debug mode
$ capsule build --release # build in release mode for testnet
$ capsule build --release -- --features release_export # build in release mode for mainnet
```

To check native test cases, which are placed in [tests](./tests/), please run:

```bash
$ capsule test # test in debug mode
$ capsule test --release # test in release mode
```

### Writing extra contracts

If your development requires to be built on Spore, steps below are recommended:

1. Writing a new Type contract
2. Modify existed contracts

For method 1, the flow is:

1. Run `capsule new-contract YOUR_CONTRACT_NAME` to initialize a new contract project
2. Modify `Cargo.toml` of your contract, and introduce `spore-types`,`spore-utils`, `spore-constant`
3. Implementing your contract rules in `entry.rs`
4. Writing new tests in `tests/src/tests.rs`. See existed test cases for how-to

## Deployed Code Hashes
The versioning philosophy is **"Using code_hash as version"** for Spore Protocol, which means the different code hash matches the different version.

Make sure you are using the proper version you want, because there's no such an "upgrade/downgrade" method but we suggest to use "destroy/reconstruct" method instead, which requires no modification of any fields in Spore cell.

Our `frozen` versions of contract, which are our prior versions, can be found in [directory](https://github.com/sporeprotocol/spore-contract/tree/master/deployment/frozen) `./deployment/frozen`. To describe more clearly, the `frozen` information contains each avaliable `code_hash` generated from Spore contracts. Historical version refers to [here](https://github.com/sporeprotocol/spore-contract/blob/master/docs/VERSIONS.md).

In addition, using Mutant contract requires the binary of Lua library. Information are recorded [here](https://github.com/sporeprotocol/spore-contract/tree/master/contracts/spore_extension_lua/lua). For simplicity, it's already deployed in the Pudge Testnet:

#### Spore Lua Lib
- tx_hash: `0x8fb7170a58d631250dabd0f323a833f4ad2cfdd0189f45497e62beb8409e7a0c`
- index: `0`
- data_hash: `0xed08faee8c29b7a7c29bd9d495b4b93cc207bd70ca93f7b356f39c677e7ab0fc`

## Deployment

We provided a simple bash script to operate deployment through `ckb-cli` toolchain, details refer to [here](https://github.com/sporeprotocol/spore-contract/tree/master/deployment)


================================================
File: Cargo.toml
================================================
[workspace]
resolver = "2"
members = [
    "lib/types",
    "lib/utils",
    "lib/errors",
    "lib/build",

    "contracts/spore",
    "contracts/cluster",
    "contracts/cluster_proxy",
    "contracts/cluster_agent",
    "contracts/spore_extension_lua",
]
exclude = ["tests"]

[profile.release]
overflow-checks = true
strip = true
opt-level = 's'
lto = true
codegen-units = 1


================================================
File: Cross.toml
================================================
[build]
default-target = "riscv64imac-unknown-none-elf"

[target.riscv64imac-unknown-none-elf]
image = "nervos/ckb-riscv-gnu-toolchain:focal-20230214"


================================================
File: LICENSE
================================================
MIT License
-----------

Copyright (c) 2023 [Team Spore Protocol]
Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

================================================
File: capsule.toml
================================================
# [rust]
# # path of rust contracts workspace directory,
# # a `Cargo.toml` file is expected under the directory.
# workspace_dir = "."

# capsule version
version = "0.10.2 5e49142"
# path of deployment config file
deployment = "deployment.toml"

# CAUTION: contracts order cannot be changed here

[[contracts]]
name = "spore_extension_lua"
template_type = "Rust"

[[contracts]]
name = "cluster"
template_type = "Rust"

[[contracts]]
name = "cluster_proxy"
template_type = "Rust"

[[contracts]]
name = "cluster_agent"
template_type = "Rust"

[[contracts]]
name = "spore"
template_type = "Rust"


================================================
File: rust-toolchain
================================================
1.74.0


================================================
File: contracts/cluster/Cargo.toml
================================================
[package]
name = "cluster"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
ckb-std = "0.14.3"
spore-types = { path = "../../lib/types" }
spore-utils = { path = "../../lib/utils" }
spore-errors = { path = "../../lib/errors" }

[build-dependencies]
ckb-hash = "0.112.1"
spore-build-tools = { path = "../../lib/build" }

[features]
default = []
release_export = []


================================================
File: contracts/cluster/build.rs
================================================
use ckb_hash::blake2b_256;
use std::{env, fs};

use spore_build_tools::{concat_code_hashes, load_frozen_toml};

pub fn main() {
    let compile_mode = env::var("PROFILE").unwrap();
    let spore_extension_lua_path = env::current_dir()
        .unwrap()
        .join("../../build")
        .join(compile_mode)
        .join("spore_extension_lua");
    let spore_extension_lua =
        std::fs::read(spore_extension_lua_path).expect("load spore_extension_lua");
    let code_hash = blake2b_256(spore_extension_lua);

    let frozen = load_frozen_toml();
    let code_hashes = [frozen.mutant_code_hashes(), vec![code_hash]].concat();

    let file = concat_code_hashes("SPORE_EXTENSION_LUA", &code_hashes);
    fs::write("./src/hash.rs", file).unwrap();
}


================================================
File: contracts/cluster/src/entry.rs
================================================
// Import heap related library from `alloc`
// https://doc.rust-lang.org/alloc/index.html
use alloc::vec::Vec;
use ckb_std::ckb_types::util::hash::blake2b_256;
use spore_types::generated::action;
// Import from `core` instead of from `std` since we are in no-std mode
use core::result::Result;

use ckb_std::ckb_constants::Source::{CellDep, GroupInput, GroupOutput, Output};
use ckb_std::ckb_types::packed::Script;
use ckb_std::{
    ckb_constants::Source,
    ckb_types::prelude::*,
    high_level::{load_cell_data, load_cell_type},
};
// Import CKB syscalls and structures
// https://docs.rs/ckb-std/
use ckb_std::high_level::{load_script, QueryIter};
use spore_errors::error::Error;
use spore_types::generated::spore::ClusterDataV2 as ClusterData;
use spore_utils::{
    check_spore_address, extract_spore_action, find_position_by_type, find_position_by_type_args,
    load_self_id, verify_type_id,
};

use crate::hash::SPORE_EXTENSION_LUA;

fn load_cluster_data(index: usize, source: Source) -> Result<ClusterData, Error> {
    let raw_data = load_cell_data(index, source)?;
    let cluster_data = ClusterData::from_compatible_slice(raw_data.as_slice())
        .map_err(|_| Error::InvalidClusterData)?;
    Ok(cluster_data)
}

fn process_creation(index: usize) -> Result<(), Error> {
    let cluster_data = load_cluster_data(index, Output)?;
    if cluster_data.name().is_empty() {
        return Err(Error::EmptyName);
    }
    let Some(cluster_id) = verify_type_id(index) else {
        return Err(Error::InvalidClusterID);
    };

    // Verify if mutant is set
    if cluster_data.mutant_id().is_some() {
        let script = load_script().unwrap_or_default();
        let filter_fn: fn(&[u8; 32]) -> bool = |x| -> bool { SPORE_EXTENSION_LUA.contains(x) };
        let args: Vec<u8> = script.args().unpack();
        find_position_by_type_args(&args, CellDep, Some(filter_fn))
            .ok_or(Error::MutantNotInDeps)?;
    }

    // check co-build action @lyk
    let action::SporeActionUnion::MintCluster(mint) = extract_spore_action()?.to_enum() else {
        return Err(Error::SporeActionMismatch);
    };
    if cluster_id != mint.cluster_id().as_slice()
        || blake2b_256(cluster_data.as_slice()) != mint.data_hash().as_slice()
    {
        return Err(Error::SporeActionFieldMismatch);
    }
    check_spore_address(GroupOutput, mint.to())?;

    Ok(())
}

fn process_transfer() -> Result<(), Error> {
    // check no field was modified
    let input_cluster_data = load_cluster_data(0, GroupInput)?;
    let output_cluster_data = load_cluster_data(0, GroupOutput)?;

    if input_cluster_data.as_slice()[..] != output_cluster_data.as_slice()[..] {
        return Err(Error::ModifyClusterPermanentField);
    }

    // check co-build action @lyk
    let action::SporeActionUnion::TransferCluster(transfer) = extract_spore_action()?.to_enum()
    else {
        return Err(Error::SporeActionMismatch);
    };
    if transfer.cluster_id().as_slice() != &load_self_id()? {
        return Err(Error::SporeActionFieldMismatch);
    }
    check_spore_address(GroupInput, transfer.from())?;
    check_spore_address(GroupOutput, transfer.to())?;

    Ok(())
}

pub fn main() -> Result<(), Error> {
    let cluster_in_output: Vec<Script> = QueryIter::new(load_cell_type, GroupOutput)
        .map(|script| script.unwrap_or_default())
        .collect();

    if cluster_in_output.len() > 1 {
        // Conflict Creation
        return Err(Error::InvalidClusterOperation);
    }

    let cluster_in_input: Vec<Script> = QueryIter::new(load_cell_type, GroupInput)
        .map(|script| script.unwrap_or_default())
        .collect();

    if cluster_in_input.len() > 1 {
        // Multi-spend
        return Err(Error::InvalidClusterOperation);
    }

    match (cluster_in_input.len(), cluster_in_output.len()) {
        (0, 1) => {
            // find it's index in Source::Output

            let output_index =
                find_position_by_type(&cluster_in_output[0], Output).unwrap_or_default(); // Once we entered here, it can't be empty, and use 0 as a fallback position
            return process_creation(output_index);
        }
        // can not destroy a cluster cell
        (1, 0) => {
            return Err(Error::InvalidClusterOperation);
        }
        (1, 1) => {
            return process_transfer();
        }
        _ => unreachable!(),
    }
}


================================================
File: contracts/cluster/src/main.rs
================================================
//! Generated by capsule
//!
//! `main.rs` is used to define rust lang items and modules.
//! See `entry.rs` for the `main` function.
//! See `error.rs` for the `Error` type.

#![no_std]
#![cfg_attr(not(test), no_main)]

// define modules
mod entry;
mod hash;

#[cfg(test)]
extern crate alloc;

#[cfg(not(test))]
use ckb_std::default_alloc;
#[cfg(not(test))]
ckb_std::entry!(program_entry);
#[cfg(not(test))]
default_alloc!();

/// program entry
pub fn program_entry() -> i8 {
    // Call main function and return error code
    match entry::main() {
        Ok(_) => 0,
        Err(err) => err as i8,
    }
}


================================================
File: contracts/cluster_agent/Cargo.toml
================================================
[package]
name = "cluster_agent"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
ckb-std = "0.14.3"
spore-utils = { path = "../../lib/utils" }
spore-types = { path = "../../lib/types" }
spore-errors = { path = "../../lib/errors" }

[build-dependencies]
ckb-hash = "0.112.1"
spore-build-tools = { path = "../../lib/build" }

[features]
default = []
release_export = []


================================================
File: contracts/cluster_agent/build.rs
================================================
use ckb_hash::blake2b_256;
use std::{env, fs};

use spore_build_tools::{concat_code_hashes, load_frozen_toml};

pub fn main() {
    let compile_mode = env::var("PROFILE").unwrap();
    let cluster_proxy_path = env::current_dir()
        .unwrap()
        .join("../../build")
        .join(compile_mode)
        .join("cluster_proxy");
    let cluster_proxy = std::fs::read(cluster_proxy_path).expect("load cluster_proxy");
    let code_hash = blake2b_256(cluster_proxy);

    let frozen = load_frozen_toml();
    let code_hashes = [frozen.cluster_proxy_code_hashes(), vec![code_hash]].concat();

    let file = concat_code_hashes("CLUSTER_PROXY_CODE_HASHES", &code_hashes);
    fs::write("./src/hash.rs", file).unwrap();
}


================================================
File: contracts/cluster_agent/src/entry.rs
================================================
// Import from `core` instead of from `std` since we are in no-std mode
use core::result::Result;

// Import heap related library from `alloc`
// https://doc.rust-lang.org/alloc/index.html
use alloc::vec::Vec;

// Import CKB syscalls and structures
// https://docs.rs/ckb-std/
use ckb_std::ckb_constants::Source::{self, CellDep, GroupInput, GroupOutput, Input, Output};
use ckb_std::ckb_types::packed::Script;
use ckb_std::high_level::{load_cell_data, load_cell_lock_hash, load_cell_type, QueryIter};
use ckb_std::{ckb_types::prelude::*, debug, high_level::load_script};

use spore_errors::error::Error;
use spore_types::generated::action;
use spore_utils::{
    calc_capacity_sum, find_position_by_type, find_position_by_type_hash, load_self_id,
};
use spore_utils::{
    check_spore_address, extract_spore_action, CLUSTER_PROXY_ID_LEN,
    CLUSTER_PROXY_ID_WITH_PAYMENT_LEN,
};

fn is_valid_cluster_proxy_cell(script_hash: &[u8; 32]) -> bool {
    crate::hash::CLUSTER_PROXY_CODE_HASHES.contains(script_hash)
}

fn has_conflict_agent(source: Source, cell_data: &[u8]) -> bool {
    let script = load_script().unwrap_or_default();
    let self_code_hash = script.code_hash();
    let agents_count = QueryIter::new(load_cell_type, source)
        .enumerate()
        .filter(|(index, type_)| {
            if let Some(type_) = type_ {
                if type_.code_hash().as_slice() == self_code_hash.as_slice() {
                    let data = load_cell_data(*index, source).unwrap();
                    return cell_data == data;
                }
            }
            false
        })
        .count();
    agents_count > 1
}

fn process_creation(_index: usize) -> Result<(), Error> {
    let proxy_type_hash = load_cell_data(0, GroupOutput)?;
    // check cluster proxy in Deps
    let proxy_index = find_position_by_type_hash(proxy_type_hash.as_slice(), CellDep)
        .ok_or(Error::ProxyCellNotInDep)?;
    let proxy_type = load_cell_type(proxy_index, CellDep)?.unwrap_or_default();
    if !is_valid_cluster_proxy_cell(&proxy_type.code_hash().unpack()) {
        return Err(Error::RefCellNotClusterProxy);
    }

    // verify cluster id
    let cluster_id = load_cell_data(proxy_index, CellDep)?;
    let script = load_script()?;
    if script.args().raw_data().as_ref() != &cluster_id {
        return Err(Error::InvalidAgentArgs);
    }

    // Condition 1: Check if cluster proxy exist in Inputs & Outputs
    let proxy_cell_in_input =
        find_position_by_type_hash(proxy_type_hash.as_slice(), Input).is_some();
    let proxy_cell_in_output =
        find_position_by_type_hash(proxy_type_hash.as_slice(), Output).is_some();

    if !proxy_cell_in_input || !proxy_cell_in_output {
        // Condition 2: Check for minimal payment
        let proxy_type_args = load_cell_type(proxy_index, CellDep)?
            .unwrap_or_default()
            .args()
            .raw_data();
        if proxy_type_args.len() == CLUSTER_PROXY_ID_WITH_PAYMENT_LEN {
            let range = CLUSTER_PROXY_ID_LEN..CLUSTER_PROXY_ID_WITH_PAYMENT_LEN;
            let minimal_payment =
                u64::from_le_bytes(proxy_type_args[range].try_into().unwrap_or_default());
            debug!("Minimal payment is: {}", minimal_payment);

            let proxy_lock_hash = load_cell_lock_hash(proxy_index, CellDep)?;
            let input_capacity = calc_capacity_sum(&proxy_lock_hash, Input);
            let output_capacity = calc_capacity_sum(&proxy_lock_hash, Output);
            if input_capacity + minimal_payment > output_capacity {
                return Err(Error::PaymentNotEnough);
            } else {
                // Condition 3: Check no same agent in creation
                if has_conflict_agent(Source::Output, &proxy_type_hash) {
                    return Err(Error::ConflictAgentCells);
                }
            }
        } else {
            if proxy_type_args.len() != CLUSTER_PROXY_ID_LEN {
                return Err(Error::PaymentMethodNotSupport);
            }
        }
    }

    // co-build check @lyk
    let action::SporeActionUnion::MintAgent(mint) = extract_spore_action()?.to_enum() else {
        return Err(Error::SporeActionMismatch);
    };
    if &cluster_id != mint.cluster_id().as_slice()
        || &proxy_type.args().raw_data()[..CLUSTER_PROXY_ID_LEN] != mint.proxy_id().as_slice()
    {
        return Err(Error::SporeActionFieldMismatch);
    }
    check_spore_address(GroupOutput, mint.to())?;

    Ok(())
}

fn process_transfer() -> Result<(), Error> {
    let input_agent_data = load_cell_data(0, GroupInput)?;
    let output_agent_data = load_cell_data(0, GroupOutput)?;

    if input_agent_data != output_agent_data || input_agent_data.is_empty() {
        return Err(Error::ImmutableAgentFieldModification);
    }

    // co-build check @lyk
    let action::SporeActionUnion::TransferAgent(transfer) = extract_spore_action()?.to_enum()
    else {
        return Err(Error::SporeActionMismatch);
    };
    if &load_self_id()? != transfer.cluster_id().as_slice() {
        return Err(Error::SporeActionFieldMismatch);
    }
    check_spore_address(GroupInput, transfer.from())?;
    check_spore_address(GroupOutput, transfer.to())?;

    Ok(())
}

fn process_destruction() -> Result<(), Error> {
    // co-build check @lyk
    let action::SporeActionUnion::BurnAgent(burn) = extract_spore_action()?.to_enum() else {
        return Err(Error::SporeActionMismatch);
    };
    if &load_self_id()? != burn.cluster_id().as_slice() {
        return Err(Error::SporeActionFieldMismatch);
    }
    check_spore_address(GroupInput, burn.from())?;
    Ok(())
}

pub fn main() -> Result<(), Error> {
    let agent_in_output: Vec<Script> = QueryIter::new(load_cell_type, GroupOutput)
        .map(|script| script.unwrap_or_default())
        .collect();

    if agent_in_output.len() > 1 {
        // Conflict Creation/Multiplier
        return Err(Error::InvalidAgentOperation);
    }

    let agent_in_input: Vec<Script> = QueryIter::new(load_cell_type, GroupInput)
        .map(|script| script.unwrap_or_default())
        .collect();

    if agent_in_input.len() > 1 {
        // Multi-spend
        return Err(Error::InvalidAgentOperation);
    }

    return match (agent_in_input.len(), agent_in_output.len()) {
        (0, 1) => {
            // Creation
            let output_index =
                find_position_by_type(&agent_in_output[0], Output).unwrap_or_default(); // Once we entered here, it can't be empty, and use 0 as a fallback position
            return process_creation(output_index);
        }
        (1, 0) => process_destruction(),
        (1, 1) => process_transfer(),
        _ => unreachable!(),
    };
}


================================================
File: contracts/cluster_agent/src/main.rs
================================================
//! Generated by capsule
//!
//! `main.rs` is used to define rust lang items and modules.
//! See `entry.rs` for the `main` function.
//! See `error.rs` for the `Error` type.

#![no_std]
#![cfg_attr(not(test), no_main)]

// define modules
mod entry;
mod hash;

#[cfg(test)]
extern crate alloc;

#[cfg(not(test))]
use ckb_std::default_alloc;
#[cfg(not(test))]
ckb_std::entry!(program_entry);
#[cfg(not(test))]
default_alloc!();

/// program entry
pub fn program_entry() -> i8 {
    // Call main function and return error code
    match entry::main() {
        Ok(_) => 0,
        Err(err) => err as i8,
    }
}


================================================
File: contracts/cluster_proxy/Cargo.toml
================================================
[package]
name = "cluster_proxy"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
ckb-std = "0.14.3"
spore-utils = { path = "../../lib/utils" }
spore-types = { path = "../../lib/types" }
spore-errors = { path = "../../lib/errors" }

[build-dependencies]
ckb-hash = "0.112.1"
hex = "0.4.3"
spore-build-tools = { path = "../../lib/build" }

[features]
default = []
release_export = []


================================================
File: contracts/cluster_proxy/build.rs
================================================
use ckb_hash::blake2b_256;
use std::{env, fs};

use spore_build_tools::{concat_code_hashes, load_frozen_toml};

pub fn main() {
    let compile_mode = env::var("PROFILE").unwrap();
    let cluster_path = env::current_dir()
        .unwrap()
        .join("../../build")
        .join(&compile_mode)
        .join("cluster");
    let cluster = std::fs::read(cluster_path).expect("load cluster");
    let code_hash = blake2b_256(cluster);

    let frozen = load_frozen_toml();
    let cluster_code_hashes = [frozen.cluster_code_hashes(), vec![code_hash]].concat();

    let content = concat_code_hashes("CLUSTER_CODE_HASHES", &cluster_code_hashes);
    fs::write("./src/hash.rs", content).unwrap();
}


================================================
File: contracts/cluster_proxy/src/entry.rs
================================================
use alloc::vec::Vec;
use ckb_std::ckb_types::prelude::Entity;
use core::result::Result;

// Import from `core` instead of from `std` since we are in no-std mode
use ckb_std::ckb_constants::Source::{CellDep, GroupInput, GroupOutput, Input, Output};
use ckb_std::ckb_types::packed::Script;
use ckb_std::high_level::{
    load_cell_data, load_cell_lock_hash, load_cell_type, load_script, QueryIter,
};

use spore_errors::error::Error;
use spore_types::generated::action;
use spore_utils::{
    check_spore_address, extract_spore_action, find_position_by_lock_hash, find_position_by_type,
    find_position_by_type_args, load_self_id, verify_type_id, CLUSTER_PROXY_ID_LEN,
    CLUSTER_PROXY_ID_WITH_PAYMENT_LEN,
};

fn is_valid_cluster_cell(script_hash: &[u8; 32]) -> bool {
    crate::hash::CLUSTER_CODE_HASHES.contains(script_hash)
}

fn process_creation(index: usize) -> Result<(), Error> {
    let cluster_id = load_cell_data(0, GroupOutput)?;
    // check cluster in Deps
    let cell_dep_index =
        find_position_by_type_args(&cluster_id, CellDep, Some(is_valid_cluster_cell))
            .ok_or(Error::ClusterCellNotInDep)?;

    // verify script args format
    let args = load_script()?.args().raw_data();
    if args.len() != CLUSTER_PROXY_ID_LEN && args.len() != CLUSTER_PROXY_ID_WITH_PAYMENT_LEN {
        return Err(Error::InvalidProxyArgs);
    }

    // verify Proxy ID
    let Some(proxy_id) = verify_type_id(index) else {
        return Err(Error::InvalidProxyID);
    };

    // Condition 1: Check if cluster exist in Inputs & Outputs
    let cluster_cell_in_input =
        find_position_by_type_args(&cluster_id, Input, Some(is_valid_cluster_cell)).is_some();
    let cluster_cell_in_output =
        find_position_by_type_args(&cluster_id, Output, Some(is_valid_cluster_cell)).is_some();

    if !cluster_cell_in_input || !cluster_cell_in_output {
        // Condition 2: Check if Lock Proxy exist in Inputs & Outputs
        let cluster_lock_hash = load_cell_lock_hash(cell_dep_index, CellDep)?;
        find_position_by_lock_hash(&cluster_lock_hash, Output)
            .ok_or(Error::ClusterOwnershipVerifyFailed)?;
        find_position_by_lock_hash(&cluster_lock_hash, Input)
            .ok_or(Error::ClusterOwnershipVerifyFailed)?;
    }

    // co-build check @lyk
    let action::SporeActionUnion::MintProxy(create) = extract_spore_action()?.to_enum() else {
        return Err(Error::SporeActionMismatch);
    };
    if proxy_id != create.proxy_id().as_slice() || &cluster_id != create.cluster_id().as_slice() {
        return Err(Error::SporeActionFieldMismatch);
    }
    check_spore_address(GroupOutput, create.to())?;

    Ok(())
}

fn process_transfer() -> Result<(), Error> {
    let input_data = load_cell_data(0, GroupInput)?;
    let output_data = load_cell_data(0, GroupOutput)?;

    if input_data != output_data {
        return Err(Error::ImmutableProxyFieldModification);
    }

    // co-build check @lyk
    let action::SporeActionUnion::TransferProxy(transfer) = extract_spore_action()?.to_enum()
    else {
        return Err(Error::SporeActionMismatch);
    };
    if input_data.as_slice() != transfer.cluster_id().as_slice()
        || &load_self_id()? != transfer.proxy_id().as_slice()
    {
        return Err(Error::SporeActionFieldMismatch);
    }
    check_spore_address(GroupInput, transfer.from())?;
    check_spore_address(GroupOutput, transfer.to())?;

    Ok(())
}

fn process_destruction() -> Result<(), Error> {
    let cluster_id = load_cell_data(0, GroupInput)?;
    let proxy_id = load_self_id()?;

    // co-build check @lyk
    let action::SporeActionUnion::BurnProxy(burn) = extract_spore_action()?.to_enum() else {
        return Err(Error::SporeActionMismatch);
    };
    if cluster_id.as_slice() != burn.cluster_id().as_slice()
        || &proxy_id != burn.proxy_id().as_slice()
    {
        return Err(Error::SporeActionFieldMismatch);
    }
    check_spore_address(GroupInput, burn.from())?;
    Ok(())
}

pub fn main() -> Result<(), Error> {
    let proxy_in_output: Vec<Script> = QueryIter::new(load_cell_type, GroupOutput)
        .map(|script| script.unwrap_or_default())
        .collect();

    if proxy_in_output.len() > 1 {
        // Conflict Creation/Multiplier
        return Err(Error::InvalidProxyOperation);
    }

    let proxy_in_input: Vec<Script> = QueryIter::new(load_cell_type, GroupInput)
        .map(|script| script.unwrap_or_default())
        .collect();

    if proxy_in_input.len() > 1 {
        // Multi-spend
        return Err(Error::InvalidProxyOperation);
    }

    return match (proxy_in_input.len(), proxy_in_output.len()) {
        (0, 1) => {
            // Creation
            let output_index =
                find_position_by_type(&proxy_in_output[0], Output).unwrap_or_default(); // Once we entered here, it can't be empty, and use 0 as a fallback position
            return process_creation(output_index);
        }
        (1, 0) => process_destruction(),
        (1, 1) => process_transfer(),
        _ => unreachable!(),
    };
}


================================================
File: contracts/cluster_proxy/src/main.rs
================================================
//! Generated by capsule
//!
//! `main.rs` is used to define rust lang items and modules.
//! See `entry.rs` for the `main` function.
//! See `error.rs` for the `Error` type.

#![no_std]
#![cfg_attr(not(test), no_main)]

// define modules
mod entry;
mod hash;

#[cfg(test)]
extern crate alloc;

#[cfg(not(test))]
use ckb_std::default_alloc;
#[cfg(not(test))]
ckb_std::entry!(program_entry);
#[cfg(not(test))]
default_alloc!();

/// program entry
pub fn program_entry() -> i8 {
    // Call main function and return error code
    match entry::main() {
        Ok(_) => 0,
        Err(err) => err as i8,
    }
}


================================================
File: contracts/spore/Cargo.toml
================================================
[package]
name = "spore"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
ckb-std = "0.14.3"
molecule = { version = "0.7.5", default-features = false }
spore-types = { path = "../../lib/types" }
spore-utils = { path = "../../lib/utils" }
spore-errors = { path = "../../lib/errors" }
kmp = { version = "0.1.1" }
ckb-transaction-cobuild = { git = "https://github.com/cryptape/ckb-transaction-cobuild-poc", rev = "bdb0c74" }

[build-dependencies]
ckb-hash = "0.112.1"
hex = "0.4.3"
spore-build-tools = { path = "../../lib/build" }

[features]
default = []
release_export = []


================================================
File: contracts/spore/build.rs
================================================
use ckb_hash::blake2b_256;
use std::{env, fs};

use spore_build_tools::{concat_code_hashes, load_frozen_toml};

fn load_code_hash(binary_name: &str, compile_mode: &str) -> [u8; 32] {
    let binary_path = env::current_dir()
        .unwrap()
        .join("../../build")
        .join(compile_mode)
        .join(binary_name);
    let binary = std::fs::read(binary_path).expect("load cluster");
    blake2b_256(binary)
}

pub fn main() {
    let compile_mode = env::var("PROFILE").unwrap();
    let cluster_code_hash = load_code_hash("cluster", &compile_mode);
    let cluster_agent_code_hash = load_code_hash("cluster_agent", &compile_mode);
    let mutant_code_hash = load_code_hash("spore_extension_lua", &compile_mode);

    let frozen = load_frozen_toml();
    let cluster_code_hashes = [frozen.cluster_code_hashes(), vec![cluster_code_hash]].concat();
    let cluster_agent_code_hashes = [
        frozen.cluster_agent_code_hashes(),
        vec![cluster_agent_code_hash],
    ]
    .concat();
    let mutant_code_hashes = [frozen.mutant_code_hashes(), vec![mutant_code_hash]].concat();

    let mut content = concat_code_hashes("CLUSTER_CODE_HASHES", &cluster_code_hashes);
    content += concat_code_hashes("CLUSTER_AGENT_CODE_HASHES", &cluster_agent_code_hashes).as_str();
    content += concat_code_hashes("MUTANT_CODE_HASHES", &mutant_code_hashes).as_str();
    fs::write("./src/hash.rs", content).unwrap();
}


================================================
File: contracts/spore/src/entry.rs
================================================
use alloc::collections::BTreeMap;
use alloc::{format, vec, vec::Vec};
use ckb_std::ckb_types::util::hash::blake2b_256;
use core::ffi::CStr;
use core::result::Result;

use ckb_std::ckb_constants::Source::{CellDep, GroupInput, GroupOutput, Input, Output};
use ckb_std::ckb_types::core::ScriptHashType;
use ckb_std::ckb_types::packed::Script;
use ckb_std::high_level::{load_cell_lock_hash, load_script};
use ckb_std::{
    ckb_constants::Source,
    ckb_types::prelude::*,
    debug,
    high_level::{load_cell_data, load_cell_type, QueryIter},
};

use spore_errors::error::Error;
use spore_types::generated::action;
use spore_types::generated::spore::SporeData;
use spore_utils::{
    calc_capacity_sum, check_spore_address, compatible_load_cluster_data, extract_spore_action,
    find_position_by_lock_hash, find_position_by_type, find_position_by_type_args, load_self_id,
    verify_type_id, MIME, MUTANT_ID_LEN, MUTANT_ID_WITH_PAYMENT_LEN,
};

use crate::hash::{CLUSTER_AGENT_CODE_HASHES, CLUSTER_CODE_HASHES};

enum Operation {
    Mint,
    Transfer,
    Burn,
}

fn check_cluster_code_hash(code_hash: &[u8; 32]) -> bool {
    CLUSTER_CODE_HASHES.contains(code_hash)
}

fn check_agent_code_hash(code_hash: &[u8; 32]) -> bool {
    CLUSTER_AGENT_CODE_HASHES.contains(code_hash)
}

fn load_spore_data(index: usize, source: Source) -> Result<SporeData, Error> {
    let raw_data = load_cell_data(index, source)?;
    let spore_data = SporeData::from_compatible_slice(raw_data.as_slice())
        .map_err(|_| Error::InvalidSporeData)?;
    Ok(spore_data)
}

fn process_creation(index: usize) -> Result<(), Error> {
    let spore_data = load_spore_data(index, Output)?;

    if spore_data.content().is_empty() {
        return Err(Error::EmptyContent);
    }

    let content = spore_data.content();
    let content_arr = content.as_slice();

    if spore_data.content_type().is_empty() {
        return Err(Error::InvalidContentType);
    }

    // verify Spore ID
    let Some(spore_id) = verify_type_id(index) else {
        return Err(Error::InvalidSporeID);
    };

    // content_type validation
    let content_type = spore_data.content_type().raw_data();
    let mime = MIME::parse(&content_type)?;
    verify_extension(&mime, Operation::Mint, vec![index as u8])?;

    // Spore supports [MIME-multipart](https://datatracker.ietf.org/doc/html/rfc1521#section-7.2).
    //
    // The Multipart Content-Type is used to represent a document that is comprised of multiple
    // parts, each of which may have its own individual MIME type
    if content_type[mime.main_type.clone()] == "multipart".as_bytes()[..] {
        // Check if boundary param exists
        // The Content-Type field for multipart entities requires one parameter, "boundary", which
        // is used to specify the encapsulation boundary. See Appendix C of rfc1521 for a complex
        // multipart example.
        debug!("check mime multipart specification");
        let boundary_range = mime
            .get_param(&content_type, "boundary")?
            .ok_or(Error::InvalidContentType)?;
        kmp::kmp_find(
            format!(
                "--{}",
                alloc::str::from_utf8(&content_type[boundary_range])
                    .or(Err(Error::BoundaryEncoding))?
            )
            .as_bytes(),
            content_arr,
        )
        .ok_or(Error::InvalidMultipartContent)?;
    }

    // check in Cluster mode
    if let Some(cluster_id) = spore_data.cluster_id().to_opt() {
        debug!("check in cluster mode");
        // check if cluster cell is in deps
        let cluster_id = cluster_id.raw_data();
        let cell_dep_index =
            find_position_by_type_args(&cluster_id, CellDep, Some(check_cluster_code_hash))
                .ok_or(Error::ClusterCellNotInDep)?;

        // the cluster contract guarantees the cluster data will always be correct once created
        let raw_cluster_data = load_cell_data(cell_dep_index, CellDep)?;
        let cluster_data = compatible_load_cluster_data(&raw_cluster_data)?;

        // check in Mutant mode
        if let Some(mutant_id) = cluster_data.mutant_id().to_opt() {
            let mutant_verify_passed = mime
                .mutants
                .iter()
                .any(|mutant| mutant == mutant_id.raw_data().as_ref());
            if !mutant_verify_passed {
                // required mutant does not applied
                return Err(Error::ClusterRequiresMutantApplied);
            }
        }

        // Condition 1: Check if cluster exists in Inputs & Outputs
        let cluster_cell_in_input =
            find_position_by_type_args(&cluster_id, Input, Some(check_cluster_code_hash)).is_some();
        let cluster_cell_in_output =
            find_position_by_type_args(&cluster_id, Output, Some(check_cluster_code_hash))
                .is_some();

        // Condition 2: Check if cluster agent exists in Inputs & Outputs
        let agent_cell_in_input =
            find_position_by_type_args(&cluster_id, Input, Some(check_agent_code_hash)).is_some();
        let agent_cell_in_output =
            find_position_by_type_args(&cluster_id, Output, Some(check_agent_code_hash)).is_some();

        if (!cluster_cell_in_input || !cluster_cell_in_output)
            && (!agent_cell_in_input || !agent_cell_in_output)
        {
            // Condition 3: Use cluster agent in Lock Proxy mode
            if let Some(agent_index) =
                find_position_by_type_args(&cluster_id, CellDep, Some(check_agent_code_hash))
            {
                debug!("check in agent mode");
                let agent_lock_hash = load_cell_lock_hash(agent_index, CellDep)?;
                find_position_by_lock_hash(&agent_lock_hash, Output)
                    .ok_or(Error::ClusterOwnershipVerifyFailed)?;
                find_position_by_lock_hash(&agent_lock_hash, Input)
                    .ok_or(Error::ClusterOwnershipVerifyFailed)?;
            } else {
                debug!("check in lock proxy mode");
                // Condition 4: Check if Lock Proxy exist in Inputs & Outputs
                let cluster_lock_hash = load_cell_lock_hash(cell_dep_index, CellDep)?;
                find_position_by_lock_hash(&cluster_lock_hash, Output)
                    .ok_or(Error::ClusterOwnershipVerifyFailed)?;
                find_position_by_lock_hash(&cluster_lock_hash, Input)
                    .ok_or(Error::ClusterOwnershipVerifyFailed)?;
            }
        }
    }

    // check co-build action @lyk
    let action::SporeActionUnion::MintSpore(mint) = extract_spore_action()?.to_enum() else {
        return Err(Error::SporeActionMismatch);
    };
    if mint.spore_id().as_slice() != spore_id
        || mint.data_hash().as_slice() != blake2b_256(spore_data.as_slice())
    {
        return Err(Error::SporeActionFieldMismatch);
    }
    check_spore_address(GroupOutput, mint.to())?;

    Ok(())
}

fn process_destruction() -> Result<(), Error> {
    let spore_data = load_spore_data(0, GroupInput)?;
    let content_type = spore_data.content_type().raw_data();

    let mime = MIME::parse(&content_type)?;
    if mime.immortal {
        // true destroy a immortal nft
        return Err(Error::DestroyImmortalNFT);
    }

    if !mime.mutants.is_empty() {
        let spore_type = load_script()?;
        let index = find_position_by_type(&spore_type, Input).ok_or(Error::IndexOutOfBound)?;
        verify_extension(&mime, Operation::Burn, vec![index as u8])?;
    }

    // check co-build action @lyk
    let action::SporeActionUnion::BurnSpore(burn) = extract_spore_action()?.to_enum() else {
        return Err(Error::SporeActionMismatch);
    };
    if burn.spore_id().as_slice() != &load_self_id()? {
        return Err(Error::SporeActionFieldMismatch);
    }
    check_spore_address(GroupInput, burn.from())?;

    Ok(())
}

fn process_transfer() -> Result<(), Error> {
    // found same NFT in output, this is a transfer, check no field was modified
    let input_data = load_spore_data(0, GroupInput)?;
    let output_data = load_spore_data(0, GroupOutput)?;

    if input_data.as_slice()[..] != output_data.as_slice()[..] {
        return Err(Error::ModifySporePermanentField);
    }

    let content_type = input_data.content_type().raw_data();
    let mime = MIME::parse(&content_type)?;

    if !mime.mutants.is_empty() {
        let spore_type = load_script()?;
        let input_index =
            find_position_by_type(&spore_type, Input).ok_or(Error::IndexOutOfBound)?;
        let output_index =
            find_position_by_type(&spore_type, Output).ok_or(Error::IndexOutOfBound)?;
        verify_extension(
            &mime,
            Operation::Transfer,
            vec![input_index as u8, output_index as u8],
        )?;
    }

    // check co-build action @lyk
    let action::SporeActionUnion::TransferSpore(transfer) = extract_spore_action()?.to_enum()
    else {
        return Err(Error::SporeActionMismatch);
    };
    if transfer.spore_id().as_slice() != &load_self_id()? {
        return Err(Error::SporeActionFieldMismatch);
    }
    check_spore_address(GroupInput, transfer.from())?;
    check_spore_address(GroupOutput, transfer.to())?;

    Ok(())
}

fn verify_extension(mime: &MIME, op: Operation, argv: Vec<u8>) -> Result<(), Error> {
    let mut payment_map: BTreeMap<[u8; 32], u64> = BTreeMap::new();
    let mut extension_hash = [0u8; 32];
    for mutant_id in mime.mutants.iter() {
        let mutant_index =
            QueryIter::new(load_cell_type, CellDep).position(|script| match script {
                Some(script) => {
                    extension_hash = script.code_hash().unpack();
                    if crate::hash::MUTANT_CODE_HASHES.contains(&extension_hash) {
                        return mutant_id[..] == script.args().raw_data()[..32];
                    }
                    false
                }
                None => false,
            });
        match mutant_index {
            None => return Err(Error::ExtensionCellNotInDep),
            Some(mutant_index) => {
                // mint spore should pay if payment set
                if let Operation::Mint = op {
                    check_payment(mutant_index, &mut payment_map)?;
                }

                debug!("run mutant_id({mutant_index}): {mutant_id:?} <= {extension_hash:?}");
                match op {
                    Operation::Mint => {
                        ckb_std::high_level::exec_cell(
                            &extension_hash,
                            ScriptHashType::Data1,
                            &[
                                CStr::from_bytes_with_nul([b'0', 0].as_slice()).unwrap_or_default(),
                                CStr::from_bytes_with_nul([b'0' + mutant_index as u8, 0].as_slice(),) .unwrap_or_default(),
                                CStr::from_bytes_with_nul([b'0' + argv[0], 0].as_slice()) .unwrap_or_default(),
                            ],
                        )?;
                    }
                    Operation::Transfer => {
                        ckb_std::high_level::exec_cell(
                            &extension_hash,
                            ScriptHashType::Data1,
                            &[
                                CStr::from_bytes_with_nul([b'1', 0].as_slice()).unwrap_or_default(),
                                CStr::from_bytes_with_nul([b'0' + mutant_index as u8, 0].as_slice(),) .unwrap_or_default(),
                                CStr::from_bytes_with_nul([b'0' + argv[0], 0].as_slice()) .unwrap_or_default(),
                                CStr::from_bytes_with_nul([b'0' + argv[1], 0].as_slice()) .unwrap_or_default(),
                            ],
                        )?;
                    }
                    Operation::Burn => {
                        ckb_std::high_level::exec_cell(
                            &extension_hash,
                            ScriptHashType::Data1,
                            &[
                                CStr::from_bytes_with_nul([b'2', 0].as_slice()).unwrap_or_default(),
                                CStr::from_bytes_with_nul([b'0' + mutant_index as u8, 0].as_slice(),) .unwrap_or_default(),
                                CStr::from_bytes_with_nul([b'0' + argv[0], 0].as_slice()) .unwrap_or_default(),
                            ],
                        )?;
                    }
                }
            }
        }
    }
    Ok(())
}

fn check_payment(
    mutant_index: usize,
    payment_map: &mut BTreeMap<[u8; 32], u64>,
) -> Result<(), Error> {
    let mutant_type = load_cell_type(mutant_index, CellDep)?.unwrap_or_default();
    let args = mutant_type.args().raw_data();
    // CAUTION: only check bytes in [32, 40) pattern, leave room for user customization
    if args.len() > MUTANT_ID_LEN {
        if args.len() < MUTANT_ID_WITH_PAYMENT_LEN {
            return Err(Error::InvalidExtensionPaymentFormat);
        }
        let mutant_lock_hash = load_cell_lock_hash(mutant_index, CellDep)?;
        let input_capacity = calc_capacity_sum(&mutant_lock_hash, Input);
        let output_capacity = calc_capacity_sum(&mutant_lock_hash, Output);
        let minimal_payment = {
            let range = MUTANT_ID_LEN..MUTANT_ID_WITH_PAYMENT_LEN;
            let threshold = u64::from_le_bytes(args[range].try_into().unwrap_or_default());
            let payment_threshold = payment_map.entry(mutant_lock_hash).or_default();
            *payment_threshold += threshold;
            *payment_threshold
        };
        if input_capacity + minimal_payment > output_capacity {
            return Err(Error::ExtensionPaymentNotEnough);
        }
    }
    Ok(())
}

pub fn main() -> Result<(), Error> {
    let spore_in_output: Vec<Script> = QueryIter::new(load_cell_type, GroupOutput)
        .map(|script| script.unwrap_or_default())
        .collect();

    if spore_in_output.len() > 1 {
        return Err(Error::ConflictCreation);
    }

    let spore_in_input: Vec<Script> = QueryIter::new(load_cell_type, GroupInput)
        .map(|script| script.unwrap_or_default())
        .collect();

    if spore_in_input.len() > 1 {
        return Err(Error::MultipleSpend);
    }

    match (spore_in_input.len(), spore_in_output.len()) {
        (0, 1) => {
            // find it's index in Output
            let output_index =
                find_position_by_type(&spore_in_output[0], Output).ok_or(Error::IndexOutOfBound)?;
            return process_creation(output_index);
        }
        (1, 0) => {
            return process_destruction();
        }
        (1, 1) => {
            return process_transfer();
        }
        _ => unreachable!(),
    }
}


================================================
File: contracts/spore/src/main.rs
================================================
//! Generated by capsule
//!
//! `main.rs` is used to define rust lang items and modules.
//! See `entry.rs` for the `main` function.
//! See `error.rs` for the `Error` type.

#![no_std]
#![cfg_attr(not(test), no_main)]

// define modules
mod entry;
mod hash;

#[cfg(test)]
extern crate alloc;

#[cfg(not(test))]
use ckb_std::default_alloc;
#[cfg(not(test))]
ckb_std::entry!(program_entry);
#[cfg(not(test))]
default_alloc!(6 * 1024, 3000 * 1024, 64);

/// program entry
pub fn program_entry() -> i8 {
    // Call main function and return error code
    match entry::main() {
        Ok(_) => 0,
        Err(err) => err as i8,
    }
}


================================================
File: contracts/spore_extension_lua/Cargo.toml
================================================
[package]
name = "spore_extension_lua"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
ckb-std = "0.14.3"
spore-utils = { path = "../../lib/utils" }
spore-errors = { path = "../../lib/errors" }

[build-dependencies]
ckb-hash = "0.112.1"

[features]
default = []
release_export = []


================================================
File: contracts/spore_extension_lua/build.rs
================================================
use ckb_hash::blake2b_256;
use std::{env, fs};

pub fn main() {
    let compile_mode = env::var("PROFILE").unwrap();
    let libckblua_path = env::current_dir().unwrap().join("lua/libckblua.so");
    let libckblua = std::fs::read(libckblua_path).expect("load libckblua.so");
    let code_hash = blake2b_256(&libckblua);
    let file = format!("pub const CKB_LUA_LIB_CODE_HASH: [u8; 32] = {code_hash:?};\n");
    fs::write("./src/hash.rs", file).unwrap();

    let build_path = env::current_dir()
        .unwrap()
        .join("../../build")
        .join(compile_mode);
    fs::create_dir_all(&build_path).unwrap();
    fs::write(build_path.join("libckblua.so"), libckblua)
        .expect("copy libckblua.so for capsule test");
}


================================================
File: contracts/spore_extension_lua/lua/README.md
================================================
steps for the generation of `libckblua.so`:
```bash
$ git clone https://github.com/nervosnetwork/ckb-lua-vm
$ cd ckb-lua-vm
$ make build/libckblua.so
```


================================================
File: contracts/spore_extension_lua/src/entry.rs
================================================
// Import from `core` instead of from `std` since we are in no-std mode
use core::result::Result;

use alloc::borrow::ToOwned;
// Import heap related library from `alloc`
// https://doc.rust-lang.org/alloc/index.html
use alloc::ffi::CString;
use alloc::string::String;
use alloc::{format, vec, vec::Vec};

// Import CKB syscalls and structures
// https://docs.rs/ckb-std/
use ckb_std::ckb_constants::Source::{CellDep, GroupInput, GroupOutput, Output};
use ckb_std::ckb_types::packed::Script;
use ckb_std::debug;
use ckb_std::dynamic_loading_c_impl::{CKBDLContext, Library, Symbol};
use ckb_std::env::Arg;
use ckb_std::high_level::{load_cell_data, load_cell_type, QueryIter};
use core::ffi::{c_char, c_int, c_ulong, c_void};
use spore_errors::error::Error;
use spore_utils::{find_position_by_type, verify_type_id};

use crate::error::WrappedError;
use crate::hash::CKB_LUA_LIB_CODE_HASH;

type CreateLuaInstanceType = unsafe extern "C" fn(c_ulong, c_ulong) -> *mut c_void;
type EvaluateLuaInstanceType = unsafe extern "C" fn(
    instance: *mut c_void,
    code: *const c_char,
    code_size: usize,
    name: *const c_char,
) -> c_int;

const SPORE_EXT_NORMAL_ARG_LEN: usize = 32;
const SPORE_EXT_MINIMAL_PAYMENT_ARG_LEN: usize = 32 + 8; // 32 bytes hash + u64 payment

struct CKBLuaLib {
    lib: Library,
}

impl CKBLuaLib {
    pub fn new() -> Result<Self, Error> {
        debug!("prepare lua lib");
        let mut context = unsafe { CKBDLContext::<[u8; 270 * 1024]>::new() };
        #[allow(deprecated)]
        let lib = context
            .load(&CKB_LUA_LIB_CODE_HASH)
            .map_err(|_| Error::FailedToLoadLuaLib)?;
        Ok(Self { lib })
    }

    pub fn evaluate_lua_script(
        &self,
        index: usize,
        prefix_code: Option<String>,
    ) -> Result<(), WrappedError> {
        let mut code_base = load_cell_data(index, Output)?;
        if let Some(prefix_code) = prefix_code {
            let mut prefix_code = prefix_code.as_bytes().to_vec();
            prefix_code.append(&mut code_base);
            code_base = prefix_code;
        }
        self.execute_lua_script(&code_base)?;
        Ok(())
    }

    fn create_lua_instance(&self) -> Result<*mut c_void, Error> {
        match unsafe { self.lib.get(b"lua_create_instance") } {
            Some(create_lua_instance) => {
                let mut lua_mem = vec![0u8; 500 * 1024];
                unsafe {
                    let instance = (create_lua_instance as Symbol<CreateLuaInstanceType>)(
                        lua_mem.as_mut_ptr() as c_ulong,
                        lua_mem.as_mut_ptr().offset(500 * 1024) as c_ulong,
                    );
                    if instance.is_null() {
                        return Err(Error::FailedToCreateLuaInstance);
                    }
                    Ok(instance)
                }
            }
            None => {
                // not a valid lua lib, maybe error deployment
                Err(Error::InvalidLuaLib)
            }
        }
    }

    pub fn execute_lua_script(&self, code: &Vec<u8>) -> Result<(), WrappedError> {
        let instance = self.create_lua_instance()?;
        let ret = match unsafe { self.lib.get(b"lua_run_code") } {
            Some(lua_run_code) => {
                let size = code.len().clone();
                let ret = unsafe {
                    (lua_run_code as Symbol<EvaluateLuaInstanceType>)(
                        instance,
                        code.as_ptr() as *const i8,
                        size,
                        CString::new("SporeExtension").unwrap_or_default().as_ptr(),
                    )
                };
                Ok(ret as i8)
            }
            None => Err(Error::InvalidLuaLib),
        }?;

        if ret == 0 {
            return Ok(());
        }
        // we recommend the error code follows this pattern: -127 <= ret <= -1 or 100 <= ret <= 127
        else if 0 < ret && ret < Error::Unknown as i8 {
            return Err(Error::InvalidLuaScript.into());
        } else {
            return Err(WrappedError::LuaError(ret));
        }
    }
}

fn process_creation(index: usize) -> Result<(), WrappedError> {
    if verify_type_id(index).is_none() {
        return Err(Error::InvalidExtensionID.into());
    }
    let args = load_cell_type(index, Output)?
        .unwrap_or_default()
        .args()
        .raw_data();
    match args.len() {
        SPORE_EXT_NORMAL_ARG_LEN | SPORE_EXT_MINIMAL_PAYMENT_ARG_LEN => {}
        _ => {
            return Err(Error::InvalidExtensionArg.into());
        }
    }
    let lua_lib = CKBLuaLib::new()?;

    let prefix_code = "local spore_ext_mode = 0\n".to_owned();
    lua_lib.evaluate_lua_script(index, Some(prefix_code))?;
    Ok(())
}

fn process_transfer() -> Result<(), WrappedError> {
    let input_data = load_cell_data(0, GroupInput)?;
    let output_data = load_cell_data(0, GroupOutput)?;

    if input_data != output_data {
        return Err(Error::ModifyExtensionPermanentField.into());
    }

    Ok(())
}

fn execute_code_create(extension_index: usize, target_index: usize) -> Result<(), WrappedError> {
    let mut code_base =
        format!("local spore_ext_mode = 1\nlocal spore_output_index = {target_index}\n")
            .as_bytes()
            .to_vec();
    let mut ext_code = load_cell_data(extension_index, CellDep)?;
    code_base.append(&mut ext_code);
    let lua_lib = CKBLuaLib::new()?;
    lua_lib.execute_lua_script(&code_base)
}

fn execute_code_transfer(
    extension_index: usize,
    input_index: usize,
    output_index: usize,
) -> Result<(), WrappedError> {
    let mut code_base = format!(
        "local spore_ext_mode = 2\nlocal spore_input_index = {input_index}\nlocal spore_output_index = {output_index}\n"
    )
    .as_bytes()
    .to_vec();
    let mut ext_code = load_cell_data(extension_index, CellDep)?;
    code_base.append(&mut ext_code);
    let lua_lib = CKBLuaLib::new()?;
    lua_lib.execute_lua_script(&code_base)
}

fn execute_code_destroy(extension_index: usize, input_index: usize) -> Result<(), WrappedError> {
    let mut code_base =
        format!("local spore_ext_mode = 3\nlocal spore_input_index = {input_index}\n")
            .as_bytes()
            .to_vec();
    let mut ext_code = load_cell_data(extension_index, CellDep)?;
    code_base.append(&mut ext_code);
    let lua_lib = CKBLuaLib::new()?;
    lua_lib.execute_lua_script(&code_base)
}

pub fn main(argv: &[Arg]) -> Result<(), WrappedError> {
    if argv.is_empty() {
        debug!("running internally");
        // creation/transfer mode
        let extension_in_output: Vec<Script> = QueryIter::new(load_cell_type, GroupOutput)
            .map(|script| script.unwrap_or_default())
            .collect();

        if extension_in_output.len() > 1 {
            return Err(Error::ConflictCreation.into());
        }

        let extension_in_input: Vec<Script> = QueryIter::new(load_cell_type, GroupInput)
            .map(|script| script.unwrap_or_default())
            .collect();

        if extension_in_input.len() > 1 {
            return Err(Error::MultipleSpend.into());
        }

        return match (extension_in_input.len(), extension_in_output.len()) {
            (0, 1) => {
                // find it's index in Source::Output
                let output_index =
                    find_position_by_type(&extension_in_output[0], Output).unwrap_or_default(); // Once we entered here, it can't be empty, and use 0 as a fallback position
                process_creation(output_index)
            }
            (1, 1) => {
                return process_transfer();
            }
            _ => Err(Error::InvalidExtensionOperation.into()), // Can not destroy a extension cell(for safety)
        };
    } else {
        // execution mode
        debug!("running externally");
        match argv[0].to_bytes() {
            &[48] => {
                // 0, CREATE SPORE
                debug!("Spore Creation with extension!");
                let spore_extension_index = argv[1]
                    .to_string_lossy()
                    .parse::<usize>()
                    .map_err(|_| Error::InvalidLuaParameters)?;
                let target_index = argv[2]
                    .to_string_lossy()
                    .parse::<usize>()
                    .map_err(|_| Error::InvalidLuaParameters)?;
                execute_code_create(spore_extension_index, target_index)?;
            }
            &[49] => {
                // 1, TRANSFER SPORE
                debug!("Spore Transfer with extension!");
                let spore_extension_index = argv[1]
                    .to_string_lossy()
                    .parse::<usize>()
                    .map_err(|_| Error::InvalidLuaParameters)?;
                let input_index = argv[2]
                    .to_string_lossy()
                    .parse::<usize>()
                    .map_err(|_| Error::InvalidLuaParameters)?;
                let output_index = argv[3]
                    .to_string_lossy()
                    .parse::<usize>()
                    .map_err(|_| Error::InvalidLuaParameters)?;
                execute_code_transfer(spore_extension_index, input_index, output_index)?;
            }
            &[50] => {
                // 2, DESTROY SPORE
                debug!("Spore Destroy with extension!");
                let spore_extension_index = argv[1]
                    .to_string_lossy()
                    .parse::<usize>()
                    .map_err(|_| Error::InvalidLuaParameters)?;
                let input_index = argv[2]
                    .to_string_lossy()
                    .parse::<usize>()
                    .map_err(|_| Error::InvalidLuaParameters)?;
                execute_code_destroy(spore_extension_index, input_index)?;
            }
            _ => return Err(Error::InvalidExtensionOperation.into()),
        }
        Ok(())
    }
}


================================================
File: contracts/spore_extension_lua/src/error.rs
================================================
use ckb_std::syscalls::SysError;
use spore_errors::error::Error;

pub enum WrappedError {
    SystemError(Error),
    LuaError(i8),
}

impl From<WrappedError> for i8 {
    fn from(value: WrappedError) -> Self {
        match value {
            WrappedError::SystemError(error) => error as i8,
            WrappedError::LuaError(error) => error,
        }
    }
}

impl From<Error> for WrappedError {
    fn from(value: Error) -> Self {
        Self::SystemError(value)
    }
}

impl From<SysError> for WrappedError {
    fn from(value: SysError) -> Self {
        Self::SystemError(value.into())
    }
}


================================================
File: contracts/spore_extension_lua/src/main.rs
================================================
//! Generated by capsule
//!
//! `main.rs` is used to define rust lang items and modules.
//! See `entry.rs` for the `main` function.
//! See `error.rs` for the `Error` type.

#![no_std]
#![cfg_attr(not(test), no_main)]

// define modules
mod entry;
mod error;
mod hash;

#[cfg(test)]
extern crate alloc;

#[cfg(not(test))]
use ckb_std::default_alloc;
#[cfg(not(test))]
ckb_std::entry!(program_entry);
#[cfg(not(test))]
default_alloc!(6 * 1024, 800 * 1024, 64);

/// program entry
pub fn program_entry() -> i8 {
    // Call main function and return error code
    ckb_std::debug!("into spore lua");
    match entry::main(ckb_std::env::argv()) {
        Ok(_) => 0,
        Err(err) => err.into(),
    }
}


================================================
File: deployment/README.md
================================================
# Deployment

usage:
```bash
$ capsule build --release # build for testnet
$ capsule build --release -- --features release_export # build for mainnet
$ cd deployment
$ ./deploy.sh <contract-name> <ckb-url> <ckb-address>
```

for example:
```bash
$ ./deploy.sh spore https://testnet.ckbapp.dev/ ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsq28phxutezqvjgfv5q38gn5kwek4m9km3cmajeqs
```

before deployment, please make sure your `<ckb-address>` matches `args` setting in deployment toml [files](https://github.com/sporeprotocol/spore-contract/tree/master/deployment/toml).

taking [cluster_agent](https://github.com/sporeprotocol/spore-contract/blob/master/deployment/toml/cluster_agent.toml) for example:
```toml
[[cells]]
name = "cluster_agent"
enable_type_id = true
location = { file = "../build/release/cluster_agent" }

[lock]
code_hash = "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8"
args = <your-wallet-lock-args>
hash_type = "type"
```

notice: `frozen` versions are always containing all of deployed contracts except the latest one


================================================
File: deployment/deploy.sh
================================================
#!/usr/bin/env bash

export network=$4

if [ -z $network ]
then
    export network="testnet"
fi

echo "deploying $1 from $3 to $2 on $network"

ckb-cli --url $2 deploy gen-txs --from-address $3 --fee-rate 1000 --deployment-config ./toml/$network/$1.toml \
    --info-file ./$1.json --migration-dir ./migration/$network/$1 --sign-now

echo "ckb transacion file '$1.json' has generated"

ckb-cli --url $2 deploy apply-txs --info-file ./$1.json --migration-dir ./migration/$network/$1

rm ./$1.json

echo "deployment finished"

# usage: ./deploy.sh spore https://testnet.ckbapp.dev/ ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsq28phxutezqvjgfv5q38gn5kwek4m9km3cmajeqs


================================================
File: deployment/frozen/mainnet.toml
================================================
[[code_hash_list]]


================================================
File: deployment/frozen/testnet.toml
================================================
# version v0.1.0
[[code_hash_list]]
cluster = "598d793defef36e2eeba54a9b45130e4ca92822e1d193671f490950c3b856080"
spore = "bbad126377d45f90a8ee120da988a2d7332c78ba8fd679aab478a19d6c133494"

# version v0.2.1
[[code_hash_list]]
cluster = "7366a61534fa7c7e6225ecc0d828ea3b5366adec2b58206f2ee84995fe030075"
spore = "5e063b4c0e7abeaa6a428df3b693521a3050934cf3b0ae97a800d1bc31449398"
cluster_agent = "c986099b41d79ca1b2a56ce5874bcda8175440a17298ea5e2bbc3897736b8c21"
cluster_proxy = "be8b9ce3d05a32c4bb26fe71cd5fc1407ce91e3a8b9e8719be2ab072cef1454b"


================================================
File: deployment/migration/mainnet/cluster/2024-01-23-0.2.2-beta.1.json
================================================
{
  "cell_recipes": [
    {
      "name": "cluster",
      "tx_hash": "0xe464b7fb9311c5e2820e61c99afc615d6b98bdefbe318c34868c010cbd0dc938",
      "index": 0,
      "occupied_capacity": 4690900000000,
      "data_hash": "0x7366a61534fa7c7e6225ecc0d828ea3b5366adec2b58206f2ee84995fe030075",
      "type_id": null
    }
  ],
  "dep_group_recipes": []
}

================================================
File: deployment/migration/mainnet/spore/2024-01-25-0.2.2-beta.1.json
================================================
{
  "cell_recipes": [
    {
      "name": "spore",
      "tx_hash": "0x96b198fb5ddbd1eed57ed667068f1f1e55d07907b4c0dbd38675a69ea1b69824",
      "index": 0,
      "occupied_capacity": 7681300000000,
      "data_hash": "0x4a4dce1df3dffff7f8b2cd7dff7303df3b6150c9788cb75dcf6747247132b9f5",
      "type_id": null
    }
  ],
  "dep_group_recipes": []
}

================================================
File: deployment/migration/testnet/cluster/2024-01-19-0.2.1.json
================================================
{
  "cell_recipes": [
    {
      "name": "cluster",
      "tx_hash": "0xfbceb70b2e683ef3a97865bb88e082e3e5366ee195a9c826e3c07d1026792fcd",
      "index": 0,
      "occupied_capacity": 4697400000000,
      "data_hash": "0x7366a61534fa7c7e6225ecc0d828ea3b5366adec2b58206f2ee84995fe030075",
      "type_id": "0x95cb51b763d4a73ac695f05fefdf3bcbe189cc6e0e71497360d2df45915c53c5"
    }
  ],
  "dep_group_recipes": []
}

================================================
File: deployment/migration/testnet/cluster/2024-03-16-0.2.2-beta.2.json
================================================
{
  "cell_recipes": [
    {
      "name": "cluster",
      "tx_hash": "0xcebb174d6e300e26074aea2f5dbd7f694bb4fe3de52b6dfe205e54f90164510a",
      "index": 0,
      "occupied_capacity": 4665400000000,
      "data_hash": "0x0bbe768b519d8ea7b96d58f1182eb7e6ef96c541fbd9526975077ee09f049058",
      "type_id": "0xc11dd38a124e544722bb6f473cb1224022f39919960dbddc364fc0e71ace3c5e"
    }
  ],
  "dep_group_recipes": []
}

================================================
File: deployment/migration/testnet/cluster_agent/2024-01-19-0.2.1.json
================================================
{
  "cell_recipes": [
    {
      "name": "cluster_agent",
      "tx_hash": "0x53fdb9366637434ff685d0aca5e2a68a859b6fcaa4b608a7ecca0713fed0f5b7",
      "index": 0,
      "occupied_capacity": 5308600000000,
      "data_hash": "0xc986099b41d79ca1b2a56ce5874bcda8175440a17298ea5e2bbc3897736b8c21",
      "type_id": "0x313310e2bb617367c0b47f5d49fc0be7a7e9dbdd7cacc5b8492a99f686898972"
    }
  ],
  "dep_group_recipes": []
}

================================================
File: deployment/migration/testnet/cluster_agent/2024-03-16-0.2.2-beta.2.json
================================================
{
  "cell_recipes": [
    {
      "name": "cluster_agent",
      "tx_hash": "0x52210232292d10c51b48e72a2cea60d8f0a08c2680a97a8ee7ca0a39379f0036",
      "index": 0,
      "occupied_capacity": 5162200000000,
      "data_hash": "0x923e997654b2697ee3f77052cb884e98f28799a4270fd412c3edb8f3987ca622",
      "type_id": "0x605e38c50cf721b52adabc3b0d4ea8e581b9aafc435f334f199c8c972de56762"
    }
  ],
  "dep_group_recipes": []
}

================================================
File: deployment/migration/testnet/cluster_proxy/2024-01-19-0.2.1.json
================================================
{
  "cell_recipes": [
    {
      "name": "cluster_proxy",
      "tx_hash": "0x0231ea581bbc38965e10a2659da326ae840c038a9d0d6849f458b51d94870104",
      "index": 0,
      "occupied_capacity": 4635000000000,
      "data_hash": "0xbe8b9ce3d05a32c4bb26fe71cd5fc1407ce91e3a8b9e8719be2ab072cef1454b",
      "type_id": "0xa746a91d3aaf46765c848d482be7e33a423c2229da98b0ad668fe14888a21142"
    }
  ],
  "dep_group_recipes": []
}

================================================
File: deployment/migration/testnet/cluster_proxy/2024-03-16-0.2.2-beta.2.json
================================================
{
  "cell_recipes": [
    {
      "name": "cluster_proxy",
      "tx_hash": "0xc5a41d58155b11ecd87a5a49fdcb6e83bd6684d3b72b2f3686f081945461c156",
      "index": 0,
      "occupied_capacity": 4655800000000,
      "data_hash": "0x4349889bda064adab8f49f7dd8810d217917f7df28e9b2a1df0b74442399670a",
      "type_id": "0xf07d2a034728c60244b745fc261eed9edad10a57e05aa740819288ed404b716c"
    }
  ],
  "dep_group_recipes": []
}

================================================
File: deployment/migration/testnet/spore/2024-01-19-0.2.1.json
================================================
{
  "cell_recipes": [
    {
      "name": "spore",
      "tx_hash": "0x06995b9fc19461a2bf9933e57b69af47a20bf0a5bc6c0ffcb85567a2c733f0a1",
      "index": 0,
      "occupied_capacity": 7691000000000,
      "data_hash": "0x5e063b4c0e7abeaa6a428df3b693521a3050934cf3b0ae97a800d1bc31449398",
      "type_id": "0x28889a10fd23b6da93c9a96b1585ad23f46e142cce4700937ac86fd811328c8a"
    }
  ],
  "dep_group_recipes": []
}

================================================
File: deployment/migration/testnet/spore/2024-03-16-0.2.2-beta.2.json
================================================
{
  "cell_recipes": [
    {
      "name": "spore",
      "tx_hash": "0x5e8d2a517d50fd4bb4d01737a7952a1f1d35c8afc77240695bb569cd7d9d5a1f",
      "index": 0,
      "occupied_capacity": 7591800000000,
      "data_hash": "0x685a60219309029d01310311dba953d67029170ca4848a4ff638e57002130a0d",
      "type_id": "0x406f121d5d0f2a51deb8eb708c905010c795ce039d90bac8a7e13663803df10f"
    }
  ],
  "dep_group_recipes": []
}

================================================
File: deployment/migration/testnet/spore_extension_lua/2024-01-19-0.2.1.json
================================================
{
  "cell_recipes": [
    {
      "name": "spore_extension_lua",
      "tx_hash": "0x3faf49cbd18fc99566079b534c3c05b2b29703d936e9c0b04234bcc686e076b1",
      "index": 0,
      "occupied_capacity": 3155000000000,
      "data_hash": "0x94a9b875911ace20f1f0d063a26495d14e4b04e32fd218261bb747f34e71ae47",
      "type_id": "0x83c394f0e439bfdd5711578b1669ec73140b5aefd8c6af1d623d6d299a5218de"
    }
  ],
  "dep_group_recipes": []
}

================================================
File: deployment/migration/testnet/spore_extension_lua/2024-03-16-0.2.2-beta.2.json
================================================
{
  "cell_recipes": [
    {
      "name": "spore_extension_lua",
      "tx_hash": "0x9b2098e5b6f575b2fd34ffd0212bc1c96e1f9e86fcdb146511849c174dfe0d02",
      "index": 0,
      "occupied_capacity": 3162200000000,
      "data_hash": "0x5ff1a403458b436ea4b2ceb72f1fa70a6507968493315b646f5302661cb68e57",
      "type_id": "0xd2344a2eb941b70cd8a621d0e5d3a5e343a3716acd992d070d135f4f05734fdd"
    }
  ],
  "dep_group_recipes": []
}

================================================
File: deployment/toml/mainnet/cluster.toml
================================================
# this is a deployment file for ckb testnet

[[cells]]
name = "cluster"
enable_type_id = false
location = { file = "../build/release/cluster" }

# The lock script set to output cells
[lock]
code_hash = "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8"
args = "0x20da6b70dfe59586e89635dbb3adc7aa998e7189"
hash_type = "type"


================================================
File: deployment/toml/mainnet/cluster_agent.toml
================================================
# this is a deployment file for ckb testnet

[[cells]]
name = "cluster_agent"
enable_type_id = false
location = { file = "../build/release/cluster_agent" }

# The lock script set to output cells
[lock]
code_hash = "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8"
args = "0x20da6b70dfe59586e89635dbb3adc7aa998e7189"
hash_type = "type"


================================================
File: deployment/toml/mainnet/cluster_proxy.toml
================================================
# this is a deployment file for ckb testnet

[[cells]]
name = "cluster_proxy"
enable_type_id = false
location = { file = "../build/release/cluster_proxy" }

# The lock script set to output cells
[lock]
code_hash = "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8"
args = "0x20da6b70dfe59586e89635dbb3adc7aa998e7189"
hash_type = "type"


================================================
File: deployment/toml/mainnet/spore.toml
================================================
# this is a deployment file for ckb testnet

[[cells]]
name = "spore"
enable_type_id = false
location = { file = "../build/release/spore" }

# The lock script set to output cells
[lock]
code_hash = "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8"
args = "0x20da6b70dfe59586e89635dbb3adc7aa998e7189"
hash_type = "type"


================================================
File: deployment/toml/mainnet/spore_extension_lua.toml
================================================
# this is a deployment file for ckb testnet

[[cells]]
name = "spore_extension_lua"
enable_type_id = false
location = { file = "../build/release/spore_extension_lua" }

# The lock script set to output cells
[lock]
code_hash = "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8"
args = "0x20da6b70dfe59586e89635dbb3adc7aa998e7189"
hash_type = "type"


================================================
File: deployment/toml/testnet/cluster.toml
================================================
# this is a deployment file for ckb testnet

[[cells]]
name = "cluster"
enable_type_id = true
location = { file = "../build/release/cluster" }

# The lock script set to output cells
[lock]
code_hash = "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8"
args = "0x470dcdc5e44064909650113a274b3b36aecb6dc7"
hash_type = "type"


================================================
File: deployment/toml/testnet/cluster_agent.toml
================================================
# this is a deployment file for ckb testnet

[[cells]]
name = "cluster_agent"
enable_type_id = true
location = { file = "../build/release/cluster_agent" }

# The lock script set to output cells
[lock]
code_hash = "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8"
args = "0x470dcdc5e44064909650113a274b3b36aecb6dc7"
hash_type = "type"


================================================
File: deployment/toml/testnet/cluster_proxy.toml
================================================
# this is a deployment file for ckb testnet

[[cells]]
name = "cluster_proxy"
enable_type_id = true
location = { file = "../build/release/cluster_proxy" }

# The lock script set to output cells
[lock]
code_hash = "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8"
args = "0x470dcdc5e44064909650113a274b3b36aecb6dc7"
hash_type = "type"


================================================
File: deployment/toml/testnet/spore.toml
================================================
# this is a deployment file for ckb testnet

[[cells]]
name = "spore"
enable_type_id = true
location = { file = "../build/release/spore" }

# The lock script set to output cells
[lock]
code_hash = "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8"
args = "0x470dcdc5e44064909650113a274b3b36aecb6dc7"
hash_type = "type"


================================================
File: deployment/toml/testnet/spore_extension_lua.toml
================================================
# this is a deployment file for ckb testnet

[[cells]]
name = "spore_extension_lua"
enable_type_id = true
location = { file = "../build/release/spore_extension_lua" }

# The lock script set to output cells
[lock]
code_hash = "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8"
args = "0x470dcdc5e44064909650113a274b3b36aecb6dc7"
hash_type = "type"


================================================
File: docs/MUTANT.md
================================================
# Mutant
Mutant is a special extension cell in Spore eco. It stores Lua scripting code inside the data field, and will be executed & evaluated in every referenced transaction once applied. One can apply mutants to:

1. A Spore by specifying in `content-type` using param `mutant[] = MUTANT_ID_1, MUTANT_ID2,…;`, and including the referenced mutant cell in `CellDep`. You'll also need to include Spore Lua Lib binary in CellDeps.
2. A cluster by setting cluster’s `mutant_id=MUTANT_ID`, and including the referenced mutant cell in `CellDep`.

For example, you can write:
```Lua
print("Hello, world!");
if spore_output_index > 0 then
  ckb.exit_script(spore_output_index)
end
```
Storing it on a Mutant Cell. Assume the ID of this mutant is `MUTANT_ID` (no `0x` prefix) we have a spore like:
```yaml
Data:
  content-type: "image/png;mutant[]=MUTANT_ID"
  content: ...
Type:
  code_hash: SPORE_TYPE_ID_V2
  args: 0xSPORE_ID
```
Which will result:
1. If the spore exist in `Output[0]`, it will output `"Hello, world!"` in every execution and return success(code 0);
2. If the spore exist in `Output[1]` (any index > 0), it will exit with a faliure code `1` (equals to Output Index as we defined in the Lua code)

Check [Lua docs](https://www.lua.org/docs.html) for standard Lua language doc, and [CKB Lua Functions](https://github.com/nervosnetwork/ckb-lua-vm/blob/master/docs/dylib.md#lua-functions) for CKB related Lua APIs


## OP Code
Mutant has three execution modes mapped to three types of opcode, and will be automatically detected during transaction:
- opcode `0`: Spore in minting operation, mutant executed as minting mode, and mutant Lua script can use external values: `spore_ext_mode`, `spore_output_index`, and `spore_ext_mode = 0`
- opcode `1`: Spore in transfer operation, mutant executed as transfer mode, and mutant Lua script can use external values: `spore_ext_mode`, `spore_input_index` `spore_output_index`, and `spore_ext_mode = 1`
- opcode `2`: Spore in melt operation, mutant executed as melt mode, and mutant Lua script can use external values: `spore_ext_mode`,`spore_input_index`, and `spore_ext_mode = 2`

## Deployment

### Pudge Testnet
#### Spore Lua Lib
- code_hash: `0xed08faee8c29b7a7c29bd9d495b4b93cc207bd70ca93f7b356f39c677e7ab0fc`
- tx: `0xa3add6709887b3e136546edb024cd905726d73a126d47764b4537e8b08de390f`
- index: `0`

#### Mutant
- code_hash: `0xf979ff194202dd2178c18cfc2e5cc60c965a1c94aad8a46eb80e74ee85842b5ce`
- tx: `0xa3add6709887b3e136546edb024cd905726d73a126d47764b4537e8b08de390f`
- index: `1`


## RFC
### Data Structure
```yaml
Data:
  LUA_CODE_DATA_BYTES
Type:
  hash_type: "data1"
  code_hash: SPORE_MUTANT_TYPE_HASH
  args: <MUTANT_ID>[<MINIMAL_PAYMENT>]
Lock: <user_defined>
```
Available Mutant args are list as below:
```yaml
<32bytes Mutant ID>
<32bytes Mutant ID><1bytes CKByte minimum>
```
Where `Mutant ID = hash(Inputs[0], Output_Index)`. The value stored in CKByte minimum  amount are interpreted in the following way: 

if `x` is stored in the field, the minimal transfer amount will be `10^x`, for example:

- If 3 is stored in CKByte minimum, it means the minimal payment amount to use this mutant cell is 1000 shannons
- If 0 is stored in CKByte minimum, it means the minimal payment amount to use this mutant cell is 1 shannon

The additions of CKByte minimums enforce a minimal payment for one to reference this mutant extension while minting Spore.

When applying a Mutant Extension to a Spore, it will cause:

1. contract will run extension code using `ckb_std::exec`
2. arguments of `exec` will be packed as:
argv[0]: `content-type` of Spore
argv[1]: Type `args` (Spore ID) of Spore
argv[2]: Spore `content`
3. Result of exec will be performed:
`0` : success, this operation to Spore is valid and will continue to finish;
any other codes: failed. operation will abort, transaction will return failure code

These effects will be performed once every time during Spore’s creation, transfer, and destruction.


================================================
File: docs/RFC.md
================================================
# RFC: Spore Protocol Spec

This RFC proposes the Spore Protocol (Spore for short) specification.

The core concept of Spore is anchored around the following functionalities:

- Immutable content issuance
- Permanent on-chain storage
- Simplified cell structure, devoid of noise
- Built-in extensibility in protocol design

There are three cell types defined in this protocol: `Spore Cell`, `Spore Cluster Cell`.

The Spore Protocol necessitates only a single cell type referred to as Spore Cell. Any other cell types are optional or are treated as extension cells, intended to augment to information of a Spore item.


## Data Structure

### Spore Cell

```yaml
data:
    content-type: Bytes # String Bytes
    content: Bytes
    # OPTIONAL
    cluster_id: Bytes
type:
    hash_type: "data1"
    code_hash: SPORE_TYPE_DATA_HASH
    args: SPORE_ID
lock:
    <user_defined>
```

- `content-type` hint text data of the formats in the `content` field, also can holds extension feature labels like `TYPE/SUBTYPE;PARAM=VAL` . It should follow the [standard of MIME](https://datatracker.ietf.org/doc/html/rfc2046). For example, `image/png` indicates this Spore contains a PNG image. While users can use this param to extend the protocol, there is preset of params provided by default:
    - `immortal` is a param defines whether this NFT is undestructible or not, default is `false`. for example: `content-type: image/png;immortal=true`
- `content` This field contains the main content of the NFT.
- `cluster_id` An optional field used to denote the series or class collection of this Spore NFT item. Refer to the [Spore Cluster Cell](https://www.notion.so/Spore-NFT-Draft-Spec-old-27e391dc259f4c4bad924d1a2fc26dfc?pvs=21) section for more details.
- `type` script is set to `SPORE_TYPE_DATA_HASH`  with args equals to `SPORE_ID`, which follows: `SPORE_ID = hash(this_transaction.inputs[0] | output_index_of_this_cell)`.

All the fields in a `Spore Cell` are immutable once created.

### Spore Cluster Cell

The structure of a Cluster Cell in Spore Protocol is defined as follows:

```yaml
data:
    name: Bytes # String Bytes
    description: Bytes # String Bytes
type:
    hash_type: "data1"
    code_hash: CLUSTER_TYPE_DATA_HASH
    args: CLUSTER_ID
lock:
    <user_defined>
```

- `name` Represents the name of the Spore Cluster.
- `description` Provides a textual description of this Cluster.
- `type` script is set to `CLUSTER_TYPE_DATA_HASH` with args equals to `CLUSTER_ID` , which follows the rules of Type ID script. And we define the `CLUSTER_ID = hash(this_transaction.inputs[0] | output_index_of_this_cell)`.

A `Spore Cluster Cell` is *indestructible*  and immutable once created.

## Examples

### Single Spore Issuance/Minting

Below is a sample transaction for creating a Spore contains PNG image.

```yaml
CellDep:
  <Spore Type Cell>
  <...>
Inputs:
  <any normal ckb cells>
Outputs:
  Spore Cell:
    Capacity: N CKBytes
    Type:
      hash_type: "data1"
      code_hash: SPORE_TYPE_DATA_HASH
      args: SPORE_ID
    Lock:
      <user-defined>
    Data:
      content-type: "image/png"
      content: BYTES_OF_THE_IMAGE
      cluster_id: null
Witnesses:
  <valid signature for public key hash>
```

If `cluster_id` was set, then the referenced `Cluster Cell` should appear in `CellDep`, and should follow rules below:

- Rule 1: The referenced Cluster Cell **must** exist in CellDep.
- Rule 2: The referenced Cluster Cell should be exist in both Inputs and Outputs. If not, Rule 5 should be applied.
- Rule 3: The input Cluster Cell should have a lock script that is unlock-able
- Rule 4: Cluster Cell with same Type Script Args in Outputs should have a same lock pair with in Inputs.
- Rule 5: If Rule 2~4 is not fit, at least one cell with a same lock of the referenced Cluster Cell should be exist in both Inputs and Outputs. We call these cell as “Lock Proxy Cell”. A Spore Cell can also be Lock Proxy Cell.

Below is an example showing the transaction when `cluster_id` is set using Cluster as Inputs:

```yaml
CellDep:
  <Spore Type Script Cell>
  <Cluster Type Script Cell>
  Cluster Cell:
    Type:
      hash_type: "data1"
      code_hash: CLUSTER_TYPE_DATA_HASH
      args: 0xbfca51165
    Lock:
      code_hash: LOCK_HASH_1
      args: LOCK_ARGS_1
    Data:
      name: CLUSTER_NAME
      description: DESCRIPTION
  <other deps...>
Inputs:
  Cluster Cell:
    Type:
      hash_type: "data1"
      code_hash: CLUSTER_TYPE_DATA_HASH
      args: 0xbfca51165
    Lock:
      code_hash: LOCK_HASH_1
      args: LOCK_ARGS_1
    Data:
      name: CLUSTER_NAME
      description: DESCRIPTION
  <other deps...>
  <other ckb cells...>
Outputs:
  Cluster Cell:
    Type:
      hash_type: "data1"
      code_hash: CLUSTER_TYPE_DATA_HASH
      args: 0xbfca51165
    Lock:
      code_hash: LOCK_HASH_1
      args: LOCK_ARGS_1
    Data:
      name: CLUSTER_NAME
      description: DESCRIPTION
  <other deps...>
  Spore Cell:
    Type:
      hash_type: "data1"
      code_hash: SPORE_V1_DATA_HASH # hash of Spore's type script data hash
		  args: TYPE_ID
    Lock:
      <user-defined>
    Data:
      content-type: "image/png"
      content:  BYTES_OF_THE_IMAGE
      cluster_id: "0xbfca51165"
  <other ckb cells...>
```

Below is an example showing the transaction when `cluster_id` is set using Lock Proxy Cells:

```yaml
CellDep:
  <Spore Type Script Cell>
  <Cluster Type Script Cell>
  Cluster Cell:
    Type:
      hash_type: "data1"
      code_hash: CLUSTER_TYPE_DATA_HASH
      args: 0xbfca51165
    Lock:
      code_hash: LOCK_HASH_1
      args: LOCK_ARGS_1
    Data:
      name: CLUSTER_NAME
      description: DESCRIPTION
  <other deps...>
Inputs:
  Cell 1: # Lock Proxy Cell
    Lock:
      code_hash: LOCK_HASH_1
      args: LOCK_ARGS_1
  <other ckb cells...>
Outputs:
  Cell 2: # Lock Proxy Cell
    Lock:
      code_hash: LOCK_HASH_1
      args: LOCK_ARGS_1
  Spore Cell:
    Type:
      hash_type: "data1"
      code_hash: SPORE_V1_DATA_HASH # hash of Spore's type script data hash
		  args: TYPE_ID
    Lock:
      <user-defined>
    Data:
      content-type: "image/png"
      content:  BYTES_OF_THE_IMAGE
      cluster_id: "0xbfca51165"
  <other ckb cells...>
```

### Cluster Creation

Below is a sample transaction for creating a `Cluster Cell`:

```yaml
Inputs:
  <Cluster Type Script Cell>
  <...>
Outputs:
  Spore Cluster Cell:
    Type:
      hash_type: "data1"
      code_hash: CLUSTER_TYPE_DATA_HASH
      args: CLUSTER_ID
    Lock:
      <user-defined>
    Data:
      name: "NAME_OF_CLUSTER"
      description: "THIS IS A DESCR FOR THIS CLUSTER"
```

### Multiple Spore Issuance/Minting

Below is a sample transaction for creating several Spore in one operation

```yaml
CellDep:
  <Spore Type Script Cell>
  <Cluster Type Script Cell>
  Cluster Cell:
    Type:
      hash_type: "data1"
      code_hash: CLUSTER_TYPE_DATA_HASH
      args: 0xbfca51165
    Lock:
      code_hash: LOCK_HASH
      args: LOCK_ARGS
    Data:
      name: CLUSTER_NAME
      description: DESCRIPTION
  <other deps...>
Inputs:
  Cluster Cell:
    Type:
      hash_type: "data1"
      code_hash: CLUSTER_TYPE_DATA_HASH
      args: 0xbfca51165
    Lock:
      code_hash: LOCK_HASH
      args: LOCK_ARGS
    Data:
      name: CLUSTER_NAME
      description: DESCRIPTION
  <any other normal ckb cells...>
Outputs:
  Spore Cell1:
    Capacity: N CKBytes
    Type:
      hash_type: "data1"
      code_hash: SPORE_TYPE_DATA_HASH
      args: SPORE_ID_1
    Lock:
      <user-defined>
    Data:
      content-type: "image/png"
      content: BYTES_OF_THE_IMAGE1
      cluster_id: 0xbfca51165

  Spore Cell2:
    Capacity: N CKBytes
    Type:
      hash_type: "data1"
      code_hash: SPORE_TYPE_DATA_HASH
      args: SPORE_ID_2
    Lock:
      <user-defined>
    Data:
      content-type: "image/png"
      content: BYTES_OF_THE_IMAGE2
      cluster_id: null

  Spore Cell3:
    Capacity: N CKBytes
    Type:
      hash_type: "data1"
      code_hash: SPORE_TYPE_DATA_HASH
      args: SPORE_ID_3
    Lock:
      <user-defined>
    Data:
      content-type: "plain/text"
      content: BYTES_OF_THE_TEXT
      cluster_id: 0xbfca51165

  Cluster Cell:
    Type:
      hash_type: "data1"
      code_hash: CLUSTER_TYPE_DATA_HASH
      args: 0xbfca51165
    Lock:
      code_hash: LOCK_HASH
      args: LOCK_ARGS
    Data:
      name: CLUSTER_NAME
      description: DESCRIPTION
  <...>
Witnesses:
  <valid signature for inputs>
```

### Transfer

Below is an example transaction transfers Spore from one to other holder
```yaml
Inputs:
  Spore Cell:
    Capacity: N CKBytes
    Data:
      content-type: "image/png"
      content: BYTES_OF_THE_IMAGE
    Type:
      hash_type: "data1"
      code_hash: SPORE_TYPE_DATA_HASH
      args: SPORE_ID
    Lock:
      code_hash: LOCK_HASH_1
      args: LOCK_ARGS_1
  <...>
Outputs:
  Spore Cell:
    Capacity: N CKBytes
    Data:
      content-type: "image/png"
      content: BYTES_OF_THE_IMAGE
    Type:
      hash_type: "data1"
      code_hash: SPORE_TYPE_DATA_HASH
      args: SPORE_ID
    Lock:
      code_hash: LOCK_HASH_2
      args: LOCK_ARGS_2
  <...>
Witnesses:
  <valid signature for inputs>
```

================================================
File: docs/RFC_PROXY_AGENT.md
================================================
# Public Cluster Verification Problems

## Original Problems

In the original design of the Spore Protocol, the creation of a Spore with a Cluster ID required the following conditions:

1. The referenced Cluster Cell must be found in the `CellDeps`.
2. The referenced Cluster Cell must be found in the `Inputs`.
3. The referenced Cluster Cell must be found in the `Outputs`.

This verification process ensures ownership of the referenced Cluster Cell, preventing malicious activities on one's private Cluster.

While this design prevents minting in a private Cluster when ownership is absent, challenges remain in public Clusters. In public mining, ownership is nullified upon a customized lock (e.g., [anyone-can-pay](https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0026-anyone-can-pay/0026-anyone-can-pay.md)) is introduced. However, this gives rise to the issue of cell competition: if two minting transactions are accidentally sent simultaneously, one will be rejected. The target Cluster gets consumed and recreated by one transaction, requiring reconstruction of the rejected transaction to proceed with minting.

## Solution

At this stage, the **owner** needs to create a special cell, here we called it **Cluster Proxy Cell**

A Cluster Proxy Cell’s structure is like below:

```yaml
Cluster Proxy Cell:
    Data: REFERENCED_CLUSTER_ID
    Type:
        code_hash: CLUSTER_PROXY_TYPE_HASH
        args: <cluster_proxy_id> [<min_payment>]
    Lock:
        <user_defined>
```

The Type args can be:

- args: <cluster_proxy_id>
- args: <cluster_proxy_id> <minimal payment in 10^n ckbytes: uint8>

Where `cluster_proxy_id = hash(Inputs[0], Output_Index)`

### Step1: Creating Cluster Proxy Cell

Creating a Cluster Proxy Cell can be done in two ways. The first method is putting a Cluster Cell to Inputs & Outputs, as shown below:

#### Method 1. Use Direct Input

```yaml
CellDeps:
    <CLUSTER_PROXY_TYPE_CELL>
    <CLUSTER_TYPE_CELL>
    Cluster Cell A:
        Data: <...>
        Type:
            args: CLUSTER_ID_A
            code_hash: CLUSTER_TYPE_HASH_A
        Lock: <user-defined>
Inputs:
    Cluster Cell A:
        Type:
            args: CLUSTER_ID_A
            code_hash: CLUSTER_TYPE_HASH_A
        Lock: <user-defined>
    <...any other cells>
Outputs:
    Cluster Cell A:
        Type:
            args: CLUSTER_ID_A
            code_hash: CLUSTER_TYPE_HASH_A
        Lock: <user-defined>
    Cluster Proxy Cell:
        Data: CLUSTER_ID_A
        Type:
            code_hash: CLUSTER_PROXY_TYPE_HASH
            args: CLUSTER_PROXY_ID_A
        Lock:
            <user_defined> # for example, acp
```

The other method is using an Input Cell with same Lock to the Cluster Cell to create a Cluster Proxy Cell.

#### Method 2. Use Lock Proxy

```yaml
CellDeps:
    <CLUSTER_PROXY_TYPE_CELL>
    Cluster Cell A:
        Type:
            args: CLUSTER_ID_A
            code_hash: CLUSTER_TYPE_HASH_A
        Lock:
            args: <public key hash A>
            code_hash: LOCK_CODE_HASH_A
Inputs:
    Any Cell:
        Lock:
            args: <public key hash A>
            code_hash: LOCK_CODE_HASH_A
    <...any other cells>
Outputs:
    Cluster Proxy Cell:
        Data: CLUSTER_ID_A
        Type:
            code_hash: CLUSTER_PROXY_TYPE_HASH
            args: CLUSTER_PROXY_ID
        Lock:
            <user_defined> # for example, acp
     <...any other cells>
```

### Step2: Create Cluster Agent Cell

Once the Cluster owner created the Cluster Proxy Cell, anyone who is able to unlock the Cluster Proxy Cell is able to create a special type cell called: Cluster Agent Cell. Holder of this Cluster Agent Cell can mint Spore in a regular process and put it into the referenced Cluster.

```yaml
Cluster Agent Cell:
    Data: Type Hash of Referenced Cluster Proxy
    Type:
        code_hash: CLUSTER_AGENT_TYPE_HASH
        args: REFERENCED_CLUSTER_ID
    Lock:
        <user_defined>
```

There are two ways to create a Cluster Proxy Agent Cell.

#### Method 1. Direct Input

```yaml
CellDeps:
    <CLUSTER_PROXY_TYPE_CELL>
    <CLUSTER_PROXY_AGENT_TYPE_CELL>
    Cluster Proxy Cell:
        Data: CLUSTER_ID_A
        Type:
            code_hash: CLUSTER_PROXY_TYPE_HASH
            args: CLUSTER_PROXY_ID
        Lock:
            <user_defined>
Inputs:
    Cluster Proxy Cell:
        Data: CLUSTER_ID_A
        Type:
            code_hash: CLUSTER_PROXY_TYPE_HASH
            args: CLUSTER_PROXY_ID
        Lock:
            <user_defined>
    <...any other cells>
Outputs:
     Cluster Agent Cell:
        Data: Hash(ClusterProxyCell.Type)
        Type:
            code_hash: CLUSTER_AGENT_TYPE_HASH
            args: CLUSTER_ID_A
        Lock:
            <user_defined>

    Cluster Proxy Cell:
        Data: CLUSTER_ID_A
        Type:
            code_hash: CLUSTER_PROXY_TYPE_HASH
            args: CLUSTER_PROXY_ID
        Lock:
            <user_defined>
     <...any other cells>
```

# Method 2. Use Payment Appearance

Alternatively, you can make a payment to the Cluster Proxy owner to create a Cluster Agent Cell. This method essentially involves transferring capacity to the same lock address with the Cluster Proxy.

```yaml
CellDeps:
    <CLUSTER_AGENT_TYPE_CELL>
    Cluster Proxy Cell:
        Data: CLUSTER_ID_A
        Type:
            code_hash: CLUSTER_PROXY_TYPE_HASH
             args: <CLUSTER_PROXY_ID_A> <MINIMAY_PAYMENT_A>
        Lock:
            code_hash: CODE_HASH_A
            args: PUBKEY_A
Inputs:
    Payment Cell: #
        Capacity: N # N >= MINIMAY_PAYMENT_A
        Lock: <user_defined>
    <...any other cells>
Outputs:
     Cluster Agent Cell:
        Data: Hash(ClusterProxyCell.Type)
        Type:
            code_hash: CLUSTER_AGENT_TYPE_HASH
            args: CLUSTER_ID_A
        Lock:
            <user_defined>

    Receivement Cell:
        Capacity: N
        Lock:
            code_hash: CODE_HASH_A
            args: PUBKEY_A
     <...any other cells>
```

Here, the payment cell serves merely as an example; it can be any unlockable cell and is not limited to only one cell.

### Step3: Mint Spore with Cluster Agent

The Cluster Agent Cell holder can mint Spore using three valid methods listed below.

#### Method 1. Mint With Direct Input

```yaml
CellDeps:
    <SPORE_TYPE>
Inputs:
    Cluster Agent Cell A:
        Type:
            args: CLUSTER_ID_A
            code_hash: CLUSTER_AGENT_TYPE_HASH
        Lock: <user-defined>
    <...any other cells>
Outputs:
    Spore Cell:
        Capacity: N CKBytes
        Data:
            content-type: "image/png"
            content:  BYTES_OF_THE_IMAGE
            cluster: CLUSTER_ID_A
        Type:
            hash_type: "data1"
   			code_hash: SPORE_TYPE_DATA_HASH # hash of Spore's type script data hash
   			args: SPORE_ID
        Lock:
            <user-defined>
    Cluster Agent Cell A:
        Data: Hash(ClusterProxyCell.Type)
        Type:
            code_hash: CLUSTER_AGENT_TYPE_HASH
            args: CLUSTER_ID_A
        Lock:
            <user_defined> # for example, acp
```

#### Method 2. Mint With Lock Proxy

```yaml
CellDeps:
    <SPORE_TYPE_CELL>
    Cluster Agent Cell A:
        Data: Hash(Cluster_Proxy_Cell_Type)
        Type:
            args: CLUSTER_ID_A
            code_hash: CLUSTER_AGENT_TYPE_HASH
        Lock: 
            args: <public key hash A>
            code_hash: LOCK_CODE_HASH_A
Inputs:
     Any Cell: # Lock Proxy Cell
        Lock: 
            args: <public key hash A>
            code_hash: LOCK_CODE_HASH_A
     <...any other cells>
Outputs:
    Spore Cell:
        Capacity: N CKBytes
        Data:
            content-type: "image/png"
            content:  BYTES_OF_THE_IMAGE
            cluster: CLUSTER_ID_A
        Type:
            hash_type: "data1"
            code_hash: SPORE_TYPE_DATA_HASH # hash of Spore's type script data hash
            args: SPORE_ID
        Lock:
            <user-defined>
```

#### Method 3. Mint With Signature (Not Implemented)

```yaml
CellDeps:
    <SPORE_TYPE_CELL>
    Cluster Agent Cell A:
        Type:
            args: CLUSTER_ID_A
            code_hash: CLUSTER_AGENT_TYPE_HASH
        Lock: 
            args: <public key hash A>
            code_hash: LOCK_CODE_HASH_A
Inputs:
     <...any other cells>
Outputs:
    Spore Cell:
        Capacity: N CKBytes
        Data:
            content-type: "image/png"
            content:  BYTES_OF_THE_IMAGE
            cluster: CLUSTER_ID_A
        Type:
            hash_type: "data1"
            code_hash: SPORE_V1_DATA_HASH # hash of Spore's type script data hash
            args: SPORE_ID
        Lock:
            <user-defined>
Witnesses:
    <valid signature for public key hash A>
```


================================================
File: docs/VERSIONS.md
================================================
# Historical Versions

## tag 0.2.1 (testnet)

**spore**:
| | |
|-|-|
|tx_hash|0x06995b9fc19461a2bf9933e57b69af47a20bf0a5bc6c0ffcb85567a2c733f0a1|
|index|0|
|code_hash|0x5e063b4c0e7abeaa6a428df3b693521a3050934cf3b0ae97a800d1bc31449398|

**cluster**:
| | |
|-|-|
|tx_hash|0xfbceb70b2e683ef3a97865bb88e082e3e5366ee195a9c826e3c07d1026792fcd|
|index|0|
|code_hash|0x7366a61534fa7c7e6225ecc0d828ea3b5366adec2b58206f2ee84995fe030075|

**cluster_agent**:
| | |
|-|-|
|tx_hash|0x53fdb9366637434ff685d0aca5e2a68a859b6fcaa4b608a7ecca0713fed0f5b7|
|index|0|
|code_hash|0xc986099b41d79ca1b2a56ce5874bcda8175440a17298ea5e2bbc3897736b8c21|

**cluster_proxy**:
| | |
|-|-|
|tx_hash|0x0231ea581bbc38965e10a2659da326ae840c038a9d0d6849f458b51d94870104|
|index|0|
|code_hash|0xbe8b9ce3d05a32c4bb26fe71cd5fc1407ce91e3a8b9e8719be2ab072cef1454b|

## tag 0.2.2-beta.1 (mainnet)

**spore**:
| | |
|-|-|
|tx_hash|0x96b198fb5ddbd1eed57ed667068f1f1e55d07907b4c0dbd38675a69ea1b69824|
|index|0|
|code_hash|0x4a4dce1df3dffff7f8b2cd7dff7303df3b6150c9788cb75dcf6747247132b9f5|

**cluster**:
| | |
|-|-|
|tx_hash|0xe464b7fb9311c5e2820e61c99afc615d6b98bdefbe318c34868c010cbd0dc938|
|index|0|
|code_hash|0x7366a61534fa7c7e6225ecc0d828ea3b5366adec2b58206f2ee84995fe030075|

## tag 0.2.2-beta.2 (testnet)

**spore**:
| | |
|-|-|
|tx_hash|0x5e8d2a517d50fd4bb4d01737a7952a1f1d35c8afc77240695bb569cd7d9d5a1f|
|index|0|
|code_hash|0x685a60219309029d01310311dba953d67029170ca4848a4ff638e57002130a0d|

**cluster**:
| | |
|-|-|
|tx_hash|0xcebb174d6e300e26074aea2f5dbd7f694bb4fe3de52b6dfe205e54f90164510a|
|index|0|
|code_hash|0x0bbe768b519d8ea7b96d58f1182eb7e6ef96c541fbd9526975077ee09f049058|

**cluster_agent**:
| | |
|-|-|
|tx_hash|0x52210232292d10c51b48e72a2cea60d8f0a08c2680a97a8ee7ca0a39379f0036|
|index|0|
|code_hash|0x923e997654b2697ee3f77052cb884e98f28799a4270fd412c3edb8f3987ca622|

**cluster_proxy**:
| | |
|-|-|
|tx_hash|0xc5a41d58155b11ecd87a5a49fdcb6e83bd6684d3b72b2f3686f081945461c156|
|index|0|
|code_hash|0x4349889bda064adab8f49f7dd8810d217917f7df28e9b2a1df0b74442399670a|

**spore_extension_lua**:
| | |
|-|-|
|tx_hash|0x9b2098e5b6f575b2fd34ffd0212bc1c96e1f9e86fcdb146511849c174dfe0d02|
|index|0|
|code_hash|0x5ff1a403458b436ea4b2ceb72f1fa70a6507968493315b646f5302661cb68e57|


================================================
File: lib/build/Cargo.toml
================================================
[package]
name = "spore-build-tools"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
toml = "0.8"
serde = { version = "1.0", default-features = false, features = [
    "serde_derive",
] }
faster-hex = { version = "0.9", default-features = false }


================================================
File: lib/build/src/lib.rs
================================================
use faster_hex::hex_decode;
use std::env;
use std::fs;

#[derive(serde::Deserialize)]
pub struct FrozenVersions {
    code_hash_list: Vec<PublishedCodeHash>,
}

#[derive(serde::Deserialize)]
pub struct PublishedCodeHash {
    #[serde(default)]
    spore: String,
    #[serde(default)]
    cluster: String,
    #[serde(default)]
    cluster_proxy: String,
    #[serde(default)]
    cluster_agent: String,
    #[serde(default)]
    mutant: String,
}

fn hex_to_byte32(hex: &str) -> [u8; 32] {
    assert!(hex.len() == 64, "only accept [u8; 32] as hex string");
    let mut byte32 = [0u8; 32];
    hex_decode(hex.as_bytes(), &mut byte32).expect("hex to byte32");
    byte32
}

impl FrozenVersions {
    pub fn spore_code_hashes(&self) -> Vec<[u8; 32]> {
        self.code_hash_list
            .iter()
            .filter_map(|v| {
                if !v.spore.is_empty() {
                    Some(hex_to_byte32(&v.spore))
                } else {
                    None
                }
            })
            .collect()
    }

    pub fn cluster_code_hashes(&self) -> Vec<[u8; 32]> {
        self.code_hash_list
            .iter()
            .filter_map(|v| {
                if !v.cluster.is_empty() {
                    Some(hex_to_byte32(&v.cluster))
                } else {
                    None
                }
            })
            .collect()
    }

    pub fn cluster_proxy_code_hashes(&self) -> Vec<[u8; 32]> {
        self.code_hash_list
            .iter()
            .filter_map(|v| {
                if !v.cluster_proxy.is_empty() {
                    Some(hex_to_byte32(&v.cluster_proxy))
                } else {
                    None
                }
            })
            .collect()
    }

    pub fn cluster_agent_code_hashes(&self) -> Vec<[u8; 32]> {
        self.code_hash_list
            .iter()
            .filter_map(|v| {
                if !v.cluster_agent.is_empty() {
                    Some(hex_to_byte32(&v.cluster_agent))
                } else {
                    None
                }
            })
            .collect()
    }

    pub fn mutant_code_hashes(&self) -> Vec<[u8; 32]> {
        self.code_hash_list
            .iter()
            .filter_map(|v| {
                if !v.mutant.is_empty() {
                    Some(hex_to_byte32(&v.mutant))
                } else {
                    None
                }
            })
            .collect()
    }
}

pub fn load_frozen_toml() -> FrozenVersions {
    let net_type = if env::var("CARGO_FEATURE_RELEASE_EXPORT").is_ok() {
        "mainnet"
    } else {
        "testnet"
    };
    let frozen_path = env::current_dir()
        .unwrap()
        .join("../../deployment/frozen")
        .join(format!("{net_type}.toml"));
    let frozen = fs::read_to_string(frozen_path).unwrap();
    toml::from_str(&frozen).unwrap()
}

pub fn concat_code_hashes(var_name: &str, code_hashes: &[[u8; 32]]) -> String {
    let mut content = format!(
        "pub const {var_name}: [[u8; 32]; {}] = [",
        code_hashes.len()
    );
    code_hashes.into_iter().for_each(|v| {
        content += &format!("{v:?},");
    });
    content += "];\n";
    content
}


================================================
File: lib/errors/Cargo.toml
================================================
[package]
name = "spore-errors"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
ckb-std = "0.14.3"


================================================
File: lib/errors/src/error.rs
================================================
use ckb_std::error::SysError;

/// Error
#[repr(i8)]
pub enum Error {
    IndexOutOfBound = 1,
    ItemMissing,
    LengthNotEnough,
    Encoding,

    // common
    InvalidClusterData,
    ClusterCellNotInDep,
    ClusterOwnershipVerifyFailed,
    InvliadCoBuildWitnessLayout,
    InvliadCoBuildMessage,
    SporeActionDuplicated,
    SporeActionMismatch,
    SporeActionFieldMismatch,
    SporeActionAddressesMismatch,

    // spore_extension_lua errors
    ModifyExtensionPermanentField = 15,
    ConflictExtensionCreation,
    ExtensionMultipleSpend,
    InvalidExtensionOperation,
    InvalidExtensionID,
    InvalidExtensionArg,
    InvalidLuaScript,
    InvalidLuaLib,
    InvalidLuaParameters,
    FailedToLoadLuaLib,
    FailedToCreateLuaInstance,

    // cluster_proxy errors
    InvalidProxyOperation = 30,
    ImmutableProxyFieldModification,
    InvalidProxyID,
    InvalidProxyArgs,

    // cluster_agent errors
    InvalidAgentOperation = 40,
    ImmutableAgentFieldModification,
    InvalidAgentArgs,
    ProxyCellNotInDep,
    PaymentNotEnough,
    PaymentMethodNotSupport,
    RefCellNotClusterProxy,
    ConflictAgentCells,

    // cluster errors
    InvalidClusterOperation = 50,
    ModifyClusterPermanentField,
    EmptyName,
    InvalidClusterID,
    MutantNotInDeps,

    // spore errors
    BoundaryEncoding = 60,
    ModifySporePermanentField,
    InvalidSporeData,
    InvalidSporeID,
    InvalidContentType, // failed to parse content-type
    DestroyImmortalNFT, // cannot destroy an immortal cellular cell
    EmptyContent,       // content is empty
    ConflictCreation,
    MultipleSpend,
    InvalidMultipartContent,
    MIMEParsingError,
    ExtensionCellNotInDep,
    ExtensionPaymentNotEnough,
    ClusterRequiresMutantApplied,
    InvalidExtensionPaymentFormat,

    // mime errors
    Illformed = 80,
    InvaliMainType,
    InvalidSubType,
    InvalidParams,
    InvalidParamValue,
    MutantIDNotValid,
    DuplicateMutantId,
    ContentOutOfRange,

    Unknown,
}

impl From<SysError> for Error {
    fn from(err: SysError) -> Self {
        use SysError::*;
        match err {
            IndexOutOfBound => Self::IndexOutOfBound,
            ItemMissing => Self::ItemMissing,
            LengthNotEnough(_) => Self::LengthNotEnough,
            Encoding => Self::Encoding,
            Unknown(err_code) => panic!("unexpected sys error {}", err_code),
        }
    }
}


================================================
File: lib/errors/src/lib.rs
================================================
#![no_std]

pub mod error;


================================================
File: lib/types/Cargo.toml
================================================
[package]
name = "spore-types"
version = "0.1.0"
edition = "2021"
license = "MIT"
description = "Spore Protocol types serilization/deserilize utilities (based on molecule)"


# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
molecule = { version = "0.7.5", default-features = false }


================================================
File: lib/types/schemas/action.mol
================================================
array Byte32 [byte; 32];
vector Bytes <byte>;

table Script {
    code_hash: Byte32,
    hash_type: byte,
    args: Bytes,
}

union Address {
    Script,
}

/* Actions for Spore */

table MintSpore {
    spore_id: Byte32,
    to: Address,
    data_hash: Byte32,
}

table TransferSpore {
    spore_id: Byte32,
    from: Address,
    to: Address,
}

table BurnSpore {
    spore_id: Byte32,
    from: Address,
}

/* Actions for Cluster */

table MintCluster {
    cluster_id: Byte32,
    to: Address,
    data_hash: Byte32,
}

table TransferCluster {
    cluster_id: Byte32,
    from: Address,
    to: Address,
}

/* Actions for Cluster/Proxy */

table MintProxy {
    cluster_id: Byte32,
    proxy_id: Byte32,
    to: Address,
}

table TransferProxy {
    cluster_id: Byte32,
    proxy_id: Byte32,
    from: Address,
    to: Address,
}

table BurnProxy {
    cluster_id: Byte32,
    proxy_id: Byte32,
    from: Address,
}

/* Actions for Cluster/Agent */

table MintAgent {
    cluster_id: Byte32,
    proxy_id: Byte32,
    to: Address,
}

table TransferAgent {
    cluster_id: Byte32,
    from: Address,
    to: Address,
}

table BurnAgent {
    cluster_id: Byte32,
    from: Address,
}

/* Action in ScriptInfo */

union SporeAction {
    MintSpore,
    TransferSpore,
    BurnSpore,

    MintCluster,
    TransferCluster,

    MintProxy,
    TransferProxy,
    BurnProxy,

    MintAgent,
    TransferAgent,
    BurnAgent,
}


================================================
File: lib/types/schemas/spore_v1.mol
================================================
vector Bytes <byte>;
option BytesOpt (Bytes);

table SporeData {
    content_type: Bytes,
    content: Bytes,
    cluster_id: BytesOpt,
}

table ClusterData {
    name: Bytes,
    description: Bytes,
}


================================================
File: lib/types/schemas/spore_v2.mol
================================================
import spore_v1;

table ClusterDataV2 {
    name: Bytes,
    description: Bytes,
    mutant_id: BytesOpt,
}


================================================
File: lib/types/src/lib.rs
================================================
#![no_std]

extern crate alloc;
pub use crate::generated::spore::{Bytes, BytesOpt, SporeData};
use alloc::string::String;
use alloc::vec::Vec;
use molecule::prelude::{Builder, Entity};

pub mod generated;

impl Into<Bytes> for &[u8] {
    fn into(self) -> Bytes {
        let len = self.len();
        let mut vec: Vec<u8> = Vec::with_capacity(4 + len);
        vec.extend_from_slice(&(len as u32).to_le_bytes()[..]);
        vec.extend_from_slice(self);
        Bytes::new_unchecked(Bytes::from_slice(vec.as_slice()).unwrap().as_bytes())
    }
}

impl Into<BytesOpt> for &[u8] {
    fn into(self) -> BytesOpt {
        let len = self.len();
        let mut vec: Vec<u8> = Vec::with_capacity(4 + len);
        vec.extend_from_slice(&(len as u32).to_le_bytes()[..]);
        vec.extend_from_slice(self);
        BytesOpt::new_unchecked(BytesOpt::from_slice(vec.as_slice()).unwrap().as_bytes())
    }
}

#[derive(Debug, Clone)]
pub struct NativeNFTData {
    pub content_type: String,
    pub content: Vec<u8>,
    pub cluster_id: Option<Vec<u8>>,
}

impl From<NativeNFTData> for generated::spore::SporeData {
    fn from(data: NativeNFTData) -> Self {
        let content: Bytes = data.content.as_slice().into();
        let content_type: Bytes = data.content_type.as_bytes().into();
        let cluster_id = match data.cluster_id {
            Some(cluster) => BytesOpt::new_builder()
                .set(Some(cluster.as_slice().into()))
                .build(),
            None => BytesOpt::default(),
        };
        SporeData::new_builder()
            .content(content)
            .content_type(content_type)
            .cluster_id(cluster_id)
            .build()
    }
}

impl generated::spore::Bytes {
    pub fn unpack(&self) -> &[u8] {
        &self.as_slice()[4..]
    }
}


================================================
File: lib/types/src/generated/action.rs
================================================
// Generated by Molecule 0.7.5
#![allow(dead_code)]

use molecule::prelude::*;
#[derive(Clone)]
pub struct Byte32(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Byte32 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Byte32 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Byte32 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Byte32 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Byte32::new_unchecked(v)
    }
}
impl Byte32 {
    const DEFAULT_VALUE: [u8; 32] = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0,
    ];
    pub const TOTAL_SIZE: usize = 32;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 32;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn nth7(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn nth8(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(8..9))
    }
    pub fn nth9(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(9..10))
    }
    pub fn nth10(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(10..11))
    }
    pub fn nth11(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(11..12))
    }
    pub fn nth12(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(12..13))
    }
    pub fn nth13(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(13..14))
    }
    pub fn nth14(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(14..15))
    }
    pub fn nth15(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(15..16))
    }
    pub fn nth16(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(16..17))
    }
    pub fn nth17(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(17..18))
    }
    pub fn nth18(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(18..19))
    }
    pub fn nth19(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(19..20))
    }
    pub fn nth20(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(20..21))
    }
    pub fn nth21(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(21..22))
    }
    pub fn nth22(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(22..23))
    }
    pub fn nth23(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(23..24))
    }
    pub fn nth24(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(24..25))
    }
    pub fn nth25(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(25..26))
    }
    pub fn nth26(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(26..27))
    }
    pub fn nth27(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(27..28))
    }
    pub fn nth28(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(28..29))
    }
    pub fn nth29(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(29..30))
    }
    pub fn nth30(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(30..31))
    }
    pub fn nth31(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(31..32))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> Byte32Reader<'r> {
        Byte32Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Byte32 {
    type Builder = Byte32Builder;
    const NAME: &'static str = "Byte32";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Byte32(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte32Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte32Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
            self.nth8(),
            self.nth9(),
            self.nth10(),
            self.nth11(),
            self.nth12(),
            self.nth13(),
            self.nth14(),
            self.nth15(),
            self.nth16(),
            self.nth17(),
            self.nth18(),
            self.nth19(),
            self.nth20(),
            self.nth21(),
            self.nth22(),
            self.nth23(),
            self.nth24(),
            self.nth25(),
            self.nth26(),
            self.nth27(),
            self.nth28(),
            self.nth29(),
            self.nth30(),
            self.nth31(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct Byte32Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Byte32Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Byte32Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Byte32Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> Byte32Reader<'r> {
    pub const TOTAL_SIZE: usize = 32;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 32;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn nth7(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
    pub fn nth8(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[8..9])
    }
    pub fn nth9(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[9..10])
    }
    pub fn nth10(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[10..11])
    }
    pub fn nth11(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[11..12])
    }
    pub fn nth12(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[12..13])
    }
    pub fn nth13(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[13..14])
    }
    pub fn nth14(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[14..15])
    }
    pub fn nth15(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[15..16])
    }
    pub fn nth16(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[16..17])
    }
    pub fn nth17(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[17..18])
    }
    pub fn nth18(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[18..19])
    }
    pub fn nth19(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[19..20])
    }
    pub fn nth20(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[20..21])
    }
    pub fn nth21(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[21..22])
    }
    pub fn nth22(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[22..23])
    }
    pub fn nth23(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[23..24])
    }
    pub fn nth24(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[24..25])
    }
    pub fn nth25(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[25..26])
    }
    pub fn nth26(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[26..27])
    }
    pub fn nth27(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[27..28])
    }
    pub fn nth28(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[28..29])
    }
    pub fn nth29(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[29..30])
    }
    pub fn nth30(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[30..31])
    }
    pub fn nth31(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[31..32])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for Byte32Reader<'r> {
    type Entity = Byte32;
    const NAME: &'static str = "Byte32Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Byte32Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct Byte32Builder(pub(crate) [Byte; 32]);
impl ::core::fmt::Debug for Byte32Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for Byte32Builder {
    fn default() -> Self {
        Byte32Builder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl Byte32Builder {
    pub const TOTAL_SIZE: usize = 32;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 32;
    pub fn set(mut self, v: [Byte; 32]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Byte) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: Byte) -> Self {
        self.0[4] = v;
        self
    }
    pub fn nth5(mut self, v: Byte) -> Self {
        self.0[5] = v;
        self
    }
    pub fn nth6(mut self, v: Byte) -> Self {
        self.0[6] = v;
        self
    }
    pub fn nth7(mut self, v: Byte) -> Self {
        self.0[7] = v;
        self
    }
    pub fn nth8(mut self, v: Byte) -> Self {
        self.0[8] = v;
        self
    }
    pub fn nth9(mut self, v: Byte) -> Self {
        self.0[9] = v;
        self
    }
    pub fn nth10(mut self, v: Byte) -> Self {
        self.0[10] = v;
        self
    }
    pub fn nth11(mut self, v: Byte) -> Self {
        self.0[11] = v;
        self
    }
    pub fn nth12(mut self, v: Byte) -> Self {
        self.0[12] = v;
        self
    }
    pub fn nth13(mut self, v: Byte) -> Self {
        self.0[13] = v;
        self
    }
    pub fn nth14(mut self, v: Byte) -> Self {
        self.0[14] = v;
        self
    }
    pub fn nth15(mut self, v: Byte) -> Self {
        self.0[15] = v;
        self
    }
    pub fn nth16(mut self, v: Byte) -> Self {
        self.0[16] = v;
        self
    }
    pub fn nth17(mut self, v: Byte) -> Self {
        self.0[17] = v;
        self
    }
    pub fn nth18(mut self, v: Byte) -> Self {
        self.0[18] = v;
        self
    }
    pub fn nth19(mut self, v: Byte) -> Self {
        self.0[19] = v;
        self
    }
    pub fn nth20(mut self, v: Byte) -> Self {
        self.0[20] = v;
        self
    }
    pub fn nth21(mut self, v: Byte) -> Self {
        self.0[21] = v;
        self
    }
    pub fn nth22(mut self, v: Byte) -> Self {
        self.0[22] = v;
        self
    }
    pub fn nth23(mut self, v: Byte) -> Self {
        self.0[23] = v;
        self
    }
    pub fn nth24(mut self, v: Byte) -> Self {
        self.0[24] = v;
        self
    }
    pub fn nth25(mut self, v: Byte) -> Self {
        self.0[25] = v;
        self
    }
    pub fn nth26(mut self, v: Byte) -> Self {
        self.0[26] = v;
        self
    }
    pub fn nth27(mut self, v: Byte) -> Self {
        self.0[27] = v;
        self
    }
    pub fn nth28(mut self, v: Byte) -> Self {
        self.0[28] = v;
        self
    }
    pub fn nth29(mut self, v: Byte) -> Self {
        self.0[29] = v;
        self
    }
    pub fn nth30(mut self, v: Byte) -> Self {
        self.0[30] = v;
        self
    }
    pub fn nth31(mut self, v: Byte) -> Self {
        self.0[31] = v;
        self
    }
}
impl molecule::prelude::Builder for Byte32Builder {
    type Entity = Byte32;
    const NAME: &'static str = "Byte32Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        writer.write_all(self.0[8].as_slice())?;
        writer.write_all(self.0[9].as_slice())?;
        writer.write_all(self.0[10].as_slice())?;
        writer.write_all(self.0[11].as_slice())?;
        writer.write_all(self.0[12].as_slice())?;
        writer.write_all(self.0[13].as_slice())?;
        writer.write_all(self.0[14].as_slice())?;
        writer.write_all(self.0[15].as_slice())?;
        writer.write_all(self.0[16].as_slice())?;
        writer.write_all(self.0[17].as_slice())?;
        writer.write_all(self.0[18].as_slice())?;
        writer.write_all(self.0[19].as_slice())?;
        writer.write_all(self.0[20].as_slice())?;
        writer.write_all(self.0[21].as_slice())?;
        writer.write_all(self.0[22].as_slice())?;
        writer.write_all(self.0[23].as_slice())?;
        writer.write_all(self.0[24].as_slice())?;
        writer.write_all(self.0[25].as_slice())?;
        writer.write_all(self.0[26].as_slice())?;
        writer.write_all(self.0[27].as_slice())?;
        writer.write_all(self.0[28].as_slice())?;
        writer.write_all(self.0[29].as_slice())?;
        writer.write_all(self.0[30].as_slice())?;
        writer.write_all(self.0[31].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Byte32::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Bytes(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Bytes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Bytes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Bytes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Bytes {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Bytes::new_unchecked(v)
    }
}
impl Bytes {
    const DEFAULT_VALUE: [u8; 4] = [0, 0, 0, 0];
    pub const ITEM_SIZE: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Byte> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Byte {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.0.slice(molecule::NUMBER_SIZE..)
    }
    pub fn as_reader<'r>(&'r self) -> BytesReader<'r> {
        BytesReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Bytes {
    type Builder = BytesBuilder;
    const NAME: &'static str = "Bytes";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Bytes(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BytesReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BytesReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct BytesReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BytesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BytesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BytesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> BytesReader<'r> {
    pub const ITEM_SIZE: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<ByteReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> ByteReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        &self.as_slice()[molecule::NUMBER_SIZE..]
    }
}
impl<'r> molecule::prelude::Reader<'r> for BytesReader<'r> {
    type Entity = Bytes;
    const NAME: &'static str = "BytesReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BytesReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct BytesBuilder(pub(crate) Vec<Byte>);
impl BytesBuilder {
    pub const ITEM_SIZE: usize = 1;
    pub fn set(mut self, v: Vec<Byte>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Byte) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Byte>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Byte) -> Option<Byte> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for BytesBuilder {
    type Entity = Bytes;
    const NAME: &'static str = "BytesBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Bytes::new_unchecked(inner.into())
    }
}
pub struct BytesIterator(Bytes, usize, usize);
impl ::core::iter::Iterator for BytesIterator {
    type Item = Byte;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for BytesIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for Bytes {
    type Item = Byte;
    type IntoIter = BytesIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        BytesIterator(self, 0, len)
    }
}
#[derive(Clone)]
pub struct Script(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Script {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Script {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Script {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "code_hash", self.code_hash())?;
        write!(f, ", {}: {}", "hash_type", self.hash_type())?;
        write!(f, ", {}: {}", "args", self.args())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Script {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Script::new_unchecked(v)
    }
}
impl Script {
    const DEFAULT_VALUE: [u8; 53] = [
        53, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn code_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn hash_type(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn args(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Bytes::new_unchecked(self.0.slice(start..end))
        } else {
            Bytes::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ScriptReader<'r> {
        ScriptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Script {
    type Builder = ScriptBuilder;
    const NAME: &'static str = "Script";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Script(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ScriptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ScriptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .code_hash(self.code_hash())
            .hash_type(self.hash_type())
            .args(self.args())
    }
}
#[derive(Clone, Copy)]
pub struct ScriptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ScriptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ScriptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ScriptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "code_hash", self.code_hash())?;
        write!(f, ", {}: {}", "hash_type", self.hash_type())?;
        write!(f, ", {}: {}", "args", self.args())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ScriptReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn code_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn hash_type(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn args(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            BytesReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ScriptReader<'r> {
    type Entity = Script;
    const NAME: &'static str = "ScriptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ScriptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        ByteReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        BytesReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct ScriptBuilder {
    pub(crate) code_hash: Byte32,
    pub(crate) hash_type: Byte,
    pub(crate) args: Bytes,
}
impl ScriptBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn code_hash(mut self, v: Byte32) -> Self {
        self.code_hash = v;
        self
    }
    pub fn hash_type(mut self, v: Byte) -> Self {
        self.hash_type = v;
        self
    }
    pub fn args(mut self, v: Bytes) -> Self {
        self.args = v;
        self
    }
}
impl molecule::prelude::Builder for ScriptBuilder {
    type Entity = Script;
    const NAME: &'static str = "ScriptBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.code_hash.as_slice().len()
            + self.hash_type.as_slice().len()
            + self.args.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.code_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.hash_type.as_slice().len();
        offsets.push(total_size);
        total_size += self.args.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.code_hash.as_slice())?;
        writer.write_all(self.hash_type.as_slice())?;
        writer.write_all(self.args.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Script::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Address(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Address {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Address {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Address {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for Address {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Address::new_unchecked(v)
    }
}
impl Address {
    const DEFAULT_VALUE: [u8; 57] = [
        0, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const ITEMS_COUNT: usize = 1;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> AddressUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => Script::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> AddressReader<'r> {
        AddressReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Address {
    type Builder = AddressBuilder;
    const NAME: &'static str = "Address";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Address(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AddressReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AddressReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct AddressReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for AddressReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for AddressReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for AddressReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> AddressReader<'r> {
    pub const ITEMS_COUNT: usize = 1;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> AddressUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => ScriptReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for AddressReader<'r> {
    type Entity = Address;
    const NAME: &'static str = "AddressReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        AddressReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => ScriptReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct AddressBuilder(pub(crate) AddressUnion);
impl AddressBuilder {
    pub const ITEMS_COUNT: usize = 1;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<AddressUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for AddressBuilder {
    type Entity = Address;
    const NAME: &'static str = "AddressBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Address::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum AddressUnion {
    Script(Script),
}
#[derive(Debug, Clone, Copy)]
pub enum AddressUnionReader<'r> {
    Script(ScriptReader<'r>),
}
impl ::core::default::Default for AddressUnion {
    fn default() -> Self {
        AddressUnion::Script(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for AddressUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            AddressUnion::Script(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Script::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for AddressUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            AddressUnionReader::Script(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Script::NAME, item)
            }
        }
    }
}
impl AddressUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            AddressUnion::Script(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> AddressUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            AddressUnionReader::Script(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<Script> for AddressUnion {
    fn from(item: Script) -> Self {
        AddressUnion::Script(item)
    }
}
impl<'r> ::core::convert::From<ScriptReader<'r>> for AddressUnionReader<'r> {
    fn from(item: ScriptReader<'r>) -> Self {
        AddressUnionReader::Script(item)
    }
}
impl AddressUnion {
    pub const NAME: &'static str = "AddressUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            AddressUnion::Script(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            AddressUnion::Script(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            AddressUnion::Script(_) => 0,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            AddressUnion::Script(_) => "Script",
        }
    }
    pub fn as_reader<'r>(&'r self) -> AddressUnionReader<'r> {
        match self {
            AddressUnion::Script(item) => item.as_reader().into(),
        }
    }
}
impl<'r> AddressUnionReader<'r> {
    pub const NAME: &'r str = "AddressUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            AddressUnionReader::Script(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            AddressUnionReader::Script(_) => 0,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            AddressUnionReader::Script(_) => "Script",
        }
    }
}
#[derive(Clone)]
pub struct MintSpore(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for MintSpore {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for MintSpore {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for MintSpore {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "spore_id", self.spore_id())?;
        write!(f, ", {}: {}", "to", self.to())?;
        write!(f, ", {}: {}", "data_hash", self.data_hash())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for MintSpore {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        MintSpore::new_unchecked(v)
    }
}
impl MintSpore {
    const DEFAULT_VALUE: [u8; 137] = [
        137, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 105, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16, 0,
        0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn spore_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn to(&self) -> Address {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Address::new_unchecked(self.0.slice(start..end))
    }
    pub fn data_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Byte32::new_unchecked(self.0.slice(start..end))
        } else {
            Byte32::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> MintSporeReader<'r> {
        MintSporeReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for MintSpore {
    type Builder = MintSporeBuilder;
    const NAME: &'static str = "MintSpore";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        MintSpore(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        MintSporeReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        MintSporeReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .spore_id(self.spore_id())
            .to(self.to())
            .data_hash(self.data_hash())
    }
}
#[derive(Clone, Copy)]
pub struct MintSporeReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for MintSporeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for MintSporeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for MintSporeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "spore_id", self.spore_id())?;
        write!(f, ", {}: {}", "to", self.to())?;
        write!(f, ", {}: {}", "data_hash", self.data_hash())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> MintSporeReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn spore_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn to(&self) -> AddressReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        AddressReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn data_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Byte32Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Byte32Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for MintSporeReader<'r> {
    type Entity = MintSpore;
    const NAME: &'static str = "MintSporeReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        MintSporeReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        AddressReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Byte32Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct MintSporeBuilder {
    pub(crate) spore_id: Byte32,
    pub(crate) to: Address,
    pub(crate) data_hash: Byte32,
}
impl MintSporeBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn spore_id(mut self, v: Byte32) -> Self {
        self.spore_id = v;
        self
    }
    pub fn to(mut self, v: Address) -> Self {
        self.to = v;
        self
    }
    pub fn data_hash(mut self, v: Byte32) -> Self {
        self.data_hash = v;
        self
    }
}
impl molecule::prelude::Builder for MintSporeBuilder {
    type Entity = MintSpore;
    const NAME: &'static str = "MintSporeBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.spore_id.as_slice().len()
            + self.to.as_slice().len()
            + self.data_hash.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.spore_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.to.as_slice().len();
        offsets.push(total_size);
        total_size += self.data_hash.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.spore_id.as_slice())?;
        writer.write_all(self.to.as_slice())?;
        writer.write_all(self.data_hash.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        MintSpore::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TransferSpore(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TransferSpore {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TransferSpore {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TransferSpore {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "spore_id", self.spore_id())?;
        write!(f, ", {}: {}", "from", self.from())?;
        write!(f, ", {}: {}", "to", self.to())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for TransferSpore {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TransferSpore::new_unchecked(v)
    }
}
impl TransferSpore {
    const DEFAULT_VALUE: [u8; 162] = [
        162, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 105, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16, 0,
        0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0,
        48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn spore_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn from(&self) -> Address {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Address::new_unchecked(self.0.slice(start..end))
    }
    pub fn to(&self) -> Address {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Address::new_unchecked(self.0.slice(start..end))
        } else {
            Address::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TransferSporeReader<'r> {
        TransferSporeReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TransferSpore {
    type Builder = TransferSporeBuilder;
    const NAME: &'static str = "TransferSpore";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TransferSpore(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TransferSporeReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TransferSporeReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .spore_id(self.spore_id())
            .from(self.from())
            .to(self.to())
    }
}
#[derive(Clone, Copy)]
pub struct TransferSporeReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TransferSporeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TransferSporeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TransferSporeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "spore_id", self.spore_id())?;
        write!(f, ", {}: {}", "from", self.from())?;
        write!(f, ", {}: {}", "to", self.to())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> TransferSporeReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn spore_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn from(&self) -> AddressReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        AddressReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn to(&self) -> AddressReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            AddressReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            AddressReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TransferSporeReader<'r> {
    type Entity = TransferSpore;
    const NAME: &'static str = "TransferSporeReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TransferSporeReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        AddressReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        AddressReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TransferSporeBuilder {
    pub(crate) spore_id: Byte32,
    pub(crate) from: Address,
    pub(crate) to: Address,
}
impl TransferSporeBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn spore_id(mut self, v: Byte32) -> Self {
        self.spore_id = v;
        self
    }
    pub fn from(mut self, v: Address) -> Self {
        self.from = v;
        self
    }
    pub fn to(mut self, v: Address) -> Self {
        self.to = v;
        self
    }
}
impl molecule::prelude::Builder for TransferSporeBuilder {
    type Entity = TransferSpore;
    const NAME: &'static str = "TransferSporeBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.spore_id.as_slice().len()
            + self.from.as_slice().len()
            + self.to.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.spore_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.from.as_slice().len();
        offsets.push(total_size);
        total_size += self.to.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.spore_id.as_slice())?;
        writer.write_all(self.from.as_slice())?;
        writer.write_all(self.to.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TransferSpore::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct BurnSpore(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BurnSpore {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BurnSpore {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BurnSpore {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "spore_id", self.spore_id())?;
        write!(f, ", {}: {}", "from", self.from())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for BurnSpore {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        BurnSpore::new_unchecked(v)
    }
}
impl BurnSpore {
    const DEFAULT_VALUE: [u8; 101] = [
        101, 0, 0, 0, 12, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0, 48, 0,
        0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn spore_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn from(&self) -> Address {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Address::new_unchecked(self.0.slice(start..end))
        } else {
            Address::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BurnSporeReader<'r> {
        BurnSporeReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BurnSpore {
    type Builder = BurnSporeBuilder;
    const NAME: &'static str = "BurnSpore";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BurnSpore(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BurnSporeReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BurnSporeReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .spore_id(self.spore_id())
            .from(self.from())
    }
}
#[derive(Clone, Copy)]
pub struct BurnSporeReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BurnSporeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BurnSporeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BurnSporeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "spore_id", self.spore_id())?;
        write!(f, ", {}: {}", "from", self.from())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> BurnSporeReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn spore_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn from(&self) -> AddressReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            AddressReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            AddressReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BurnSporeReader<'r> {
    type Entity = BurnSpore;
    const NAME: &'static str = "BurnSporeReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BurnSporeReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        AddressReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct BurnSporeBuilder {
    pub(crate) spore_id: Byte32,
    pub(crate) from: Address,
}
impl BurnSporeBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn spore_id(mut self, v: Byte32) -> Self {
        self.spore_id = v;
        self
    }
    pub fn from(mut self, v: Address) -> Self {
        self.from = v;
        self
    }
}
impl molecule::prelude::Builder for BurnSporeBuilder {
    type Entity = BurnSpore;
    const NAME: &'static str = "BurnSporeBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.spore_id.as_slice().len()
            + self.from.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.spore_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.from.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.spore_id.as_slice())?;
        writer.write_all(self.from.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BurnSpore::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct MintCluster(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for MintCluster {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for MintCluster {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for MintCluster {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cluster_id", self.cluster_id())?;
        write!(f, ", {}: {}", "to", self.to())?;
        write!(f, ", {}: {}", "data_hash", self.data_hash())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for MintCluster {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        MintCluster::new_unchecked(v)
    }
}
impl MintCluster {
    const DEFAULT_VALUE: [u8; 137] = [
        137, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 105, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16, 0,
        0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cluster_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn to(&self) -> Address {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Address::new_unchecked(self.0.slice(start..end))
    }
    pub fn data_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Byte32::new_unchecked(self.0.slice(start..end))
        } else {
            Byte32::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> MintClusterReader<'r> {
        MintClusterReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for MintCluster {
    type Builder = MintClusterBuilder;
    const NAME: &'static str = "MintCluster";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        MintCluster(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        MintClusterReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        MintClusterReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .cluster_id(self.cluster_id())
            .to(self.to())
            .data_hash(self.data_hash())
    }
}
#[derive(Clone, Copy)]
pub struct MintClusterReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for MintClusterReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for MintClusterReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for MintClusterReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cluster_id", self.cluster_id())?;
        write!(f, ", {}: {}", "to", self.to())?;
        write!(f, ", {}: {}", "data_hash", self.data_hash())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> MintClusterReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cluster_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn to(&self) -> AddressReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        AddressReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn data_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Byte32Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Byte32Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for MintClusterReader<'r> {
    type Entity = MintCluster;
    const NAME: &'static str = "MintClusterReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        MintClusterReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        AddressReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Byte32Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct MintClusterBuilder {
    pub(crate) cluster_id: Byte32,
    pub(crate) to: Address,
    pub(crate) data_hash: Byte32,
}
impl MintClusterBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn cluster_id(mut self, v: Byte32) -> Self {
        self.cluster_id = v;
        self
    }
    pub fn to(mut self, v: Address) -> Self {
        self.to = v;
        self
    }
    pub fn data_hash(mut self, v: Byte32) -> Self {
        self.data_hash = v;
        self
    }
}
impl molecule::prelude::Builder for MintClusterBuilder {
    type Entity = MintCluster;
    const NAME: &'static str = "MintClusterBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.cluster_id.as_slice().len()
            + self.to.as_slice().len()
            + self.data_hash.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.cluster_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.to.as_slice().len();
        offsets.push(total_size);
        total_size += self.data_hash.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.cluster_id.as_slice())?;
        writer.write_all(self.to.as_slice())?;
        writer.write_all(self.data_hash.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        MintCluster::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TransferCluster(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TransferCluster {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TransferCluster {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TransferCluster {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cluster_id", self.cluster_id())?;
        write!(f, ", {}: {}", "from", self.from())?;
        write!(f, ", {}: {}", "to", self.to())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for TransferCluster {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TransferCluster::new_unchecked(v)
    }
}
impl TransferCluster {
    const DEFAULT_VALUE: [u8; 162] = [
        162, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 105, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16, 0,
        0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0,
        48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cluster_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn from(&self) -> Address {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Address::new_unchecked(self.0.slice(start..end))
    }
    pub fn to(&self) -> Address {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Address::new_unchecked(self.0.slice(start..end))
        } else {
            Address::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TransferClusterReader<'r> {
        TransferClusterReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TransferCluster {
    type Builder = TransferClusterBuilder;
    const NAME: &'static str = "TransferCluster";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TransferCluster(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TransferClusterReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TransferClusterReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .cluster_id(self.cluster_id())
            .from(self.from())
            .to(self.to())
    }
}
#[derive(Clone, Copy)]
pub struct TransferClusterReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TransferClusterReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TransferClusterReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TransferClusterReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cluster_id", self.cluster_id())?;
        write!(f, ", {}: {}", "from", self.from())?;
        write!(f, ", {}: {}", "to", self.to())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> TransferClusterReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cluster_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn from(&self) -> AddressReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        AddressReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn to(&self) -> AddressReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            AddressReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            AddressReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TransferClusterReader<'r> {
    type Entity = TransferCluster;
    const NAME: &'static str = "TransferClusterReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TransferClusterReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        AddressReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        AddressReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TransferClusterBuilder {
    pub(crate) cluster_id: Byte32,
    pub(crate) from: Address,
    pub(crate) to: Address,
}
impl TransferClusterBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn cluster_id(mut self, v: Byte32) -> Self {
        self.cluster_id = v;
        self
    }
    pub fn from(mut self, v: Address) -> Self {
        self.from = v;
        self
    }
    pub fn to(mut self, v: Address) -> Self {
        self.to = v;
        self
    }
}
impl molecule::prelude::Builder for TransferClusterBuilder {
    type Entity = TransferCluster;
    const NAME: &'static str = "TransferClusterBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.cluster_id.as_slice().len()
            + self.from.as_slice().len()
            + self.to.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.cluster_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.from.as_slice().len();
        offsets.push(total_size);
        total_size += self.to.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.cluster_id.as_slice())?;
        writer.write_all(self.from.as_slice())?;
        writer.write_all(self.to.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TransferCluster::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct MintProxy(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for MintProxy {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for MintProxy {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for MintProxy {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cluster_id", self.cluster_id())?;
        write!(f, ", {}: {}", "proxy_id", self.proxy_id())?;
        write!(f, ", {}: {}", "to", self.to())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for MintProxy {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        MintProxy::new_unchecked(v)
    }
}
impl MintProxy {
    const DEFAULT_VALUE: [u8; 137] = [
        137, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16,
        0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cluster_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn proxy_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn to(&self) -> Address {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Address::new_unchecked(self.0.slice(start..end))
        } else {
            Address::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> MintProxyReader<'r> {
        MintProxyReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for MintProxy {
    type Builder = MintProxyBuilder;
    const NAME: &'static str = "MintProxy";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        MintProxy(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        MintProxyReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        MintProxyReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .cluster_id(self.cluster_id())
            .proxy_id(self.proxy_id())
            .to(self.to())
    }
}
#[derive(Clone, Copy)]
pub struct MintProxyReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for MintProxyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for MintProxyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for MintProxyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cluster_id", self.cluster_id())?;
        write!(f, ", {}: {}", "proxy_id", self.proxy_id())?;
        write!(f, ", {}: {}", "to", self.to())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> MintProxyReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cluster_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proxy_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn to(&self) -> AddressReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            AddressReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            AddressReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for MintProxyReader<'r> {
    type Entity = MintProxy;
    const NAME: &'static str = "MintProxyReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        MintProxyReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        AddressReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct MintProxyBuilder {
    pub(crate) cluster_id: Byte32,
    pub(crate) proxy_id: Byte32,
    pub(crate) to: Address,
}
impl MintProxyBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn cluster_id(mut self, v: Byte32) -> Self {
        self.cluster_id = v;
        self
    }
    pub fn proxy_id(mut self, v: Byte32) -> Self {
        self.proxy_id = v;
        self
    }
    pub fn to(mut self, v: Address) -> Self {
        self.to = v;
        self
    }
}
impl molecule::prelude::Builder for MintProxyBuilder {
    type Entity = MintProxy;
    const NAME: &'static str = "MintProxyBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.cluster_id.as_slice().len()
            + self.proxy_id.as_slice().len()
            + self.to.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.cluster_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.proxy_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.to.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.cluster_id.as_slice())?;
        writer.write_all(self.proxy_id.as_slice())?;
        writer.write_all(self.to.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        MintProxy::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TransferProxy(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TransferProxy {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TransferProxy {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TransferProxy {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cluster_id", self.cluster_id())?;
        write!(f, ", {}: {}", "proxy_id", self.proxy_id())?;
        write!(f, ", {}: {}", "from", self.from())?;
        write!(f, ", {}: {}", "to", self.to())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for TransferProxy {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TransferProxy::new_unchecked(v)
    }
}
impl TransferProxy {
    const DEFAULT_VALUE: [u8; 198] = [
        198, 0, 0, 0, 20, 0, 0, 0, 52, 0, 0, 0, 84, 0, 0, 0, 141, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        53, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0,
        0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cluster_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn proxy_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn from(&self) -> Address {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Address::new_unchecked(self.0.slice(start..end))
    }
    pub fn to(&self) -> Address {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            Address::new_unchecked(self.0.slice(start..end))
        } else {
            Address::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TransferProxyReader<'r> {
        TransferProxyReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TransferProxy {
    type Builder = TransferProxyBuilder;
    const NAME: &'static str = "TransferProxy";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TransferProxy(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TransferProxyReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TransferProxyReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .cluster_id(self.cluster_id())
            .proxy_id(self.proxy_id())
            .from(self.from())
            .to(self.to())
    }
}
#[derive(Clone, Copy)]
pub struct TransferProxyReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TransferProxyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TransferProxyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TransferProxyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cluster_id", self.cluster_id())?;
        write!(f, ", {}: {}", "proxy_id", self.proxy_id())?;
        write!(f, ", {}: {}", "from", self.from())?;
        write!(f, ", {}: {}", "to", self.to())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> TransferProxyReader<'r> {
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cluster_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proxy_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn from(&self) -> AddressReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        AddressReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn to(&self) -> AddressReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            AddressReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            AddressReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TransferProxyReader<'r> {
    type Entity = TransferProxy;
    const NAME: &'static str = "TransferProxyReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TransferProxyReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        AddressReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        AddressReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TransferProxyBuilder {
    pub(crate) cluster_id: Byte32,
    pub(crate) proxy_id: Byte32,
    pub(crate) from: Address,
    pub(crate) to: Address,
}
impl TransferProxyBuilder {
    pub const FIELD_COUNT: usize = 4;
    pub fn cluster_id(mut self, v: Byte32) -> Self {
        self.cluster_id = v;
        self
    }
    pub fn proxy_id(mut self, v: Byte32) -> Self {
        self.proxy_id = v;
        self
    }
    pub fn from(mut self, v: Address) -> Self {
        self.from = v;
        self
    }
    pub fn to(mut self, v: Address) -> Self {
        self.to = v;
        self
    }
}
impl molecule::prelude::Builder for TransferProxyBuilder {
    type Entity = TransferProxy;
    const NAME: &'static str = "TransferProxyBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.cluster_id.as_slice().len()
            + self.proxy_id.as_slice().len()
            + self.from.as_slice().len()
            + self.to.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.cluster_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.proxy_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.from.as_slice().len();
        offsets.push(total_size);
        total_size += self.to.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.cluster_id.as_slice())?;
        writer.write_all(self.proxy_id.as_slice())?;
        writer.write_all(self.from.as_slice())?;
        writer.write_all(self.to.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TransferProxy::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct BurnProxy(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BurnProxy {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BurnProxy {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BurnProxy {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cluster_id", self.cluster_id())?;
        write!(f, ", {}: {}", "proxy_id", self.proxy_id())?;
        write!(f, ", {}: {}", "from", self.from())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for BurnProxy {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        BurnProxy::new_unchecked(v)
    }
}
impl BurnProxy {
    const DEFAULT_VALUE: [u8; 137] = [
        137, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16,
        0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cluster_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn proxy_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn from(&self) -> Address {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Address::new_unchecked(self.0.slice(start..end))
        } else {
            Address::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BurnProxyReader<'r> {
        BurnProxyReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BurnProxy {
    type Builder = BurnProxyBuilder;
    const NAME: &'static str = "BurnProxy";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BurnProxy(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BurnProxyReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BurnProxyReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .cluster_id(self.cluster_id())
            .proxy_id(self.proxy_id())
            .from(self.from())
    }
}
#[derive(Clone, Copy)]
pub struct BurnProxyReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BurnProxyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BurnProxyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BurnProxyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cluster_id", self.cluster_id())?;
        write!(f, ", {}: {}", "proxy_id", self.proxy_id())?;
        write!(f, ", {}: {}", "from", self.from())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> BurnProxyReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cluster_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proxy_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn from(&self) -> AddressReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            AddressReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            AddressReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BurnProxyReader<'r> {
    type Entity = BurnProxy;
    const NAME: &'static str = "BurnProxyReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BurnProxyReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        AddressReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct BurnProxyBuilder {
    pub(crate) cluster_id: Byte32,
    pub(crate) proxy_id: Byte32,
    pub(crate) from: Address,
}
impl BurnProxyBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn cluster_id(mut self, v: Byte32) -> Self {
        self.cluster_id = v;
        self
    }
    pub fn proxy_id(mut self, v: Byte32) -> Self {
        self.proxy_id = v;
        self
    }
    pub fn from(mut self, v: Address) -> Self {
        self.from = v;
        self
    }
}
impl molecule::prelude::Builder for BurnProxyBuilder {
    type Entity = BurnProxy;
    const NAME: &'static str = "BurnProxyBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.cluster_id.as_slice().len()
            + self.proxy_id.as_slice().len()
            + self.from.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.cluster_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.proxy_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.from.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.cluster_id.as_slice())?;
        writer.write_all(self.proxy_id.as_slice())?;
        writer.write_all(self.from.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BurnProxy::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct MintAgent(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for MintAgent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for MintAgent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for MintAgent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cluster_id", self.cluster_id())?;
        write!(f, ", {}: {}", "proxy_id", self.proxy_id())?;
        write!(f, ", {}: {}", "to", self.to())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for MintAgent {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        MintAgent::new_unchecked(v)
    }
}
impl MintAgent {
    const DEFAULT_VALUE: [u8; 137] = [
        137, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16,
        0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cluster_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn proxy_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn to(&self) -> Address {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Address::new_unchecked(self.0.slice(start..end))
        } else {
            Address::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> MintAgentReader<'r> {
        MintAgentReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for MintAgent {
    type Builder = MintAgentBuilder;
    const NAME: &'static str = "MintAgent";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        MintAgent(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        MintAgentReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        MintAgentReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .cluster_id(self.cluster_id())
            .proxy_id(self.proxy_id())
            .to(self.to())
    }
}
#[derive(Clone, Copy)]
pub struct MintAgentReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for MintAgentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for MintAgentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for MintAgentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cluster_id", self.cluster_id())?;
        write!(f, ", {}: {}", "proxy_id", self.proxy_id())?;
        write!(f, ", {}: {}", "to", self.to())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> MintAgentReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cluster_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proxy_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn to(&self) -> AddressReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            AddressReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            AddressReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for MintAgentReader<'r> {
    type Entity = MintAgent;
    const NAME: &'static str = "MintAgentReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        MintAgentReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        AddressReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct MintAgentBuilder {
    pub(crate) cluster_id: Byte32,
    pub(crate) proxy_id: Byte32,
    pub(crate) to: Address,
}
impl MintAgentBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn cluster_id(mut self, v: Byte32) -> Self {
        self.cluster_id = v;
        self
    }
    pub fn proxy_id(mut self, v: Byte32) -> Self {
        self.proxy_id = v;
        self
    }
    pub fn to(mut self, v: Address) -> Self {
        self.to = v;
        self
    }
}
impl molecule::prelude::Builder for MintAgentBuilder {
    type Entity = MintAgent;
    const NAME: &'static str = "MintAgentBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.cluster_id.as_slice().len()
            + self.proxy_id.as_slice().len()
            + self.to.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.cluster_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.proxy_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.to.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.cluster_id.as_slice())?;
        writer.write_all(self.proxy_id.as_slice())?;
        writer.write_all(self.to.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        MintAgent::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TransferAgent(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TransferAgent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TransferAgent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TransferAgent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cluster_id", self.cluster_id())?;
        write!(f, ", {}: {}", "from", self.from())?;
        write!(f, ", {}: {}", "to", self.to())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for TransferAgent {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TransferAgent::new_unchecked(v)
    }
}
impl TransferAgent {
    const DEFAULT_VALUE: [u8; 162] = [
        162, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 105, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16, 0,
        0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0,
        48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cluster_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn from(&self) -> Address {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Address::new_unchecked(self.0.slice(start..end))
    }
    pub fn to(&self) -> Address {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Address::new_unchecked(self.0.slice(start..end))
        } else {
            Address::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TransferAgentReader<'r> {
        TransferAgentReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TransferAgent {
    type Builder = TransferAgentBuilder;
    const NAME: &'static str = "TransferAgent";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TransferAgent(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TransferAgentReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TransferAgentReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .cluster_id(self.cluster_id())
            .from(self.from())
            .to(self.to())
    }
}
#[derive(Clone, Copy)]
pub struct TransferAgentReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TransferAgentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TransferAgentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TransferAgentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cluster_id", self.cluster_id())?;
        write!(f, ", {}: {}", "from", self.from())?;
        write!(f, ", {}: {}", "to", self.to())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> TransferAgentReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cluster_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn from(&self) -> AddressReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        AddressReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn to(&self) -> AddressReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            AddressReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            AddressReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TransferAgentReader<'r> {
    type Entity = TransferAgent;
    const NAME: &'static str = "TransferAgentReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TransferAgentReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        AddressReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        AddressReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TransferAgentBuilder {
    pub(crate) cluster_id: Byte32,
    pub(crate) from: Address,
    pub(crate) to: Address,
}
impl TransferAgentBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn cluster_id(mut self, v: Byte32) -> Self {
        self.cluster_id = v;
        self
    }
    pub fn from(mut self, v: Address) -> Self {
        self.from = v;
        self
    }
    pub fn to(mut self, v: Address) -> Self {
        self.to = v;
        self
    }
}
impl molecule::prelude::Builder for TransferAgentBuilder {
    type Entity = TransferAgent;
    const NAME: &'static str = "TransferAgentBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.cluster_id.as_slice().len()
            + self.from.as_slice().len()
            + self.to.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.cluster_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.from.as_slice().len();
        offsets.push(total_size);
        total_size += self.to.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.cluster_id.as_slice())?;
        writer.write_all(self.from.as_slice())?;
        writer.write_all(self.to.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TransferAgent::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct BurnAgent(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BurnAgent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BurnAgent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BurnAgent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cluster_id", self.cluster_id())?;
        write!(f, ", {}: {}", "from", self.from())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for BurnAgent {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        BurnAgent::new_unchecked(v)
    }
}
impl BurnAgent {
    const DEFAULT_VALUE: [u8; 101] = [
        101, 0, 0, 0, 12, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0, 48, 0,
        0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cluster_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn from(&self) -> Address {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Address::new_unchecked(self.0.slice(start..end))
        } else {
            Address::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BurnAgentReader<'r> {
        BurnAgentReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BurnAgent {
    type Builder = BurnAgentBuilder;
    const NAME: &'static str = "BurnAgent";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BurnAgent(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BurnAgentReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BurnAgentReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .cluster_id(self.cluster_id())
            .from(self.from())
    }
}
#[derive(Clone, Copy)]
pub struct BurnAgentReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BurnAgentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BurnAgentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BurnAgentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cluster_id", self.cluster_id())?;
        write!(f, ", {}: {}", "from", self.from())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> BurnAgentReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cluster_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn from(&self) -> AddressReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            AddressReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            AddressReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BurnAgentReader<'r> {
    type Entity = BurnAgent;
    const NAME: &'static str = "BurnAgentReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BurnAgentReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        AddressReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct BurnAgentBuilder {
    pub(crate) cluster_id: Byte32,
    pub(crate) from: Address,
}
impl BurnAgentBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn cluster_id(mut self, v: Byte32) -> Self {
        self.cluster_id = v;
        self
    }
    pub fn from(mut self, v: Address) -> Self {
        self.from = v;
        self
    }
}
impl molecule::prelude::Builder for BurnAgentBuilder {
    type Entity = BurnAgent;
    const NAME: &'static str = "BurnAgentBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.cluster_id.as_slice().len()
            + self.from.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.cluster_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.from.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.cluster_id.as_slice())?;
        writer.write_all(self.from.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BurnAgent::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SporeAction(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SporeAction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SporeAction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SporeAction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for SporeAction {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        SporeAction::new_unchecked(v)
    }
}
impl SporeAction {
    const DEFAULT_VALUE: [u8; 141] = [
        0, 0, 0, 0, 137, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 105, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0,
        0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const ITEMS_COUNT: usize = 11;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> SporeActionUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => MintSpore::new_unchecked(inner).into(),
            1 => TransferSpore::new_unchecked(inner).into(),
            2 => BurnSpore::new_unchecked(inner).into(),
            3 => MintCluster::new_unchecked(inner).into(),
            4 => TransferCluster::new_unchecked(inner).into(),
            5 => MintProxy::new_unchecked(inner).into(),
            6 => TransferProxy::new_unchecked(inner).into(),
            7 => BurnProxy::new_unchecked(inner).into(),
            8 => MintAgent::new_unchecked(inner).into(),
            9 => TransferAgent::new_unchecked(inner).into(),
            10 => BurnAgent::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> SporeActionReader<'r> {
        SporeActionReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SporeAction {
    type Builder = SporeActionBuilder;
    const NAME: &'static str = "SporeAction";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SporeAction(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SporeActionReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SporeActionReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct SporeActionReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SporeActionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SporeActionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SporeActionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> SporeActionReader<'r> {
    pub const ITEMS_COUNT: usize = 11;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> SporeActionUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => MintSporeReader::new_unchecked(inner).into(),
            1 => TransferSporeReader::new_unchecked(inner).into(),
            2 => BurnSporeReader::new_unchecked(inner).into(),
            3 => MintClusterReader::new_unchecked(inner).into(),
            4 => TransferClusterReader::new_unchecked(inner).into(),
            5 => MintProxyReader::new_unchecked(inner).into(),
            6 => TransferProxyReader::new_unchecked(inner).into(),
            7 => BurnProxyReader::new_unchecked(inner).into(),
            8 => MintAgentReader::new_unchecked(inner).into(),
            9 => TransferAgentReader::new_unchecked(inner).into(),
            10 => BurnAgentReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SporeActionReader<'r> {
    type Entity = SporeAction;
    const NAME: &'static str = "SporeActionReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SporeActionReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => MintSporeReader::verify(inner_slice, compatible),
            1 => TransferSporeReader::verify(inner_slice, compatible),
            2 => BurnSporeReader::verify(inner_slice, compatible),
            3 => MintClusterReader::verify(inner_slice, compatible),
            4 => TransferClusterReader::verify(inner_slice, compatible),
            5 => MintProxyReader::verify(inner_slice, compatible),
            6 => TransferProxyReader::verify(inner_slice, compatible),
            7 => BurnProxyReader::verify(inner_slice, compatible),
            8 => MintAgentReader::verify(inner_slice, compatible),
            9 => TransferAgentReader::verify(inner_slice, compatible),
            10 => BurnAgentReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct SporeActionBuilder(pub(crate) SporeActionUnion);
impl SporeActionBuilder {
    pub const ITEMS_COUNT: usize = 11;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<SporeActionUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for SporeActionBuilder {
    type Entity = SporeAction;
    const NAME: &'static str = "SporeActionBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SporeAction::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum SporeActionUnion {
    MintSpore(MintSpore),
    TransferSpore(TransferSpore),
    BurnSpore(BurnSpore),
    MintCluster(MintCluster),
    TransferCluster(TransferCluster),
    MintProxy(MintProxy),
    TransferProxy(TransferProxy),
    BurnProxy(BurnProxy),
    MintAgent(MintAgent),
    TransferAgent(TransferAgent),
    BurnAgent(BurnAgent),
}
#[derive(Debug, Clone, Copy)]
pub enum SporeActionUnionReader<'r> {
    MintSpore(MintSporeReader<'r>),
    TransferSpore(TransferSporeReader<'r>),
    BurnSpore(BurnSporeReader<'r>),
    MintCluster(MintClusterReader<'r>),
    TransferCluster(TransferClusterReader<'r>),
    MintProxy(MintProxyReader<'r>),
    TransferProxy(TransferProxyReader<'r>),
    BurnProxy(BurnProxyReader<'r>),
    MintAgent(MintAgentReader<'r>),
    TransferAgent(TransferAgentReader<'r>),
    BurnAgent(BurnAgentReader<'r>),
}
impl ::core::default::Default for SporeActionUnion {
    fn default() -> Self {
        SporeActionUnion::MintSpore(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for SporeActionUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            SporeActionUnion::MintSpore(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, MintSpore::NAME, item)
            }
            SporeActionUnion::TransferSpore(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TransferSpore::NAME, item)
            }
            SporeActionUnion::BurnSpore(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, BurnSpore::NAME, item)
            }
            SporeActionUnion::MintCluster(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, MintCluster::NAME, item)
            }
            SporeActionUnion::TransferCluster(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TransferCluster::NAME, item)
            }
            SporeActionUnion::MintProxy(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, MintProxy::NAME, item)
            }
            SporeActionUnion::TransferProxy(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TransferProxy::NAME, item)
            }
            SporeActionUnion::BurnProxy(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, BurnProxy::NAME, item)
            }
            SporeActionUnion::MintAgent(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, MintAgent::NAME, item)
            }
            SporeActionUnion::TransferAgent(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TransferAgent::NAME, item)
            }
            SporeActionUnion::BurnAgent(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, BurnAgent::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for SporeActionUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            SporeActionUnionReader::MintSpore(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, MintSpore::NAME, item)
            }
            SporeActionUnionReader::TransferSpore(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TransferSpore::NAME, item)
            }
            SporeActionUnionReader::BurnSpore(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, BurnSpore::NAME, item)
            }
            SporeActionUnionReader::MintCluster(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, MintCluster::NAME, item)
            }
            SporeActionUnionReader::TransferCluster(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TransferCluster::NAME, item)
            }
            SporeActionUnionReader::MintProxy(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, MintProxy::NAME, item)
            }
            SporeActionUnionReader::TransferProxy(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TransferProxy::NAME, item)
            }
            SporeActionUnionReader::BurnProxy(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, BurnProxy::NAME, item)
            }
            SporeActionUnionReader::MintAgent(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, MintAgent::NAME, item)
            }
            SporeActionUnionReader::TransferAgent(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TransferAgent::NAME, item)
            }
            SporeActionUnionReader::BurnAgent(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, BurnAgent::NAME, item)
            }
        }
    }
}
impl SporeActionUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            SporeActionUnion::MintSpore(ref item) => write!(f, "{}", item),
            SporeActionUnion::TransferSpore(ref item) => write!(f, "{}", item),
            SporeActionUnion::BurnSpore(ref item) => write!(f, "{}", item),
            SporeActionUnion::MintCluster(ref item) => write!(f, "{}", item),
            SporeActionUnion::TransferCluster(ref item) => write!(f, "{}", item),
            SporeActionUnion::MintProxy(ref item) => write!(f, "{}", item),
            SporeActionUnion::TransferProxy(ref item) => write!(f, "{}", item),
            SporeActionUnion::BurnProxy(ref item) => write!(f, "{}", item),
            SporeActionUnion::MintAgent(ref item) => write!(f, "{}", item),
            SporeActionUnion::TransferAgent(ref item) => write!(f, "{}", item),
            SporeActionUnion::BurnAgent(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> SporeActionUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            SporeActionUnionReader::MintSpore(ref item) => write!(f, "{}", item),
            SporeActionUnionReader::TransferSpore(ref item) => write!(f, "{}", item),
            SporeActionUnionReader::BurnSpore(ref item) => write!(f, "{}", item),
            SporeActionUnionReader::MintCluster(ref item) => write!(f, "{}", item),
            SporeActionUnionReader::TransferCluster(ref item) => write!(f, "{}", item),
            SporeActionUnionReader::MintProxy(ref item) => write!(f, "{}", item),
            SporeActionUnionReader::TransferProxy(ref item) => write!(f, "{}", item),
            SporeActionUnionReader::BurnProxy(ref item) => write!(f, "{}", item),
            SporeActionUnionReader::MintAgent(ref item) => write!(f, "{}", item),
            SporeActionUnionReader::TransferAgent(ref item) => write!(f, "{}", item),
            SporeActionUnionReader::BurnAgent(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<MintSpore> for SporeActionUnion {
    fn from(item: MintSpore) -> Self {
        SporeActionUnion::MintSpore(item)
    }
}
impl ::core::convert::From<TransferSpore> for SporeActionUnion {
    fn from(item: TransferSpore) -> Self {
        SporeActionUnion::TransferSpore(item)
    }
}
impl ::core::convert::From<BurnSpore> for SporeActionUnion {
    fn from(item: BurnSpore) -> Self {
        SporeActionUnion::BurnSpore(item)
    }
}
impl ::core::convert::From<MintCluster> for SporeActionUnion {
    fn from(item: MintCluster) -> Self {
        SporeActionUnion::MintCluster(item)
    }
}
impl ::core::convert::From<TransferCluster> for SporeActionUnion {
    fn from(item: TransferCluster) -> Self {
        SporeActionUnion::TransferCluster(item)
    }
}
impl ::core::convert::From<MintProxy> for SporeActionUnion {
    fn from(item: MintProxy) -> Self {
        SporeActionUnion::MintProxy(item)
    }
}
impl ::core::convert::From<TransferProxy> for SporeActionUnion {
    fn from(item: TransferProxy) -> Self {
        SporeActionUnion::TransferProxy(item)
    }
}
impl ::core::convert::From<BurnProxy> for SporeActionUnion {
    fn from(item: BurnProxy) -> Self {
        SporeActionUnion::BurnProxy(item)
    }
}
impl ::core::convert::From<MintAgent> for SporeActionUnion {
    fn from(item: MintAgent) -> Self {
        SporeActionUnion::MintAgent(item)
    }
}
impl ::core::convert::From<TransferAgent> for SporeActionUnion {
    fn from(item: TransferAgent) -> Self {
        SporeActionUnion::TransferAgent(item)
    }
}
impl ::core::convert::From<BurnAgent> for SporeActionUnion {
    fn from(item: BurnAgent) -> Self {
        SporeActionUnion::BurnAgent(item)
    }
}
impl<'r> ::core::convert::From<MintSporeReader<'r>> for SporeActionUnionReader<'r> {
    fn from(item: MintSporeReader<'r>) -> Self {
        SporeActionUnionReader::MintSpore(item)
    }
}
impl<'r> ::core::convert::From<TransferSporeReader<'r>> for SporeActionUnionReader<'r> {
    fn from(item: TransferSporeReader<'r>) -> Self {
        SporeActionUnionReader::TransferSpore(item)
    }
}
impl<'r> ::core::convert::From<BurnSporeReader<'r>> for SporeActionUnionReader<'r> {
    fn from(item: BurnSporeReader<'r>) -> Self {
        SporeActionUnionReader::BurnSpore(item)
    }
}
impl<'r> ::core::convert::From<MintClusterReader<'r>> for SporeActionUnionReader<'r> {
    fn from(item: MintClusterReader<'r>) -> Self {
        SporeActionUnionReader::MintCluster(item)
    }
}
impl<'r> ::core::convert::From<TransferClusterReader<'r>> for SporeActionUnionReader<'r> {
    fn from(item: TransferClusterReader<'r>) -> Self {
        SporeActionUnionReader::TransferCluster(item)
    }
}
impl<'r> ::core::convert::From<MintProxyReader<'r>> for SporeActionUnionReader<'r> {
    fn from(item: MintProxyReader<'r>) -> Self {
        SporeActionUnionReader::MintProxy(item)
    }
}
impl<'r> ::core::convert::From<TransferProxyReader<'r>> for SporeActionUnionReader<'r> {
    fn from(item: TransferProxyReader<'r>) -> Self {
        SporeActionUnionReader::TransferProxy(item)
    }
}
impl<'r> ::core::convert::From<BurnProxyReader<'r>> for SporeActionUnionReader<'r> {
    fn from(item: BurnProxyReader<'r>) -> Self {
        SporeActionUnionReader::BurnProxy(item)
    }
}
impl<'r> ::core::convert::From<MintAgentReader<'r>> for SporeActionUnionReader<'r> {
    fn from(item: MintAgentReader<'r>) -> Self {
        SporeActionUnionReader::MintAgent(item)
    }
}
impl<'r> ::core::convert::From<TransferAgentReader<'r>> for SporeActionUnionReader<'r> {
    fn from(item: TransferAgentReader<'r>) -> Self {
        SporeActionUnionReader::TransferAgent(item)
    }
}
impl<'r> ::core::convert::From<BurnAgentReader<'r>> for SporeActionUnionReader<'r> {
    fn from(item: BurnAgentReader<'r>) -> Self {
        SporeActionUnionReader::BurnAgent(item)
    }
}
impl SporeActionUnion {
    pub const NAME: &'static str = "SporeActionUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            SporeActionUnion::MintSpore(item) => item.as_bytes(),
            SporeActionUnion::TransferSpore(item) => item.as_bytes(),
            SporeActionUnion::BurnSpore(item) => item.as_bytes(),
            SporeActionUnion::MintCluster(item) => item.as_bytes(),
            SporeActionUnion::TransferCluster(item) => item.as_bytes(),
            SporeActionUnion::MintProxy(item) => item.as_bytes(),
            SporeActionUnion::TransferProxy(item) => item.as_bytes(),
            SporeActionUnion::BurnProxy(item) => item.as_bytes(),
            SporeActionUnion::MintAgent(item) => item.as_bytes(),
            SporeActionUnion::TransferAgent(item) => item.as_bytes(),
            SporeActionUnion::BurnAgent(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            SporeActionUnion::MintSpore(item) => item.as_slice(),
            SporeActionUnion::TransferSpore(item) => item.as_slice(),
            SporeActionUnion::BurnSpore(item) => item.as_slice(),
            SporeActionUnion::MintCluster(item) => item.as_slice(),
            SporeActionUnion::TransferCluster(item) => item.as_slice(),
            SporeActionUnion::MintProxy(item) => item.as_slice(),
            SporeActionUnion::TransferProxy(item) => item.as_slice(),
            SporeActionUnion::BurnProxy(item) => item.as_slice(),
            SporeActionUnion::MintAgent(item) => item.as_slice(),
            SporeActionUnion::TransferAgent(item) => item.as_slice(),
            SporeActionUnion::BurnAgent(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            SporeActionUnion::MintSpore(_) => 0,
            SporeActionUnion::TransferSpore(_) => 1,
            SporeActionUnion::BurnSpore(_) => 2,
            SporeActionUnion::MintCluster(_) => 3,
            SporeActionUnion::TransferCluster(_) => 4,
            SporeActionUnion::MintProxy(_) => 5,
            SporeActionUnion::TransferProxy(_) => 6,
            SporeActionUnion::BurnProxy(_) => 7,
            SporeActionUnion::MintAgent(_) => 8,
            SporeActionUnion::TransferAgent(_) => 9,
            SporeActionUnion::BurnAgent(_) => 10,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            SporeActionUnion::MintSpore(_) => "MintSpore",
            SporeActionUnion::TransferSpore(_) => "TransferSpore",
            SporeActionUnion::BurnSpore(_) => "BurnSpore",
            SporeActionUnion::MintCluster(_) => "MintCluster",
            SporeActionUnion::TransferCluster(_) => "TransferCluster",
            SporeActionUnion::MintProxy(_) => "MintProxy",
            SporeActionUnion::TransferProxy(_) => "TransferProxy",
            SporeActionUnion::BurnProxy(_) => "BurnProxy",
            SporeActionUnion::MintAgent(_) => "MintAgent",
            SporeActionUnion::TransferAgent(_) => "TransferAgent",
            SporeActionUnion::BurnAgent(_) => "BurnAgent",
        }
    }
    pub fn as_reader<'r>(&'r self) -> SporeActionUnionReader<'r> {
        match self {
            SporeActionUnion::MintSpore(item) => item.as_reader().into(),
            SporeActionUnion::TransferSpore(item) => item.as_reader().into(),
            SporeActionUnion::BurnSpore(item) => item.as_reader().into(),
            SporeActionUnion::MintCluster(item) => item.as_reader().into(),
            SporeActionUnion::TransferCluster(item) => item.as_reader().into(),
            SporeActionUnion::MintProxy(item) => item.as_reader().into(),
            SporeActionUnion::TransferProxy(item) => item.as_reader().into(),
            SporeActionUnion::BurnProxy(item) => item.as_reader().into(),
            SporeActionUnion::MintAgent(item) => item.as_reader().into(),
            SporeActionUnion::TransferAgent(item) => item.as_reader().into(),
            SporeActionUnion::BurnAgent(item) => item.as_reader().into(),
        }
    }
}
impl<'r> SporeActionUnionReader<'r> {
    pub const NAME: &'r str = "SporeActionUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            SporeActionUnionReader::MintSpore(item) => item.as_slice(),
            SporeActionUnionReader::TransferSpore(item) => item.as_slice(),
            SporeActionUnionReader::BurnSpore(item) => item.as_slice(),
            SporeActionUnionReader::MintCluster(item) => item.as_slice(),
            SporeActionUnionReader::TransferCluster(item) => item.as_slice(),
            SporeActionUnionReader::MintProxy(item) => item.as_slice(),
            SporeActionUnionReader::TransferProxy(item) => item.as_slice(),
            SporeActionUnionReader::BurnProxy(item) => item.as_slice(),
            SporeActionUnionReader::MintAgent(item) => item.as_slice(),
            SporeActionUnionReader::TransferAgent(item) => item.as_slice(),
            SporeActionUnionReader::BurnAgent(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            SporeActionUnionReader::MintSpore(_) => 0,
            SporeActionUnionReader::TransferSpore(_) => 1,
            SporeActionUnionReader::BurnSpore(_) => 2,
            SporeActionUnionReader::MintCluster(_) => 3,
            SporeActionUnionReader::TransferCluster(_) => 4,
            SporeActionUnionReader::MintProxy(_) => 5,
            SporeActionUnionReader::TransferProxy(_) => 6,
            SporeActionUnionReader::BurnProxy(_) => 7,
            SporeActionUnionReader::MintAgent(_) => 8,
            SporeActionUnionReader::TransferAgent(_) => 9,
            SporeActionUnionReader::BurnAgent(_) => 10,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            SporeActionUnionReader::MintSpore(_) => "MintSpore",
            SporeActionUnionReader::TransferSpore(_) => "TransferSpore",
            SporeActionUnionReader::BurnSpore(_) => "BurnSpore",
            SporeActionUnionReader::MintCluster(_) => "MintCluster",
            SporeActionUnionReader::TransferCluster(_) => "TransferCluster",
            SporeActionUnionReader::MintProxy(_) => "MintProxy",
            SporeActionUnionReader::TransferProxy(_) => "TransferProxy",
            SporeActionUnionReader::BurnProxy(_) => "BurnProxy",
            SporeActionUnionReader::MintAgent(_) => "MintAgent",
            SporeActionUnionReader::TransferAgent(_) => "TransferAgent",
            SporeActionUnionReader::BurnAgent(_) => "BurnAgent",
        }
    }
}


================================================
File: lib/types/src/generated/mod.rs
================================================
mod spore_v1;
mod spore_v2;

pub mod spore {
    pub use super::spore_v1::*;
    pub use super::spore_v2::*;
}

pub mod action;


================================================
File: lib/types/src/generated/spore_v1.rs
================================================
// Generated by Molecule 0.7.5
#![allow(dead_code)]

use molecule::prelude::*;
#[derive(Clone)]
pub struct Bytes(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Bytes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Bytes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Bytes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Bytes {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Bytes::new_unchecked(v)
    }
}
impl Bytes {
    const DEFAULT_VALUE: [u8; 4] = [0, 0, 0, 0];
    pub const ITEM_SIZE: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Byte> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Byte {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.0.slice(molecule::NUMBER_SIZE..)
    }
    pub fn as_reader<'r>(&'r self) -> BytesReader<'r> {
        BytesReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Bytes {
    type Builder = BytesBuilder;
    const NAME: &'static str = "Bytes";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Bytes(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BytesReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BytesReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct BytesReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BytesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BytesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BytesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> BytesReader<'r> {
    pub const ITEM_SIZE: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<ByteReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> ByteReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        &self.as_slice()[molecule::NUMBER_SIZE..]
    }
}
impl<'r> molecule::prelude::Reader<'r> for BytesReader<'r> {
    type Entity = Bytes;
    const NAME: &'static str = "BytesReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BytesReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct BytesBuilder(pub(crate) Vec<Byte>);
impl BytesBuilder {
    pub const ITEM_SIZE: usize = 1;
    pub fn set(mut self, v: Vec<Byte>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Byte) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Byte>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Byte) -> Option<Byte> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for BytesBuilder {
    type Entity = Bytes;
    const NAME: &'static str = "BytesBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Bytes::new_unchecked(inner.into())
    }
}
pub struct BytesIterator(Bytes, usize, usize);
impl ::core::iter::Iterator for BytesIterator {
    type Item = Byte;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for BytesIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for Bytes {
    type Item = Byte;
    type IntoIter = BytesIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        BytesIterator(self, 0, len)
    }
}
#[derive(Clone)]
pub struct BytesOpt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BytesOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BytesOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BytesOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for BytesOpt {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        BytesOpt::new_unchecked(v)
    }
}
impl BytesOpt {
    const DEFAULT_VALUE: [u8; 0] = [];
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Bytes> {
        if self.is_none() {
            None
        } else {
            Some(Bytes::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BytesOptReader<'r> {
        BytesOptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BytesOpt {
    type Builder = BytesOptBuilder;
    const NAME: &'static str = "BytesOpt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BytesOpt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BytesOptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BytesOptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct BytesOptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BytesOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BytesOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BytesOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> BytesOptReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<BytesReader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(BytesReader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BytesOptReader<'r> {
    type Entity = BytesOpt;
    const NAME: &'static str = "BytesOptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BytesOptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            BytesReader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct BytesOptBuilder(pub(crate) Option<Bytes>);
impl BytesOptBuilder {
    pub fn set(mut self, v: Option<Bytes>) -> Self {
        self.0 = v;
        self
    }
}
impl molecule::prelude::Builder for BytesOptBuilder {
    type Entity = BytesOpt;
    const NAME: &'static str = "BytesOptBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BytesOpt::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SporeData(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SporeData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SporeData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SporeData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "content_type", self.content_type())?;
        write!(f, ", {}: {}", "content", self.content())?;
        write!(f, ", {}: {}", "cluster_id", self.cluster_id())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for SporeData {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        SporeData::new_unchecked(v)
    }
}
impl SporeData {
    const DEFAULT_VALUE: [u8; 24] = [
        24, 0, 0, 0, 16, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn content_type(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }
    pub fn content(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }
    pub fn cluster_id(&self) -> BytesOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            BytesOpt::new_unchecked(self.0.slice(start..end))
        } else {
            BytesOpt::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> SporeDataReader<'r> {
        SporeDataReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SporeData {
    type Builder = SporeDataBuilder;
    const NAME: &'static str = "SporeData";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SporeData(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SporeDataReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SporeDataReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .content_type(self.content_type())
            .content(self.content())
            .cluster_id(self.cluster_id())
    }
}
#[derive(Clone, Copy)]
pub struct SporeDataReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SporeDataReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SporeDataReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SporeDataReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "content_type", self.content_type())?;
        write!(f, ", {}: {}", "content", self.content())?;
        write!(f, ", {}: {}", "cluster_id", self.cluster_id())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> SporeDataReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn content_type(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn content(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn cluster_id(&self) -> BytesOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            BytesOptReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesOptReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SporeDataReader<'r> {
    type Entity = SporeData;
    const NAME: &'static str = "SporeDataReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SporeDataReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        BytesReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        BytesReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        BytesOptReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct SporeDataBuilder {
    pub(crate) content_type: Bytes,
    pub(crate) content: Bytes,
    pub(crate) cluster_id: BytesOpt,
}
impl SporeDataBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn content_type(mut self, v: Bytes) -> Self {
        self.content_type = v;
        self
    }
    pub fn content(mut self, v: Bytes) -> Self {
        self.content = v;
        self
    }
    pub fn cluster_id(mut self, v: BytesOpt) -> Self {
        self.cluster_id = v;
        self
    }
}
impl molecule::prelude::Builder for SporeDataBuilder {
    type Entity = SporeData;
    const NAME: &'static str = "SporeDataBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.content_type.as_slice().len()
            + self.content.as_slice().len()
            + self.cluster_id.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.content_type.as_slice().len();
        offsets.push(total_size);
        total_size += self.content.as_slice().len();
        offsets.push(total_size);
        total_size += self.cluster_id.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.content_type.as_slice())?;
        writer.write_all(self.content.as_slice())?;
        writer.write_all(self.cluster_id.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SporeData::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ClusterData(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ClusterData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ClusterData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ClusterData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "name", self.name())?;
        write!(f, ", {}: {}", "description", self.description())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ClusterData {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        ClusterData::new_unchecked(v)
    }
}
impl ClusterData {
    const DEFAULT_VALUE: [u8; 20] = [
        20, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn name(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }
    pub fn description(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Bytes::new_unchecked(self.0.slice(start..end))
        } else {
            Bytes::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ClusterDataReader<'r> {
        ClusterDataReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ClusterData {
    type Builder = ClusterDataBuilder;
    const NAME: &'static str = "ClusterData";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ClusterData(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ClusterDataReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ClusterDataReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .name(self.name())
            .description(self.description())
    }
}
#[derive(Clone, Copy)]
pub struct ClusterDataReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ClusterDataReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ClusterDataReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ClusterDataReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "name", self.name())?;
        write!(f, ", {}: {}", "description", self.description())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ClusterDataReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn name(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn description(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            BytesReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ClusterDataReader<'r> {
    type Entity = ClusterData;
    const NAME: &'static str = "ClusterDataReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ClusterDataReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        BytesReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        BytesReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct ClusterDataBuilder {
    pub(crate) name: Bytes,
    pub(crate) description: Bytes,
}
impl ClusterDataBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn name(mut self, v: Bytes) -> Self {
        self.name = v;
        self
    }
    pub fn description(mut self, v: Bytes) -> Self {
        self.description = v;
        self
    }
}
impl molecule::prelude::Builder for ClusterDataBuilder {
    type Entity = ClusterData;
    const NAME: &'static str = "ClusterDataBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.name.as_slice().len()
            + self.description.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.name.as_slice().len();
        offsets.push(total_size);
        total_size += self.description.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.name.as_slice())?;
        writer.write_all(self.description.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ClusterData::new_unchecked(inner.into())
    }
}


================================================
File: lib/types/src/generated/spore_v2.rs
================================================
// Generated by Molecule 0.7.5
#![allow(dead_code)]

use super::spore_v1::*;
use molecule::prelude::*;
#[derive(Clone)]
pub struct ClusterDataV2(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ClusterDataV2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ClusterDataV2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ClusterDataV2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "name", self.name())?;
        write!(f, ", {}: {}", "description", self.description())?;
        write!(f, ", {}: {}", "mutant_id", self.mutant_id())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ClusterDataV2 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        ClusterDataV2::new_unchecked(v)
    }
}
impl ClusterDataV2 {
    const DEFAULT_VALUE: [u8; 24] = [
        24, 0, 0, 0, 16, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn name(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }
    pub fn description(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }
    pub fn mutant_id(&self) -> BytesOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            BytesOpt::new_unchecked(self.0.slice(start..end))
        } else {
            BytesOpt::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ClusterDataV2Reader<'r> {
        ClusterDataV2Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ClusterDataV2 {
    type Builder = ClusterDataV2Builder;
    const NAME: &'static str = "ClusterDataV2";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ClusterDataV2(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ClusterDataV2Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ClusterDataV2Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .name(self.name())
            .description(self.description())
            .mutant_id(self.mutant_id())
    }
}
#[derive(Clone, Copy)]
pub struct ClusterDataV2Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ClusterDataV2Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ClusterDataV2Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ClusterDataV2Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "name", self.name())?;
        write!(f, ", {}: {}", "description", self.description())?;
        write!(f, ", {}: {}", "mutant_id", self.mutant_id())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ClusterDataV2Reader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn name(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn description(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn mutant_id(&self) -> BytesOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            BytesOptReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesOptReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ClusterDataV2Reader<'r> {
    type Entity = ClusterDataV2;
    const NAME: &'static str = "ClusterDataV2Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ClusterDataV2Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        BytesReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        BytesReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        BytesOptReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct ClusterDataV2Builder {
    pub(crate) name: Bytes,
    pub(crate) description: Bytes,
    pub(crate) mutant_id: BytesOpt,
}
impl ClusterDataV2Builder {
    pub const FIELD_COUNT: usize = 3;
    pub fn name(mut self, v: Bytes) -> Self {
        self.name = v;
        self
    }
    pub fn description(mut self, v: Bytes) -> Self {
        self.description = v;
        self
    }
    pub fn mutant_id(mut self, v: BytesOpt) -> Self {
        self.mutant_id = v;
        self
    }
}
impl molecule::prelude::Builder for ClusterDataV2Builder {
    type Entity = ClusterDataV2;
    const NAME: &'static str = "ClusterDataV2Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.name.as_slice().len()
            + self.description.as_slice().len()
            + self.mutant_id.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.name.as_slice().len();
        offsets.push(total_size);
        total_size += self.description.as_slice().len();
        offsets.push(total_size);
        total_size += self.mutant_id.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.name.as_slice())?;
        writer.write_all(self.description.as_slice())?;
        writer.write_all(self.mutant_id.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ClusterDataV2::new_unchecked(inner.into())
    }
}


================================================
File: lib/utils/Cargo.toml
================================================
[package]
name = "spore-utils"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
ckb-std = "0.14.0"
spore-types = { path = "../types" }
spore-errors = { path = "../errors" }
ckb-transaction-cobuild = { git = "https://github.com/cryptape/ckb-transaction-cobuild-poc", rev = "bdb0c74" }


================================================
File: lib/utils/src/lib.rs
================================================
#![no_std]

extern crate alloc;

use alloc::vec::Vec;
use ckb_std::ckb_constants::Source;
use ckb_std::ckb_types::bytes::Bytes;
use ckb_std::ckb_types::packed::Script;
use ckb_std::ckb_types::prelude::*;
use ckb_std::ckb_types::util::hash::Blake2bBuilder;
use ckb_std::debug;
use ckb_std::high_level::{
    load_cell, load_cell_data, load_cell_lock, load_cell_lock_hash, load_cell_type,
    load_cell_type_hash, load_input, load_script, load_script_hash, QueryIter,
};

use spore_errors::error::Error;
use spore_types::generated::{action, spore};

pub use mime::MIME;
pub mod co_build_types {
    pub use ckb_transaction_cobuild::schemas::basic::*;
    pub use ckb_transaction_cobuild::schemas::top_level::*;
}

mod mime;

pub const MUTANT_ID_LEN: usize = 32;
pub const MUTANT_ID_WITH_PAYMENT_LEN: usize = MUTANT_ID_LEN + 8;

pub const CLUSTER_PROXY_ID_LEN: usize = 32;
pub const CLUSTER_PROXY_ID_WITH_PAYMENT_LEN: usize = CLUSTER_PROXY_ID_LEN + 8;

pub fn load_self_id() -> Result<Vec<u8>, Error> {
    Ok(load_script()?.args().raw_data()[..32].to_vec())
}

pub fn load_type_args(index: usize, source: Source) -> Bytes {
    load_cell_type(index, source)
        .unwrap_or(None)
        .unwrap_or_default()
        .args()
        .raw_data()
}

// only be avaliable in mint/create like ckb transaction
pub fn verify_type_id(output_index: usize) -> Option<[u8; 32]> {
    let first_input = match load_input(0, Source::Input) {
        Ok(cell_input) => cell_input,
        Err(_) => return None,
    };

    let expected_id = calc_type_id(first_input.as_slice(), output_index);
    let type_id_args = load_type_args(output_index, Source::Output);

    debug!("wanted: {expected_id:?}");
    debug!("got({output_index}): {type_id_args:?}");
    if type_id_args.len() < 32 {
        return None;
    }
    if type_id_args.as_ref()[..32] == expected_id {
        return Some(expected_id);
    }

    None
}

/// The type ID is calculated as the blake2b (with CKB's personalization) of
/// the first CellInput in current transaction, and the created output cell
/// index(in 64-bit little endian unsigned integer).
pub fn calc_type_id(tx_first_input: &[u8], output_index: usize) -> [u8; 32] {
    let mut blake2b = Blake2bBuilder::new(32)
        .personal(b"ckb-default-hash")
        .build();
    blake2b.update(tx_first_input);
    blake2b.update(&(output_index as u64).to_le_bytes());
    let mut verify_id = [0; 32];
    blake2b.finalize(&mut verify_id);
    verify_id
}

pub fn type_hash_filter_builder(type_hash: [u8; 32]) -> impl Fn(&Option<[u8; 32]>) -> bool {
    move |script_hash: &Option<[u8; 32]>| match script_hash {
        Some(script_hash) => script_hash[..] == type_hash[..],
        _ => false,
    }
}

pub fn find_position_by_type_args(
    args: &[u8],
    source: Source,
    filter_fn: Option<fn(&[u8; 32]) -> bool>,
) -> Option<usize> {
    QueryIter::new(load_cell_type, source).position(|script| {
        if let Some(script) = script {
            if let Some(filter) = filter_fn {
                if !filter(&script.code_hash().unpack()) {
                    return false;
                }
            }
            script.args().raw_data().as_ref() == args
        } else {
            false
        }
    })
}

pub fn find_position_by_type(type_script: &Script, source: Source) -> Option<usize> {
    QueryIter::new(load_cell_type, source).position(|script| match script {
        Some(script) => script.as_bytes() == type_script.as_bytes(),
        _ => false,
    })
}

pub fn find_position_by_type_hash(type_hash: &[u8], source: Source) -> Option<usize> {
    QueryIter::new(load_cell_type_hash, source).position(|cell_type_hash| match cell_type_hash {
        None => false,
        Some(cell_type_hash) => {
            debug!(
                "cell_type_hash : {:?}, wanted: {:?}",
                cell_type_hash, type_hash
            );
            cell_type_hash[..] == type_hash[..]
        }
    })
}

pub fn find_position_by_type_and_data(
    target_data: &[u8],
    source: Source,
    filter_fn: Option<fn(&[u8; 32]) -> bool>,
) -> Option<usize> {
    QueryIter::new(load_cell_data, source)
        .enumerate()
        .position(|(index, data)| {
            data[..] == target_data[..]
                && match filter_fn {
                    None => true,
                    Some(ref filter_fn) => {
                        if let Some(type_hash) =
                            load_cell_type_hash(index, source).unwrap_or_default()
                        {
                            filter_fn(&type_hash)
                        } else {
                            false
                        }
                    }
                }
        })
}

pub fn find_position_by_lock_hash(lock_hash: &[u8; 32], source: Source) -> Option<usize> {
    QueryIter::new(load_cell_lock_hash, source).position(|hash| hash[..] == lock_hash[..])
}

pub fn calc_capacity_sum(lock_hash: &[u8; 32], source: Source) -> u64 {
    QueryIter::new(load_cell, source)
        .filter(|cell| cell.lock().calc_script_hash().raw_data().as_ref() == lock_hash)
        .map(|cell| cell.capacity().unpack())
        .sum()
}

pub fn check_spore_address(
    group_source: Source,
    spore_address: action::Address,
) -> Result<(), Error> {
    let address = load_cell_lock(0, group_source)?;
    let action::AddressUnion::Script(expected_script) = spore_address.to_enum();
    if address.as_slice() != expected_script.as_slice() {
        return Err(Error::SporeActionAddressesMismatch);
    }
    Ok(())
}

pub fn extract_spore_action() -> Result<action::SporeAction, Error> {
    let message = ckb_transaction_cobuild::fetch_message()
        .map_err(|_| Error::InvliadCoBuildWitnessLayout)?
        .ok_or(Error::InvliadCoBuildWitnessLayout)?;
    let script_hash = load_script_hash()?;

    let mut iter = message
        .actions()
        .into_iter()
        .filter(|value| value.script_hash().as_slice() == script_hash.as_slice());
    match (iter.next(), iter.next()) {
        (Some(action), None) => action::SporeAction::from_slice(&action.data().raw_data())
            .map_err(|_| Error::InvliadCoBuildMessage),
        _ => Err(Error::SporeActionDuplicated),
    }
}

pub fn compatible_load_cluster_data(
    raw_cluster_data: &[u8],
) -> Result<spore::ClusterDataV2, Error> {
    let cluster_data = spore::ClusterData::from_compatible_slice(raw_cluster_data)
        .map_err(|_| Error::InvalidClusterData)?;
    debug!("cluster_data filed count: {}", cluster_data.field_count());
    if cluster_data.field_count() == 2 {
        Ok(spore::ClusterDataV2::new_builder()
            .name(cluster_data.name())
            .description(cluster_data.description())
            .mutant_id(Default::default())
            .build())
    } else {
        Ok(
            spore::ClusterDataV2::from_compatible_slice(raw_cluster_data)
                .map_err(|_| Error::InvalidClusterData)?,
        )
    }
}


================================================
File: lib/utils/src/mime.rs
================================================
// note: impelemtation refers to https://github.com/hyperium/mime

use core::ops::Range;

use alloc::ffi::CString;
use alloc::str;
use alloc::vec::Vec;
use ckb_std::debug;
use ckb_std::high_level::decode_hex;
use spore_errors::error::Error;

type RangePair = core::ops::Range<usize>;

#[derive(Debug, Clone)]
enum ParamType {
    Generic(RangePair),
    Immortal(RangePair),
    Mutant(RangePair),
}

#[derive(Debug, Clone)]
pub struct MIME {
    pub main_type: RangePair,
    pub sub_type: RangePair,
    pub mutants: Vec<[u8; 32]>,
    pub immortal: bool,
    params: Vec<(RangePair, RangePair)>,
}

impl MIME {
    pub fn parse(raw_content_type: &[u8]) -> Result<MIME, Error> {
        let content_type = match str::from_utf8(raw_content_type) {
            Ok(x) => x,
            _ => return Err(Error::Illformed),
        }
        .trim_start()
        .trim_end();
        Self::str_parse(&content_type)
    }

    pub fn str_parse(content_type: &str) -> Result<Self, Error> {
        debug!("Content type is: {}", content_type);
        // main_type.len() + '/' + sub_type.len() + '+' +
        let (main_type, right) = match content_type.find('/') {
            Some(pos) => (0usize..pos, pos..content_type.len()),
            _ => return Err(Error::Illformed),
        };

        if !is_restricted_name(&content_type[main_type.clone()]) {
            return Err(Error::InvaliMainType);
        }

        if !content_type[right.clone()].chars().any(is_restricted_char) {
            return Err(Error::Illformed);
        }

        let sub_end = content_type[right.clone()].find(';').unwrap_or(right.len()) + main_type.end;
        let sub_type = main_type.end + 1..sub_end;

        let mut vec = Vec::new();
        let _right_part = &content_type[sub_end..];
        let mut offset = sub_end;
        let mut mutants = Vec::new();
        let mut immortal = false;
        while let Some((name_range, value_range, new_offset)) = parse_param(content_type, offset)? {
            match name_range {
                ParamType::Mutant(name_range) => {
                    vec.push((name_range, value_range.clone()));
                    let value = &content_type[value_range];
                    for mutant_id in value.split(',') {
                        // hexed mutant id doesn't have a prefix '0x'
                        let mutant_id_hex = mutant_id.trim_matches(is_ows);
                        if mutant_id_hex.len() != 64 {
                            return Err(Error::MutantIDNotValid);
                        }
                        let mutant_id_c_str =
                            CString::new(mutant_id_hex).map_err(|_| Error::MutantIDNotValid)?;
                        let mutant_id: [u8; 32] = decode_hex(mutant_id_c_str.as_c_str())
                            .map_err(|_| Error::MutantIDNotValid)?
                            .try_into()
                            .unwrap();
                        if mutants.contains(&mutant_id) {
                            return Err(Error::DuplicateMutantId);
                        }
                        mutants.push(mutant_id);
                    }
                }
                ParamType::Generic(name_range) => {
                    vec.push((name_range, value_range));
                }
                ParamType::Immortal(name_range) => {
                    immortal = &content_type[value_range.clone()] == "true";
                    vec.push((name_range, value_range));
                }
            }
            offset = new_offset;
        }

        let mime_type = MIME {
            main_type: main_type,
            sub_type: sub_type,
            params: vec,
            mutants,
            immortal,
        };

        Ok(mime_type)
    }

    pub fn params(&self) -> &Vec<(RangePair, RangePair)> {
        &self.params
    }

    pub fn mut_params(&mut self) -> &mut Vec<(RangePair, RangePair)> {
        &mut self.params
    }

    pub fn get_param(&self, content_type: &[u8], param: &str) -> Result<Option<RangePair>, Error> {
        for (param_range, value_range) in self.params.iter() {
            check_range_validate(content_type, param_range)?;
            if content_type[param_range.clone()] == param.as_bytes()[..] {
                check_range_validate(content_type, value_range)?;
                return Ok(Some(value_range.clone()));
            }
        }
        Ok(None)
    }
}

fn check_range_validate(array: &[u8], range: &Range<usize>) -> Result<(), Error> {
    let end: usize = range.end;
    debug!("len = {}, end = {end}", array.len());
    if array.len() < end {
        return Err(Error::ContentOutOfRange);
    }
    Ok(())
}

fn is_restricted_name(s: &str) -> bool {
    s.starts_with(|c: char| c.is_ascii_alphanumeric() || c == '*') && is_restricted_str(s)
}

fn is_restricted_name_patched(s: &str) -> bool {
    s == "mutant[]" || is_restricted_name(s)
}

fn is_restricted_value_char(c: char) -> bool {
    c.is_ascii_alphanumeric()
        || matches!(
            c,
            '!' | '#' | '$' | '&' | '-' | '^' | '_' | '.' | '+' | '%' | '*' | '\'' | ','
        )
}

fn is_restricted_str(s: &str) -> bool {
    s.chars().all(is_restricted_char)
}

fn is_restricted_char(c: char) -> bool {
    c.is_ascii_alphanumeric()
        || matches!(
            c,
            '!' | '#' | '$' | '&' | '-' | '^' | '_' | '.' | '+' | '%' | '*' | '\''
        )
}

const fn is_ows(c: char) -> bool {
    c == ' ' || c == '\t'
}

fn parse_param(
    source: &str,
    offset: usize,
) -> Result<Option<(ParamType, RangePair, usize)>, Error> {
    if offset >= source.len() {
        return Ok(None);
    }
    let s = &source[offset..];
    let (lhs, rhs) = match s.split_once(';') {
        Some((lhs, rhs)) if lhs.chars().all(is_ows) && rhs.chars().all(is_ows) => return Ok(None),
        Some((lhs, rhs)) if lhs.chars().all(is_ows) => (lhs, rhs),
        _ if s.chars().all(is_ows) => return Ok(None),
        _ => return Err(Error::InvalidParams),
    };

    let (name, value) = match rhs.split_once('=') {
        Some((name, value_maybe)) => match value_maybe.split_once(';') {
            None => (name, value_maybe),
            Some((value_maybe_lhs, _)) => (name, value_maybe_lhs),
        },
        _ => return Err(Error::InvalidParams),
    };

    let key_trimmed = name.trim_start_matches(is_ows).len();
    let key_start = lhs.len() + 1 + name.len() - key_trimmed;
    let key_range = key_start + offset..key_start + offset + key_trimmed;
    if !is_restricted_name_patched(&source[key_range.clone()]) {
        return Err(Error::InvalidParams);
    }
    let key = match &source[key_range.clone()] {
        "immortal" => ParamType::Immortal(key_range.clone()),
        "mutant[]" => ParamType::Mutant(key_range.clone()),
        _ => ParamType::Generic(key_range.clone()),
    };
    let value_start = key_range.end + 1;
    if let Some(value) = value.strip_prefix('\"') {
        let value_end = value_start + parse_quoted_value(value)? + 1;
        let value_range = value_start..value_end;
        Ok(Some((key.clone(), value_range.clone(), value_end)))
    } else {
        let value_end = value_start
            + value
                .chars()
                .take_while(|&c| is_restricted_value_char(c))
                .map(char::len_utf8)
                .sum::<usize>();
        let value_range = value_start..value_end;
        Ok(Some((key.clone(), value_range.clone(), value_end)))
    }
}

fn parse_quoted_value(s: &str) -> Result<usize, Error> {
    let mut len = 0;
    let mut escaped = false;
    for c in s.chars() {
        len += c.len_utf8();
        match c {
            _ if escaped => {
                escaped = false;
            }
            '\\' => {
                escaped = true;
            }
            '"' => return Ok(len),
            '\n' => return Err(Error::InvalidParamValue),
            _ => (),
        }
    }
    Err(Error::InvalidParamValue)
}


================================================
File: tests/Cargo.lock
================================================
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "addr2line"
version = "0.21.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a30b2e23b9e17a9f90641c7ab1549cd9b44f296d3ccbf309d2863cfe398a0cb"
dependencies = [
 "gimli",
]

[[package]]
name = "adler"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe"

[[package]]
name = "ahash"
version = "0.7.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fcb51a0695d8f838b1ee009b3fbf66bda078cd64590202a864a8f3e8c4315c47"
dependencies = [
 "getrandom 0.2.10",
 "once_cell",
 "version_check",
]

[[package]]
name = "aho-corasick"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "43f6cb1bf222025340178f382c426f13757b2960e89779dfcb319c32542a5a41"
dependencies = [
 "memchr",
]

[[package]]
name = "anyhow"
version = "1.0.71"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c7d0618f0e0b7e8ff11427422b64564d5fb0be1940354bfe2e0529b18a9d9b8"

[[package]]
name = "autocfg"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa"

[[package]]
name = "backtrace"
version = "0.3.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2089b7e3f35b9dd2d0ed921ead4f6d318c27680d4a5bd167b3ee120edb105837"
dependencies = [
 "addr2line",
 "cc",
 "cfg-if 1.0.0",
 "libc",
 "miniz_oxide",
 "object",
 "rustc-demangle",
]

[[package]]
name = "base64"
version = "0.21.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9d297deb1925b89f2ccc13d7635fa0714f12c87adce1c75356b39ca9b7178567"

[[package]]
name = "bech32"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cf9ff0bbfd639f15c74af777d81383cf53efb7c93613f6cab67c6c11e05bbf8b"

[[package]]
name = "bit-vec"
version = "0.6.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "349f9b6a179ed607305526ca489b34ad0a41aed5f7980fa90eb03160b69598fb"

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "bitflags"
version = "2.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed570934406eb16438a4e976b1b4500774099c13b8cb96eec99f620f05090ddf"

[[package]]
name = "blake2b-ref"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "294d17c72e0ba59fad763caa112368d0672083779cdebbb97164f4bb4c1e339a"

[[package]]
name = "blake2b-rs"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a89a8565807f21b913288968e391819e7f9b2f0f46c7b89549c051cccf3a2771"
dependencies = [
 "cc",
 "cty",
]

[[package]]
name = "block-buffer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
dependencies = [
 "generic-array",
]

[[package]]
name = "buddy-alloc"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f0d2da64a6a895d5a7e0724882825d50f83c13396b1b9f1878e19a024bab395"

[[package]]
name = "bumpalo"
version = "3.15.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7ff69b9dd49fd426c69a0db9fc04dd934cdb6645ff000864d98f7e2af8830eaa"

[[package]]
name = "byteorder"
version = "1.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "14c189c53d098945499cdfa7ecc63567cf3886b3332b312a5b4585d8d3a6a610"

[[package]]
name = "bytes"
version = "1.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "89b2fd2a0dcf38d7971e2194b6b6eebab45ae01067456a7fd93d5547a61b70be"
dependencies = [
 "serde",
]

[[package]]
name = "cc"
version = "1.0.79"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "50d30906286121d95be3d479533b458f87493b30a4b5f79a607db8f5d11aa91f"

[[package]]
name = "cfg-if"
version = "0.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822"

[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "ckb-always-success-script"
version = "0.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b3b72a38c9920a29990df12002c4d069a147c8782f0c211f8a01b2df8f42bfd"

[[package]]
name = "ckb-chain-spec"
version = "0.111.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dbd58081d4ac4f08d068b52c5a07f0b379d93aad0dfa8344c6890429a9b73c2b"
dependencies = [
 "ckb-constant",
 "ckb-crypto",
 "ckb-dao-utils",
 "ckb-error",
 "ckb-hash",
 "ckb-jsonrpc-types",
 "ckb-pow",
 "ckb-rational",
 "ckb-resource",
 "ckb-traits",
 "ckb-types",
 "ckb-util",
 "serde",
 "toml",
]

[[package]]
name = "ckb-channel"
version = "0.111.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "701e6829c3dcbae46dd2442de63d080046480a6c2bb4951dbf419ad092459402"
dependencies = [
 "crossbeam-channel",
]

[[package]]
name = "ckb-constant"
version = "0.111.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9d5c980d4724770f72a37bceffa26ea64dd914891e45e856e2a3792fdb4a5a18"

[[package]]
name = "ckb-crypto"
version = "0.111.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df80db694e42b64a5774ae551daff3c8310cd99bb528643dbe0dd409abb298e7"
dependencies = [
 "ckb-fixed-hash",
 "faster-hex",
 "lazy_static",
 "rand 0.7.3",
 "secp256k1",
 "thiserror",
]

[[package]]
name = "ckb-dao"
version = "0.111.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "76cb0dd4d284d6908595fa809668555ad36bc89538ea9440d11208090481c240"
dependencies = [
 "byteorder",
 "ckb-chain-spec",
 "ckb-dao-utils",
 "ckb-traits",
 "ckb-types",
]

[[package]]
name = "ckb-dao-utils"
version = "0.111.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e158ce5a4e9d1fcd08d9dee87332474572c629c6273cca0aea80ba24892a403"
dependencies = [
 "byteorder",
 "ckb-error",
 "ckb-types",
]

[[package]]
name = "ckb-error"
version = "0.111.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34cfd733cabcb4262ee679c02733864b13c8fa879e3aabc078fe0ec727cd95d6"
dependencies = [
 "anyhow",
 "ckb-occupied-capacity",
 "derive_more",
 "thiserror",
]

[[package]]
name = "ckb-fixed-hash"
version = "0.111.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b1dfab045fffa31cae9680d73e1f09833ca1abfb807dc4b9544739c94c23fd0"
dependencies = [
 "ckb-fixed-hash-core",
 "ckb-fixed-hash-macros",
]

[[package]]
name = "ckb-fixed-hash-core"
version = "0.111.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bdd1727a6ecd4d0bcab604cb1ef707fe92e939fa6e9a438f9f25bf05208cb080"
dependencies = [
 "faster-hex",
 "serde",
 "thiserror",
]

[[package]]
name = "ckb-fixed-hash-macros"
version = "0.111.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7b5da34c32585c35715fcde4e3a1dd3b0346d7af43506c5e51c613f01483e4f9"
dependencies = [
 "ckb-fixed-hash-core",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "ckb-gen-types"
version = "0.111.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a3bc54ca99b09e1eb5fc6c49bb1156644ce57fce9c6f52b5c13110b9a3143f7e"
dependencies = [
 "cfg-if 1.0.0",
 "ckb-error",
 "ckb-fixed-hash",
 "ckb-hash",
 "ckb-occupied-capacity",
 "molecule",
 "numext-fixed-uint",
]

[[package]]
name = "ckb-hash"
version = "0.111.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8c88e5e2d6454be488fa5cf8b49175879353c6af969ff210dd6416f315b53120"
dependencies = [
 "blake2b-ref",
 "blake2b-rs",
]

[[package]]
name = "ckb-jsonrpc-types"
version = "0.111.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d789a71538da07871c11aecbd28d6c632bb426bdfeed5fc2fa1b455e31152468"
dependencies = [
 "ckb-types",
 "faster-hex",
 "serde",
 "serde_json",
]

[[package]]
name = "ckb-logger"
version = "0.111.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "939fa09ca3534248d3d452552546f016fc7e11346644fbc5b55d2ad38d3e80e7"
dependencies = [
 "log",
]

[[package]]
name = "ckb-merkle-mountain-range"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56ccb671c5921be8a84686e6212ca184cb1d7c51cadcdbfcbd1cc3f042f5dfb8"
dependencies = [
 "cfg-if 1.0.0",
]

[[package]]
name = "ckb-mock-tx-types"
version = "0.111.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dcd5b156c36f03ad6053e174e26a874088c8e9098c3a2e80ec93dc9831ecfac3"
dependencies = [
 "ckb-jsonrpc-types",
 "ckb-traits",
 "ckb-types",
 "serde",
]

[[package]]
name = "ckb-occupied-capacity"
version = "0.111.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "358ad364465a5a359575642c12952ba8735a148382789d65ddd5231cd21899fc"
dependencies = [
 "ckb-occupied-capacity-core",
 "ckb-occupied-capacity-macros",
]

[[package]]
name = "ckb-occupied-capacity-core"
version = "0.111.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "de2dc06db98f8a995cb7145bc56dbd17bb0c8ab2e59a07aaa40f2c956c2451dd"
dependencies = [
 "serde",
]

[[package]]
name = "ckb-occupied-capacity-macros"
version = "0.111.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b1709e0f101026c4ef29b1593692e480b03cdb4e0dace1e348494c6554d50d35"
dependencies = [
 "ckb-occupied-capacity-core",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "ckb-pow"
version = "0.111.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "481e76388993d7e6e0dd797e8532c60398901787e28d0638ca114254257b8813"
dependencies = [
 "byteorder",
 "ckb-hash",
 "ckb-types",
 "eaglesong",
 "log",
 "serde",
]

[[package]]
name = "ckb-rational"
version = "0.111.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bd3959391a4fb05d6a2578aa8db75732ada1ce381fb34d6eeaf09d395702e63c"
dependencies = [
 "numext-fixed-uint",
 "serde",
]

[[package]]
name = "ckb-resource"
version = "0.111.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "03222b0613cf3f55cb181471d7a84879b6fba5e920e2e1c7ba2c2315614bd387"
dependencies = [
 "ckb-system-scripts",
 "ckb-types",
 "includedir",
 "includedir_codegen",
 "phf",
 "serde",
 "walkdir",
]

[[package]]
name = "ckb-script"
version = "0.111.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8c9075ad901eae97925f491b6be675d7b19bf7b10eaa94a88f6e8070c0cd00ba"
dependencies = [
 "byteorder",
 "ckb-chain-spec",
 "ckb-error",
 "ckb-hash",
 "ckb-logger",
 "ckb-traits",
 "ckb-types",
 "ckb-vm",
 "faster-hex",
 "serde",
]

[[package]]
name = "ckb-sdk"
version = "3.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "718c12dee9e39d9e438a6cc6da0168ac83ca8dc17ace32ce08a2568d4b574398"
dependencies = [
 "anyhow",
 "bech32",
 "bitflags 1.3.2",
 "bytes",
 "ckb-chain-spec",
 "ckb-crypto",
 "ckb-dao-utils",
 "ckb-hash",
 "ckb-jsonrpc-types",
 "ckb-mock-tx-types",
 "ckb-resource",
 "ckb-script",
 "ckb-traits",
 "ckb-types",
 "dashmap",
 "derive-getters",
 "dyn-clone",
 "enum-repr-derive",
 "futures",
 "jsonrpc-core",
 "lazy_static",
 "log",
 "lru",
 "parking_lot",
 "reqwest",
 "secp256k1",
 "serde",
 "serde_derive",
 "serde_json",
 "sha3",
 "sparse-merkle-tree",
 "thiserror",
 "tokio",
 "tokio-util",
]

[[package]]
name = "ckb-standalone-types"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b5c776d70eb4f60a22a3180857646d77b2da8d33c0c4a063ad9f6610fc94609f"
dependencies = [
 "blake2b-ref",
 "cfg-if 1.0.0",
 "molecule",
]

[[package]]
name = "ckb-std"
version = "0.14.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2a08518aa0fd4ce069d3ec80b63dcd3d6543ad3805ad1c0b4e1d8e4d38f8a9fc"
dependencies = [
 "buddy-alloc",
 "cc",
 "ckb-standalone-types",
]

[[package]]
name = "ckb-system-scripts"
version = "0.5.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa5c59063142de7a68cfad4449c6b3863563856219a2925dfb8c5f019ec2aa47"
dependencies = [
 "blake2b-rs",
 "faster-hex",
 "includedir",
 "includedir_codegen",
 "phf",
]

[[package]]
name = "ckb-systemtime"
version = "0.111.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d5c03dd01263a66eaf171fb1bbadd12d80a0b54abe19aa55a2c53c5ae3300cda"

[[package]]
name = "ckb-testtool"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "61f7426eb44c6cfc703a68fb99c74b675a378fdca12df5af94683b27a60d377e"
dependencies = [
 "ckb-always-success-script",
 "ckb-chain-spec",
 "ckb-crypto",
 "ckb-error",
 "ckb-hash",
 "ckb-jsonrpc-types",
 "ckb-resource",
 "ckb-script",
 "ckb-traits",
 "ckb-types",
 "ckb-verification",
 "lazy_static",
 "rand 0.8.5",
]

[[package]]
name = "ckb-traits"
version = "0.111.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ca049aba2cb2d1208c6044accb497b17290ad56de629f6a4b95eded67a43fd40"
dependencies = [
 "ckb-types",
]

[[package]]
name = "ckb-transaction-cobuild"
version = "0.1.0"
source = "git+https://github.com/cryptape/ckb-transaction-cobuild-poc?rev=bdb0c74#bdb0c745a76c1aa349a0e881ad4ccdd4af286723"
dependencies = [
 "blake2b-ref",
 "ckb-gen-types",
 "ckb-std",
 "molecule",
]

[[package]]
name = "ckb-types"
version = "0.111.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6ec737e4957418bbd0f4091e8565a89bbd8f6fc37a20360820e44d1f1e44e58"
dependencies = [
 "bit-vec",
 "bytes",
 "ckb-channel",
 "ckb-constant",
 "ckb-error",
 "ckb-fixed-hash",
 "ckb-gen-types",
 "ckb-hash",
 "ckb-merkle-mountain-range",
 "ckb-occupied-capacity",
 "ckb-rational",
 "derive_more",
 "golomb-coded-set",
 "merkle-cbt",
 "molecule",
 "numext-fixed-uint",
 "once_cell",
 "paste",
]

[[package]]
name = "ckb-util"
version = "0.111.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "011b907b18aa706fc224a1309f14eadd9cc14c42cf2258ca3010d1324bc20f10"
dependencies = [
 "linked-hash-map",
 "once_cell",
 "parking_lot",
 "regex",
]

[[package]]
name = "ckb-verification"
version = "0.111.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fe3338bb8cf49c5a21de636eeb448deeba1e379491d34b67f2201fc77a08e215"
dependencies = [
 "ckb-chain-spec",
 "ckb-dao",
 "ckb-dao-utils",
 "ckb-error",
 "ckb-pow",
 "ckb-script",
 "ckb-systemtime",
 "ckb-traits",
 "ckb-types",
 "ckb-verification-traits",
 "derive_more",
 "lru",
]

[[package]]
name = "ckb-verification-traits"
version = "0.111.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba1bbfdeff1f930f26c60103b59442494dba83493254bb255f1ba318be2f27fe"
dependencies = [
 "bitflags 1.3.2",
 "ckb-error",
]

[[package]]
name = "ckb-vm"
version = "0.24.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0cc004a826b9bc9319ffae0b8415690e1b5f1482266d55fbd43843aa40ddcd63"
dependencies = [
 "byteorder",
 "bytes",
 "cc",
 "ckb-vm-definitions",
 "derive_more",
 "goblin 0.2.3",
 "goblin 0.4.0",
 "rand 0.7.3",
 "scroll",
 "serde",
]

[[package]]
name = "ckb-vm-definitions"
version = "0.24.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c4ced3ff9d79b53d93c106720f6c1f855694290e33581850e05c859500eee83f"
dependencies = [
 "paste",
]

[[package]]
name = "convert_case"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6245d59a3e82a7fc217c5828a6692dbc6dfb63a0c8c90495621f7b9d79704a0e"

[[package]]
name = "core-foundation"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "91e195e091a93c46f7102ec7818a2aa394e1e1771c3ab4825963fa03e45afb8f"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "core-foundation-sys"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06ea2b9bc92be3c2baa9334a323ebca2d6f074ff852cd1d7b11064035cd3868f"

[[package]]
name = "cpufeatures"
version = "0.2.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "53fe5e26ff1b7aef8bca9c6080520cfb8d9333c7568e1829cef191a9723e5504"
dependencies = [
 "libc",
]

[[package]]
name = "crc32fast"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b540bd8bc810d3885c6ea91e2018302f68baba2129ab3e88f32389ee9370880d"
dependencies = [
 "cfg-if 1.0.0",
]

[[package]]
name = "crossbeam-channel"
version = "0.5.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a33c2bf77f2df06183c3aa30d1e96c0695a313d4f9c453cc3762a6db39f99200"
dependencies = [
 "cfg-if 1.0.0",
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-utils"
version = "0.8.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a22b2d63d4d1dc0b7f1b6b2747dd0088008a9be28b6ddf0b1e7d335e3037294"
dependencies = [
 "cfg-if 1.0.0",
]

[[package]]
name = "crypto-common"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3"
dependencies = [
 "generic-array",
 "typenum",
]

[[package]]
name = "cty"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b365fabc795046672053e29c954733ec3b05e4be654ab130fe8f1f94d7051f35"

[[package]]
name = "dashmap"
version = "5.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "978747c1d849a7d2ee5e8adc0159961c48fb7e5db2f06af6723b80123bb53856"
dependencies = [
 "cfg-if 1.0.0",
 "hashbrown 0.14.3",
 "lock_api",
 "once_cell",
 "parking_lot_core",
]

[[package]]
name = "derive-getters"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0122f262bf9c9a367829da84f808d9fb128c10ef283bbe7b0922a77cf07b2747"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "derive_more"
version = "0.99.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4fb810d30a7c1953f91334de7244731fc3f3c10d7fe163338a35b9f640960321"
dependencies = [
 "convert_case",
 "proc-macro2",
 "quote",
 "rustc_version",
 "syn 1.0.109",
]

[[package]]
name = "digest"
version = "0.10.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
dependencies = [
 "block-buffer",
 "crypto-common",
]

[[package]]
name = "dyn-clone"
version = "1.0.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0d6ef0072f8a535281e4876be788938b528e9a1d43900b82c2569af7da799125"

[[package]]
name = "eaglesong"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8d978bd5d343e8ab9b5c0fc8d93ff9c602fdc96616ffff9c05ac7a155419b824"

[[package]]
name = "encoding_rs"
version = "0.8.33"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7268b386296a025e474d5140678f75d6de9493ae55a5d709eeb9dd08149945e1"
dependencies = [
 "cfg-if 1.0.0",
]

[[package]]
name = "enum-repr-derive"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c6f2936062c28214e84685742fa4affc52a39d036e8a3dcf98034810e449ec95"
dependencies = [
 "proc-macro-error",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "equivalent"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5443807d6dff69373d433ab9ef5378ad8df50ca6298caf15de6e52e24aaf54d5"

[[package]]
name = "errno"
version = "0.3.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a258e46cdc063eb8519c00b9fc845fc47bcfca4130e2f08e88665ceda8474245"
dependencies = [
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "faster-hex"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "51e2ce894d53b295cf97b05685aa077950ff3e8541af83217fc720a6437169f8"

[[package]]
name = "fastrand"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "25cbce373ec4653f1a01a31e8a5e5ec0c622dc27ff9c4e6606eefef5cbbed4a5"

[[package]]
name = "flate2"
version = "1.0.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b9429470923de8e8cbd4d2dc513535400b4b3fef0319fb5c4e1f520a7bef743"
dependencies = [
 "crc32fast",
 "miniz_oxide",
]

[[package]]
name = "fnv"
version = "1.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"

[[package]]
name = "foreign-types"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6f339eb8adc052cd2ca78910fda869aefa38d22d5cb648e6485e4d3fc06f3b1"
dependencies = [
 "foreign-types-shared",
]

[[package]]
name = "foreign-types-shared"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "00b0228411908ca8685dba7fc2cdd70ec9990a6e753e89b6ac91a84c40fbaf4b"

[[package]]
name = "form_urlencoded"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e13624c2627564efccf4934284bdd98cbaa14e79b0b5a141218e507b3a823456"
dependencies = [
 "percent-encoding",
]

[[package]]
name = "futures"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "645c6916888f6cb6350d2550b80fb63e734897a8498abe35cfb732b6487804b0"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-executor",
 "futures-io",
 "futures-sink",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-channel"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eac8f7d7865dcb88bd4373ab671c8cf4508703796caa2b1985a9ca867b3fcb78"
dependencies = [
 "futures-core",
 "futures-sink",
]

[[package]]
name = "futures-core"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dfc6580bb841c5a68e9ef15c77ccc837b40a7504914d52e47b8b0e9bbda25a1d"

[[package]]
name = "futures-executor"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a576fc72ae164fca6b9db127eaa9a9dda0d61316034f33a0a0d4eda41f02b01d"
dependencies = [
 "futures-core",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-io"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a44623e20b9681a318efdd71c299b6b222ed6f231972bfe2f224ebad6311f0c1"

[[package]]
name = "futures-macro"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87750cf4b7a4c0625b1529e4c543c2182106e4dedc60a2a6455e00d212c489ac"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.25",
]

[[package]]
name = "futures-sink"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9fb8e00e87438d937621c1c6269e53f536c14d3fbd6a042bb24879e57d474fb5"

[[package]]
name = "futures-task"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38d84fa142264698cdce1a9f9172cf383a0c82de1bddcf3092901442c4097004"

[[package]]
name = "futures-util"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3d6401deb83407ab3da39eba7e33987a73c3df0c82b4bb5813ee871c19c41d48"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-io",
 "futures-macro",
 "futures-sink",
 "futures-task",
 "memchr",
 "pin-project-lite",
 "pin-utils",
 "slab",
]

[[package]]
name = "generic-array"
version = "0.14.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
dependencies = [
 "typenum",
 "version_check",
]

[[package]]
name = "getrandom"
version = "0.1.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8fc3cb4d91f53b50155bdcfd23f6a4c39ae1969c2ae85982b135750cccaf5fce"
dependencies = [
 "cfg-if 1.0.0",
 "libc",
 "wasi 0.9.0+wasi-snapshot-preview1",
]

[[package]]
name = "getrandom"
version = "0.2.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "be4136b2a15dd319360be1c07d9933517ccf0be8f16bf62a3bee4f0d618df427"
dependencies = [
 "cfg-if 1.0.0",
 "libc",
 "wasi 0.11.0+wasi-snapshot-preview1",
]

[[package]]
name = "gimli"
version = "0.28.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4271d37baee1b8c7e4b708028c57d816cf9d2434acb33a549475f78c181f6253"

[[package]]
name = "goblin"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d20fd25aa456527ce4f544271ae4fea65d2eda4a6561ea56f39fb3ee4f7e3884"
dependencies = [
 "log",
 "plain",
 "scroll",
]

[[package]]
name = "goblin"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "532a09cd3df2c6bbfc795fb0434bff8f22255d1d07328180e918a2e6ce122d4d"
dependencies = [
 "log",
 "plain",
 "scroll",
]

[[package]]
name = "golomb-coded-set"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4c7076c0cd6257d84b785b0f22c36443dd47a5e86a1256d7ef82c8cb88ea9a7e"
dependencies = [
 "siphasher",
]

[[package]]
name = "h2"
version = "0.3.24"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bb2c4422095b67ee78da96fbb51a4cc413b3b25883c7717ff7ca1ab31022c9c9"
dependencies = [
 "bytes",
 "fnv",
 "futures-core",
 "futures-sink",
 "futures-util",
 "http",
 "indexmap",
 "slab",
 "tokio",
 "tokio-util",
 "tracing",
]

[[package]]
name = "hashbrown"
version = "0.12.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888"
dependencies = [
 "ahash",
]

[[package]]
name = "hashbrown"
version = "0.14.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "290f1a1d9242c78d09ce40a5e87e7554ee637af1351968159f4952f028f75604"

[[package]]
name = "heapsize"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1679e6ea370dee694f91f1dc469bf94cf8f52051d147aec3e1f9497c6fc22461"
dependencies = [
 "winapi",
]

[[package]]
name = "hex"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"

[[package]]
name = "http"
version = "0.2.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "601cbb57e577e2f5ef5be8e7b83f0f63994f25aa94d673e54a92d5c516d101f1"
dependencies = [
 "bytes",
 "fnv",
 "itoa",
]

[[package]]
name = "http-body"
version = "0.4.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7ceab25649e9960c0311ea418d17bee82c0dcec1bd053b5f9a66e265a693bed2"
dependencies = [
 "bytes",
 "http",
 "pin-project-lite",
]

[[package]]
name = "httparse"
version = "1.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d897f394bad6a705d5f4104762e116a75639e470d80901eed05a860a95cb1904"

[[package]]
name = "httpdate"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df3b46402a9d5adb4c86a0cf463f42e19994e3ee891101b1841f30a545cb49a9"

[[package]]
name = "hyper"
version = "0.14.28"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bf96e135eb83a2a8ddf766e426a841d8ddd7449d5f00d34ea02b41d2f19eef80"
dependencies = [
 "bytes",
 "futures-channel",
 "futures-core",
 "futures-util",
 "h2",
 "http",
 "http-body",
 "httparse",
 "httpdate",
 "itoa",
 "pin-project-lite",
 "socket2",
 "tokio",
 "tower-service",
 "tracing",
 "want",
]

[[package]]
name = "hyper-tls"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d6183ddfa99b85da61a140bea0efc93fdf56ceaa041b37d553518030827f9905"
dependencies = [
 "bytes",
 "hyper",
 "native-tls",
 "tokio",
 "tokio-native-tls",
]

[[package]]
name = "idna"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "634d9b1461af396cad843f47fdba5597a4f9e6ddd4bfb6ff5d85028c25cb12f6"
dependencies = [
 "unicode-bidi",
 "unicode-normalization",
]

[[package]]
name = "includedir"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "afd126bd778c00c43a9dc76d1609a0894bf4222088088b2217ccc0ce9e816db7"
dependencies = [
 "flate2",
 "phf",
]

[[package]]
name = "includedir_codegen"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0ac1500c9780957c9808c4ec3b94002f35aab01483833f5a8bce7dfb243e3148"
dependencies = [
 "flate2",
 "phf_codegen",
 "walkdir",
]

[[package]]
name = "indexmap"
version = "2.2.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7b0b929d511467233429c45a44ac1dcaa21ba0f5ba11e4879e6ed28ddb4f9df4"
dependencies = [
 "equivalent",
 "hashbrown 0.14.3",
]

[[package]]
name = "ipnet"
version = "2.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f518f335dce6725a761382244631d86cf0ccb2863413590b31338feb467f9c3"

[[package]]
name = "itoa"
version = "1.0.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62b02a5381cc465bd3041d84623d0fa3b66738b52b8e2fc3bab8ad63ab032f4a"

[[package]]
name = "js-sys"
version = "0.3.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "29c15563dc2726973df627357ce0c9ddddbea194836909d655df6a75d2cf296d"
dependencies = [
 "wasm-bindgen",
]

[[package]]
name = "jsonrpc-core"
version = "18.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "14f7f76aef2d054868398427f6c54943cf3d1caa9a7ec7d0c38d69df97a965eb"
dependencies = [
 "futures",
 "futures-executor",
 "futures-util",
 "log",
 "serde",
 "serde_derive",
 "serde_json",
]

[[package]]
name = "keccak"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ecc2af9a1119c51f12a14607e783cb977bde58bc069ff0c3da1095e635d70654"
dependencies = [
 "cpufeatures",
]

[[package]]
name = "lazy_static"
version = "1.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646"

[[package]]
name = "libc"
version = "0.2.153"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c198f91728a82281a64e1f4f9eeb25d82cb32a5de251c6bd1b5154d63a8e7bd"

[[package]]
name = "linked-hash-map"
version = "0.5.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0717cef1bc8b636c6e1c1bbdefc09e6322da8a9321966e8928ef80d20f7f770f"
dependencies = [
 "serde",
]

[[package]]
name = "linux-raw-sys"
version = "0.4.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "01cda141df6706de531b6c46c3a33ecca755538219bd484262fa09410c13539c"

[[package]]
name = "lock_api"
version = "0.4.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c1cc9717a20b1bb222f333e6a92fd32f7d8a18ddc5a3191a11af45dcbf4dcd16"
dependencies = [
 "autocfg",
 "scopeguard",
]

[[package]]
name = "log"
version = "0.4.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b06a4cde4c0f271a446782e3eff8de789548ce57dbc8eca9292c27f4a42004b4"

[[package]]
name = "lru"
version = "0.7.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e999beba7b6e8345721bd280141ed958096a2e4abdf74f67ff4ce49b4b54e47a"
dependencies = [
 "hashbrown 0.12.3",
]

[[package]]
name = "memchr"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2dffe52ecf27772e601905b7522cb4ef790d2cc203488bbd0e2fe85fcb74566d"

[[package]]
name = "merkle-cbt"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "171d2f700835121c3b04ccf0880882987a050fd5c7ae88148abf537d33dd3a56"
dependencies = [
 "cfg-if 1.0.0",
]

[[package]]
name = "mime"
version = "0.3.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6877bb514081ee2a7ff5ef9de3281f14a4dd4bceac4c09388074a6b5df8a139a"

[[package]]
name = "miniz_oxide"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e7810e0be55b428ada41041c41f32c9f1a42817901b4ccf45fa3d4b6561e74c7"
dependencies = [
 "adler",
]

[[package]]
name = "mio"
version = "0.8.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4a650543ca06a924e8b371db273b2756685faae30f8487da1b56505a8f78b0c"
dependencies = [
 "libc",
 "wasi 0.11.0+wasi-snapshot-preview1",
 "windows-sys 0.48.0",
]

[[package]]
name = "molecule"
version = "0.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d4fd9767ab5e5f2ea40f71ff4c8bdb633c50509052e093c2fdd0e390a749dfa3"
dependencies = [
 "bytes",
 "cfg-if 1.0.0",
 "faster-hex",
]

[[package]]
name = "native-tls"
version = "0.2.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "07226173c32f2926027b63cce4bcd8076c3552846cbe7925f3aaffeac0a3b92e"
dependencies = [
 "lazy_static",
 "libc",
 "log",
 "openssl",
 "openssl-probe",
 "openssl-sys",
 "schannel",
 "security-framework",
 "security-framework-sys",
 "tempfile",
]

[[package]]
name = "numext-constructor"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "621fe0f044729f810c6815cdd77e8f5e0cd803ce4f6a38380ebfc1322af98661"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "numext-fixed-uint"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c68c76f96d589d1009a666c5072f37f3114d682696505f2cf445f27766c7d70"
dependencies = [
 "numext-fixed-uint-core",
 "numext-fixed-uint-hack",
]

[[package]]
name = "numext-fixed-uint-core"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6aab1d6457b97b49482f22a92f0f58a2f39bdd7f3b2f977eae67e8bc206aa980"
dependencies = [
 "heapsize",
 "numext-constructor",
 "rand 0.7.3",
 "serde",
 "thiserror",
]

[[package]]
name = "numext-fixed-uint-hack"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0200f8d55c36ec1b6a8cf810115be85d4814f045e0097dfd50033ba25adb4c9e"
dependencies = [
 "numext-fixed-uint-core",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "object"
version = "0.32.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a6a622008b6e321afc04970976f62ee297fdbaa6f95318ca343e3eebb9648441"
dependencies = [
 "memchr",
]

[[package]]
name = "once_cell"
version = "1.18.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dd8b5dd2ae5ed71462c540258bedcb51965123ad7e7ccf4b9a8cafaa4a63576d"

[[package]]
name = "openssl"
version = "0.10.64"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "95a0481286a310808298130d22dd1fef0fa571e05a8f44ec801801e84b216b1f"
dependencies = [
 "bitflags 2.4.2",
 "cfg-if 1.0.0",
 "foreign-types",
 "libc",
 "once_cell",
 "openssl-macros",
 "openssl-sys",
]

[[package]]
name = "openssl-macros"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a948666b637a0f465e8564c73e89d4dde00d72d4d473cc972f390fc3dcee7d9c"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.25",
]

[[package]]
name = "openssl-probe"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ff011a302c396a5197692431fc1948019154afc178baf7d8e37367442a4601cf"

[[package]]
name = "openssl-sys"
version = "0.9.101"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dda2b0f344e78efc2facf7d195d098df0dd72151b26ab98da807afc26c198dff"
dependencies = [
 "cc",
 "libc",
 "pkg-config",
 "vcpkg",
]

[[package]]
name = "parking_lot"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3742b2c103b9f06bc9fff0a37ff4912935851bee6d36f3c02bcc755bcfec228f"
dependencies = [
 "lock_api",
 "parking_lot_core",
]

[[package]]
name = "parking_lot_core"
version = "0.9.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93f00c865fe7cabf650081affecd3871070f26767e7b2070a3ffae14c654b447"
dependencies = [
 "cfg-if 1.0.0",
 "libc",
 "redox_syscall",
 "smallvec",
 "windows-targets 0.48.1",
]

[[package]]
name = "paste"
version = "1.0.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "de3145af08024dea9fa9914f381a17b8fc6034dfb00f3a84013f7ff43f29ed4c"

[[package]]
name = "percent-encoding"
version = "2.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3148f5046208a5d56bcfc03053e3ca6334e51da8dfb19b6cdc8b306fae3283e"

[[package]]
name = "phf"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3dfb61232e34fcb633f43d12c58f83c1df82962dcdfa565a4e866ffc17dafe12"
dependencies = [
 "phf_shared",
]

[[package]]
name = "phf_codegen"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cbffee61585b0411840d3ece935cce9cb6321f01c45477d30066498cd5e1a815"
dependencies = [
 "phf_generator",
 "phf_shared",
]

[[package]]
name = "phf_generator"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "17367f0cc86f2d25802b2c26ee58a7b23faeccf78a396094c13dced0d0182526"
dependencies = [
 "phf_shared",
 "rand 0.7.3",
]

[[package]]
name = "phf_shared"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c00cf8b9eafe68dde5e9eaa2cef8ee84a9336a47d566ec55ca16589633b65af7"
dependencies = [
 "siphasher",
]

[[package]]
name = "pin-project-lite"
version = "0.2.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8afb450f006bf6385ca15ef45d71d2288452bc3683ce2e2cacc0d18e4be60b58"

[[package]]
name = "pin-utils"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"

[[package]]
name = "pkg-config"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d231b230927b5e4ad203db57bbcbee2802f6bce620b1e4a9024a07d94e2907ec"

[[package]]
name = "plain"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b4596b6d070b27117e987119b4dac604f3c58cfb0b191112e24771b2faeac1a6"

[[package]]
name = "ppv-lite86"
version = "0.2.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b40af805b3121feab8a3c29f04d8ad262fa8e0561883e7653e024ae4479e6de"

[[package]]
name = "proc-macro-error"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "da25490ff9892aab3fcf7c36f08cfb902dd3e71ca0f9f9517bea02a73a5ce38c"
dependencies = [
 "proc-macro-error-attr",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
 "version_check",
]

[[package]]
name = "proc-macro-error-attr"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a1be40180e52ecc98ad80b184934baf3d0d29f979574e439af5a55274b35f869"
dependencies = [
 "proc-macro2",
 "quote",
 "version_check",
]

[[package]]
name = "proc-macro2"
version = "1.0.64"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78803b62cbf1f46fde80d7c0e803111524b9877184cfe7c3033659490ac7a7da"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.29"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "573015e8ab27661678357f27dc26460738fd2b6c86e46f386fde94cb5d913105"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "rand"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6a6b1679d49b24bbfe0c803429aa1874472f50d9b363131f0e89fc356b544d03"
dependencies = [
 "getrandom 0.1.16",
 "libc",
 "rand_chacha 0.2.2",
 "rand_core 0.5.1",
 "rand_hc",
 "rand_pcg",
]

[[package]]
name = "rand"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [
 "libc",
 "rand_chacha 0.3.1",
 "rand_core 0.6.4",
]

[[package]]
name = "rand_chacha"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f4c8ed856279c9737206bf725bf36935d8666ead7aa69b52be55af369d193402"
dependencies = [
 "ppv-lite86",
 "rand_core 0.5.1",
]

[[package]]
name = "rand_chacha"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88"
dependencies = [
 "ppv-lite86",
 "rand_core 0.6.4",
]

[[package]]
name = "rand_core"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "90bde5296fc891b0cef12a6d03ddccc162ce7b2aff54160af9338f8d40df6d19"
dependencies = [
 "getrandom 0.1.16",
]

[[package]]
name = "rand_core"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
dependencies = [
 "getrandom 0.2.10",
]

[[package]]
name = "rand_hc"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ca3129af7b92a17112d59ad498c6f81eaf463253766b90396d39ea7a39d6613c"
dependencies = [
 "rand_core 0.5.1",
]

[[package]]
name = "rand_pcg"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "16abd0c1b639e9eb4d7c50c0b8100b0d0f849be2349829c740fe8e6eb4816429"
dependencies = [
 "rand_core 0.5.1",
]

[[package]]
name = "redox_syscall"
version = "0.3.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "567664f262709473930a4bf9e51bf2ebf3348f2e748ccc50dea20646858f8f29"
dependencies = [
 "bitflags 1.3.2",
]

[[package]]
name = "regex"
version = "1.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b2eae68fc220f7cf2532e4494aded17545fce192d59cd996e0fe7887f4ceb575"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata",
 "regex-syntax",
]

[[package]]
name = "regex-automata"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "83d3daa6976cffb758ec878f108ba0e062a45b2d6ca3a2cca965338855476caf"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax",
]

[[package]]
name = "regex-syntax"
version = "0.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e5ea92a5b6195c6ef2a0295ea818b312502c6fc94dde986c5553242e18fd4ce2"

[[package]]
name = "reqwest"
version = "0.11.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78bf93c4af7a8bb7d879d51cebe797356ff10ae8516ace542b5182d9dcac10b2"
dependencies = [
 "base64",
 "bytes",
 "encoding_rs",
 "futures-core",
 "futures-util",
 "h2",
 "http",
 "http-body",
 "hyper",
 "hyper-tls",
 "ipnet",
 "js-sys",
 "log",
 "mime",
 "native-tls",
 "once_cell",
 "percent-encoding",
 "pin-project-lite",
 "rustls-pemfile",
 "serde",
 "serde_json",
 "serde_urlencoded",
 "sync_wrapper",
 "system-configuration",
 "tokio",
 "tokio-native-tls",
 "tower-service",
 "url",
 "wasm-bindgen",
 "wasm-bindgen-futures",
 "web-sys",
 "winreg",
]

[[package]]
name = "rustc-demangle"
version = "0.1.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d626bb9dae77e28219937af045c257c28bfd3f69333c512553507f5f9798cb76"

[[package]]
name = "rustc_version"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bfa0f585226d2e68097d4f95d113b15b83a82e819ab25717ec0590d9584ef366"
dependencies = [
 "semver",
]

[[package]]
name = "rustix"
version = "0.38.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6ea3e1a662af26cd7a3ba09c0297a31af215563ecf42817c98df621387f4e949"
dependencies = [
 "bitflags 2.4.2",
 "errno",
 "libc",
 "linux-raw-sys",
 "windows-sys 0.52.0",
]

[[package]]
name = "rustls-pemfile"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1c74cae0a4cf6ccbbf5f359f08efdf8ee7e1dc532573bf0db71968cb56b1448c"
dependencies = [
 "base64",
]

[[package]]
name = "ryu"
version = "1.0.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fe232bdf6be8c8de797b22184ee71118d63780ea42ac85b61d1baa6d3b782ae9"

[[package]]
name = "same-file"
version = "1.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93fc1dc3aaa9bfed95e02e6eadabb4baf7e3078b0bd1b4d7b6b0b68378900502"
dependencies = [
 "winapi-util",
]

[[package]]
name = "schannel"
version = "0.1.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fbc91545643bcf3a0bbb6569265615222618bdf33ce4ffbbd13c4bbd4c093534"
dependencies = [
 "windows-sys 0.52.0",
]

[[package]]
name = "scopeguard"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd"

[[package]]
name = "scroll"
version = "0.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fda28d4b4830b807a8b43f7b0e6b5df875311b3e7621d84577188c175b6ec1ec"
dependencies = [
 "scroll_derive",
]

[[package]]
name = "scroll_derive"
version = "0.10.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aaaae8f38bb311444cfb7f1979af0bc9240d95795f75f9ceddf6a59b79ceffa0"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "secp256k1"
version = "0.24.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6b1629c9c557ef9b293568b338dddfc8208c98a18c59d722a9d53f859d9c9b62"
dependencies = [
 "secp256k1-sys",
]

[[package]]
name = "secp256k1-sys"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "83080e2c2fc1006e625be82e5d1eb6a43b7fd9578b617fcc55814daf286bba4b"
dependencies = [
 "cc",
]

[[package]]
name = "security-framework"
version = "2.9.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05b64fb303737d99b81884b2c63433e9ae28abebe5eb5045dcdd175dc2ecf4de"
dependencies = [
 "bitflags 1.3.2",
 "core-foundation",
 "core-foundation-sys",
 "libc",
 "security-framework-sys",
]

[[package]]
name = "security-framework-sys"
version = "2.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e932934257d3b408ed8f30db49d85ea163bfe74961f017f405b025af298f0c7a"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "semver"
version = "1.0.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bebd363326d05ec3e2f532ab7660680f3b02130d780c299bca73469d521bc0ed"

[[package]]
name = "serde"
version = "1.0.171"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "30e27d1e4fd7659406c492fd6cfaf2066ba8773de45ca75e855590f856dc34a9"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.171"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "389894603bd18c46fa56231694f8d827779c0951a667087194cf9de94ed24682"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.25",
]

[[package]]
name = "serde_json"
version = "1.0.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0f1e14e89be7aa4c4b78bdbdc9eb5bf8517829a600ae8eaa39a6e1d960b5185c"
dependencies = [
 "itoa",
 "ryu",
 "serde",
]

[[package]]
name = "serde_urlencoded"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3491c14715ca2294c4d6a88f15e84739788c1d030eed8c110436aafdaa2f3fd"
dependencies = [
 "form_urlencoded",
 "itoa",
 "ryu",
 "serde",
]

[[package]]
name = "sha3"
version = "0.10.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75872d278a8f37ef87fa0ddbda7802605cb18344497949862c0d4dcb291eba60"
dependencies = [
 "digest",
 "keccak",
]

[[package]]
name = "siphasher"
version = "0.3.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7bd3e3206899af3f8b12af284fafc038cc1dc2b41d1b89dd17297221c5d225de"

[[package]]
name = "slab"
version = "0.4.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f92a496fb766b417c996b9c5e57daf2f7ad3b0bebe1ccfca4856390e3d3bb67"
dependencies = [
 "autocfg",
]

[[package]]
name = "smallvec"
version = "1.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62bb4feee49fdd9f707ef802e22365a35de4b7b299de4763d44bfea899442ff9"

[[package]]
name = "socket2"
version = "0.5.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05ffd9c0a93b7543e062e759284fcf5f5e3b098501104bfbdde4d404db792871"
dependencies = [
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "sparse-merkle-tree"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8851f6c92491ebe5528eabc1244292175a739eb0162974f9f9670a7dc748748b"
dependencies = [
 "blake2b-rs",
 "cc",
 "cfg-if 0.1.10",
]

[[package]]
name = "spore-errors"
version = "0.1.0"
dependencies = [
 "ckb-std",
]

[[package]]
name = "spore-types"
version = "0.1.0"
dependencies = [
 "molecule",
]

[[package]]
name = "spore-utils"
version = "0.1.0"
dependencies = [
 "ckb-std",
 "ckb-transaction-cobuild",
 "spore-errors",
 "spore-types",
]

[[package]]
name = "syn"
version = "1.0.109"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "syn"
version = "2.0.25"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "15e3fc8c0c74267e2df136e5e5fb656a464158aa57624053375eb9c8c6e25ae2"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "sync_wrapper"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2047c6ded9c721764247e62cd3b03c09ffc529b2ba5b10ec482ae507a4a70160"

[[package]]
name = "system-configuration"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba3a3adc5c275d719af8cb4272ea1c4a6d668a777f37e115f6d11ddbc1c8e0e7"
dependencies = [
 "bitflags 1.3.2",
 "core-foundation",
 "system-configuration-sys",
]

[[package]]
name = "system-configuration-sys"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a75fb188eb626b924683e3b95e3a48e63551fcfb51949de2f06a9d91dbee93c9"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "tempfile"
version = "3.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85b77fafb263dd9d05cbeac119526425676db3784113aa9295c88498cbf8bff1"
dependencies = [
 "cfg-if 1.0.0",
 "fastrand",
 "rustix",
 "windows-sys 0.52.0",
]

[[package]]
name = "tests"
version = "0.1.0"
dependencies = [
 "ckb-sdk",
 "ckb-testtool",
 "hex",
 "serde_json",
 "spore-types",
 "spore-utils",
]

[[package]]
name = "thiserror"
version = "1.0.43"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a35fc5b8971143ca348fa6df4f024d4d55264f3468c71ad1c2f365b0a4d58c42"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "1.0.43"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "463fe12d7993d3b327787537ce8dd4dfa058de32fc2b195ef3cde03dc4771e8f"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.25",
]

[[package]]
name = "tinyvec"
version = "1.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87cc5ceb3875bb20c2890005a4e226a4651264a5c75edb2421b52861a0a0cb50"
dependencies = [
 "tinyvec_macros",
]

[[package]]
name = "tinyvec_macros"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"

[[package]]
name = "tokio"
version = "1.36.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "61285f6515fa018fb2d1e46eb21223fff441ee8db5d0f1435e8ab4f5cdb80931"
dependencies = [
 "backtrace",
 "bytes",
 "libc",
 "mio",
 "pin-project-lite",
 "socket2",
 "windows-sys 0.48.0",
]

[[package]]
name = "tokio-native-tls"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbae76ab933c85776efabc971569dd6119c580d8f5d448769dec1764bf796ef2"
dependencies = [
 "native-tls",
 "tokio",
]

[[package]]
name = "tokio-util"
version = "0.7.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5419f34732d9eb6ee4c3578b7989078579b7f039cbbb9ca2c4da015749371e15"
dependencies = [
 "bytes",
 "futures-core",
 "futures-sink",
 "pin-project-lite",
 "tokio",
 "tracing",
]

[[package]]
name = "toml"
version = "0.5.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f4f7f0dd8d50a853a531c426359045b1998f04219d88799810762cd4ad314234"
dependencies = [
 "serde",
]

[[package]]
name = "tower-service"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6bc1c9ce2b5135ac7f93c72918fc37feb872bdc6a5533a8b85eb4b86bfdae52"

[[package]]
name = "tracing"
version = "0.1.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3523ab5a71916ccf420eebdf5521fcef02141234bbc0b8a49f2fdc4544364ef"
dependencies = [
 "pin-project-lite",
 "tracing-core",
]

[[package]]
name = "tracing-core"
version = "0.1.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c06d3da6113f116aaee68e4d601191614c9053067f9ab7f6edbcb161237daa54"
dependencies = [
 "once_cell",
]

[[package]]
name = "try-lock"
version = "0.2.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e421abadd41a4225275504ea4d6566923418b7f05506fbc9c0fe86ba7396114b"

[[package]]
name = "typenum"
version = "1.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42ff0bf0c66b8238c6f3b578df37d0b7848e55df8577b3f74f92a69acceeb825"

[[package]]
name = "unicode-bidi"
version = "0.3.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "08f95100a766bf4f8f28f90d77e0a5461bbdb219042e7679bebe79004fed8d75"

[[package]]
name = "unicode-ident"
version = "1.0.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22049a19f4a68748a168c0fc439f9516686aa045927ff767eca0a85101fb6e73"

[[package]]
name = "unicode-normalization"
version = "0.1.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a56d1686db2308d901306f92a263857ef59ea39678a5458e7cb17f01415101f5"
dependencies = [
 "tinyvec",
]

[[package]]
name = "url"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "31e6302e3bb753d46e83516cae55ae196fc0c309407cf11ab35cc51a4c2a4633"
dependencies = [
 "form_urlencoded",
 "idna",
 "percent-encoding",
]

[[package]]
name = "vcpkg"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "accd4ea62f7bb7a82fe23066fb0957d48ef677f6eeb8215f372f52e48bb32426"

[[package]]
name = "version_check"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f"

[[package]]
name = "walkdir"
version = "2.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "36df944cda56c7d8d8b7496af378e6b16de9284591917d307c9b4d313c44e698"
dependencies = [
 "same-file",
 "winapi-util",
]

[[package]]
name = "want"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bfa7760aed19e106de2c7c0b581b509f2f25d3dacaf737cb82ac61bc6d760b0e"
dependencies = [
 "try-lock",
]

[[package]]
name = "wasi"
version = "0.9.0+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cccddf32554fecc6acb585f82a32a72e28b48f8c4c1883ddfeeeaa96f7d8e519"

[[package]]
name = "wasi"
version = "0.11.0+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"

[[package]]
name = "wasm-bindgen"
version = "0.2.92"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4be2531df63900aeb2bca0daaaddec08491ee64ceecbee5076636a3b026795a8"
dependencies = [
 "cfg-if 1.0.0",
 "wasm-bindgen-macro",
]

[[package]]
name = "wasm-bindgen-backend"
version = "0.2.92"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "614d787b966d3989fa7bb98a654e369c762374fd3213d212cfc0251257e747da"
dependencies = [
 "bumpalo",
 "log",
 "once_cell",
 "proc-macro2",
 "quote",
 "syn 2.0.25",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-futures"
version = "0.4.42"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "76bc14366121efc8dbb487ab05bcc9d346b3b5ec0eaa76e46594cabbe51762c0"
dependencies = [
 "cfg-if 1.0.0",
 "js-sys",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.92"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a1f8823de937b71b9460c0c34e25f3da88250760bec0ebac694b49997550d726"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.92"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e94f17b526d0a461a191c78ea52bbce64071ed5c04c9ffe424dcb38f74171bb7"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.25",
 "wasm-bindgen-backend",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.92"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "af190c94f2773fdb3729c55b007a722abb5384da03bc0986df4c289bf5567e96"

[[package]]
name = "web-sys"
version = "0.3.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77afa9a11836342370f4817622a2f0f418b134426d91a82dfb48f532d2ec13ef"
dependencies = [
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-util"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70ec6ce85bb158151cae5e5c87f95a8e97d2c0c4b001223f33a334e3ce5de178"
dependencies = [
 "winapi",
]

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "windows-sys"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "677d2418bec65e3338edb076e806bc1ec15693c5d0104683f2efe857f61056a9"
dependencies = [
 "windows-targets 0.48.1",
]

[[package]]
name = "windows-sys"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
dependencies = [
 "windows-targets 0.52.4",
]

[[package]]
name = "windows-targets"
version = "0.48.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05d4b17490f70499f20b9e791dcf6a299785ce8af4d709018206dc5b4953e95f"
dependencies = [
 "windows_aarch64_gnullvm 0.48.0",
 "windows_aarch64_msvc 0.48.0",
 "windows_i686_gnu 0.48.0",
 "windows_i686_msvc 0.48.0",
 "windows_x86_64_gnu 0.48.0",
 "windows_x86_64_gnullvm 0.48.0",
 "windows_x86_64_msvc 0.48.0",
]

[[package]]
name = "windows-targets"
version = "0.52.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7dd37b7e5ab9018759f893a1952c9420d060016fc19a472b4bb20d1bdd694d1b"
dependencies = [
 "windows_aarch64_gnullvm 0.52.4",
 "windows_aarch64_msvc 0.52.4",
 "windows_i686_gnu 0.52.4",
 "windows_i686_msvc 0.52.4",
 "windows_x86_64_gnu 0.52.4",
 "windows_x86_64_gnullvm 0.52.4",
 "windows_x86_64_msvc 0.52.4",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "91ae572e1b79dba883e0d315474df7305d12f569b400fcf90581b06062f7e1bc"

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bcf46cf4c365c6f2d1cc93ce535f2c8b244591df96ceee75d8e83deb70a9cac9"

[[package]]
name = "windows_aarch64_msvc"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b2ef27e0d7bdfcfc7b868b317c1d32c641a6fe4629c171b8928c7b08d98d7cf3"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "da9f259dd3bcf6990b55bffd094c4f7235817ba4ceebde8e6d11cd0c5633b675"

[[package]]
name = "windows_i686_gnu"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "622a1962a7db830d6fd0a69683c80a18fda201879f0f447f065a3b7467daa241"

[[package]]
name = "windows_i686_gnu"
version = "0.52.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b474d8268f99e0995f25b9f095bc7434632601028cf86590aea5c8a5cb7801d3"

[[package]]
name = "windows_i686_msvc"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4542c6e364ce21bf45d69fdd2a8e455fa38d316158cfd43b3ac1c5b1b19f8e00"

[[package]]
name = "windows_i686_msvc"
version = "0.52.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1515e9a29e5bed743cb4415a9ecf5dfca648ce85ee42e15873c3cd8610ff8e02"

[[package]]
name = "windows_x86_64_gnu"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ca2b8a661f7628cbd23440e50b05d705db3686f894fc9580820623656af974b1"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5eee091590e89cc02ad514ffe3ead9eb6b660aedca2183455434b93546371a03"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7896dbc1f41e08872e9d5e8f8baa8fdd2677f29468c4e156210174edc7f7b953"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77ca79f2451b49fa9e2af39f0747fe999fcda4f5e241b2898624dca97a1f2177"

[[package]]
name = "windows_x86_64_msvc"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a515f5799fe4961cb532f983ce2b23082366b898e52ffbce459c86f67c8378a"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32b752e52a2da0ddfbdbcc6fceadfeede4c939ed16d13e648833a61dfb611ed8"

[[package]]
name = "winreg"
version = "0.50.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "524e57b2c537c0f9b1e69f1965311ec12182b4122e45035b1508cd24d2adadb1"
dependencies = [
 "cfg-if 1.0.0",
 "windows-sys 0.48.0",
]


================================================
File: tests/Cargo.toml
================================================
[package]
name = "tests"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
ckb-testtool = "0.10.0"
ckb-sdk = "3.0.1"
hex = { version = "0.4.3" }
serde_json = "1.0"

spore-types = { path = "../lib/types" }
spore-utils = { path = "../lib/utils" }


================================================
File: tests/src/lib.rs
================================================
use ckb_testtool::ckb_types::bytes::Bytes;
use std::env;
use std::fs;
use std::path::PathBuf;
use std::str::FromStr;

#[allow(dead_code)]
const MAX_CYCLES: u64 = 10_000_000;

#[cfg(test)]
mod tests;
mod utils;

const TEST_ENV_VAR: &str = "CAPSULE_TEST_ENV";

pub enum TestEnv {
    Debug,
    Release,
}

impl FromStr for TestEnv {
    type Err = &'static str;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "debug" => Ok(TestEnv::Debug),
            "release" => Ok(TestEnv::Release),
            _ => Err("no match"),
        }
    }
}

pub struct Loader(PathBuf);

impl Default for Loader {
    fn default() -> Self {
        let test_env = match env::var(TEST_ENV_VAR) {
            Ok(val) => val.parse().expect("test env"),
            Err(_) => TestEnv::Debug,
        };
        Self::with_test_env(test_env)
    }
}

impl Loader {
    fn with_test_env(env: TestEnv) -> Self {
        let load_prefix = match env {
            TestEnv::Debug => "debug",
            TestEnv::Release => "release",
        };
        let dir = env::current_dir().unwrap();
        let mut base_path = PathBuf::new();
        base_path.push(dir);
        base_path.push("..");
        base_path.push("build");
        base_path.push(load_prefix);
        Loader(base_path)
    }

    pub fn load_binary(&self, name: &str) -> Bytes {
        let mut path = self.0.clone();
        path.push(name);
        fs::read(path).expect("binary").into()
    }
}


================================================
File: tests/src/tests.rs
================================================
mod cluster;
mod mutant;
mod spore;
mod utils;

#[cfg(test)]
mod xxx {
    use std::str::FromStr;

    use ckb_sdk::{Address, CkbRpcClient};
    use ckb_testtool::ckb_jsonrpc_types::{Either, TransactionView as JsonTxView};
    use ckb_testtool::ckb_types::core::{DepType, TransactionView};
    use ckb_testtool::ckb_types::h256;
    use ckb_testtool::ckb_types::packed::{CellDep, CellInput, CellOutput, OutPoint};
    use ckb_testtool::ckb_types::prelude::{Builder, Entity, Pack};

    #[ignore = "used to generate consuming transaction"]
    #[test]
    fn burn_spore_contract() {
        let tx_hash = h256!("0xcb67e11a39594a183eae50664073a85fa0140ae25480df61114aca0e47726d38");
        let index = 0u32;
        let payee_address = "ckb1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsqfqmf4hphl9jkrw3934mwe6m3a2nx88rzgrd9gqh";
        let network = "https://mainnet.ckb.dev/";

        // fetch deployed spore contract cell
        let rpc = CkbRpcClient::new(network);
        let raw_tx = rpc
            .get_transaction(tx_hash.clone())
            .unwrap()
            .unwrap()
            .transaction
            .unwrap()
            .inner;
        let tx = match raw_tx {
            Either::Left(tx) => tx,
            Either::Right(bytes) => serde_json::from_slice(bytes.as_bytes()).unwrap(),
        };
        let spore_contract_cell = tx.inner.outputs.get(index as usize).unwrap();
        println!("spore contract cell: {spore_contract_cell:?}");

        // confirm payee address
        let address = Address::from_str(payee_address).unwrap();
        println!("address payload: {address:?}");

        // assemble burn transaction
        let input_cell = CellInput::new_builder()
            .previous_output(
                OutPoint::new_builder()
                    .tx_hash(tx_hash.pack())
                    .index(index.pack())
                    .build(),
            )
            .build();
        let capacity: u64 = spore_contract_cell.capacity.into();
        let output_cell = CellOutput::new_builder()
            .lock(address.payload().into())
            .capacity((capacity - 100_000_000u64).pack())
            .build();
        let dep_cell = CellDep::new_builder()
            .out_point(
                OutPoint::new_builder()
                    .tx_hash(
                        h256!("0x71a7ba8fc96349fea0ed3a5c47992e3b4084b031a42264a018e0072e8172e46c")
                            .pack(),
                    )
                    .index(0u32.pack())
                    .build(),
            )
            .dep_type(DepType::DepGroup.into())
            .build();
        let tx = TransactionView::new_advanced_builder()
            .input(input_cell)
            .output(output_cell)
            .output_data(Default::default())
            .cell_dep(dep_cell)
            .build();
        let json_tx = serde_json::to_string_pretty(&JsonTxView::from(tx)).unwrap();
        println!("tx = {json_tx}");
        std::fs::write("../deployment/tx.json", json_tx).unwrap();
    }
}


================================================
File: tests/src/tests/cluster.rs
================================================
use ckb_testtool::ckb_hash::blake2b_256;
use ckb_testtool::ckb_types::{core::TransactionBuilder, packed, prelude::*};
use ckb_testtool::context::Context;

use crate::utils::co_build::*;
use crate::utils::*;
use crate::MAX_CYCLES;

mod simple_cluster_mint {
    use super::*;

    fn make_simple_cluster_mint(cluster_out_index: usize) {
        let mut context = Context::default();
        let input_cell = build_normal_input(&mut context);

        let cluster = build_serialized_cluster_data("Spore Cluster", "Test Cluster");
        let (cluster_out_point, cluster_script_dep) =
            build_spore_contract_materials(&mut context, "cluster");
        let cluster_type_id = build_type_id(&input_cell, cluster_out_index);
        let type_ = build_spore_type_script(
            &mut context,
            &cluster_out_point,
            cluster_type_id.to_vec().into(),
        );
        let cluster_out_cell = build_normal_output_cell_with_type(&mut context, type_.clone());

        let tx = TransactionBuilder::default()
            .input(input_cell)
            .output(cluster_out_cell)
            .output_data(cluster.as_slice().pack())
            .cell_dep(cluster_script_dep)
            .build();

        let action = build_mint_cluster_action(&mut context, cluster_type_id, cluster.as_slice());
        let tx = complete_co_build_message_with_actions(tx, &[(type_, action)]);

        let tx = context.complete_tx(tx);

        context
            .verify_tx(&tx, MAX_CYCLES)
            .expect("test simple spore mint");
    }

    #[test]
    fn test_simple_cluster_mint() {
        make_simple_cluster_mint(0);
    }

    #[should_panic]
    #[test]
    fn test_simple_cluster_mint_failed_with_wrong_out_index() {
        make_simple_cluster_mint(1);
    }
}

#[cfg(test)]
mod simple_cluster_transfer {
    use super::*;

    fn make_simple_cluster_transfer(new_cluster_data_desc: &str, new_cluster_out_index: usize) {
        let mut context = Context::default();
        let normal_cell = build_normal_input(&mut context);
        let (cluster_out_point, cluster_script_dep) =
            build_spore_contract_materials(&mut context, "cluster");

        // cluster in Input
        let old_cluster_data =
            build_serialized_cluster_data("Spore Cluster", "Test Cluster Transfer");
        let old_cluster_type_id = build_type_id(&normal_cell, 0);
        let type_ = build_spore_type_script(
            &mut context,
            &cluster_out_point,
            old_cluster_type_id.to_vec().into(),
        );
        let old_cluster_cell = build_cluster_input(&mut context, old_cluster_data, type_);

        // cluster in Output
        let new_cluster_data =
            build_serialized_cluster_data("Spore Cluster", new_cluster_data_desc);
        let new_cluster_type_id = build_type_id(&normal_cell, new_cluster_out_index);
        let type_ = build_spore_type_script(
            &mut context,
            &cluster_out_point,
            new_cluster_type_id.to_vec().into(),
        );
        let new_cluster_cell = build_normal_output_cell_with_type(&mut context, type_.clone());

        // build cluster transfer tx
        let tx = TransactionBuilder::default()
            .input(old_cluster_cell)
            .output(new_cluster_cell)
            .output_data(new_cluster_data.as_slice().pack())
            .cell_dep(cluster_script_dep)
            .build();

        let action = build_transfer_cluster_action(&mut context, new_cluster_type_id);
        let tx = complete_co_build_message_with_actions(tx, &[(type_, action)]);

        let tx = context.complete_tx(tx);

        context
            .verify_tx(&tx, MAX_CYCLES)
            .expect("test cluster transfer");
    }

    #[test]
    fn test_simple_cluster_transfer() {
        make_simple_cluster_transfer("Test Cluster Transfer", 0);
    }

    #[should_panic]
    #[test]
    fn test_simple_cluster_transfer_failed_with_wrong_cluster_data() {
        make_simple_cluster_transfer("Test New Cluster Transfer", 0);
    }

    #[should_panic]
    #[test]
    fn test_simple_cluster_transfer_failed_with_wrong_type_id() {
        make_simple_cluster_transfer("Test Cluster Transfer", 1);
    }
}

#[should_panic]
#[test]
fn test_simple_cluster_destroy_failed() {
    let mut context = Context::default();

    let cluster = build_serialized_cluster_data("Spore Cluster", "Test Cluster");

    let (cluster_out_point, cluster_script_dep) =
        build_spore_contract_materials(&mut context, "cluster");
    let cluster_id = build_type_id(&build_normal_input(&mut context), 0);
    let type_ =
        build_spore_type_script(&mut context, &cluster_out_point, cluster_id.to_vec().into());

    let cluster_input = build_cluster_input(&mut context, cluster, type_.clone());
    let output_cell = build_normal_output(&mut context);

    let tx = TransactionBuilder::default()
        .input(cluster_input)
        .output(output_cell)
        .output_data(packed::Bytes::default())
        .cell_dep(cluster_script_dep)
        .build();
    let tx = context.complete_tx(tx);

    context
        .verify_tx(&tx, MAX_CYCLES)
        .expect("test destroy cluster");
}

#[test]
fn test_simple_spore_mint_with_cluster() {
    let cluster_id = blake2b_256("12345678");
    let serialized = build_serialized_spore_data(
        "Hello Spore!".as_bytes().to_vec(),
        "plain/text",
        Some(cluster_id.to_vec()),
    );

    let mut context = Context::default();
    let tx = build_single_spore_mint_in_cluster_tx(&mut context, serialized, cluster_id);
    let tx = context.complete_tx(tx);

    // run
    context
        .verify_tx(&tx, MAX_CYCLES)
        .expect("pass verification");
}

#[test]
fn test_cluster_agent_mint() {
    let mut context = Context::default();

    let input_cell = build_normal_input(&mut context);

    // cluster
    let cluster = build_serialized_cluster_data("Spore Cluster", "Test Cluster");
    let (cluster_out_point, cluster_script_dep) =
        build_spore_contract_materials(&mut context, "cluster");
    let cluster_id = build_type_id(&input_cell, 0);
    let cluster_type =
        build_spore_type_script_with_payment(&mut context, &cluster_out_point, &cluster_id, 1);
    let cluster_dep = build_normal_cell_dep(&mut context, cluster.as_slice(), cluster_type);

    // proxy
    let (proxy_out_point, proxy_script_dep) =
        build_spore_contract_materials(&mut context, "cluster_proxy");
    let proxy_id = build_type_id(&input_cell, 1);
    let proxy_type =
        build_spore_type_script_with_payment(&mut context, &proxy_out_point, &proxy_id, 1);
    let proxy_dep = build_normal_cell_dep(&mut context, &cluster_id, proxy_type.clone());
    let proxy_type_hash = proxy_type.unwrap_or_default().calc_script_hash();

    // agent
    let (agent_out_point, agent_script_dep) =
        build_spore_contract_materials(&mut context, "cluster_agent");
    let agent_type =
        build_spore_type_script(&mut context, &agent_out_point, cluster_id.to_vec().into());
    let agent_out_cell = build_normal_output_cell_with_type(&mut context, agent_type.clone())
        .as_builder()
        .capacity((2 * CAPACITY_UNIT).pack())
        .build();

    let tx = TransactionBuilder::default()
        .input(input_cell)
        .output(agent_out_cell)
        .output_data(proxy_type_hash.as_slice().pack())
        .cell_deps(vec![
            cluster_script_dep,
            proxy_script_dep,
            agent_script_dep,
            cluster_dep,
            proxy_dep,
        ])
        .build();

    let action = build_mint_agent_action(&mut context, cluster_id, proxy_id);
    let tx = complete_co_build_message_with_actions(tx, &[(agent_type, action)]);

    let tx = context.complete_tx(tx);

    context
        .verify_tx(&tx, MAX_CYCLES)
        .expect("test cluster_agent create");
}

mod cluster_agent_transfer {
    use super::*;

    fn make_cluster_agent_transfer(new_agent_data: &[u8], new_cluster_out_index: usize) {
        let mut context = Context::default();
        let input_cell = build_normal_input(&mut context);
        let (agent_out_point, agent_script_dep) =
            build_spore_contract_materials(&mut context, "cluster_agent");

        // agent in Input
        let old_cluster_id = build_type_id(&input_cell, 0);
        let old_agent_data = blake2b_256("12345676890");
        let old_agent_type = build_spore_type_script_with_payment(
            &mut context,
            &agent_out_point,
            &old_cluster_id,
            1,
        );
        let old_agent_cell = build_agent_proxy_input(&mut context, &old_agent_data, old_agent_type);

        // agent in Output
        let new_cluster_id = build_type_id(&input_cell, new_cluster_out_index);
        let new_agent_type = build_spore_type_script_with_payment(
            &mut context,
            &agent_out_point,
            &new_cluster_id,
            1,
        );
        let new_agent_cell =
            build_normal_output_cell_with_type(&mut context, new_agent_type.clone());

        // build agent transfer tx
        let tx = TransactionBuilder::default()
            .input(old_agent_cell)
            .output(new_agent_cell)
            .output_data(new_agent_data.pack())
            .cell_dep(agent_script_dep)
            .build();

        let action = build_transfer_agent_action(&mut context, new_cluster_id);
        let tx = complete_co_build_message_with_actions(tx, &[(new_agent_type, action)]);

        let tx = context.complete_tx(tx);

        context
            .verify_tx(&tx, MAX_CYCLES)
            .expect("test agent transfer");
    }

    #[test]
    fn test_cluster_agent_transfer() {
        let proxy_type_hash = blake2b_256("12345676890");
        make_cluster_agent_transfer(&proxy_type_hash, 0);
    }

    #[should_panic]
    #[test]
    fn test_cluster_agent_transfer_failed_with_wrong_data() {
        make_cluster_agent_transfer(&[1u8], 0);
    }

    #[should_panic]
    #[test]
    fn test_cluster_agent_transfer_failed_with_wrong_cluster_id() {
        let proxy_type_hash = blake2b_256("12345676890");
        make_cluster_agent_transfer(&proxy_type_hash, 1);
    }
}

#[test]
fn test_cluster_agent_burn() {
    let mut context = Context::default();
    let input_cell = build_normal_input(&mut context);
    let (agent_out_point, agent_script_dep) =
        build_spore_contract_materials(&mut context, "cluster_agent");

    // agent in Input
    let cluster_id = build_type_id(&input_cell, 0);
    let agent_data = blake2b_256("12345676890");
    let agent_type =
        build_spore_type_script_with_payment(&mut context, &agent_out_point, &cluster_id, 1);
    let agent_cell = build_agent_proxy_input(&mut context, &agent_data, agent_type.clone());

    // build agent burn tx
    let normal_cell = build_normal_output(&mut context);
    let tx = TransactionBuilder::default()
        .input(agent_cell)
        .output(normal_cell)
        .output_data(Default::default())
        .cell_dep(agent_script_dep)
        .build();

    let action = build_burn_agent_action(&mut context, cluster_id);
    let tx = complete_co_build_message_with_actions(tx, &[(agent_type, action)]);

    let tx = context.complete_tx(tx);

    context.verify_tx(&tx, MAX_CYCLES).expect("test agent burn");
}

#[test]
fn test_cluster_proxy_mint() {
    let mut context = Context::default();

    let input_cell = build_normal_input(&mut context);

    // cluster
    let cluster = build_serialized_cluster_data("Spore Cluster", "Test Cluster");
    let (cluster_out_point, cluster_script_dep) =
        build_spore_contract_materials(&mut context, "cluster");
    let cluster_id = build_type_id(&input_cell, 1);
    let cluster_type =
        build_spore_type_script(&mut context, &cluster_out_point, cluster_id.to_vec().into());
    let cluster_dep = build_normal_cell_dep(&mut context, cluster.as_slice(), cluster_type);

    // proxy
    let (proxy_out_point, proxy_script_dep) =
        build_spore_contract_materials(&mut context, "cluster_proxy");
    let proxy_id = build_type_id(&input_cell, 0);
    let proxy_type =
        build_spore_type_script_with_payment(&mut context, &proxy_out_point, &proxy_id, 1);
    let proxy_out_cell = build_normal_output_cell_with_type(&mut context, proxy_type.clone());

    let tx = TransactionBuilder::default()
        .input(input_cell)
        .output(proxy_out_cell)
        .output_data(cluster_id.to_vec().pack())
        .cell_deps(vec![cluster_script_dep, proxy_script_dep, cluster_dep])
        .build();

    let action = build_mint_proxy_action(&mut context, cluster_id, proxy_id);
    let tx = complete_co_build_message_with_actions(tx, &[(proxy_type, action)]);

    let tx = context.complete_tx(tx);

    context
        .verify_tx(&tx, MAX_CYCLES)
        .expect("test spore mint with lock proxy");
}

mod cluster_proxy_transfer {
    use super::*;

    fn make_cluster_proxy_transfer(new_proxy_out_index: usize, new_cluster_id: [u8; 32]) {
        let mut context = Context::default();
        let input_cell = build_normal_input(&mut context);
        let (proxy_out_point, proxy_script_dep) =
            build_spore_contract_materials(&mut context, "cluster_proxy");

        // proxy in Input
        let old_cluster_id = blake2b_256("12345678");
        let old_proxy_id = build_type_id(&input_cell, 0);
        let old_proxy_type =
            build_spore_type_script_with_payment(&mut context, &proxy_out_point, &old_proxy_id, 1);
        let old_proxy_cell = build_agent_proxy_input(&mut context, &old_cluster_id, old_proxy_type);

        // proxy in Output
        let new_proxy_id = build_type_id(&input_cell, new_proxy_out_index);
        let new_proxy_type =
            build_spore_type_script_with_payment(&mut context, &proxy_out_point, &new_proxy_id, 1);
        let new_proxy_cell =
            build_normal_output_cell_with_type(&mut context, new_proxy_type.clone());

        // build proxy transfer tx
        let tx = TransactionBuilder::default()
            .input(old_proxy_cell)
            .output(new_proxy_cell)
            .output_data(new_cluster_id.to_vec().pack())
            .cell_dep(proxy_script_dep)
            .build();

        let action = build_transfer_proxy_action(&mut context, old_cluster_id, old_proxy_id);
        let tx = complete_co_build_message_with_actions(tx, &[(new_proxy_type, action)]);

        let tx = context.complete_tx(tx);

        context
            .verify_tx(&tx, MAX_CYCLES)
            .expect("test proxy transfer");
    }

    #[test]
    fn test_cluster_proxy_transfer() {
        let new_cluster_id = blake2b_256("12345678");
        make_cluster_proxy_transfer(0, new_cluster_id);
    }

    #[should_panic]
    #[test]
    fn test_cluster_proxy_transfer_failed_with_wrong_proxy_id() {
        let new_cluster_id = blake2b_256("12345678");
        make_cluster_proxy_transfer(1, new_cluster_id);
    }

    #[should_panic]
    #[test]
    fn test_cluster_proxy_transfer_failed_with_wrong_cluster_id() {
        let new_cluster_id = blake2b_256("87654321");
        make_cluster_proxy_transfer(0, new_cluster_id);
    }
}

#[test]
fn test_cluster_proxy_burn() {
    let mut context = Context::default();
    let input_cell = build_normal_input(&mut context);
    let (proxy_out_point, proxy_script_dep) =
        build_spore_contract_materials(&mut context, "cluster_proxy");

    // proxy in Input
    let cluster_id = blake2b_256("12345678");
    let proxy_id = build_type_id(&input_cell, 0);
    let proxy_type =
        build_spore_type_script_with_payment(&mut context, &proxy_out_point, &proxy_id, 1);
    let proxy_cell = build_agent_proxy_input(&mut context, &cluster_id, proxy_type.clone());

    // build proxy burn tx
    let normal_cell = build_normal_output(&mut context);
    let tx = TransactionBuilder::default()
        .input(proxy_cell)
        .output(normal_cell)
        .output_data(Default::default())
        .cell_dep(proxy_script_dep)
        .build();

    let action = build_burn_proxy_action(&mut context, cluster_id, proxy_id);
    let tx = complete_co_build_message_with_actions(tx, &[(proxy_type, action)]);

    let tx = context.complete_tx(tx);

    context.verify_tx(&tx, MAX_CYCLES).expect("test proxy burn");
}


================================================
File: tests/src/tests/mutant.rs
================================================
use ckb_testtool::ckb_types::{core::TransactionBuilder, prelude::*};
use ckb_testtool::context::Context;

use crate::utils::*;
use crate::MAX_CYCLES;

#[test]
fn test_simple_mutant_mint() {
    let mut context = Context::default();

    let (_, lua_lib_dep) = build_spore_contract_materials(&mut context, "libckblua.so");
    let (spore_extension_out_point, spore_extension_script_dep) =
        build_spore_contract_materials(&mut context, "spore_extension_lua");

    let lua_code = String::from("print('hello world')");
    let input_cell = build_normal_input(&mut context);

    println!(
        "input cell hash: {:?}, out_index: {}",
        input_cell.previous_output().tx_hash().unpack().to_string(),
        0
    );
    let mutant_id = build_type_id(&input_cell, 0);
    let type_ = build_spore_type_script(
        &mut context,
        &spore_extension_out_point,
        mutant_id.to_vec().into(),
    );

    let mutant_cell_output = build_normal_output_cell_with_type(&mut context, type_.clone());

    let tx = TransactionBuilder::default()
        .input(input_cell)
        .output(mutant_cell_output)
        .output_data(lua_code.pack())
        .cell_deps(vec![lua_lib_dep, spore_extension_script_dep])
        .build();

    let tx = context.complete_tx(tx);

    context
        .verify_tx(&tx, MAX_CYCLES)
        .expect("test mint mutant_cell");
}

#[test]
fn test_simple_mutant_spore_mint_without_cluster() {
    let mut context = Context::default();

    let lua_code = "print('hello world')";
    let (tx, mutant_id) = build_single_mutant_celldep_tx(&mut context, lua_code, 1);

    println!("mutant_id: {mutant_id:?}");
    let content_type = format!("plain/test;mutant[]={}", hex::encode(mutant_id));
    let (output_data, normal_input, spore_output, spore_celldep) = build_spore_output_materials(
        &mut context,
        "mutant spore".as_bytes().to_vec(),
        &content_type,
        0,
        None,
    );

    let tx = tx
        .as_advanced_builder()
        .input(normal_input)
        .output(spore_output)
        .output_data(output_data.as_bytes().pack())
        .cell_dep(spore_celldep)
        .build();
    let tx = context.complete_tx(tx);

    context
        .verify_tx(&tx, MAX_CYCLES)
        .expect("test mint mutant spore cell (no cluster)");
}


================================================
File: tests/src/tests/spore.rs
================================================
use ckb_testtool::ckb_hash::blake2b_256;
use ckb_testtool::ckb_types::{bytes::Bytes, core::TransactionBuilder, packed, prelude::*};
use ckb_testtool::context::Context;

use crate::utils::co_build::*;
use crate::utils::*;
use crate::MAX_CYCLES;

mod simple_spore_mint {
    use super::*;
    use std::fs::File;
    use std::io::{BufReader, Read};

    fn make_simple_spore_mint(output_data: Vec<u8>, content_type: &str) -> Result<u64, String> {
        let mut context = Context::default();
        let tx = build_single_spore_mint_tx(&mut context, output_data, content_type, None, None);
        let tx = context.complete_tx(tx);
        context
            .verify_tx(&tx, MAX_CYCLES)
            .map_err(|err| format!("test simple spore mint: {err}"))
    }

    #[test]
    fn test_simple_spore_mint() {
        make_simple_spore_mint("THIS IS A TEST NFT".as_bytes().to_vec(), "plain/text").unwrap();
    }

    #[test]
    fn test_simple_spore_mint_from_jpeg_image() {
        let jpeg = File::open("resource/test.jpg").unwrap();
        let mut reader = BufReader::new(jpeg);
        let mut buffer = Vec::new();
        reader.read_to_end(&mut buffer).expect("Error read to end");

        make_simple_spore_mint(buffer, "image/jpeg").unwrap();
    }

    #[should_panic]
    #[test]
    fn test_simple_spore_mint_failed_with_empty_content() {
        make_simple_spore_mint(vec![], "plain/text").unwrap();
    }

    #[should_panic]
    #[test]
    fn test_simple_spore_mint_failed_with_empty_content_type() {
        make_simple_spore_mint("THIS IS A TEST NFT".as_bytes().to_vec(), "").unwrap();
    }

    #[should_panic = "all failed"]
    #[test]
    fn test_simple_spore_mint_failed_with_wrong_content_types() {
        let output_data = "THIS IS A TEST NFT".as_bytes().to_vec();

        let all_failed = ["plain/;", "text", ";", "-", "plain/", "plain/test;;test=;"]
            .into_iter()
            .map(|content_type| make_simple_spore_mint(output_data.clone(), content_type))
            .all(|v| v.is_err());

        assert!(all_failed == false, "all failed");
    }
}

#[test]
fn test_simple_spore_mint_with_extra_cells() {
    let mut context = Context::default();

    let tx = build_single_spore_mint_tx(
        &mut context,
        "THIS IS A TEST NFT".as_bytes().to_vec(),
        "plain/text",
        None,
        None,
    );

    let extra_input_cell_1 = build_normal_input(&mut context);
    let extra_input_cell_2 = build_normal_input(&mut context);
    let extra_output_cell = build_normal_output(&mut context);

    let tx = tx
        .as_advanced_builder()
        .inputs(vec![extra_input_cell_1, extra_input_cell_2])
        .output(extra_output_cell)
        .output_data(Bytes::default().pack())
        .build();

    let tx = context.complete_tx(tx);

    context
        .verify_tx(&tx, MAX_CYCLES)
        .expect("test simple spore mint with multi normal cells");
}

#[test]
fn test_multi_spores_mint() {
    let mut context = Context::default();

    // multiple mint tx test
    let serialized =
        build_serialized_spore_data("Hello Spore!".as_bytes().to_vec(), "plain/text", None);

    let (spore_out_point, spore_script_dep) = build_spore_contract_materials(&mut context, "spore");

    let input_cell_1 = build_normal_input(&mut context);
    let input_cell_2 = build_normal_input(&mut context);
    let input_cell_3 = build_normal_input(&mut context);

    let spore_id_1 = build_type_id(&input_cell_1, 0);
    let spore_type_1 =
        build_spore_type_script(&mut context, &spore_out_point, spore_id_1.to_vec().into());

    let spore_id_2 = build_type_id(&input_cell_1, 2);
    let spore_type_2 =
        build_spore_type_script(&mut context, &spore_out_point, spore_id_2.to_vec().into());

    let spore_out_cell_1 = build_normal_output_cell_with_type(&mut context, spore_type_1.clone());
    let spore_out_cell_2 = build_normal_output_cell_with_type(&mut context, spore_type_2.clone());
    let output_cell = build_normal_output(&mut context);

    let tx = TransactionBuilder::default()
        .inputs(vec![input_cell_1, input_cell_2, input_cell_3])
        .outputs(vec![spore_out_cell_1, output_cell, spore_out_cell_2])
        .outputs_data(vec![
            serialized.as_slice().pack(),
            packed::Bytes::default(),
            serialized.as_slice().pack(),
        ])
        .cell_dep(spore_script_dep)
        .build();

    let action1 = build_mint_spore_action(&mut context, spore_id_1, serialized.as_slice());
    let action2 = build_mint_spore_action(&mut context, spore_id_2, serialized.as_slice());
    let tx = complete_co_build_message_with_actions(
        tx,
        &[(spore_type_1, action1), (spore_type_2, action2)],
    );

    let tx = context.complete_tx(tx);

    context
        .verify_tx(&tx, MAX_CYCLES)
        .expect("test multi spore mint");
}

mod spore_multipart_mint {
    use super::*;

    fn make_spore_multipart_mint(output_data: &str, content_type: &str) {
        let mut context = Context::default();
        let tx = build_single_spore_mint_tx(
            &mut context,
            output_data.as_bytes().to_vec(),
            content_type,
            None,
            None,
        );
        let tx = context.complete_tx(tx);
        context
            .verify_tx(&tx, MAX_CYCLES)
            .expect("test multipart mint");
    }

    #[test]
    fn test_spore_multipart_mint() {
        let output_data = "THIS IS A TEST MULTIPART NFT\n\n--SporeDefaultBoundary\nThis is an extra message I want to include";
        let content_type = "multipart/mixed;boundary=SporeDefaultBoundary";
        make_spore_multipart_mint(output_data, content_type);
    }

    #[should_panic]
    #[test]
    fn test_spore_multipart_mint_with_wrong_boundary_name() {
        let output_data = "THIS IS A TEST MULTIPART NFT\n\n--SporeDefaultBoundary\nThis is an extra message I want to include";
        let content_type = "multipart/mixed;boundary=SporeBoundary";
        make_spore_multipart_mint(output_data, content_type);
    }

    #[should_panic]
    #[test]
    fn test_spore_multipart_mint_failed_with_wrong_boundary_type() {
        let output_data = "THIS IS A TEST MULTIPART NFT\n\n--SporeDefaultBoundary\nThis is an extra message I want to include";
        let content_type = "multipart/mixed";
        make_spore_multipart_mint(output_data, content_type)
    }

    #[should_panic]
    #[test]
    fn test_spore_multipart_mint_failed_with_wrong_boundary_data() {
        let output_data =
            "THIS IS A TEST MULTIPART NFT\n\nThis is an extra message I want to include";
        let content_type = "multipart/mixed;boundary=SporeDefaultBoundary;";
        make_spore_multipart_mint(output_data, content_type);
    }
}

mod simple_spore_transfer {
    use super::*;

    fn make_simple_spore_transfer(new_content: Vec<u8>, new_out_index: usize) {
        let mut context = Context::default();
        let (spore_out_point, spore_script_dep) =
            build_spore_contract_materials(&mut context, "spore");
        let normal_input = &build_normal_input(&mut context);

        // build spore cell in Input
        let old_spore_id = build_type_id(&normal_input, 0);
        let old_serialized =
            build_serialized_spore_data("Hello Spore!".as_bytes().to_vec(), "plain/text", None);
        let old_spore_type =
            build_spore_type_script(&mut context, &spore_out_point, old_spore_id.to_vec().into());
        let spore_input = build_spore_input(&mut context, old_spore_type.clone(), old_serialized);

        // build spore cell in Output
        let new_spore_id = build_type_id(&normal_input, new_out_index);
        let new_serialized = build_serialized_spore_data(new_content, "plain/text", None);
        let new_spore_type =
            build_spore_type_script(&mut context, &spore_out_point, new_spore_id.to_vec().into());
        let spore_output = build_normal_output_cell_with_type(&mut context, new_spore_type.clone());

        // build spore transfer tx
        let tx = TransactionBuilder::default()
            .input(spore_input)
            .output(spore_output)
            .output_data(new_serialized.as_slice().pack())
            .cell_dep(spore_script_dep)
            .build();

        let action = build_transfer_spore_action(&mut context, old_spore_id);
        let tx = complete_co_build_message_with_actions(tx, &[(new_spore_type, action)]);

        let tx = context.complete_tx(tx);

        context
            .verify_tx(&tx, MAX_CYCLES)
            .expect("test simple spore transfer");
    }

    #[test]
    fn test_simple_spore_transfer() {
        make_simple_spore_transfer("Hello Spore!".as_bytes().to_vec(), 0);
    }

    #[should_panic]
    #[test]
    fn test_simple_spore_transfer_failed_with_wrong_content() {
        make_simple_spore_transfer("Hello New Spore!".as_bytes().to_vec(), 0);
    }

    #[should_panic]
    #[test]
    fn test_simple_spore_transfer_failed_with_wrong_out_index() {
        make_simple_spore_transfer("Hello Spore!".as_bytes().to_vec(), 1);
    }
}

mod spore_mint_from_cluster_lock_proxy {
    use super::*;

    fn make_spore_mint_from_cluster_lock_proxy(append_cluster_dep: bool, lock_args: &[u8]) {
        let mut context = Context::default();
        let (cluster_out_point, _) = build_spore_contract_materials(&mut context, "cluster");

        // build cluster celldep
        let cluster = build_serialized_cluster_data("Spore Cluster", "Test Cluster");
        let (cluster_id, _, _, _, cluster_dep) =
            build_cluster_materials(&mut context, &cluster_out_point, cluster, 0, lock_args);

        // build spore mint from cluster tx
        let mut tx = build_single_spore_mint_tx(
            &mut context,
            "Hello Spore!".as_bytes().to_vec(),
            "plain/text",
            None,
            Some(cluster_id),
        );
        if append_cluster_dep {
            tx = tx.as_advanced_builder().cell_dep(cluster_dep).build();
        }
        let tx = context.complete_tx(tx);

        context
            .verify_tx(&tx, MAX_CYCLES)
            .expect("test spore mint from lock proxy");
    }

    #[test]
    fn test_spore_mint_from_cluster_lock_proxy() {
        make_spore_mint_from_cluster_lock_proxy(true, &[]);
    }

    #[should_panic]
    #[test]
    fn test_spore_mint_from_cluster_lock_proxy_failed_without_cluster() {
        make_spore_mint_from_cluster_lock_proxy(false, &[]);
    }

    #[should_panic]
    #[test]
    fn test_spore_mint_from_cluster_lock_proxy_failed_with_wrong_cluster() {
        make_spore_mint_from_cluster_lock_proxy(true, &[1]);
    }
}

/// test creating Spore v2 with Cluster v1
#[test]
fn test_spore_mint_from_cluster_lock_proxy_compatible_v1() {
    let mut context = Context::default();
    let (cluster_out_point, _) = build_spore_contract_materials(&mut context, "cluster");

    // build cluster celldep
    let cluster = spore_types::generated::spore::ClusterData::new_builder()
        .name("Test Cluster".as_bytes().into())
        .description("Spore Cluster".as_bytes().into())
        .build();

    let cluster_id = blake2b_256("12345678");
    let cluster_type =
        build_spore_type_script(&mut context, &cluster_out_point, cluster_id.to_vec().into());
    let cluster_dep = build_normal_cell_dep_with_lock_args(
        &mut context,
        cluster.as_slice(),
        cluster_type.clone(),
        &[],
    );

    // build spore mint from cluster tx
    let tx = build_single_spore_mint_tx(
        &mut context,
        "Hello Spore!".as_bytes().to_vec(),
        "plain/text",
        None,
        Some(cluster_id),
    )
    .as_advanced_builder()
    .cell_dep(cluster_dep)
    .build();
    let tx = context.complete_tx(tx);

    context
        .verify_tx(&tx, MAX_CYCLES)
        .expect("test spore mint compatible v1");
}

mod spore_mint_from_cluster_transfer {
    use super::*;

    fn make_spore_mint_from_cluster_transfer(add_cluster_action: bool, add_cluster_dep: bool) {
        let mut context = Context::default();
        let (cluster_out_point, cluster_contract_dep) =
            build_spore_contract_materials(&mut context, "cluster");

        // build cluster materials
        let cluster = build_serialized_cluster_data("Spore Cluster", "Test Cluster");
        let (cluster_id, cluster_type, cluster_input, cluster_output, cluster_dep) =
            build_cluster_materials(&mut context, &cluster_out_point, cluster.clone(), 0, &[]);

        // build spore mint from cluster transfer tx
        let action = co_build::build_transfer_cluster_action(&mut context, cluster_id);
        let cluster_action = if add_cluster_action {
            vec![(cluster_type, action)]
        } else {
            vec![]
        };
        let mut tx = build_single_spore_mint_tx_with_extra_action(
            &mut context,
            "Hello Spore!".as_bytes().to_vec(),
            "plain/text",
            None,
            Some(cluster_id),
            cluster_action,
        );
        tx = tx
            .as_advanced_builder()
            .input(cluster_input)
            .output(cluster_output)
            .output_data(cluster.as_bytes().pack())
            .cell_dep(cluster_contract_dep)
            .build();
        if add_cluster_dep {
            tx = tx.as_advanced_builder().cell_dep(cluster_dep).build();
        }
        tx = context.complete_tx(tx);

        context
            .verify_tx(&tx, MAX_CYCLES)
            .expect("test spore mint from cluster transfer");
    }

    #[test]
    fn test_spore_mint_from_cluster_transfer() {
        make_spore_mint_from_cluster_transfer(true, true);
    }

    #[should_panic]
    #[test]
    fn test_spore_mint_from_cluster_transfer_failed_with_no_cluster_action() {
        make_spore_mint_from_cluster_transfer(false, true);
    }

    #[should_panic]
    #[test]
    fn test_spore_mint_from_cluster_transfer_failed_with_no_cluster_dep() {
        make_spore_mint_from_cluster_transfer(true, false);
    }
}

mod spore_mint_from_agent_lock_proxy {
    use super::*;
    use ckb_testtool::ckb_hash::blake2b_256;

    fn make_spore_mint_from_agent_lock_proxy(add_cluster_dep: bool) {
        let mut context = Context::default();
        let (cluster_out_point, _) = build_spore_contract_materials(&mut context, "cluster");
        let (agent_out_point, _) = build_spore_contract_materials(&mut context, "cluster_agent");

        // build cluster materials
        let cluster = build_serialized_cluster_data("Spore Cluster", "Test Cluster");
        let (cluster_id, _, _, _, cluster_dep) =
            build_cluster_materials(&mut context, &cluster_out_point, cluster.clone(), 0, &[]);

        // build cluster agent
        let proxy_type_hash = blake2b_256("12345678");
        let (_, _, _, agent_dep) = build_agent_materials(
            &mut context,
            &agent_out_point,
            &cluster_id,
            &proxy_type_hash,
        );

        // build spore mint from cluster transfer tx
        let mut tx = build_single_spore_mint_tx(
            &mut context,
            "Hello Spore!".as_bytes().to_vec(),
            "plain/text",
            None,
            Some(cluster_id),
        );
        tx = tx.as_advanced_builder().cell_dep(agent_dep).build();
        if add_cluster_dep {
            tx = tx.as_advanced_builder().cell_dep(cluster_dep).build();
        }
        tx = context.complete_tx(tx);

        context
            .verify_tx(&tx, MAX_CYCLES)
            .expect("test spore mint from cluster transfer");
    }

    #[test]
    fn test_spore_mint_from_agent_lock_proxy() {
        make_spore_mint_from_agent_lock_proxy(true);
    }

    #[should_panic]
    #[test]
    fn test_spore_mint_from_agent_lock_proxy_failed_with_no_cluster_dep() {
        make_spore_mint_from_agent_lock_proxy(false);
    }
}

mod spore_mint_from_agent_transfer {
    use super::*;
    use ckb_testtool::ckb_hash::blake2b_256;

    fn make_spore_mint_from_agent_transfer(add_cluster_dep: bool, add_agent_action: bool) {
        let mut context = Context::default();
        let (cluster_out_point, _) = build_spore_contract_materials(&mut context, "cluster");
        let (agent_out_point, agent_script_dep) =
            build_spore_contract_materials(&mut context, "cluster_agent");

        // build cluster materials
        let cluster = build_serialized_cluster_data("Spore Cluster", "Test Cluster");
        let (cluster_id, _, _, _, cluster_dep) =
            build_cluster_materials(&mut context, &cluster_out_point, cluster.clone(), 0, &[]);

        // build cluster agent
        let proxy_type_hash = blake2b_256("12345678");
        let (agent_type, agent_input, agent_output, _) = build_agent_materials(
            &mut context,
            &agent_out_point,
            &cluster_id,
            &proxy_type_hash,
        );

        // build spore mint from cluster transfer tx
        let action = co_build::build_transfer_agent_action(&mut context, cluster_id);
        let agent_action = if add_agent_action {
            vec![(agent_type, action)]
        } else {
            vec![]
        };
        let mut tx = build_single_spore_mint_tx_with_extra_action(
            &mut context,
            "Hello Spore!".as_bytes().to_vec(),
            "plain/text",
            None,
            Some(cluster_id),
            agent_action,
        );
        tx = tx
            .as_advanced_builder()
            .input(agent_input)
            .output(agent_output)
            .output_data(proxy_type_hash.to_vec().pack())
            .cell_dep(agent_script_dep)
            .build();
        if add_cluster_dep {
            tx = tx.as_advanced_builder().cell_dep(cluster_dep).build();
        }
        tx = context.complete_tx(tx);

        context
            .verify_tx(&tx, MAX_CYCLES)
            .expect("test spore mint from cluster transfer");
    }

    #[test]
    fn test_spore_mint_from_agent_transfer() {
        make_spore_mint_from_agent_transfer(true, true);
    }

    #[should_panic]
    #[test]
    fn test_spore_mint_from_agent_transfer_failed_with_no_cluster_dep() {
        make_spore_mint_from_agent_transfer(false, true);
    }

    #[should_panic]
    #[test]
    fn test_spore_mint_from_agent_transfer_failed_with_no_agent_action() {
        make_spore_mint_from_agent_transfer(true, false);
    }
}

mod simple_spore_destroy {
    use super::*;

    fn make_simple_spore_destroy(content_type: &str) {
        let mut context = Context::default();
        let serialized =
            build_serialized_spore_data("Hello Spore!".as_bytes().to_vec(), content_type, None);
        let (spore_out_point, spore_script_dep) =
            build_spore_contract_materials(&mut context, "spore");

        let normal_input = build_normal_input(&mut context);
        let spore_type_id = build_type_id(&normal_input, 0);
        let type_ = build_spore_type_script(
            &mut context,
            &spore_out_point,
            spore_type_id.to_vec().into(),
        );
        let spore_input = build_spore_input(&mut context, type_.clone(), serialized.clone());

        let normal_output = build_normal_output(&mut context);
        let tx = TransactionBuilder::default()
            .input(spore_input)
            .output(normal_output)
            .output_data(Default::default())
            .cell_dep(spore_script_dep)
            .build();

        let action = build_burn_spore_action(&mut context, spore_type_id);
        let tx = complete_co_build_message_with_actions(tx, &[(type_, action)]);

        let tx = context.complete_tx(tx);

        context
            .verify_tx(&tx, MAX_CYCLES)
            .expect("try destroy spore");
    }

    #[test]
    fn test_simple_spore_destroy() {
        make_simple_spore_destroy("plain/text");
    }

    #[should_panic]
    #[test]
    fn test_simple_spore_destroy_with_immortal() {
        make_simple_spore_destroy("plain/text;immortal=true");
    }
}


================================================
File: tests/src/tests/utils.rs
================================================
use ckb_testtool::ckb_types::prelude::{Builder, Entity};
use spore_types::generated::spore;
use spore_utils::{compatible_load_cluster_data, MIME};

#[test]
fn test_mime_basic() {
    assert!(MIME::str_parse("image/png").is_ok());
    assert!(MIME::str_parse("image/png;immortal=true").is_ok());
    assert!(MIME::str_parse("image/").is_err());
    assert!(MIME::str_parse("image/;").is_err());
    assert!(MIME::str_parse("/;").is_err());
    assert!(MIME::str_parse(";").is_err());
    assert!(MIME::str_parse("").is_err());

    let content_type = "image/png;immortal=true;mutant[]=c219351b150b900e50a7039f1e448b844110927e5fd9bd30425806cb8ddff1fd,9c87faf08de5c15c727d5350399115431bf4f0226fbc4abd400e63492faac3d2";
    let mime = MIME::str_parse(content_type)
        .map_err(|err| format!("mutant str_parse: {}", err as u8))
        .unwrap();
    let expected_value = b"c219351b150b900e50a7039f1e448b844110927e5fd9bd30425806cb8ddff1fd,9c87faf08de5c15c727d5350399115431bf4f0226fbc4abd400e63492faac3d2";
    let value_range = mime
        .get_param(content_type.as_bytes(), "mutant[]")
        .map_err(|err| format!("mutant get_param: {}", err as u8))
        .unwrap()
        .expect("empty range");
    assert!(content_type.as_bytes()[value_range] == expected_value[..]);

    let expected_value = b"true";
    let value_range = mime
        .get_param(content_type.as_bytes(), "immortal")
        .map_err(|err| format!("mutant get_param: {}", err as u8))
        .unwrap()
        .expect("empty range");
    assert!(content_type.as_bytes()[value_range] == expected_value[..]);
}

#[test]
fn test_compatible_load_cluster_data() {
    // test ClusterDataV1 -> ClusterDataV2
    let cluster_data_v1 = spore::ClusterData::new_builder()
        .name("Test Cluster Name".as_bytes().into())
        .description("Test Cluster Description".as_bytes().into())
        .build();
    let raw_cluster_data = cluster_data_v1.as_slice();
    let cluster_data_v2 = compatible_load_cluster_data(raw_cluster_data)
        .map_err(|_| "compatible_load_cluster_data error")
        .expect("test ClusterDataV1 -> ClusterDataV2");
    assert_eq!(
        cluster_data_v2.name().as_slice(),
        cluster_data_v1.name().as_slice()
    );
    assert_eq!(
        cluster_data_v2.description().as_slice(),
        cluster_data_v1.description().as_slice()
    );
    assert!(cluster_data_v2.mutant_id().is_none());

    // test ClusterDataV2 -> ClusterDataV2
    let cluster_data_v2_with_mutant_id = cluster_data_v2
        .as_builder()
        .mutant_id("mock mutant_id".as_bytes().into())
        .build();
    let raw_cluster_data = cluster_data_v2_with_mutant_id.as_slice();
    let cluster_data_v1 = spore::ClusterData::from_compatible_slice(raw_cluster_data)
        .map_err(|_| "spore::ClusterData::from_compatible_slice error")
        .expect("test old format -> new format");
    assert!(cluster_data_v1.has_extra_fields());
    assert_eq!(cluster_data_v1.field_count(), 3);
    assert_eq!(cluster_data_v1.count_extra_fields(), 1);
    let cluster_data_v2 = compatible_load_cluster_data(raw_cluster_data)
        .map_err(|_| "compatible_load_cluster_data error")
        .expect("test ClusterDataV2 -> ClusterDataV2");
    assert!(cluster_data_v2.mutant_id().is_some());
}


================================================
File: tests/src/utils/co_build.rs
================================================
use ckb_testtool::ckb_hash::blake2b_256;
use ckb_testtool::ckb_types::core::TransactionView;
use ckb_testtool::ckb_types::packed;
use ckb_testtool::ckb_types::prelude::*;

use ckb_testtool::context::Context;
use spore_types::generated::action::BurnAgent;
use spore_types::generated::action::BurnProxy;
use spore_types::generated::action::{
    Address, AddressUnion, BurnSpore, Byte32, Bytes, MintAgent, MintCluster, MintProxy, MintSpore,
    Script, SporeAction, SporeActionUnion, TransferAgent, TransferCluster, TransferProxy,
    TransferSpore,
};
use spore_utils::co_build_types::{
    Action, ActionVec, Message, SighashAll, WitnessLayout, WitnessLayoutUnion,
};

use super::internal;

fn h256_to_byte32(hash: [u8; 32]) -> Byte32 {
    let hash = hash
        .into_iter()
        .map(packed::Byte::new)
        .collect::<Vec<packed::Byte>>()
        .try_into()
        .unwrap();
    Byte32::new_builder().set(hash).build()
}

fn script_to_address(script: packed::Script) -> Address {
    let code_hash = script.code_hash().unpack();
    let hash_type = script.hash_type();
    let args = script.args().raw_data();

    let code_hash = h256_to_byte32(code_hash.into());
    let args = Bytes::new_builder()
        .set(args.into_iter().map(packed::Byte::new).collect())
        .build();

    let script = Script::new_builder()
        .code_hash(code_hash)
        .hash_type(hash_type)
        .args(args)
        .build();

    Address::new_builder()
        .set(AddressUnion::Script(script))
        .build()
}

pub fn complete_co_build_message_with_actions(
    tx: TransactionView,
    actions: &[(Option<packed::Script>, SporeActionUnion)],
) -> TransactionView {
    let action_value_vec = actions
        .to_owned()
        .into_iter()
        .map(|(script_hash, action)| {
            let script_hash = if let Some(script_hash) = script_hash {
                script_hash.calc_script_hash()
            } else {
                packed::Byte32::default()
            };
            let spore_action = SporeAction::new_builder().set(action).build();
            Action::new_builder()
                .script_hash(script_hash)
                .data(spore_action.as_slice().pack())
                .build()
        })
        .collect();
    let action_vec = ActionVec::new_builder().set(action_value_vec).build();
    let message = Message::new_builder().actions(action_vec).build();
    let sighash_all = SighashAll::new_builder().message(message).build();
    let witness_layout = WitnessLayout::new_builder()
        .set(WitnessLayoutUnion::SighashAll(sighash_all))
        .build();

    tx.as_advanced_builder()
        .witness(witness_layout.as_slice().pack())
        .build()
}

pub fn build_mint_spore_action(
    context: &mut Context,
    nft_id: [u8; 32],
    content: &[u8],
) -> SporeActionUnion {
    let to = internal::build_always_success_script(context, Default::default());
    let mint = MintSpore::new_builder()
        .spore_id(h256_to_byte32(nft_id))
        .data_hash(h256_to_byte32(blake2b_256(content)))
        .to(script_to_address(to))
        .build();
    SporeActionUnion::MintSpore(mint)
}

pub fn build_transfer_spore_action(context: &mut Context, nft_id: [u8; 32]) -> SporeActionUnion {
    let script = internal::build_always_success_script(context, Default::default());
    let address = script_to_address(script);
    let transfer = TransferSpore::new_builder()
        .spore_id(h256_to_byte32(nft_id))
        .from(address.clone())
        .to(address)
        .build();
    SporeActionUnion::TransferSpore(transfer)
}

pub fn build_burn_spore_action(context: &mut Context, nft_id: [u8; 32]) -> SporeActionUnion {
    let from = internal::build_always_success_script(context, Default::default());
    let burn = BurnSpore::new_builder()
        .spore_id(h256_to_byte32(nft_id))
        .from(script_to_address(from))
        .build();
    SporeActionUnion::BurnSpore(burn)
}

pub fn build_mint_cluster_action(
    context: &mut Context,
    cluster_id: [u8; 32],
    content: &[u8],
) -> SporeActionUnion {
    let to = internal::build_always_success_script(context, Default::default());
    let cluster_create = MintCluster::new_builder()
        .cluster_id(h256_to_byte32(cluster_id))
        .data_hash(h256_to_byte32(blake2b_256(content)))
        .to(script_to_address(to))
        .build();
    SporeActionUnion::MintCluster(cluster_create)
}

pub fn build_transfer_cluster_action(
    context: &mut Context,
    cluster_id: [u8; 32],
) -> SporeActionUnion {
    let script = internal::build_always_success_script(context, Default::default());
    let address = script_to_address(script);
    let cluster_transfer = TransferCluster::new_builder()
        .cluster_id(h256_to_byte32(cluster_id))
        .from(address.clone())
        .to(address)
        .build();
    SporeActionUnion::TransferCluster(cluster_transfer)
}

pub fn build_mint_proxy_action(
    context: &mut Context,
    cluster_id: [u8; 32],
    proxy_id: [u8; 32],
) -> SporeActionUnion {
    let to = internal::build_always_success_script(context, Default::default());
    let proxy_create = MintProxy::new_builder()
        .cluster_id(h256_to_byte32(cluster_id))
        .proxy_id(h256_to_byte32(proxy_id))
        .to(script_to_address(to))
        .build();
    SporeActionUnion::MintProxy(proxy_create)
}

pub fn build_transfer_proxy_action(
    context: &mut Context,
    cluster_id: [u8; 32],
    proxy_id: [u8; 32],
) -> SporeActionUnion {
    let script = internal::build_always_success_script(context, Default::default());
    let from = script_to_address(script);
    let to = from.clone();
    let proxy_transfer = TransferProxy::new_builder()
        .cluster_id(h256_to_byte32(cluster_id))
        .proxy_id(h256_to_byte32(proxy_id))
        .from(from)
        .to(to)
        .build();
    SporeActionUnion::TransferProxy(proxy_transfer)
}

pub fn build_burn_proxy_action(
    context: &mut Context,
    cluster_id: [u8; 32],
    proxy_id: [u8; 32],
) -> SporeActionUnion {
    let script = internal::build_always_success_script(context, Default::default());
    let from = script_to_address(script);
    let proxy_burn = BurnProxy::new_builder()
        .cluster_id(h256_to_byte32(cluster_id))
        .proxy_id(h256_to_byte32(proxy_id))
        .from(from)
        .build();
    SporeActionUnion::BurnProxy(proxy_burn)
}

pub fn build_mint_agent_action(
    context: &mut Context,
    cluster_id: [u8; 32],
    proxy_id: [u8; 32],
) -> SporeActionUnion {
    let to = internal::build_always_success_script(context, Default::default());
    let agent_create = MintAgent::new_builder()
        .cluster_id(h256_to_byte32(cluster_id))
        .proxy_id(h256_to_byte32(proxy_id))
        .to(script_to_address(to))
        .build();
    SporeActionUnion::MintAgent(agent_create)
}

pub fn build_transfer_agent_action(
    context: &mut Context,
    cluster_id: [u8; 32],
) -> SporeActionUnion {
    let script = internal::build_always_success_script(context, Default::default());
    let from = script_to_address(script);
    let to = from.clone();
    let agent_transfer = TransferAgent::new_builder()
        .cluster_id(h256_to_byte32(cluster_id))
        .from(from)
        .to(to)
        .build();
    SporeActionUnion::TransferAgent(agent_transfer)
}

pub fn build_burn_agent_action(context: &mut Context, cluster_id: [u8; 32]) -> SporeActionUnion {
    let script = internal::build_always_success_script(context, Default::default());
    let from = script_to_address(script);
    let agent_burn = BurnAgent::new_builder()
        .cluster_id(h256_to_byte32(cluster_id))
        .from(from)
        .build();
    SporeActionUnion::BurnAgent(agent_burn)
}


================================================
File: tests/src/utils/internal.rs
================================================
use ckb_testtool::builtin::ALWAYS_SUCCESS;
use ckb_testtool::ckb_types::{bytes::Bytes, packed::*, prelude::*};
use ckb_testtool::context::Context;

pub fn build_always_success_script(context: &mut Context, args: Bytes) -> Script {
    let always_success_out_point = context.deploy_cell(ALWAYS_SUCCESS.clone());

    // build lock script
    context
        .build_script(&always_success_out_point, args)
        .expect("always success script")
}

pub fn build_output(
    context: &mut Context,
    capacity: u64,
    type_script: Option<Script>,
    lock_args: Bytes,
) -> CellOutput {
    let lock_script = build_always_success_script(context, lock_args);
    CellOutput::new_builder()
        .capacity(capacity.pack())
        .lock(lock_script)
        .type_(ScriptOpt::new_builder().set(type_script).build())
        .build()
}

pub fn build_outpoint(
    context: &mut Context,
    capacity: u64,
    type_script: Option<Script>,
    data: Bytes,
    lock_args: Bytes,
) -> OutPoint {
    let output = build_output(context, capacity, type_script, lock_args);
    context.create_cell(output, data)
}

pub fn build_input(
    context: &mut Context,
    capacity: u64,
    type_script: Option<Script>,
    data: Bytes,
    lock_args: Bytes,
) -> CellInput {
    let outpoint = build_outpoint(context, capacity, type_script, data, lock_args);
    CellInput::new_builder()
        .since(Uint64::default())
        .previous_output(outpoint)
        .build()
}


================================================
File: tests/src/utils/mod.rs
================================================
#![allow(dead_code)]

use ckb_testtool::builtin::ALWAYS_SUCCESS;
use ckb_testtool::ckb_hash::{new_blake2b, Blake2bBuilder};
use ckb_testtool::ckb_types::core::ScriptHashType;
use ckb_testtool::ckb_types::{
    bytes::Bytes, core::TransactionBuilder, core::TransactionView, packed, packed::*, prelude::*,
};
use ckb_testtool::context::Context;
use spore_types::generated::action::SporeActionUnion;
use std::num::ParseIntError;

use spore_types::generated::spore::{ClusterDataV2 as ClusterData, SporeData};
use spore_types::NativeNFTData;

use crate::Loader;

pub mod co_build;
mod internal;

pub const UNIFORM_CAPACITY: u64 = 1000u64;
pub const CAPACITY_UNIT: u64 = 100_000_000;

pub fn build_serialized_cluster_data(name: &str, description: &str) -> ClusterData {
    ClusterData::new_builder()
        .name(name.as_bytes().into())
        .description(description.as_bytes().into())
        .mutant_id(Default::default())
        .build()
}

pub fn build_serialized_spore_data(
    nft_content: Vec<u8>,
    nft_type: &str,
    cluster_id: Option<Vec<u8>>,
) -> SporeData {
    let nft = NativeNFTData {
        content: nft_content,
        content_type: nft_type.to_owned(),
        cluster_id,
    };
    SporeData::from(nft)
}

pub fn build_type_id(first_input: &CellInput, out_index: usize) -> [u8; 32] {
    let mut blake2b = Blake2bBuilder::new(32)
        .personal(b"ckb-default-hash")
        .build();
    blake2b.update(first_input.as_slice());
    blake2b.update(&(out_index as u64).to_le_bytes());
    let mut verify_id = [0; 32];
    blake2b.finalize(&mut verify_id);
    verify_id
}

pub fn build_spore_type_script(
    context: &mut Context,
    out_point: &OutPoint,
    args: Bytes,
) -> Option<Script> {
    context.build_script_with_hash_type(out_point, ScriptHashType::Data1, args)
}

pub fn build_spore_type_script_with_payment(
    context: &mut Context,
    out_point: &OutPoint,
    args: &[u8; 32],
    payment: u64,
) -> Option<Script> {
    let payment_in_ckb = payment * CAPACITY_UNIT;
    let args = vec![args.to_vec(), payment_in_ckb.to_le_bytes().to_vec()].concat();
    context.build_script_with_hash_type(out_point, ScriptHashType::Data1, args.into())
}

pub fn build_spore_input(
    context: &mut Context,
    spore_type: Option<Script>,
    spore_data: SporeData,
) -> CellInput {
    let input_ckb = spore_data.total_size() as u64;
    internal::build_input(
        context,
        input_ckb,
        spore_type,
        Bytes::copy_from_slice(spore_data.as_slice()),
        Default::default(),
    )
}

pub fn build_cluster_input(
    context: &mut Context,
    cluster_data: ClusterData,
    type_: Option<Script>,
) -> CellInput {
    let input_ckb = cluster_data.total_size() as u64;
    internal::build_input(
        context,
        input_ckb,
        type_,
        Bytes::copy_from_slice(cluster_data.as_slice()),
        Default::default(),
    )
}

pub fn build_agent_proxy_input(
    context: &mut Context,
    cell_data: &[u8],
    type_: Option<Script>,
) -> CellInput {
    let input_ckb = cell_data.len() as u64;
    internal::build_input(
        context,
        input_ckb,
        type_,
        Bytes::copy_from_slice(cell_data),
        Default::default(),
    )
}

pub fn build_normal_input(context: &mut Context) -> CellInput {
    internal::build_input(
        context,
        UNIFORM_CAPACITY,
        None,
        Bytes::new(),
        Default::default(),
    )
}

pub fn build_normal_output_cell_with_type(
    context: &mut Context,
    type_: Option<Script>,
) -> CellOutput {
    internal::build_output(context, UNIFORM_CAPACITY, type_, Default::default())
}

pub fn build_normal_output(context: &mut Context) -> CellOutput {
    internal::build_output(context, UNIFORM_CAPACITY, None, Default::default())
}

pub fn build_normal_cell_dep(context: &mut Context, data: &[u8], type_: Option<Script>) -> CellDep {
    build_normal_cell_dep_with_lock_args(context, data, type_, Default::default())
}

pub fn build_normal_cell_dep_with_lock_args(
    context: &mut Context,
    data: &[u8],
    type_: Option<Script>,
    lock_args: &[u8],
) -> CellDep {
    let outpoint = internal::build_outpoint(
        context,
        data.len() as u64,
        type_,
        Bytes::copy_from_slice(data),
        lock_args.to_vec().into(),
    );
    CellDep::new_builder().out_point(outpoint).build()
}

pub fn build_spore_contract_materials(
    context: &mut Context,
    binary_name: &str,
) -> (OutPoint, CellDep) {
    let binary = Loader::default().load_binary(binary_name);
    let out_point = context.deploy_cell(binary);
    let script_dep = CellDep::new_builder().out_point(out_point.clone()).build();
    (out_point, script_dep)
}

pub fn build_cluster_materials(
    context: &mut Context,
    cluster_out_point: &OutPoint,
    cluster_data: ClusterData,
    cluster_out_index: usize,
    lock_args: &[u8],
) -> ([u8; 32], Option<Script>, CellInput, CellOutput, CellDep) {
    let normal_input = build_normal_input(context);
    let cluster_id = build_type_id(&normal_input, cluster_out_index);
    let cluster_type =
        build_spore_type_script(context, cluster_out_point, cluster_id.to_vec().into());
    let cluster_input = build_cluster_input(context, cluster_data.clone(), cluster_type.clone());
    let cluster_output = build_normal_output_cell_with_type(context, cluster_type.clone());
    let cluster_dep = build_normal_cell_dep_with_lock_args(
        context,
        cluster_data.as_slice(),
        cluster_type.clone(),
        lock_args,
    );
    (
        cluster_id,
        cluster_type,
        cluster_input,
        cluster_output,
        cluster_dep,
    )
}

pub fn build_agent_materials(
    context: &mut Context,
    agent_out_point: &OutPoint,
    cluster_id: &[u8; 32],
    proxy_type_hash: &[u8; 32],
) -> (Option<Script>, CellInput, CellOutput, CellDep) {
    let agent_type = build_spore_type_script(context, agent_out_point, cluster_id.to_vec().into());
    let agent_input = build_agent_proxy_input(context, proxy_type_hash, agent_type.clone());
    let agent_output = build_normal_output_cell_with_type(context, agent_type.clone());
    let agent_dep = build_normal_cell_dep(context, proxy_type_hash, agent_type.clone());
    (agent_type, agent_input, agent_output, agent_dep)
}

pub fn build_spore_output_materials(
    context: &mut Context,
    content: Vec<u8>,
    content_type: &str,
    out_index: usize,
    cluster_id: Option<[u8; 32]>,
) -> (SporeData, CellInput, CellOutput, CellDep) {
    let (spore_out_point, spore_script_dep) = build_spore_contract_materials(context, "spore");
    let output_data =
        build_serialized_spore_data(content, content_type, cluster_id.map(|v| v.to_vec()));

    let normal_input = build_normal_input(context);
    let type_id = build_type_id(&normal_input, out_index);
    let spore_type = build_spore_type_script(context, &spore_out_point, type_id.to_vec().into());
    let spore_output = build_normal_output_cell_with_type(context, spore_type.clone());

    (output_data, normal_input, spore_output, spore_script_dep)
}

pub fn build_single_spore_mint_tx_with_extra_action(
    context: &mut Context,
    content: Vec<u8>,
    content_type: &str,
    input_data: Option<SporeData>,
    cluster_id: Option<[u8; 32]>,
    mut actions: Vec<(Option<Script>, SporeActionUnion)>,
) -> TransactionView {
    let output_data =
        build_serialized_spore_data(content, content_type, cluster_id.map(|v| v.to_vec()));

    let (spore_out_point, spore_script_dep) = build_spore_contract_materials(context, "spore");
    let (input, type_id) = match input_data {
        None => {
            let input = build_normal_input(context);
            let spore_type_id = build_type_id(&input, 0);
            (input, spore_type_id)
        }
        Some(input_data) => {
            let input = build_normal_input(context);
            let spore_type_id = build_type_id(&input, 0);
            let spore_type =
                build_spore_type_script(context, &spore_out_point, spore_type_id.to_vec().into());
            let spore_input = build_spore_input(context, spore_type, input_data);
            (spore_input, spore_type_id)
        }
    };
    let spore_type = build_spore_type_script(context, &spore_out_point, type_id.to_vec().into());
    let spore_output = build_normal_output_cell_with_type(context, spore_type.clone());
    let tx = TransactionBuilder::default()
        .input(input)
        .output(spore_output)
        .output_data(output_data.as_slice().pack())
        .cell_dep(spore_script_dep)
        .build();

    let action = co_build::build_mint_spore_action(context, type_id, output_data.as_slice());
    actions.push((spore_type, action));
    co_build::complete_co_build_message_with_actions(tx, &actions)
}

pub fn build_single_spore_mint_tx(
    context: &mut Context,
    content: Vec<u8>,
    content_type: &str,
    input_data: Option<SporeData>,
    cluster_id: Option<[u8; 32]>,
) -> TransactionView {
    build_single_spore_mint_tx_with_extra_action(
        context,
        content,
        content_type,
        input_data,
        cluster_id,
        vec![],
    )
}

pub fn decode_hex(s: &str) -> Result<Vec<u8>, ParseIntError> {
    (0..s.len())
        .step_by(2)
        .map(|i| u8::from_str_radix(&s[i..i + 2], 16))
        .collect()
}

pub fn calc_code_hash(data: Bytes) -> [u8; 32] {
    let mut blake2b = new_blake2b();
    blake2b.update(data.to_vec().as_slice());
    let mut hash = [0u8; 32];
    blake2b.finalize(&mut hash);
    hash
}

pub fn build_single_spore_mint_in_cluster_tx(
    context: &mut Context,
    spore_data: SporeData,
    cluster_id: [u8; 32],
) -> TransactionView {
    let cluster_data = build_serialized_cluster_data("Spore Cluster!", "Spore Description!");
    let nft_bin: Bytes = Loader::default().load_binary("spore");
    let nft_out_point = context.deploy_cell(nft_bin);
    let cluster_bin: Bytes = Loader::default().load_binary("cluster");
    let cluster_out_point = context.deploy_cell(cluster_bin);
    let input_ckb = spore_data.total_size() as u64;

    let output_ckb = input_ckb;
    let always_success_out_point = context.deploy_cell(ALWAYS_SUCCESS.clone());

    // build lock script
    let lock_script = internal::build_always_success_script(context, Default::default());
    let lock_script_dep = CellDep::new_builder()
        .out_point(always_success_out_point)
        .build();

    let cluster_script_dep = CellDep::new_builder()
        .out_point(cluster_out_point.clone())
        .build();

    let input_out_point = context.create_cell(
        CellOutput::new_builder()
            .lock(lock_script.clone())
            .capacity(input_ckb.pack())
            .build(),
        Bytes::new(),
    );

    let cluster_script = context.build_script_with_hash_type(
        &cluster_out_point,
        ScriptHashType::Data1,
        cluster_id.to_vec().into(),
    );

    let cluster_out_point = context.create_cell(
        CellOutput::new_builder()
            .capacity((cluster_data.total_size() as u64).pack())
            .lock(lock_script.clone())
            .type_(cluster_script.pack())
            .build(),
        Bytes::copy_from_slice(cluster_data.as_slice()),
    );

    let cluster_dep = CellDep::new_builder()
        .out_point(cluster_out_point.clone())
        .build();

    let cluster_input = CellInput::new_builder()
        .previous_output(cluster_out_point)
        .build();

    let normal_input = CellInput::new_builder()
        .previous_output(
            context.create_cell(
                CellOutput::new_builder()
                    .capacity(1000000u64.pack())
                    .lock(lock_script.clone())
                    .build(),
                Bytes::new(),
            ),
        )
        .build();

    let input = CellInput::new_builder()
        .previous_output(input_out_point)
        .build();

    let nft_id = {
        let mut blake2b = Blake2bBuilder::new(32)
            .personal(b"ckb-default-hash")
            .build();
        blake2b.update(input.as_slice());
        blake2b.update(&1u64.to_le_bytes());
        let mut verify_id = [0; 32];
        blake2b.finalize(&mut verify_id);
        verify_id
    };

    let nft_script = context.build_script_with_hash_type(
        &nft_out_point,
        ScriptHashType::Data1,
        nft_id.to_vec().into(),
    );

    let nft_script_dep = CellDep::new_builder().out_point(nft_out_point).build();

    let output = CellOutput::new_builder()
        .capacity((output_ckb + cluster_data.total_size() as u64).pack())
        .lock(lock_script.clone())
        .type_(nft_script.pack())
        .build();

    let cluster_output = CellOutput::new_builder()
        .capacity(input_ckb.pack())
        .lock(lock_script.clone())
        .type_(cluster_script.pack())
        .build();

    let normal_output = CellOutput::new_builder()
        .capacity(9999u64.pack())
        .lock(lock_script.clone())
        .build();

    let tx = TransactionBuilder::default()
        .inputs(vec![input, normal_input, cluster_input])
        .outputs(vec![normal_output, output, cluster_output])
        .outputs_data(vec![
            packed::Bytes::default(),
            spore_data.as_slice().pack(),
            cluster_data.as_slice().pack(),
        ])
        .cell_deps(vec![
            lock_script_dep,
            cluster_script_dep,
            nft_script_dep,
            cluster_dep,
        ])
        .build();

    let cluster_transfer = co_build::build_transfer_cluster_action(context, cluster_id);
    let nft_action = co_build::build_mint_spore_action(context, nft_id, spore_data.as_slice());
    co_build::complete_co_build_message_with_actions(
        tx,
        &[(cluster_script, cluster_transfer), (nft_script, nft_action)],
    )
}

pub fn build_single_mutant_celldep_tx(
    context: &mut Context,
    lua_code: &str,
    out_index: usize,
) -> (TransactionView, [u8; 32]) {
    let (_, lua_lib_dep) = build_spore_contract_materials(context, "libckblua.so");
    let (lua_extension_out_point, lua_extension_script_dep) =
        build_spore_contract_materials(context, "spore_extension_lua");

    let input_cell = build_normal_input(context);
    let mutant_id = build_type_id(&input_cell, out_index);
    let type_ =
        build_spore_type_script(context, &lua_extension_out_point, mutant_id.to_vec().into());

    let mutant_celldep =
        build_normal_cell_dep_with_lock_args(context, lua_code.as_bytes(), type_, &mutant_id);
    let tx = TransactionBuilder::default()
        .cell_deps(vec![mutant_celldep, lua_extension_script_dep, lua_lib_dep])
        .build();

    (tx, mutant_id)
}


================================================
File: .github/workflows/capsule.yaml
================================================
name: Capsule build/test
on:
  push:
  pull_request:
    paths:
      - contracts/**
      - lib/**
      - tests/**

jobs:
  capsule-build-and-test:
    strategy:
      fail-fast: false
      matrix:
        include:
          - target: debug
            cargo-option: ""
            target-dir: "build/debug"
          - target: testnet
            cargo-option: "--release"
            target-dir: "build/release"
          - target: mainnet
            cargo-option: "--release -- --features release_export"
            target-dir: "build/release"
    runs-on: ubuntu-20.04
    steps:
      - uses: actions/checkout@v4
      
      - name: Prepare capsule v0.10.2
        run: |
          if [ ! -f "/tmp/capsule.tar.gz" ]; then
            curl -L https://github.com/nervosnetwork/capsule/releases/download/v0.10.2/capsule_v0.10.2_x86_64-linux.tar.gz -o /tmp/capsule.tar.gz
          fi
          tar -zxf /tmp/capsule.tar.gz -C /tmp
          echo "/tmp/capsule_v0.10.2_x86_64-linux" >> $GITHUB_PATH
    
      - name: Install cross
        run: cargo install cross --git https://github.com/cross-rs/cross

      - name: Capsule build
        run: capsule build ${{ matrix.cargo-option }}

      - name: Capsule test
        run: capsule test ${{ matrix.cargo-option }}

      - name: List all the contract binaries of ${{ github.ref }}
        run: ls -l ${{ matrix.target-dir }}

      - name: Archive the contract binaries ${{ github.sha }}
        uses: actions/upload-artifact@v4
        with:
          name: contract-binaries-${{ matrix.target }}-${{ github.sha }}
          path: |
            build/debug
            build/release
    outputs:
      spore-contract-ref: ${{ github.sha }}
  
  record-code-hash:
    needs: capsule-build-and-test
    strategy:
      matrix:
        target: [debug, testnet, mainnet]
    runs-on: ubuntu-20.04
    steps:
      # TODO: add this codehash util into the `tests` directory
      # or, simply use `ckb-cli util blake2b --binary-path ...` to get the codehash
      - name: Checkout a code_hash tool
        uses: actions/checkout@v4
        with:
          repository: Flouse/spore-contract
          ref: codehash-tool

      - uses: actions/download-artifact@v4
        with:
          name: contract-binaries-${{ matrix.target }}-${{ needs.capsule-build-and-test.outputs.spore-contract-ref }}
          path: build

      - name: Build codehash-tool
        working-directory: build
        run: cargo build

      - name: Record code_hash of contract binaries
        working-directory: build
        run: |
          echo "spore-contract-commit: ${{ needs.capsule-build-and-test.outputs.spore-contract-ref }}\n"
          ./target/debug/code_hash


================================================
File: .github/workflows/devnet.yaml
================================================
# Test the functionality of the spore-sdk packages.

name: Devnet Test

on:
  push:
    branches: master
      - contracts/**
      - lib/**
  pull_request:
    paths:
      - contracts/**
      - lib/**

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}

jobs:
  devnet:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout spore-devenv
        uses: actions/checkout@v4
        with:
          repository: sporeprotocol/spore-devenv
          path: spore-devenv

      - name: Checkout spore-sdk
        uses: actions/checkout@v4
        with:
          repository: sporeprotocol/spore-sdk
          ref: ${{ vars.SPORE_SDK_COMMIT }}
          path: spore-sdk
      
      - name: Install Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 20.x

      - uses: pnpm/action-setup@v2
        name: Install -g pnpm
        with:
          version: 8
          run_install: false

      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - uses: actions/cache@v3
        name: Setup pnpm cache
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Prepare spore-devenv (contracts and stuff)
        working-directory: spore-devenv
        run: bash prepare.sh -b $GITHUB_HEAD_REF

      - name: Start devenv services
        working-directory: spore-devenv
        run: npm run test:start

      - name: Move generated config file to spore-sdk
        working-directory: spore-devenv
        run: |
          mkdir -p ../spore-sdk/packages/core/src/__tests__/tmp
          cp config.json ../spore-sdk/packages/core/src/__tests__/tmp

      - name: Recharge capacity for accounts
        working-directory: spore-devenv
        run: npm run test:e2e
        env:
          VITE_ACCOUNT_CHARLIE: ${{ secrets.ACCOUNT_CHARLIE }}
          VITE_ACCOUNT_ALICE: ${{ secrets.ACCOUNT_ALICE }}

      - name: Prepare spore-sdk
        working-directory: spore-sdk
        run: pnpm install

      - name: Run tests for @spore-sdk/core
        working-directory: spore-sdk/packages/core
        run: pnpm run test
        env:
          VITE_ACCOUNT_CHARLIE: ${{ secrets.ACCOUNT_CHARLIE }}
          VITE_ACCOUNT_ALICE: ${{ secrets.ACCOUNT_ALICE }}
          VITE_NETWORK: devnet


