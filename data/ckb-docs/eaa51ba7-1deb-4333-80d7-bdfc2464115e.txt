Directory structure:
└── ckb-devrel-ckb-ssri-std/
    ├── Cargo.toml
    ├── ckb-ssri-std/
    │   ├── README.md
    │   ├── Cargo.toml
    │   └── src/
    │       ├── lib.rs
    │       ├── macros.rs
    │       ├── prelude.rs
    │       ├── public_module_traits/
    │       │   ├── mod.rs
    │       │   └── udt.rs
    │       └── utils/
    │           ├── high_level.rs
    │           ├── mod.rs
    │           └── syscalls/
    │               ├── mod.rs
    │               └── native.rs
    └── ckb-ssri-std-proc-macro/
        ├── Cargo.toml
        └── src/
            └── lib.rs

================================================
File: Cargo.toml
================================================
[workspace]
resolver = "2"

members = [
  "ckb-ssri-std",
  "ckb-ssri-std-proc-macro",
  # Please don't remove the following line, we use it to automatically
  # detect insertion point for newly generated crates.
  # @@INSERTION_POINT@@
]

[profile.release]
overflow-checks = true
strip = true
codegen-units = 1


================================================
File: ckb-ssri-std/README.md
================================================
# ckb-ssri-std

>
> [[EN/CN] Script-Sourced Rich Information - 来源于 Script 的富信息](https://talk.nervos.org/t/en-cn-script-sourced-rich-information-script/8256): General introduction to SSRI.
>
> [`ssri-test`](https://github.com/Hanssen0/ssri-test): First prototype of SSRI-Compliant contract.
>
> [`ssri-server`](https://github.com/ckb-devrel/ssri-server): Server for calling SSRI methods.
>

## Quick Note on SSRI

- SSRI stands for `Script Sourced Rich Information`; it is a protocol for strong bindings of relevant information and conventions to the Script itself on CKB. For more information, please read [[EN/CN] Script-Sourced Rich Information - 来源于 Script 的富信息](https://talk.nervos.org/t/en-cn-script-sourced-rich-information-script/8256)>.
- Such bindings would take place in a progressive pattern:
    - In the current coding paradigms for all contracts in production, testing, or active development, (or specifically, in Stage 1), the CKB smart contract being SSRI-Compliant would help us:
        1. In the typical scenario of validating transactions, by specifically using Rust Traits, we recognize the purpose (or more specifically, the `Intent` of running the script) (e.g., `minting UDT`, `transferring`) and build relevant validation logics within the scope of the corresponding method.
        2. On the level of reading and organizing contract code, by selectively implementing methods of public module traits (e.g. `UDT`, `UDTExtended`, `UDTPausable`) in combinations, generic users and devs would be able to quickly understand and organize functionalities of contracts as well as the relevant adaptations / integrations in dApps , especially in use cases involving multiple distinct contracts (and very likely from different projects) within same transactions.

### Goals of `ckb-ssri-std`

- Easier and intuitive implementations and built-in integration support (e.g. `CCC` and `ckb_ssri_cli`) of SSRI public traits.
- Easier and intuitive definitions of customized SSRI traits.
- [ ] TODO: Unified entry function;
- Scrip-Sourced code sharing for on-chain verification, off-chain query/integration, and off-chain transaction generations/completions.

## Usage

1. [ ] TODO: SSRI-Compliant Smart Contract Code would have an identifier Type that also implements TypeID mechanism. Please use [`ckb-cinnabar`](https://github.com/ashuralyk/ckb-cinnabar?tab=readme-ov-file#deployment-module) for easier deployment and migration.
2. SSRI-Compliant Smart Contract would use the unified entry function to run the script and call the exposed methods by specifying the path at `argv[0]` and the arguments at `argv[1..]`.
    - The default namespace is `SSRI` which consists of:
        - `SSRI.version() -> u8`
        - `SSRI.get_methods(offset: u64, limit: u64) -> Vec<Bytes8>`
        - `SSRI.has_methods(methods: Vec<Bytes8>) -> Vec<bool>`
    - [ ] TODO: By using the `#[ssri_module]` macro and `#[ssri_method]` attribute, methods can be automatically exposed in the namespace defined by trait name.
3. By implementing traits from `ckb_ssri_std::public_module_traits` in the SSRI-Compliant Smart Contract, infrastructures would be able to provide richer information off-chain as well for all kinds of purposes based on the SSRI protocol.

## Example Contract

[`pausable-udt`](https://github.com/ckb-devrel/pausable-udt) is a real production level contract (instead of a pseudo-project) that exemplifies the usage of SSRI.

## [ ] TODO: Defining a SSRI Module with `proc-macros` and Implement SSRI Traits

### #[ssri_module]

- version: implement a method to get the version of the SSRI module.

### #[ssri_method]

- By default, all of the following flags are set to false or empty;
- 'level={ExecutionEnvironmentLevel}': This method can only be run when the execution environment level is above or equal to the specified level;
- 'transaction=true': Will return a transaction object of molecule `struct` that can be sent to directly to RPC. If transaction is set to true, the required level is automatically set to Chain;
- 'internal=true': This method is not exposed through SSRI, but it's a dependency for other methods;

## Defining a SSRI Public Module Trait

## Deployment and Migration

- Deploy and upgrade with [ckb-cinnabar](https://github.com/ashuralyk/ckb-cinnabar?tab=readme-ov-file#deployment-module) for easier deployment and migration with Type ID.

```shell
ckb-cinnabar deploy --contract-name pausable-udt --tag transaction.v241112 --payer-address ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsqtxe0gs9yvwrsc40znvdc6sg4fehd2mttsngg4t4 --type-id 


ckb-cinnabar migrate --contract-name pausable-udt --from-tag v241030.1 --to-tag v241030.2
```

## Interacting with SSRI-Compliant Contracts

With SSRI-server and SSRI-VM, users, devs, and admins would have the ability to obtain Script-Source Rich Information directly from the script by calling SSRI methods via SSRI-server (which can be both run locally and for public usage).

The returned information can be just data for display, or a transaction object that can be sent to a CKB RPC, without the need of extra implementations on either dApps or backend applications.

```sh
echo '{
    "id": 2,
    "jsonrpc": "2.0",
    "method": "run_script",
    "params": ["<TxHash of the target Cell>", <Index>, [<Bytes of methods path>, <...argv>]]
}'
```

### `ckb_ssri_cli`

## Testing

Due to the limitations of `ckb_testtools`, it is recommended to test the same SSRI-Compliant Contract on two level:

- On-chain Verification: Test with `ckb_testtools`
- Off-chain Query/Integration, Transaction Generations/Completions: Test with `ckb_ssri_cli` against the latest deployment.

## Key Concepts

### Execution Environment Levels

- Code: If only the code hash is provided, the execution environment level is Code;
- Script: If the code hash and args are both provided, the execution environment level is Script;
- Cell: If the CellInput / Outpoint is provided, the execution environment level is Cell;
- Transaction: If the Transaction Hash is provided, the execution environment level is Transaction; This is also the level of execution environment for regular CKB-VM when submitting transaction;


================================================
File: ckb-ssri-std/Cargo.toml
================================================
[package]
name = "ckb-ssri-std"
version = "0.0.1"
edition = "2021"
description = "SDK for implementing SSRI-compliant smart contracts on CKB"
license = "MIT"
repository = "https://github.com/ckb-devrel/ckb-ssri-std"
documentation = "https://docs.rs/ckb-ssri-std"
readme = "README.md"
authors = ["Alive24 <xct24@live.com>"]
keywords = ["ckb", "nervos", "blockchain", "smart-contracts", "ssri"]
categories = ["cryptography::cryptocurrencies", "development-tools"]

[dependencies]
ckb-std = { version = "0.16.4", features = ["allocator", "ckb-types"] }
serde_molecule = { version = "1.1.0", default-features = false, features = ["alloc"] }
serde = { version = "1.0.210", default-features = false, features = ["derive"] }
ckb-ssri-std-proc-macro = { version = "0.0.1", path = "../ckb-ssri-std-proc-macro" }


================================================
File: ckb-ssri-std/src/lib.rs
================================================
#![no_std]
//! # CKB SSRI std
//! 
//! Utils for implementing SSRI-compliant smart contracts on the Nervos CKB blockchain.
//! 
//! ## Overview
//! 
//! The SSRI (Standard Smart Contract Runtime Interface) std provides a standardized way to develop
//! smart contracts that are compliant with the SSRI protocol. This enables better interoperability
//! and a more consistent development experience across the CKB ecosystem.
//!
//! ## Features
//! 
//! - **Public Traits**: Pre-defined interfaces that receive first-class support within the ecosystem
//! - **Utility Functions**: Helper functions for SSRI-VM syscalls and data handling
//! - **Procedural Macros**: Simplify contract development with automatic SSRI method generation
//! - **No Standard Library**: Designed for the constrained smart contract environment
//!
//! ## Usage
//!
//! Add this to your `Cargo.toml`:
//! ```toml
//! [dependencies]
//! ckb-ssri-std = "0.1.0"
//! ```
//!
//! ## Example
//!
//! ```rust,no_run
//! use ckb_ssri_std::prelude::*;
//! use ckb_ssri_std::public_module_traits::udt::UDT;
//! 
//! // Implement a basic UDT (User-Defined Token)
//! #[derive(Default)]
//! struct MyToken;
//! 
//! impl UDT for MyToken {
//!     type Error = ();
//!     // ... implement required methods
//! }
//! ```

pub mod public_module_traits;
pub mod prelude;
pub mod utils;
pub mod macros;

// Re-export proc macros at crate root for convenience
pub use macros::*;

extern crate alloc;

// macro_rules! ssri_entry {
//     ( $( $module:path ),* $(,)? ) => {
//         pub fn unified_dispatch(namespace_and_function: &str, args: Vec<&str>) -> Result<String, crate::error::DispatchError> {
//             $(
//                 let argv = ckb_std::env::argv();
//                 if argv.is_empty() {
//                     return fallback::fallback().map(|_| ());
//                 }

//                 if vm_version() != u64::MAX {
//                     return Err(Error::InvalidVmVersion);
//                 }

//                 set_content(&res)?;
//                 if $module::EXPOSED_FUNCTIONS.contains(&namespace_and_function) {
//                     return $module::dispatch_function(namespace_and_function, args);
//                 }
//             )*
//             Err(crate::error::DispatchError::FunctionNotFound)
//         }

//         pub fn get_methods() -> Vec<&'static str> {
//             let mut methods = Vec::new();
//             $(
//                 methods.extend_from_slice($module::EXPOSED_FUNCTIONS);
//             )*
//             methods
//         }
//     };
// }

#[repr(i8)]
#[derive(Debug)]
/// Represents possible errors that can occur during SSRI method execution
///
/// This enum provides a standardized set of errors that can occur when executing
/// SSRI methods. These errors help identify issues with method discovery,
/// argument validation, implementation status, and environment compatibility.
///
/// # Examples
///
/// ```rust
/// use ckb_ssri_std::SSRIError;
///
/// fn example_handler() -> Result<(), SSRIError> {
///     // Method implementation missing
///     Err(SSRIError::SSRIMethodsNotImplemented)
/// }
/// ```
pub enum SSRIError {
    /// The requested SSRI method was not found in the contract
    SSRIMethodsNotFound,
    /// The arguments provided to the SSRI method were invalid
    SSRIMethodsArgsInvalid,
    /// The requested SSRI method is not implemented
    SSRIMethodsNotImplemented,
    /// The method requires a higher execution environment level
    SSRIMethodRequireHigherLevel,
    /// The CKB VM version is not compatible with this implementation
    InvalidVmVersion
}


================================================
File: ckb-ssri-std/src/macros.rs
================================================
//! Re-exports of procedural macros from ckb-ssri-std-proc-macro
//!
//! This module provides convenient access to all procedural macros defined in the
//! `ckb-ssri-std-proc-macro` crate. These macros are essential for implementing
//! SSRI-compliant smart contracts.
//!
//! # Available Macros
//!
//! - `ssri_module`: Marks a module as an SSRI-compliant module
//! - `ssri_method`: Marks a function as an exposed SSRI method
//!
//! # Example
//!
//! ```ignore
//! use ckb_ssri_std::macros::*;
//!
//! #[ssri_module]
//! mod my_contract {
//!     #[ssri_method]
//!     fn my_method() -> Result<(), Error> {
//!         // Implementation
//!     }
//! }
//! ```

pub use ckb_ssri_std_proc_macro::*;


================================================
File: ckb-ssri-std/src/prelude.rs
================================================
use alloc::vec::Vec;

pub fn encode_u64_vector(val: impl AsRef<[u64]>) -> Vec<u8> {
    let val = val.as_ref();
    u32::to_le_bytes(val.len() as u32)
        .into_iter()
        .chain(val.iter().flat_map(|v| u64::to_le_bytes(*v)))
        .collect()
}

#[allow(clippy::result_unit_err)]
pub fn decode_u64_vector(raw: impl AsRef<[u8]>) -> Result<Vec<u64>, ()> {
    let raw = raw.as_ref();

    Ok(raw
        .chunks(8)
        .map(|chunk| u64::from_le_bytes(chunk.try_into().unwrap()))
        .collect())
}

pub fn encode_u8_32_vector(val: impl AsRef<[[u8; 32]]>) -> Vec<u8> {
    let val = val.as_ref();
    u32::to_le_bytes(val.len() as u32)
        .into_iter()
        .chain(val.iter().flat_map(|v| v.iter().copied()))
        .collect()
}

#[allow(clippy::result_unit_err)]
pub fn decode_u8_32_vector(raw: impl AsRef<[u8]>) -> Result<Vec<[u8; 32]>, ()> {
    let raw = raw.as_ref();
    let len = u32::from_le_bytes(raw[0..4].try_into().unwrap()) as usize;
    if len * 32 + 4 != raw.len() {
        return Err(());
    }

    Ok(raw[4..]
        .chunks(32)
        .map(|chunk| {
            let mut arr = [0u8; 32];
            arr.copy_from_slice(chunk);
            arr
        })
        .collect())
}

================================================
File: ckb-ssri-std/src/public_module_traits/mod.rs
================================================
pub mod udt;


================================================
File: ckb-ssri-std/src/public_module_traits/udt.rs
================================================
use ckb_std::ckb_types::{
    bytes::Bytes,
    packed::{Byte32Vec, Script, Transaction},
};
extern crate alloc;

use alloc::vec::Vec;
use serde::{Deserialize, Serialize};

/// User-Defined Token (UDT) trait for implementing custom tokens on CKB
///
/// This trait defines the standard interface for implementing fungible tokens
/// on the CKB blockchain following the SSRI protocol. 
///
/// # Implementation Notes
///
/// - All amounts are represented as u128 in convention
/// - Methods that modify state return a Transaction that must be committed
/// - Verification methods are separate from state-changing methods
///
/// # Example
///
/// ```rust,no_run
/// use ckb_ssri_std::public_module_traits::udt::UDT;
///
/// struct MyToken;
///
/// impl UDT for MyToken {
///     type Error = ();
///     
///     fn balance() -> Result<u128, Self::Error> {
///         // Implementation
///         Ok(0)
///     }
///     // ... implement other required methods
/// }
/// ```
pub trait UDT {
    type Error;
    fn transfer(
        tx: Option<Transaction>,
        to_lock_vec: Vec<Script>,
        to_amount_vec: Vec<u128>,
    ) -> Result<Transaction, Self::Error>;
    fn verify_transfer() -> Result<(), Self::Error>;
    fn name() -> Result<Bytes, Self::Error>;
    fn symbol() -> Result<Bytes, Self::Error>;
    fn decimals() -> Result<u8, Self::Error>;
    fn icon() -> Result<Bytes, Self::Error>;
    fn mint(
        tx: Option<Transaction>,
        to_lock_vec: Vec<Script>,
        to_amount_vec: Vec<u128>,
    ) -> Result<Transaction, Self::Error>;
    fn verify_mint() -> Result<(), Self::Error>;
}
pub const UDT_LEN: usize = 16;
pub enum UDTError {
    InsufficientBalance,
    NoMintPermission,
    NoBurnPermission,
}

pub trait UDTPausable: UDT {
    /* NOTE: Pausing/Unpause without lock hashes should take effect on the global level */
    fn pause(
        tx: Option<Transaction>,
        lock_hashes: &Vec<[u8; 32]>,
    ) -> Result<Transaction, Self::Error>;
    fn unpause(
        tx: Option<Transaction>,
        lock_hashes: &Vec<[u8; 32]>,
    ) -> Result<Transaction, Self::Error>;
    fn is_paused(lock_hashes: &Vec<[u8; 32]>) -> Result<Vec<bool>, Self::Error>;
    fn enumerate_paused(offset: u64, limit: u64) -> Result<Byte32Vec, Self::Error>;
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct UDTPausableData {
    pub pause_list: Vec<[u8; 32]>,
    pub next_type_script: Option<ScriptLike>
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct ScriptLike {
    pub code_hash: [u8; 32],
    pub hash_type: u8,
    pub args: Vec<u8>,
}
pub enum UDTPausableError {
    NoPausePermission,
    NoUnpausePermission,
    AbortedFromPause,
    IncompletePauseList,
    CyclicPauseList,
}


================================================
File: ckb-ssri-std/src/utils/high_level.rs
================================================
use crate::utils::syscalls;
use alloc::vec;
use alloc::vec::Vec;
use ckb_std::{
    ckb_types::{
        packed::{CellOutput, CellOutputReader, OutPoint, OutPointReader, Script},
        prelude::*,
    },
    error::SysError,
    high_level::BUF_SIZE,
};

/// Common method to fully load data from syscall
fn load_data<F: Fn(&mut [u8], usize) -> Result<usize, SysError>>(
    syscall: F,
) -> Result<Vec<u8>, SysError> {
    let mut buf = [0u8; BUF_SIZE];
    match syscall(&mut buf, 0) {
        Ok(len) => Ok(buf[..len].to_vec()),
        Err(SysError::LengthNotEnough(actual_size)) => {
            let mut data = vec![0; actual_size];
            let loaded_len = buf.len();
            data[..loaded_len].copy_from_slice(&buf);
            let len = syscall(&mut data[loaded_len..], loaded_len)?;
            debug_assert_eq!(len + loaded_len, actual_size);
            Ok(data)
        }
        Err(err) => Err(err),
    }
}

/// Find an OutPoint by searching for a cell with a specific type script
///
/// Searches the transaction for a cell that matches the given type script
/// and returns its OutPoint if found.
///
/// # Arguments
///
/// * `type_script` - The Script to search for as a cell's type script
///
/// # Returns
///
/// * `Ok(OutPoint)` - The OutPoint of the first matching cell
/// * `Err(SysError)` - A system error if the operation fails
///
/// # Example
///
/// ```
/// let out_point = find_out_point_by_type(type_script).unwrap();
/// ```
///
/// # Errors
///
/// * Returns `SysError::ItemMissing` if no cell with matching type script is found
/// * Returns `SysError::Encoding` if the OutPoint data is malformed
///
/// # Panics
///
/// This function can panic if the underlying data is too large,
/// potentially causing an out-of-memory error.
pub fn find_out_point_by_type(type_script: Script) -> Result<OutPoint, SysError> {
    let mut data = [0u8; OutPoint::TOTAL_SIZE];
    syscalls::find_out_point_by_type(&mut data, &type_script.as_slice())?;
    match OutPointReader::verify(&data, false) {
        Ok(()) => Ok(OutPoint::new_unchecked(data.to_vec().into())),
        Err(_err) => Err(SysError::Encoding),
    }
}

/// Find a cell by its OutPoint
///
/// Retrieves the CellOutput of a cell identified by the given OutPoint.
///
/// # Arguments
///
/// * `out_point` - The OutPoint identifying the cell to find
///
/// # Returns
///
/// * `Ok(CellOutput)` - The cell's output data if found
/// * `Err(SysError)` - A system error if the operation fails
///
/// # Example
///
/// ```
/// let out_point = OutPoint::new(...);
/// let cell_output = find_cell_by_out_point(out_point).unwrap();
/// ```
///
/// # Errors
///
/// * Returns `SysError::ItemMissing` if the cell cannot be found
/// * Returns `SysError::Encoding` if the CellOutput data is malformed
///
/// # Panics
///
/// This function can panic if the underlying data is too large,
/// potentially causing an out-of-memory error.
pub fn find_cell_by_out_point(out_point: OutPoint) -> Result<CellOutput, SysError> {
    let data =
        load_data(|buf, _offset| syscalls::find_cell_by_out_point(buf, out_point.as_slice()))?;

    match CellOutputReader::verify(&data, false) {
        Ok(()) => Ok(CellOutput::new_unchecked(data.into())),
        Err(_err) => Err(SysError::Encoding),
    }
}

/// Find cell data by OutPoint
///
/// Retrieves the data contained in a cell identified by the given OutPoint.
///
/// # Arguments
///
/// * `out_point` - The OutPoint identifying the cell whose data to retrieve
///
/// # Returns
///
/// * `Ok(Vec<u8>)` - The cell's data as a byte vector if found
/// * `Err(SysError)` - A system error if the operation fails
///
/// # Example
///
/// ```
/// let out_point = OutPoint::new(...);
/// let data = find_cell_data_by_out_point(out_point).unwrap();
/// ```
///
/// # Errors
///
/// * Returns `SysError::ItemMissing` if the cell cannot be found
/// * Returns `SysError::LengthNotEnough` if the data buffer is too small
///
/// # Panics
///
/// This function can panic if the underlying data is too large,
/// potentially causing an out-of-memory error.
pub fn find_cell_data_by_out_point(out_point: OutPoint) -> Result<Vec<u8>, SysError> {
    load_data(|buf, _offset| syscalls::find_cell_data_by_out_point(buf, out_point.as_slice()))
}


================================================
File: ckb-ssri-std/src/utils/mod.rs
================================================
use ckb_std::debug;
use syscalls::vm_version;

use crate::SSRIError;

pub mod syscalls;
pub mod high_level;

pub fn should_fallback() -> Result<bool, SSRIError> {
  if ckb_std::env::argv().is_empty() {
      debug!("Should fallback!");
      return Ok(true);
  } else {
      if vm_version() != u64::MAX {
          return Err(SSRIError::InvalidVmVersion);
      } else {
          debug!("Should not fallback!");
          return Ok(false);
      }
  }
}


================================================
File: ckb-ssri-std/src/utils/syscalls/mod.rs
================================================
// re-export to maintain compatible with old versions
pub use ckb_std::error::SysError;

#[cfg(not(feature = "native-simulator"))]
mod native;
#[cfg(not(feature = "native-simulator"))]
pub use native::*;

#[cfg(feature = "native-simulator")]
mod simulator;
#[cfg(feature = "native-simulator")]
pub use simulator::*;

================================================
File: ckb-ssri-std/src/utils/syscalls/native.rs
================================================
#[cfg(target_arch = "riscv64")]
use core::arch::asm;

use ckb_std::{ckb_constants::SYS_VM_VERSION, error::SysError};

/// System call number for finding an OutPoint by type script
pub const SYS_FIND_OUT_POINT_BY_TYPE: u64 = 2277;
/// System call number for finding a cell by OutPoint
pub const SYS_FIND_CELL_BY_OUT_POINT: u64 = 2287;
/// System call number for finding cell data by OutPoint
pub const SYS_FIND_CELL_DATA_BY_OUT_POINT: u64 = 2297;

#[cfg(target_arch = "riscv64")]
#[allow(clippy::too_many_arguments)]
pub unsafe fn syscall(
    mut a0: u64,
    a1: u64,
    a2: u64,
    a3: u64,
    a4: u64,
    a5: u64,
    a6: u64,
    a7: u64,
) -> u64 {
    asm!(
        "ecall",
        inout("a0") a0,
        in("a1") a1,
        in("a2") a2,
        in("a3") a3,
        in("a4") a4,
        in("a5") a5,
        in("a6") a6,
        in("a7") a7
    );
    a0
}

#[cfg(not(target_arch = "riscv64"))]
#[allow(clippy::too_many_arguments)]
pub unsafe fn syscall(
    _a0: u64,
    _a1: u64,
    _a2: u64,
    _a3: u64,
    _a4: u64,
    _a5: u64,
    _a6: u64,
    _a7: u64,
) -> u64 {
    u64::MAX
}

pub fn vm_version() -> u64 {
    unsafe { syscall(0, 0, 0, 0, 0, 0, 0, SYS_VM_VERSION) }
}



/// Load data
/// Return data length or syscall error
fn syscall_load(
    buf_ptr: *mut u8,
    len: usize,
    a2: usize,
    a3: u64,
    a4: u64,
    a5: u64,
    a6: u64,
    syscall_num: u64,
) -> Result<usize, SysError> {
    let mut actual_data_len = len;
    let len_ptr: *mut usize = &mut actual_data_len;
    let ret = unsafe {
        syscall(
            buf_ptr as u64,
            len_ptr as u64,
            a2 as u64,
            a3,
            a4,
            a5,
            a6,
            syscall_num,
        )
    };
    build_syscall_result(ret, len, actual_data_len)
}

fn build_syscall_result(
    errno: u64,
    load_len: usize,
    actual_data_len: usize,
) -> Result<usize, SysError> {
    use SysError::*;

    match errno {
        0 => {
            if actual_data_len > load_len {
                return Err(LengthNotEnough(actual_data_len));
            }
            Ok(actual_data_len)
        }
        1 => Err(IndexOutOfBound),
        2 => Err(ItemMissing),
        _ => Err(Unknown(errno)),
    }
}


/// Find an OutPoint by searching for a specific type script
///
/// Searches for a cell with the given type script and returns its OutPoint.
/// The OutPoint data is written to the provided buffer.
///
/// # Arguments
///
/// * `buf` - A mutable buffer to receive the OutPoint data
/// * `type_script` - The serialized type script to search for
///
/// # Returns
///
/// * `Ok(usize)` - The actual length of the OutPoint data written to the buffer
/// * `Err(SysError)` - A system error if the operation fails
///
/// # Errors
///
/// Returns `SysError::LengthNotEnough` if the buffer is too small to hold the data
/// Returns `SysError::IndexOutOfBound` if the type script is invalid
/// Returns `SysError::ItemMissing` if no matching cell is found
pub fn find_out_point_by_type(
    buf: &mut [u8],
    type_script: &[u8],
) -> Result<usize, SysError> {
    syscall_load(
        buf.as_mut_ptr(),
        buf.len(),
        type_script.as_ptr() as usize,
        type_script.len() as u64,
        0,
        0,
        0,
        SYS_FIND_OUT_POINT_BY_TYPE,
    )
}

/// Find a cell by its OutPoint
///
/// Retrieves cell information using the specified OutPoint.
/// The cell data is written to the provided buffer.
///
/// # Arguments
///
/// * `buf` - A mutable buffer to receive the cell data
/// * `out_point` - The serialized OutPoint identifying the cell to find
///
/// # Returns
///
/// * `Ok(usize)` - The actual length of the cell data written to the buffer
/// * `Err(SysError)` - A system error if the operation fails
///
/// # Errors
///
/// Returns `SysError::LengthNotEnough` if the buffer is too small to hold the data
/// Returns `SysError::IndexOutOfBound` if the OutPoint is invalid
/// Returns `SysError::ItemMissing` if the cell cannot be found
pub fn find_cell_by_out_point(
    buf: &mut [u8],
    out_point: &[u8],
) -> Result<usize, SysError> {
    syscall_load(
        buf.as_mut_ptr(),
        buf.len(),
        out_point.as_ptr() as usize,
        0,
        0,
        0,
        0,
        SYS_FIND_CELL_BY_OUT_POINT,
    )
}

/// Find cell data by OutPoint
///
/// Retrieves the data contained in a cell identified by the specified OutPoint.
/// The cell's data is written to the provided buffer.
///
/// # Arguments
///
/// * `buf` - A mutable buffer to receive the cell's data
/// * `out_point` - The serialized OutPoint identifying the cell whose data to retrieve
///
/// # Returns
///
/// * `Ok(usize)` - The actual length of the cell data written to the buffer
/// * `Err(SysError)` - A system error if the operation fails
///
/// # Errors
///
/// Returns `SysError::LengthNotEnough` if the buffer is too small to hold the data
/// Returns `SysError::IndexOutOfBound` if the OutPoint is invalid
/// Returns `SysError::ItemMissing` if the cell cannot be found
pub fn find_cell_data_by_out_point(
    buf: &mut [u8],
    out_point: &[u8],
) -> Result<usize, SysError> {
    syscall_load(
        buf.as_mut_ptr(),
        buf.len(),
        out_point.as_ptr() as usize,
        0,
        0,
        0,
        0,
        SYS_FIND_CELL_DATA_BY_OUT_POINT,
    )
}



================================================
File: ckb-ssri-std-proc-macro/Cargo.toml
================================================
[package]
name = "ckb-ssri-std-proc-macro"
version = "0.0.1"
edition = "2021"
description = "Procedural macros for CKB SSRI std"
license = "MIT"
repository = "https://github.com/ckb-devrel/ckb-ssri-std"
documentation = "https://github.com/ckb-devrel/ckb-ssri-std"
authors = ["Alive24 <xct24@live.com>"]
keywords = ["ckb", "nervos", "blockchain", "smart-contracts", "ssri"]
categories = ["cryptography::cryptocurrencies", "development-tools"]

[lib]
proc-macro = true

[dependencies]
ckb-hash = "0.116.1"
quote = "1.0.37"
syn = { version = "2.0", features = ["full"] }
proc-macro2 = "1.0.87"


================================================
File: ckb-ssri-std-proc-macro/src/lib.rs
================================================
#![no_std]

extern crate alloc;
extern crate proc_macro;

use core::panic;

use ckb_hash::blake2b_256;
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse::Parse, parse_macro_input, Expr, ExprLit, Ident, Lit, Token};

use alloc::vec;
use alloc::vec::Vec;

fn encode_u64_vector(val: impl AsRef<[u64]>) -> Vec<u8> {
    let val = val.as_ref();
    u32::to_le_bytes(val.len() as u32)
        .into_iter()
        .chain(val.iter().flat_map(|v| u64::to_le_bytes(*v)))
        .collect()
}

fn method_path(name: impl AsRef<[u8]>) -> u64 {
    u64::from_le_bytes(blake2b_256(name)[0..8].try_into().unwrap())
}

struct Methods {
    argv: Expr,
    invalid_method: Expr,
    invalid_args: Expr,
    method_keys: Vec<u64>,
    method_bodies: Vec<Expr>,
}

impl Parse for Methods {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        input.parse::<Ident>()?;
        input.parse::<Token![:]>()?;
        let argv = input.parse::<Expr>()?;
        input.parse::<Token![,]>()?;
        input.parse::<Ident>()?;
        input.parse::<Token![:]>()?;
        let invalid_method = input.parse::<Expr>()?;
        input.parse::<Token![,]>()?;
        input.parse::<Ident>()?;
        input.parse::<Token![:]>()?;
        let invalid_args = input.parse::<Expr>()?;
        input.parse::<Token![,]>()?;

        let mut method_keys = vec![];
        let mut method_bodies = vec![];
        while !input.is_empty() {
            let name = match input.parse::<Expr>()? {
                Expr::Lit(ExprLit {
                    lit: Lit::Str(v), ..
                }) => v.value(),
                _ => panic!("method name should be a string"),
            };
            input.parse::<Token![=>]>()?;
            let body = input.parse::<Expr>()?;
            input.parse::<Token![,]>()?;

            method_keys.push(method_path(name));
            method_bodies.push(body);
        }

        Ok(Methods {
            argv,
            invalid_method,
            invalid_args,
            method_keys,
            method_bodies,
        })
    }
}

#[proc_macro]
pub fn ssri_methods(input: TokenStream) -> TokenStream {
    let Methods {
        argv,
        invalid_method,
        invalid_args,
        method_keys,
        method_bodies,
    } = parse_macro_input!(input as Methods);

    let version_path = method_path("SSRI.version");
    let get_methods_path = method_path("SSRI.get_methods");
    let has_methods_path = method_path("SSRI.has_methods");

    let raw_methods = encode_u64_vector(
        [version_path, get_methods_path, has_methods_path]
            .iter()
            .chain(method_keys.iter())
            .copied()
            .collect::<Vec<_>>(),
    );
    let raw_methods_len = raw_methods.len();

    TokenStream::from(quote! {
        {
            use alloc::{borrow::Cow, vec::Vec};
            use ckb_std::high_level::decode_hex;
            const RAW_METHODS: [u8; #raw_methods_len] = [#(#raw_methods,)*];
            let res: Result<Cow<'static, [u8]>, Error> = match u64::from_le_bytes(
                decode_hex(&(#argv)[0])?.try_into().map_err(|_| #invalid_method)?,
            ) {
                #version_path => Ok(Cow::from(&[0][..])),
                #get_methods_path => {
                    let offset = usize::min((u64::from_le_bytes(
                        decode_hex(&(#argv)[1])?
                            .try_into()
                            .map_err(|_| #invalid_args)?
                    ) as usize * 8), #raw_methods_len - 4);

                    // If second argument is 0, take all remaining methods
                    let second_arg = u64::from_le_bytes(
                        decode_hex(&(#argv)[2])?
                            .try_into()
                            .map_err(|_| #invalid_args)?
                    );

                    let mut raw_result: Vec<u8>;
                    if second_arg == 0 {
                        // Take all remaining methods from offset
                        raw_result = RAW_METHODS[(offset + 4)..].to_vec();
                        let method_count = (RAW_METHODS.len() - (offset + 4)) / 8;
                        let mut result = (method_count as u32).to_le_bytes().to_vec();
                        result.extend_from_slice(&raw_result);
                        Ok(Cow::from(result))
                    } else {
                        let limit = usize::min((offset + (second_arg as usize * 8)), #raw_methods_len - 4);
                        raw_result = RAW_METHODS[(offset + 4)..(limit + 4)].to_vec();
                        let method_count = (limit - offset) / 8;
                        let mut result = (method_count as u32).to_le_bytes().to_vec();
                        result.extend_from_slice(&raw_result);
                        Ok(Cow::from(result))
                    }
                },
                #has_methods_path => {
                    let mut result = Vec::new();
                    let matches = decode_hex(&(#argv)[1])?[4..].chunks(8).map(|path| {
                        match RAW_METHODS[4..]
                            .chunks(8)
                            .find(|v| v == &path) {
                                Some(_) => 1,
                                None => 0,
                            }
                    }).collect::<Vec<_>>();
                    result.extend_from_slice(&(matches.len() as u32).to_le_bytes());
                    result.extend_from_slice(&matches);
                    Ok(Cow::from(result))
                },
                #(
                    #method_keys => #method_bodies,
                )*
                _ => Err(#invalid_method),
            };
            res
        }
    })
}


