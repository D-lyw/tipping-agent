Directory structure:
└── nervosnetwork-ckb-vm/
    ├── README.md
    ├── CONTRIBUTING.md
    ├── COPYING
    ├── Cargo.toml
    ├── Makefile
    ├── SECURITY.md
    ├── build.rs
    ├── clippy.toml
    ├── codecov.yml
    ├── deny.toml
    ├── rust-toolchain
    ├── rustfmt.toml
    ├── benches/
    │   ├── bits_benchmark.rs
    │   ├── vm_benchmark.rs
    │   └── data/
    │       ├── secp256k1_bench
    │       └── secp256k1_bench_old
    ├── definitions/
    │   ├── Cargo.toml
    │   └── src/
    │       ├── asm.rs
    │       ├── generate_asm_constants.rs
    │       ├── instructions.rs
    │       ├── lib.rs
    │       ├── memory.rs
    │       └── registers.rs
    ├── examples/
    │   ├── check_real_memory.rs
    │   ├── ckb_vm_runner.rs
    │   ├── is13.c
    │   └── is13.rs
    ├── fuzz/
    │   ├── Cargo.toml
    │   ├── .gitignore
    │   └── fuzz_targets/
    │       ├── asm.rs
    │       ├── interpreter.rs
    │       ├── isa_a.rs
    │       ├── isa_b.rs
    │       ├── snapshot.rs
    │       └── snapshot2.rs
    ├── src/
    │   ├── bits.rs
    │   ├── cost_model.rs
    │   ├── debugger.rs
    │   ├── decoder.rs
    │   ├── elf.rs
    │   ├── error.rs
    │   ├── lib.rs
    │   ├── snapshot.rs
    │   ├── snapshot2.rs
    │   ├── instructions/
    │   │   ├── a.rs
    │   │   ├── ast.rs
    │   │   ├── b.rs
    │   │   ├── common.rs
    │   │   ├── execute.rs
    │   │   ├── i.rs
    │   │   ├── m.rs
    │   │   ├── mod.rs
    │   │   ├── register.rs
    │   │   ├── rvc.rs
    │   │   ├── tagged.rs
    │   │   └── utils.rs
    │   ├── machine/
    │   │   ├── mod.rs
    │   │   ├── trace.rs
    │   │   └── asm/
    │   │       ├── cdefinitions_generated.h
    │   │       ├── execute_aarch64.S
    │   │       ├── execute_x64.S
    │   │       ├── mod.rs
    │   │       └── traces.rs
    │   ├── memory/
    │   │   ├── flat.rs
    │   │   ├── mod.rs
    │   │   ├── sparse.rs
    │   │   └── wxorx.rs
    │   └── syscalls/
    │       └── mod.rs
    ├── tests/
    │   ├── machine_build.rs
    │   ├── test_a_extension.rs
    │   ├── test_asm.rs
    │   ├── test_auipc_fusion.rs
    │   ├── test_b_extension.rs
    │   ├── test_dy_memory.rs
    │   ├── test_error.rs
    │   ├── test_minimal.rs
    │   ├── test_misc.rs
    │   ├── test_mop.rs
    │   ├── test_reset.rs
    │   ├── test_resume.rs
    │   ├── test_resume2.rs
    │   ├── test_signal_pause.rs
    │   ├── test_simple.rs
    │   ├── test_spawn.rs
    │   ├── test_versions.rs
    │   └── programs/
    │       ├── _build_all.sh
    │       ├── _build_all_native.sh
    │       ├── _build_clang.sh
    │       ├── _build_clang_native.sh
    │       ├── alloc_many
    │       ├── alloc_many.c
    │       ├── amo_check_write
    │       ├── amo_check_write.S
    │       ├── amo_check_write.lds
    │       ├── amo_compare
    │       ├── amo_compare.S
    │       ├── amo_compare.lds
    │       ├── amo_write_permission
    │       ├── amo_write_permission.S
    │       ├── andi
    │       ├── andi.c
    │       ├── argv_null_test
    │       ├── argv_null_test.c
    │       ├── asm_trace_bug
    │       ├── auipc_no_sign_extend
    │       ├── auipc_no_sign_extend.S
    │       ├── big_binary
    │       ├── big_binary.c
    │       ├── cadd_hints
    │       ├── cadd_hints.S
    │       ├── ckbforks
    │       ├── ckbforks.S
    │       ├── clang_sample
    │       ├── clang_sample.c
    │       ├── clmul_bug
    │       ├── clmul_bug.S
    │       ├── clzw_bug
    │       ├── clzw_bug.S
    │       ├── decoder_instructions_cache_pc_out_of_bound_timeout
    │       ├── ebreak.S
    │       ├── ebreak64
    │       ├── flat_crash_64
    │       ├── goblin_overflow_elf
    │       ├── invalid_file_offset64
    │       ├── invalid_read.S
    │       ├── invalid_read64
    │       ├── jalr_bug
    │       ├── jalr_bug.S
    │       ├── jalr_bug_noc
    │       ├── jalr_bug_noc.S
    │       ├── jump0.S
    │       ├── jump0_64
    │       ├── load_elf_crash_64
    │       ├── load_elf_section_crash_64
    │       ├── load_malformed_elf_crash_64
    │       ├── memory_crash
    │       ├── memory_crash.md
    │       ├── minimal
    │       ├── minimal.c
    │       ├── misaligned_jump.S
    │       ├── misaligned_jump64
    │       ├── mop_adc
    │       ├── mop_adc.S
    │       ├── mop_adcs
    │       ├── mop_adcs.S
    │       ├── mop_add3
    │       ├── mop_add3.S
    │       ├── mop_far_jump
    │       ├── mop_far_jump.S
    │       ├── mop_far_jump.dump
    │       ├── mop_jump_abs_version1_reg_not_updated_bug
    │       ├── mop_jump_abs_version1_reg_not_updated_bug.S
    │       ├── mop_jump_rel_version1_bug
    │       ├── mop_jump_rel_version1_bug.S
    │       ├── mop_jump_rel_version1_reg_not_updated_bug
    │       ├── mop_jump_rel_version1_reg_not_updated_bug.S
    │       ├── mop_ld_signextend_32
    │       ├── mop_ld_signextend_32.c
    │       ├── mop_ld_signextend_32_overflow_bug
    │       ├── mop_ld_signextend_32_overflow_bug.S
    │       ├── mop_random_adc_sbb
    │       ├── mop_random_adc_sbb.S
    │       ├── mop_sbb
    │       ├── mop_sbb.S
    │       ├── mop_sbbs
    │       ├── mop_sbbs.S
    │       ├── mop_wide_div_zero
    │       ├── mop_wide_div_zero.S
    │       ├── mop_wide_divide
    │       ├── mop_wide_divide.c
    │       ├── mop_wide_mul_zero
    │       ├── mop_wide_mul_zero.S
    │       ├── mop_wide_multiply
    │       ├── mop_wide_multiply.c
    │       ├── mulw.S
    │       ├── mulw64
    │       ├── nop
    │       ├── nop.S
    │       ├── op_rvc_slli_crash_32
    │       ├── op_rvc_srai_crash_32
    │       ├── op_rvc_srli_crash_32
    │       ├── orc_bug
    │       ├── orc_bug.S
    │       ├── pause_resume
    │       ├── pause_resume.c
    │       ├── pcnt
    │       ├── pcnt.c
    │       ├── read_at_boundary.S
    │       ├── read_at_boundary64
    │       ├── read_memory
    │       ├── read_memory.S
    │       ├── reset_callee
    │       ├── reset_callee.c
    │       ├── reset_caller
    │       ├── reset_caller.c
    │       ├── resume2_load_data
    │       ├── resume2_load_data.c
    │       ├── rorw_in_end_of_aot_block
    │       ├── rorw_in_end_of_aot_block.S
    │       ├── rvc_pageend
    │       ├── rvc_pageend.S
    │       ├── rvc_pageend.dump
    │       ├── rvc_pageend.lds
    │       ├── rvc_pageend.sh
    │       ├── sbinvi_aot_load_imm_bug
    │       ├── sbinvi_aot_load_imm_bug.S
    │       ├── sc_after_sc
    │       ├── sc_after_sc.S
    │       ├── sc_after_sc.lds
    │       ├── sc_after_snapshot
    │       ├── sc_after_snapshot.S
    │       ├── sc_after_snapshot.lds
    │       ├── sc_only
    │       ├── sc_only.S
    │       ├── sc_only.lds
    │       ├── simple
    │       ├── simple.c
    │       ├── simple64
    │       ├── sp_alignment_test
    │       ├── sp_alignment_test.S
    │       ├── spawn
    │       ├── spawn.c
    │       ├── syscall.S
    │       ├── syscall64
    │       ├── trace.S
    │       ├── trace64
    │       ├── unaligned64
    │       ├── unaligned64.S
    │       ├── writable_page
    │       ├── writable_page.c
    │       ├── writable_page.dump
    │       ├── write_at_boundary.S
    │       ├── write_at_boundary64
    │       ├── write_large_address.S
    │       ├── write_large_address64
    │       ├── wxorx_crash_64
    │       ├── zero_address
    │       ├── zero_address.S
    │       └── zero_address.lds
    └── .github/
        ├── CODEOWNERS
        ├── ISSUE_TEMPLATE/
        │   └── bug_report.md
        └── workflows/
            └── develop.yml

================================================
File: README.md
================================================
# [Nervos CKB](https://nervos.org) VM

[![Build Status](https://dev.azure.com/nervosnetwork/ckb-vm/_apis/build/status/nervosnetwork.ckb-vm?branchName=develop)](https://dev.azure.com/nervosnetwork/ckb-vm/_build/latest?definitionId=10&branchName=develop)
[![codecov](https://codecov.io/gh/nervosnetwork/ckb-vm/branch/develop/graph/badge.svg)](https://codecov.io/gh/nervosnetwork/ckb-vm)

---

## About CKB VM

CKB VM is a pure software implementation of the [RISC-V](https://riscv.org/) instruction set used as scripting VM in CKB. Right now it implements full IMCB instructions for both 32-bit and 64-bit register size support. In the future we might also implement V extensions to enable better crypto implementations.

## License

Nervos CKB is released under the terms of the MIT license. See [COPYING](COPYING) for more information or see [https://opensource.org/licenses/MIT](https://opensource.org/licenses/MIT).

## Development Process

This is now deployed and used in production CKB mainnet.

The `develop` branch is regularly built and tested, but is not guaranteed to be completely stable. CKB will use released versions of CKB VM which are tested and more stable.

The contribution workflow is described in [CONTRIBUTING.md](CONTRIBUTING.md), and security policy is described in [SECURITY.md](SECURITY.md). To propose new protocol or standard for Nervos, see [Nervos RFC](https://github.com/nervosnetwork/rfcs).

---

## How to build

CKB VM is currently tested mainly with `stable` Rust version on 64-bit Linux, macOS, and Windows.

```bash
# download CKB VM
$ git clone https://github.com/nervosnetwork/ckb-vm
$ cd ckb-vm
$ cargo build
```

You can also run the tests:

```bash
make test
```

CKB VM has already included RISC-V binaries used in tests, so you don't need a RISC-V compiler to build binaries. However if you do want to play with your own binaries, a RISC-V compiler might be needed. [riscv-tools](https://github.com/riscv/riscv-tools) can be a good starting point here, or if you are an expert on GNU toolchain, you might also compile upstream GCC from source with RISC-V support, [here](./examples/is13.rs) is an example. CKB VM is using standard RISC-V instructions and ELF binary format, so theoretically any RISC-V compatible compilers are able to produce contracts used in CKB VM(tho bug reports are very welcome if you find breakage).

## Notes on Different Modes

Right now CKB VM has 2 different modes:

* Rust interpreter mode
* Assembly based interpreter mode(ASM mode)

For consistent behavior, you should only use ASM mode. The Rust mode is developed more to assist development, and never used in production by us. In case of bugs, there might be inconsistent behaviors between Rust mode and ASM mode.


================================================
File: CONTRIBUTING.md
================================================
# Contributing

When contributing to this repository, please first discuss the change you wish to make via issue,
email, or any other method with the community before making a change. The developer mailing list
([English] | [Chinese]) should be used to discuss complicated or controversial changes before working
on a patch set.

[english]: https://groups.google.com/a/nervos.org/d/forum/ckb-dev
[chinese]: https://groups.google.com/a/nervos.org/d/forum/ckb-dev-zh

Please note we have a code of conduct, please follow it in all your interactions with the project.

### Report Issue

* **Do not open up a GitHub issue to report security vulnerabilities**. Instead,
  refer to the [security policy](SECURITY.md).

* Search existing issues to see whether others had already posted a similar issue.

* When creating a new issue, be sure to include a title and clear description. It is appreciated that if you can also attach as much relevant information as possible, such as version, environment, reproducing steps, samples.

* If possible, use the relevant bug report templates to create the issue.

### Fix Bug

* Open a new GitHub pull request with the patch.

* Ensure the PR description clearly describes the problem and solution. Include the relevant issue number if applicable.

### Propose new features

See [Nervos Network RFCs Process](https://github.com/nervosnetwork/rfcs).

## Code of Conduct

### Our Pledge

In the interest of fostering an open and welcoming environment, we as
contributors and maintainers pledge to making participation in our project and
our community a harassment-free experience for everyone, regardless of age, body
size, disability, ethnicity, sex characteristics, gender identity and expression,
level of experience, education, socio-economic status, nationality, personal
appearance, race, religion, or sexual identity and orientation.

### Our Standards

Examples of behavior that contributes to creating a positive environment
include:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery and unwelcome sexual attention or
 advances
* Trolling, insulting/derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or electronic
 address, without explicit permission
* Other conduct which could reasonably be considered inappropriate in a
 professional setting

### Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable
behavior and are expected to take appropriate and fair corrective action in
response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or
reject comments, commits, code, wiki edits, issues, and other contributions
that are not aligned to this Code of Conduct, or to ban temporarily or
permanently any contributor for other behaviors that they deem inappropriate,
threatening, offensive, or harmful.

### Scope

This Code of Conduct applies both within project spaces and in public spaces
when an individual is representing the project or its community. Examples of
representing a project or community include using an official project e-mail
address, posting via an official social media account, or acting as an appointed
representative at an online or offline event. Representation of a project may be
further defined and clarified by project maintainers.

### Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported by contacting the project team at hello@nervos.org. All
complaints will be reviewed and investigated and will result in a response that
is deemed necessary and appropriate to the circumstances. The project team is
obligated to maintain confidentiality with regard to the reporter of an incident.
Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good
faith may face temporary or permanent repercussions as determined by other
members of the project's leadership.

### Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,
available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see
https://www.contributor-covenant.org/faq


================================================
File: COPYING
================================================
The MIT License (MIT)

Copyright (c) 2018 Nervos Foundation

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


================================================
File: Cargo.toml
================================================
[package]
name = "ckb-vm"
description = "CKB's Virtual machine"
version = "0.24.0"
license = "MIT"
authors = ["Nervos Core Dev <dev@nervos.org>"]
edition = "2021"
rust-version = "1.81.0"
build = "build.rs"
exclude = ["/benches", "/tests"]
homepage = "https://github.com/nervosnetwork/ckb-vm"
repository = "https://github.com/nervosnetwork/ckb-vm"

[features]
default = []
# Require asm feature, generates an error if asm cannot be enabled.
asm = []
# Detect if requirements are met, and enable asm feature when we can.
detect-asm = []
enable-chaos-mode-by-default = ["ckb-vm-definitions/enable-chaos-mode-by-default"]
# Disable slow tests to run miri on CI
miri-ci = []
pprof = []

[dependencies]
byteorder = "1"
bytes = "1"
goblin_v023 = { package = "goblin", version = "=0.2.3" }
goblin_v040 = { package = "goblin", version = "=0.4.0" }
scroll = "0.10"
serde = { version = "1.0", features = ["derive"] }
ckb-vm-definitions = { path = "definitions", version = "=0.24.0" }
derive_more = { version = "1", features = ["full"] }
rand = "0.7.3"

[build-dependencies]
cc = "1.0"

[dev-dependencies]
criterion = "0.5.1"
proptest = "1.5.0"

[target.'cfg(not(target_os = "windows"))'.dev-dependencies]
jemallocator = "0.5.0"
jemalloc-ctl = "0.5.0"

[[bench]]
name = "bits_benchmark"
path = "benches/bits_benchmark.rs"
harness = false

[[bench]]
name = "vm_benchmark"
path = "benches/vm_benchmark.rs"
harness = false

[lints.rust]
unexpected_cfgs = { level = "warn", check-cfg = ['cfg(has_asm)'] }


================================================
File: Makefile
================================================
test:
	cargo test --all -- --nocapture

test-asm:
	cargo test --all --features=asm -- --nocapture

test-asm-chaos:
	cargo test --all --features=asm,enable-chaos-mode-by-default -- --nocapture

check:
	cargo check --all --all-targets --all-features

cov:
	cargo clean
	cargo build --tests --all --features=asm
	for file in `find target/debug/ -maxdepth 1 -executable -type f`; do mkdir -p "target/cov/$$(basename $$file)"; kcov --exclude-pattern=/.cargo,/usr/lib,tests --verify "target/cov/$$(basename $$file)" "$$file"; done

fmt:
	cargo fmt --all -- --check
	cd definitions && cargo fmt ${VERBOSE} --all -- --check

clippy_rule = -D warnings \
	-D clippy::clone_on_ref_ptr \
	-D clippy::enum_glob_use \
	-A clippy::collapsible-else-if \
	-A clippy::upper_case_acronyms \
	-A clippy::unusual_byte_groupings \
	-A clippy::inconsistent_digit_grouping \
	-A clippy::large_digit_groups \
	-A clippy::suspicious_operation_groupings \
	-A clippy::unnecessary_cast \
	-A clippy::mut_from_ref
clippy:
	cargo clippy --all --features=asm -- $(clippy_rule)
	cd definitions && cargo clippy --all -- $(clippy_rule)

fuzz:
	cargo +nightly fuzz run asm -- -max_total_time=180
	cargo +nightly fuzz run isa_a -- -max_total_time=180

ci: fmt check clippy test
	git diff --exit-code Cargo.lock

ci-asm: test-asm
	git diff --exit-code Cargo.lock

ci-asm-chaos: test-asm-chaos
	git diff --exit-code Cargo.lock

ci-generated: update-cdefinitions
	git diff --exit-code src/machine/asm/cdefinitions_generated.h

update-cdefinitions:
	cargo run --manifest-path=definitions/Cargo.toml --bin generate_asm_constants > src/machine/asm/cdefinitions_generated.h

.PHONY: test clippy fmt fuzz
.PHONY: ci ci-quick ci-all-features ci-cdefinitions
.PHONY: stats security-audit check-licenses check-crates
.PHONY: update-cdefinitions


================================================
File: SECURITY.md
================================================
# Security Policy

This project is still under development, the primary goal at this stage is to implement features but we also take security very seriously. This document defines the policy on how to report vulnerabilities and receive updates when patches to those are released.

[Join Nervos Security Team!](mailto:careers@nervos.org)


## Reporting a vulnerability

All security bugs should be reported by sending email to [Nervos Security Team \<security@nervos.org>](mailto:security@nervos.org). Please encrypt your mail using GPG with the following public key.

* Unique ID: `Nervos Security Team <security@nervos.org>`
* Fingerprint: C3D9 CF8A 1450 D04B 997E  4E31 6CBD D93A 0C9F 6BCD
* Import from keys.openpgp.org: [0C9F6BCD](https://keys.openpgp.org/search?q=security@nervos.org)

This will deliver a message to Nervos Security Team who handle security issues. Your report will be acknowledged within 24 hours, and you'll receive a more detailed response to your email within 72 hours indicating the next steps in handling your report.

After the initial reply to your report the security team will endeavor to keep you informed of the progress being made towards a fix and full announcement.

## Disclosure process

1. Security report received and is assigned a primary handler. This person will coordinate the fix and release process. Problem is confirmed and all affected versions is determined. Code is audited to find any potential similar problems.
2. Fixes are prepared for all supported releases. These fixes are not committed to the public repository but rather held locally pending the announcement.
3. A suggested embargo date for this vulnerability is chosen. This notification will include patches for all supported versions.
4. On the embargo date, the [Nervos security mailing list](https://groups.google.com/u/0/a/nervos.org/g/security-mailing-list) is sent a copy of the announcement. The changes are pushed to the public repository. At least 6 hours after the mailing list is notified, a copy of the advisory will be published on Nervos community channels.

This process can take some time, especially when coordination is required with maintainers of other projects. Every effort will be made to handle the bug in as timely a manner as possible, however it's important that we follow the release process above to ensure that the disclosure is handled in a consistent manner.

## Receiving disclosures

If you require prior notification of vulnerabilities please subscribe to the [Nervos Security mailing list](https://groups.google.com/u/0/a/nervos.org/g/security-mailing-list). The mailing list is very low traffic, and it receives the public notifications the moment the embargo is lifted.

If you have any suggestions to improve this policy, please send an email to [Nervos Security Team](security@nervos.org).



================================================
File: build.rs
================================================
// Due to this bug: https://github.com/rust-lang/cargo/issues/4866, we cannot
// specify different features based on different targets now in cargo file. We
// have to keep features always on, and do conditional compilation within the
// source code

fn main() {
    use std::env;

    let target_family = env::var("CARGO_CFG_TARGET_FAMILY").unwrap_or_default();
    let target_arch = env::var("CARGO_CFG_TARGET_ARCH").unwrap_or_default();
    let target_env = env::var("CARGO_CFG_TARGET_ENV").unwrap_or_default();
    let is_windows = target_family == "windows";
    let is_msvc = is_windows && (target_env == "msvc");
    let is_unix = target_family == "unix";
    let is_x86_64 = target_arch == "x86_64";
    let is_aarch64 = target_arch == "aarch64";
    let x64_asm = is_x86_64 && (is_windows || is_unix);
    let aarch64_asm = is_aarch64 && is_unix;
    let can_enable_asm = x64_asm || aarch64_asm;

    if cfg!(feature = "asm") && (!can_enable_asm) {
        panic!(
            "Asm feature is not available for target {} on {}!",
            target_arch, target_family
        );
    }

    if cfg!(any(feature = "asm", feature = "detect-asm")) && can_enable_asm {
        println!("cargo:rerun-if-changed=src/machine/asm/execute_x64.S");
        println!("cargo:rerun-if-changed=src/machine/asm/execute_aarch64.S");
        println!("cargo:rerun-if-changed=src/machine/asm/cdefinitions_generated.h");

        let mut build = cc::Build::new();

        if x64_asm {
            build.file("src/machine/asm/execute_x64.S");
            if is_msvc {
                // For now, only an assembly source code is required for CKB-VM, we won't
                // need to build any C source file here. Hence we can use this simpler solution
                // to set the default compiler to GCC. We will need to manually trigger the
                // command to assemble the assembly code file, should any C source file is also
                // required here.
                build.compiler("gcc");
            }
        } else if aarch64_asm {
            build.file("src/machine/asm/execute_aarch64.S");
        }

        build.include("src/machine/asm").compile("asm");

        println!("cargo:rustc-cfg=has_asm")
    }
}


================================================
File: clippy.toml
================================================
single-char-binding-names-threshold = 4


================================================
File: codecov.yml
================================================
coverage:
  status:
    project:
      default:
        target: 50
        threshold: 10
    patch: off


================================================
File: deny.toml
================================================
# This template contains all of the possible sections and their default values

# Note that all fields that take a lint level have these possible values:
# * deny - An error will be produced and the check will fail
# * warn - A warning will be produced, but the check will not fail
# * allow - No warning or error will be produced, though in some cases a note
# will be

# The values provided in this template are the default values that will be used
# when any section or field is not specified in your own configuration

# Root options

# The graph table configures how the dependency graph is constructed and thus
# which crates the checks are performed against
[graph]
# If 1 or more target triples (and optionally, target_features) are specified,
# only the specified targets will be checked when running `cargo deny check`.
# This means, if a particular package is only ever used as a target specific
# dependency, such as, for example, the `nix` crate only being used via the
# `target_family = "unix"` configuration, that only having windows targets in
# this list would mean the nix crate, as well as any of its exclusive
# dependencies not shared by any other crates, would be ignored, as the target
# list here is effectively saying which targets you are building for.
targets = [
    # The triple can be any string, but only the target triples built in to
    # rustc (as of 1.40) can be checked against actual config expressions
    #"x86_64-unknown-linux-musl",
    # You can also specify which target_features you promise are enabled for a
    # particular target. target_features are currently not validated against
    # the actual valid features supported by the target architecture.
    #{ triple = "wasm32-unknown-unknown", features = ["atomics"] },
]
# When creating the dependency graph used as the source of truth when checks are
# executed, this field can be used to prune crates from the graph, removing them
# from the view of cargo-deny. This is an extremely heavy hammer, as if a crate
# is pruned from the graph, all of its dependencies will also be pruned unless
# they are connected to another crate in the graph that hasn't been pruned,
# so it should be used with care. The identifiers are [Package ID Specifications]
# (https://doc.rust-lang.org/cargo/reference/pkgid-spec.html)
#exclude = []
# If true, metadata will be collected with `--all-features`. Note that this can't
# be toggled off if true, if you want to conditionally enable `--all-features` it
# is recommended to pass `--all-features` on the cmd line instead
all-features = false
# If true, metadata will be collected with `--no-default-features`. The same
# caveat with `all-features` applies
no-default-features = false
# If set, these feature will be enabled when collecting metadata. If `--features`
# is specified on the cmd line they will take precedence over this option.
#features = []

# The output table provides options for how/if diagnostics are outputted
[output]
# When outputting inclusion graphs in diagnostics that include features, this
# option can be used to specify the depth at which feature edges will be added.
# This option is included since the graphs can be quite large and the addition
# of features from the crate(s) to all of the graph roots can be far too verbose.
# This option can be overridden via `--feature-depth` on the cmd line
feature-depth = 1

# This section is considered when running `cargo deny check advisories`
# More documentation for the advisories section can be found here:
# https://embarkstudios.github.io/cargo-deny/checks/advisories/cfg.html
[advisories]
# The path where the advisory databases are cloned/fetched into
#db-path = "$CARGO_HOME/advisory-dbs"
# The url(s) of the advisory databases to use
#db-urls = ["https://github.com/rustsec/advisory-db"]
# A list of advisory IDs to ignore. Note that ignored advisories will still
# output a note when they are encountered.
ignore = [
    #"RUSTSEC-0000-0000",
    #{ id = "RUSTSEC-0000-0000", reason = "you can specify a reason the advisory is ignored" },
    #"a-crate-that-is-yanked@0.1.1", # you can also ignore yanked crate versions if you wish
    #{ crate = "a-crate-that-is-yanked@0.1.1", reason = "you can specify why you are ignoring the yanked crate" },
]
# If this is true, then cargo deny will use the git executable to fetch advisory database.
# If this is false, then it uses a built-in git library.
# Setting this to true can be helpful if you have special authentication requirements that cargo-deny does not support.
# See Git Authentication for more information about setting up git authentication.
#git-fetch-with-cli = true

# This section is considered when running `cargo deny check licenses`
# More documentation for the licenses section can be found here:
# https://embarkstudios.github.io/cargo-deny/checks/licenses/cfg.html
[licenses]
# List of explicitly allowed licenses
# See https://spdx.org/licenses/ for list of possible licenses
# [possible values: any SPDX 3.11 short identifier (+ optional exception)].
allow = [
    "Apache-2.0",
    "BSD-2-Clause",
    "BSD-3-Clause",
    "ISC",
    "MIT",
    "Unicode-DFS-2016",
    "Unicode-3.0",
]
# The confidence threshold for detecting a license from license text.
# The higher the value, the more closely the license text must be to the
# canonical license text of a valid SPDX license file.
# [possible values: any between 0.0 and 1.0].
confidence-threshold = 0.8
# Allow 1 or more licenses on a per-crate basis, so that particular licenses
# aren't accepted for every possible crate as with the normal allow list
exceptions = [
    # Each entry is the crate and version constraint, and its specific allow
    # list
    #{ allow = ["Zlib"], crate = "adler32" },
]

# Some crates don't have (easily) machine readable licensing information,
# adding a clarification entry for it allows you to manually specify the
# licensing information
#[[licenses.clarify]]
# The package spec the clarification applies to
#crate = "ring"
# The SPDX expression for the license requirements of the crate
#expression = "MIT AND ISC AND OpenSSL"
# One or more files in the crate's source used as the "source of truth" for
# the license expression. If the contents match, the clarification will be used
# when running the license check, otherwise the clarification will be ignored
# and the crate will be checked normally, which may produce warnings or errors
# depending on the rest of your configuration
#license-files = [
# Each entry is a crate relative path, and the (opaque) hash of its contents
#{ path = "LICENSE", hash = 0xbd0eed23 }
#]

[licenses.private]
# If true, ignores workspace crates that aren't published, or are only
# published to private registries.
# To see how to mark a crate as unpublished (to the official registry),
# visit https://doc.rust-lang.org/cargo/reference/manifest.html#the-publish-field.
ignore = false
# One or more private registries that you might publish crates to, if a crate
# is only published to private registries, and ignore is true, the crate will
# not have its license(s) checked
registries = [
    #"https://sekretz.com/registry
]

# This section is considered when running `cargo deny check bans`.
# More documentation about the 'bans' section can be found here:
# https://embarkstudios.github.io/cargo-deny/checks/bans/cfg.html
[bans]
# Lint level for when multiple versions of the same crate are detected
multiple-versions = "warn"
# Lint level for when a crate version requirement is `*`
wildcards = "allow"
# The graph highlighting used when creating dotgraphs for crates
# with multiple versions
# * lowest-version - The path to the lowest versioned duplicate is highlighted
# * simplest-path - The path to the version with the fewest edges is highlighted
# * all - Both lowest-version and simplest-path are used
highlight = "all"
# The default lint level for `default` features for crates that are members of
# the workspace that is being checked. This can be overridden by allowing/denying
# `default` on a crate-by-crate basis if desired.
workspace-default-features = "allow"
# The default lint level for `default` features for external crates that are not
# members of the workspace. This can be overridden by allowing/denying `default`
# on a crate-by-crate basis if desired.
external-default-features = "allow"
# List of crates that are allowed. Use with care!
allow = [
    #"ansi_term@0.11.0",
    #{ crate = "ansi_term@0.11.0", reason = "you can specify a reason it is allowed" },
]
# List of crates to deny
deny = [
    #"ansi_term@0.11.0",
    #{ crate = "ansi_term@0.11.0", reason = "you can specify a reason it is banned" },
    # Wrapper crates can optionally be specified to allow the crate when it
    # is a direct dependency of the otherwise banned crate
    #{ crate = "ansi_term@0.11.0", wrappers = ["this-crate-directly-depends-on-ansi_term"] },
]

# List of features to allow/deny
# Each entry the name of a crate and a version range. If version is
# not specified, all versions will be matched.
#[[bans.features]]
#crate = "reqwest"
# Features to not allow
#deny = ["json"]
# Features to allow
#allow = [
#    "rustls",
#    "__rustls",
#    "__tls",
#    "hyper-rustls",
#    "rustls",
#    "rustls-pemfile",
#    "rustls-tls-webpki-roots",
#    "tokio-rustls",
#    "webpki-roots",
#]
# If true, the allowed features must exactly match the enabled feature set. If
# this is set there is no point setting `deny`
#exact = true

# Certain crates/versions that will be skipped when doing duplicate detection.
skip = [
    #"ansi_term@0.11.0",
    #{ crate = "ansi_term@0.11.0", reason = "you can specify a reason why it can't be updated/removed" },
]
# Similarly to `skip` allows you to skip certain crates during duplicate
# detection. Unlike skip, it also includes the entire tree of transitive
# dependencies starting at the specified crate, up to a certain depth, which is
# by default infinite.
skip-tree = [
    #"ansi_term@0.11.0", # will be skipped along with _all_ of its direct and transitive dependencies
    #{ crate = "ansi_term@0.11.0", depth = 20 },
]

# This section is considered when running `cargo deny check sources`.
# More documentation about the 'sources' section can be found here:
# https://embarkstudios.github.io/cargo-deny/checks/sources/cfg.html
[sources]
# Lint level for what to happen when a crate from a crate registry that is not
# in the allow list is encountered
unknown-registry = "warn"
# Lint level for what to happen when a crate from a git repository that is not
# in the allow list is encountered
unknown-git = "warn"
# List of URLs for allowed crate registries. Defaults to the crates.io index
# if not specified. If it is specified but empty, no registries are allowed.
allow-registry = ["https://github.com/rust-lang/crates.io-index"]
# List of URLs for allowed Git repositories
allow-git = []

[sources.allow-org]
# github.com organizations to allow git sources for
github = []
# gitlab.com organizations to allow git sources for
gitlab = []
# bitbucket.org organizations to allow git sources for
bitbucket = []


================================================
File: rust-toolchain
================================================
1.81.0


================================================
File: rustfmt.toml
================================================
max_width = 100
tab_spaces = 4
reorder_imports = true
reorder_modules = true
use_try_shorthand = true


================================================
File: benches/bits_benchmark.rs
================================================
#[macro_use]
extern crate criterion;

use ckb_vm::bits;
use criterion::Criterion;

#[inline(always)]
pub fn roundup_via_remainder(x: u64, round: u64) -> u64 {
    let remainder = x % round;
    if remainder > 0 {
        x - remainder + round
    } else {
        x - remainder
    }
}

#[inline(always)]
pub fn rounddown_via_remainder(x: u64, round: u64) -> u64 {
    let remainder = x % round;
    x - remainder
}

#[inline(always)]
pub fn roundup_via_multiplication(x: u64, round: u64) -> u64 {
    if x == 0 {
        0
    } else {
        ((x - 1) / round + 1) * round
    }
}

#[inline(always)]
pub fn rounddown_via_multiplication(x: u64, round: u64) -> u64 {
    x / round * round
}

const ROUNDS: &[u64] = &[1, 2, 4, 8, 16, 32];

macro_rules! round_bench {
    ($f:expr) => {
        (0..9999).for_each(|x| {
            (&ROUNDS).iter().for_each(|round| {
                $f(x, *round);
            })
        })
    };
}

fn roundup_benchmark(c: &mut Criterion) {
    c.bench_function("roundup via remainder", |b| {
        b.iter(|| round_bench!(roundup_via_remainder))
    });
    c.bench_function("roundup via bit ops", |b| {
        b.iter(|| round_bench!(bits::roundup))
    });
    c.bench_function("roundup via multication", |b| {
        b.iter(|| round_bench!(roundup_via_multiplication))
    });
}

fn rounddown_benchmark(c: &mut Criterion) {
    c.bench_function("roundup via remainder", |b| {
        b.iter(|| round_bench!(rounddown_via_remainder))
    });
    c.bench_function("roundup via bit ops", |b| {
        b.iter(|| round_bench!(bits::rounddown))
    });
    c.bench_function("roundup via multication", |b| {
        b.iter(|| round_bench!(rounddown_via_multiplication))
    });
}

criterion_group!(benches, roundup_benchmark, rounddown_benchmark);
criterion_main!(benches);


================================================
File: benches/vm_benchmark.rs
================================================
#[macro_use]
extern crate criterion;

use bytes::Bytes;
#[cfg(has_asm)]
use ckb_vm::{
    decoder::build_decoder,
    machine::{
        asm::{
            traces::{MemoizedDynamicTraceDecoder, MemoizedFixedTraceDecoder},
            AsmCoreMachine, AsmMachine,
        },
        DefaultMachineBuilder, VERSION0, VERSION2,
    },
    ISA_B, ISA_IMC, ISA_MOP,
};
use ckb_vm::{run, SparseMemory};
use criterion::Criterion;
use std::fs;

fn interpret_benchmark(c: &mut Criterion) {
    c.bench_function("interpret secp256k1_bench", |b| {
        let buffer = fs::read("benches/data/secp256k1_bench").unwrap().into();
        let args: Vec<Bytes> = vec![
            "secp256k1_bench",
            "033f8cf9c4d51a33206a6c1c6b27d2cc5129daa19dbd1fc148d395284f6b26411f",
            "304402203679d909f43f073c7c1dcf8468a485090589079ee834e6eed92fea9b09b06a2402201e46f1075afa18f306715e7db87493e7b7e779569aa13c64ab3d09980b3560a3",
            "foo",
            "bar"
        ].into_iter().map(|a| a.into()).collect();
        b.iter(|| run::<u64, SparseMemory<u64>>(&buffer, &args[..]).unwrap());
    });
}

#[cfg(has_asm)]
fn asm_benchmark(c: &mut Criterion) {
    c.bench_function("interpret secp256k1_bench via assembly", |b| {
        let buffer = fs::read("benches/data/secp256k1_bench").unwrap().into();
        let args = [
            "secp256k1_bench",
            "033f8cf9c4d51a33206a6c1c6b27d2cc5129daa19dbd1fc148d395284f6b26411f",
            "304402203679d909f43f073c7c1dcf8468a485090589079ee834e6eed92fea9b09b06a2402201e46f1075afa18f306715e7db87493e7b7e779569aa13c64ab3d09980b3560a3",
            "foo",
            "bar",
        ].into_iter().map(|a| Ok(a.into()));
        b.iter(|| {
            let asm_core = AsmCoreMachine::new(ISA_IMC, VERSION0, u64::MAX);
            let core = DefaultMachineBuilder::new(asm_core).build();
            let mut machine = AsmMachine::new(core);
            machine.load_program(&buffer, args.clone()).unwrap();
            machine.run().unwrap()
        });
    });
}

#[cfg(has_asm)]
fn mop_benchmark(c: &mut Criterion) {
    c.bench_function("interpret secp256k1_bench via assembly mop", |b| {
        let buffer = fs::read("benches/data/secp256k1_bench").unwrap().into();
        let args = [
            "secp256k1_bench",
            "033f8cf9c4d51a33206a6c1c6b27d2cc5129daa19dbd1fc148d395284f6b26411f",
            "304402203679d909f43f073c7c1dcf8468a485090589079ee834e6eed92fea9b09b06a2402201e46f1075afa18f306715e7db87493e7b7e779569aa13c64ab3d09980b3560a3",
            "foo",
            "bar",
        ].into_iter().map(|a| Ok(a.into()));
        b.iter(|| {
            let asm_core = AsmCoreMachine::new(ISA_IMC | ISA_B | ISA_MOP, VERSION2, u64::MAX);
            let core = DefaultMachineBuilder::<Box<AsmCoreMachine>>::new(asm_core)
                .build();
            let mut machine = AsmMachine::new(core);
            machine.load_program(&buffer, args.clone()).unwrap();
            machine.run().unwrap()
        });
    });
}

#[cfg(has_asm)]
fn mop_memoized_benchmark(c: &mut Criterion) {
    c.bench_function("interpret secp256k1_bench via assembly mop (memoized decoder)", |b| {
        let isa = ISA_IMC | ISA_B | ISA_MOP;
        let version = VERSION2;
        let buffer = fs::read("benches/data/secp256k1_bench").unwrap().into();
        let args = [
            "secp256k1_bench",
            "033f8cf9c4d51a33206a6c1c6b27d2cc5129daa19dbd1fc148d395284f6b26411f",
            "304402203679d909f43f073c7c1dcf8468a485090589079ee834e6eed92fea9b09b06a2402201e46f1075afa18f306715e7db87493e7b7e779569aa13c64ab3d09980b3560a3",
            "foo",
            "bar",
        ].into_iter().map(|a| Ok(a.into()));
        let mut decoder = MemoizedFixedTraceDecoder::new(build_decoder::<u64>(isa, version));
        let asm_core = AsmCoreMachine::new(isa, version, u64::MAX);
        let core = DefaultMachineBuilder::<Box<AsmCoreMachine>>::new(asm_core)
            .build();
        let mut machine = AsmMachine::new(core);
        machine.load_program(&buffer, args.clone()).unwrap();
        machine.run_with_decoder(&mut decoder).unwrap();

        b.iter(|| {
            let asm_core = AsmCoreMachine::new(isa, version, u64::MAX);
            let core = DefaultMachineBuilder::<Box<AsmCoreMachine>>::new(asm_core)
                .build();
            let mut machine = AsmMachine::new(core);
            machine.load_program(&buffer, args.clone()).unwrap();
            decoder.clear_traces();
            machine.run_with_decoder(&mut decoder).unwrap()
        });
    });
}

#[cfg(has_asm)]
fn mop_memoized_dynamic_benchmark(c: &mut Criterion) {
    c.bench_function("interpret secp256k1_bench via assembly mop (memoized dynamic length decoder)", |b| {
        let isa = ISA_IMC | ISA_B | ISA_MOP;
        let version = VERSION2;
        let buffer = fs::read("benches/data/secp256k1_bench").unwrap().into();
        let args = [
            "secp256k1_bench",
            "033f8cf9c4d51a33206a6c1c6b27d2cc5129daa19dbd1fc148d395284f6b26411f",
            "304402203679d909f43f073c7c1dcf8468a485090589079ee834e6eed92fea9b09b06a2402201e46f1075afa18f306715e7db87493e7b7e779569aa13c64ab3d09980b3560a3",
            "foo",
            "bar",
        ].into_iter().map(|a| Ok(a.into()));
        let mut decoder = MemoizedDynamicTraceDecoder::new(build_decoder::<u64>(isa, version));
        let asm_core = AsmCoreMachine::new(isa, version, u64::MAX);
        let core = DefaultMachineBuilder::<Box<AsmCoreMachine>>::new(asm_core)
            .build();
        let mut machine = AsmMachine::new(core);
        machine.load_program(&buffer, args.clone()).unwrap();
        machine.run_with_decoder(&mut decoder).unwrap();

        b.iter(|| {
            let asm_core = AsmCoreMachine::new(isa, version, u64::MAX);
            let core = DefaultMachineBuilder::<Box<AsmCoreMachine>>::new(asm_core)
                .build();
            let mut machine = AsmMachine::new(core);
            machine.load_program(&buffer, args.clone()).unwrap();
            decoder.clear_traces();
            machine.run_with_decoder(&mut decoder).unwrap()
        });
    });
}

#[cfg(not(has_asm))]
criterion_group!(benches, interpret_benchmark);

#[cfg(has_asm)]
criterion_group!(
    benches,
    interpret_benchmark,
    asm_benchmark,
    mop_benchmark,
    mop_memoized_benchmark,
    mop_memoized_dynamic_benchmark
);
criterion_main!(benches);


================================================
File: definitions/Cargo.toml
================================================
[package]
name = "ckb-vm-definitions"
description = "Common definition files for CKB VM"
version = "0.24.0"
license = "MIT"
authors = ["Nervos Core Dev <dev@nervos.org>"]
edition = "2021"
rust-version = "1.81.0"
autobins = false
homepage = "https://github.com/nervosnetwork/ckb-vm"
repository = "https://github.com/nervosnetwork/ckb-vm"

[features]
enable-chaos-mode-by-default = []

[[bin]]
name = "generate_asm_constants"
path = "src/generate_asm_constants.rs"

[dependencies]
paste = "1.0.12"


================================================
File: definitions/src/asm.rs
================================================
use crate::{
    instructions::Instruction, DEFAULT_MEMORY_SIZE, MEMORY_FRAMESIZE, MEMORY_FRAME_SHIFTS,
    RISCV_GENERAL_REGISTER_NUMBER, RISCV_PAGESIZE,
};
use std::alloc::{alloc, alloc_zeroed, dealloc, Layout};

// The number of trace items to keep
pub const TRACE_SIZE: usize = 8192;
pub const TRACE_ITEM_LENGTH: usize = 16;

pub const RET_DECODE_TRACE: u8 = 1;
pub const RET_ECALL: u8 = 2;
pub const RET_EBREAK: u8 = 3;
pub const RET_DYNAMIC_JUMP: u8 = 4;
pub const RET_MAX_CYCLES_EXCEEDED: u8 = 5;
pub const RET_CYCLES_OVERFLOW: u8 = 6;
pub const RET_OUT_OF_BOUND: u8 = 7;
pub const RET_INVALID_PERMISSION: u8 = 8;
pub const RET_SLOWPATH: u8 = 9;
pub const RET_PAUSE: u8 = 10;

#[inline(always)]
pub fn calculate_slot(addr: u64) -> usize {
    (addr as usize >> 2) & (TRACE_SIZE - 1)
}

#[repr(C)]
#[derive(Clone, Debug)]
pub struct FixedTrace {
    pub address: u64,
    pub length: u32,
    pub cycles: u64,
    // We are using direct threaded code here:
    // https://en.wikipedia.org/wiki/Threaded_code
    // each individual thread is made of 2 consecutive
    // items here: the jumping offset, and the actual decoded
    // instructions. Since we will use both of them as plain
    // u64 values anyway in the assembly code, we cast the
    // Instruction type to u64. A test case will ensure that
    // Instruction type stays the same as u64 type.
    pub _threads: [u64; 2 * (TRACE_ITEM_LENGTH + 1)],
}

impl FixedTrace {
    pub fn thread(&self, idx: usize) -> Option<(Instruction, u64)> {
        if idx < TRACE_ITEM_LENGTH + 1 {
            Some((self._threads[idx * 2 + 1], self._threads[idx * 2]))
        } else {
            None
        }
    }

    pub fn set_thread(&mut self, idx: usize, instruction: Instruction, thread: u64) {
        if idx < TRACE_ITEM_LENGTH + 1 {
            self._threads[idx * 2] = thread;
            self._threads[idx * 2 + 1] = instruction;
        }
    }
}

impl Default for FixedTrace {
    fn default() -> Self {
        FixedTrace {
            address: 0,
            length: 0,
            cycles: 0,
            _threads: [0; 2 * (TRACE_ITEM_LENGTH + 1)],
        }
    }
}

#[repr(C)]
pub struct InvokeData {
    pub pause: *mut u8,
    pub fixed_traces: *const FixedTrace,
    pub fixed_trace_mask: u64,
}

#[repr(C)]
pub struct AsmCoreMachine {
    pub registers: [u64; RISCV_GENERAL_REGISTER_NUMBER],
    pub pc: u64,
    pub next_pc: u64,
    pub running: u8,
    pub cycles: u64,
    pub max_cycles: u64,
    pub chaos_mode: u8,
    pub chaos_seed: u32,
    pub load_reservation_address: u64,
    pub reset_signal: u8,
    pub isa: u8,
    pub version: u32,

    pub error_arg0: u64,

    pub memory_size: u64,
    pub frames_size: u64,
    pub flags_size: u64,

    pub last_read_frame: u64,
    pub last_write_page: u64,

    pub memory_ptr: u64,
    pub flags_ptr: u64,
    pub frames_ptr: u64,
}

impl Drop for AsmCoreMachine {
    fn drop(&mut self) {
        let memory_layout = Layout::array::<u8>(self.memory_size as usize).unwrap();
        unsafe { dealloc(self.memory_ptr as *mut u8, memory_layout) };
        let flags_layout = Layout::array::<u8>(self.flags_size as usize).unwrap();
        unsafe { dealloc(self.flags_ptr as *mut u8, flags_layout) };
        let frames_layout = Layout::array::<u8>(self.frames_size as usize).unwrap();
        unsafe { dealloc(self.frames_ptr as *mut u8, frames_layout) };
    }
}

impl AsmCoreMachine {
    pub fn new(isa: u8, version: u32, max_cycles: u64) -> Box<AsmCoreMachine> {
        Self::new_with_memory(isa, version, max_cycles, DEFAULT_MEMORY_SIZE)
    }

    pub fn new_with_memory(
        isa: u8,
        version: u32,
        max_cycles: u64,
        memory_size: usize,
    ) -> Box<AsmCoreMachine> {
        assert_ne!(memory_size, 0);
        assert_eq!(memory_size % RISCV_PAGESIZE, 0);
        assert_eq!(memory_size % (1 << MEMORY_FRAME_SHIFTS), 0);
        let mut machine = unsafe {
            let layout = Layout::new::<AsmCoreMachine>();
            let raw_allocation = alloc_zeroed(layout) as *mut AsmCoreMachine;
            Box::from_raw(raw_allocation)
        };
        machine.max_cycles = max_cycles;
        if cfg!(feature = "enable-chaos-mode-by-default") {
            machine.chaos_mode = 1;
        }
        machine.load_reservation_address = u64::MAX;
        machine.version = version;
        machine.isa = isa;

        machine.memory_size = memory_size as u64;
        machine.frames_size = (memory_size / MEMORY_FRAMESIZE) as u64;
        machine.flags_size = (memory_size / RISCV_PAGESIZE) as u64;

        machine.last_read_frame = u64::MAX;
        machine.last_write_page = u64::MAX;

        let memory_layout = Layout::array::<u8>(machine.memory_size as usize).unwrap();
        machine.memory_ptr = unsafe { alloc(memory_layout) } as u64;
        let flags_layout = Layout::array::<u8>(machine.flags_size as usize).unwrap();
        machine.flags_ptr = unsafe { alloc_zeroed(flags_layout) } as u64;
        let frames_layout = Layout::array::<u8>(machine.frames_size as usize).unwrap();
        machine.frames_ptr = unsafe { alloc_zeroed(frames_layout) } as u64;

        machine
    }

    pub fn set_max_cycles(&mut self, cycles: u64) {
        self.max_cycles = cycles;
    }
}


================================================
File: definitions/src/generate_asm_constants.rs
================================================
use ckb_vm_definitions::{
    asm::{
        AsmCoreMachine, FixedTrace, InvokeData, RET_CYCLES_OVERFLOW, RET_DECODE_TRACE,
        RET_DYNAMIC_JUMP, RET_EBREAK, RET_ECALL, RET_INVALID_PERMISSION, RET_MAX_CYCLES_EXCEEDED,
        RET_OUT_OF_BOUND, RET_PAUSE, RET_SLOWPATH, TRACE_ITEM_LENGTH,
    },
    for_each_inst,
    instructions::{instruction_opcode_name, MAXIMUM_OPCODE, MINIMAL_OPCODE},
    memory::{FLAG_DIRTY, FLAG_EXECUTABLE, FLAG_FREEZED, FLAG_WRITABLE, FLAG_WXORX_BIT},
    registers::{RA, SP},
    MEMORY_FRAMESIZE, MEMORY_FRAME_PAGE_SHIFTS, MEMORY_FRAME_SHIFTS, RISCV_PAGESIZE,
    RISCV_PAGE_SHIFTS,
};
use std::mem::{size_of, zeroed};

macro_rules! print_inst_label {
    ($name:ident, $real_name:ident, $code:expr) => {
        println!(
            "\t.long\t.CKB_VM_ASM_LABEL_OP_{} - .CKB_VM_ASM_LABEL_TABLE",
            stringify!($real_name)
        );
    };
}

// This utility helps us generate C-based macros containing definitions
// such as return code, opcode, struct size, struct offset, etc. The exact
// data here are derived while inspecting Rust structs dynamically. We keep
// this in a separate crate so build failures from the main crate won't cause
// a problem when updating the definitions with this crate. Or you can think
// of this as a workaround to the problem that build.rs cannot depend on any
// of its crate contents.
fn main() {
    println!("#define CKB_VM_ASM_RISCV_PAGE_SHIFTS {}", RISCV_PAGE_SHIFTS);
    println!("#define CKB_VM_ASM_RISCV_PAGE_SIZE {}", RISCV_PAGESIZE);
    println!("#define CKB_VM_ASM_RISCV_PAGE_MASK {}", RISCV_PAGESIZE - 1);
    println!(
        "#define CKB_VM_ASM_MEMORY_FRAME_SHIFTS {}",
        MEMORY_FRAME_SHIFTS
    );
    println!("#define CKB_VM_ASM_MEMORY_FRAMESIZE {}", MEMORY_FRAMESIZE);
    println!(
        "#define CKB_VM_ASM_MEMORY_FRAME_PAGE_SHIFTS {}",
        MEMORY_FRAME_PAGE_SHIFTS
    );
    println!();

    println!(
        "#define CKB_VM_ASM_MAXIMUM_TRACE_ADDRESS_LENGTH {}",
        TRACE_ITEM_LENGTH * 4
    );
    println!();

    println!("#define CKB_VM_ASM_RET_DECODE_TRACE {}", RET_DECODE_TRACE);
    println!("#define CKB_VM_ASM_RET_ECALL {}", RET_ECALL);
    println!("#define CKB_VM_ASM_RET_EBREAK {}", RET_EBREAK);
    println!("#define CKB_VM_ASM_RET_DYNAMIC_JUMP {}", RET_DYNAMIC_JUMP);
    println!(
        "#define CKB_VM_ASM_RET_MAX_CYCLES_EXCEEDED {}",
        RET_MAX_CYCLES_EXCEEDED
    );
    println!(
        "#define CKB_VM_ASM_RET_CYCLES_OVERFLOW {}",
        RET_CYCLES_OVERFLOW
    );
    println!("#define CKB_VM_ASM_RET_OUT_OF_BOUND {}", RET_OUT_OF_BOUND);
    println!(
        "#define CKB_VM_ASM_RET_INVALID_PERMISSION {}",
        RET_INVALID_PERMISSION
    );
    println!("#define CKB_VM_ASM_RET_SLOWPATH {}", RET_SLOWPATH);
    println!("#define CKB_VM_ASM_RET_PAUSE {}", RET_PAUSE);
    println!();

    println!("#define CKB_VM_ASM_REGISTER_RA {}", RA);
    println!("#define CKB_VM_ASM_REGISTER_SP {}", SP);
    println!();

    println!("#define CKB_VM_ASM_MEMORY_FLAG_FREEZED {}", FLAG_FREEZED);
    println!(
        "#define CKB_VM_ASM_MEMORY_FLAG_EXECUTABLE {}",
        FLAG_EXECUTABLE
    );
    println!(
        "#define CKB_VM_ASM_MEMORY_FLAG_WXORX_BIT {}",
        FLAG_WXORX_BIT
    );
    println!("#define CKB_VM_ASM_MEMORY_FLAG_WRITABLE {}", FLAG_WRITABLE);
    println!("#define CKB_VM_ASM_MEMORY_FLAG_DIRTY {}", FLAG_DIRTY);
    println!();

    println!(
        "#define CKB_VM_ASM_FIXED_TRACE_STRUCT_SIZE {}",
        size_of::<FixedTrace>()
    );

    let t: FixedTrace = unsafe { zeroed() };
    let t_address = &t as *const FixedTrace as usize;
    println!(
        "#define CKB_VM_ASM_TRACE_OFFSET_ADDRESS {}",
        (&t.address as *const u64 as usize) - t_address
    );
    println!(
        "#define CKB_VM_ASM_TRACE_OFFSET_LENGTH {}",
        (&t.length as *const u32 as usize) - t_address
    );
    println!(
        "#define CKB_VM_ASM_TRACE_OFFSET_CYCLES {}",
        (&t.cycles as *const u64 as usize) - t_address
    );
    println!(
        "#define CKB_VM_ASM_TRACE_OFFSET_THREADS {}",
        (&t._threads as *const u64 as usize) - t_address
    );
    println!();

    let i: InvokeData = unsafe { zeroed() };
    let i_address = &i as *const InvokeData as usize;
    println!(
        "#define CKB_VM_ASM_INVOKE_DATA_OFFSET_PAUSE {}",
        (&i.pause as *const _ as usize) - i_address,
    );
    println!(
        "#define CKB_VM_ASM_INVOKE_DATA_OFFSET_FIXED_TRACES {}",
        (&i.fixed_traces as *const _ as usize) - i_address,
    );
    println!(
        "#define CKB_VM_ASM_INVOKE_DATA_OFFSET_FIXED_TRACE_MASK {}",
        (&i.fixed_trace_mask as *const _ as usize) - i_address,
    );
    println!();

    let m: Box<AsmCoreMachine> = AsmCoreMachine::new(0, 0, 0);
    let m_address = &*m as *const AsmCoreMachine as usize;
    println!(
        "#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_REGISTERS {}",
        (&m.registers as *const u64 as usize) - m_address
    );
    println!(
        "#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_PC {}",
        (&m.pc as *const u64 as usize) - m_address
    );
    println!(
        "#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_CYCLES {}",
        (&m.cycles as *const u64 as usize) - m_address
    );
    println!(
        "#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MAX_CYCLES {}",
        (&m.max_cycles as *const u64 as usize) - m_address
    );
    println!(
        "#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_CHAOS_MODE {}",
        (&m.chaos_mode as *const u8 as usize) - m_address
    );
    println!(
        "#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_CHAOS_SEED {}",
        (&m.chaos_seed as *const u32 as usize) - m_address
    );
    println!(
        "#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_LOAD_RESERVATION_ADDRESS {}",
        (&m.load_reservation_address as *const u64 as usize) - m_address
    );
    println!(
        "#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_VERSION {}",
        (&m.version as *const u32 as usize) - m_address
    );
    println!(
        "#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_ERROR_ARG0 {}",
        (&m.error_arg0 as *const u64 as usize) - m_address
    );
    println!(
        "#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_SIZE {}",
        (&m.memory_size as *const u64 as usize) - m_address
    );
    println!(
        "#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_FRAMES_SIZE {}",
        (&m.frames_size as *const u64 as usize) - m_address
    );
    println!(
        "#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_FLAGS_SIZE {}",
        (&m.flags_size as *const u64 as usize) - m_address
    );

    println!(
        "#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_LAST_READ_FRAME {}",
        (&m.last_read_frame as *const u64 as usize) - m_address
    );
    println!(
        "#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_LAST_WRITE_PAGE {}",
        (&m.last_write_page as *const u64 as usize) - m_address
    );
    println!(
        "#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR {}",
        (&m.memory_ptr as *const u64 as usize) - m_address
    );
    println!(
        "#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_FLAGS_PTR {}",
        (&m.flags_ptr as *const u64 as usize) - m_address
    );
    println!(
        "#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_FRAMES_PTR {}",
        (&m.frames_ptr as *const u64 as usize) - m_address
    );
    println!();

    for op in MINIMAL_OPCODE..MAXIMUM_OPCODE {
        println!(
            "#define CKB_VM_ASM_OP_{} {}",
            instruction_opcode_name(op),
            op
        );
    }
    println!();

    println!("#ifdef CKB_VM_ASM_GENERATE_LABEL_TABLES");
    println!("#ifdef __APPLE__");
    println!(".global _ckb_vm_asm_labels");
    println!("_ckb_vm_asm_labels:");
    println!("#else");
    println!(".global ckb_vm_asm_labels");
    println!("ckb_vm_asm_labels:");
    println!("#endif");
    println!(".CKB_VM_ASM_LABEL_TABLE:");
    for _ in 0..0x10 {
        println!("\t.long\t.exit_slowpath - .CKB_VM_ASM_LABEL_TABLE");
    }
    for_each_inst!(print_inst_label);
    println!("#endif /* CKB_VM_ASM_GENERATE_LABEL_TABLES */");
}


================================================
File: definitions/src/instructions.rs
================================================
// For fast decoding and cache friendly, RISC-V instruction is decoded
// into 64 bit unsigned integer in the following format:
//
// +-----+-----+-----+-----+-----+-----+-----+-----+
// |           | rs2 | rs1 | flg | op2 | rd  | op  | R-type
// +-----+-----+-----+-----+-----+-----+-----+-----+
// |     | rs3 | rs2 | rs1 | flg | op2 | rd  | op  | R4-type
// +-----------+-----------------------------------+
// | rs4 | rs3 | rs2 | rs1 | flg | op2 | rd  | op  | R5-type
// +-----------+-----------------------------------+
// |    immediate    | rs1 | flg | op2 | rd  | op  | I-type
// +-----------------------------------------------+
// |    immediate    | rs1 | flg | op2 | rs2 | op  | S-type/B-type
// +-----------------+-----------------------------+
// |       immediate       | flg | op2 | rd  | op  | U-type/J-type
// +-----+-----+-----+-----+-----+-----+-----+-----+
//
// +flg+ here means a combination of flags, Its format is as follows:
//
// +---+---+---+---+---+---+---+---+
// | 7 | 6 | 5 | 4 | length >> 1   |
// +---+---+---+---+---+---+---+---+
//
// This way each op and register index are in full byte, accessing them
// will be much faster than the original compact form. Hence we will have
// a fast path where the interpreter loop reads instruction directly in this
// format, and a slow path where a full featured decoder decodes RISC-V
// instruction into the internal form here(much like how traces/micro-ops work.)
//
// About +op+ and +op2+:
// When the op value is 0x10-0xff, it expresses a first-level instruction under fast
// path, at this time the value of op2 is ignored.
// When the op value is 0x00-0x0f, op and op2 are combined to express a
// second-level instruction under slow path.
//
// Notice that this module now uses macro-based techniques to define opcodes.
// To see a full list of opcodes as plain Rust source code, install
// [cargo-expand](https://github.com/dtolnay/cargo-expand) first, then use the
// following command:
//
// cargo expand --manifest-path=definitions/Cargo.toml --lib instructions
pub type Instruction = u64;

pub type InstructionOpcode = u16;

pub use paste::paste;

#[doc(hidden)]
#[macro_export]
macro_rules! __apply {
    ((0, $callback:ident), $(($name:ident, $code:expr)),*) => {
        $crate::instructions::paste! {
            $(
                $callback!([< OP_ $name >], $name, $code);
            )*
        }
    };
    ((1, $x:ident, $callback:ident), $(($name:ident, $code:expr)),*) => {
        $crate::instructions::paste! {
            $(
                $callback!([< OP_ $name >], $name, $code, $x);
            )*
        }
    };
    ((2, $x:ident, $y:ident, $callback:ident), $(($name:ident, $code:expr)),*) => {
        $crate::instructions::paste! {
            $(
                $callback!([< OP_ $name >], $name, $code, $x, $y);
            )*
        }
    };
    ((100, $res:ident, $val:expr, $callback:ident, $others:expr), $(($name:ident, $code:expr)),*) => {
        $crate::instructions::paste! {
            let $res = match $val {
                $( $code => $callback!([< OP_ $name >], $name, $code), )*
                _ => $others
            };
        }
    };
    ((101, $x:ident, $res:ident, $val:expr, $callback:ident, $others:expr), $(($name:ident, $code:expr)),*) => {
        $crate::instructions::paste! {
            let $res = match $val {
                $( $code => $callback!([< OP_ $name >], $name, $code, $x), )*
                _ => $others
            };
        }
    };
    ((102, $x:ident, $y:ident, $res:ident, $val:expr, $callback:ident, $others:expr), $(($name:ident, $code:expr)),*) => {
        $crate::instructions::paste! {
            let $res = match $val {
                $( $code => $callback!([< OP_ $name >], $name, $code, $x, $y), )*
                _ => $others
            };
        }
    };
    ((200, $res:ident, $callback:ident), $(($name:ident, $code:expr)),*) => {
        $crate::instructions::paste! {
            let $res = [
                $( $callback!([< OP_ $name >], $name, $code), )*
            ];
        }
    };
    ((201, $x:ident, $res:ident, $callback:ident), $(($name:ident, $code:expr)),*) => {
        $crate::instructions::paste! {
            let $res = [
                $( $callback!([< OP_ $name >], $name, $code, $x), )*
            ];
        }
    };
    ((202, $x:ident, $y:ident, $res:ident, $callback:ident), $(($name:ident, $code:expr)),*) => {
        $crate::instructions::paste! {
            let $res = [
                $( $callback!([< OP_ $name >], $name, $code, $x, $y), )*
            ];
        }
    };
}

#[doc(hidden)]
#[macro_export]
macro_rules! __for_each_inst_inner {
    ($callback:tt) => {
        $crate::__apply!(
            $callback,
            // IMC
            (UNLOADED, 0x10),
            (ADD, 0x11),
            (ADDI, 0x12),
            (ADDIW, 0x13),
            (ADDW, 0x14),
            (AND, 0x15),
            (ANDI, 0x16),
            (DIV, 0x17),
            (DIVU, 0x18),
            (DIVUW, 0x19),
            (DIVW, 0x1a),
            (LB_VERSION0, 0x1b),
            (LB_VERSION1, 0x1c),
            (LBU_VERSION0, 0x1d),
            (LBU_VERSION1, 0x1e),
            (LD_VERSION0, 0x1f),
            (LD_VERSION1, 0x20),
            (LH_VERSION0, 0x21),
            (LH_VERSION1, 0x22),
            (LHU_VERSION0, 0x23),
            (LHU_VERSION1, 0x24),
            (LUI, 0x25),
            (LW_VERSION0, 0x26),
            (LW_VERSION1, 0x27),
            (LWU_VERSION0, 0x28),
            (LWU_VERSION1, 0x29),
            (MUL, 0x2a),
            (MULH, 0x2b),
            (MULHSU, 0x2c),
            (MULHU, 0x2d),
            (MULW, 0x2e),
            (OR, 0x2f),
            (ORI, 0x30),
            (REM, 0x31),
            (REMU, 0x32),
            (REMUW, 0x33),
            (REMW, 0x34),
            (SB, 0x35),
            (SD, 0x36),
            (SH, 0x37),
            (SLL, 0x38),
            (SLLI, 0x39),
            (SLLIW, 0x3a),
            (SLLW, 0x3b),
            (SLT, 0x3c),
            (SLTI, 0x3d),
            (SLTIU, 0x3e),
            (SLTU, 0x3f),
            (SRA, 0x40),
            (SRAI, 0x41),
            (SRAIW, 0x42),
            (SRAW, 0x43),
            (SRL, 0x44),
            (SRLI, 0x45),
            (SRLIW, 0x46),
            (SRLW, 0x47),
            (SUB, 0x48),
            (SUBW, 0x49),
            (SW, 0x4a),
            (XOR, 0x4b),
            (XORI, 0x4c),
            // A
            (LR_W, 0x4d),
            (SC_W, 0x4e),
            (AMOSWAP_W, 0x4f),
            (AMOADD_W, 0x50),
            (AMOXOR_W, 0x51),
            (AMOAND_W, 0x52),
            (AMOOR_W, 0x53),
            (AMOMIN_W, 0x54),
            (AMOMAX_W, 0x55),
            (AMOMINU_W, 0x56),
            (AMOMAXU_W, 0x57),
            (LR_D, 0x58),
            (SC_D, 0x59),
            (AMOSWAP_D, 0x5a),
            (AMOADD_D, 0x5b),
            (AMOXOR_D, 0x5c),
            (AMOAND_D, 0x5d),
            (AMOOR_D, 0x5e),
            (AMOMIN_D, 0x5f),
            (AMOMAX_D, 0x60),
            (AMOMINU_D, 0x61),
            (AMOMAXU_D, 0x62),
            // B
            (ADDUW, 0x63),
            (ANDN, 0x64),
            (BCLR, 0x65),
            (BCLRI, 0x66),
            (BEXT, 0x67),
            (BEXTI, 0x68),
            (BINV, 0x69),
            (BINVI, 0x6a),
            (BSET, 0x6b),
            (BSETI, 0x6c),
            (CLMUL, 0x6d),
            (CLMULH, 0x6e),
            (CLMULR, 0x6f),
            (CLZ, 0x70),
            (CLZW, 0x71),
            (CPOP, 0x72),
            (CPOPW, 0x73),
            (CTZ, 0x74),
            (CTZW, 0x75),
            (MAX, 0x76),
            (MAXU, 0x77),
            (MIN, 0x78),
            (MINU, 0x79),
            (ORCB, 0x7a),
            (ORN, 0x7b),
            (REV8, 0x7c),
            (ROL, 0x7d),
            (ROLW, 0x7e),
            (ROR, 0x7f),
            (RORI, 0x80),
            (RORIW, 0x81),
            (RORW, 0x82),
            (SEXTB, 0x83),
            (SEXTH, 0x84),
            (SH1ADD, 0x85),
            (SH1ADDUW, 0x86),
            (SH2ADD, 0x87),
            (SH2ADDUW, 0x88),
            (SH3ADD, 0x89),
            (SH3ADDUW, 0x8a),
            (SLLIUW, 0x8b),
            (XNOR, 0x8c),
            (ZEXTH, 0x8d),
            // Mop
            (WIDE_MUL, 0x8e),
            (WIDE_MULU, 0x8f),
            (WIDE_MULSU, 0x90),
            (WIDE_DIV, 0x91),
            (WIDE_DIVU, 0x92),
            (ADC, 0x93),
            (SBB, 0x94),
            (ADCS, 0x95),
            (SBBS, 0x96),
            (ADD3A, 0x97),
            (ADD3B, 0x98),
            (ADD3C, 0x99),
            (CUSTOM_LOAD_UIMM, 0x9a),
            (CUSTOM_LOAD_IMM, 0x9b),
            // All branches
            (AUIPC, 0x9c),
            (BEQ, 0x9d),
            (BGE, 0x9e),
            (BGEU, 0x9f),
            (BLT, 0xa0),
            (BLTU, 0xa1),
            (BNE, 0xa2),
            (EBREAK, 0xa3),
            (ECALL, 0xa4),
            (FENCE, 0xa5),
            (FENCEI, 0xa6),
            (JAL, 0xa7),
            (JALR_VERSION0, 0xa8),
            (JALR_VERSION1, 0xa9),
            (FAR_JUMP_REL, 0xaa),
            (FAR_JUMP_ABS, 0xab),
            (CUSTOM_ASM_TRACE_JUMP, 0xac),
            (CUSTOM_TRACE_END, 0xad)
        );
    };
}

/// Generates a possible definition for each instruction, it leverages
/// a callback macro that takes (at least) 3 arguments:
///
/// 1. $name: an identifier containing the full defined opcode name,
///     e.g., OP_ADD
/// 2. $real_name: an identifier containing just the opcode part, e.g., ADD
/// 3. $code: an expr containing the actual opcode number
///
/// Free variables are attached to the variants ending with inst1, inst2, etc.
/// Those free variables will also be appended as arguments to the callback macro.
#[macro_export]
macro_rules! for_each_inst {
    ($callback:ident) => {
        $crate::__for_each_inst_inner!((0, $callback));
    };
}

#[macro_export]
macro_rules! for_each_inst1 {
    ($callback:ident, $x:ident) => {
        $crate::__for_each_inst_inner!((1, $x, $callback));
    };
}

#[macro_export]
macro_rules! for_each_inst2 {
    ($callback:ident, $x:ident, $y:ident) => {
        $crate::__for_each_inst_inner!((2, $x, $y, $callback));
    };
}

/// Generates a match expression containing all instructions, it takes 3
/// arguments:
///
/// * A callback macro that takes the exact same arguments as callback
///     macro in +for_each_inst+
/// * A value expression containing the actual value to match against.
/// * An expression used as wildcard matches when the passed value does
///     not match any opcode
///
/// * Free variables are attached to the variants ending with match1, match2, etc.
#[macro_export]
macro_rules! for_each_inst_match {
    ($callback:ident, $val:expr, $others:expr) => {{
        $crate::__for_each_inst_inner!((100, __res__, $val, $callback, $others));
        __res__
    }};
}

#[macro_export]
macro_rules! for_each_inst_match1 {
    ($callback:ident, $val:expr, $others:expr, $x:ident) => {{
        $crate::__for_each_inst_inner!((101, $x, __res__, $val, $callback, $others));
        __res__
    }};
}

#[macro_export]
macro_rules! for_each_inst_match2 {
    ($callback:ident, $val:expr, $others:expr, $x:ident, $y:ident) => {{
        $crate::__for_each_inst_inner!((102, $x, $y, __res__, $val, $callback, $others));
        __res__
    }};
}

/// Generates an array on all instructions
///
/// * A callback macro that takes the exact same arguments as callback
///     macro in +for_each_inst+
///
/// * Free variables are attached to the variants ending with fold1, fold2, etc.
#[macro_export]
macro_rules! for_each_inst_array {
    ($callback:ident) => {{
        $crate::__for_each_inst_inner!((200, __res__, $callback));
        __res__
    }};
}

#[macro_export]
macro_rules! for_each_inst_array1 {
    ($callback:ident, $x:ident) => {{
        $crate::__for_each_inst_inner!((201, $x, __res__, $callback));
        __res__
    }};
}

#[macro_export]
macro_rules! for_each_inst_array2 {
    ($callback:ident, $x:ident, $y:ident) => {{
        $crate::__for_each_inst_inner!((202, $x, $y, __res__, $callback));
        __res__
    }};
}

// Define the actual opcodes
macro_rules! define_instruction {
    ($name:ident, $real_name:ident, $code:expr) => {
        pub const $name: InstructionOpcode = $code;
    };
}
for_each_inst!(define_instruction);

pub const MINIMAL_OPCODE: InstructionOpcode = OP_UNLOADED;
pub const MAXIMUM_OPCODE: InstructionOpcode = OP_CUSTOM_TRACE_END;

pub const MINIMAL_BASIC_BLOCK_END_OPCODE: InstructionOpcode = OP_AUIPC;
pub const MAXIMUM_BASIC_BLOCK_END_OPCODE: InstructionOpcode = OP_FAR_JUMP_ABS;

macro_rules! inst_real_name {
    ($name:ident, $real_name:ident, $code:expr) => {
        stringify!($real_name)
    };
}

pub fn instruction_opcode_name(i: InstructionOpcode) -> &'static str {
    for_each_inst_match!(inst_real_name, i, "UNKNOWN_INSTRUCTION!")
}


================================================
File: definitions/src/lib.rs
================================================
pub mod asm;
pub mod instructions;
pub mod memory;
pub mod registers;

pub const RISCV_PAGE_SHIFTS: usize = 12;
pub const RISCV_PAGESIZE: usize = 1 << RISCV_PAGE_SHIFTS;
pub const RISCV_GENERAL_REGISTER_NUMBER: usize = 32;
pub const MEMORY_FRAME_SHIFTS: usize = 18;
pub const MEMORY_FRAMESIZE: usize = 1 << MEMORY_FRAME_SHIFTS; // 256 KB
pub const MEMORY_FRAME_PAGE_SHIFTS: usize = MEMORY_FRAME_SHIFTS - RISCV_PAGE_SHIFTS;

pub const DEFAULT_MEMORY_SIZE: usize = 4 << 20; // 4 MB

pub const ISA_IMC: u8 = 0b0000_0000;
pub const ISA_B: u8 = 0b0000_0001;
pub const ISA_MOP: u8 = 0b0000_0010;
// Extension ISA_A is not enabled in ckb 2nd hardfork(aka, meepo hardfork)
pub const ISA_A: u8 = 0b0000_0100;


================================================
File: definitions/src/memory.rs
================================================
pub const FLAG_FREEZED: u8 = 0b01;
// CKB VM enforces W^X logic, if this flag is set, current memory page will
// be marked as executable, otherwise the page will be writable.
pub const FLAG_EXECUTABLE: u8 = 0b10;
pub const FLAG_WXORX_BIT: u8 = 0b10;
pub const FLAG_WRITABLE: u8 = (!FLAG_EXECUTABLE) & FLAG_WXORX_BIT;
pub const FLAG_DIRTY: u8 = 0b100;


================================================
File: definitions/src/registers.rs
================================================
// Register ABI names
pub const ZERO: usize = 0;
pub const RA: usize = 1;
pub const SP: usize = 2;
pub const GP: usize = 3;
pub const FP: usize = 8;
pub const TP: usize = 4;
pub const T0: usize = 5;
pub const T1: usize = 6;
pub const T2: usize = 7;
pub const T3: usize = 28;
pub const T4: usize = 29;
pub const T5: usize = 30;
pub const T6: usize = 31;
pub const S0: usize = 8;
pub const S1: usize = 9;
pub const S2: usize = 18;
pub const S3: usize = 19;
pub const S4: usize = 20;
pub const S5: usize = 21;
pub const S6: usize = 22;
pub const S7: usize = 23;
pub const S8: usize = 24;
pub const S9: usize = 25;
pub const S10: usize = 26;
pub const S11: usize = 27;
pub const A0: usize = 10;
pub const A1: usize = 11;
pub const A2: usize = 12;
pub const A3: usize = 13;
pub const A4: usize = 14;
pub const A5: usize = 15;
pub const A6: usize = 16;
pub const A7: usize = 17;

// Register ABI names
#[rustfmt::skip]
pub const REGISTER_ABI_NAMES: [&str; 32] = [
    "zero", "ra", "sp", "gp",
    "tp", "t0", "t1", "t2",
    "s0", "s1", "a0", "a1",
    "a2", "a3", "a4", "a5",
    "a6", "a7", "s2", "s3",
    "s4", "s5", "s6", "s7",
    "s8", "s9", "s10", "s11",
    "t3", "t4", "t5", "t6",
];


================================================
File: examples/check_real_memory.rs
================================================
// This example is mainly to test whether there is memory overflow.
// Under linux, we choose to use smem, which can monitor memory changes more accurately

use ckb_vm::{run_with_memory, Bytes, FlatMemory, SparseMemory};
use std::process::{id, Command};

#[cfg(has_asm)]
use ckb_vm::{
    machine::{
        asm::{AsmCoreMachine, AsmMachine},
        DefaultMachineBuilder, VERSION0,
    },
    ISA_IMC,
};

#[cfg(has_asm)]
use std::thread;

static BIN_PATH_BUFFER: &'static [u8] = include_bytes!("../tests/programs/alloc_many");
static BIN_NAME: &str = "alloc_many";

#[cfg(not(target_os = "windows"))]
#[global_allocator]
static GLOBAL: jemallocator::Jemalloc = jemallocator::Jemalloc;

static G_CHECK_LOOP: usize = 10;

fn get_current_memory_linux() -> usize {
    let output = String::from_utf8(
        Command::new("smem")
            .arg("-P")
            .arg("check_real_memory")   // current process name
            .arg("-c")
            .arg("pid uss")
            .output()
            .expect("run ps failed")
            .stdout,
    )
    .unwrap();

    let outputs = output.split("\n").collect::<Vec<&str>>();
    for i in 1..outputs.len() {
        let mut has_pid = false;
        let mut memory_size: u32 = 0;
        for d in outputs[i].split(" ").collect::<Vec<&str>>() {
            if d == " " || d == "" {
                continue;
            }
            let val: u32 = d.parse().unwrap();
            if !has_pid {
                if val != id() {
                    continue;
                }
                has_pid = true;
            } else {
                memory_size = val;
            }
        }
        if memory_size != 0 {
            return memory_size as usize;
        }
    }

    0
}

fn get_current_memory() -> usize {
    if !cfg!(target_os = "linux") {
        get_current_memory_linux()
    } else {
        let pid = format!("{}", id());
        let output = String::from_utf8(
            Command::new("ps")
                .arg("-p")
                .arg(pid)
                .arg("-o")
                .arg("rss")
                .output()
                .expect("run ps failed")
                .stdout,
        )
        .unwrap();

        let output = output.split("\n").collect::<Vec<&str>>();

        let memory_size = output[1].replace(" ", "");
        memory_size.parse().unwrap()
    }
}

struct MemoryOverflow {
    #[cfg(not(target_os = "windows"))]
    base_allocated: usize,

    #[cfg(not(target_os = "windows"))]
    base_resident: usize,
}

impl MemoryOverflow {
    pub fn new() -> Self {
        Self {
            #[cfg(not(target_os = "windows"))]
            base_allocated: jemalloc_ctl::stats::allocated::read().unwrap(),

            #[cfg(not(target_os = "windows"))]
            base_resident: jemalloc_ctl::stats::resident::read().unwrap(),
        }
    }

    pub fn check(&self) {
        #[cfg(not(target_os = "windows"))]
        assert!(jemalloc_ctl::stats::allocated::read().unwrap() <= self.base_allocated);

        #[cfg(not(target_os = "windows"))]
        assert!(jemalloc_ctl::stats::resident::read().unwrap() <= self.base_resident);
    }
}

fn check_interpreter(memory_size: usize) -> Result<(), ()> {
    println!(
        "Check interpreter memory overflow, ckb-vm memory size: {}",
        memory_size
    );
    println!("Base memory: {}", get_current_memory());
    for _ in 0..G_CHECK_LOOP {
        let result = run_with_memory::<u64, SparseMemory<u64>>(
            &Bytes::from(BIN_PATH_BUFFER),
            &vec![Bytes::from(BIN_NAME)],
            SparseMemory::new_with_memory(memory_size),
        );
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), 0);
        println!("Current memory: {}", get_current_memory());
    }
    println!("End of check");
    Ok(())
}

fn check_falt(memory_size: usize) -> Result<(), ()> {
    println!(
        "Check falt memory overflow, ckb-vm memory size: {}",
        memory_size
    );
    println!("Base memory: {}", get_current_memory());
    for _ in 0..G_CHECK_LOOP {
        let result = run_with_memory::<u64, FlatMemory<u64>>(
            &Bytes::from(BIN_PATH_BUFFER),
            &vec![Bytes::from(BIN_NAME)],
            FlatMemory::new_with_memory(memory_size),
        );
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), 0);
        println!("Current memory: {}", get_current_memory());
    }
    println!("End of check");
    Ok(())
}

#[cfg(has_asm)]
fn check_asm(memory_size: usize) -> Result<(), ()> {
    println!(
        "Check asm memory overflow, ckb-vm memory size: {}",
        memory_size
    );
    println!("Base memory: {}", get_current_memory());
    for _ in 0..G_CHECK_LOOP {
        let asm_core = AsmCoreMachine::new_with_memory(ISA_IMC, VERSION0, u64::MAX, memory_size);
        let core = DefaultMachineBuilder::new(asm_core).build();
        let mut machine = AsmMachine::new(core);
        machine
            .load_program(
                &Bytes::from(BIN_PATH_BUFFER),
                [Ok(Bytes::from(BIN_NAME))].into_iter(),
            )
            .unwrap();
        let result = machine.run();
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), 0);

        println!("Current memory: {}", get_current_memory());
    }
    println!("End of check");
    Ok(())
}

#[cfg(has_asm)]
fn check_asm_in_thread(memory_size: usize) -> Result<(), ()> {
    println!(
        "Check asm in thread memory overflow, ckb-vm memory size: {}",
        memory_size
    );
    println!("Base memory: {}", get_current_memory());
    for _ in 0..G_CHECK_LOOP {
        let asm_core = AsmCoreMachine::new_with_memory(ISA_IMC, VERSION0, u64::MAX, memory_size);
        let core = DefaultMachineBuilder::new(asm_core).build();
        let mut machine = AsmMachine::new(core);
        machine
            .load_program(
                &Bytes::from(BIN_PATH_BUFFER),
                [Ok(Bytes::from(BIN_NAME))].into_iter(),
            )
            .unwrap();
        let thread_join_handle = thread::spawn(move || {
            let result = machine.run();
            assert!(result.is_ok());
            assert_eq!(result.unwrap(), 0);
        });
        thread_join_handle.join().unwrap();
        println!("Current memory: {}", get_current_memory());
    }
    println!("End of check");
    Ok(())
}

fn test_memory(memory_size: usize) -> Result<(), ()> {
    if check_interpreter(memory_size).is_err() {
        return Err(());
    }
    if check_falt(memory_size).is_err() {
        return Err(());
    }

    #[cfg(has_asm)]
    if check_asm(memory_size).is_err() {
        return Err(());
    }

    #[cfg(has_asm)]
    if check_asm_in_thread(memory_size).is_err() {
        return Err(());
    }
    Ok(())
}

fn main() {
    #[cfg(not(target_os = "windows"))]
    jemalloc_ctl::epoch::advance().unwrap();

    let memory_overflow = MemoryOverflow::new();

    let memory_size = 1024 * 1024 * 4;
    if test_memory(memory_size).is_err() {
        panic!("run testcase failed");
    }

    memory_overflow.check();

    let memory_size = 1024 * 1024 * 2;
    if test_memory(memory_size).is_err() {
        panic!("run testcase failed");
    }

    memory_overflow.check();
}


================================================
File: examples/ckb_vm_runner.rs
================================================
use ckb_vm::cost_model::estimate_cycles;
use ckb_vm::registers::{A0, A7};
use ckb_vm::{Bytes, CoreMachine, Memory, Register, SupportMachine, Syscalls};

pub struct DebugSyscall {}

impl<Mac: SupportMachine> Syscalls<Mac> for DebugSyscall {
    fn initialize(&mut self, _machine: &mut Mac) -> Result<(), ckb_vm::error::Error> {
        Ok(())
    }

    fn ecall(&mut self, machine: &mut Mac) -> Result<bool, ckb_vm::error::Error> {
        let code = &machine.registers()[A7];
        if code.to_i32() != 2177 {
            return Ok(false);
        }

        let mut addr = machine.registers()[A0].to_u64();
        let mut buffer = Vec::new();

        loop {
            let byte = machine
                .memory_mut()
                .load8(&Mac::REG::from_u64(addr))?
                .to_u8();
            if byte == 0 {
                break;
            }
            buffer.push(byte);
            addr += 1;
        }

        let s = String::from_utf8(buffer).unwrap();
        println!("{:?}", s);

        Ok(true)
    }
}

#[cfg(has_asm)]
fn main_asm(code: Bytes, args: Vec<Bytes>) -> Result<(), Box<dyn std::error::Error>> {
    let asm_core = ckb_vm::machine::asm::AsmCoreMachine::new(
        ckb_vm::ISA_IMC | ckb_vm::ISA_B | ckb_vm::ISA_MOP,
        ckb_vm::machine::VERSION2,
        u64::MAX,
    );
    let core = ckb_vm::DefaultMachineBuilder::new(asm_core)
        .instruction_cycle_func(Box::new(estimate_cycles))
        .syscall(Box::new(DebugSyscall {}))
        .build();
    let mut machine = ckb_vm::machine::asm::AsmMachine::new(core);
    machine.load_program(&code, args.into_iter().map(Ok))?;
    let exit = machine.run();
    let cycles = machine.machine.cycles();
    println!(
        "asm exit={:?} cycles={:?} r[a1]={:?}",
        exit,
        cycles,
        machine.machine.registers()[ckb_vm::registers::A1]
    );
    std::process::exit(exit? as i32);
}

#[cfg(not(has_asm))]
fn main_int(code: Bytes, args: Vec<Bytes>) -> Result<(), Box<dyn std::error::Error>> {
    let core_machine = ckb_vm::DefaultCoreMachine::<u64, ckb_vm::SparseMemory<u64>>::new(
        ckb_vm::ISA_IMC | ckb_vm::ISA_B | ckb_vm::ISA_MOP,
        ckb_vm::machine::VERSION2,
        u64::MAX,
    );
    let machine_builder = ckb_vm::DefaultMachineBuilder::new(core_machine)
        .instruction_cycle_func(Box::new(estimate_cycles));
    let mut machine = machine_builder.syscall(Box::new(DebugSyscall {})).build();
    machine.load_program(&code, args.into_iter().map(Ok))?;
    let exit = machine.run();
    let cycles = machine.cycles();
    println!(
        "int exit={:?} cycles={:?} r[a1]={:?}",
        exit,
        cycles,
        machine.registers()[ckb_vm::registers::A1]
    );
    std::process::exit(exit? as i32);
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args: Vec<String> = std::env::args().collect();
    let code = std::fs::read(&args[1])?.into();
    let riscv_args: Vec<Bytes> = if args.len() > 2 {
        (&args[2..]).into_iter().map(|s| s.clone().into()).collect()
    } else {
        Vec::new()
    };
    #[cfg(has_asm)]
    main_asm(code, riscv_args)?;
    #[cfg(not(has_asm))]
    main_int(code, riscv_args)?;
    Ok(())
}


================================================
File: examples/is13.c
================================================
#include <string.h>

int is13(char* data) {
    if (strcmp(data, "13") == 0) {
        return 0;
    }
    if (strcmp(data, "0xd") == 0) {
        return 0;
    }
    if (strcmp(data, "0o15") == 0) {
        return 0;
    }
    if (strcmp(data, "0b1101") == 0) {
        return 0;
    }
    return 1;
}

int main(int argc, char* argv[]) {
    if (argc == 1) {
        return 1;
    }
    return is13(argv[1]);
}



================================================
File: examples/is13.rs
================================================
// Example "is-thirteen" is a useless(almost) program for just checking if a number is equal to 13.
//
// But it's also important because it shows how to compile a program from C source code and then run
// it by ckb-vm. So, Let's start.
//
// To build the "is13.c" to riscv output, you will need to install "riscv-gnu-toolchain" in your system.
//
//   $ git clone --recursive https://github.com/riscv/riscv-gnu-toolchain
//   $ cd riscv-gnu-toolchain
//   $ mkdir build && cd build
//   $ ../configure --prefix=/opt/riscv --with-arch=rv64imac
//   $ make
//
// On my ubuntu machine, it takes 1 hours. Sad.
//
// Then, you can build "is13.c" by "riscv64-unknown-elf-gcc"
//
//   $ riscv64-unknown-elf-gcc -o is13 is13.c
//
// Where can you find the "riscv64-unknown-elf-gcc", depending on the previous "../configure --prefix=xxxx"
//
// Now, you have the "is13" binary! Copy the file to this directory, call it by ckb-vm, as shown in the Rust
// code below. And feel free to run this example by command "cargo":
//
//     $ cargo run --example is13 13
//  or $ cargo run --example is13 0xd
//  or $ cargo run --example is13 HELLO
use bytes::Bytes;
use std::io::Read;

fn main() {
    let args: Vec<Bytes> = std::env::args().map(|a| a.into()).collect();

    let mut file = std::fs::File::open("examples/is13").unwrap();
    let mut buffer = Vec::new();
    file.read_to_end(&mut buffer).unwrap();
    let buffer = Bytes::from(buffer);

    let r = ckb_vm::run::<u64, ckb_vm::SparseMemory<u64>>(&buffer, &args[..]).unwrap();
    match r {
        1 => println!("{:?} is not thirteen", args[1]),
        0 => println!("{:?} is thirteen", args[1]),
        _ => panic!(""),
    }
}


================================================
File: fuzz/Cargo.toml
================================================
[package]
name = "ckb-vm-fuzz"
version = "0.1.0"
authors = ["Nervos Core Dev <dev@nervos.org>"]
publish = false
edition = "2018"

[package.metadata]
cargo-fuzz = true

[dependencies]
libfuzzer-sys = "0.4"
spike-sys = "0.1.2"
ckb-vm = { path = "..", features = ["asm"] }
ckb-vm-definitions = { path = "../definitions" }

# Prevent this from interfering with workspaces
[workspace]
members = ["."]

[[bin]]
name = "asm"
path = "fuzz_targets/asm.rs"
test = false
doc = false

[[bin]]
name = "interpreter"
path = "fuzz_targets/interpreter.rs"
test = false
doc = false

[[bin]]
name = "isa_a"
path = "fuzz_targets/isa_a.rs"
test = false
doc = false

[[bin]]
name = "isa_b"
path = "fuzz_targets/isa_b.rs"
test = false
doc = false

[[bin]]
name = "snapshot"
path = "fuzz_targets/snapshot.rs"
test = false
doc = false

[[bin]]
name = "snapshot2"
path = "fuzz_targets/snapshot2.rs"
test = false
doc = false


================================================
File: fuzz/.gitignore
================================================
target
corpus
artifacts


================================================
File: fuzz/fuzz_targets/asm.rs
================================================
#![no_main]
use ckb_vm::cost_model::constant_cycles;
use ckb_vm::machine::asm::{AsmCoreMachine, AsmMachine};
use ckb_vm::machine::trace::TraceMachine;
use ckb_vm::machine::{DefaultCoreMachine, DefaultMachineBuilder, SupportMachine, VERSION2};
use ckb_vm::memory::sparse::SparseMemory;
use ckb_vm::memory::wxorx::WXorXMemory;
use ckb_vm::{Bytes, Error, ISA_A, ISA_B, ISA_IMC, ISA_MOP};
use libfuzzer_sys::fuzz_target;

fn run_asm(data: &[u8]) -> Result<(i8, u64), Error> {
    let asm_core = AsmCoreMachine::new(ISA_IMC | ISA_A | ISA_B | ISA_MOP, VERSION2, 200_000);
    let core = DefaultMachineBuilder::<Box<AsmCoreMachine>>::new(asm_core)
        .instruction_cycle_func(Box::new(constant_cycles))
        .build();
    let mut machine = AsmMachine::new(core);
    let program = Bytes::copy_from_slice(data);
    machine.load_program(&program, vec![].into_iter())?;
    let exit_code = machine.run()?;
    let cycles = machine.machine.cycles();
    Ok((exit_code, cycles))
}

fn run_int(data: &[u8]) -> Result<(i8, u64), Error> {
    let machine_memory = WXorXMemory::new(SparseMemory::<u64>::default());
    let machine_core = DefaultCoreMachine::new_with_memory(
        ISA_IMC | ISA_A | ISA_B | ISA_MOP,
        VERSION2,
        200_000,
        machine_memory,
    );
    let mut machine = TraceMachine::new(
        DefaultMachineBuilder::new(machine_core)
            .instruction_cycle_func(Box::new(constant_cycles))
            .build(),
    );
    let program = Bytes::copy_from_slice(data);
    machine.load_program(&program, vec![].into_iter())?;
    let exit_code = machine.run()?;
    let cycles = machine.machine.cycles();
    Ok((exit_code, cycles))
}

fuzz_target!(|data: &[u8]| {
    let r0 = run_asm(data);
    let r1 = run_asm(data);
    let r2 = run_asm(data);
    let r3 = run_int(data);
    assert_eq!(r0, r1);
    assert_eq!(r1, r2);
    if r2.is_ok() {
        assert_eq!(r2.unwrap(), r3.unwrap());
    } else {
        assert!(r3.is_err())
    }
});


================================================
File: fuzz/fuzz_targets/interpreter.rs
================================================
#![no_main]
use ckb_vm::cost_model::constant_cycles;
use ckb_vm::machine::trace::TraceMachine;
use ckb_vm::machine::{DefaultCoreMachine, DefaultMachineBuilder, SupportMachine, VERSION2};
use ckb_vm::memory::sparse::SparseMemory;
use ckb_vm::memory::wxorx::WXorXMemory;
use ckb_vm::{Bytes, Error, ISA_A, ISA_B, ISA_IMC, ISA_MOP};
use libfuzzer_sys::fuzz_target;

fn run(data: &[u8]) -> Result<(i8, u64), Error> {
    let machine_memory = WXorXMemory::new(SparseMemory::<u64>::default());
    let machine_core = DefaultCoreMachine::new_with_memory(
        ISA_IMC | ISA_A | ISA_B | ISA_MOP,
        VERSION2,
        200_000,
        machine_memory,
    );
    let mut machine = TraceMachine::new(
        DefaultMachineBuilder::new(machine_core)
            .instruction_cycle_func(Box::new(constant_cycles))
            .build(),
    );
    let program = Bytes::copy_from_slice(data);
    machine.load_program(&program, vec![].into_iter())?;
    let exit_code = machine.run()?;
    let cycles = machine.machine.cycles();
    Ok((exit_code, cycles))
}

fuzz_target!(|data: &[u8]| {
    let r0 = run(data);
    let r1 = run(data);
    let r2 = run(data);
    assert_eq!(r0, r1);
    assert_eq!(r1, r2);
});


================================================
File: fuzz/fuzz_targets/isa_a.rs
================================================
#![no_main]
use ckb_vm::{CoreMachine, Memory};
use libfuzzer_sys::fuzz_target;
use spike_sys::Spike;
use std::collections::VecDeque;

struct Deque {
    n: VecDeque<u8>,
}

impl Deque {
    fn new(data: [u8; 512]) -> Self {
        Self {
            n: VecDeque::from(data),
        }
    }

    fn u8(&mut self) -> u8 {
        let r = self.n.pop_front().unwrap();
        self.n.push_back(r);
        r
    }

    fn u64(&mut self) -> u64 {
        let mut r = [0u8; 8];
        r.fill_with(|| self.u8());
        u64::from_le_bytes(r)
    }
}

fuzz_target!(|data: [u8; 512]| {
    let mut deque = Deque::new(data);
    let spike = Spike::new(4 * 1024 * 1024 - 4096);
    let ckb_vm_isa = ckb_vm::ISA_IMC | ckb_vm::ISA_A | ckb_vm::ISA_B;
    let ckb_vm_version = ckb_vm::machine::VERSION2;
    let mut ckb_vm_int =
        ckb_vm::DefaultMachineBuilder::new(ckb_vm::DefaultCoreMachine::<
            u64,
            ckb_vm::SparseMemory<u64>,
        >::new(ckb_vm_isa, ckb_vm_version, u64::MAX))
        .build();
    let mut ckb_vm_asm = ckb_vm::DefaultMachineBuilder::new(
        ckb_vm::machine::asm::AsmCoreMachine::new(ckb_vm_isa, ckb_vm_version, u64::MAX),
    )
    .build();
    let insts: [u32; 18] = [
        0b00001_00_00000_00000_010_00000_0101111, // AMOSWAP.W
        0b00000_00_00000_00000_010_00000_0101111, // AMOADD.W
        0b00100_00_00000_00000_010_00000_0101111, // AMOXOR.W
        0b01100_00_00000_00000_010_00000_0101111, // AMOAND.W
        0b01000_00_00000_00000_010_00000_0101111, // AMOOR.W
        0b10000_00_00000_00000_010_00000_0101111, // AMOMIN.W
        0b10100_00_00000_00000_010_00000_0101111, // AMOMAX.W
        0b11000_00_00000_00000_010_00000_0101111, // AMOMINU.W
        0b11100_00_00000_00000_010_00000_0101111, // AMOMAXU.W
        0b00001_00_00000_00000_011_00000_0101111, // AMOSWAP.D
        0b00000_00_00000_00000_011_00000_0101111, // AMOADD.D
        0b00100_00_00000_00000_011_00000_0101111, // AMOXOR.D
        0b01100_00_00000_00000_011_00000_0101111, // AMOAND.D
        0b01000_00_00000_00000_011_00000_0101111, // AMOOR.D
        0b10000_00_00000_00000_011_00000_0101111, // AMOMIN.D
        0b10100_00_00000_00000_011_00000_0101111, // AMOMAX.D
        0b11000_00_00000_00000_011_00000_0101111, // AMOMINU.D
        0b11100_00_00000_00000_011_00000_0101111, // AMOMAXU.D
    ];

    for _ in 0..1024 {
        let inst = insts[deque.u8() as usize % insts.len()];
        let rs1 = deque.u8() as usize % 31 + 1;
        let rs2 = deque.u8() as usize % 31 + 1;
        let rs2_data = deque.u64();
        let rd = deque.u8() as usize % 32;

        spike.set_reg(rs1 as u64, 0x4000).unwrap();
        ckb_vm_int.set_register(rs1, 0x4000);
        ckb_vm_asm.set_register(rs1, 0x4000);

        if rs2 != rs1 {
            spike.set_reg(rs2 as u64, rs2_data).unwrap();
            ckb_vm_int.set_register(rs2, rs2_data);
            ckb_vm_asm.set_register(rs2, rs2_data);
        }

        let inst = inst | ((rs1 as u32) << 15) | ((rs2 as u32) << 20) | ((rd as u32) << 7);
        let insn = ckb_vm::instructions::a::factory::<u64>(inst, ckb_vm_version).unwrap();

        spike.execute(inst as u64).unwrap();
        ckb_vm::instructions::execute_instruction(insn, &mut ckb_vm_int).unwrap();
        ckb_vm::instructions::execute_instruction(insn, &mut ckb_vm_asm).unwrap();

        let spike_reg = spike.get_reg(rd as u64).unwrap();
        let ckb_vm_int_reg = ckb_vm_int.registers()[rd];
        let ckb_vm_asm_reg = ckb_vm_asm.registers()[rd];
        assert_eq!(spike_reg, ckb_vm_int_reg);
        assert_eq!(spike_reg, ckb_vm_asm_reg);

        let mut spike_mem = [0u8; 8];
        spike.ld(0x4000, 8, spike_mem.as_mut_ptr()).unwrap();
        let ckb_vm_int_mem = ckb_vm_int.memory_mut().load64(&0x4000).unwrap();
        assert_eq!(u64::from_le_bytes(spike_mem), ckb_vm_int_mem);
        let ckb_vm_asm_mem = ckb_vm_asm.memory_mut().load64(&0x4000).unwrap();
        assert_eq!(u64::from_le_bytes(spike_mem), ckb_vm_asm_mem);
    }
    for i in 0..32 {
        let spike_reg = spike.get_reg(i).unwrap();
        let ckb_vm_int_reg = ckb_vm_int.registers()[i as usize];
        let ckb_vm_asm_reg = ckb_vm_asm.registers()[i as usize];
        assert_eq!(spike_reg, ckb_vm_int_reg);
        assert_eq!(spike_reg, ckb_vm_asm_reg);
    }
});


================================================
File: fuzz/fuzz_targets/isa_b.rs
================================================
#![no_main]
use ckb_vm::CoreMachine;
use libfuzzer_sys::fuzz_target;
use spike_sys::Spike;
use std::collections::VecDeque;

struct Deque {
    n: VecDeque<u8>,
}

impl Deque {
    fn new(data: [u8; 512]) -> Self {
        Self {
            n: VecDeque::from(data),
        }
    }

    fn u8(&mut self) -> u8 {
        let r = self.n.pop_front().unwrap();
        self.n.push_back(r);
        r
    }

    fn u32(&mut self) -> u32 {
        let mut r = [0u8; 4];
        r.fill_with(|| self.u8());
        u32::from_le_bytes(r)
    }

    fn u64(&mut self) -> u64 {
        let mut r = [0u8; 8];
        r.fill_with(|| self.u8());
        u64::from_le_bytes(r)
    }
}

fuzz_target!(|data: [u8; 512]| {
    let mut deque = Deque::new(data);
    let spike = Spike::new(4 * 1024 * 1024 - 4096);
    let ckb_vm_isa = ckb_vm::ISA_IMC | ckb_vm::ISA_A | ckb_vm::ISA_B;
    let ckb_vm_version = ckb_vm::machine::VERSION2;
    let mut ckb_vm_int =
        ckb_vm::DefaultMachineBuilder::new(ckb_vm::DefaultCoreMachine::<
            u64,
            ckb_vm::SparseMemory<u64>,
        >::new(ckb_vm_isa, ckb_vm_version, u64::MAX))
        .build();
    let mut ckb_vm_asm = ckb_vm::DefaultMachineBuilder::new(
        ckb_vm::machine::asm::AsmCoreMachine::new(ckb_vm_isa, ckb_vm_version, u64::MAX),
    )
    .build();

    #[rustfmt::skip]
    let insts: [(u32, u32); 43] = [
        (0b0000100_00000_00000_000_00000_0111011, 0b0000000_11111_11111_000_11111_0000000), // ADDUW
        (0b0100000_00000_00000_111_00000_0110011, 0b0000000_11111_11111_000_11111_0000000), // ANDN
        (0b0100100_00000_00000_001_00000_0110011, 0b0000000_11111_11111_000_11111_0000000), // BCLR
        (0b010010_000000_00000_001_00000_0010011, 0b000000_111111_11111_000_11111_0000000), // BCLRI
        (0b0100100_00000_00000_101_00000_0110011, 0b0000000_11111_11111_000_11111_0000000), // BEXT
        (0b010010_000000_00000_101_00000_0010011, 0b000000_111111_11111_000_11111_0000000), // BEXTI
        (0b0110100_00000_00000_001_00000_0110011, 0b0000000_11111_11111_000_11111_0000000), // BINV
        (0b011010_000000_00000_001_00000_0010011, 0b000000_111111_11111_000_11111_0000000), // BINVI
        (0b0010100_00000_00000_001_00000_0110011, 0b0000000_11111_11111_000_11111_0000000), // BSET
        (0b001010_000000_00000_001_00000_0010011, 0b000000_111111_11111_000_11111_0000000), // BSETI
        (0b0000101_00000_00000_001_00000_0110011, 0b0000000_11111_11111_000_11111_0000000), // CLMUL
        (0b0000101_00000_00000_011_00000_0110011, 0b0000000_11111_11111_000_11111_0000000), // CLMULH
        (0b0000101_00000_00000_010_00000_0110011, 0b0000000_11111_11111_000_11111_0000000), // CLMULR
        (0b0110000_00000_00000_001_00000_0010011, 0b0000000_00000_11111_000_11111_0000000), // CLZ
        (0b0110000_00000_00000_001_00000_0011011, 0b0000000_00000_11111_000_11111_0000000), // CLZW
        (0b0110000_00010_00000_001_00000_0010011, 0b0000000_00000_11111_000_11111_0000000), // CPOP
        (0b0110000_00010_00000_001_00000_0011011, 0b0000000_00000_11111_000_11111_0000000), // CPOPW
        (0b0110000_00001_00000_001_00000_0010011, 0b0000000_00000_11111_000_11111_0000000), // CTZ
        (0b0110000_00001_00000_001_00000_0011011, 0b0000000_00000_11111_000_11111_0000000), // CTZW
        (0b0000101_00000_00000_110_00000_0110011, 0b0000000_11111_11111_000_11111_0000000), // MAX
        (0b0000101_00000_00000_111_00000_0110011, 0b0000000_11111_11111_000_11111_0000000), // MAXU
        (0b0000101_00000_00000_100_00000_0110011, 0b0000000_11111_11111_000_11111_0000000), // MIN
        (0b0000101_00000_00000_101_00000_0110011, 0b0000000_11111_11111_000_11111_0000000), // MINU
        (0b0010100_00111_00000_101_00000_0010011, 0b0000000_00000_11111_000_11111_0000000), // ORCB
        (0b0100000_00000_00000_110_00000_0110011, 0b0000000_11111_11111_000_11111_0000000), // ORN
        (0b0110101_11000_00000_101_00000_0010011, 0b0000000_00000_11111_000_11111_0000000), // REV8
        (0b0110000_00000_00000_001_00000_0110011, 0b0000000_11111_11111_000_11111_0000000), // ROL
        (0b0110000_00000_00000_001_00000_0111011, 0b0000000_11111_11111_000_11111_0000000), // ROLW
        (0b0110000_00000_00000_101_00000_0110011, 0b0000000_11111_11111_000_11111_0000000), // ROR
        (0b011000_000000_00000_101_00000_0010011, 0b000000_111111_11111_000_11111_0000000), // RORI
        (0b0110000_00000_00000_101_00000_0011011, 0b0000000_11111_11111_000_11111_0000000), // RORIW
        (0b0110000_00000_00000_101_00000_0111011, 0b0000000_11111_11111_000_11111_0000000), // RORW
        (0b0110000_00100_00000_001_00000_0010011, 0b0000000_00000_11111_000_11111_0000000), // SEXTB
        (0b0110000_00101_00000_001_00000_0010011, 0b0000000_00000_11111_000_11111_0000000), // SEXTH
        (0b0010000_00000_00000_010_00000_0110011, 0b0000000_11111_11111_000_11111_0000000), // SH1ADD
        (0b0010000_00000_00000_010_00000_0111011, 0b0000000_11111_11111_000_11111_0000000), // SH1ADDUW
        (0b0010000_00000_00000_100_00000_0110011, 0b0000000_11111_11111_000_11111_0000000), // SH2ADD
        (0b0010000_00000_00000_100_00000_0111011, 0b0000000_11111_11111_000_11111_0000000), // SH2ADDUW
        (0b0010000_00000_00000_110_00000_0110011, 0b0000000_11111_11111_000_11111_0000000), // SH3ADD
        (0b0010000_00000_00000_110_00000_0111011, 0b0000000_11111_11111_000_11111_0000000), // SH3ADDUW
        (0b000010_000000_00000_001_00000_0011011, 0b000000_111111_11111_000_11111_0000000), // SLLIUW
        (0b0100000_00000_00000_100_00000_0110011, 0b0000000_11111_11111_000_11111_0000000), // XNOR
        (0b0000100_00000_00000_100_00000_0111011, 0b0000000_00000_11111_000_11111_0000000), // ZEXTH
    ];
    for i in 1..32 {
        let d = deque.u64();
        spike.set_reg(i as u64, d).unwrap();
        ckb_vm_int.set_register(i, d);
        ckb_vm_asm.set_register(i, d);
    }
    for _ in 0..1024 {
        let choose = deque.u8() as usize % insts.len();
        let inst = insts[choose].0;
        let mask = insts[choose].1;

        let inst = inst | (mask & deque.u32());
        let insn = ckb_vm::instructions::b::factory::<u64>(inst, ckb_vm_version).unwrap();

        spike.execute(inst as u64).unwrap();
        ckb_vm::instructions::execute_instruction(insn, &mut ckb_vm_int).unwrap();
        ckb_vm::instructions::execute_instruction(insn, &mut ckb_vm_asm).unwrap();
    }
    for i in 0..32 {
        let spike_reg = spike.get_reg(i).unwrap();
        let ckb_vm_int_reg = ckb_vm_int.registers()[i as usize];
        let ckb_vm_asm_reg = ckb_vm_asm.registers()[i as usize];
        assert_eq!(spike_reg, ckb_vm_int_reg);
        assert_eq!(spike_reg, ckb_vm_asm_reg);
    }
});


================================================
File: fuzz/fuzz_targets/snapshot.rs
================================================
#![no_main]
use ckb_vm::cost_model::constant_cycles;
use ckb_vm::machine::asm::{AsmCoreMachine, AsmMachine};
use ckb_vm::machine::{DefaultMachineBuilder, VERSION2};
use ckb_vm::snapshot;
use ckb_vm::{Bytes, Error, SupportMachine, ISA_A, ISA_B, ISA_IMC, ISA_MOP};
use libfuzzer_sys::fuzz_target;

fuzz_target!(|data: &[u8]| {
    let mut machine1 = {
        let asm_core = AsmCoreMachine::new(ISA_IMC | ISA_A | ISA_B | ISA_MOP, VERSION2, 200_000);
        let machine = DefaultMachineBuilder::<Box<AsmCoreMachine>>::new(asm_core)
            .instruction_cycle_func(Box::new(constant_cycles))
            .build();
        AsmMachine::new(machine)
    };
    let program = Bytes::copy_from_slice(data);
    if machine1.load_program(&program, vec![].into_iter()).is_err() {
        return;
    };
    let result1 = machine1.run();
    if machine1.machine.cycles() < 4 {
        return;
    }

    let half_cycles = machine1.machine.cycles() / 2;
    let mut machine2 = {
        let asm_core =
            AsmCoreMachine::new(ISA_IMC | ISA_A | ISA_B | ISA_MOP, VERSION2, half_cycles);
        let machine = DefaultMachineBuilder::<Box<AsmCoreMachine>>::new(asm_core)
            .instruction_cycle_func(Box::new(constant_cycles))
            .build();
        AsmMachine::new(machine)
    };
    machine2.load_program(&program, vec![].into_iter()).unwrap();
    let result2 = machine2.run();
    assert_eq!(result2.unwrap_err(), Error::CyclesExceeded);
    let snap = snapshot::make_snapshot(&mut machine2.machine).unwrap();

    let mut machine3 = {
        let asm_core =
            AsmCoreMachine::new(ISA_IMC | ISA_A | ISA_B | ISA_MOP, VERSION2, half_cycles);
        let machine = DefaultMachineBuilder::<Box<AsmCoreMachine>>::new(asm_core)
            .instruction_cycle_func(Box::new(constant_cycles))
            .build();
        AsmMachine::new(machine)
    };
    snapshot::resume(&mut machine3.machine, &snap).unwrap();

    machine3.machine.set_cycles(machine2.machine.cycles());
    machine3.machine.set_max_cycles(200_000);
    let result3 = machine3.run();
    assert_eq!(result1, result3);
    assert_eq!(machine1.machine.cycles(), machine3.machine.cycles());
});


================================================
File: fuzz/fuzz_targets/snapshot2.rs
================================================
#![no_main]
use ckb_vm::{
    elf::{LoadingAction, ProgramMetadata},
    machine::VERSION2,
    memory::{round_page_down, round_page_up, FLAG_EXECUTABLE, FLAG_FREEZED},
    snapshot2::{DataSource, Snapshot2Context},
    Bytes, CoreMachine, DefaultMachine, DefaultMachineBuilder, Memory, DEFAULT_MEMORY_SIZE, ISA_A,
    ISA_B, ISA_IMC, ISA_MOP, RISCV_PAGESIZE,
};
use ckb_vm_definitions::asm::AsmCoreMachine;
use libfuzzer_sys::fuzz_target;
use std::collections::VecDeque;

struct Deque {
    n: VecDeque<u8>,
}

impl Deque {
    fn new(data: [u8; 96]) -> Self {
        Self {
            n: VecDeque::from(data),
        }
    }

    fn u8(&mut self) -> u8 {
        let r = self.n.pop_front().unwrap();
        self.n.push_back(r);
        r
    }

    fn u32(&mut self) -> u32 {
        let mut r = [0u8; 4];
        r.fill_with(|| self.u8());
        u32::from_le_bytes(r)
    }
}

const DATA_SOURCE_PROGRAM: u32 = 0;
const DATA_SOURCE_CONTENT: u32 = 1;
const MAX_TX_SIZE: u32 = 600_000;

#[derive(Clone)]
pub struct DummyData {
    pub program: Bytes,
    pub content: Bytes,
}

impl DataSource<u32> for DummyData {
    fn load_data(&self, id: &u32, offset: u64, length: u64) -> Option<(Bytes, u64)> {
        let data = match *id {
            DATA_SOURCE_PROGRAM => &self.program,
            DATA_SOURCE_CONTENT => &self.content,
            _ => unreachable!(),
        };
        let offset = std::cmp::min(offset as usize, data.len());
        let full_size = data.len() - offset;
        let real_size = if length > 0 {
            std::cmp::min(full_size, length as usize)
        } else {
            full_size
        };
        Some((data.slice(offset..offset + real_size), full_size as u64))
    }
}

fn build_machine() -> DefaultMachine<Box<AsmCoreMachine>> {
    let isa = ISA_IMC | ISA_A | ISA_B | ISA_MOP;
    let core_machine = AsmCoreMachine::new(isa, VERSION2, u64::MAX);
    DefaultMachineBuilder::new(core_machine).build()
}

fuzz_target!(|data: [u8; 96]| {
    let mut deque = Deque::new(data);
    let dummy_data = {
        let mut program = vec![0u8; (deque.u32() % MAX_TX_SIZE) as usize];
        for i in 0..program.len() {
            program[i] = (i % 3) as u8;
        }
        let mut content = vec![0u8; (deque.u32() % MAX_TX_SIZE) as usize];
        for i in 0..content.len() {
            content[i] = (i % 5) as u8 + 10;
        }
        DummyData {
            program: program.into(),
            content: content.into(),
        }
    };
    let mut loading_action_vec: Vec<LoadingAction> = Vec::new();
    for _ in 0..2 {
        let p_vaddr = deque.u32() as u64;
        let p_memsz = deque.u32() as u64;
        let p_offset = deque.u32() as u64;
        let p_filesz = deque.u32() as u64;
        let aligned_start = round_page_down(p_vaddr);
        let padding_start = (p_vaddr).wrapping_sub(aligned_start);
        let size = round_page_up((p_memsz).wrapping_add(padding_start));
        let slice_start = p_offset;
        let slice_end = p_offset.wrapping_add(p_filesz);
        if slice_start >= slice_end || slice_end >= dummy_data.program.len() as u64 {
            return;
        }
        loading_action_vec.push(LoadingAction {
            addr: aligned_start,
            size,
            flags: FLAG_EXECUTABLE | FLAG_FREEZED,
            source: slice_start as u64..slice_end as u64,
            offset_from_addr: padding_start,
        })
    }
    let mut ctx = Snapshot2Context::new(dummy_data.clone());
    let metadata = ProgramMetadata {
        actions: loading_action_vec.clone(),
        entry: 0,
    };

    let mut machine1 = build_machine();
    let mut machine2 = build_machine();
    let result =
        machine1.load_program_with_metadata(&dummy_data.program, &metadata, vec![].into_iter());
    if result.is_err() {
        return;
    }
    let result = ctx.mark_program(&mut machine1, &metadata, &0, 0);
    if result.is_err() {
        return;
    }
    for _ in 0..2 {
        let length = deque.u32() as u64;
        let offset = deque.u32() as u64;
        let addr = deque.u32() as u64;
        let result = ctx.store_bytes(&mut machine1, addr, &DATA_SOURCE_CONTENT, offset, length, 0);
        if result.is_err() {
            return;
        }
    }
    for _ in 0..2 {
        let length = deque.u32() as u64;
        let offset = deque.u32() as u64;
        let addr = deque.u32() as u64;
        let data = dummy_data
            .load_data(&DATA_SOURCE_CONTENT, offset, length)
            .unwrap()
            .0;
        let result = machine1.memory_mut().store_bytes(addr, &data);
        if result.is_err() {
            continue;
        }
    }
    let snapshot = ctx.make_snapshot(&mut machine1).unwrap();
    ctx.resume(&mut machine2, &snapshot).unwrap();
    for i in 0..DEFAULT_MEMORY_SIZE / RISCV_PAGESIZE {
        let mem1 = machine1
            .memory_mut()
            .load_bytes((i * RISCV_PAGESIZE) as u64, RISCV_PAGESIZE as u64)
            .unwrap();
        let mem2 = machine2
            .memory_mut()
            .load_bytes((i * RISCV_PAGESIZE) as u64, RISCV_PAGESIZE as u64)
            .unwrap();
        assert_eq!(mem1, mem2);
        let flag1 = machine1.memory_mut().fetch_flag(i as u64);
        let flag2 = machine2.memory_mut().fetch_flag(i as u64);
        assert_eq!(flag1, flag2);
    }
});


================================================
File: src/bits.rs
================================================
#[inline(always)]
pub fn roundup(x: u64, round: u64) -> u64 {
    debug_assert!(round.is_power_of_two());
    // x + (((!x) + 1) & (round - 1))
    x.wrapping_add((!x).wrapping_add(1) & (round.wrapping_sub(1)))
}

#[inline(always)]
pub fn rounddown(x: u64, round: u64) -> u64 {
    debug_assert!(round.is_power_of_two());
    // x & !(round - 1)
    x & !(round.wrapping_sub(1))
}

#[cfg(test)]
mod tests {
    use super::*;
    use proptest::prelude::*;

    #[test]
    fn test_roundup() {
        assert_eq!(0, roundup(0, 16));
        assert_eq!(16, roundup(1, 16));
        assert_eq!(16, roundup(15, 16));
        assert_eq!(16, roundup(16, 16));
        assert_eq!(32, roundup(17, 16));
        assert_eq!(u64::MAX - 15, roundup(u64::MAX - 15, 16));
        assert_eq!(0, roundup(u64::MAX, 16));
    }

    #[test]
    fn test_rounddown() {
        assert_eq!(0, rounddown(0, 16));
        assert_eq!(0, rounddown(1, 16));
        assert_eq!(0, rounddown(15, 16));
        assert_eq!(16, rounddown(16, 16));
        assert_eq!(16, rounddown(17, 16));
        assert_eq!(u64::MAX - 15, rounddown(u64::MAX, 16));
    }

    proptest! {
        #[test]
        #[cfg_attr(all(miri, feature = "miri-ci"), ignore)]
        fn roundup_proptest(x: u64, round in (0u32..16).prop_map(|d| 2u64.pow(d))) {
            prop_assume!(x.checked_add(round).is_some(), "avoid integer overflow");
            let result = roundup(x, round);

            // multiple of round
            assert_eq!(result % round, 0);

            // lower bound
            assert!(result >= x);

            // upper bound
            assert!(result < x + round);
        }

        #[test]
        #[cfg_attr(all(miri, feature = "miri-ci"), ignore)]
        fn rounddown_proptest(x: u64, round in (0u32..16).prop_map(|d| 2u64.pow(d))) {
            let result = rounddown(x, round);

            // multiple of round
            assert_eq!(result % round, 0);

            // upper bound
            assert!(result <= x);

            // lower bound
            if let Some(lower_bound) = x.checked_sub(round) {
                assert!(result > lower_bound);
            } else {
                assert_eq!(result, 0);
            }
        }
    }
}


================================================
File: src/cost_model.rs
================================================
use crate::{
    instructions::{extract_opcode, insts},
    Instruction,
};

// Returns the spent cycles to execute the specific instruction.
// This function is usually used to write test cases, which can visually
// display how many instructions are executed.
pub fn constant_cycles(_: Instruction) -> u64 {
    1
}

// Returns the spent cycles to execute the specific instruction.
// These values come from estimates of hardware execution speed.
pub fn estimate_cycles(i: Instruction) -> u64 {
    match extract_opcode(i) {
        // IMC
        insts::OP_JALR_VERSION0 => 3,
        insts::OP_JALR_VERSION1 => 3,
        insts::OP_LD_VERSION0 => 2,
        insts::OP_LD_VERSION1 => 2,
        insts::OP_LW_VERSION0 => 3,
        insts::OP_LW_VERSION1 => 3,
        insts::OP_LH_VERSION0 => 3,
        insts::OP_LH_VERSION1 => 3,
        insts::OP_LB_VERSION0 => 3,
        insts::OP_LB_VERSION1 => 3,
        insts::OP_LWU_VERSION0 => 3,
        insts::OP_LWU_VERSION1 => 3,
        insts::OP_LHU_VERSION0 => 3,
        insts::OP_LHU_VERSION1 => 3,
        insts::OP_LBU_VERSION0 => 3,
        insts::OP_LBU_VERSION1 => 3,
        insts::OP_SB => 3,
        insts::OP_SH => 3,
        insts::OP_SW => 3,
        insts::OP_SD => 2,
        insts::OP_BEQ => 3,
        insts::OP_BGE => 3,
        insts::OP_BGEU => 3,
        insts::OP_BLT => 3,
        insts::OP_BLTU => 3,
        insts::OP_BNE => 3,
        insts::OP_EBREAK => 500,
        insts::OP_ECALL => 500,
        insts::OP_JAL => 3,
        insts::OP_MUL => 5,
        insts::OP_MULW => 5,
        insts::OP_MULH => 5,
        insts::OP_MULHU => 5,
        insts::OP_MULHSU => 5,
        insts::OP_DIV => 32,
        insts::OP_DIVW => 32,
        insts::OP_DIVU => 32,
        insts::OP_DIVUW => 32,
        insts::OP_REM => 32,
        insts::OP_REMW => 32,
        insts::OP_REMU => 32,
        insts::OP_REMUW => 32,
        // A
        insts::OP_LR_W => 4,
        insts::OP_SC_W => 4,
        insts::OP_AMOSWAP_W => 4,
        insts::OP_AMOADD_W => 4,
        insts::OP_AMOXOR_W => 4,
        insts::OP_AMOAND_W => 4,
        insts::OP_AMOOR_W => 4,
        insts::OP_AMOMIN_W => 4,
        insts::OP_AMOMAX_W => 4,
        insts::OP_AMOMINU_W => 4,
        insts::OP_AMOMAXU_W => 4,
        insts::OP_LR_D => 3,
        insts::OP_SC_D => 3,
        insts::OP_AMOSWAP_D => 3,
        insts::OP_AMOADD_D => 3,
        insts::OP_AMOXOR_D => 3,
        insts::OP_AMOAND_D => 3,
        insts::OP_AMOOR_D => 3,
        insts::OP_AMOMIN_D => 3,
        insts::OP_AMOMAX_D => 3,
        insts::OP_AMOMINU_D => 3,
        insts::OP_AMOMAXU_D => 3,
        // MOP
        insts::OP_WIDE_MUL => 5,
        insts::OP_WIDE_MULU => 5,
        insts::OP_WIDE_MULSU => 5,
        insts::OP_WIDE_DIV => 32,
        insts::OP_WIDE_DIVU => 32,
        insts::OP_FAR_JUMP_REL => 3,
        insts::OP_FAR_JUMP_ABS => 3,
        _ => 1,
    }
}


================================================
File: src/debugger.rs
================================================
use crate::{machine::SupportMachine, Error};

pub trait Debugger<Mac: SupportMachine>: Send + Sync {
    fn initialize(&mut self, machine: &mut Mac) -> Result<(), Error>;
    fn ebreak(&mut self, machine: &mut Mac) -> Result<(), Error>;
}


================================================
File: src/decoder.rs
================================================
use ckb_vm_definitions::instructions::{self as insts};
use ckb_vm_definitions::registers::{RA, ZERO};

use crate::error::OutOfBoundKind;
use crate::instructions::{
    a, b, extract_opcode, i, instruction_length, m, rvc, set_instruction_length_n, Instruction,
    InstructionFactory, Itype, R4type, R5type, Register, Rtype, Utype,
};
use crate::machine::VERSION2;
use crate::memory::Memory;
use crate::{Error, ISA_A, ISA_B, ISA_MOP, RISCV_PAGESIZE};

const RISCV_PAGESIZE_MASK: u64 = RISCV_PAGESIZE as u64 - 1;
const INSTRUCTION_CACHE_SIZE: usize = 4096;

pub trait InstDecoder {
    fn decode<M: Memory>(&mut self, memory: &mut M, pc: u64) -> Result<Instruction, Error>;
    fn reset_instructions_cache(&mut self) -> Result<(), Error>;
}

pub struct Decoder {
    factories: Vec<InstructionFactory>,
    mop: bool,
    version: u32,
    // Use a cache of instructions to avoid decoding the same instruction
    // twice, pc is the key and the instruction is the value.
    //
    // Use Vector so that the data is on the heap. Otherwise, if there is
    // a vm call chain, it will quickly consume Rust's 2M stack space.
    instructions_cache: Vec<(u64, u64)>,
}

impl Decoder {
    pub fn new(mop: bool, version: u32) -> Decoder {
        Decoder {
            factories: vec![],
            mop,
            version,
            instructions_cache: vec![(u64::MAX as u64, 0); INSTRUCTION_CACHE_SIZE],
        }
    }

    pub fn add_instruction_factory(&mut self, factory: InstructionFactory) {
        self.factories.push(factory);
    }

    // This method is used to decode instruction raw bits from memory pointed
    // by current PC. Right now we support 32-bit instructions and RVC compressed
    // instructions. In future version we might add support for longer instructions.
    //
    // This decode method actually leverages a trick from little endian encoding:
    // the format for a full 32 bit RISC-V instruction is as follows:
    //
    // WWWWWWWWZZZZZZZZYYYYYYYYXXXXXX11
    //
    // While the format for a 16 bit RVC RIST-V instruction is one of the following 3:
    //
    // YYYYYYYYXXXXXX00
    // YYYYYYYYXXXXXX01
    // YYYYYYYYXXXXXX10
    //
    // Here X, Y, Z and W stands for arbitrary bits.
    // However the above is the representation in a 16-bit or 32-bit integer, since
    // we are using little endian, in memory it's actually in following reversed order:
    //
    // XXXXXX11 YYYYYYYY ZZZZZZZZ WWWWWWWW
    // XXXXXX00 YYYYYYYY
    // XXXXXX01 YYYYYYYY
    // XXXXXX10 YYYYYYYY
    //
    // One observation here, is the first byte in memory is always the least
    // significant byte whether we load a 32-bit or 16-bit integer.
    // So when we are decoding an instruction, we can first load 2 bytes forming
    // a 16-bit integer, then we check the 2 least significant bits, if the 2 bitss
    // are 0b11, we know this is a 32-bit instruction, we should load another 2 bytes
    // from memory and concat the 2 16-bit integers into a full 32-bit integers.
    // Otherwise, we know we are loading a RVC integer, and we are done here.
    // Also, due to RISC-V encoding behavior, it's totally okay when we cast a 16-bit
    // RVC instruction into a 32-bit instruction, the meaning of the instruction stays
    // unchanged in the cast conversion.
    fn decode_bits<M: Memory>(&self, memory: &mut M, pc: u64) -> Result<u32, Error> {
        // when the address is not the last 2 bytes of an executable page,
        // use a faster path to load instruction bits
        if pc & RISCV_PAGESIZE_MASK < RISCV_PAGESIZE_MASK - 1 {
            let mut instruction_bits = memory.execute_load32(pc)?;
            if instruction_bits & 0x3 != 0x3 {
                instruction_bits &= 0xffff;
            }
            Ok(instruction_bits)
        } else {
            let mut instruction_bits = u32::from(memory.execute_load16(pc)?);
            if instruction_bits & 0x3 == 0x3 {
                instruction_bits |= u32::from(memory.execute_load16(pc + 2)?) << 16;
            }
            Ok(instruction_bits)
        }
    }

    pub fn decode_raw<M: Memory>(&mut self, memory: &mut M, pc: u64) -> Result<Instruction, Error> {
        // since we are using u64::MAX as the default key in the instruction cache, have to check out of bound
        // error first.
        if pc as usize >= memory.memory_size() {
            return Err(Error::MemOutOfBound(pc, OutOfBoundKind::Memory));
        }
        let instruction_cache_key = {
            // according to RISC-V instruction encoding, the lowest bit in PC will always be zero
            let pc = pc >> 1;
            // Here we try to balance between local code and remote code. At times,
            // we can find the code jumping to a remote function(e.g., memcpy or
            // alloc), then resumes execution at a local location. Previous cache
            // key only optimizes for local operations, while this new cache key
            // balances the code between a 8192-byte local region, and certain remote
            // code region. Notice the value 12 and 8 here are chosen by empirical
            // evidence.
            ((pc & 0xFF) | (pc >> 12 << 8)) as usize % INSTRUCTION_CACHE_SIZE
        };
        let cached_instruction = self.instructions_cache[instruction_cache_key];
        if cached_instruction.0 == pc {
            return Ok(cached_instruction.1);
        }
        let instruction_bits = self.decode_bits(memory, pc)?;
        for factory in &self.factories {
            if let Some(instruction) = factory(instruction_bits, self.version) {
                self.instructions_cache[instruction_cache_key] = (pc, instruction);
                return Ok(instruction);
            }
        }
        Err(Error::InvalidInstruction {
            pc,
            instruction: instruction_bits,
        })
    }

    // Macro-Operation Fusion (also Macro-Op Fusion, MOP Fusion, or Macrofusion) is a hardware optimization technique found
    // in many modern microarchitectures whereby a series of adjacent macro-operations are merged into a single
    // macro-operation prior or during decoding. Those instructions are later decoded into fused-µOPs.
    //
    // - https://riscv.org/wp-content/uploads/2016/07/Tue1130celio-fusion-finalV2.pdf
    // - https://en.wikichip.org/wiki/macro-operation_fusion#Proposed_fusion_operations
    // - https://carrv.github.io/2017/papers/clark-rv8-carrv2017.pdf
    pub fn decode_mop<M: Memory>(&mut self, memory: &mut M, pc: u64) -> Result<Instruction, Error> {
        let head_instruction = self.decode_raw(memory, pc)?;
        let head_opcode = extract_opcode(head_instruction);
        match head_opcode {
            insts::OP_ADD => {
                let rule_adc = |decoder: &mut Self,
                                memory: &mut M|
                 -> Result<Option<Instruction>, Error> {
                    let head_inst = Rtype(head_instruction);
                    let head_size = instruction_length(head_instruction);
                    if head_inst.rd() != head_inst.rs1() || head_inst.rs1() == head_inst.rs2() {
                        return Ok(None);
                    }
                    let next_instruction = decoder.decode_raw(memory, pc + head_size as u64)?;
                    let next_opcode = extract_opcode(next_instruction);
                    if next_opcode != insts::OP_SLTU {
                        return Ok(None);
                    }
                    let next_inst = Rtype(next_instruction);
                    let next_size = instruction_length(next_instruction);
                    if next_inst.rd() != head_inst.rs2()
                        || head_inst.rs2() != next_inst.rs2()
                        || next_inst.rs1() != head_inst.rs1()
                    {
                        return Ok(None);
                    }
                    let neck_instruction =
                        decoder.decode_raw(memory, pc + head_size as u64 + next_size as u64)?;
                    let neck_opcode = extract_opcode(neck_instruction);
                    if neck_opcode != insts::OP_ADD {
                        return Ok(None);
                    }
                    let neck_inst = Rtype(neck_instruction);
                    let neck_size = instruction_length(neck_instruction);
                    if neck_inst.rd() != neck_inst.rs1()
                        || neck_inst.rs1() != next_inst.rs1()
                        || neck_inst.rs2() == head_inst.rs1()
                        || neck_inst.rs2() == head_inst.rs2()
                    {
                        return Ok(None);
                    }
                    let body_instruction = decoder.decode_raw(
                        memory,
                        pc + head_size as u64 + next_size as u64 + neck_size as u64,
                    )?;
                    let body_opcode = extract_opcode(body_instruction);
                    if body_opcode != insts::OP_SLTU {
                        return Ok(None);
                    }
                    let body_inst = Rtype(body_instruction);
                    let body_size = instruction_length(body_instruction);
                    if body_inst.rd() != body_inst.rs2()
                        || body_inst.rs2() != neck_inst.rs2()
                        || body_inst.rs1() != neck_inst.rs1()
                    {
                        return Ok(None);
                    }
                    let tail_instruction = decoder.decode_raw(
                        memory,
                        pc + head_size as u64
                            + next_size as u64
                            + neck_size as u64
                            + body_size as u64,
                    )?;
                    let tail_opcode = extract_opcode(tail_instruction);
                    if tail_opcode != insts::OP_OR {
                        return Ok(None);
                    }
                    let tail_inst = Rtype(tail_instruction);
                    let tail_size = instruction_length(tail_instruction);
                    if tail_inst.rd() != tail_inst.rs1()
                        || tail_inst.rs1() != head_inst.rs2()
                        || tail_inst.rs2() != body_inst.rs2()
                    {
                        return Ok(None);
                    }
                    if head_inst.rd() == ZERO || next_inst.rd() == ZERO || body_inst.rd() == ZERO {
                        return Ok(None);
                    }
                    let fuze_inst = Rtype::new(
                        insts::OP_ADC,
                        head_inst.rd(),
                        next_inst.rd(),
                        body_inst.rd(),
                    );
                    let fuze_size = head_size + next_size + neck_size + body_size + tail_size;
                    Ok(Some(set_instruction_length_n(fuze_inst.0, fuze_size)))
                };
                let rule_add3 =
                    |decoder: &mut Self, memory: &mut M| -> Result<Option<Instruction>, Error> {
                        if decoder.version < VERSION2 {
                            return Ok(None);
                        }

                        let i0 = Rtype(head_instruction);
                        let i0_size = instruction_length(head_instruction);

                        let (i1, i1_size) = {
                            let i1 = decoder.decode_raw(memory, pc + i0_size as u64)?;
                            let i1_opcode = extract_opcode(i1);
                            if i1_opcode != insts::OP_SLTU {
                                return Ok(None);
                            }
                            (Rtype(i1), instruction_length(i1))
                        };

                        let (i2, i2_size) = {
                            let i2 =
                                decoder.decode_raw(memory, pc + i0_size as u64 + i1_size as u64)?;
                            let i2_opcode = extract_opcode(i2);
                            if i2_opcode != insts::OP_ADD {
                                return Ok(None);
                            }
                            (Rtype(i2), instruction_length(i2))
                        };

                        let fuze_size = i0_size + i1_size + i2_size;

                        {
                            // add r0, r1, r0
                            // sltu r2, r0, r1
                            // add r3, r2, r4
                            //
                            // r0 != r1
                            // r0 != r4
                            // r2 != r4
                            // r0 != x0
                            // r2 != x0
                            let r0 = i0.rd();
                            let r1 = i0.rs1();
                            let r2 = i1.rd();
                            let r3 = i2.rd();
                            let r4 = i2.rs2();

                            if i0.rd() == r0
                                && i0.rs1() == r1
                                && i0.rs2() == r0
                                && i1.rd() == r2
                                && i1.rs1() == r0
                                && i1.rs2() == r1
                                && i2.rd() == r3
                                && i2.rs1() == r2
                                && i2.rs2() == r4
                                && r0 != r1
                                && r0 != r4
                                && r2 != r4
                                && r0 != ZERO
                                && r2 != ZERO
                            {
                                let fuze_inst = R5type::new(insts::OP_ADD3A, r0, r1, r2, r3, r4);
                                return Ok(Some(set_instruction_length_n(fuze_inst.0, fuze_size)));
                            }
                        }

                        {
                            // add r0, r1, r2
                            // sltu r1, r0, r1
                            // add r3, r1, r4
                            //
                            // r0 != r1
                            // r0 != r4
                            // r1 != r4
                            // r0 != x0
                            // r1 != x0
                            let r0 = i0.rd();
                            let r1 = i0.rs1();
                            let r2 = i0.rs2();
                            let r3 = i2.rd();
                            let r4 = i2.rs2();

                            if i0.rd() == r0
                                && i0.rs1() == r1
                                && i0.rs2() == r2
                                && i1.rd() == r1
                                && i1.rs1() == r0
                                && i1.rs2() == r1
                                && i2.rd() == r3
                                && i2.rs1() == r1
                                && i2.rs2() == r4
                                && r0 != r1
                                && r0 != r4
                                && r1 != r4
                                && r0 != ZERO
                                && r1 != ZERO
                            {
                                let fuze_inst = R5type::new(insts::OP_ADD3B, r0, r1, r2, r3, r4);
                                return Ok(Some(set_instruction_length_n(fuze_inst.0, fuze_size)));
                            }
                        }
                        {
                            // add r0, r1, r2
                            // sltu r3, r0, r1
                            // add r3, r3, r4
                            //
                            // r0 != r1
                            // r0 != r4
                            // r3 != r4
                            // r0 != x0
                            // r3 != x0
                            let r0 = i0.rd();
                            let r1 = i0.rs1();
                            let r2 = i0.rs2();
                            let r3 = i1.rd();
                            let r4 = i2.rs2();

                            if i0.rd() == r0
                                && i0.rs1() == r1
                                && i0.rs2() == r2
                                && i1.rd() == r3
                                && i1.rs1() == r0
                                && i1.rs2() == r1
                                && i2.rd() == r3
                                && i2.rs1() == r3
                                && i2.rs2() == r4
                                && r0 != r1
                                && r0 != r4
                                && r3 != r4
                                && r0 != ZERO
                                && r3 != ZERO
                            {
                                let fuze_inst = R5type::new(insts::OP_ADD3C, r0, r1, r2, r3, r4);
                                return Ok(Some(set_instruction_length_n(fuze_inst.0, fuze_size)));
                            }
                        }
                        Ok(None)
                    };
                let rule_adcs =
                    |decoder: &mut Self, memory: &mut M| -> Result<Option<Instruction>, Error> {
                        // add r0, r1, r2
                        // sltu r3, r0, r1
                        //
                        // or
                        //
                        // add r0, r2, r1
                        // sltu r3, r0, r1
                        //
                        // r0 != r1
                        // r0 != x0
                        if decoder.version < VERSION2 {
                            return Ok(None);
                        }

                        let mut i0 = Rtype(head_instruction);
                        let i0_size = instruction_length(head_instruction);

                        if i0.rd() == i0.rs1() && i0.rd() != i0.rs2() {
                            i0 = Rtype::new(i0.op(), i0.rd(), i0.rs2(), i0.rs1());
                        }

                        let (i1, i1_size) = {
                            let i1 = decoder.decode_raw(memory, pc + i0_size as u64)?;
                            let i1_opcode = extract_opcode(i1);
                            if i1_opcode != insts::OP_SLTU {
                                return Ok(None);
                            }
                            (Rtype(i1), instruction_length(i1))
                        };

                        let r0 = i0.rd();
                        let r1 = i0.rs1();
                        let r2 = i0.rs2();
                        let r3 = i1.rd();

                        if i0.rd() == r0
                            && i0.rs1() == r1
                            && i0.rs2() == r2
                            && i1.rd() == r3
                            && i1.rs1() == r0
                            && i1.rs2() == r1
                            && r0 != r1
                            && r0 != ZERO
                        {
                            let fuze_inst = R4type::new(insts::OP_ADCS, r0, r1, r2, r3);
                            let fuze_size = i0_size + i1_size;
                            Ok(Some(set_instruction_length_n(fuze_inst.0, fuze_size)))
                        } else {
                            Ok(None)
                        }
                    };
                if let Ok(Some(i)) = rule_adc(self, memory) {
                    Ok(i)
                } else if let Ok(Some(i)) = rule_add3(self, memory) {
                    Ok(i)
                } else if let Ok(Some(i)) = rule_adcs(self, memory) {
                    Ok(i)
                } else {
                    Ok(head_instruction)
                }
            }
            insts::OP_SUB => {
                let rule_sbb =
                    |decoder: &mut Self, memory: &mut M| -> Result<Option<Instruction>, Error> {
                        let head_inst = Rtype(head_instruction);
                        let head_size = instruction_length(head_instruction);
                        if head_inst.rd() != head_inst.rs2() || head_inst.rs1() == head_inst.rs2() {
                            return Ok(None);
                        }
                        let next_instruction = decoder.decode_raw(memory, pc + head_size as u64)?;
                        let next_opcode = extract_opcode(next_instruction);
                        if next_opcode != insts::OP_SLTU {
                            return Ok(None);
                        }
                        let next_inst = Rtype(next_instruction);
                        let next_size = instruction_length(next_instruction);
                        if next_inst.rd() == head_inst.rs1()
                            || next_inst.rd() == head_inst.rs2()
                            || next_inst.rs1() != head_inst.rs1()
                            || next_inst.rs2() != next_inst.rs2()
                        {
                            return Ok(None);
                        }
                        let neck_instruction =
                            decoder.decode_raw(memory, pc + head_size as u64 + next_size as u64)?;
                        let neck_opcode = extract_opcode(neck_instruction);
                        if neck_opcode != insts::OP_SUB {
                            return Ok(None);
                        }
                        let neck_inst = Rtype(neck_instruction);
                        let neck_size = instruction_length(neck_instruction);
                        if neck_inst.rd() != head_inst.rs1()
                            || neck_inst.rs1() != head_inst.rs2()
                            || neck_inst.rs2() == head_inst.rs1()
                            || neck_inst.rs2() == head_inst.rs2()
                            || neck_inst.rs2() == next_inst.rd()
                        {
                            return Ok(None);
                        }
                        let body_instruction = decoder.decode_raw(
                            memory,
                            pc + head_size as u64 + next_size as u64 + neck_size as u64,
                        )?;
                        let body_opcode = extract_opcode(body_instruction);
                        if body_opcode != insts::OP_SLTU {
                            return Ok(None);
                        }
                        let body_inst = Rtype(body_instruction);
                        let body_size = instruction_length(body_instruction);
                        if body_inst.rd() != neck_inst.rs2()
                            || body_inst.rs1() != head_inst.rs2()
                            || body_inst.rs2() != head_inst.rs1()
                        {
                            return Ok(None);
                        }
                        let tail_instruction = decoder.decode_raw(
                            memory,
                            pc + head_size as u64
                                + next_size as u64
                                + neck_size as u64
                                + body_size as u64,
                        )?;
                        let tail_opcode = extract_opcode(tail_instruction);
                        if tail_opcode != insts::OP_OR {
                            return Ok(None);
                        }
                        let tail_inst = Rtype(tail_instruction);
                        let tail_size = instruction_length(tail_instruction);
                        if tail_inst.rd() != head_inst.rd()
                            || tail_inst.rs1() != neck_inst.rs2()
                            || tail_inst.rs2() != next_inst.rd()
                        {
                            return Ok(None);
                        }
                        let fuze_inst = R4type::new(
                            insts::OP_SBB,
                            head_inst.rs1(),
                            head_inst.rs2(),
                            neck_inst.rs2(),
                            next_inst.rd(),
                        );
                        if head_inst.rs1() == ZERO
                            || head_inst.rs2() == ZERO
                            || neck_inst.rs2() == ZERO
                            || next_inst.rd() == ZERO
                        {
                            return Ok(None);
                        }
                        let fuze_size = head_size + next_size + neck_size + body_size + tail_size;
                        Ok(Some(set_instruction_length_n(fuze_inst.0, fuze_size)))
                    };
                let rule_sbbs =
                    |decoder: &mut Self, memory: &mut M| -> Result<Option<Instruction>, Error> {
                        // sub r0, r1, r2
                        // sltu r3, r1, r2
                        //
                        // r0 != r1
                        // r0 != r2
                        if decoder.version < VERSION2 {
                            return Ok(None);
                        }

                        let i0 = Rtype(head_instruction);
                        let i0_size = instruction_length(head_instruction);

                        let (i1, i1_size) = {
                            let i1 = decoder.decode_raw(memory, pc + i0_size as u64)?;
                            let i1_opcode = extract_opcode(i1);
                            if i1_opcode != insts::OP_SLTU {
                                return Ok(None);
                            }
                            (Rtype(i1), instruction_length(i1))
                        };

                        let r0 = i0.rd();
                        let r1 = i0.rs1();
                        let r2 = i0.rs2();
                        let r3 = i1.rd();

                        if i0.rd() == r0
                            && i0.rs1() == r1
                            && i0.rs2() == r2
                            && i1.rd() == r3
                            && i1.rs1() == r1
                            && i1.rs2() == r2
                            && r0 != r1
                            && r0 != r2
                        {
                            let fuze_inst = R4type::new(insts::OP_SBBS, r0, r1, r2, r3);
                            let fuze_size = i0_size + i1_size;
                            Ok(Some(set_instruction_length_n(fuze_inst.0, fuze_size)))
                        } else {
                            Ok(None)
                        }
                    };
                if let Ok(Some(i)) = rule_sbb(self, memory) {
                    Ok(i)
                } else if let Ok(Some(i)) = rule_sbbs(self, memory) {
                    Ok(i)
                } else {
                    Ok(head_instruction)
                }
            }
            insts::OP_LUI => {
                let head_inst = Utype(head_instruction);
                let head_size = instruction_length(head_instruction);
                let next_instruction = match self.decode_raw(memory, pc + head_size as u64) {
                    Ok(ni) => ni,
                    Err(_) => return Ok(head_instruction),
                };
                let next_opcode = extract_opcode(next_instruction);
                match next_opcode {
                    insts::OP_JALR_VERSION1 => {
                        let next_inst = Itype(next_instruction);
                        let test_condition = if self.version >= VERSION2 {
                            next_inst.rs1() == head_inst.rd()
                                && next_inst.rd() == RA
                                && next_inst.rs1() == RA
                        } else {
                            next_inst.rs1() == head_inst.rd() && next_inst.rd() == RA
                        };
                        if test_condition {
                            let fuze_imm = head_inst
                                .immediate_s()
                                .wrapping_add(next_inst.immediate_s());
                            let fuze_inst = Utype::new_s(insts::OP_FAR_JUMP_ABS, RA, fuze_imm);
                            let next_size = instruction_length(next_instruction);
                            let fuze_size = head_size + next_size;
                            Ok(set_instruction_length_n(fuze_inst.0, fuze_size))
                        } else {
                            Ok(head_instruction)
                        }
                    }
                    insts::OP_ADDIW => {
                        let next_inst = Itype(next_instruction);
                        if next_inst.rs1() == next_inst.rd() && next_inst.rd() == head_inst.rd() {
                            let fuze_imm = head_inst
                                .immediate_s()
                                .wrapping_add(next_inst.immediate_s());
                            let fuze_inst =
                                Utype::new_s(insts::OP_CUSTOM_LOAD_IMM, head_inst.rd(), fuze_imm);
                            let next_size = instruction_length(next_instruction);
                            let fuze_size = head_size + next_size;
                            Ok(set_instruction_length_n(fuze_inst.0, fuze_size))
                        } else {
                            Ok(head_instruction)
                        }
                    }
                    _ => Ok(head_instruction),
                }
            }
            insts::OP_AUIPC => {
                let head_inst = Utype(head_instruction);
                let head_size = instruction_length(head_instruction);
                let next_instruction = match self.decode_raw(memory, pc + head_size as u64) {
                    Ok(ni) => ni,
                    Err(_) => return Ok(head_instruction),
                };
                let next_opcode = extract_opcode(next_instruction);
                match next_opcode {
                    insts::OP_JALR_VERSION1 => {
                        let next_inst = Itype(next_instruction);
                        let mut result = head_instruction;

                        if self.version >= VERSION2 {
                            if next_inst.rs1() == head_inst.rd()
                                && next_inst.rd() == RA
                                && next_inst.rs1() == RA
                            {
                                if let Some(fuze_imm) =
                                    head_inst.immediate_s().checked_add(next_inst.immediate_s())
                                {
                                    let fuze_inst =
                                        Utype::new_s(insts::OP_FAR_JUMP_REL, RA, fuze_imm);
                                    let next_size = instruction_length(next_instruction);
                                    let fuze_size = head_size + next_size;
                                    result = set_instruction_length_n(fuze_inst.0, fuze_size);
                                }
                            }
                        } else {
                            if next_inst.rs1() == head_inst.rd() && next_inst.rd() == RA {
                                let fuze_imm = head_inst
                                    .immediate_s()
                                    .wrapping_add(next_inst.immediate_s());
                                let fuze_inst = Utype::new_s(insts::OP_FAR_JUMP_REL, RA, fuze_imm);
                                let next_size = instruction_length(next_instruction);
                                let fuze_size = head_size + next_size;
                                result = set_instruction_length_n(fuze_inst.0, fuze_size);
                            }
                        }
                        Ok(result)
                    }
                    insts::OP_ADDI if self.version >= VERSION2 => {
                        let next_inst = Itype(next_instruction);
                        let mut result = head_instruction;

                        if next_inst.rs1() == next_inst.rd() && next_inst.rd() == head_inst.rd() {
                            if let Ok(pc) = i32::try_from(pc) {
                                if let Some(fuze_imm) = head_inst
                                    .immediate_s()
                                    .checked_add(next_inst.immediate_s())
                                    .and_then(|s| s.checked_add(pc))
                                {
                                    let fuze_inst = Utype::new_s(
                                        insts::OP_CUSTOM_LOAD_IMM,
                                        head_inst.rd(),
                                        fuze_imm,
                                    );
                                    let next_size = instruction_length(next_instruction);
                                    let fuze_size = head_size + next_size;
                                    result = set_instruction_length_n(fuze_inst.0, fuze_size);
                                }
                            }
                        }
                        Ok(result)
                    }
                    _ => Ok(head_instruction),
                }
            }
            insts::OP_MULH => {
                let head_inst = Rtype(head_instruction);
                let head_size = instruction_length(head_instruction);
                let next_instruction = match self.decode_raw(memory, pc + head_size as u64) {
                    Ok(ni) => ni,
                    Err(_) => return Ok(head_instruction),
                };
                let next_opcode = extract_opcode(next_instruction);
                match next_opcode {
                    insts::OP_MUL => {
                        let next_inst = Rtype(next_instruction);
                        if head_inst.rd() != head_inst.rs1()
                            && head_inst.rd() != head_inst.rs2()
                            && head_inst.rs1() == next_inst.rs1()
                            && head_inst.rs2() == next_inst.rs2()
                            && head_inst.rd() != next_inst.rd()
                        {
                            let next_size = instruction_length(next_instruction);
                            let fuze_inst = R4type::new(
                                insts::OP_WIDE_MUL,
                                head_inst.rd(),
                                head_inst.rs1(),
                                head_inst.rs2(),
                                next_inst.rd(),
                            );
                            let fuze_size = head_size + next_size;
                            Ok(set_instruction_length_n(fuze_inst.0, fuze_size))
                        } else {
                            Ok(head_instruction)
                        }
                    }
                    _ => Ok(head_instruction),
                }
            }
            insts::OP_MULHU => {
                let head_inst = Rtype(head_instruction);
                let head_size = instruction_length(head_instruction);
                let next_instruction = match self.decode_raw(memory, pc + head_size as u64) {
                    Ok(ni) => ni,
                    Err(_) => return Ok(head_instruction),
                };
                let next_opcode = extract_opcode(next_instruction);
                match next_opcode {
                    insts::OP_MUL => {
                        let next_inst = Rtype(next_instruction);
                        if head_inst.rd() != head_inst.rs1()
                            && head_inst.rd() != head_inst.rs2()
                            && head_inst.rs1() == next_inst.rs1()
                            && head_inst.rs2() == next_inst.rs2()
                            && head_inst.rd() != next_inst.rd()
                        {
                            let next_size = instruction_length(next_instruction);
                            let fuze_inst = R4type::new(
                                insts::OP_WIDE_MULU,
                                head_inst.rd(),
                                head_inst.rs1(),
                                head_inst.rs2(),
                                next_inst.rd(),
                            );
                            let fuze_size = head_size + next_size;
                            Ok(set_instruction_length_n(fuze_inst.0, fuze_size))
                        } else {
                            Ok(head_instruction)
                        }
                    }
                    _ => Ok(head_instruction),
                }
            }
            insts::OP_MULHSU => {
                let head_inst = Rtype(head_instruction);
                let head_size = instruction_length(head_instruction);
                let next_instruction = match self.decode_raw(memory, pc + head_size as u64) {
                    Ok(ni) => ni,
                    Err(_) => return Ok(head_instruction),
                };
                let next_opcode = extract_opcode(next_instruction);
                match next_opcode {
                    insts::OP_MUL => {
                        let next_inst = Rtype(next_instruction);
                        if head_inst.rd() != head_inst.rs1()
                            && head_inst.rd() != head_inst.rs2()
                            && head_inst.rs1() == next_inst.rs1()
                            && head_inst.rs2() == next_inst.rs2()
                            && head_inst.rd() != next_inst.rd()
                        {
                            let next_size = instruction_length(next_instruction);
                            let fuze_inst = R4type::new(
                                insts::OP_WIDE_MULSU,
                                head_inst.rd(),
                                head_inst.rs1(),
                                head_inst.rs2(),
                                next_inst.rd(),
                            );
                            let fuze_size = head_size + next_size;
                            Ok(set_instruction_length_n(fuze_inst.0, fuze_size))
                        } else {
                            Ok(head_instruction)
                        }
                    }
                    _ => Ok(head_instruction),
                }
            }
            insts::OP_DIV => {
                let head_inst = Rtype(head_instruction);
                let head_size = instruction_length(head_instruction);
                let next_instruction = match self.decode_raw(memory, pc + head_size as u64) {
                    Ok(ni) => ni,
                    Err(_) => return Ok(head_instruction),
                };
                let next_opcode = extract_opcode(next_instruction);
                match next_opcode {
                    insts::OP_REM => {
                        let next_inst = Rtype(next_instruction);
                        if head_inst.rd() != head_inst.rs1()
                            && head_inst.rd() != head_inst.rs2()
                            && head_inst.rs1() == next_inst.rs1()
                            && head_inst.rs2() == next_inst.rs2()
                            && head_inst.rd() != next_inst.rd()
                        {
                            let next_size = instruction_length(next_instruction);
                            let fuze_inst = R4type::new(
                                insts::OP_WIDE_DIV,
                                head_inst.rd(),
                                head_inst.rs1(),
                                head_inst.rs2(),
                                next_inst.rd(),
                            );
                            let fuze_size = head_size + next_size;
                            Ok(set_instruction_length_n(fuze_inst.0, fuze_size))
                        } else {
                            Ok(head_instruction)
                        }
                    }
                    _ => Ok(head_instruction),
                }
            }
            insts::OP_DIVU => {
                let head_inst = Rtype(head_instruction);
                let head_size = instruction_length(head_instruction);
                let next_instruction = match self.decode_raw(memory, pc + head_size as u64) {
                    Ok(ni) => ni,
                    Err(_) => return Ok(head_instruction),
                };
                let next_opcode = extract_opcode(next_instruction);
                match next_opcode {
                    insts::OP_REMU => {
                        let next_inst = Rtype(next_instruction);
                        if head_inst.rd() != head_inst.rs1()
                            && head_inst.rd() != head_inst.rs2()
                            && head_inst.rs1() == next_inst.rs1()
                            && head_inst.rs2() == next_inst.rs2()
                            && head_inst.rd() != next_inst.rd()
                        {
                            let next_size = instruction_length(next_instruction);
                            let fuze_inst = R4type::new(
                                insts::OP_WIDE_DIVU,
                                head_inst.rd(),
                                head_inst.rs1(),
                                head_inst.rs2(),
                                next_inst.rd(),
                            );
                            let fuze_size = head_size + next_size;
                            Ok(set_instruction_length_n(fuze_inst.0, fuze_size))
                        } else {
                            Ok(head_instruction)
                        }
                    }
                    _ => Ok(head_instruction),
                }
            }
            _ => Ok(head_instruction),
        }
    }
}

impl InstDecoder for Decoder {
    fn decode<M: Memory>(&mut self, memory: &mut M, pc: u64) -> Result<Instruction, Error> {
        if self.mop {
            self.decode_mop(memory, pc)
        } else {
            self.decode_raw(memory, pc)
        }
    }

    fn reset_instructions_cache(&mut self) -> Result<(), Error> {
        self.instructions_cache = vec![(u64::MAX, 0); INSTRUCTION_CACHE_SIZE];
        Ok(())
    }
}

pub fn build_decoder<R: Register>(isa: u8, version: u32) -> Decoder {
    let mut decoder = Decoder::new(isa & ISA_MOP != 0, version);
    decoder.add_instruction_factory(rvc::factory::<R>);
    decoder.add_instruction_factory(i::factory::<R>);
    decoder.add_instruction_factory(m::factory::<R>);
    if isa & ISA_B != 0 {
        decoder.add_instruction_factory(b::factory::<R>);
    }
    if isa & ISA_A != 0 {
        decoder.add_instruction_factory(a::factory::<R>);
    }
    decoder
}


================================================
File: src/elf.rs
================================================
// This module maps the data structure of different versions of goblin to the
// same internal structure.
use crate::machine::VERSION1;
use crate::memory::{round_page_down, round_page_up, FLAG_EXECUTABLE, FLAG_FREEZED};
use crate::{Error, Register};
use bytes::Bytes;
use scroll::Pread;
use std::ops::Range;

// Even for different versions of goblin, their values must be consistent.
pub use goblin_v023::elf::program_header::{PF_R, PF_W, PF_X, PT_LOAD};
pub use goblin_v023::elf::section_header::SHF_EXECINSTR;

/// Converts goblin's ELF flags into RISC-V flags
pub fn convert_flags(p_flags: u32, allow_freeze_writable: bool, vaddr: u64) -> Result<u8, Error> {
    let readable = p_flags & PF_R != 0;
    let writable = p_flags & PF_W != 0;
    let executable = p_flags & PF_X != 0;
    if !readable {
        return Err(Error::ElfSegmentUnreadable(vaddr));
    }
    if writable && executable {
        return Err(Error::ElfSegmentWritableAndExecutable(vaddr));
    }
    if executable {
        Ok(FLAG_EXECUTABLE | FLAG_FREEZED)
    } else if writable && !allow_freeze_writable {
        Ok(0)
    } else {
        Ok(FLAG_FREEZED)
    }
}

/// Same as goblin::elf::ProgramHeader.
pub struct ProgramHeader {
    pub p_type: u32,
    pub p_flags: u32,
    pub p_offset: u64,
    pub p_vaddr: u64,
    pub p_paddr: u64,
    pub p_filesz: u64,
    pub p_memsz: u64,
    pub p_align: u64,
}

impl ProgramHeader {
    pub fn from_v0(header: &goblin_v023::elf::ProgramHeader) -> Self {
        Self {
            p_type: header.p_type,
            p_flags: header.p_flags,
            p_offset: header.p_offset,
            p_vaddr: header.p_vaddr,
            p_paddr: header.p_paddr,
            p_filesz: header.p_filesz,
            p_memsz: header.p_memsz,
            p_align: header.p_align,
        }
    }

    pub fn from_v1(header: &goblin_v040::elf::ProgramHeader) -> Self {
        Self {
            p_type: header.p_type,
            p_flags: header.p_flags,
            p_offset: header.p_offset,
            p_vaddr: header.p_vaddr,
            p_paddr: header.p_paddr,
            p_filesz: header.p_filesz,
            p_memsz: header.p_memsz,
            p_align: header.p_align,
        }
    }
}

/// Same as goblin::elf::SectionHeader.
pub struct SectionHeader {
    pub sh_name: usize,
    pub sh_type: u32,
    pub sh_flags: u64,
    pub sh_addr: u64,
    pub sh_offset: u64,
    pub sh_size: u64,
    pub sh_link: u32,
    pub sh_info: u32,
    pub sh_addralign: u64,
    pub sh_entsize: u64,
}

impl SectionHeader {
    pub fn from_v0(header: &goblin_v023::elf::SectionHeader) -> Self {
        Self {
            sh_name: header.sh_name,
            sh_type: header.sh_type,
            sh_flags: header.sh_flags,
            sh_addr: header.sh_addr,
            sh_offset: header.sh_offset,
            sh_size: header.sh_size,
            sh_link: header.sh_link,
            sh_info: header.sh_info,
            sh_addralign: header.sh_addralign,
            sh_entsize: header.sh_entsize,
        }
    }

    pub fn from_v1(header: &goblin_v040::elf::SectionHeader) -> Self {
        Self {
            sh_name: header.sh_name,
            sh_type: header.sh_type,
            sh_flags: header.sh_flags,
            sh_addr: header.sh_addr,
            sh_offset: header.sh_offset,
            sh_size: header.sh_size,
            sh_link: header.sh_link,
            sh_info: header.sh_info,
            sh_addralign: header.sh_addralign,
            sh_entsize: header.sh_entsize,
        }
    }
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct LoadingAction {
    pub addr: u64,
    pub size: u64,
    pub flags: u8,
    pub source: Range<u64>,
    pub offset_from_addr: u64,
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct ProgramMetadata {
    pub actions: Vec<LoadingAction>,
    pub entry: u64,
}

pub fn parse_elf<R: Register>(program: &Bytes, version: u32) -> Result<ProgramMetadata, Error> {
    // We did not use Elf::parse here to avoid triggering potential bugs in goblin.
    // * https://github.com/nervosnetwork/ckb-vm/issues/143
    let (entry, program_headers): (u64, Vec<ProgramHeader>) = if version < VERSION1 {
        use goblin_v023::container::Ctx;
        use goblin_v023::elf::{program_header::ProgramHeader as GoblinProgramHeader, Header};
        let header = program.pread::<Header>(0)?;
        let container = header.container().map_err(|_e| Error::ElfBits)?;
        let endianness = header.endianness().map_err(|_e| Error::ElfBits)?;
        if R::BITS != if container.is_big() { 64 } else { 32 } {
            return Err(Error::ElfBits);
        }
        let ctx = Ctx::new(container, endianness);
        let program_headers = GoblinProgramHeader::parse(
            program,
            header.e_phoff as usize,
            header.e_phnum as usize,
            ctx,
        )?
        .iter()
        .map(ProgramHeader::from_v0)
        .collect();
        (header.e_entry, program_headers)
    } else {
        use goblin_v040::container::Ctx;
        use goblin_v040::elf::{program_header::ProgramHeader as GoblinProgramHeader, Header};
        let header = program.pread::<Header>(0)?;
        let container = header.container().map_err(|_e| Error::ElfBits)?;
        let endianness = header.endianness().map_err(|_e| Error::ElfBits)?;
        if R::BITS != if container.is_big() { 64 } else { 32 } {
            return Err(Error::ElfBits);
        }
        let ctx = Ctx::new(container, endianness);
        let program_headers = GoblinProgramHeader::parse(
            program,
            header.e_phoff as usize,
            header.e_phnum as usize,
            ctx,
        )?
        .iter()
        .map(ProgramHeader::from_v1)
        .collect();
        (header.e_entry, program_headers)
    };
    let mut bytes: u64 = 0;
    let mut actions = vec![];
    for program_header in program_headers {
        if program_header.p_type == PT_LOAD {
            let aligned_start = round_page_down(program_header.p_vaddr);
            let padding_start = program_header.p_vaddr.wrapping_sub(aligned_start);
            let size = round_page_up(program_header.p_memsz.wrapping_add(padding_start));
            let slice_start = program_header.p_offset;
            let slice_end = program_header
                .p_offset
                .wrapping_add(program_header.p_filesz);
            if slice_start > slice_end || slice_end > program.len() as u64 {
                return Err(Error::ElfSegmentAddrOrSizeError(program_header.p_vaddr));
            }
            actions.push(LoadingAction {
                addr: aligned_start,
                size,
                flags: convert_flags(
                    program_header.p_flags,
                    version < VERSION1,
                    program_header.p_vaddr,
                )?,
                source: slice_start..slice_end,
                offset_from_addr: padding_start,
            });
            bytes = bytes.checked_add(slice_end - slice_start).ok_or_else(|| {
                Error::Unexpected(String::from("The bytes count overflowed on loading elf"))
            })?;
        }
    }
    Ok(ProgramMetadata { actions, entry })
}


================================================
File: src/error.rs
================================================
#[derive(Debug, PartialEq, Clone, Eq, Display)]
pub enum Error {
    #[display("asm error: {_0}")]
    Asm(u8),
    #[display("cycles error: max cycles exceeded")]
    CyclesExceeded,
    #[display("cycles error: overflow")]
    CyclesOverflow,
    #[display("elf error: bits")]
    ElfBits,
    #[display("elf error: {_0}")]
    ElfParseError(String),
    #[display("elf error: segment is unreadable vaddr=0x{_0:x}")]
    ElfSegmentUnreadable(u64),
    #[display("elf error: segment is writable and executable vaddr=0x{_0:x}")]
    ElfSegmentWritableAndExecutable(u64),
    #[display("elf error: segment addr or size is wrong vaddr=0x{_0:x}")]
    ElfSegmentAddrOrSizeError(u64),
    // When users need to implement traits defined in CKB-VM, they can use
    // this error type to wrap their own errors.
    #[display("external error: {_0}")]
    External(String),
    #[display("invalid syscall {_0}")]
    InvalidEcall(u64),
    #[display("invalid instruction pc=0x{pc:x} instruction=0x{instruction:x}")]
    InvalidInstruction { pc: u64, instruction: u32 },
    #[display("invalid operand {_0}")]
    InvalidOp(u16),
    #[display("invalid version")]
    InvalidVersion,
    #[display("I/O error: {kind:?} {data}")]
    IO {
        kind: std::io::ErrorKind,
        data: String,
    },
    #[display("memory error: out of bound addr=0x{_0:x}, kind={_1:?}")]
    MemOutOfBound(u64, OutOfBoundKind),
    #[display("memory error: out of stack")]
    MemOutOfStack,
    #[display("memory error: unaligned page access addr=0x{_0:x}")]
    MemPageUnalignedAccess(u64),
    #[display("memory error: write on executable page page_index={_0}")]
    MemWriteOnExecutablePage(u64),
    #[display("memory error: write on freezed page page_index={_0}")]
    MemWriteOnFreezedPage(u64),
    #[display("pause")]
    Pause,
    #[display("snapshot data load error")]
    SnapshotDataLoadError,
    #[display("unexpected error")]
    Unexpected(String),
    #[display("yield")]
    Yield,
}

#[derive(Debug, PartialEq, Clone, Eq, Display)]
pub enum OutOfBoundKind {
    Memory,
    ExternalData,
}

impl std::error::Error for Error {}

impl From<std::io::Error> for Error {
    fn from(error: std::io::Error) -> Self {
        Error::IO {
            kind: error.kind(),
            data: error.to_string(),
        }
    }
}

impl From<goblin_v023::error::Error> for Error {
    fn from(error: goblin_v023::error::Error) -> Self {
        Error::ElfParseError(error.to_string())
    }
}

impl From<goblin_v040::error::Error> for Error {
    fn from(error: goblin_v040::error::Error) -> Self {
        Error::ElfParseError(error.to_string())
    }
}


================================================
File: src/lib.rs
================================================
#[macro_use]
extern crate derive_more;

pub mod bits;
pub mod cost_model;
pub mod debugger;
pub mod decoder;
pub mod elf;
pub mod error;
pub mod instructions;
pub mod machine;
pub mod memory;
pub mod snapshot;
pub mod snapshot2;
pub mod syscalls;

pub use bytes;
pub use ckb_vm_definitions;

pub use crate::{
    debugger::Debugger,
    instructions::{Instruction, Register},
    machine::{
        trace::TraceMachine, CoreMachine, DefaultCoreMachine, DefaultMachine,
        DefaultMachineBuilder, FlattenedArgsReader, InstructionCycleFunc, Machine, SupportMachine,
    },
    memory::{flat::FlatMemory, sparse::SparseMemory, wxorx::WXorXMemory, Memory},
    syscalls::Syscalls,
};
pub use bytes::Bytes;

pub use ckb_vm_definitions::{
    registers, DEFAULT_MEMORY_SIZE, ISA_A, ISA_B, ISA_IMC, ISA_MOP, MEMORY_FRAMESIZE,
    MEMORY_FRAME_SHIFTS, RISCV_GENERAL_REGISTER_NUMBER, RISCV_PAGESIZE, RISCV_PAGE_SHIFTS,
};

pub use error::Error;

pub fn run<R: Register, M: Memory<REG = R> + Default>(
    program: &Bytes,
    args: &[Bytes],
) -> Result<i8, Error> {
    let core_machine = DefaultCoreMachine::<R, WXorXMemory<M>>::new_with_memory(
        ISA_IMC | ISA_B | ISA_MOP,
        machine::VERSION2,
        u64::MAX,
        WXorXMemory::new(M::default()),
    );
    let mut machine = TraceMachine::new(DefaultMachineBuilder::new(core_machine).build());
    machine.load_program(program, args.iter().map(|e| Ok(e.clone())))?;
    machine.run()
}

pub fn run_with_memory<R: Register, M: Memory<REG = R>>(
    program: &Bytes,
    args: &[Bytes],
    memory: M,
) -> Result<i8, Error> {
    let core_machine = DefaultCoreMachine::<R, WXorXMemory<M>>::new_with_memory(
        ISA_IMC | ISA_B | ISA_MOP,
        machine::VERSION2,
        u64::MAX,
        WXorXMemory::new(memory),
    );
    let mut machine = TraceMachine::new(DefaultMachineBuilder::new(core_machine).build());
    machine.load_program(program, args.iter().map(|e| Ok(e.clone())))?;
    machine.run()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_max_memory_must_be_multiple_of_pages() {
        assert_eq!(DEFAULT_MEMORY_SIZE % RISCV_PAGESIZE, 0);
    }

    #[test]
    fn test_page_size_be_power_of_2() {
        assert!(RISCV_PAGESIZE.is_power_of_two());
    }
}


================================================
File: src/snapshot.rs
================================================
use crate::instructions::Register;
use crate::memory::Memory;
use crate::memory::FLAG_DIRTY;
use crate::{CoreMachine, Error, RISCV_GENERAL_REGISTER_NUMBER, RISCV_PAGESIZE, RISCV_PAGE_SHIFTS};
use serde::{Deserialize, Serialize};

// Snapshot provides a mechanism for suspending and resuming a virtual machine.
//
// When cycle limit is too low, our work won't be finished when we hit it and
// a "max cycles exceeded" error will be returned. At this time, a snapshot could
// be created, we can create a new virtual machine from this snapshot, provide
// more cycles and then continue to run it.
//
// For the following data, we simply save them, and then restore them.
//   - machine.version
//   - machine.pc
//   - machine.registers
//
// For memory, the situation becomes more complicated. Every memory page has
// page flag where each page flag stores a optional FLAG_DIRTY. When this page
// is wrote, the memory instance will set this bit to 1, this helps us keep
// track of those pages that have been modified. After `machine.load_elf`, We
// clean up all dirty flags, so after the program terminates, all pages marked
// as dirty are the pages that have been modified by the program. We only store
// these pages in the snapshot.

#[derive(Default, Deserialize, Serialize)]
pub struct Snapshot {
    pub version: u32,
    pub registers: [u64; RISCV_GENERAL_REGISTER_NUMBER],
    pub pc: u64,
    pub page_indices: Vec<u64>,
    pub page_flags: Vec<u8>,
    pub pages: Vec<Vec<u8>>,
    pub load_reservation_address: u64,
}

pub fn make_snapshot<T: CoreMachine>(machine: &mut T) -> Result<Snapshot, Error> {
    let mut snap = Snapshot {
        version: machine.version(),
        pc: machine.pc().to_u64(),
        load_reservation_address: machine.memory().lr().to_u64(),
        ..Default::default()
    };
    for (i, v) in machine.registers().iter().enumerate() {
        snap.registers[i] = v.to_u64();
    }

    for i in 0..machine.memory().memory_pages() {
        let flag = machine.memory_mut().fetch_flag(i as u64)?;
        if flag & FLAG_DIRTY != 0 {
            let addr_from = i << RISCV_PAGE_SHIFTS;
            let addr_to = (i + 1) << RISCV_PAGE_SHIFTS;

            let mut page = vec![0; RISCV_PAGESIZE];
            for i in (addr_from..addr_to).step_by(8) {
                let v64 = machine
                    .memory_mut()
                    .load64(&T::REG::from_u64(i as u64))?
                    .to_u64();
                let j = i - addr_from;
                page[j] = v64 as u8;
                page[j + 1] = (v64 >> 8) as u8;
                page[j + 2] = (v64 >> 16) as u8;
                page[j + 3] = (v64 >> 24) as u8;
                page[j + 4] = (v64 >> 32) as u8;
                page[j + 5] = (v64 >> 40) as u8;
                page[j + 6] = (v64 >> 48) as u8;
                page[j + 7] = (v64 >> 56) as u8;
            }

            snap.page_indices.push(i as u64);
            snap.page_flags.push(flag);
            snap.pages.push(page);
        }
    }
    Ok(snap)
}

pub fn resume<T: CoreMachine>(machine: &mut T, snapshot: &Snapshot) -> Result<(), Error> {
    if machine.version() != snapshot.version {
        return Err(Error::InvalidVersion);
    }
    for (i, v) in snapshot.registers.iter().enumerate() {
        machine.set_register(i, T::REG::from_u64(*v));
    }
    machine.update_pc(T::REG::from_u64(snapshot.pc));
    machine.commit_pc();
    for i in 0..snapshot.page_indices.len() {
        let page_index = snapshot.page_indices[i];
        let page_flag = snapshot.page_flags[i];
        let page = &snapshot.pages[i];
        let addr_from = page_index << RISCV_PAGE_SHIFTS;
        machine.memory_mut().store_bytes(addr_from, &page[..])?;
        machine.memory_mut().set_flag(page_index, page_flag)?;
    }
    machine
        .memory_mut()
        .set_lr(&T::REG::from_u64(snapshot.load_reservation_address));
    Ok(())
}


================================================
File: src/snapshot2.rs
================================================
use crate::{
    bits::roundup,
    elf::{LoadingAction, ProgramMetadata},
    machine::SupportMachine,
    memory::{get_page_indices, Memory, FLAG_DIRTY},
    Error, Register, RISCV_GENERAL_REGISTER_NUMBER, RISCV_PAGESIZE,
};
use bytes::Bytes;
use serde::{Deserialize, Serialize};
use std::cmp::min;
use std::collections::HashMap;

const PAGE_SIZE: u64 = RISCV_PAGESIZE as u64;

/// DataSource represents data source that can stay stable and possibly
/// immutable for the entire lifecycle duration of a VM instance. One example
/// can be the enclosing transaction when using CKB-VM in CKB's environment,
/// no matter where and when we run the CKB smart contract, the enclosing
/// transaction will always be the same down to every last byte. As a result,
/// we can leverage DataSource for snapshot optimizations: data that is already
/// locatable in the DataSource will not need to be included in the snapshot
/// again, all we need is an id to locate it, together with a pair of
/// offset / length to cut in to the correct slices. Just like CKB's syscall design,
/// an extra u64 value is included here to return the remaining full length of data
/// starting from offset, without considering `length` parameter
pub trait DataSource<I: Clone + PartialEq> {
    fn load_data(&self, id: &I, offset: u64, length: u64) -> Option<(Bytes, u64)>;
}

#[derive(Clone, Debug)]
pub struct Snapshot2Context<I: Clone + PartialEq, D: DataSource<I>> {
    // page index -> (id, offset, flag)
    pages: HashMap<u64, (I, u64, u8)>,
    data_source: D,
}

impl<I: Clone + PartialEq, D: DataSource<I> + Default> Default for Snapshot2Context<I, D> {
    fn default() -> Self {
        Self::new(D::default())
    }
}

impl<I: Clone + PartialEq, D: DataSource<I>> Snapshot2Context<I, D> {
    pub fn new(data_source: D) -> Self {
        Self {
            pages: HashMap::default(),
            data_source,
        }
    }

    /// Resume a previously suspended machine from snapshot.
    pub fn resume<M: SupportMachine>(
        &mut self,
        machine: &mut M,
        snapshot: &Snapshot2<I>,
    ) -> Result<(), Error> {
        if machine.version() != snapshot.version {
            return Err(Error::InvalidVersion);
        }
        // A resume basically means we reside in a new context
        self.pages.clear();
        for (i, v) in snapshot.registers.iter().enumerate() {
            machine.set_register(i, M::REG::from_u64(*v));
        }
        machine.update_pc(M::REG::from_u64(snapshot.pc));
        machine.commit_pc();
        machine.set_cycles(snapshot.cycles);
        machine.set_max_cycles(snapshot.max_cycles);
        for (address, flag, id, offset, length) in &snapshot.pages_from_source {
            if address % PAGE_SIZE != 0 {
                return Err(Error::MemPageUnalignedAccess(*address));
            }
            let (data, _) = self.load_data(id, *offset, *length)?;
            if data.len() as u64 % PAGE_SIZE != 0 {
                return Err(Error::MemPageUnalignedAccess(
                    address.wrapping_add(data.len() as u64),
                ));
            }
            machine.memory_mut().store_bytes(*address, &data)?;
            for i in 0..(data.len() as u64 / PAGE_SIZE) {
                let page = address / PAGE_SIZE + i;
                machine.memory_mut().set_flag(page, *flag)?;
            }
            self.track_pages(machine, *address, data.len() as u64, id, *offset)?;
        }
        for (address, flag, content) in &snapshot.dirty_pages {
            if address % PAGE_SIZE != 0 {
                return Err(Error::MemPageUnalignedAccess(*address));
            }
            if content.len() as u64 % PAGE_SIZE != 0 {
                return Err(Error::MemPageUnalignedAccess(
                    address.wrapping_add(content.len() as u64),
                ));
            }
            machine.memory_mut().store_bytes(*address, content)?;
            for i in 0..(content.len() as u64 / PAGE_SIZE) {
                let page = address / PAGE_SIZE + i;
                machine.memory_mut().set_flag(page, *flag)?;
            }
        }
        machine
            .memory_mut()
            .set_lr(&M::REG::from_u64(snapshot.load_reservation_address));
        Ok(())
    }

    pub fn load_data(&self, id: &I, offset: u64, length: u64) -> Result<(Bytes, u64), Error> {
        self.data_source
            .load_data(id, offset, length)
            .ok_or(Error::SnapshotDataLoadError)
    }

    /// Similar to Memory::store_bytes, but this method also tracks memory
    /// pages whose entire content comes from DataSource. It returns 2 values:
    /// the actual written bytes, and the full length of data starting from offset,
    /// but ignoring `length` parameter.
    pub fn store_bytes<M: SupportMachine>(
        &mut self,
        machine: &mut M,
        addr: u64,
        id: &I,
        offset: u64,
        length: u64,
        size_addr: u64,
    ) -> Result<(u64, u64), Error> {
        let (data, full_length) = self.load_data(id, offset, length)?;
        machine
            .memory_mut()
            .store64(&M::REG::from_u64(size_addr), &M::REG::from_u64(full_length))?;
        self.untrack_pages(machine, addr, data.len() as u64)?;
        machine.memory_mut().store_bytes(addr, &data)?;
        self.track_pages(machine, addr, data.len() as u64, id, offset)?;
        Ok((data.len() as u64, full_length))
    }

    /// Due to the design of ckb-vm right now, load_program function does not
    /// belong to SupportMachine yet. For Snapshot2Context to track memory pages
    /// from program in DataSource, we have to use the following steps now:
    ///
    /// 1. use elf::parse_elf to generate ProgramMetadata
    /// 2. use DefaultMachine::load_program_with_metadata to load the program
    /// 3. Pass ProgramMetadata to this method so we can track memory pages from
    ///     program, so as to further reduce the size of the generated snapshot.
    ///
    /// One can also use the original DefaultMachine::load_program, and parse the
    /// ELF a second time to extract metadata for this method. However the above
    /// listed process saves us the time to parse the ELF again.
    pub fn mark_program<M: SupportMachine>(
        &mut self,
        machine: &mut M,
        metadata: &ProgramMetadata,
        id: &I,
        offset: u64,
    ) -> Result<(), Error> {
        for action in &metadata.actions {
            self.init_pages(machine, action, id, offset)?;
        }
        Ok(())
    }

    /// Create a snapshot for the passed machine.
    pub fn make_snapshot<M: SupportMachine>(&self, machine: &mut M) -> Result<Snapshot2<I>, Error> {
        let mut dirty_pages: Vec<(u64, u8, Vec<u8>)> = vec![];
        for i in 0..machine.memory().memory_pages() as u64 {
            let flag = machine.memory_mut().fetch_flag(i)?;
            if flag & FLAG_DIRTY == 0 {
                continue;
            }
            let address = i * PAGE_SIZE;
            let mut data: Vec<u8> = machine.memory_mut().load_bytes(address, PAGE_SIZE)?.into();
            if let Some(last) = dirty_pages.last_mut() {
                if last.0 + last.2.len() as u64 == address && last.1 == flag {
                    last.2.append(&mut data);
                }
            }
            if !data.is_empty() {
                dirty_pages.push((address, flag, data));
            }
        }
        let mut pages_from_source: Vec<(u64, u8, I, u64, u64)> = vec![];
        let mut pages: Vec<u64> = self.pages.keys().copied().collect();
        pages.sort_unstable();
        for page in pages {
            // Some pages might be marked as cached pages from data source, but receives
            // memory writes later(and marked as dirty). We are safely skipping those pages
            // here as they will be gathered as dirty pages.
            if machine.memory_mut().fetch_flag(page)? & FLAG_DIRTY != 0 {
                continue;
            }
            let address = page * PAGE_SIZE;
            let (id, offset, flag) = &self.pages[&page];
            let mut appended_to_last = false;
            if let Some((last_address, last_flag, last_id, last_offset, last_length)) =
                pages_from_source.last_mut()
            {
                if *last_address + *last_length == address
                    && *last_flag == *flag
                    && *last_id == *id
                    && *last_offset + *last_length == *offset
                {
                    *last_length += PAGE_SIZE;
                    appended_to_last = true;
                }
            }
            if !appended_to_last {
                pages_from_source.push((address, *flag, id.clone(), *offset, PAGE_SIZE));
            }
        }
        let mut registers = [0u64; RISCV_GENERAL_REGISTER_NUMBER];
        for (i, v) in machine.registers().iter().enumerate() {
            registers[i] = v.to_u64();
        }
        Ok(Snapshot2 {
            pages_from_source,
            dirty_pages,
            version: machine.version(),
            registers,
            pc: machine.pc().to_u64(),
            cycles: machine.cycles(),
            max_cycles: machine.max_cycles(),
            load_reservation_address: machine.memory().lr().to_u64(),
        })
    }

    fn init_pages<M: SupportMachine>(
        &mut self,
        machine: &mut M,
        action: &LoadingAction,
        id: &I,
        offset: u64,
    ) -> Result<(), Error> {
        let start = action.addr + action.offset_from_addr;
        let length = min(
            action.source.end - action.source.start,
            action.size - action.offset_from_addr,
        );
        self.track_pages(machine, start, length, id, offset + action.source.start)
    }

    /// The followings are only made public for advanced usages, but make sure to exercise more
    /// cautions when calling it!
    pub fn track_pages<M: SupportMachine>(
        &mut self,
        machine: &mut M,
        start: u64,
        mut length: u64,
        id: &I,
        mut offset: u64,
    ) -> Result<(), Error> {
        let mut aligned_start = roundup(start, PAGE_SIZE);
        let aligned_bytes = aligned_start - start;
        if length < aligned_bytes {
            return Ok(());
        }
        offset += aligned_bytes;
        length -= aligned_bytes;
        while length >= PAGE_SIZE {
            let page = aligned_start / PAGE_SIZE;
            machine.memory_mut().clear_flag(page, FLAG_DIRTY)?;
            let flag = machine.memory_mut().fetch_flag(page)?;
            self.pages.insert(page, (id.clone(), offset, flag));
            aligned_start += PAGE_SIZE;
            length -= PAGE_SIZE;
            offset += PAGE_SIZE;
        }
        Ok(())
    }

    pub fn untrack_pages<M: SupportMachine>(
        &mut self,
        machine: &mut M,
        start: u64,
        length: u64,
    ) -> Result<(), Error> {
        if length == 0 {
            return Ok(());
        }
        let page_indices = get_page_indices(start, length);
        for page in page_indices.0..=page_indices.1 {
            machine.memory_mut().set_flag(page, FLAG_DIRTY)?;
            self.pages.remove(&page);
        }
        Ok(())
    }
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Snapshot2<I: Clone + PartialEq> {
    // (address, flag, id, source offset, source length)
    pub pages_from_source: Vec<(u64, u8, I, u64, u64)>,
    // (address, flag, content)
    pub dirty_pages: Vec<(u64, u8, Vec<u8>)>,
    pub version: u32,
    pub registers: [u64; RISCV_GENERAL_REGISTER_NUMBER],
    pub pc: u64,
    pub cycles: u64,
    pub max_cycles: u64,
    pub load_reservation_address: u64,
}


================================================
File: src/instructions/a.rs
================================================
use ckb_vm_definitions::instructions as insts;

use super::utils::{funct3, funct7, opcode, rd, rs1, rs2};
use super::{set_instruction_length_4, Instruction, Register, Rtype};

pub fn factory<R: Register>(instruction_bits: u32, _: u32) -> Option<Instruction> {
    let bit_length = R::BITS;
    if bit_length != 32 && bit_length != 64 {
        return None;
    }
    let rv64 = bit_length == 64;
    if opcode(instruction_bits) != 0b_0101111 {
        return None;
    }
    let f7 = funct7(instruction_bits);
    let f5 = f7 >> 2;
    let f3 = funct3(instruction_bits);
    let match_rv32 = || match (f3, f5) {
        (0b010, 0b00010) => {
            if rs2(instruction_bits) == 0 {
                Some(insts::OP_LR_W)
            } else {
                None
            }
        }
        (0b010, 0b00011) => Some(insts::OP_SC_W),
        (0b010, 0b00001) => Some(insts::OP_AMOSWAP_W),
        (0b010, 0b00000) => Some(insts::OP_AMOADD_W),
        (0b010, 0b00100) => Some(insts::OP_AMOXOR_W),
        (0b010, 0b01100) => Some(insts::OP_AMOAND_W),
        (0b010, 0b01000) => Some(insts::OP_AMOOR_W),
        (0b010, 0b10000) => Some(insts::OP_AMOMIN_W),
        (0b010, 0b10100) => Some(insts::OP_AMOMAX_W),
        (0b010, 0b11000) => Some(insts::OP_AMOMINU_W),
        (0b010, 0b11100) => Some(insts::OP_AMOMAXU_W),
        _ => None,
    };
    let match_rv64 = || match (f3, f5) {
        (0b011, 0b00010) => {
            if rs2(instruction_bits) == 0 {
                Some(insts::OP_LR_D)
            } else {
                None
            }
        }
        (0b011, 0b00011) => Some(insts::OP_SC_D),
        (0b011, 0b00001) => Some(insts::OP_AMOSWAP_D),
        (0b011, 0b00000) => Some(insts::OP_AMOADD_D),
        (0b011, 0b00100) => Some(insts::OP_AMOXOR_D),
        (0b011, 0b01100) => Some(insts::OP_AMOAND_D),
        (0b011, 0b01000) => Some(insts::OP_AMOOR_D),
        (0b011, 0b10000) => Some(insts::OP_AMOMIN_D),
        (0b011, 0b10100) => Some(insts::OP_AMOMAX_D),
        (0b011, 0b11000) => Some(insts::OP_AMOMINU_D),
        (0b011, 0b11100) => Some(insts::OP_AMOMAXU_D),
        _ => None,
    };
    let inst_opt = if rv64 {
        match_rv32().or_else(match_rv64)
    } else {
        match_rv32()
    };
    inst_opt
        .map(|inst| {
            Rtype::new(
                inst,
                rd(instruction_bits),
                rs1(instruction_bits),
                rs2(instruction_bits),
            )
            .0
        })
        .map(set_instruction_length_4)
}


================================================
File: src/instructions/ast.rs
================================================
use crate::Register;
use std::fmt::{self, Display};
use std::ops::{BitAnd, BitOr, BitXor, Not, Shl, Shr};
use std::rc::Rc;

#[derive(Debug, Clone, Copy)]
pub enum ActionOp1 {
    Not,
    LogicalNot,
    Clz,
    Ctz,
    Cpop,
    Orcb,
    Rev8,
}

#[derive(Debug, Clone, Copy)]
pub enum ActionOp2 {
    Add,
    Sub,
    Mul,
    Mulhsu,
    Bitand,
    Bitor,
    Bitxor,
    Shl,
    Eq,
    Clmul,
    Clmulh,
    Clmulr,
    Rol,
    Ror,
}

#[derive(Debug, Clone, Copy)]
pub enum SignActionOp2 {
    Mulh,
    Div,
    Rem,
    Shr,
    Lt,
    Extend,
}

#[derive(Debug, Clone)]
pub enum Value {
    Lr,
    Imm(u64),
    Register(usize),
    Op1(ActionOp1, Rc<Value>),
    Op2(ActionOp2, Rc<Value>, Rc<Value>),
    SignOp2(SignActionOp2, Rc<Value>, Rc<Value>, bool),
    Cond(Rc<Value>, Rc<Value>, Rc<Value>),
    Load(Rc<Value>, u8),
    External(Rc<Value>, u64),
}

impl Default for Value {
    fn default() -> Value {
        Value::zero()
    }
}

impl Display for Value {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}

impl Not for Value {
    type Output = Self;

    fn not(self) -> Value {
        if let Value::Imm(imm) = self {
            return Value::Imm(!imm);
        }
        Value::Op1(ActionOp1::Not, Rc::new(self))
    }
}

impl BitAnd for Value {
    type Output = Self;

    fn bitand(self, rhs: Self) -> Value {
        if let (Value::Imm(imm1), Value::Imm(imm2)) = (&self, &rhs) {
            return Value::Imm(imm1 & imm2);
        }
        Value::Op2(ActionOp2::Bitand, Rc::new(self), Rc::new(rhs))
    }
}

impl BitOr for Value {
    type Output = Self;

    fn bitor(self, rhs: Self) -> Value {
        if let (Value::Imm(imm1), Value::Imm(imm2)) = (&self, &rhs) {
            return Value::Imm(imm1 | imm2);
        }
        Value::Op2(ActionOp2::Bitor, Rc::new(self), Rc::new(rhs))
    }
}

impl BitXor for Value {
    type Output = Self;

    fn bitxor(self, rhs: Self) -> Value {
        if let (Value::Imm(imm1), Value::Imm(imm2)) = (&self, &rhs) {
            return Value::Imm(imm1 ^ imm2);
        }
        Value::Op2(ActionOp2::Bitxor, Rc::new(self), Rc::new(rhs))
    }
}

impl Shl<Value> for Value {
    type Output = Self;

    fn shl(self, rhs: Self) -> Value {
        if let (Value::Imm(imm1), Value::Imm(imm2)) = (&self, &rhs) {
            // By default immediates are unsigned
            return Value::Imm(imm1 << imm2);
        }
        Value::Op2(ActionOp2::Shl, Rc::new(self), Rc::new(rhs))
    }
}

impl Shr<Value> for Value {
    type Output = Self;

    fn shr(self, rhs: Self) -> Value {
        if let (Value::Imm(imm1), Value::Imm(imm2)) = (&self, &rhs) {
            // By default immediates are unsigned
            return Value::Imm(imm1 >> imm2);
        }
        Value::SignOp2(SignActionOp2::Shr, Rc::new(self), Rc::new(rhs), false)
    }
}

impl Register for Value {
    // For now we only support JIT on 64 bit RISC-V machine
    const BITS: u8 = 64;
    const SHIFT_MASK: u8 = 0x3F;

    fn zero() -> Value {
        Value::Imm(0)
    }

    fn one() -> Value {
        Value::Imm(1)
    }

    fn min_value() -> Value {
        Value::Imm(u64::MIN)
    }

    fn max_value() -> Value {
        Value::Imm(u64::MAX)
    }

    fn eq(&self, other: &Value) -> Value {
        Value::Op2(ActionOp2::Eq, Rc::new(self.clone()), Rc::new(other.clone()))
    }

    fn lt(&self, other: &Value) -> Value {
        Value::SignOp2(
            SignActionOp2::Lt,
            Rc::new(self.clone()),
            Rc::new(other.clone()),
            false,
        )
    }

    fn lt_s(&self, other: &Value) -> Value {
        Value::SignOp2(
            SignActionOp2::Lt,
            Rc::new(self.clone()),
            Rc::new(other.clone()),
            true,
        )
    }

    fn logical_not(&self) -> Value {
        Value::Op1(ActionOp1::LogicalNot, Rc::new(self.clone()))
    }

    fn cond(&self, true_value: &Value, false_value: &Value) -> Value {
        Value::Cond(
            Rc::new(self.clone()),
            Rc::new(true_value.clone()),
            Rc::new(false_value.clone()),
        )
    }

    fn overflowing_add(&self, rhs: &Value) -> Value {
        if let (Value::Imm(imm1), Value::Imm(imm2)) = (self, rhs) {
            let imm = (*imm1).overflowing_add(*imm2).0;
            return Value::Imm(imm);
        }
        Value::Op2(ActionOp2::Add, Rc::new(self.clone()), Rc::new(rhs.clone()))
    }

    fn overflowing_sub(&self, rhs: &Value) -> Value {
        if let (Value::Imm(imm1), Value::Imm(imm2)) = (self, rhs) {
            let imm = (*imm1).overflowing_sub(*imm2).0;
            return Value::Imm(imm);
        }
        Value::Op2(ActionOp2::Sub, Rc::new(self.clone()), Rc::new(rhs.clone()))
    }

    fn overflowing_mul(&self, rhs: &Value) -> Value {
        Value::Op2(ActionOp2::Mul, Rc::new(self.clone()), Rc::new(rhs.clone()))
    }

    fn overflowing_div(&self, rhs: &Value) -> Value {
        Value::SignOp2(
            SignActionOp2::Div,
            Rc::new(self.clone()),
            Rc::new(rhs.clone()),
            false,
        )
    }

    fn overflowing_rem(&self, rhs: &Value) -> Value {
        Value::SignOp2(
            SignActionOp2::Rem,
            Rc::new(self.clone()),
            Rc::new(rhs.clone()),
            false,
        )
    }

    fn overflowing_div_signed(&self, rhs: &Value) -> Value {
        Value::SignOp2(
            SignActionOp2::Div,
            Rc::new(self.clone()),
            Rc::new(rhs.clone()),
            true,
        )
    }

    fn overflowing_rem_signed(&self, rhs: &Value) -> Value {
        Value::SignOp2(
            SignActionOp2::Rem,
            Rc::new(self.clone()),
            Rc::new(rhs.clone()),
            true,
        )
    }

    fn overflowing_mul_high_signed(&self, rhs: &Value) -> Value {
        Value::SignOp2(
            SignActionOp2::Mulh,
            Rc::new(self.clone()),
            Rc::new(rhs.clone()),
            true,
        )
    }

    fn overflowing_mul_high_unsigned(&self, rhs: &Value) -> Value {
        Value::SignOp2(
            SignActionOp2::Mulh,
            Rc::new(self.clone()),
            Rc::new(rhs.clone()),
            false,
        )
    }

    fn overflowing_mul_high_signed_unsigned(&self, rhs: &Value) -> Value {
        Value::Op2(
            ActionOp2::Mulhsu,
            Rc::new(self.clone()),
            Rc::new(rhs.clone()),
        )
    }

    fn clz(&self) -> Value {
        Value::Op1(ActionOp1::Clz, Rc::new(self.clone()))
    }

    fn ctz(&self) -> Value {
        Value::Op1(ActionOp1::Ctz, Rc::new(self.clone()))
    }

    fn cpop(&self) -> Value {
        Value::Op1(ActionOp1::Cpop, Rc::new(self.clone()))
    }

    fn clmul(&self, rhs: &Value) -> Value {
        if let (Value::Imm(imm1), Value::Imm(imm2)) = (self, rhs) {
            return Value::Imm(imm1.clmul(imm2));
        }
        Value::Op2(
            ActionOp2::Clmul,
            Rc::new(self.clone()),
            Rc::new(rhs.clone()),
        )
    }

    fn clmulh(&self, rhs: &Value) -> Value {
        if let (Value::Imm(imm1), Value::Imm(imm2)) = (self, rhs) {
            return Value::Imm(imm1.clmulh(imm2));
        }
        Value::Op2(
            ActionOp2::Clmulh,
            Rc::new(self.clone()),
            Rc::new(rhs.clone()),
        )
    }

    fn clmulr(&self, rhs: &Value) -> Value {
        if let (Value::Imm(imm1), Value::Imm(imm2)) = (self, rhs) {
            return Value::Imm(imm1.clmulr(imm2));
        }
        Value::Op2(
            ActionOp2::Clmulr,
            Rc::new(self.clone()),
            Rc::new(rhs.clone()),
        )
    }

    fn orcb(&self) -> Self {
        if let Value::Imm(imm1) = self {
            return Value::Imm(imm1.orcb());
        }
        Value::Op1(ActionOp1::Orcb, Rc::new(self.clone()))
    }

    fn rev8(&self) -> Self {
        if let Value::Imm(imm1) = self {
            return Value::Imm(imm1.rev8());
        }
        Value::Op1(ActionOp1::Rev8, Rc::new(self.clone()))
    }

    fn rol(&self, rhs: &Value) -> Value {
        if let (Value::Imm(imm1), Value::Imm(imm2)) = (self, rhs) {
            return Value::Imm(imm1.rotate_left(*imm2 as u32));
        }
        Value::Op2(ActionOp2::Rol, Rc::new(self.clone()), Rc::new(rhs.clone()))
    }

    fn ror(&self, rhs: &Value) -> Value {
        if let (Value::Imm(imm1), Value::Imm(imm2)) = (self, rhs) {
            return Value::Imm(imm1.rotate_right(*imm2 as u32));
        }
        Value::Op2(ActionOp2::Ror, Rc::new(self.clone()), Rc::new(rhs.clone()))
    }

    fn signed_shl(&self, rhs: &Value) -> Value {
        // Signed shl and unsigned shl are the same thing
        self.clone().shl(rhs.clone())
    }

    fn signed_shr(&self, rhs: &Value) -> Value {
        if let (Value::Imm(imm1), Value::Imm(imm2)) = (self, rhs) {
            // By default immediates are unsigned
            return Value::Imm(((*imm1 as i64) >> imm2) as u64);
        }
        Value::SignOp2(
            SignActionOp2::Shr,
            Rc::new(self.clone()),
            Rc::new(rhs.clone()),
            true,
        )
    }

    fn zero_extend(&self, start_bit: &Value) -> Value {
        Value::SignOp2(
            SignActionOp2::Extend,
            Rc::new(self.clone()),
            Rc::new(start_bit.clone()),
            false,
        )
    }

    fn sign_extend(&self, start_bit: &Value) -> Value {
        Value::SignOp2(
            SignActionOp2::Extend,
            Rc::new(self.clone()),
            Rc::new(start_bit.clone()),
            true,
        )
    }

    fn to_i8(&self) -> i8 {
        0
    }

    fn to_i16(&self) -> i16 {
        0
    }

    fn to_i32(&self) -> i32 {
        0
    }

    fn to_i64(&self) -> i64 {
        0
    }

    fn to_u8(&self) -> u8 {
        0
    }

    fn to_u16(&self) -> u16 {
        0
    }

    fn to_u32(&self) -> u32 {
        0
    }

    fn to_u64(&self) -> u64 {
        0
    }

    fn from_i8(v: i8) -> Value {
        Value::Imm(i64::from(v) as u64)
    }

    fn from_i16(v: i16) -> Value {
        Value::Imm(i64::from(v) as u64)
    }

    fn from_i32(v: i32) -> Value {
        Value::Imm(i64::from(v) as u64)
    }

    fn from_i64(v: i64) -> Value {
        Value::Imm(v as u64)
    }

    fn from_u8(v: u8) -> Value {
        Value::Imm(u64::from(v))
    }

    fn from_u16(v: u16) -> Value {
        Value::Imm(u64::from(v))
    }

    fn from_u32(v: u32) -> Value {
        Value::Imm(u64::from(v))
    }

    fn from_u64(v: u64) -> Value {
        Value::Imm(v)
    }
}


================================================
File: src/instructions/b.rs
================================================
// RISC-V Bitmanip (Bit Manipulation) Extension
// See https://github.com/riscv/riscv-bitmanip/releases/download/1.0.0/bitmanip-1.0.0.pdf

use ckb_vm_definitions::instructions as insts;

use super::utils::{self, funct3, funct7, opcode, rd, rs1, rs2};
use super::{set_instruction_length_4, Instruction, Itype, Register, Rtype};

pub fn factory<R: Register>(instruction_bits: u32, _: u32) -> Option<Instruction> {
    let bit_length = R::BITS;
    if bit_length != 32 && bit_length != 64 {
        return None;
    }
    let rv64 = bit_length == 64;
    let inst = match opcode(instruction_bits) {
        0b_0111011 => {
            let funct3_value = funct3(instruction_bits);
            let funct7_value = funct7(instruction_bits);
            let inst_opt = match (funct3_value, funct7_value) {
                (0b_000, 0b_0000100) => Some(insts::OP_ADDUW),
                (0b_001, 0b_0110000) => Some(insts::OP_ROLW),
                (0b_010, 0b_0010000) => Some(insts::OP_SH1ADDUW),
                (0b_100, 0b_0000100) => {
                    if rv64 && rs2(instruction_bits) == 0 {
                        Some(insts::OP_ZEXTH)
                    } else {
                        None
                    }
                }
                (0b_100, 0b_0010000) => Some(insts::OP_SH2ADDUW),
                (0b_101, 0b_0110000) => Some(insts::OP_RORW),
                (0b_110, 0b_0010000) => Some(insts::OP_SH3ADDUW),
                _ => None,
            };
            inst_opt.map(|inst| {
                Rtype::new(
                    inst,
                    rd(instruction_bits),
                    rs1(instruction_bits),
                    rs2(instruction_bits),
                )
                .0
            })
        }
        0b_0110011 => {
            let funct3_value = funct3(instruction_bits);
            let funct7_value = funct7(instruction_bits);
            let inst_opt = match (funct3_value, funct7_value) {
                (0b_111, 0b_0100000) => Some(insts::OP_ANDN),
                (0b_110, 0b_0100000) => Some(insts::OP_ORN),
                (0b_100, 0b_0100000) => Some(insts::OP_XNOR),
                (0b_001, 0b_0110000) => Some(insts::OP_ROL),
                (0b_101, 0b_0110000) => Some(insts::OP_ROR),
                (0b_001, 0b_0110100) => Some(insts::OP_BINV),
                (0b_001, 0b_0010100) => Some(insts::OP_BSET),
                (0b_001, 0b_0100100) => Some(insts::OP_BCLR),
                (0b_101, 0b_0100100) => Some(insts::OP_BEXT),
                (0b_010, 0b_0010000) => Some(insts::OP_SH1ADD),
                (0b_100, 0b_0010000) => Some(insts::OP_SH2ADD),
                (0b_110, 0b_0010000) => Some(insts::OP_SH3ADD),
                (0b_001, 0b_0000101) => Some(insts::OP_CLMUL),
                (0b_011, 0b_0000101) => Some(insts::OP_CLMULH),
                (0b_010, 0b_0000101) => Some(insts::OP_CLMULR),
                (0b_100, 0b_0000101) => Some(insts::OP_MIN),
                (0b_101, 0b_0000101) => Some(insts::OP_MINU),
                (0b_110, 0b_0000101) => Some(insts::OP_MAX),
                (0b_111, 0b_0000101) => Some(insts::OP_MAXU),
                _ => None,
            };
            inst_opt.map(|inst| {
                Rtype::new(
                    inst,
                    rd(instruction_bits),
                    rs1(instruction_bits),
                    rs2(instruction_bits),
                )
                .0
            })
        }
        0b_0010011 => {
            let funct3_value = funct3(instruction_bits);
            let funct7_value = funct7(instruction_bits);
            let rs2_value = rs2(instruction_bits);
            let inst_opt = match (funct7_value, funct3_value, rs2_value) {
                (0b_0010100, 0b_101, 0b_00111) => Some(insts::OP_ORCB),
                (0b_0110101, 0b_101, 0b_11000) => Some(insts::OP_REV8),
                (0b_0110000, 0b_001, 0b_00000) => Some(insts::OP_CLZ),
                (0b_0110000, 0b_001, 0b_00010) => Some(insts::OP_CPOP),
                (0b_0110000, 0b_001, 0b_00001) => Some(insts::OP_CTZ),
                (0b_0110000, 0b_001, 0b_00100) => Some(insts::OP_SEXTB),
                (0b_0110000, 0b_001, 0b_00101) => Some(insts::OP_SEXTH),
                _ => None,
            };
            if let Some(inst) = inst_opt {
                Some(
                    Rtype::new(
                        inst,
                        rd(instruction_bits),
                        rs1(instruction_bits),
                        rs2(instruction_bits),
                    )
                    .0,
                )
            } else {
                let inst_opt = match (funct7_value >> 1, funct3_value) {
                    (0b_010010, 0b_001) => Some(insts::OP_BCLRI),
                    (0b_010010, 0b_101) => Some(insts::OP_BEXTI),
                    (0b_011010, 0b_001) => Some(insts::OP_BINVI),
                    (0b_001010, 0b_001) => Some(insts::OP_BSETI),
                    (0b_011000, 0b_101) => Some(insts::OP_RORI),
                    _ => None,
                };
                inst_opt.map(|inst| {
                    Itype::new_u(
                        inst,
                        rd(instruction_bits),
                        rs1(instruction_bits),
                        utils::x(instruction_bits, 20, 6, 0),
                    )
                    .0
                })
            }
        }
        0b_0011011 => {
            let funct3_value = funct3(instruction_bits);
            let funct7_value = funct7(instruction_bits);
            let rs2_value = rs2(instruction_bits);

            match funct7_value {
                0b_0110000 => match funct3_value {
                    0b_001 => {
                        let inst_opt = match rs2_value {
                            0b_00000 => Some(insts::OP_CLZW),
                            0b_00010 => Some(insts::OP_CPOPW),
                            0b_00001 => Some(insts::OP_CTZW),
                            _ => None,
                        };
                        inst_opt.map(|inst| {
                            Rtype::new(inst, rd(instruction_bits), rs1(instruction_bits), rs2_value)
                                .0
                        })
                    }
                    0b_101 => Some(
                        Itype::new_u(
                            insts::OP_RORIW,
                            rd(instruction_bits),
                            rs1(instruction_bits),
                            utils::x(instruction_bits, 20, 5, 0),
                        )
                        .0,
                    ),
                    _ => None,
                },
                _ => {
                    if funct7_value >> 1 == 0b_000010 && funct3_value == 0b_001 {
                        Some(
                            Itype::new_u(
                                insts::OP_SLLIUW,
                                rd(instruction_bits),
                                rs1(instruction_bits),
                                utils::x(instruction_bits, 20, 6, 0),
                            )
                            .0,
                        )
                    } else {
                        None
                    }
                }
            }
        }
        _ => None,
    };

    inst.map(set_instruction_length_4)
}


================================================
File: src/instructions/common.rs
================================================
use super::super::error::OutOfBoundKind;
use super::super::machine::Machine;
use super::super::memory::Memory;
use super::register::Register;
use super::utils::update_register;
use super::{Error, RegisterIndex, SImmediate, UImmediate};

// Other instruction set functions common with RVC

// ======================
// #  ALU instructions  #
// ======================
pub fn add<Mac: Machine>(
    machine: &mut Mac,
    rd: RegisterIndex,
    rs1: RegisterIndex,
    rs2: RegisterIndex,
) {
    let rs1_value = &machine.registers()[rs1 as usize];
    let rs2_value = &machine.registers()[rs2 as usize];
    let value = rs1_value.overflowing_add(rs2_value);
    update_register(machine, rd, value);
}

pub fn addw<Mac: Machine>(
    machine: &mut Mac,
    rd: RegisterIndex,
    rs1: RegisterIndex,
    rs2: RegisterIndex,
) {
    let rs1_value = &machine.registers()[rs1 as usize];
    let rs2_value = &machine.registers()[rs2 as usize];
    let value = rs1_value.overflowing_add(rs2_value);
    update_register(machine, rd, value.sign_extend(&Mac::REG::from_u8(32)));
}

pub fn sub<Mac: Machine>(
    machine: &mut Mac,
    rd: RegisterIndex,
    rs1: RegisterIndex,
    rs2: RegisterIndex,
) {
    let rs1_value = &machine.registers()[rs1 as usize];
    let rs2_value = &machine.registers()[rs2 as usize];
    let value = rs1_value.overflowing_sub(rs2_value);
    update_register(machine, rd, value);
}

pub fn subw<Mac: Machine>(
    machine: &mut Mac,
    rd: RegisterIndex,
    rs1: RegisterIndex,
    rs2: RegisterIndex,
) {
    let rs1_value = &machine.registers()[rs1 as usize];
    let rs2_value = &machine.registers()[rs2 as usize];
    let value = rs1_value.overflowing_sub(rs2_value);
    update_register(machine, rd, value.sign_extend(&Mac::REG::from_u8(32)));
}

pub fn addi<Mac: Machine>(
    machine: &mut Mac,
    rd: RegisterIndex,
    rs1: RegisterIndex,
    imm: SImmediate,
) {
    let value = machine.registers()[rs1 as usize].overflowing_add(&Mac::REG::from_i32(imm));
    update_register(machine, rd, value);
}

pub fn addiw<Mac: Machine>(
    machine: &mut Mac,
    rd: RegisterIndex,
    rs1: RegisterIndex,
    imm: SImmediate,
) {
    let value = machine.registers()[rs1 as usize].overflowing_add(&Mac::REG::from_i32(imm));
    update_register(machine, rd, value.sign_extend(&Mac::REG::from_u8(32)));
}

// =======================
// #  LOAD instructions  #
// =======================
fn check_load_boundary<R: Register>(
    version0: bool,
    address: &R,
    bytes: u64,
    memory_size: u64,
) -> Result<(), Error> {
    if version0 {
        let address = address.to_u64();
        let (end, overflow) = address.overflowing_add(bytes);
        if overflow || end == memory_size {
            return Err(Error::MemOutOfBound(end, OutOfBoundKind::Memory));
        }
    }
    Ok(())
}

pub fn lb<Mac: Machine>(
    machine: &mut Mac,
    rd: RegisterIndex,
    rs1: RegisterIndex,
    imm: SImmediate,
    version0: bool,
) -> Result<(), Error> {
    let address = machine.registers()[rs1 as usize].overflowing_add(&Mac::REG::from_i32(imm));
    check_load_boundary(version0, &address, 1, machine.memory().memory_size() as u64)?;
    let value = machine.memory_mut().load8(&address)?;
    // sign-extened
    update_register(machine, rd, value.sign_extend(&Mac::REG::from_u8(8)));
    Ok(())
}

pub fn lh<Mac: Machine>(
    machine: &mut Mac,
    rd: RegisterIndex,
    rs1: RegisterIndex,
    imm: SImmediate,
    version0: bool,
) -> Result<(), Error> {
    let address = machine.registers()[rs1 as usize].overflowing_add(&Mac::REG::from_i32(imm));
    check_load_boundary(version0, &address, 2, machine.memory().memory_size() as u64)?;
    let value = machine.memory_mut().load16(&address)?;
    // sign-extened
    update_register(machine, rd, value.sign_extend(&Mac::REG::from_u8(16)));
    Ok(())
}

pub fn lw<Mac: Machine>(
    machine: &mut Mac,
    rd: RegisterIndex,
    rs1: RegisterIndex,
    imm: SImmediate,
    version0: bool,
) -> Result<(), Error> {
    let address = machine.registers()[rs1 as usize].overflowing_add(&Mac::REG::from_i32(imm));
    check_load_boundary(version0, &address, 4, machine.memory().memory_size() as u64)?;
    let value = machine.memory_mut().load32(&address)?;
    update_register(machine, rd, value.sign_extend(&Mac::REG::from_u8(32)));
    Ok(())
}

pub fn ld<Mac: Machine>(
    machine: &mut Mac,
    rd: RegisterIndex,
    rs1: RegisterIndex,
    imm: SImmediate,
    version0: bool,
) -> Result<(), Error> {
    let address = machine.registers()[rs1 as usize].overflowing_add(&Mac::REG::from_i32(imm));
    check_load_boundary(version0, &address, 8, machine.memory().memory_size() as u64)?;
    let value = machine.memory_mut().load64(&address)?;
    update_register(machine, rd, value.sign_extend(&Mac::REG::from_u8(64)));
    Ok(())
}

pub fn lbu<Mac: Machine>(
    machine: &mut Mac,
    rd: RegisterIndex,
    rs1: RegisterIndex,
    imm: SImmediate,
    version0: bool,
) -> Result<(), Error> {
    let address = machine.registers()[rs1 as usize].overflowing_add(&Mac::REG::from_i32(imm));
    check_load_boundary(version0, &address, 1, machine.memory().memory_size() as u64)?;
    let value = machine.memory_mut().load8(&address)?;
    update_register(machine, rd, value);
    Ok(())
}

pub fn lhu<Mac: Machine>(
    machine: &mut Mac,
    rd: RegisterIndex,
    rs1: RegisterIndex,
    imm: SImmediate,
    version0: bool,
) -> Result<(), Error> {
    let address = machine.registers()[rs1 as usize].overflowing_add(&Mac::REG::from_i32(imm));
    check_load_boundary(version0, &address, 2, machine.memory().memory_size() as u64)?;
    let value = machine.memory_mut().load16(&address)?;
    update_register(machine, rd, value);
    Ok(())
}

pub fn lwu<Mac: Machine>(
    machine: &mut Mac,
    rd: RegisterIndex,
    rs1: RegisterIndex,
    imm: SImmediate,
    version0: bool,
) -> Result<(), Error> {
    let address = machine.registers()[rs1 as usize].overflowing_add(&Mac::REG::from_i32(imm));
    check_load_boundary(version0, &address, 4, machine.memory().memory_size() as u64)?;
    let value = machine.memory_mut().load32(&address)?;
    update_register(machine, rd, value);
    Ok(())
}

// ========================
// #  STORE instructions  #
// ========================
pub fn sb<Mac: Machine>(
    machine: &mut Mac,
    rs1: RegisterIndex,
    rs2: RegisterIndex,
    imm: SImmediate,
) -> Result<(), Error> {
    let address = machine.registers()[rs1 as usize].overflowing_add(&Mac::REG::from_i32(imm));
    let value = machine.registers()[rs2 as usize].clone();
    machine.memory_mut().store8(&address, &value)?;
    Ok(())
}

pub fn sh<Mac: Machine>(
    machine: &mut Mac,
    rs1: RegisterIndex,
    rs2: RegisterIndex,
    imm: SImmediate,
) -> Result<(), Error> {
    let address = machine.registers()[rs1 as usize].overflowing_add(&Mac::REG::from_i32(imm));
    let value = machine.registers()[rs2 as usize].clone();
    machine.memory_mut().store16(&address, &value)?;
    Ok(())
}

pub fn sw<Mac: Machine>(
    machine: &mut Mac,
    rs1: RegisterIndex,
    rs2: RegisterIndex,
    imm: SImmediate,
) -> Result<(), Error> {
    let address = machine.registers()[rs1 as usize].overflowing_add(&Mac::REG::from_i32(imm));
    let value = machine.registers()[rs2 as usize].clone();
    machine.memory_mut().store32(&address, &value)?;
    Ok(())
}

pub fn sd<Mac: Machine>(
    machine: &mut Mac,
    rs1: RegisterIndex,
    rs2: RegisterIndex,
    imm: SImmediate,
) -> Result<(), Error> {
    let address = machine.registers()[rs1 as usize].overflowing_add(&Mac::REG::from_i32(imm));
    let value = machine.registers()[rs2 as usize].clone();
    machine.memory_mut().store64(&address, &value)?;
    Ok(())
}

// =========================
// #  BIT-OP instructions  #
// =========================
pub fn and<Mac: Machine>(
    machine: &mut Mac,
    rd: RegisterIndex,
    rs1: RegisterIndex,
    rs2: RegisterIndex,
) {
    let rs1_value = machine.registers()[rs1 as usize].clone();
    let rs2_value = machine.registers()[rs2 as usize].clone();
    let value = rs1_value & rs2_value;
    update_register(machine, rd, value);
}

pub fn xor<Mac: Machine>(
    machine: &mut Mac,
    rd: RegisterIndex,
    rs1: RegisterIndex,
    rs2: RegisterIndex,
) {
    let rs1_value = machine.registers()[rs1 as usize].clone();
    let rs2_value = machine.registers()[rs2 as usize].clone();
    let value = rs1_value ^ rs2_value;
    update_register(machine, rd, value);
}

pub fn or<Mac: Machine>(
    machine: &mut Mac,
    rd: RegisterIndex,
    rs1: RegisterIndex,
    rs2: RegisterIndex,
) {
    let rs1_value = machine.registers()[rs1 as usize].clone();
    let rs2_value = machine.registers()[rs2 as usize].clone();
    let value = rs1_value | rs2_value;
    update_register(machine, rd, value);
}

pub fn andi<Mac: Machine>(
    machine: &mut Mac,
    rd: RegisterIndex,
    rs1: RegisterIndex,
    imm: SImmediate,
) {
    let value = machine.registers()[rs1 as usize].clone() & Mac::REG::from_i32(imm);
    update_register(machine, rd, value);
}

pub fn xori<Mac: Machine>(
    machine: &mut Mac,
    rd: RegisterIndex,
    rs1: RegisterIndex,
    imm: SImmediate,
) {
    let value = machine.registers()[rs1 as usize].clone() ^ Mac::REG::from_i32(imm);
    update_register(machine, rd, value);
}

pub fn ori<Mac: Machine>(
    machine: &mut Mac,
    rd: RegisterIndex,
    rs1: RegisterIndex,
    imm: SImmediate,
) {
    let value = machine.registers()[rs1 as usize].clone() | Mac::REG::from_i32(imm);
    update_register(machine, rd, value);
}

pub fn slli<Mac: Machine>(
    machine: &mut Mac,
    rd: RegisterIndex,
    rs1: RegisterIndex,
    shamt: UImmediate,
) {
    let value = machine.registers()[rs1 as usize].clone() << Mac::REG::from_u32(shamt);
    update_register(machine, rd, value);
}

pub fn srli<Mac: Machine>(
    machine: &mut Mac,
    rd: RegisterIndex,
    rs1: RegisterIndex,
    shamt: UImmediate,
) {
    let value = machine.registers()[rs1 as usize].clone() >> Mac::REG::from_u32(shamt);
    update_register(machine, rd, value);
}

pub fn srai<Mac: Machine>(
    machine: &mut Mac,
    rd: RegisterIndex,
    rs1: RegisterIndex,
    shamt: UImmediate,
) {
    let value = machine.registers()[rs1 as usize].signed_shr(&Mac::REG::from_u32(shamt));
    update_register(machine, rd, value);
}

pub fn slliw<Mac: Machine>(
    machine: &mut Mac,
    rd: RegisterIndex,
    rs1: RegisterIndex,
    shamt: UImmediate,
) {
    let value = machine.registers()[rs1 as usize].clone() << Mac::REG::from_u32(shamt);
    update_register(machine, rd, value.sign_extend(&Mac::REG::from_u8(32)));
}

pub fn srliw<Mac: Machine>(
    machine: &mut Mac,
    rd: RegisterIndex,
    rs1: RegisterIndex,
    shamt: UImmediate,
) {
    let value = machine.registers()[rs1 as usize].zero_extend(&Mac::REG::from_u8(32))
        >> Mac::REG::from_u32(shamt);
    update_register(machine, rd, value.sign_extend(&Mac::REG::from_u8(32)));
}

pub fn sraiw<Mac: Machine>(
    machine: &mut Mac,
    rd: RegisterIndex,
    rs1: RegisterIndex,
    shamt: UImmediate,
) {
    let value = machine.registers()[rs1 as usize]
        .sign_extend(&Mac::REG::from_u8(32))
        .signed_shr(&Mac::REG::from_u32(shamt));
    update_register(machine, rd, value.sign_extend(&Mac::REG::from_u8(32)));
}

// =======================
// #  JUMP instructions  #
// =======================
pub fn jal<Mac: Machine>(machine: &mut Mac, rd: RegisterIndex, imm: SImmediate, xbytes: u8) {
    let link = machine.pc().overflowing_add(&Mac::REG::from_u8(xbytes));
    update_register(machine, rd, link);
    machine.update_pc(machine.pc().overflowing_add(&Mac::REG::from_i32(imm)));
}


================================================
File: src/instructions/execute.rs
================================================
use super::{
    super::{machine::Machine, Error},
    common, extract_opcode, instruction_length,
    utils::update_register,
    Instruction, InstructionOpcode, Itype, R4type, R5type, Register, Rtype, Stype, Utype,
};
use crate::memory::Memory;
use ckb_vm_definitions::{
    for_each_inst_array1, for_each_inst_match2,
    instructions::{self as insts, paste},
    registers::RA,
};

pub fn handle_sub<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    common::sub(machine, i.rd(), i.rs1(), i.rs2());
    Ok(())
}

pub fn handle_subw<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    common::subw(machine, i.rd(), i.rs1(), i.rs2());
    Ok(())
}

pub fn handle_add<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    common::add(machine, i.rd(), i.rs1(), i.rs2());
    Ok(())
}

pub fn handle_addw<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    common::addw(machine, i.rd(), i.rs1(), i.rs2());
    Ok(())
}

pub fn handle_xor<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    common::xor(machine, i.rd(), i.rs1(), i.rs2());
    Ok(())
}

pub fn handle_or<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    common::or(machine, i.rd(), i.rs1(), i.rs2());
    Ok(())
}

pub fn handle_and<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    common::and(machine, i.rd(), i.rs1(), i.rs2());
    Ok(())
}

pub fn handle_sll<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let shift_value =
        machine.registers()[i.rs2()].clone() & Mac::REG::from_u8(Mac::REG::SHIFT_MASK);
    let value = machine.registers()[i.rs1()].clone() << shift_value;
    update_register(machine, i.rd(), value);

    Ok(())
}

pub fn handle_sllw<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let shift_value = machine.registers()[i.rs2()].clone() & Mac::REG::from_u8(0x1F);
    let value = machine.registers()[i.rs1()].clone() << shift_value;
    update_register(machine, i.rd(), value.sign_extend(&Mac::REG::from_u8(32)));
    Ok(())
}

pub fn handle_srl<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let shift_value =
        machine.registers()[i.rs2()].clone() & Mac::REG::from_u8(Mac::REG::SHIFT_MASK);
    let value = machine.registers()[i.rs1()].clone() >> shift_value;
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_srlw<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let shift_value = machine.registers()[i.rs2()].clone() & Mac::REG::from_u8(0x1F);
    let value = machine.registers()[i.rs1()].zero_extend(&Mac::REG::from_u8(32)) >> shift_value;
    update_register(machine, i.rd(), value.sign_extend(&Mac::REG::from_u8(32)));
    Ok(())
}

pub fn handle_sra<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let shift_value =
        machine.registers()[i.rs2()].clone() & Mac::REG::from_u8(Mac::REG::SHIFT_MASK);
    let value = machine.registers()[i.rs1()].signed_shr(&shift_value);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_sraw<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let shift_value = machine.registers()[i.rs2()].clone() & Mac::REG::from_u8(0x1F);
    let value = machine.registers()[i.rs1()]
        .sign_extend(&Mac::REG::from_u8(32))
        .signed_shr(&shift_value);
    update_register(machine, i.rd(), value.sign_extend(&Mac::REG::from_u8(32)));
    Ok(())
}

pub fn handle_slt<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let value = rs1_value.lt_s(rs2_value);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_sltu<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let value = rs1_value.lt(rs2_value);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_lb_version0<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Itype(inst);
    common::lb(machine, i.rd(), i.rs1(), i.immediate_s(), true)?;
    Ok(())
}

pub fn handle_lb_version1<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Itype(inst);
    common::lb(machine, i.rd(), i.rs1(), i.immediate_s(), false)?;
    Ok(())
}

pub fn handle_lh_version0<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Itype(inst);
    common::lh(machine, i.rd(), i.rs1(), i.immediate_s(), true)?;
    Ok(())
}

pub fn handle_lh_version1<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Itype(inst);
    common::lh(machine, i.rd(), i.rs1(), i.immediate_s(), false)?;
    Ok(())
}

pub fn handle_lw_version0<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Itype(inst);
    common::lw(machine, i.rd(), i.rs1(), i.immediate_s(), true)?;
    Ok(())
}

pub fn handle_lw_version1<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Itype(inst);
    common::lw(machine, i.rd(), i.rs1(), i.immediate_s(), false)?;
    Ok(())
}

pub fn handle_ld_version0<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Itype(inst);
    common::ld(machine, i.rd(), i.rs1(), i.immediate_s(), true)?;
    Ok(())
}

pub fn handle_ld_version1<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Itype(inst);
    common::ld(machine, i.rd(), i.rs1(), i.immediate_s(), false)?;
    Ok(())
}

pub fn handle_lbu_version0<Mac: Machine>(
    machine: &mut Mac,
    inst: Instruction,
) -> Result<(), Error> {
    let i = Itype(inst);
    common::lbu(machine, i.rd(), i.rs1(), i.immediate_s(), true)?;
    Ok(())
}

pub fn handle_lbu_version1<Mac: Machine>(
    machine: &mut Mac,
    inst: Instruction,
) -> Result<(), Error> {
    let i = Itype(inst);
    common::lbu(machine, i.rd(), i.rs1(), i.immediate_s(), false)?;
    Ok(())
}

pub fn handle_lhu_version0<Mac: Machine>(
    machine: &mut Mac,
    inst: Instruction,
) -> Result<(), Error> {
    let i = Itype(inst);
    common::lhu(machine, i.rd(), i.rs1(), i.immediate_s(), true)?;
    Ok(())
}

pub fn handle_lhu_version1<Mac: Machine>(
    machine: &mut Mac,
    inst: Instruction,
) -> Result<(), Error> {
    let i = Itype(inst);
    common::lhu(machine, i.rd(), i.rs1(), i.immediate_s(), false)?;
    Ok(())
}

pub fn handle_lwu_version0<Mac: Machine>(
    machine: &mut Mac,
    inst: Instruction,
) -> Result<(), Error> {
    let i = Itype(inst);
    common::lwu(machine, i.rd(), i.rs1(), i.immediate_s(), true)?;
    Ok(())
}

pub fn handle_lwu_version1<Mac: Machine>(
    machine: &mut Mac,
    inst: Instruction,
) -> Result<(), Error> {
    let i = Itype(inst);
    common::lwu(machine, i.rd(), i.rs1(), i.immediate_s(), false)?;
    Ok(())
}

pub fn handle_addi<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Itype(inst);
    common::addi(machine, i.rd(), i.rs1(), i.immediate_s());
    Ok(())
}

pub fn handle_addiw<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Itype(inst);
    common::addiw(machine, i.rd(), i.rs1(), i.immediate_s());
    Ok(())
}

pub fn handle_xori<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Itype(inst);
    common::xori(machine, i.rd(), i.rs1(), i.immediate_s());
    Ok(())
}

pub fn handle_lr_w<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let address = machine.registers()[i.rs1()].clone();
    let value = machine.memory_mut().load32(&address)?;
    update_register(machine, i.rd(), value.sign_extend(&Mac::REG::from_u8(32)));
    machine.memory_mut().set_lr(&address);
    Ok(())
}

pub fn handle_sc_w<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let address = machine.registers()[i.rs1()].clone();
    let condition = address.eq(machine.memory().lr());
    let mem_value = condition.cond(
        &machine.registers()[i.rs2()].clone(),
        &machine.memory_mut().load32(&address)?,
    );
    let rd_value = condition.cond(&Mac::REG::from_u8(0), &Mac::REG::from_u8(1));
    machine.memory_mut().store32(&address, &mem_value)?;
    update_register(machine, i.rd(), rd_value);
    machine.memory_mut().set_lr(&Mac::REG::from_u64(u64::MAX));
    Ok(())
}

pub fn handle_amoswap_w<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = machine.registers()[i.rs1()].clone();
    let rs2_value = machine.registers()[i.rs2()].clone();
    let mem_value = machine.memory_mut().load32(&rs1_value)?;
    let mem_value = mem_value.sign_extend(&Mac::REG::from_u8(32));
    update_register(machine, i.rd(), mem_value);
    machine.memory_mut().store32(&rs1_value, &rs2_value)?;
    Ok(())
}

pub fn handle_amoadd_w<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = machine.registers()[i.rs1()].clone();
    let rs2_value = machine.registers()[i.rs2()].clone();
    let mem_value = machine.memory_mut().load32(&rs1_value)?;
    let mem_value = mem_value.sign_extend(&Mac::REG::from_u8(32));
    update_register(machine, i.rd(), mem_value.clone());
    let mem_value = rs2_value.overflowing_add(&mem_value);
    machine.memory_mut().store32(&rs1_value, &mem_value)?;
    Ok(())
}

pub fn handle_amoxor_w<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = machine.registers()[i.rs1()].clone();
    let rs2_value = machine.registers()[i.rs2()].clone();
    let mem_value = machine.memory_mut().load32(&rs1_value)?;
    let mem_value = mem_value.sign_extend(&Mac::REG::from_u8(32));
    update_register(machine, i.rd(), mem_value.clone());
    let mem_value = rs2_value ^ mem_value;
    machine.memory_mut().store32(&rs1_value, &mem_value)?;
    Ok(())
}

pub fn handle_amoand_w<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = machine.registers()[i.rs1()].clone();
    let rs2_value = machine.registers()[i.rs2()].clone();
    let mem_value = machine.memory_mut().load32(&rs1_value)?;
    let mem_value = mem_value.sign_extend(&Mac::REG::from_u8(32));
    update_register(machine, i.rd(), mem_value.clone());
    let mem_value = rs2_value & mem_value;
    machine.memory_mut().store32(&rs1_value, &mem_value)?;
    Ok(())
}

pub fn handle_amoor_w<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = machine.registers()[i.rs1()].clone();
    let rs2_value = machine.registers()[i.rs2()].clone();
    let mem_value = machine.memory_mut().load32(&rs1_value)?;
    let mem_value = mem_value.sign_extend(&Mac::REG::from_u8(32));
    update_register(machine, i.rd(), mem_value.clone());
    let mem_value = rs2_value | mem_value;
    machine.memory_mut().store32(&rs1_value, &mem_value)?;
    Ok(())
}

pub fn handle_amomin_w<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = machine.registers()[i.rs1()].clone();
    let rs2_value = machine.registers()[i.rs2()].sign_extend(&Mac::REG::from_u8(32));
    let mem_value = machine.memory_mut().load32(&rs1_value)?;
    let mem_value = mem_value.sign_extend(&Mac::REG::from_u8(32));
    update_register(machine, i.rd(), mem_value.clone());
    let mem_value = rs2_value.lt_s(&mem_value).cond(&rs2_value, &mem_value);
    machine.memory_mut().store32(&rs1_value, &mem_value)?;
    Ok(())
}

pub fn handle_amomax_w<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = machine.registers()[i.rs1()].clone();
    let rs2_value = machine.registers()[i.rs2()].sign_extend(&Mac::REG::from_u8(32));
    let mem_value = machine.memory_mut().load32(&rs1_value)?;
    let mem_value = mem_value.sign_extend(&Mac::REG::from_u8(32));
    update_register(machine, i.rd(), mem_value.clone());
    let mem_value = rs2_value.ge_s(&mem_value).cond(&rs2_value, &mem_value);
    machine.memory_mut().store32(&rs1_value, &mem_value)?;
    Ok(())
}

pub fn handle_amominu_w<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = machine.registers()[i.rs1()].clone();
    let rs2_value = machine.registers()[i.rs2()].zero_extend(&Mac::REG::from_u8(32));
    let mem_value = machine.memory_mut().load32(&rs1_value)?;
    let mem_value_sext = mem_value.sign_extend(&Mac::REG::from_u8(32));
    update_register(machine, i.rd(), mem_value_sext);
    let mem_value = rs2_value.lt(&mem_value).cond(&rs2_value, &mem_value);
    machine.memory_mut().store32(&rs1_value, &mem_value)?;
    Ok(())
}

pub fn handle_amomaxu_w<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = machine.registers()[i.rs1()].clone();
    let rs2_value = machine.registers()[i.rs2()].zero_extend(&Mac::REG::from_u8(32));
    let mem_value = machine.memory_mut().load32(&rs1_value)?;
    let mem_value_sext = mem_value.sign_extend(&Mac::REG::from_u8(32));
    update_register(machine, i.rd(), mem_value_sext);
    let mem_value = rs2_value.ge(&mem_value).cond(&rs2_value, &mem_value);
    machine.memory_mut().store32(&rs1_value, &mem_value)?;
    Ok(())
}

pub fn handle_lr_d<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let address = machine.registers()[i.rs1()].clone();
    let value = machine.memory_mut().load64(&address)?;
    update_register(machine, i.rd(), value);
    machine.memory_mut().set_lr(&address);
    Ok(())
}

pub fn handle_sc_d<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let address = machine.registers()[i.rs1()].clone();
    let condition = address.eq(machine.memory().lr());
    let mem_value = condition.cond(
        &machine.registers()[i.rs2()].clone(),
        &machine.memory_mut().load64(&address)?,
    );
    let rd_value = condition.cond(&Mac::REG::from_u8(0), &Mac::REG::from_u8(1));
    machine.memory_mut().store64(&address, &mem_value)?;
    update_register(machine, i.rd(), rd_value);
    machine.memory_mut().set_lr(&Mac::REG::from_u64(u64::MAX));
    Ok(())
}

pub fn handle_amoswap_d<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = machine.registers()[i.rs1()].clone();
    let rs2_value = machine.registers()[i.rs2()].clone();
    let mem_value = machine.memory_mut().load64(&rs1_value)?;
    update_register(machine, i.rd(), mem_value);
    machine.memory_mut().store64(&rs1_value, &rs2_value)?;
    Ok(())
}

pub fn handle_amoadd_d<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = machine.registers()[i.rs1()].clone();
    let rs2_value = machine.registers()[i.rs2()].clone();
    let mem_value = machine.memory_mut().load64(&rs1_value)?;
    update_register(machine, i.rd(), mem_value.clone());
    let mem_value = rs2_value.overflowing_add(&mem_value);
    machine.memory_mut().store64(&rs1_value, &mem_value)?;
    Ok(())
}

pub fn handle_amoxor_d<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = machine.registers()[i.rs1()].clone();
    let rs2_value = machine.registers()[i.rs2()].clone();
    let mem_value = machine.memory_mut().load64(&rs1_value)?;
    update_register(machine, i.rd(), mem_value.clone());
    let mem_value = rs2_value ^ mem_value;
    machine.memory_mut().store64(&rs1_value, &mem_value)?;
    Ok(())
}

pub fn handle_amoand_d<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = machine.registers()[i.rs1()].clone();
    let rs2_value = machine.registers()[i.rs2()].clone();
    let mem_value = machine.memory_mut().load64(&rs1_value)?;
    update_register(machine, i.rd(), mem_value.clone());
    let mem_value = rs2_value & mem_value;
    machine.memory_mut().store64(&rs1_value, &mem_value)?;
    Ok(())
}

pub fn handle_amoor_d<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = machine.registers()[i.rs1()].clone();
    let rs2_value = machine.registers()[i.rs2()].clone();
    let mem_value = machine.memory_mut().load64(&rs1_value)?;
    update_register(machine, i.rd(), mem_value.clone());
    let mem_value = rs2_value | mem_value;
    machine.memory_mut().store64(&rs1_value, &mem_value)?;
    Ok(())
}

pub fn handle_amomin_d<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = machine.registers()[i.rs1()].clone();
    let rs2_value = machine.registers()[i.rs2()].clone();
    let mem_value = machine.memory_mut().load64(&rs1_value)?;
    update_register(machine, i.rd(), mem_value.clone());
    let mem_value = rs2_value.lt_s(&mem_value).cond(&rs2_value, &mem_value);
    machine.memory_mut().store64(&rs1_value, &mem_value)?;
    Ok(())
}

pub fn handle_amomax_d<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = machine.registers()[i.rs1()].clone();
    let rs2_value = machine.registers()[i.rs2()].clone();
    let mem_value = machine.memory_mut().load64(&rs1_value)?;
    update_register(machine, i.rd(), mem_value.clone());
    let mem_value = rs2_value.ge_s(&mem_value).cond(&rs2_value, &mem_value);
    machine.memory_mut().store64(&rs1_value, &mem_value)?;
    Ok(())
}

pub fn handle_amominu_d<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = machine.registers()[i.rs1()].clone();
    let rs2_value = machine.registers()[i.rs2()].clone();
    let mem_value = machine.memory_mut().load64(&rs1_value)?;
    update_register(machine, i.rd(), mem_value.clone());
    let mem_value = rs2_value.lt(&mem_value).cond(&rs2_value, &mem_value);
    machine.memory_mut().store64(&rs1_value, &mem_value)?;
    Ok(())
}

pub fn handle_amomaxu_d<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = machine.registers()[i.rs1()].clone();
    let rs2_value = machine.registers()[i.rs2()].clone();
    let mem_value = machine.memory_mut().load64(&rs1_value)?;
    update_register(machine, i.rd(), mem_value.clone());
    let mem_value = rs2_value.ge(&mem_value).cond(&rs2_value, &mem_value);
    machine.memory_mut().store64(&rs1_value, &mem_value)?;
    Ok(())
}

pub fn handle_ori<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Itype(inst);
    common::ori(machine, i.rd(), i.rs1(), i.immediate_s());
    Ok(())
}

pub fn handle_andi<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Itype(inst);
    common::andi(machine, i.rd(), i.rs1(), i.immediate_s());
    Ok(())
}

pub fn handle_slti<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Itype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let imm_value = Mac::REG::from_i32(i.immediate_s());
    let value = rs1_value.lt_s(&imm_value);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_sltiu<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Itype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let imm_value = Mac::REG::from_i32(i.immediate_s());
    let value = rs1_value.lt(&imm_value);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_jalr_version0<Mac: Machine>(
    machine: &mut Mac,
    inst: Instruction,
) -> Result<(), Error> {
    let i = Itype(inst);
    let size = instruction_length(inst);
    let link = machine.pc().overflowing_add(&Mac::REG::from_u8(size));
    update_register(machine, i.rd(), link);
    let mut next_pc =
        machine.registers()[i.rs1()].overflowing_add(&Mac::REG::from_i32(i.immediate_s()));
    next_pc = next_pc & (!Mac::REG::one());
    machine.update_pc(next_pc);
    Ok(())
}

pub fn handle_jalr_version1<Mac: Machine>(
    machine: &mut Mac,
    inst: Instruction,
) -> Result<(), Error> {
    let i = Itype(inst);
    let size = instruction_length(inst);
    let link = machine.pc().overflowing_add(&Mac::REG::from_u8(size));
    let mut next_pc =
        machine.registers()[i.rs1()].overflowing_add(&Mac::REG::from_i32(i.immediate_s()));
    next_pc = next_pc & (!Mac::REG::one());
    update_register(machine, i.rd(), link);
    machine.update_pc(next_pc);
    Ok(())
}

pub fn handle_slli<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Itype(inst);
    common::slli(machine, i.rd(), i.rs1(), i.immediate_u());
    Ok(())
}

pub fn handle_srli<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Itype(inst);
    common::srli(machine, i.rd(), i.rs1(), i.immediate_u());
    Ok(())
}

pub fn handle_srai<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Itype(inst);
    common::srai(machine, i.rd(), i.rs1(), i.immediate_u());
    Ok(())
}

pub fn handle_slliw<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Itype(inst);
    common::slliw(machine, i.rd(), i.rs1(), i.immediate_u());
    Ok(())
}

pub fn handle_srliw<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Itype(inst);
    common::srliw(machine, i.rd(), i.rs1(), i.immediate_u());
    Ok(())
}

pub fn handle_sraiw<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Itype(inst);
    common::sraiw(machine, i.rd(), i.rs1(), i.immediate_u());
    Ok(())
}

pub fn handle_sb<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Stype(inst);
    common::sb(machine, i.rs1(), i.rs2(), i.immediate_s())?;
    Ok(())
}

pub fn handle_sh<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Stype(inst);
    common::sh(machine, i.rs1(), i.rs2(), i.immediate_s())?;
    Ok(())
}

pub fn handle_sw<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Stype(inst);
    common::sw(machine, i.rs1(), i.rs2(), i.immediate_s())?;
    Ok(())
}

pub fn handle_sd<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Stype(inst);
    common::sd(machine, i.rs1(), i.rs2(), i.immediate_s())?;
    Ok(())
}

pub fn handle_beq<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Stype(inst);
    let pc = machine.pc();
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let condition = rs1_value.eq(rs2_value);
    let new_pc = condition.cond(
        &Mac::REG::from_i32(i.immediate_s()).overflowing_add(pc),
        &Mac::REG::from_u8(instruction_length(inst)).overflowing_add(pc),
    );
    machine.update_pc(new_pc);
    Ok(())
}

pub fn handle_bne<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Stype(inst);
    let pc = machine.pc();
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let condition = rs1_value.ne(rs2_value);
    let new_pc = condition.cond(
        &Mac::REG::from_i32(i.immediate_s()).overflowing_add(pc),
        &Mac::REG::from_u8(instruction_length(inst)).overflowing_add(pc),
    );
    machine.update_pc(new_pc);
    Ok(())
}

pub fn handle_blt<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Stype(inst);
    let pc = machine.pc();
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let condition = rs1_value.lt_s(rs2_value);
    let new_pc = condition.cond(
        &Mac::REG::from_i32(i.immediate_s()).overflowing_add(pc),
        &Mac::REG::from_u8(instruction_length(inst)).overflowing_add(pc),
    );
    machine.update_pc(new_pc);
    Ok(())
}

pub fn handle_bge<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Stype(inst);
    let pc = machine.pc();
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let condition = rs1_value.ge_s(rs2_value);
    let new_pc = condition.cond(
        &Mac::REG::from_i32(i.immediate_s()).overflowing_add(pc),
        &Mac::REG::from_u8(instruction_length(inst)).overflowing_add(pc),
    );
    machine.update_pc(new_pc);
    Ok(())
}

pub fn handle_bltu<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Stype(inst);
    let pc = machine.pc();
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let condition = rs1_value.lt(rs2_value);
    let new_pc = condition.cond(
        &Mac::REG::from_i32(i.immediate_s()).overflowing_add(pc),
        &Mac::REG::from_u8(instruction_length(inst)).overflowing_add(pc),
    );
    machine.update_pc(new_pc);
    Ok(())
}

pub fn handle_bgeu<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Stype(inst);
    let pc = machine.pc();
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let condition = rs1_value.ge(rs2_value);
    let new_pc = condition.cond(
        &Mac::REG::from_i32(i.immediate_s()).overflowing_add(pc),
        &Mac::REG::from_u8(instruction_length(inst)).overflowing_add(pc),
    );
    machine.update_pc(new_pc);
    Ok(())
}

pub fn handle_lui<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Utype(inst);
    update_register(machine, i.rd(), Mac::REG::from_i32(i.immediate_s()));
    Ok(())
}

pub fn handle_auipc<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Utype(inst);
    let value = machine
        .pc()
        .overflowing_add(&Mac::REG::from_i32(i.immediate_s()));
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_ecall<Mac: Machine>(machine: &mut Mac, _inst: Instruction) -> Result<(), Error> {
    // The semantic of ECALL is determined by the hardware, which
    // is not part of the spec, hence here the implementation is
    // deferred to the machine. This way custom ECALLs might be
    // provided for different environments.
    machine.ecall()?;
    Ok(())
}

pub fn handle_ebreak<Mac: Machine>(machine: &mut Mac, _inst: Instruction) -> Result<(), Error> {
    machine.ebreak()?;
    Ok(())
}

pub fn handle_fencei<Mac: Machine>(_machine: &mut Mac, _inst: Instruction) -> Result<(), Error> {
    Ok(())
}

pub fn handle_fence<Mac: Machine>(_machine: &mut Mac, _inst: Instruction) -> Result<(), Error> {
    Ok(())
}

pub fn handle_jal<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Utype(inst);
    common::jal(machine, i.rd(), i.immediate_s(), instruction_length(inst));
    Ok(())
}

pub fn handle_mul<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let value = rs1_value.overflowing_mul(rs2_value);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_mulw<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let value = rs1_value
        .zero_extend(&Mac::REG::from_u8(32))
        .overflowing_mul(&rs2_value.zero_extend(&Mac::REG::from_u8(32)));
    update_register(machine, i.rd(), value.sign_extend(&Mac::REG::from_u8(32)));
    Ok(())
}

pub fn handle_mulh<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let value = rs1_value.overflowing_mul_high_signed(rs2_value);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_mulhsu<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let value = rs1_value.overflowing_mul_high_signed_unsigned(rs2_value);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_mulhu<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let value = rs1_value.overflowing_mul_high_unsigned(rs2_value);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_div<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let value = rs1_value.overflowing_div_signed(rs2_value);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_divw<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let rs1_value = rs1_value.sign_extend(&Mac::REG::from_u8(32));
    let rs2_value = rs2_value.sign_extend(&Mac::REG::from_u8(32));
    let value = rs1_value.overflowing_div_signed(&rs2_value);
    update_register(machine, i.rd(), value.sign_extend(&Mac::REG::from_u8(32)));
    Ok(())
}

pub fn handle_divu<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let value = rs1_value.overflowing_div(rs2_value);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_divuw<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let rs1_value = rs1_value.zero_extend(&Mac::REG::from_u8(32));
    let rs2_value = rs2_value.zero_extend(&Mac::REG::from_u8(32));
    let value = rs1_value.overflowing_div(&rs2_value);
    update_register(machine, i.rd(), value.sign_extend(&Mac::REG::from_u8(32)));
    Ok(())
}

pub fn handle_rem<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let value = rs1_value.overflowing_rem_signed(rs2_value);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_remw<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let rs1_value = rs1_value.sign_extend(&Mac::REG::from_u8(32));
    let rs2_value = rs2_value.sign_extend(&Mac::REG::from_u8(32));
    let value = rs1_value.overflowing_rem_signed(&rs2_value);
    update_register(machine, i.rd(), value.sign_extend(&Mac::REG::from_u8(32)));
    Ok(())
}

pub fn handle_remu<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let value = rs1_value.overflowing_rem(rs2_value);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_remuw<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let rs1_value = rs1_value.zero_extend(&Mac::REG::from_u8(32));
    let rs2_value = rs2_value.zero_extend(&Mac::REG::from_u8(32));
    let value = rs1_value.overflowing_rem(&rs2_value);
    update_register(machine, i.rd(), value.sign_extend(&Mac::REG::from_u8(32)));
    Ok(())
}

pub fn handle_adduw<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let rs1_u = rs1_value.zero_extend(&Mac::REG::from_u8(32));
    let value = rs2_value.overflowing_add(&rs1_u);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_andn<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let value = rs1_value.clone() & !rs2_value.clone();
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_bclr<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let shamt = rs2_value.clone() & Mac::REG::from_u8(Mac::REG::SHIFT_MASK);
    let value = rs1_value.clone() & !(Mac::REG::one() << shamt);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_bclri<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Itype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &Mac::REG::from_u32(i.immediate_u());
    let shamt = rs2_value.clone() & Mac::REG::from_u8(Mac::REG::SHIFT_MASK);
    let value = rs1_value.clone() & !(Mac::REG::one() << shamt);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_bext<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let shamt = rs2_value.clone() & Mac::REG::from_u8(Mac::REG::SHIFT_MASK);
    let value = Mac::REG::one() & (rs1_value.clone() >> shamt);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_bexti<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Itype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &Mac::REG::from_u32(i.immediate_u());
    let shamt = rs2_value.clone() & Mac::REG::from_u8(Mac::REG::SHIFT_MASK);
    let value = Mac::REG::one() & (rs1_value.clone() >> shamt);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_binv<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let shamt = rs2_value.clone() & Mac::REG::from_u8(Mac::REG::SHIFT_MASK);
    let value = rs1_value.clone() ^ (Mac::REG::one() << shamt);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_binvi<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Itype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &Mac::REG::from_u32(i.immediate_u());
    let shamt = rs2_value.clone() & Mac::REG::from_u8(Mac::REG::SHIFT_MASK);
    let value = rs1_value.clone() ^ (Mac::REG::one() << shamt);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_bset<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let shamt = rs2_value.clone() & Mac::REG::from_u8(Mac::REG::SHIFT_MASK);
    let value = rs1_value.clone() | (Mac::REG::one() << shamt);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_bseti<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Itype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &Mac::REG::from_u32(i.immediate_u());
    let shamt = rs2_value.clone() & Mac::REG::from_u8(Mac::REG::SHIFT_MASK);
    let value = rs1_value.clone() | (Mac::REG::one() << shamt);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_clmul<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let value = rs1_value.clmul(rs2_value);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_clmulh<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let value = rs1_value.clmulh(rs2_value);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_clmulr<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let value = rs1_value.clmulr(rs2_value);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_clz<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let value = rs1_value.clz();
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_clzw<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let value = rs1_value
        .zero_extend(&Mac::REG::from_u8(32))
        .clz()
        .overflowing_sub(&Mac::REG::from_u8(32));
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_cpop<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let value = rs1_value.cpop();
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_cpopw<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let value = rs1_value.zero_extend(&Mac::REG::from_u8(32)).cpop();
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_ctz<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let value = rs1_value.ctz();
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_ctzw<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let value = (rs1_value.clone() | Mac::REG::from_u64(0xffff_ffff_0000_0000)).ctz();
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_max<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let value = rs1_value.ge_s(rs2_value).cond(rs1_value, rs2_value);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_maxu<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let value = rs1_value.ge(rs2_value).cond(rs1_value, rs2_value);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_min<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let value = rs1_value.lt_s(rs2_value).cond(rs1_value, rs2_value);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_minu<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let value = rs1_value.lt(rs2_value).cond(rs1_value, rs2_value);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_orcb<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let value = rs1_value.orcb();
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_orn<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let value = rs1_value.clone() | !rs2_value.clone();
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_rev8<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let value = rs1_value.rev8();
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_rol<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let shamt = rs2_value.clone() & Mac::REG::from_u8(Mac::REG::SHIFT_MASK);
    let value = rs1_value.rol(&shamt);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_rolw<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let shamt = rs2_value.clone() & Mac::REG::from_u8(31);
    let twins = rs1_value
        .zero_extend(&Mac::REG::from_u8(32))
        .overflowing_mul(&Mac::REG::from_u64(0x_0000_0001_0000_0001));
    let value = twins.rol(&shamt).sign_extend(&Mac::REG::from_u8(32));
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_ror<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let shamt = rs2_value.clone() & Mac::REG::from_u8(Mac::REG::SHIFT_MASK);
    let value = rs1_value.ror(&shamt);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_rori<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Itype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &Mac::REG::from_u32(i.immediate_u());
    let shamt = rs2_value.clone() & Mac::REG::from_u8(Mac::REG::SHIFT_MASK);
    let value = rs1_value.ror(&shamt);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_roriw<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Itype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &Mac::REG::from_u32(i.immediate_u());
    let shamt = rs2_value.clone() & Mac::REG::from_u8(31);
    let twins = rs1_value
        .zero_extend(&Mac::REG::from_u8(32))
        .overflowing_mul(&Mac::REG::from_u64(0x_0000_0001_0000_0001));
    let value = twins.ror(&shamt).sign_extend(&Mac::REG::from_u8(32));
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_rorw<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let shamt = rs2_value.clone() & Mac::REG::from_u8(31);
    let twins = rs1_value
        .zero_extend(&Mac::REG::from_u8(32))
        .overflowing_mul(&Mac::REG::from_u64(0x_0000_0001_0000_0001));
    let value = twins.ror(&shamt).sign_extend(&Mac::REG::from_u8(32));
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_sextb<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let shift = &Mac::REG::from_u8(Mac::REG::BITS - 8);
    let value = rs1_value.signed_shl(shift).signed_shr(shift);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_sexth<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let shift = &Mac::REG::from_u8(Mac::REG::BITS - 16);
    let value = rs1_value.signed_shl(shift).signed_shr(shift);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_sh1add<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let value = (rs1_value.clone() << Mac::REG::from_u32(1)).overflowing_add(rs2_value);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_sh1adduw<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let rs1_z = rs1_value.clone().zero_extend(&Mac::REG::from_u8(32));
    let value = (rs1_z << Mac::REG::from_u32(1)).overflowing_add(rs2_value);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_sh2add<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let value = (rs1_value.clone() << Mac::REG::from_u32(2)).overflowing_add(rs2_value);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_sh2adduw<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let rs1_z = rs1_value.clone().zero_extend(&Mac::REG::from_u8(32));
    let value = (rs1_z << Mac::REG::from_u32(2)).overflowing_add(rs2_value);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_sh3add<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let value = (rs1_value.clone() << Mac::REG::from_u32(3)).overflowing_add(rs2_value);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_sh3adduw<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let rs1_z = rs1_value.clone().zero_extend(&Mac::REG::from_u8(32));
    let value = (rs1_z << Mac::REG::from_u32(3)).overflowing_add(rs2_value);
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_slliuw<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Itype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = Mac::REG::from_u32(i.immediate_u());
    let rs1_u = rs1_value.clone().zero_extend(&Mac::REG::from_u8(32));
    let shamt = rs2_value & Mac::REG::from_u8(Mac::REG::SHIFT_MASK);
    let value = rs1_u << shamt;
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_xnor<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let value = rs1_value.clone() ^ !rs2_value.clone();
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_zexth<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let value = rs1_value.zero_extend(&Mac::REG::from_u8(16));
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_wide_mul<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = R4type(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let value_h = rs1_value.overflowing_mul_high_signed(rs2_value);
    let value_l = rs1_value.overflowing_mul(rs2_value);
    update_register(machine, i.rd(), value_h);
    update_register(machine, i.rs3(), value_l);
    Ok(())
}

pub fn handle_wide_mulu<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = R4type(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let value_h = rs1_value.overflowing_mul_high_unsigned(rs2_value);
    let value_l = rs1_value.overflowing_mul(rs2_value);
    update_register(machine, i.rd(), value_h);
    update_register(machine, i.rs3(), value_l);
    Ok(())
}

pub fn handle_wide_mulsu<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = R4type(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let value_h = rs1_value.overflowing_mul_high_signed_unsigned(rs2_value);
    let value_l = rs1_value.overflowing_mul(rs2_value);
    update_register(machine, i.rd(), value_h);
    update_register(machine, i.rs3(), value_l);
    Ok(())
}

pub fn handle_wide_div<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = R4type(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let value_h = rs1_value.overflowing_div_signed(rs2_value);
    let value_l = rs1_value.overflowing_rem_signed(rs2_value);
    update_register(machine, i.rd(), value_h);
    update_register(machine, i.rs3(), value_l);
    Ok(())
}

pub fn handle_wide_divu<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = R4type(inst);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let value_h = rs1_value.overflowing_div(rs2_value);
    let value_l = rs1_value.overflowing_rem(rs2_value);
    update_register(machine, i.rd(), value_h);
    update_register(machine, i.rs3(), value_l);
    Ok(())
}

pub fn handle_far_jump_rel<Mac: Machine>(
    machine: &mut Mac,
    inst: Instruction,
) -> Result<(), Error> {
    let i = Utype(inst);
    let size = instruction_length(inst);
    let link = machine.pc().overflowing_add(&Mac::REG::from_u8(size));
    let next_pc = machine
        .pc()
        .overflowing_add(&Mac::REG::from_i32(i.immediate_s()))
        & (!Mac::REG::one());
    update_register(machine, RA, link);
    machine.update_pc(next_pc);
    Ok(())
}

pub fn handle_far_jump_abs<Mac: Machine>(
    machine: &mut Mac,
    inst: Instruction,
) -> Result<(), Error> {
    let i = Utype(inst);
    let size = instruction_length(inst);
    let link = machine.pc().overflowing_add(&Mac::REG::from_u8(size));
    let next_pc = Mac::REG::from_i32(i.immediate_s()) & (!Mac::REG::one());
    update_register(machine, RA, link);
    machine.update_pc(next_pc);
    Ok(())
}

pub fn handle_adc<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = Rtype(inst);
    let rd_value = &machine.registers()[i.rd()];
    let rs1_value = &machine.registers()[i.rs1()];
    let r = rd_value.overflowing_add(rs1_value);
    update_register(machine, i.rd(), r);
    let rd_value = &machine.registers()[i.rd()];
    let rs1_value = &machine.registers()[i.rs1()];
    let r = rd_value.lt(rs1_value);
    update_register(machine, i.rs1(), r);
    let rd_value = &machine.registers()[i.rd()];
    let rs2_value = &machine.registers()[i.rs2()];
    let r = rd_value.overflowing_add(rs2_value);
    update_register(machine, i.rd(), r);
    let rd_value = &machine.registers()[i.rd()];
    let rs2_value = &machine.registers()[i.rs2()];
    let r = rd_value.lt(rs2_value);
    update_register(machine, i.rs2(), r);
    let rs1_value = machine.registers()[i.rs1()].clone();
    let rs2_value = machine.registers()[i.rs2()].clone();
    let r = rs1_value | rs2_value;
    update_register(machine, i.rs1(), r);
    Ok(())
}

pub fn handle_sbb<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = R4type(inst);
    let rd_value = &machine.registers()[i.rd()];
    let rs1_value = &machine.registers()[i.rs1()];
    let r = rd_value.overflowing_sub(rs1_value);
    update_register(machine, i.rs1(), r);
    let rd_value = &machine.registers()[i.rd()];
    let rs1_value = &machine.registers()[i.rs1()];
    let r = rd_value.lt(rs1_value);
    update_register(machine, i.rs3(), r);
    let rs1_value = &machine.registers()[i.rs1()];
    let rs2_value = &machine.registers()[i.rs2()];
    let r = rs1_value.overflowing_sub(rs2_value);
    update_register(machine, i.rd(), r);
    let rd_value = &machine.registers()[i.rd()];
    let rs1_value = &machine.registers()[i.rs1()];
    let r = rs1_value.lt(rd_value);
    update_register(machine, i.rs2(), r);
    let rs2_value = machine.registers()[i.rs2()].clone();
    let rs3_value = machine.registers()[i.rs3()].clone();
    let r = rs2_value | rs3_value;
    update_register(machine, i.rs1(), r);
    Ok(())
}

pub fn handle_adcs<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = R4type(inst);
    let rs1_value = machine.registers()[i.rs1()].clone();
    let rs2_value = machine.registers()[i.rs2()].clone();
    let r = rs1_value.overflowing_add(&rs2_value);
    update_register(machine, i.rd(), r.clone());
    let r = r.lt(&rs1_value);
    update_register(machine, i.rs3(), r);
    Ok(())
}

pub fn handle_sbbs<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = R4type(inst);
    let rs1_value = machine.registers()[i.rs1()].clone();
    let rs2_value = machine.registers()[i.rs2()].clone();
    let r = rs1_value.overflowing_sub(&rs2_value);
    update_register(machine, i.rd(), r);
    let r = rs1_value.lt(&rs2_value);
    update_register(machine, i.rs3(), r);
    Ok(())
}

pub fn handle_add3a<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = R5type(inst);
    {
        let rd_value = machine.registers()[i.rd()].clone();
        let rs1_value = machine.registers()[i.rs1()].clone();
        let r = rd_value.overflowing_add(&rs1_value);
        update_register(machine, i.rd(), r);
    }
    {
        let rd_value = &machine.registers()[i.rd()];
        let rs1_value = &machine.registers()[i.rs1()];
        let r = rd_value.lt(rs1_value);
        update_register(machine, i.rs2(), r);
    }
    {
        let rs2_value = &machine.registers()[i.rs2()];
        let rs4_value = &machine.registers()[i.rs4()];
        let r = rs2_value.overflowing_add(rs4_value);
        update_register(machine, i.rs3(), r);
    }
    Ok(())
}

pub fn handle_add3b<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = R5type(inst);
    {
        let rs1_value = machine.registers()[i.rs1()].clone();
        let rs2_value = machine.registers()[i.rs2()].clone();
        let r = rs1_value.overflowing_add(&rs2_value);
        update_register(machine, i.rd(), r);
    }
    {
        let rd_value = &machine.registers()[i.rd()];
        let rs1_value = &machine.registers()[i.rs1()];
        let r = rd_value.lt(rs1_value);
        update_register(machine, i.rs1(), r);
    }
    {
        let rs1_value = &machine.registers()[i.rs1()];
        let rs4_value = &machine.registers()[i.rs4()];
        let r = rs1_value.overflowing_add(rs4_value);
        update_register(machine, i.rs3(), r);
    }
    Ok(())
}

pub fn handle_add3c<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    let i = R5type(inst);
    {
        let rs1_value = machine.registers()[i.rs1()].clone();
        let rs2_value = machine.registers()[i.rs2()].clone();
        let r = rs1_value.overflowing_add(&rs2_value);
        update_register(machine, i.rd(), r);
    }
    {
        let rd_value = &machine.registers()[i.rd()];
        let rs1_value = &machine.registers()[i.rs1()];
        let rs4_value = &machine.registers()[i.rs4()];
        let r = rd_value.lt(rs1_value);
        let r = r.overflowing_add(rs4_value);
        update_register(machine, i.rs3(), r);
    }
    Ok(())
}

pub fn handle_custom_load_uimm<Mac: Machine>(
    machine: &mut Mac,
    inst: Instruction,
) -> Result<(), Error> {
    let i = Utype(inst);
    update_register(machine, i.rd(), Mac::REG::from_u32(i.immediate_u()));
    Ok(())
}

pub fn handle_custom_load_imm<Mac: Machine>(
    machine: &mut Mac,
    inst: Instruction,
) -> Result<(), Error> {
    let i = Utype(inst);
    let value = Mac::REG::from_i32(i.immediate_s());
    update_register(machine, i.rd(), value);
    Ok(())
}

pub fn handle_unloaded<Mac: Machine>(machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    handle_invalid_op(machine, inst)
}

pub fn handle_custom_trace_end<Mac: Machine>(
    machine: &mut Mac,
    inst: Instruction,
) -> Result<(), Error> {
    handle_invalid_op(machine, inst)
}

pub fn handle_custom_asm_trace_jump<Mac: Machine>(
    machine: &mut Mac,
    inst: Instruction,
) -> Result<(), Error> {
    handle_invalid_op(machine, inst)
}

pub fn handle_invalid_op<Mac: Machine>(_machine: &mut Mac, inst: Instruction) -> Result<(), Error> {
    Err(Error::InvalidOp(extract_opcode(inst)))
}

macro_rules! handle_single_opcode {
    ($name:ident, $real_name:ident, $code:expr, $machine:ident, $inst:ident) => {
        paste! {
            Ok([< handle_ $real_name:lower >]($machine, $inst)?)
        }
    };
}

pub fn execute_instruction<Mac: Machine>(
    inst: Instruction,
    machine: &mut Mac,
) -> Result<(), Error> {
    let op = extract_opcode(inst);
    for_each_inst_match2!(
        handle_single_opcode,
        op,
        handle_invalid_op(machine, inst),
        machine,
        inst
    )
}

pub fn execute<Mac: Machine>(inst: Instruction, machine: &mut Mac) -> Result<(), Error> {
    let instruction_size = instruction_length(inst);
    let next_pc = machine
        .pc()
        .overflowing_add(&Mac::REG::from_u8(instruction_size));
    machine.update_pc(next_pc);
    let r = execute_instruction(inst, machine);
    machine.commit_pc();
    r
}

pub fn execute_with_thread<Mac: Machine>(
    inst: Instruction,
    machine: &mut Mac,
    thread: &Thread<Mac>,
) -> Result<(), Error> {
    let instruction_size = instruction_length(inst);
    let next_pc = machine
        .pc()
        .overflowing_add(&Mac::REG::from_u8(instruction_size));
    machine.update_pc(next_pc);
    let r = thread(machine, inst);
    machine.commit_pc();
    r
}

pub type Thread<Mac> = fn(&mut Mac, Instruction) -> Result<(), Error>;

pub struct ThreadFactory<Mac: Machine> {
    // Right now we are only dealing with fastpath opcodes, later we might
    // (or might not?) expand this with some opcodes in the slowpath category.
    threads: Vec<Thread<Mac>>,
}

macro_rules! thread_func_item {
    ($name:ident, $real_name:ident, $code:expr, $t:ident) => {
        paste! {
            [< handle_ $real_name:lower >]::<$t> as Thread<$t>
        }
    };
}

impl<Mac: Machine> ThreadFactory<Mac> {
    pub fn create() -> Self {
        let threads = for_each_inst_array1!(thread_func_item, Mac);
        Self {
            threads: Vec::from(threads),
        }
    }

    pub fn get(&self, op: InstructionOpcode) -> Option<&Thread<Mac>> {
        self.threads
            .get((op as usize).wrapping_sub(insts::MINIMAL_OPCODE as usize))
    }

    pub fn get_cloned(&self, op: InstructionOpcode) -> Option<Thread<Mac>> {
        self.get(op).cloned()
    }
}

impl<Mac: Machine> std::ops::Index<InstructionOpcode> for ThreadFactory<Mac> {
    type Output = Thread<Mac>;

    fn index(&self, opcode: InstructionOpcode) -> &Thread<Mac> {
        self.get(opcode).unwrap()
    }
}


================================================
File: src/instructions/i.rs
================================================
use ckb_vm_definitions::instructions as insts;

use super::utils::{
    btype_immediate, funct3, funct7, itype_immediate, jalr, jtype_immediate, lb, lbu, ld, lh, lhu,
    lw, lwu, opcode, rd, rs1, rs2, stype_immediate, utype_immediate,
};
use super::{
    blank_instruction, set_instruction_length_4, Instruction, Itype, Register, Rtype, Stype, Utype,
};

// The FENCE instruction is used to order device I/O and memory accesses
// as viewed by other RISC- V harts and external devices or coprocessors.
#[derive(Debug, Clone, Copy)]
pub struct FenceType(Instruction);

impl FenceType {
    pub fn new(fm: u8, pred: u8, succ: u8) -> Self {
        FenceType(Rtype::new(insts::OP_FENCE, fm as usize, pred as usize, succ as usize).0)
    }

    pub fn fm(self) -> u8 {
        Rtype(self.0).rd() as u8
    }

    pub fn pred(self) -> u8 {
        Rtype(self.0).rs1() as u8
    }

    pub fn succ(self) -> u8 {
        Rtype(self.0).rs2() as u8
    }
}

pub fn factory<R: Register>(instruction_bits: u32, version: u32) -> Option<Instruction> {
    let bit_length = R::BITS;
    if bit_length != 32 && bit_length != 64 {
        return None;
    }
    let rv64 = bit_length == 64;
    let inst = (|| match opcode(instruction_bits) {
        0b_0110111 => Some(
            Utype::new_s(
                insts::OP_LUI,
                rd(instruction_bits),
                utype_immediate(instruction_bits),
            )
            .0,
        ),
        0b_0010111 => Some(
            Utype::new_s(
                insts::OP_AUIPC,
                rd(instruction_bits),
                utype_immediate(instruction_bits),
            )
            .0,
        ),
        0b_1101111 => Some(
            Utype::new_s(
                insts::OP_JAL,
                rd(instruction_bits),
                jtype_immediate(instruction_bits),
            )
            .0,
        ),
        0b_1100111 => {
            let inst_opt = match funct3(instruction_bits) {
                // I-type jump instructions
                0b_000 => Some(jalr(version)),
                _ => None,
            };
            inst_opt.map(|inst| {
                Itype::new_s(
                    inst,
                    rd(instruction_bits),
                    rs1(instruction_bits),
                    itype_immediate(instruction_bits),
                )
                .0
            })
        }
        0b_0000011 => {
            // I-type load instructions
            let inst_opt = match funct3(instruction_bits) {
                0b_000 => Some(lb(version)),
                0b_001 => Some(lh(version)),
                0b_010 => Some(lw(version)),
                0b_100 => Some(lbu(version)),
                0b_101 => Some(lhu(version)),
                0b_110 if rv64 => Some(lwu(version)),
                0b_011 if rv64 => Some(ld(version)),
                _ => None,
            };
            inst_opt.map(|inst| {
                Itype::new_s(
                    inst,
                    rd(instruction_bits),
                    rs1(instruction_bits),
                    itype_immediate(instruction_bits),
                )
                .0
            })
        }
        0b_0010011 => {
            let funct3_value = funct3(instruction_bits);
            let inst_opt = match funct3_value {
                // I-type ALU instructions
                0b_000 => Some(insts::OP_ADDI),
                0b_010 => Some(insts::OP_SLTI),
                0b_011 => Some(insts::OP_SLTIU),
                0b_100 => Some(insts::OP_XORI),
                0b_110 => Some(insts::OP_ORI),
                0b_111 => Some(insts::OP_ANDI),
                // I-type special ALU instructions
                0b_001 | 0b_101 => {
                    let top6_value = funct7(instruction_bits) >> 1;
                    let inst_opt = match (funct3_value, top6_value) {
                        (0b_001, 0b_000000) => Some(insts::OP_SLLI),
                        (0b_101, 0b_000000) => Some(insts::OP_SRLI),
                        (0b_101, 0b_010000) => Some(insts::OP_SRAI),
                        _ => None,
                    };
                    return inst_opt.map(|inst| {
                        Itype::new_s(
                            inst,
                            rd(instruction_bits),
                            rs1(instruction_bits),
                            itype_immediate(instruction_bits) & i32::from(R::SHIFT_MASK),
                        )
                        .0
                    });
                }
                _ => None,
            };

            inst_opt.map(|inst| {
                Itype::new_s(
                    inst,
                    rd(instruction_bits),
                    rs1(instruction_bits),
                    itype_immediate(instruction_bits),
                )
                .0
            })
        }
        0b_1100011 => {
            let inst_opt = match funct3(instruction_bits) {
                0b_000 => Some(insts::OP_BEQ),
                0b_001 => Some(insts::OP_BNE),
                0b_100 => Some(insts::OP_BLT),
                0b_101 => Some(insts::OP_BGE),
                0b_110 => Some(insts::OP_BLTU),
                0b_111 => Some(insts::OP_BGEU),
                _ => None,
            };
            inst_opt.map(|inst| {
                Stype::new_s(
                    inst,
                    btype_immediate(instruction_bits),
                    rs1(instruction_bits),
                    rs2(instruction_bits),
                )
                .0
            })
        }
        0b_0100011 => {
            let inst_opt = match funct3(instruction_bits) {
                0b_000 => Some(insts::OP_SB),
                0b_001 => Some(insts::OP_SH),
                0b_010 => Some(insts::OP_SW),
                0b_011 if rv64 => Some(insts::OP_SD),
                _ => None,
            };
            inst_opt.map(|inst| {
                Stype::new_s(
                    inst,
                    stype_immediate(instruction_bits),
                    rs1(instruction_bits),
                    rs2(instruction_bits),
                )
                .0
            })
        }
        0b_0110011 => {
            let inst_opt = match (funct3(instruction_bits), funct7(instruction_bits)) {
                (0b_000, 0b_0000000) => Some(insts::OP_ADD),
                (0b_000, 0b_0100000) => Some(insts::OP_SUB),
                (0b_001, 0b_0000000) => Some(insts::OP_SLL),
                (0b_010, 0b_0000000) => Some(insts::OP_SLT),
                (0b_011, 0b_0000000) => Some(insts::OP_SLTU),
                (0b_100, 0b_0000000) => Some(insts::OP_XOR),
                (0b_101, 0b_0000000) => Some(insts::OP_SRL),
                (0b_101, 0b_0100000) => Some(insts::OP_SRA),
                (0b_110, 0b_0000000) => Some(insts::OP_OR),
                (0b_111, 0b_0000000) => Some(insts::OP_AND),
                _ => None,
            };
            inst_opt.map(|inst| {
                Rtype::new(
                    inst,
                    rd(instruction_bits),
                    rs1(instruction_bits),
                    rs2(instruction_bits),
                )
                .0
            })
        }
        0b_0001111 => {
            const FENCE_LOW_BITS: u32 = 0b_00000_000_00000_0001111;
            const FENCEI_VALUE: u32 = 0b_0000_0000_0000_00000_001_00000_0001111;
            if instruction_bits == FENCEI_VALUE {
                Some(blank_instruction(insts::OP_FENCEI))
            } else if instruction_bits & 0x000_FFFFF == FENCE_LOW_BITS {
                Some(
                    FenceType::new(
                        ((instruction_bits & 0xF00_00000) >> 28) as u8,
                        ((instruction_bits & 0x0F0_00000) >> 24) as u8,
                        ((instruction_bits & 0x00F_00000) >> 20) as u8,
                    )
                    .0,
                )
            } else {
                None
            }
        }
        0b_1110011 => match instruction_bits {
            0b_000000000000_00000_000_00000_1110011 => Some(blank_instruction(insts::OP_ECALL)),
            0b_000000000001_00000_000_00000_1110011 => Some(blank_instruction(insts::OP_EBREAK)),
            _ => None,
        },
        0b_0011011 if rv64 => {
            let funct3_value = funct3(instruction_bits);
            match funct3_value {
                0b_000 => Some(
                    Itype::new_s(
                        insts::OP_ADDIW,
                        rd(instruction_bits),
                        rs1(instruction_bits),
                        itype_immediate(instruction_bits),
                    )
                    .0,
                ),
                0b_001 | 0b_101 => {
                    let funct7_value = funct7(instruction_bits);
                    let inst_opt = match (funct3_value, funct7_value) {
                        (0b_001, 0b_0000000) => Some(insts::OP_SLLIW),
                        (0b_101, 0b_0000000) => Some(insts::OP_SRLIW),
                        (0b_101, 0b_0100000) => Some(insts::OP_SRAIW),
                        _ => None,
                    };
                    inst_opt.map(|inst| {
                        Itype::new_s(
                            inst,
                            rd(instruction_bits),
                            rs1(instruction_bits),
                            itype_immediate(instruction_bits) & 0x1F,
                        )
                        .0
                    })
                }
                _ => None,
            }
        }
        0b_0111011 if rv64 => {
            let inst_opt = match (funct3(instruction_bits), funct7(instruction_bits)) {
                (0b_000, 0b_0000000) => Some(insts::OP_ADDW),
                (0b_000, 0b_0100000) => Some(insts::OP_SUBW),
                (0b_001, 0b_0000000) => Some(insts::OP_SLLW),
                (0b_101, 0b_0000000) => Some(insts::OP_SRLW),
                (0b_101, 0b_0100000) => Some(insts::OP_SRAW),
                _ => None,
            };
            inst_opt.map(|inst| {
                Rtype::new(
                    inst,
                    rd(instruction_bits),
                    rs1(instruction_bits),
                    rs2(instruction_bits),
                )
                .0
            })
        }
        _ => None,
    })();
    inst.map(set_instruction_length_4)
}

pub fn nop() -> Instruction {
    Itype::new_u(insts::OP_ADDI, 0, 0, 0).0
}


================================================
File: src/instructions/m.rs
================================================
use ckb_vm_definitions::instructions as insts;

use super::utils::{funct3, funct7, opcode, rd, rs1, rs2};
use super::{set_instruction_length_4, Instruction, Register, Rtype};

pub fn factory<R: Register>(instruction_bits: u32, _: u32) -> Option<Instruction> {
    let bit_length = R::BITS;
    if bit_length != 32 && bit_length != 64 {
        return None;
    }
    let rv64 = bit_length == 64;
    if funct7(instruction_bits) != 0b_0000001 {
        return None;
    }
    let inst_opt = match opcode(instruction_bits) {
        0b_0110011 => match funct3(instruction_bits) {
            0b_000 => Some(insts::OP_MUL),
            0b_001 => Some(insts::OP_MULH),
            0b_010 => Some(insts::OP_MULHSU),
            0b_011 => Some(insts::OP_MULHU),
            0b_100 => Some(insts::OP_DIV),
            0b_101 => Some(insts::OP_DIVU),
            0b_110 => Some(insts::OP_REM),
            0b_111 => Some(insts::OP_REMU),
            _ => None,
        },
        0b_0111011 if rv64 => match funct3(instruction_bits) {
            0b_000 => Some(insts::OP_MULW),
            0b_100 => Some(insts::OP_DIVW),
            0b_101 => Some(insts::OP_DIVUW),
            0b_110 => Some(insts::OP_REMW),
            0b_111 => Some(insts::OP_REMUW),
            _ => None,
        },
        _ => None,
    };
    inst_opt
        .map(|inst| {
            Rtype::new(
                inst,
                rd(instruction_bits),
                rs1(instruction_bits),
                rs2(instruction_bits),
            )
            .0
        })
        .map(set_instruction_length_4)
}


================================================
File: src/instructions/mod.rs
================================================
mod common;
mod execute;
mod register;
mod utils;

pub mod a;
pub mod ast;
pub mod b;
pub mod i;
pub mod m;
pub mod rvc;
pub mod tagged;

pub use self::register::Register;
use super::Error;
pub use ckb_vm_definitions::{
    instructions::{
        self as insts, instruction_opcode_name, Instruction, InstructionOpcode,
        MAXIMUM_BASIC_BLOCK_END_OPCODE, MINIMAL_BASIC_BLOCK_END_OPCODE, MINIMAL_OPCODE,
    },
    registers::REGISTER_ABI_NAMES,
};
use core::fmt;
pub use execute::{
    execute, execute_instruction, execute_with_thread, handle_invalid_op, Thread, ThreadFactory,
};

pub type RegisterIndex = usize;
pub type SImmediate = i32;
pub type UImmediate = u32;

#[inline(always)]
pub fn extract_opcode(i: Instruction) -> InstructionOpcode {
    (((i >> 8) & 0xff00) | (i & 0x00ff)) as u16
}

pub type InstructionFactory = fn(instruction_bits: u32, version: u32) -> Option<Instruction>;

// Blank instructions need no register indices nor immediates, they only have opcode
// and module bit set.
pub fn blank_instruction(op: InstructionOpcode) -> Instruction {
    (op as u64 >> 8 << 16) | (op as u64 & 0xff)
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Rtype(pub Instruction);

impl Rtype {
    pub fn new(
        op: InstructionOpcode,
        rd: RegisterIndex,
        rs1: RegisterIndex,
        rs2: RegisterIndex,
    ) -> Self {
        Rtype(
            (u64::from(op) >> 8 << 16)
                | u64::from(op as u8)
                | (u64::from(rd as u8) << 8)
                | (u64::from(rs1 as u8) << 32)
                | (u64::from(rs2 as u8) << 40),
        )
    }

    pub fn op(self) -> InstructionOpcode {
        ((self.0 >> 16 << 8) | (self.0 & 0xFF)) as InstructionOpcode
    }

    pub fn rd(self) -> RegisterIndex {
        (self.0 >> 8) as u8 as RegisterIndex
    }

    pub fn rs1(self) -> RegisterIndex {
        (self.0 >> 32) as u8 as RegisterIndex
    }

    pub fn rs2(self) -> RegisterIndex {
        (self.0 >> 40) as u8 as RegisterIndex
    }
}

impl fmt::Display for Rtype {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "{} {},{},{}",
            instruction_opcode_name(self.op()).to_lowercase(),
            REGISTER_ABI_NAMES[self.rd()],
            REGISTER_ABI_NAMES[self.rs1()],
            REGISTER_ABI_NAMES[self.rs2()]
        )
    }
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Itype(pub Instruction);

impl Itype {
    pub fn new_u(
        op: InstructionOpcode,
        rd: RegisterIndex,
        rs1: RegisterIndex,
        immediate_u: UImmediate,
    ) -> Self {
        Itype(
            (u64::from(op) >> 8 << 16) |
            u64::from(op as u8) |
              (u64::from(rd as u8) << 8) |
              (u64::from(rs1 as u8) << 32) |
              // Per RISC-V spec, I-type uses 12 bits at most, so it's perfectly
              // fine we store them in 3-byte location.
              (u64::from(immediate_u) << 40),
        )
    }

    pub fn new_s(
        op: InstructionOpcode,
        rd: RegisterIndex,
        rs1: RegisterIndex,
        immediate_s: SImmediate,
    ) -> Self {
        Self::new_u(op, rd, rs1, immediate_s as UImmediate)
    }

    pub fn op(self) -> InstructionOpcode {
        ((self.0 >> 16 << 8) | (self.0 & 0xFF)) as InstructionOpcode
    }

    pub fn rd(self) -> RegisterIndex {
        (self.0 >> 8) as u8 as RegisterIndex
    }

    pub fn rs1(self) -> RegisterIndex {
        (self.0 >> 32) as u8 as RegisterIndex
    }

    pub fn immediate_u(self) -> UImmediate {
        self.immediate_s() as UImmediate
    }

    pub fn immediate_s(self) -> SImmediate {
        ((self.0 as i64) >> 40) as SImmediate
    }
}

impl fmt::Display for Itype {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // TODO: there are 2 simplifications here:
        // 1. It will print `addi a1,s0,-64` as `addi a1,-64(s0)`, and also print
        // `ld ra,88(sp)` as `ld ra,88(sp)`
        // 2. It will always use signed immediate numbers.
        // It is debatable if we should do a per-instruction pattern match to show
        // more patterns.
        write!(
            f,
            "{} {},{}({})",
            instruction_opcode_name(self.op()).to_lowercase(),
            REGISTER_ABI_NAMES[self.rd()],
            self.immediate_s(),
            REGISTER_ABI_NAMES[self.rs1()]
        )
    }
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Stype(pub Instruction);

impl Stype {
    pub fn new_u(
        op: InstructionOpcode,
        immediate_u: UImmediate,
        rs1: RegisterIndex,
        rs2: RegisterIndex,
    ) -> Self {
        Stype(
            (u64::from(op) >> 8 << 16) |
            u64::from(op as u8) |
              (u64::from(rs2 as u8) << 8) |
              (u64::from(rs1 as u8) << 32) |
              // Per RISC-V spec, S/B type uses 13 bits at most, so it's perfectly
              // fine we store them in 3-byte location.
              (u64::from(immediate_u) << 40),
        )
    }

    pub fn new_s(
        op: InstructionOpcode,
        immediate_s: SImmediate,
        rs1: RegisterIndex,
        rs2: RegisterIndex,
    ) -> Self {
        Self::new_u(op, immediate_s as UImmediate, rs1, rs2)
    }

    pub fn op(self) -> InstructionOpcode {
        ((self.0 >> 16 << 8) | (self.0 & 0xFF)) as InstructionOpcode
    }

    pub fn rs1(self) -> RegisterIndex {
        (self.0 >> 32) as u8 as RegisterIndex
    }

    pub fn rs2(self) -> RegisterIndex {
        (self.0 >> 8) as u8 as RegisterIndex
    }

    pub fn immediate_u(self) -> UImmediate {
        self.immediate_s() as UImmediate
    }

    pub fn immediate_s(self) -> SImmediate {
        ((self.0 as i64) >> 40) as SImmediate
    }
}

impl fmt::Display for Stype {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.op() {
            // Branches are in fact of B-type, we reuse S-type in CKB-VM
            // since they share the same constructs after decoding, but
            // they have different encoding rules in texts.
            insts::OP_BEQ
            | insts::OP_BNE
            | insts::OP_BLT
            | insts::OP_BGE
            | insts::OP_BLTU
            | insts::OP_BGEU => write!(
                f,
                "{} {},{},{}",
                instruction_opcode_name(self.op()).to_lowercase(),
                REGISTER_ABI_NAMES[self.rs1()],
                REGISTER_ABI_NAMES[self.rs2()],
                self.immediate_s()
            ),
            _ => write!(
                f,
                "{} {},{}({})",
                instruction_opcode_name(self.op()).to_lowercase(),
                REGISTER_ABI_NAMES[self.rs2()],
                self.immediate_s(),
                REGISTER_ABI_NAMES[self.rs1()]
            ),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Utype(pub Instruction);

impl Utype {
    pub fn new(op: InstructionOpcode, rd: RegisterIndex, immediate_u: UImmediate) -> Self {
        Utype(
            (u64::from(op) >> 8 << 16)
                | u64::from(op as u8)
                | (u64::from(rd as u8) << 8)
                | (u64::from(immediate_u) << 32),
        )
    }

    pub fn new_s(op: InstructionOpcode, rd: RegisterIndex, immediate_s: SImmediate) -> Self {
        Self::new(op, rd, immediate_s as UImmediate)
    }

    pub fn op(self) -> InstructionOpcode {
        ((self.0 >> 16 << 8) | (self.0 & 0xFF)) as InstructionOpcode
    }

    pub fn rd(self) -> RegisterIndex {
        (self.0 >> 8) as u8 as RegisterIndex
    }

    pub fn immediate_u(self) -> UImmediate {
        self.immediate_s() as UImmediate
    }

    pub fn immediate_s(self) -> SImmediate {
        ((self.0 as i64) >> 32) as SImmediate
    }
}

impl fmt::Display for Utype {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "{} {},{}",
            instruction_opcode_name(self.op()).to_lowercase(),
            REGISTER_ABI_NAMES[self.rd()],
            self.immediate_s()
        )
    }
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct R4type(pub Instruction);

impl R4type {
    pub fn new(
        op: InstructionOpcode,
        rd: RegisterIndex,
        rs1: RegisterIndex,
        rs2: RegisterIndex,
        rs3: RegisterIndex,
    ) -> Self {
        R4type(
            (u64::from(op) >> 8 << 16)
                | u64::from(op as u8)
                | (u64::from(rd as u8) << 8)
                | (u64::from(rs1 as u8) << 32)
                | (u64::from(rs2 as u8) << 40)
                | (u64::from(rs3 as u8) << 48),
        )
    }

    pub fn op(self) -> InstructionOpcode {
        ((self.0 >> 16 << 8) | (self.0 & 0xFF)) as InstructionOpcode
    }

    pub fn rd(self) -> RegisterIndex {
        (self.0 >> 8) as u8 as RegisterIndex
    }

    pub fn rs1(self) -> RegisterIndex {
        (self.0 >> 32) as u8 as RegisterIndex
    }

    pub fn rs2(self) -> RegisterIndex {
        (self.0 >> 40) as u8 as RegisterIndex
    }

    pub fn rs3(self) -> RegisterIndex {
        (self.0 >> 48) as u8 as RegisterIndex
    }
}

impl fmt::Display for R4type {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "{} {},{},{},{}",
            instruction_opcode_name(self.op()).to_lowercase(),
            REGISTER_ABI_NAMES[self.rd()],
            REGISTER_ABI_NAMES[self.rs1()],
            REGISTER_ABI_NAMES[self.rs2()],
            REGISTER_ABI_NAMES[self.rs3()]
        )
    }
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct R5type(pub Instruction);

impl R5type {
    pub fn new(
        op: InstructionOpcode,
        rd: RegisterIndex,
        rs1: RegisterIndex,
        rs2: RegisterIndex,
        rs3: RegisterIndex,
        rs4: RegisterIndex,
    ) -> Self {
        R5type(
            ((op as u64) >> 8 << 16)
                | (op as u8 as u64)
                | ((rd as u8 as u64) << 8)
                | ((rs1 as u8 as u64) << 32)
                | ((rs2 as u8 as u64) << 40)
                | ((rs3 as u8 as u64) << 48)
                | ((rs4 as u8 as u64) << 56),
        )
    }

    pub fn op(self) -> InstructionOpcode {
        ((self.0 >> 16 << 8) | (self.0 & 0xFF)) as InstructionOpcode
    }

    pub fn rd(self) -> RegisterIndex {
        (self.0 >> 8) as u8 as RegisterIndex
    }

    pub fn rs1(self) -> RegisterIndex {
        (self.0 >> 32) as u8 as RegisterIndex
    }

    pub fn rs2(self) -> RegisterIndex {
        (self.0 >> 40) as u8 as RegisterIndex
    }

    pub fn rs3(self) -> RegisterIndex {
        (self.0 >> 48) as u8 as RegisterIndex
    }

    pub fn rs4(self) -> RegisterIndex {
        (self.0 >> 56) as u8 as RegisterIndex
    }
}

impl fmt::Display for R5type {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "{} {},{},{},{},{}",
            instruction_opcode_name(self.op()).to_lowercase(),
            REGISTER_ABI_NAMES[self.rd()],
            REGISTER_ABI_NAMES[self.rs1()],
            REGISTER_ABI_NAMES[self.rs2()],
            REGISTER_ABI_NAMES[self.rs3()],
            REGISTER_ABI_NAMES[self.rs4()]
        )
    }
}

pub fn is_slowpath_instruction(i: Instruction) -> bool {
    (i as u8 as u16) < MINIMAL_OPCODE
}

pub fn is_basic_block_end_instruction(i: Instruction) -> bool {
    let opcode = extract_opcode(i);
    (MINIMAL_BASIC_BLOCK_END_OPCODE..=MAXIMUM_BASIC_BLOCK_END_OPCODE).contains(&opcode)
        || is_slowpath_instruction(i)
}

#[inline(always)]
pub fn set_instruction_length_2(i: u64) -> u64 {
    i | 0x1000000
}

#[inline(always)]
pub fn set_instruction_length_4(i: u64) -> u64 {
    i | 0x2000000
}

#[inline(always)]
pub fn set_instruction_length_n(i: u64, n: u8) -> u64 {
    debug_assert!(n % 2 == 0);
    debug_assert!(n <= 30);
    i | ((n as u64 & 0x1f) >> 1 << 24)
}

#[inline(always)]
pub fn instruction_length(i: Instruction) -> u8 {
    (((i >> 24) & 0x0f) << 1) as u8
}

#[cfg(test)]
mod tests {
    use super::i::factory;
    use super::*;
    use ckb_vm_definitions::{for_each_inst1, instructions::MAXIMUM_OPCODE};
    use std::cmp::{max, min};
    use std::mem::size_of;

    #[test]
    fn test_instruction_op_should_fit_in_byte() {
        assert_eq!(2, size_of::<InstructionOpcode>());
    }

    #[test]
    fn test_stype_display() {
        // This is "sd	a5,568(sp)"
        let sd_inst = 0x22f13c23;
        let decoded = factory::<u64>(sd_inst, u32::MAX).expect("decoding");
        let stype = Stype(decoded);

        assert_eq!("sd a5,568(sp)", format!("{}", stype));

        // This is "beq	a0,a5,1012e"
        let sd_inst = 0xf4f500e3;
        let decoded = factory::<u64>(sd_inst, u32::MAX).expect("decoding");
        let stype = Stype(decoded);

        assert_eq!("beq a0,a5,-192", format!("{}", stype));
    }

    macro_rules! update_min_opcode {
        ($name:ident, $real_name:ident, $code:expr, $x:ident) => {
            $x = min($code, $x);
        };
    }

    #[test]
    fn test_minimal_opcode_is_minimal() {
        let mut o = MINIMAL_OPCODE;
        for_each_inst1!(update_min_opcode, o);
        assert_eq!(MINIMAL_OPCODE, o);
    }

    macro_rules! update_max_opcode {
        ($name:ident, $real_name:ident, $code:expr, $x:ident) => {
            $x = max($code, $x);
        };
    }

    #[test]
    fn test_maximal_opcode_is_maximal() {
        let mut o = MAXIMUM_OPCODE;
        for_each_inst1!(update_max_opcode, o);
        assert_eq!(MAXIMUM_OPCODE, o);
    }

    #[test]
    fn test_basic_block_end_opcode_is_in_range() {
        for o in MINIMAL_OPCODE..=MAXIMUM_OPCODE {
            if is_basic_block_end_instruction(blank_instruction(o)) {
                assert!(
                    o >= MINIMAL_BASIC_BLOCK_END_OPCODE,
                    "Opcode {} ({}) is smaller than minimal basic block end opcode!",
                    o,
                    instruction_opcode_name(o)
                );
                assert!(
                    o <= MAXIMUM_BASIC_BLOCK_END_OPCODE,
                    "Opcode {} ({}) is bigger than maximum basic block end opcode!",
                    o,
                    instruction_opcode_name(o)
                );
            }
        }
    }

    macro_rules! test_opcode_with_last {
        ($name:ident, $real_name:ident, $code:expr, $last:ident) => {
            assert_eq!(
                $last + 1,
                $code,
                "Opcode {} ({}) does not follow last opcode!",
                stringify!($real_name),
                $code
            );
            $last = $code;
        };
    }

    #[test]
    fn test_opcodes_are_defined_seqentially() {
        let mut last = MINIMAL_OPCODE - 1;
        for_each_inst1!(test_opcode_with_last, last);
        assert_eq!(last, MAXIMUM_OPCODE);
    }

    #[test]
    fn test_instruction_is_essentially_u64() {
        assert_eq!(
            std::mem::size_of::<Instruction>(),
            std::mem::size_of::<u64>()
        );
    }
}


================================================
File: src/instructions/register.rs
================================================
use std::cmp::min;
use std::fmt::Display;
use std::ops::{BitAnd, BitOr, BitXor, Not, Shl, Shr};

pub trait Register:
    Sized
    + Clone
    + Default
    + Display
    + Not<Output = Self>
    + BitAnd<Output = Self>
    + BitOr<Output = Self>
    + BitXor<Output = Self>
    + Shl<Self, Output = Self>
    + Shr<Self, Output = Self>
{
    const BITS: u8;
    const SHIFT_MASK: u8;

    fn zero() -> Self;
    fn one() -> Self;

    fn min_value() -> Self;
    fn max_value() -> Self;

    // Conditional operations, if the condition evaluated here is true, R::one()
    // will be emitted, otherwise R::zero() will be emitted
    fn eq(&self, other: &Self) -> Self;
    fn lt(&self, other: &Self) -> Self;
    fn lt_s(&self, other: &Self) -> Self;
    fn logical_not(&self) -> Self;

    // self here should be the result of one of the conditional operations, if
    // self is R::one(), true_value will be returned, otherwise false_value will
    // be returned. No values other than R::one() or R::zero() should be accepted
    // as self here.
    fn cond(&self, true_value: &Self, false_value: &Self) -> Self;

    fn overflowing_add(&self, rhs: &Self) -> Self;
    fn overflowing_sub(&self, rhs: &Self) -> Self;
    fn overflowing_mul(&self, rhs: &Self) -> Self;

    // Those 4 methods should implement RISC-V's overflowing strategies:
    // +---------------------------------------------------------------------------------------+
    // | Condition              | Dividend  | Divisor | DIVU[W] | REMU[W] |  DIV[W]   | REM[W] |
    // +------------------------+-----------+---------+---------+---------+-----------+--------+
    // | Division by zero       |     x     |    0    | 2**L-1  |    x    |    -1     |   x    |
    // +------------------------+-----------+---------+---------+---------+-----------+--------+
    // | Overflow (signed only) | −2**(L−1) |   −1    |    -    |    -    | -2**(L-1) |   0    |
    // +---------------------------------------------------------------------------------------+
    fn overflowing_div(&self, rhs: &Self) -> Self;
    fn overflowing_rem(&self, rhs: &Self) -> Self;
    fn overflowing_div_signed(&self, rhs: &Self) -> Self;
    fn overflowing_rem_signed(&self, rhs: &Self) -> Self;

    fn overflowing_mul_high_signed(&self, rhs: &Self) -> Self;
    fn overflowing_mul_high_unsigned(&self, rhs: &Self) -> Self;
    fn overflowing_mul_high_signed_unsigned(&self, rhs: &Self) -> Self;

    // The clz operation counts the number of 0 bits at the MSB end of the argument.
    fn clz(&self) -> Self;
    // The ctz operation counts the number of 0 bits at the LSB end of the argument.
    fn ctz(&self) -> Self;
    // Counts the number of 1 bits.
    fn cpop(&self) -> Self;
    // Carry-less multiply (low-part)
    fn clmul(&self, rhs: &Self) -> Self;
    // Carry-less multiply (high-part)
    fn clmulh(&self, rhs: &Self) -> Self;
    // Carry-less multiply (reversed)
    fn clmulr(&self, rhs: &Self) -> Self;
    fn orcb(&self) -> Self;
    fn rev8(&self) -> Self;

    fn signed_shl(&self, rhs: &Self) -> Self;
    fn signed_shr(&self, rhs: &Self) -> Self;

    // Rotate left/right.
    fn rol(&self, rhs: &Self) -> Self;
    fn ror(&self, rhs: &Self) -> Self;

    // Zero extend from start_bit to the highest bit, note
    // start_bit is offset by 0
    fn zero_extend(&self, start_bit: &Self) -> Self;
    // Sign extend from start_bit to the highest bit leveraging
    // bit in (start_bit - 1), note start_bit is offset by 0
    fn sign_extend(&self, start_bit: &Self) -> Self;

    // NOTE: one alternative solution is to encode those methods using
    // From/Into traits, however we opt for manual conversion here for 2
    // reasons:
    // 1. This leads to more clarity in code, so when we see `to_u8`, we know
    // immediately that the method is called on a register type, while `as u8`
    // tells us it's a different type.
    // 2. Adding those additional methods allows us to implement this trait on
    // plain u32/u64 types.
    fn to_i8(&self) -> i8;
    fn to_i16(&self) -> i16;
    fn to_i32(&self) -> i32;
    fn to_i64(&self) -> i64;
    fn to_u8(&self) -> u8;
    fn to_u16(&self) -> u16;
    fn to_u32(&self) -> u32;
    fn to_u64(&self) -> u64;

    fn from_i8(v: i8) -> Self;
    fn from_i16(v: i16) -> Self;
    fn from_i32(v: i32) -> Self;
    fn from_i64(v: i64) -> Self;
    fn from_u8(v: u8) -> Self;
    fn from_u16(v: u16) -> Self;
    fn from_u32(v: u32) -> Self;
    fn from_u64(v: u64) -> Self;

    fn ne(&self, rhs: &Self) -> Self {
        self.eq(rhs).logical_not()
    }

    fn ge(&self, other: &Self) -> Self {
        self.lt(other).logical_not()
    }

    fn ge_s(&self, other: &Self) -> Self {
        self.lt_s(other).logical_not()
    }
}

impl Register for u32 {
    const BITS: u8 = 32;
    const SHIFT_MASK: u8 = 0x1F;

    fn zero() -> u32 {
        0
    }

    fn one() -> u32 {
        1
    }

    fn min_value() -> u32 {
        u32::MIN
    }

    fn max_value() -> u32 {
        u32::MAX
    }

    fn eq(&self, other: &u32) -> u32 {
        (self == other).into()
    }

    fn lt(&self, other: &u32) -> u32 {
        (self < other).into()
    }

    fn lt_s(&self, other: &u32) -> u32 {
        ((*self as i32) < (*other as i32)).into()
    }

    fn logical_not(&self) -> u32 {
        (*self != Self::one()).into()
    }

    fn cond(&self, true_value: &u32, false_value: &u32) -> u32 {
        if *self == Self::one() {
            *true_value
        } else {
            *false_value
        }
    }

    fn overflowing_add(&self, rhs: &u32) -> u32 {
        (*self).overflowing_add(*rhs).0
    }

    fn overflowing_sub(&self, rhs: &u32) -> u32 {
        (*self).overflowing_sub(*rhs).0
    }

    fn overflowing_mul(&self, rhs: &u32) -> u32 {
        (*self).overflowing_mul(*rhs).0
    }

    fn overflowing_div(&self, rhs: &u32) -> u32 {
        if *rhs == 0 {
            Self::MAX
        } else {
            (*self).overflowing_div(*rhs).0
        }
    }

    fn overflowing_rem(&self, rhs: &u32) -> u32 {
        if *rhs == 0 {
            *self
        } else {
            (*self).overflowing_rem(*rhs).0
        }
    }

    fn overflowing_div_signed(&self, rhs: &u32) -> u32 {
        if *rhs == 0 {
            (-1i32) as u32
        } else {
            let (v, o) = (*self as i32).overflowing_div(*rhs as i32);
            if o {
                // -2**(L-1) implemented using (-1) << (L - 1)
                ((-1i32) as u32) << (<Self as Register>::BITS - 1)
            } else {
                v as u32
            }
        }
    }

    fn overflowing_rem_signed(&self, rhs: &u32) -> u32 {
        if *rhs == 0 {
            *self
        } else {
            let (v, o) = (*self as i32).overflowing_rem(*rhs as i32);
            if o {
                0
            } else {
                v as u32
            }
        }
    }

    fn overflowing_mul_high_signed(&self, rhs: &u32) -> u32 {
        let a = i64::from(*self as i32);
        let b = i64::from(*rhs as i32);
        let (value, _) = a.overflowing_mul(b);
        (value >> 32) as u32
    }

    fn overflowing_mul_high_unsigned(&self, rhs: &u32) -> u32 {
        let a = u64::from(*self);
        let b = u64::from(*rhs);
        let (value, _) = a.overflowing_mul(b);
        (value >> 32) as u32
    }

    fn overflowing_mul_high_signed_unsigned(&self, rhs: &u32) -> u32 {
        let a = i64::from(*self as i32);
        let b = i64::from(*rhs);
        let (value, _) = a.overflowing_mul(b);
        (value >> 32) as u32
    }

    fn signed_shl(&self, rhs: &u32) -> u32 {
        (*self as i32).shl(*rhs) as u32
    }

    fn signed_shr(&self, rhs: &u32) -> u32 {
        (*self as i32).shr(*rhs) as u32
    }

    fn zero_extend(&self, start_bit: &u32) -> u32 {
        let start_bit = min(*start_bit, 32);
        debug_assert!(start_bit > 0);
        (*self << (32 - start_bit)) >> (32 - start_bit)
    }

    fn sign_extend(&self, start_bit: &u32) -> u32 {
        let start_bit = min(*start_bit, 32);
        debug_assert!(start_bit > 0);
        (((*self << (32 - start_bit)) as i32) >> (32 - start_bit)) as u32
    }

    fn clz(&self) -> u32 {
        self.leading_zeros()
    }

    fn ctz(&self) -> u32 {
        self.trailing_zeros()
    }

    fn cpop(&self) -> u32 {
        self.count_ones()
    }

    fn clmul(&self, rhs: &u32) -> u32 {
        let mut x: u32 = 0;
        for i in 0..32 {
            if ((rhs >> i) & 1) != 0 {
                x ^= self << i;
            }
        }
        x
    }

    fn clmulh(&self, rhs: &u32) -> u32 {
        let mut x: u32 = 0;
        for i in 1..32 {
            if ((rhs >> i) & 1) != 0 {
                x ^= self >> (32 - i);
            }
        }
        x
    }

    fn clmulr(&self, rhs: &u32) -> u32 {
        let mut x: u32 = 0;
        for i in 0..32 {
            if ((rhs >> i) & 1) != 0 {
                x ^= self >> (31 - i);
            }
        }
        x
    }

    fn orcb(&self) -> u32 {
        let mut rr = 0;
        if self & 0x000000ff != 0 {
            rr |= 0x000000ff
        }
        if self & 0x0000ff00 != 0 {
            rr |= 0x0000ff00
        }
        if self & 0x00ff0000 != 0 {
            rr |= 0x00ff0000
        }
        if self & 0xff000000 != 0 {
            rr |= 0xff000000
        }
        rr
    }

    fn rev8(&self) -> u32 {
        let mut r = 0;
        let a = self & 0x000000ff;
        r |= a << 24;
        let a = self & 0x0000ff00;
        r |= a << 8;
        let a = self & 0x00ff0000;
        r |= a >> 8;
        let a = self & 0xff000000;
        r |= a >> 24;
        r
    }

    fn rol(&self, rhs: &u32) -> u32 {
        (*self as u32).rotate_left(*rhs) as u32
    }

    fn ror(&self, rhs: &u32) -> u32 {
        (*self as u32).rotate_right(*rhs) as u32
    }

    fn to_i8(&self) -> i8 {
        *self as i8
    }

    fn to_i16(&self) -> i16 {
        *self as i16
    }

    fn to_i32(&self) -> i32 {
        *self as i32
    }

    fn to_i64(&self) -> i64 {
        i64::from(*self as i32)
    }

    fn to_u8(&self) -> u8 {
        *self as u8
    }

    fn to_u16(&self) -> u16 {
        *self as u16
    }

    fn to_u32(&self) -> u32 {
        *self
    }

    fn to_u64(&self) -> u64 {
        u64::from(*self)
    }

    fn from_i8(v: i8) -> u32 {
        i32::from(v) as u32
    }

    fn from_i16(v: i16) -> u32 {
        i32::from(v) as u32
    }

    fn from_i32(v: i32) -> u32 {
        v as u32
    }

    fn from_i64(v: i64) -> u32 {
        (v as i32) as u32
    }

    fn from_u8(v: u8) -> u32 {
        u32::from(v)
    }

    fn from_u16(v: u16) -> u32 {
        u32::from(v)
    }

    fn from_u32(v: u32) -> u32 {
        v
    }

    fn from_u64(v: u64) -> u32 {
        v as u32
    }
}

impl Register for u64 {
    const BITS: u8 = 64;
    const SHIFT_MASK: u8 = 0x3F;

    fn zero() -> u64 {
        0
    }

    fn one() -> u64 {
        1
    }

    fn min_value() -> u64 {
        u64::MIN
    }

    fn max_value() -> u64 {
        u64::MAX
    }

    fn eq(&self, other: &u64) -> u64 {
        (self == other).into()
    }

    fn lt(&self, other: &u64) -> u64 {
        (self < other).into()
    }

    fn lt_s(&self, other: &u64) -> u64 {
        ((*self as i64) < (*other as i64)).into()
    }

    fn logical_not(&self) -> u64 {
        (*self != Self::one()).into()
    }

    fn cond(&self, true_value: &u64, false_value: &u64) -> u64 {
        if *self == Self::one() {
            *true_value
        } else {
            *false_value
        }
    }

    fn overflowing_add(&self, rhs: &u64) -> u64 {
        (*self).overflowing_add(*rhs).0
    }

    fn overflowing_sub(&self, rhs: &u64) -> u64 {
        (*self).overflowing_sub(*rhs).0
    }

    fn overflowing_mul(&self, rhs: &u64) -> u64 {
        (*self).overflowing_mul(*rhs).0
    }

    fn overflowing_div(&self, rhs: &u64) -> u64 {
        if *rhs == 0 {
            Self::MAX
        } else {
            (*self).overflowing_div(*rhs).0
        }
    }

    fn overflowing_rem(&self, rhs: &u64) -> u64 {
        if *rhs == 0 {
            *self
        } else {
            (*self).overflowing_rem(*rhs).0
        }
    }

    fn overflowing_div_signed(&self, rhs: &u64) -> u64 {
        if *rhs == 0 {
            (-1i64) as u64
        } else {
            let (v, o) = (*self as i64).overflowing_div(*rhs as i64);
            if o {
                // -2**(L-1) implemented using (-1) << (L - 1)
                ((-1i64) as u64) << (<Self as Register>::BITS - 1)
            } else {
                v as u64
            }
        }
    }

    fn overflowing_rem_signed(&self, rhs: &u64) -> u64 {
        if *rhs == 0 {
            *self
        } else {
            let (v, o) = (*self as i64).overflowing_rem(*rhs as i64);
            if o {
                0
            } else {
                v as u64
            }
        }
    }

    fn overflowing_mul_high_signed(&self, rhs: &u64) -> u64 {
        let a = i128::from(*self as i64);
        let b = i128::from(*rhs as i64);
        let (value, _) = a.overflowing_mul(b);
        (value >> 64) as u64
    }

    fn overflowing_mul_high_unsigned(&self, rhs: &u64) -> u64 {
        let a = u128::from(*self);
        let b = u128::from(*rhs);
        let (value, _) = a.overflowing_mul(b);
        (value >> 64) as u64
    }

    fn overflowing_mul_high_signed_unsigned(&self, rhs: &u64) -> u64 {
        let a = i128::from(*self as i64);
        let b = i128::from(*rhs);
        let (value, _) = a.overflowing_mul(b);
        (value >> 64) as u64
    }

    fn signed_shl(&self, rhs: &u64) -> u64 {
        (*self as i64).shl(*rhs) as u64
    }

    fn signed_shr(&self, rhs: &u64) -> u64 {
        (*self as i64).shr(*rhs) as u64
    }

    fn zero_extend(&self, start_bit: &u64) -> u64 {
        let start_bit = min(*start_bit, 64);
        debug_assert!(start_bit > 0);
        (*self << (64 - start_bit)) >> (64 - start_bit)
    }

    fn sign_extend(&self, start_bit: &u64) -> u64 {
        let start_bit = min(*start_bit, 64);
        debug_assert!(start_bit > 0);
        (((*self << (64 - start_bit)) as i64) >> (64 - start_bit)) as u64
    }

    fn clz(&self) -> u64 {
        self.leading_zeros() as u64
    }

    fn ctz(&self) -> u64 {
        self.trailing_zeros() as u64
    }

    fn cpop(&self) -> u64 {
        self.count_ones() as u64
    }

    fn clmul(&self, rhs: &u64) -> u64 {
        let mut x: u64 = 0;
        for i in 0..64 {
            if ((rhs >> i) & 1) != 0 {
                x ^= self << i;
            }
        }
        x
    }

    fn clmulh(&self, rhs: &u64) -> u64 {
        let mut x: u64 = 0;
        for i in 1..64 {
            if ((rhs >> i) & 1) != 0 {
                x ^= self >> (64 - i);
            }
        }
        x
    }

    fn clmulr(&self, rhs: &u64) -> u64 {
        let mut x: u64 = 0;
        for i in 0..64 {
            if ((rhs >> i) & 1) != 0 {
                x ^= self >> (63 - i);
            }
        }
        x
    }

    fn orcb(&self) -> u64 {
        let mut rr = 0;
        if self & 0x00000000000000ff != 0 {
            rr |= 0x00000000000000ff
        }
        if self & 0x000000000000ff00 != 0 {
            rr |= 0x000000000000ff00
        }
        if self & 0x0000000000ff0000 != 0 {
            rr |= 0x0000000000ff0000
        }
        if self & 0x00000000ff000000 != 0 {
            rr |= 0x00000000ff000000
        }
        if self & 0x000000ff00000000 != 0 {
            rr |= 0x000000ff00000000
        }
        if self & 0x0000ff0000000000 != 0 {
            rr |= 0x0000ff0000000000
        }
        if self & 0x00ff000000000000 != 0 {
            rr |= 0x00ff000000000000
        }
        if self & 0xff00000000000000 != 0 {
            rr |= 0xff00000000000000
        }
        rr
    }

    fn rev8(&self) -> u64 {
        let mut r = 0;
        let a = self & 0x00000000000000ff;
        r |= a << 56;
        let a = self & 0x000000000000ff00;
        r |= a << 40;
        let a = self & 0x0000000000ff0000;
        r |= a << 24;
        let a = self & 0x00000000ff000000;
        r |= a << 8;
        let a = self & 0x000000ff00000000;
        r |= a >> 8;
        let a = self & 0x0000ff0000000000;
        r |= a >> 24;
        let a = self & 0x00ff000000000000;
        r |= a >> 40;
        let a = self & 0xff00000000000000;
        r |= a >> 56;
        r
    }

    fn rol(&self, rhs: &u64) -> u64 {
        (*self as u64).rotate_left((*rhs) as u32) as u64
    }

    fn ror(&self, rhs: &u64) -> u64 {
        (*self as u64).rotate_right((*rhs) as u32) as u64
    }

    fn to_i8(&self) -> i8 {
        *self as i8
    }

    fn to_i16(&self) -> i16 {
        *self as i16
    }

    fn to_i32(&self) -> i32 {
        *self as i32
    }

    fn to_i64(&self) -> i64 {
        *self as i64
    }

    fn to_u8(&self) -> u8 {
        *self as u8
    }

    fn to_u16(&self) -> u16 {
        *self as u16
    }

    fn to_u32(&self) -> u32 {
        *self as u32
    }

    fn to_u64(&self) -> u64 {
        *self
    }

    fn from_i8(v: i8) -> u64 {
        i64::from(v) as u64
    }

    fn from_i16(v: i16) -> u64 {
        i64::from(v) as u64
    }

    fn from_i32(v: i32) -> u64 {
        i64::from(v) as u64
    }

    fn from_i64(v: i64) -> u64 {
        v as u64
    }

    fn from_u8(v: u8) -> u64 {
        u64::from(v)
    }

    fn from_u16(v: u16) -> u64 {
        u64::from(v)
    }

    fn from_u32(v: u32) -> u64 {
        u64::from(v)
    }

    fn from_u64(v: u64) -> u64 {
        v
    }
}


================================================
File: src/instructions/rvc.rs
================================================
use ckb_vm_definitions::instructions::{self as insts};
use ckb_vm_definitions::registers::SP;

use super::i::nop;
use super::register::Register;
use super::utils::{jalr, ld, lw, rd, x, xs};
use super::{blank_instruction, set_instruction_length_2, Instruction, Itype, Rtype, Stype, Utype};

// Notice the location of rs2 in RVC encoding is different from full encoding
#[inline(always)]
fn c_rs2(instruction_bits: u32) -> usize {
    x(instruction_bits, 2, 5, 0) as usize
}

// This function extract 3 bits from least_bit to form a register number,
// here since we are only using 3 bits, we can only reference the most popular
// used registers x8 - x15. In other words, a number of 0 extracted here means
// x8, 1 means x9, etc.
#[inline(always)]
fn compact_register_number(instruction_bits: u32, least_bit: usize) -> usize {
    x(instruction_bits, least_bit, 3, 0) as usize + 8
}

// [12]  => imm[5]
// [6:2] => imm[4:0]
fn immediate(instruction_bits: u32) -> i32 {
    (x(instruction_bits, 2, 5, 0) | xs(instruction_bits, 12, 1, 5)) as i32
}

// [12]  => imm[5]
// [6:2] => imm[4:0]
fn uimmediate(instruction_bits: u32) -> u32 {
    x(instruction_bits, 2, 5, 0) | x(instruction_bits, 12, 1, 5)
}

// [12:2] => imm[11|4|9:8|10|6|7|3:1|5]
fn j_immediate(instruction_bits: u32) -> i32 {
    (x(instruction_bits, 3, 3, 1)
        | x(instruction_bits, 11, 1, 4)
        | x(instruction_bits, 2, 1, 5)
        | x(instruction_bits, 7, 1, 6)
        | x(instruction_bits, 6, 1, 7)
        | x(instruction_bits, 9, 2, 8)
        | x(instruction_bits, 8, 1, 10)
        | xs(instruction_bits, 12, 1, 11)) as i32
}

// [12:10] => uimm[5:3]
// [6:5]   => uimm[7:6]
fn fld_uimmediate(instruction_bits: u32) -> u32 {
    x(instruction_bits, 10, 3, 3) | x(instruction_bits, 5, 2, 6)
}

// [10:12] => uimm[5:3]
// [5:6]   => uimm[2|6]
fn sw_uimmediate(instruction_bits: u32) -> u32 {
    x(instruction_bits, 6, 1, 2) | x(instruction_bits, 10, 3, 3) | x(instruction_bits, 5, 1, 6)
}

// [12]  => uimm[5]
// [6:2] => uimm[4:2|7:6]
fn lwsp_uimmediate(instruction_bits: u32) -> u32 {
    x(instruction_bits, 4, 3, 2) | x(instruction_bits, 12, 1, 5) | x(instruction_bits, 2, 2, 6)
}

// [12]  => uimm[5]
// [6:2] => uimm[4:3|8:6]
fn fldsp_uimmediate(instruction_bits: u32) -> u32 {
    x(instruction_bits, 5, 2, 3) | x(instruction_bits, 12, 1, 5) | x(instruction_bits, 2, 3, 6)
}

// [12:7] => uimm[5:3|8:6]
fn fsdsp_uimmediate(instruction_bits: u32) -> u32 {
    x(instruction_bits, 10, 3, 3) | x(instruction_bits, 7, 3, 6)
}

// [12:7] => uimm[5:2|7:6]
fn swsp_uimmediate(instruction_bits: u32) -> u32 {
    x(instruction_bits, 9, 4, 2) | x(instruction_bits, 7, 2, 6)
}

// [12:10] => imm[8|4:3]
// [6:2]   => imm[7:6|2:1|5]
fn b_immediate(instruction_bits: u32) -> i32 {
    (x(instruction_bits, 3, 2, 1)
        | x(instruction_bits, 10, 2, 3)
        | x(instruction_bits, 2, 1, 5)
        | x(instruction_bits, 5, 2, 6)
        | xs(instruction_bits, 12, 1, 8)) as i32
}

#[allow(clippy::cognitive_complexity)]
pub fn factory<R: Register>(instruction_bits: u32, version: u32) -> Option<Instruction> {
    let bit_length = R::BITS;
    if bit_length != 32 && bit_length != 64 {
        return None;
    }
    let rv32 = bit_length == 32;
    let rv64 = bit_length == 64;
    match instruction_bits & 0b_111_00000000000_11 {
        // == Quadrant 0
        0b_000_00000000000_00 => {
            let nzuimm = x(instruction_bits, 6, 1, 2)
                | x(instruction_bits, 5, 1, 3)
                | x(instruction_bits, 11, 2, 4)
                | x(instruction_bits, 7, 4, 6);
            if nzuimm != 0 {
                // C.ADDI4SPN
                Some(
                    Itype::new_u(
                        insts::OP_ADDI,
                        compact_register_number(instruction_bits, 2),
                        SP,
                        nzuimm,
                    )
                    .0,
                )
            } else {
                // Illegal instruction
                None
            }
        }
        0b_010_00000000000_00 => Some(
            // C.LW
            Itype::new_u(
                lw(version),
                compact_register_number(instruction_bits, 2),
                compact_register_number(instruction_bits, 7),
                sw_uimmediate(instruction_bits),
            )
            .0,
        ),
        0b_011_00000000000_00 => {
            if rv32 {
                None
            } else {
                // C.LD
                Some(
                    Itype::new_u(
                        ld(version),
                        compact_register_number(instruction_bits, 2),
                        compact_register_number(instruction_bits, 7),
                        fld_uimmediate(instruction_bits),
                    )
                    .0,
                )
            }
        }
        // Reserved
        0b_100_00000000000_00 => None,
        0b_110_00000000000_00 => Some(
            // C.SW
            Stype::new_u(
                insts::OP_SW,
                sw_uimmediate(instruction_bits),
                compact_register_number(instruction_bits, 7),
                compact_register_number(instruction_bits, 2),
            )
            .0,
        ),
        0b_111_00000000000_00 => {
            if rv32 {
                None
            } else {
                // C.SD
                Some(
                    Stype::new_u(
                        insts::OP_SD,
                        fld_uimmediate(instruction_bits),
                        compact_register_number(instruction_bits, 7),
                        compact_register_number(instruction_bits, 2),
                    )
                    .0,
                )
            }
        }
        // == Quadrant 1
        0b_000_00000000000_01 => {
            let nzimm = immediate(instruction_bits);
            let rd = rd(instruction_bits);
            if rd != 0 {
                // C.ADDI
                if nzimm != 0 {
                    Some(Itype::new_s(insts::OP_ADDI, rd, rd, nzimm).0)
                } else if version >= 1 {
                    // HINTs
                    Some(nop())
                } else {
                    None
                }
            } else {
                // C.NOP
                #[allow(clippy::if_same_then_else)]
                if nzimm == 0 {
                    Some(nop())
                } else if version >= 1 {
                    // HINTs
                    Some(nop())
                } else {
                    None
                }
            }
        }
        0b_001_00000000000_01 => {
            if rv32 {
                // C.JAL
                Some(Utype::new_s(insts::OP_JAL, 1, j_immediate(instruction_bits)).0)
            } else {
                let rd = rd(instruction_bits);
                if rd != 0 {
                    // C.ADDIW
                    Some(Itype::new_s(insts::OP_ADDIW, rd, rd, immediate(instruction_bits)).0)
                } else {
                    None
                }
            }
        }
        0b_010_00000000000_01 => {
            let rd = rd(instruction_bits);
            if rd != 0 {
                // C.LI
                Some(Itype::new_s(insts::OP_ADDI, rd, 0, immediate(instruction_bits)).0)
            } else if version >= 1 {
                // HINTs
                Some(nop())
            } else {
                None
            }
        }
        0b_011_00000000000_01 => {
            let imm = immediate(instruction_bits) << 12;
            if imm != 0 {
                let rd = rd(instruction_bits);
                if rd == SP {
                    // C.ADDI16SP
                    Some(
                        Itype::new_s(
                            insts::OP_ADDI,
                            SP,
                            SP,
                            (x(instruction_bits, 6, 1, 4)
                                | x(instruction_bits, 2, 1, 5)
                                | x(instruction_bits, 5, 1, 6)
                                | x(instruction_bits, 3, 2, 7)
                                | xs(instruction_bits, 12, 1, 9))
                                as i32,
                        )
                        .0,
                    )
                } else {
                    // C.LUI
                    if rd != 0 {
                        Some(Utype::new_s(insts::OP_LUI, rd, imm).0)
                    } else if version >= 1 {
                        // HINTs
                        Some(nop())
                    } else {
                        None
                    }
                }
            } else {
                None
            }
        }
        0b_100_00000000000_01 => {
            let rd = compact_register_number(instruction_bits, 7);
            match instruction_bits & 0b_1_11_000_11000_00 {
                // C.SRLI64
                0b_0_00_000_00000_00 if instruction_bits & 0b_111_00 == 0 => Some(nop()),
                // C.SRAI64
                0b_0_01_000_00000_00 if instruction_bits & 0b_111_00 == 0 => Some(nop()),
                // C.SUB
                0b_0_11_000_00000_00 => Some(
                    Rtype::new(
                        insts::OP_SUB,
                        rd,
                        rd,
                        compact_register_number(instruction_bits, 2),
                    )
                    .0,
                ),
                // C.XOR
                0b_0_11_000_01000_00 => Some(
                    Rtype::new(
                        insts::OP_XOR,
                        rd,
                        rd,
                        compact_register_number(instruction_bits, 2),
                    )
                    .0,
                ),
                // C.OR
                0b_0_11_000_10000_00 => Some(
                    Rtype::new(
                        insts::OP_OR,
                        rd,
                        rd,
                        compact_register_number(instruction_bits, 2),
                    )
                    .0,
                ),
                // C.AND
                0b_0_11_000_11000_00 => Some(
                    Rtype::new(
                        insts::OP_AND,
                        rd,
                        rd,
                        compact_register_number(instruction_bits, 2),
                    )
                    .0,
                ),
                // C.SUBW
                0b_1_11_000_00000_00 if rv64 => Some(
                    Rtype::new(
                        insts::OP_SUBW,
                        rd,
                        rd,
                        compact_register_number(instruction_bits, 2),
                    )
                    .0,
                ),
                // C.ADDW
                0b_1_11_000_01000_00 if rv64 => Some(
                    Rtype::new(
                        insts::OP_ADDW,
                        rd,
                        rd,
                        compact_register_number(instruction_bits, 2),
                    )
                    .0,
                ),
                // Reserved
                0b_1_11_000_10000_00 => None,
                // Reserved
                0b_1_11_000_11000_00 => None,
                _ => {
                    let uimm = uimmediate(instruction_bits);
                    match (instruction_bits & 0b_11_000_00000_00, uimm) {
                        // Invalid instruction
                        (0b_00_000_00000_00, 0) => None,
                        // C.SRLI
                        (0b_00_000_00000_00, uimm) => Some(
                            Itype::new_u(insts::OP_SRLI, rd, rd, uimm & u32::from(R::SHIFT_MASK)).0,
                        ),
                        // Invalid instruction
                        (0b_01_000_00000_00, 0) => None,
                        // C.SRAI
                        (0b_01_000_00000_00, uimm) => Some(
                            Itype::new_u(insts::OP_SRAI, rd, rd, uimm & u32::from(R::SHIFT_MASK)).0,
                        ),
                        // C.ANDI
                        (0b_10_000_00000_00, _) => Some(
                            Itype::new_s(insts::OP_ANDI, rd, rd, immediate(instruction_bits)).0,
                        ),
                        _ => None,
                    }
                }
            }
        }
        // C.J
        0b_101_00000000000_01 => {
            Some(Utype::new_s(insts::OP_JAL, 0, j_immediate(instruction_bits)).0)
        }
        // C.BEQZ
        0b_110_00000000000_01 => Some(
            Stype::new_s(
                insts::OP_BEQ,
                b_immediate(instruction_bits),
                compact_register_number(instruction_bits, 7),
                0,
            )
            .0,
        ),
        // C.BNEZ
        0b_111_00000000000_01 => Some(
            Stype::new_s(
                insts::OP_BNE,
                b_immediate(instruction_bits),
                compact_register_number(instruction_bits, 7),
                0,
            )
            .0,
        ),
        // == Quadrant 2
        0b_000_00000000000_10 => {
            let uimm = uimmediate(instruction_bits);
            let rd = rd(instruction_bits);
            if rd != 0 && uimm != 0 {
                // C.SLLI
                Some(Itype::new_u(insts::OP_SLLI, rd, rd, uimm & u32::from(R::SHIFT_MASK)).0)
            } else if version >= 1 {
                // HINTs
                Some(nop())
            } else {
                None
            }
        }
        0b_010_00000000000_10 => {
            let rd = rd(instruction_bits);
            if rd != 0 {
                // C.LWSP
                Some(Itype::new_u(lw(version), rd, SP, lwsp_uimmediate(instruction_bits)).0)
            } else {
                // Reserved
                None
            }
        }
        0b_011_00000000000_10 => {
            if rv32 {
                None
            } else {
                let rd = rd(instruction_bits);
                if rd != 0 {
                    // C.LDSP
                    Some(Itype::new_u(ld(version), rd, SP, fldsp_uimmediate(instruction_bits)).0)
                } else {
                    // Reserved
                    None
                }
            }
        }
        0b_100_00000000000_10 => {
            match instruction_bits & 0b_1_00000_00000_00 {
                0b_0_00000_00000_00 => {
                    let rd = rd(instruction_bits);
                    let rs2 = c_rs2(instruction_bits);
                    if rs2 == 0 {
                        if rd != 0 {
                            // C.JR
                            Some(Itype::new_s(jalr(version), 0, rd, 0).0)
                        } else {
                            // Reserved
                            None
                        }
                    } else {
                        if rd != 0 {
                            // C.MV
                            Some(Rtype::new(insts::OP_ADD, rd, 0, rs2).0)
                        } else if version >= 1 {
                            // HINTs
                            Some(nop())
                        } else {
                            None
                        }
                    }
                }
                0b_1_00000_00000_00 => {
                    let rd = rd(instruction_bits);
                    let rs2 = c_rs2(instruction_bits);
                    match (rd, rs2) {
                        // C.EBREAK
                        (0, 0) => Some(blank_instruction(insts::OP_EBREAK)),
                        // C.JALR
                        (rs1, 0) => Some(Itype::new_s(jalr(version), 1, rs1, 0).0),
                        // C.ADD
                        (rd, rs2) => {
                            if rd != 0 {
                                Some(Rtype::new(insts::OP_ADD, rd, rd, rs2).0)
                            } else if version >= 1 {
                                // HINTs
                                Some(nop())
                            } else {
                                None
                            }
                        }
                    }
                }
                _ => unreachable!(),
            }
        }
        0b_110_00000000000_10 => Some(
            // C.SWSP
            Stype::new_u(
                insts::OP_SW,
                swsp_uimmediate(instruction_bits),
                SP,
                c_rs2(instruction_bits),
            )
            .0,
        ),
        0b_111_00000000000_10 => {
            if rv32 {
                None
            } else {
                // C.SDSP
                Some(
                    Stype::new_u(
                        insts::OP_SD,
                        fsdsp_uimmediate(instruction_bits),
                        2,
                        c_rs2(instruction_bits),
                    )
                    .0,
                )
            }
        }
        _ => None,
    }
    .map(set_instruction_length_2)
}


================================================
File: src/instructions/tagged.rs
================================================
use crate::{
    error::Error,
    instructions::{
        extract_opcode, insts, Instruction, Itype, R4type, R5type, Rtype, Stype, Utype,
    },
};
use core::convert::TryFrom;
use core::fmt;

// This is used for generating human readable texts from RISC-V instructions.
// For performance reason, ckb-vm will not use this representation internally.
#[derive(Debug, Clone, PartialEq)]
pub enum TaggedInstruction {
    Rtype(Rtype),
    Itype(Itype),
    Stype(Stype),
    Utype(Utype),
    R4type(R4type),
    R5type(R5type),
}

impl fmt::Display for TaggedInstruction {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            TaggedInstruction::Rtype(i) => i.fmt(f),
            TaggedInstruction::Itype(i) => i.fmt(f),
            TaggedInstruction::Stype(i) => i.fmt(f),
            TaggedInstruction::Utype(i) => i.fmt(f),
            TaggedInstruction::R4type(i) => i.fmt(f),
            TaggedInstruction::R5type(i) => i.fmt(f),
        }
    }
}

impl From<Rtype> for TaggedInstruction {
    fn from(i: Rtype) -> Self {
        TaggedInstruction::Rtype(i)
    }
}

impl From<Itype> for TaggedInstruction {
    fn from(i: Itype) -> Self {
        TaggedInstruction::Itype(i)
    }
}

impl From<Stype> for TaggedInstruction {
    fn from(i: Stype) -> Self {
        TaggedInstruction::Stype(i)
    }
}

impl From<Utype> for TaggedInstruction {
    fn from(i: Utype) -> Self {
        TaggedInstruction::Utype(i)
    }
}

impl From<R4type> for TaggedInstruction {
    fn from(i: R4type) -> Self {
        TaggedInstruction::R4type(i)
    }
}

impl From<R5type> for TaggedInstruction {
    fn from(i: R5type) -> Self {
        TaggedInstruction::R5type(i)
    }
}

impl From<TaggedInstruction> for Instruction {
    fn from(t: TaggedInstruction) -> Self {
        match t {
            TaggedInstruction::Rtype(i) => i.0,
            TaggedInstruction::Itype(i) => i.0,
            TaggedInstruction::Stype(i) => i.0,
            TaggedInstruction::Utype(i) => i.0,
            TaggedInstruction::R4type(i) => i.0,
            TaggedInstruction::R5type(i) => i.0,
        }
    }
}

impl TryFrom<Instruction> for TaggedInstruction {
    type Error = Error;

    fn try_from(i: Instruction) -> Result<Self, Self::Error> {
        let op = extract_opcode(i);
        let tagged_inst = match op {
            insts::OP_UNLOADED => Rtype(i).into(),
            insts::OP_ECALL => Rtype(i).into(),
            insts::OP_EBREAK => Rtype(i).into(),
            insts::OP_FENCEI => Rtype(i).into(),
            insts::OP_FENCE => Rtype(i).into(),
            insts::OP_CUSTOM_TRACE_END => Rtype(i).into(),
            insts::OP_CUSTOM_ASM_TRACE_JUMP => Rtype(i).into(),
            insts::OP_SUB => Rtype(i).into(),
            insts::OP_SUBW => Rtype(i).into(),
            insts::OP_ADD => Rtype(i).into(),
            insts::OP_ADDW => Rtype(i).into(),
            insts::OP_XOR => Rtype(i).into(),
            insts::OP_OR => Rtype(i).into(),
            insts::OP_AND => Rtype(i).into(),
            insts::OP_SLL => Rtype(i).into(),
            insts::OP_SLLW => Rtype(i).into(),
            insts::OP_SRL => Rtype(i).into(),
            insts::OP_SRLW => Rtype(i).into(),
            insts::OP_SRA => Rtype(i).into(),
            insts::OP_SRAW => Rtype(i).into(),
            insts::OP_SLT => Rtype(i).into(),
            insts::OP_SLTU => Rtype(i).into(),
            insts::OP_LB_VERSION0 => Itype(i).into(),
            insts::OP_LB_VERSION1 => Itype(i).into(),
            insts::OP_LH_VERSION0 => Itype(i).into(),
            insts::OP_LH_VERSION1 => Itype(i).into(),
            insts::OP_LW_VERSION0 => Itype(i).into(),
            insts::OP_LW_VERSION1 => Itype(i).into(),
            insts::OP_LD_VERSION0 => Itype(i).into(),
            insts::OP_LD_VERSION1 => Itype(i).into(),
            insts::OP_LBU_VERSION0 => Itype(i).into(),
            insts::OP_LBU_VERSION1 => Itype(i).into(),
            insts::OP_LHU_VERSION0 => Itype(i).into(),
            insts::OP_LHU_VERSION1 => Itype(i).into(),
            insts::OP_LWU_VERSION0 => Itype(i).into(),
            insts::OP_LWU_VERSION1 => Itype(i).into(),
            insts::OP_ADDI => Itype(i).into(),
            insts::OP_ADDIW => Itype(i).into(),
            insts::OP_XORI => Itype(i).into(),
            insts::OP_ORI => Itype(i).into(),
            insts::OP_ANDI => Itype(i).into(),
            insts::OP_SLTI => Itype(i).into(),
            insts::OP_SLTIU => Itype(i).into(),
            insts::OP_JALR_VERSION0 => Itype(i).into(),
            insts::OP_JALR_VERSION1 => Itype(i).into(),
            insts::OP_SLLI => Itype(i).into(),
            insts::OP_SRLI => Itype(i).into(),
            insts::OP_SRAI => Itype(i).into(),
            insts::OP_SLLIW => Itype(i).into(),
            insts::OP_SRLIW => Itype(i).into(),
            insts::OP_SRAIW => Itype(i).into(),
            insts::OP_SB => Stype(i).into(),
            insts::OP_SH => Stype(i).into(),
            insts::OP_SW => Stype(i).into(),
            insts::OP_SD => Stype(i).into(),
            insts::OP_BEQ => Stype(i).into(),
            insts::OP_BNE => Stype(i).into(),
            insts::OP_BLT => Stype(i).into(),
            insts::OP_BGE => Stype(i).into(),
            insts::OP_BLTU => Stype(i).into(),
            insts::OP_BGEU => Stype(i).into(),
            insts::OP_LUI => Utype(i).into(),
            insts::OP_AUIPC => Utype(i).into(),
            insts::OP_JAL => Utype(i).into(),
            insts::OP_MUL => Rtype(i).into(),
            insts::OP_MULW => Rtype(i).into(),
            insts::OP_MULH => Rtype(i).into(),
            insts::OP_MULHSU => Rtype(i).into(),
            insts::OP_MULHU => Rtype(i).into(),
            insts::OP_DIV => Rtype(i).into(),
            insts::OP_DIVW => Rtype(i).into(),
            insts::OP_DIVU => Rtype(i).into(),
            insts::OP_DIVUW => Rtype(i).into(),
            insts::OP_REM => Rtype(i).into(),
            insts::OP_REMW => Rtype(i).into(),
            insts::OP_REMU => Rtype(i).into(),
            insts::OP_REMUW => Rtype(i).into(),
            insts::OP_LR_W => Rtype(i).into(),
            insts::OP_SC_W => Rtype(i).into(),
            insts::OP_AMOSWAP_W => Rtype(i).into(),
            insts::OP_AMOADD_W => Rtype(i).into(),
            insts::OP_AMOXOR_W => Rtype(i).into(),
            insts::OP_AMOAND_W => Rtype(i).into(),
            insts::OP_AMOOR_W => Rtype(i).into(),
            insts::OP_AMOMIN_W => Rtype(i).into(),
            insts::OP_AMOMAX_W => Rtype(i).into(),
            insts::OP_AMOMINU_W => Rtype(i).into(),
            insts::OP_AMOMAXU_W => Rtype(i).into(),
            insts::OP_LR_D => Rtype(i).into(),
            insts::OP_SC_D => Rtype(i).into(),
            insts::OP_AMOSWAP_D => Rtype(i).into(),
            insts::OP_AMOADD_D => Rtype(i).into(),
            insts::OP_AMOXOR_D => Rtype(i).into(),
            insts::OP_AMOAND_D => Rtype(i).into(),
            insts::OP_AMOOR_D => Rtype(i).into(),
            insts::OP_AMOMIN_D => Rtype(i).into(),
            insts::OP_AMOMAX_D => Rtype(i).into(),
            insts::OP_AMOMINU_D => Rtype(i).into(),
            insts::OP_AMOMAXU_D => Rtype(i).into(),
            insts::OP_ADDUW => Rtype(i).into(),
            insts::OP_ANDN => Rtype(i).into(),
            insts::OP_BCLR => Rtype(i).into(),
            insts::OP_BCLRI => Itype(i).into(),
            insts::OP_BEXT => Rtype(i).into(),
            insts::OP_BEXTI => Itype(i).into(),
            insts::OP_BINV => Rtype(i).into(),
            insts::OP_BINVI => Itype(i).into(),
            insts::OP_BSET => Rtype(i).into(),
            insts::OP_BSETI => Itype(i).into(),
            insts::OP_CLMUL => Rtype(i).into(),
            insts::OP_CLMULH => Rtype(i).into(),
            insts::OP_CLMULR => Rtype(i).into(),
            insts::OP_CLZ => Rtype(i).into(),
            insts::OP_CLZW => Rtype(i).into(),
            insts::OP_CPOP => Rtype(i).into(),
            insts::OP_CPOPW => Rtype(i).into(),
            insts::OP_CTZ => Rtype(i).into(),
            insts::OP_CTZW => Rtype(i).into(),
            insts::OP_MAX => Rtype(i).into(),
            insts::OP_MAXU => Rtype(i).into(),
            insts::OP_MIN => Rtype(i).into(),
            insts::OP_MINU => Rtype(i).into(),
            insts::OP_ORCB => Rtype(i).into(),
            insts::OP_ORN => Rtype(i).into(),
            insts::OP_REV8 => Rtype(i).into(),
            insts::OP_ROL => Rtype(i).into(),
            insts::OP_ROLW => Rtype(i).into(),
            insts::OP_ROR => Rtype(i).into(),
            insts::OP_RORI => Itype(i).into(),
            insts::OP_RORIW => Itype(i).into(),
            insts::OP_RORW => Rtype(i).into(),
            insts::OP_SEXTB => Rtype(i).into(),
            insts::OP_SEXTH => Rtype(i).into(),
            insts::OP_SH1ADD => Rtype(i).into(),
            insts::OP_SH1ADDUW => Rtype(i).into(),
            insts::OP_SH2ADD => Rtype(i).into(),
            insts::OP_SH2ADDUW => Rtype(i).into(),
            insts::OP_SH3ADD => Rtype(i).into(),
            insts::OP_SH3ADDUW => Rtype(i).into(),
            insts::OP_SLLIUW => Itype(i).into(),
            insts::OP_XNOR => Rtype(i).into(),
            insts::OP_ZEXTH => Rtype(i).into(),
            insts::OP_WIDE_MUL => R4type(i).into(),
            insts::OP_WIDE_MULU => R4type(i).into(),
            insts::OP_WIDE_MULSU => R4type(i).into(),
            insts::OP_WIDE_DIV => R4type(i).into(),
            insts::OP_WIDE_DIVU => R4type(i).into(),
            insts::OP_FAR_JUMP_REL => Utype(i).into(),
            insts::OP_FAR_JUMP_ABS => Utype(i).into(),
            insts::OP_ADC => Rtype(i).into(),
            insts::OP_SBB => R4type(i).into(),
            insts::OP_ADCS => R4type(i).into(),
            insts::OP_SBBS => R4type(i).into(),
            insts::OP_ADD3A => R5type(i).into(),
            insts::OP_ADD3B => R5type(i).into(),
            insts::OP_ADD3C => R5type(i).into(),
            insts::OP_CUSTOM_LOAD_UIMM => Utype(i).into(),
            insts::OP_CUSTOM_LOAD_IMM => Utype(i).into(),
            _ => return Err(Error::InvalidOp(op)),
        };
        Ok(tagged_inst)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::instructions::{blank_instruction, instruction_opcode_name};

    #[test]
    fn test_all_valid_opcodes_convert_to_tagged_instruction() {
        for i in insts::OP_UNLOADED..=insts::OP_CUSTOM_TRACE_END {
            let inst = blank_instruction(i);
            let result = TaggedInstruction::try_from(inst);
            assert!(
                result.is_ok(),
                "TaggedInstruction does not handle opcode {}({})!",
                i,
                instruction_opcode_name(i)
            );
        }
    }
}


================================================
File: src/instructions/utils.rs
================================================
use super::super::machine::Machine;
use crate::RISCV_GENERAL_REGISTER_NUMBER;
use ckb_vm_definitions::instructions::{self as insts, InstructionOpcode};

// Inspired from https://github.com/riscv/riscv-isa-sim/blob/master/riscv/decode.h#L105-L106
#[inline(always)]
pub fn x(instruction_bits: u32, lower: usize, length: usize, shifts: usize) -> u32 {
    ((instruction_bits >> lower) & ((1 << length) - 1)) << shifts
}

#[inline(always)]
pub fn xs(instruction_bits: u32, lower: usize, length: usize, shifts: usize) -> u32 {
    ((instruction_bits as i32) << (32 - lower - length) >> (32 - length) << shifts) as u32
}

#[inline(always)]
pub fn opcode(instruction_bits: u32) -> u32 {
    x(instruction_bits, 0, 7, 0)
}

#[inline(always)]
pub fn funct3(instruction_bits: u32) -> u32 {
    x(instruction_bits, 12, 3, 0)
}

#[inline(always)]
pub fn funct7(instruction_bits: u32) -> u32 {
    x(instruction_bits, 25, 7, 0)
}

#[inline(always)]
pub fn rd(instruction_bits: u32) -> usize {
    x(instruction_bits, 7, 5, 0) as usize
}

#[inline(always)]
pub fn rs1(instruction_bits: u32) -> usize {
    x(instruction_bits, 15, 5, 0) as usize
}

#[inline(always)]
pub fn rs2(instruction_bits: u32) -> usize {
    x(instruction_bits, 20, 5, 0) as usize
}

#[inline(always)]
pub fn btype_immediate(instruction_bits: u32) -> i32 {
    (x(instruction_bits, 8, 4, 1)
        | x(instruction_bits, 25, 6, 5)
        | x(instruction_bits, 7, 1, 11)
        | xs(instruction_bits, 31, 1, 12)) as i32
}

#[inline(always)]
pub fn jtype_immediate(instruction_bits: u32) -> i32 {
    (x(instruction_bits, 21, 10, 1)
        | x(instruction_bits, 20, 1, 11)
        | x(instruction_bits, 12, 8, 12)
        | xs(instruction_bits, 31, 1, 20)) as i32
}

#[inline(always)]
pub fn itype_immediate(instruction_bits: u32) -> i32 {
    xs(instruction_bits, 20, 12, 0) as i32
}

#[inline(always)]
pub fn stype_immediate(instruction_bits: u32) -> i32 {
    (x(instruction_bits, 7, 5, 0) | xs(instruction_bits, 25, 7, 5)) as i32
}

#[inline(always)]
pub fn utype_immediate(instruction_bits: u32) -> i32 {
    xs(instruction_bits, 12, 20, 12) as i32
}

pub fn update_register<M: Machine>(machine: &mut M, register_index: usize, value: M::REG) {
    let register_index = register_index % RISCV_GENERAL_REGISTER_NUMBER;
    // In RISC-V, x0 is a special zero register with the following properties:
    //
    // * All writes to this register are silently ignored
    // * All reads from this register will respond with 0
    //
    // The goal here is to maintain a place where we can read zeros to allow for
    // compact encoding. Hence we are ignoring all writes to x0 register here.
    if register_index > 0 {
        machine.set_register(register_index, value);
    }
}

#[inline(always)]
pub fn jalr(version: u32) -> InstructionOpcode {
    if version >= 1 {
        insts::OP_JALR_VERSION1
    } else {
        insts::OP_JALR_VERSION0
    }
}

#[inline(always)]
pub fn lb(version: u32) -> InstructionOpcode {
    if version >= 1 {
        insts::OP_LB_VERSION1
    } else {
        insts::OP_LB_VERSION0
    }
}

#[inline(always)]
pub fn lbu(version: u32) -> InstructionOpcode {
    if version >= 1 {
        insts::OP_LBU_VERSION1
    } else {
        insts::OP_LBU_VERSION0
    }
}

#[inline(always)]
pub fn ld(version: u32) -> InstructionOpcode {
    if version >= 1 {
        insts::OP_LD_VERSION1
    } else {
        insts::OP_LD_VERSION0
    }
}

#[inline(always)]
pub fn lh(version: u32) -> InstructionOpcode {
    if version >= 1 {
        insts::OP_LH_VERSION1
    } else {
        insts::OP_LH_VERSION0
    }
}

#[inline(always)]
pub fn lhu(version: u32) -> InstructionOpcode {
    if version >= 1 {
        insts::OP_LHU_VERSION1
    } else {
        insts::OP_LHU_VERSION0
    }
}

#[inline(always)]
pub fn lw(version: u32) -> InstructionOpcode {
    if version >= 1 {
        insts::OP_LW_VERSION1
    } else {
        insts::OP_LW_VERSION0
    }
}

#[inline(always)]
pub fn lwu(version: u32) -> InstructionOpcode {
    if version >= 1 {
        insts::OP_LWU_VERSION1
    } else {
        insts::OP_LWU_VERSION0
    }
}


================================================
File: src/machine/mod.rs
================================================
#[cfg(has_asm)]
pub mod asm;
pub mod trace;

use std::fmt::{self, Display};
use std::sync::atomic::{AtomicU8, Ordering};
use std::sync::Arc;

use bytes::Bytes;

use super::debugger::Debugger;
use super::decoder::{build_decoder, InstDecoder};
use super::elf::{parse_elf, LoadingAction, ProgramMetadata};
use super::instructions::{execute, Instruction, Register};
use super::memory::{load_c_string_byte_by_byte, Memory};
use super::syscalls::Syscalls;
use super::{
    registers::{A0, A7, REGISTER_ABI_NAMES, SP},
    Error, ISA_MOP, RISCV_GENERAL_REGISTER_NUMBER,
};

// Version 0 is the initial launched CKB VM, it is used in CKB Lina mainnet
pub const VERSION0: u32 = 0;
// Version 1 fixes known bugs discovered in version 0:
// * It's not possible to read the last byte in the VM memory;
// * https://github.com/nervosnetwork/ckb-vm/issues/92
// * https://github.com/nervosnetwork/ckb-vm/issues/97
// * https://github.com/nervosnetwork/ckb-vm/issues/98
// * https://github.com/nervosnetwork/ckb-vm/issues/106
pub const VERSION1: u32 = 1;
pub const VERSION2: u32 = 2;

/// This is the core part of RISC-V that only deals with data part, it
/// is extracted from Machine so we can handle lifetime logic in dynamic
/// syscall support.
pub trait CoreMachine {
    type REG: Register;
    type MEM: Memory<REG = Self::REG>;

    fn pc(&self) -> &Self::REG;
    fn update_pc(&mut self, pc: Self::REG);
    fn commit_pc(&mut self);
    fn memory(&self) -> &Self::MEM;
    fn memory_mut(&mut self) -> &mut Self::MEM;
    fn registers(&self) -> &[Self::REG];
    fn set_register(&mut self, idx: usize, value: Self::REG);

    // Current running machine version, used to support compatible behavior
    // in case of bug fixes.
    fn version(&self) -> u32;
    fn isa(&self) -> u8;
}

/// This is the core trait describing a full RISC-V machine. Instruction
/// package only needs to deal with the functions in this trait.
pub trait Machine: CoreMachine {
    fn ecall(&mut self) -> Result<(), Error>;
    fn ebreak(&mut self) -> Result<(), Error>;
}

/// This traits extend on top of CoreMachine by adding additional support
/// such as ELF range, cycles which might be needed on Rust side of the logic,
/// such as runner or syscall implementations.
pub trait SupportMachine: CoreMachine {
    // Current execution cycles, it's up to the actual implementation to
    // call add_cycles for each instruction/operation to provide cycles.
    // The implementation might also choose not to do this to ignore this
    // feature.
    fn cycles(&self) -> u64;
    fn set_cycles(&mut self, cycles: u64);
    fn max_cycles(&self) -> u64;
    fn set_max_cycles(&mut self, cycles: u64);

    fn running(&self) -> bool;
    fn set_running(&mut self, running: bool);

    // Erase all the states of the virtual machine.
    fn reset(&mut self, max_cycles: u64) -> Result<(), Error>;
    fn reset_signal(&mut self) -> bool;

    fn add_cycles(&mut self, cycles: u64) -> Result<(), Error> {
        let new_cycles = self
            .cycles()
            .checked_add(cycles)
            .ok_or(Error::CyclesOverflow)?;
        if new_cycles > self.max_cycles() {
            return Err(Error::CyclesExceeded);
        }
        self.set_cycles(new_cycles);
        Ok(())
    }

    fn add_cycles_no_checking(&mut self, cycles: u64) -> Result<(), Error> {
        let new_cycles = self
            .cycles()
            .checked_add(cycles)
            .ok_or(Error::CyclesOverflow)?;
        self.set_cycles(new_cycles);
        Ok(())
    }

    fn load_elf_inner(&mut self, program: &Bytes, update_pc: bool) -> Result<u64, Error> {
        let version = self.version();
        let metadata = parse_elf::<Self::REG>(program, version)?;
        self.load_binary(program, &metadata, update_pc)
    }

    fn load_elf(&mut self, program: &Bytes, update_pc: bool) -> Result<u64, Error> {
        // Allows to override load_elf by writing the real function body in load_elf_inner.
        //
        // impl SupportMachine for Somebody {
        //     fn load_elf(&mut self, program: &Bytes, update_pc: bool) -> Result<u64, Error> {
        //         // Do something before load_elf
        //         let r = self.load_elf_inner(program, update_pc);
        //         // Do something after
        //         return r;
        //     }
        // }
        self.load_elf_inner(program, update_pc)
    }

    fn load_binary_inner(
        &mut self,
        program: &Bytes,
        metadata: &ProgramMetadata,
        update_pc: bool,
    ) -> Result<u64, Error> {
        let version = self.version();
        let mut bytes: u64 = 0;
        for action in &metadata.actions {
            let LoadingAction {
                addr,
                size,
                flags,
                source,
                offset_from_addr,
            } = action;

            self.memory_mut().init_pages(
                *addr,
                *size,
                *flags,
                Some(program.slice(source.start as usize..source.end as usize)),
                *offset_from_addr,
            )?;
            if version < VERSION1 {
                self.memory_mut().store_byte(*addr, *offset_from_addr, 0)?;
            }
            bytes = bytes
                .checked_add(source.end - source.start)
                .ok_or_else(|| {
                    Error::Unexpected(String::from("The bytes count overflowed on loading elf"))
                })?;
        }
        if update_pc {
            self.update_pc(Self::REG::from_u64(metadata.entry));
            self.commit_pc();
        }
        Ok(bytes)
    }

    fn load_binary(
        &mut self,
        program: &Bytes,
        metadata: &ProgramMetadata,
        update_pc: bool,
    ) -> Result<u64, Error> {
        // Similar to load_elf, this provides a way to adjust the behavior of load_binary_inner
        self.load_binary_inner(program, metadata, update_pc)
    }

    fn initialize_stack(
        &mut self,
        args: impl ExactSizeIterator<Item = Result<Bytes, Error>>,
        stack_start: u64,
        stack_size: u64,
    ) -> Result<u64, Error> {
        // When we re-ordered the sections of a program, writing data in high memory
        // will cause unnecessary changes. At the same time, for ckb, argc is always 0
        // and the memory is initialized to 0, so memory writing can be safely skipped.
        //
        // It should be noted that when "chaos_mode" enabled and "argv" is empty,
        // reading "argc" will return an unexpected data. This situation is not very common.
        //
        // See https://github.com/nervosnetwork/ckb-vm/issues/106 for more details.
        if self.version() >= VERSION1 && args.len() == 0 {
            let argc_size = u64::from(Self::REG::BITS / 8);
            let origin_sp = stack_start + stack_size;
            let unaligned_sp_address = origin_sp - argc_size;
            let aligned_sp_address = unaligned_sp_address & (!15);
            let used_bytes = origin_sp - aligned_sp_address;
            self.set_register(SP, Self::REG::from_u64(aligned_sp_address));
            return Ok(used_bytes);
        }

        // We are enforcing WXorX now, there's no need to call init_pages here
        // since all the required bits are already set.
        self.set_register(SP, Self::REG::from_u64(stack_start + stack_size));
        // First value in this array is argc, then it contains the address(pointer)
        // of each argv object.
        let mut values = vec![Self::REG::from_u64(args.len() as u64)];
        for arg in args {
            let arg = arg?;
            let len = Self::REG::from_u64(arg.len() as u64 + 1);
            let address = self.registers()[SP].overflowing_sub(&len);

            self.memory_mut().store_bytes(address.to_u64(), &arg)?;
            self.memory_mut()
                .store_byte(address.to_u64() + arg.len() as u64, 1, 0)?;

            values.push(address.clone());
            self.set_register(SP, address.clone());

            if self.version() >= VERSION2 && address.to_u64() < stack_start {
                // Provides an early exit to large argv array.
                return Err(Error::MemOutOfStack);
            }
        }
        if self.version() >= VERSION1 {
            // There are 2 standard requirements of the initialized stack:
            // 1. argv[argc] should contain a null pointer here, hence we are
            // pushing another 0 to the values array;
            values.push(Self::REG::zero());
            // 2. SP must be aligned to 16-byte boundary, also considering _start
            // will read argc from SP and argv from SP + 8, we have to factor in
            // alignment here first, then push the values.
            let values_bytes =
                Self::REG::from_u64(Self::REG::BITS as u64 / 8 * values.len() as u64);
            let unaligned_sp_address = self.registers()[SP].overflowing_sub(&values_bytes).to_u64();
            // Perform alignment at 16-byte boundary towards lower address
            let aligned_sp_address = unaligned_sp_address & (!15);
            let aligned_bytes = unaligned_sp_address - aligned_sp_address;
            self.set_register(
                SP,
                self.registers()[SP].overflowing_sub(&Self::REG::from_u64(aligned_bytes)),
            );
        }
        // Since we are dealing with a stack, we need to push items in reversed
        // order
        for value in values.iter().rev() {
            let address =
                self.registers()[SP].overflowing_sub(&Self::REG::from_u8(Self::REG::BITS / 8));
            if self.version() >= VERSION1 {
                if Self::REG::BITS == 64 {
                    self.memory_mut().store64(&address, value)?;
                } else {
                    self.memory_mut().store32(&address, value)?;
                }
            } else {
                self.memory_mut().store32(&address, value)?;
            }
            self.set_register(SP, address);
        }
        if self.registers()[SP].to_u64() < stack_start {
            // Args exceed stack size.
            return Err(Error::MemOutOfStack);
        }
        Ok(stack_start + stack_size - self.registers()[SP].to_u64())
    }

    #[cfg(feature = "pprof")]
    fn code(&self) -> &Bytes;
}

#[derive(Default)]
pub struct DefaultCoreMachine<R, M> {
    registers: [R; RISCV_GENERAL_REGISTER_NUMBER],
    pc: R,
    next_pc: R,
    reset_signal: bool,
    memory: M,
    cycles: u64,
    max_cycles: u64,
    running: bool,
    isa: u8,
    version: u32,
    #[cfg(feature = "pprof")]
    code: Bytes,
}

impl<R: Register, M: Memory<REG = R>> CoreMachine for DefaultCoreMachine<R, M> {
    type REG = R;
    type MEM = M;
    fn pc(&self) -> &Self::REG {
        &self.pc
    }

    fn update_pc(&mut self, pc: Self::REG) {
        self.next_pc = pc;
    }

    fn commit_pc(&mut self) {
        self.pc = self.next_pc.clone();
    }

    fn memory(&self) -> &Self::MEM {
        &self.memory
    }

    fn memory_mut(&mut self) -> &mut Self::MEM {
        &mut self.memory
    }

    fn registers(&self) -> &[Self::REG] {
        &self.registers
    }

    fn set_register(&mut self, idx: usize, value: Self::REG) {
        self.registers[idx] = value;
    }

    fn isa(&self) -> u8 {
        self.isa
    }

    fn version(&self) -> u32 {
        self.version
    }
}

impl<R: Register, M: Memory<REG = R>> SupportMachine for DefaultCoreMachine<R, M> {
    fn cycles(&self) -> u64 {
        self.cycles
    }

    fn set_cycles(&mut self, cycles: u64) {
        self.cycles = cycles;
    }

    fn max_cycles(&self) -> u64 {
        self.max_cycles
    }

    fn set_max_cycles(&mut self, max_cycles: u64) {
        self.max_cycles = max_cycles;
    }

    fn reset(&mut self, max_cycles: u64) -> Result<(), Error> {
        self.registers = Default::default();
        self.pc = Default::default();
        self.memory.reset_memory()?;
        self.cycles = 0;
        self.max_cycles = max_cycles;
        self.reset_signal = true;
        self.memory_mut().set_lr(&R::from_u64(u64::MAX));
        Ok(())
    }

    fn reset_signal(&mut self) -> bool {
        let ret = self.reset_signal;
        self.reset_signal = false;
        ret
    }

    fn running(&self) -> bool {
        self.running
    }

    fn set_running(&mut self, running: bool) {
        self.running = running;
    }

    fn load_binary(
        &mut self,
        program: &Bytes,
        metadata: &ProgramMetadata,
        update_pc: bool,
    ) -> Result<u64, Error> {
        #[cfg(feature = "pprof")]
        {
            self.code = program.clone();
        }
        self.load_binary_inner(program, metadata, update_pc)
    }

    fn load_elf(&mut self, program: &Bytes, update_pc: bool) -> Result<u64, Error> {
        #[cfg(feature = "pprof")]
        {
            self.code = program.clone();
        }
        self.load_elf_inner(program, update_pc)
    }

    #[cfg(feature = "pprof")]
    fn code(&self) -> &Bytes {
        &self.code
    }
}

impl<R: Register, M: Memory + Default> DefaultCoreMachine<R, M> {
    pub fn new(isa: u8, version: u32, max_cycles: u64) -> Self {
        Self::new_with_memory(isa, version, max_cycles, M::default())
    }
}

impl<R: Register, M: Memory> DefaultCoreMachine<R, M> {
    pub fn new_with_memory(isa: u8, version: u32, max_cycles: u64, memory: M) -> Self {
        Self {
            registers: Default::default(),
            pc: Default::default(),
            next_pc: Default::default(),
            reset_signal: Default::default(),
            memory,
            cycles: Default::default(),
            max_cycles,
            running: Default::default(),
            isa,
            version,
            #[cfg(feature = "pprof")]
            code: Default::default(),
        }
    }

    pub fn set_max_cycles(&mut self, cycles: u64) {
        self.max_cycles = cycles;
    }

    pub fn take_memory(self) -> M {
        self.memory
    }
}

pub type InstructionCycleFunc = dyn Fn(Instruction) -> u64 + Send + Sync;

pub struct DefaultMachine<Inner> {
    inner: Inner,
    pause: Pause,

    // We have run benchmarks on secp256k1 verification, the performance
    // cost of the Box wrapper here is neglectable, hence we are sticking
    // with Box solution for simplicity now. Later if this becomes an issue,
    // we can change to static dispatch.
    instruction_cycle_func: Box<InstructionCycleFunc>,
    debugger: Option<Box<dyn Debugger<Inner>>>,
    syscalls: Vec<Box<dyn Syscalls<Inner>>>,
    exit_code: i8,
}

impl<Inner: CoreMachine> CoreMachine for DefaultMachine<Inner> {
    type REG = <Inner as CoreMachine>::REG;
    type MEM = <Inner as CoreMachine>::MEM;

    fn pc(&self) -> &Self::REG {
        self.inner.pc()
    }

    fn update_pc(&mut self, pc: Self::REG) {
        self.inner.update_pc(pc);
    }

    fn commit_pc(&mut self) {
        self.inner.commit_pc();
    }

    fn memory(&self) -> &Self::MEM {
        self.inner.memory()
    }

    fn memory_mut(&mut self) -> &mut Self::MEM {
        self.inner.memory_mut()
    }

    fn registers(&self) -> &[Self::REG] {
        self.inner.registers()
    }

    fn set_register(&mut self, idx: usize, value: Self::REG) {
        self.inner.set_register(idx, value)
    }

    fn isa(&self) -> u8 {
        self.inner.isa()
    }

    fn version(&self) -> u32 {
        self.inner.version()
    }
}

impl<Inner: SupportMachine> SupportMachine for DefaultMachine<Inner> {
    fn cycles(&self) -> u64 {
        self.inner.cycles()
    }

    fn set_cycles(&mut self, cycles: u64) {
        self.inner.set_cycles(cycles)
    }

    fn max_cycles(&self) -> u64 {
        self.inner.max_cycles()
    }

    fn set_max_cycles(&mut self, max_cycles: u64) {
        self.inner.set_max_cycles(max_cycles)
    }

    fn reset(&mut self, max_cycles: u64) -> Result<(), Error> {
        self.inner_mut().reset(max_cycles)
    }

    fn reset_signal(&mut self) -> bool {
        self.inner_mut().reset_signal()
    }

    fn running(&self) -> bool {
        self.inner.running()
    }

    fn set_running(&mut self, running: bool) {
        self.inner.set_running(running);
    }

    fn load_binary(
        &mut self,
        program: &Bytes,
        metadata: &ProgramMetadata,
        update_pc: bool,
    ) -> Result<u64, Error> {
        self.inner.load_binary(program, metadata, update_pc)
    }

    fn load_elf(&mut self, program: &Bytes, update_pc: bool) -> Result<u64, Error> {
        self.inner.load_elf(program, update_pc)
    }

    #[cfg(feature = "pprof")]
    fn code(&self) -> &Bytes {
        self.inner.code()
    }
}

impl<Inner: SupportMachine> Machine for DefaultMachine<Inner> {
    fn ecall(&mut self) -> Result<(), Error> {
        let code = self.registers()[A7].to_u64();
        match code {
            93 => {
                // exit
                self.exit_code = self.registers()[A0].to_i8();
                self.set_running(false);
                Ok(())
            }
            _ => {
                for syscall in &mut self.syscalls {
                    let processed = syscall.ecall(&mut self.inner)?;
                    if processed {
                        if self.cycles() > self.max_cycles() {
                            return Err(Error::CyclesExceeded);
                        }
                        return Ok(());
                    }
                }
                Err(Error::InvalidEcall(code))
            }
        }
    }

    fn ebreak(&mut self) -> Result<(), Error> {
        if let Some(debugger) = &mut self.debugger {
            debugger.ebreak(&mut self.inner)
        } else {
            // Unlike ecall, the default behavior of an EBREAK operation is
            // a dummy one.
            Ok(())
        }
    }
}

impl<Inner: CoreMachine> Display for DefaultMachine<Inner> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        writeln!(f, "pc  : 0x{:16X}", self.pc().to_u64())?;
        for (i, name) in REGISTER_ABI_NAMES.iter().enumerate() {
            write!(f, "{:4}: 0x{:16X}", name, self.registers()[i].to_u64())?;
            if (i + 1) % 4 == 0 {
                writeln!(f)?;
            } else {
                write!(f, " ")?;
            }
        }
        Ok(())
    }
}

impl<Inner: SupportMachine> DefaultMachine<Inner> {
    pub fn load_program(
        &mut self,
        program: &Bytes,
        args: impl ExactSizeIterator<Item = Result<Bytes, Error>>,
    ) -> Result<u64, Error> {
        let elf_bytes = self.load_elf(program, true)?;
        let stack_bytes = self.initialize(args)?;
        let bytes = elf_bytes.checked_add(stack_bytes).ok_or_else(|| {
            Error::Unexpected(String::from(
                "The bytes count overflowed on loading program",
            ))
        })?;
        Ok(bytes)
    }

    pub fn load_program_with_metadata(
        &mut self,
        program: &Bytes,
        metadata: &ProgramMetadata,
        args: impl ExactSizeIterator<Item = Result<Bytes, Error>>,
    ) -> Result<u64, Error> {
        let elf_bytes = self.load_binary(program, metadata, true)?;
        let stack_bytes = self.initialize(args)?;
        let bytes = elf_bytes.checked_add(stack_bytes).ok_or_else(|| {
            Error::Unexpected(String::from(
                "The bytes count overflowed on loading program",
            ))
        })?;
        Ok(bytes)
    }

    fn initialize(
        &mut self,
        args: impl ExactSizeIterator<Item = Result<Bytes, Error>>,
    ) -> Result<u64, Error> {
        for syscall in &mut self.syscalls {
            syscall.initialize(&mut self.inner)?;
        }
        if let Some(debugger) = &mut self.debugger {
            debugger.initialize(&mut self.inner)?;
        }
        let memory_size = self.memory().memory_size();
        let stack_size = memory_size / 4;
        let stack_bytes =
            self.initialize_stack(args, (memory_size - stack_size) as u64, stack_size as u64)?;
        // Make sure SP is 16 byte aligned
        if self.inner.version() >= VERSION1 {
            debug_assert!(self.registers()[SP].to_u64() % 16 == 0);
        }
        Ok(stack_bytes)
    }

    pub fn take_inner(self) -> Inner {
        self.inner
    }

    pub fn pause(&self) -> Pause {
        self.pause.clone()
    }

    pub fn set_pause(&mut self, pause: Pause) {
        self.pause = pause;
    }

    pub fn exit_code(&self) -> i8 {
        self.exit_code
    }

    pub fn instruction_cycle_func(&self) -> &InstructionCycleFunc {
        &self.instruction_cycle_func
    }

    pub fn inner_mut(&mut self) -> &mut Inner {
        &mut self.inner
    }

    // This is the most naive way of running the VM, it only decodes each
    // instruction and run it, no optimization is performed here. It might
    // not be practical in production, but it serves as a baseline and
    // reference implementation
    pub fn run(&mut self) -> Result<i8, Error> {
        let mut decoder = build_decoder::<Inner::REG>(self.isa(), self.version());
        self.run_with_decoder(&mut decoder)
    }

    pub fn run_with_decoder<D: InstDecoder>(&mut self, decoder: &mut D) -> Result<i8, Error> {
        if self.isa() & ISA_MOP != 0 && self.version() == VERSION0 {
            return Err(Error::InvalidVersion);
        }
        self.set_running(true);
        while self.running() {
            if self.pause.has_interrupted() {
                self.pause.free();
                return Err(Error::Pause);
            }
            if self.reset_signal() {
                decoder.reset_instructions_cache()?;
            }
            self.step(decoder)?;
        }
        Ok(self.exit_code())
    }

    pub fn step<D: InstDecoder>(&mut self, decoder: &mut D) -> Result<(), Error> {
        let instruction = {
            let pc = self.pc().to_u64();
            let memory = self.memory_mut();
            decoder.decode(memory, pc)?
        };
        let cycles = self.instruction_cycle_func()(instruction);
        self.add_cycles(cycles)?;
        execute(instruction, self)
    }
}

pub struct DefaultMachineBuilder<Inner> {
    inner: Inner,
    instruction_cycle_func: Box<InstructionCycleFunc>,
    debugger: Option<Box<dyn Debugger<Inner>>>,
    syscalls: Vec<Box<dyn Syscalls<Inner>>>,
    pause: Pause,
}

impl<Inner> DefaultMachineBuilder<Inner> {
    pub fn new(inner: Inner) -> Self {
        Self {
            inner,
            instruction_cycle_func: Box::new(|_| 0),
            debugger: None,
            syscalls: vec![],
            pause: Pause::new(),
        }
    }

    pub fn instruction_cycle_func(
        mut self,
        instruction_cycle_func: Box<InstructionCycleFunc>,
    ) -> Self {
        self.instruction_cycle_func = instruction_cycle_func;
        self
    }

    pub fn syscall(mut self, syscall: Box<dyn Syscalls<Inner>>) -> Self {
        self.syscalls.push(syscall);
        self
    }

    pub fn pause(mut self, pause: Pause) -> Self {
        self.pause = pause;
        self
    }

    pub fn debugger(mut self, debugger: Box<dyn Debugger<Inner>>) -> Self {
        self.debugger = Some(debugger);
        self
    }

    pub fn build(self) -> DefaultMachine<Inner> {
        DefaultMachine {
            inner: self.inner,
            pause: self.pause,
            instruction_cycle_func: self.instruction_cycle_func,
            debugger: self.debugger,
            syscalls: self.syscalls,
            exit_code: 0,
        }
    }
}

#[derive(Clone, Default)]
pub struct Pause {
    s: Arc<AtomicU8>,
}

impl Pause {
    pub fn new() -> Self {
        Self {
            s: Arc::new(AtomicU8::new(0)),
        }
    }

    pub fn interrupt(&self) {
        self.s.store(1, Ordering::SeqCst);
    }

    pub fn has_interrupted(&self) -> bool {
        self.s.load(Ordering::SeqCst) != 0
    }

    pub fn get_raw_ptr(&self) -> *mut u8 {
        &*self.s as *const _ as *mut u8
    }

    pub fn free(&mut self) {
        self.s.store(0, Ordering::SeqCst);
    }
}

pub struct FlattenedArgsReader<'a, M: Memory> {
    memory: &'a mut M,
    argc: M::REG,
    argv: M::REG,
    cidx: M::REG,
}

impl<'a, M: Memory> FlattenedArgsReader<'a, M> {
    pub fn new(memory: &'a mut M, argc: M::REG, argv: M::REG) -> Self {
        Self {
            memory,
            argc,
            argv,
            cidx: M::REG::zero(),
        }
    }
}

impl<'a, M: Memory> Iterator for FlattenedArgsReader<'a, M> {
    type Item = Result<Bytes, Error>;

    fn next(&mut self) -> Option<Self::Item> {
        if self.cidx.ge(&self.argc).to_u8() == 1 {
            return None;
        }
        let addr = match M::REG::BITS {
            32 => self.memory.load32(&self.argv),
            64 => self.memory.load64(&self.argv),
            _ => unreachable!(),
        };
        if let Err(err) = addr {
            return Some(Err(err));
        };
        let addr = addr.unwrap();
        let cstr = load_c_string_byte_by_byte(self.memory, &addr);
        if let Err(err) = cstr {
            return Some(Err(err));
        };
        let cstr = cstr.unwrap();
        self.cidx = self.cidx.overflowing_add(&M::REG::from_u8(1));
        self.argv = self
            .argv
            .overflowing_add(&M::REG::from_u8(M::REG::BITS / 8));
        Some(Ok(cstr))
    }
}

impl<'a, M: Memory> ExactSizeIterator for FlattenedArgsReader<'a, M> {
    fn len(&self) -> usize {
        self.argc.to_u64() as usize
    }
}

#[cfg(test)]
mod tests {
    use std::sync::atomic::AtomicU8;

    #[test]
    fn test_atomicu8() {
        // Assert AtomicU8 type has the same in-memory representation as u8.
        // This ensures that Pause::get_raw_ptr() works properly.
        assert_eq!(std::mem::size_of::<AtomicU8>(), 1);
    }
}


================================================
File: src/machine/trace.rs
================================================
use super::{
    super::{
        decoder::{build_decoder, InstDecoder},
        elf::ProgramMetadata,
        instructions::{
            execute_with_thread, extract_opcode, handle_invalid_op, instruction_length,
            is_basic_block_end_instruction, Instruction, Register, Thread, ThreadFactory,
        },
        Error,
    },
    CoreMachine, DefaultMachine, Machine, SupportMachine, VERSION2,
};
use bytes::Bytes;

// The number of trace items to keep
const TRACE_SIZE: usize = 8192;
// Quick bit-mask to truncate a value in trace size range
const TRACE_MASK: usize = TRACE_SIZE - 1;
// The maximum number of instructions to cache in a trace item
const TRACE_ITEM_LENGTH: usize = 16;
// Shifts to truncate a value so 2 traces has the minimal chance of sharing code.
const TRACE_ADDRESS_SHIFTS: usize = 2;

struct Trace<Inner: Machine> {
    address: u64,
    length: usize,
    instruction_count: u8,
    instructions: [Instruction; TRACE_ITEM_LENGTH],
    threads: [Thread<Inner>; TRACE_ITEM_LENGTH],
}

impl<Inner: Machine> Default for Trace<Inner> {
    fn default() -> Self {
        Trace {
            address: 0,
            length: 0,
            instruction_count: 0,
            instructions: [0; TRACE_ITEM_LENGTH],
            threads: [handle_invalid_op::<Inner>; TRACE_ITEM_LENGTH],
        }
    }
}

#[inline(always)]
fn calculate_slot(addr: u64) -> usize {
    (addr as usize >> TRACE_ADDRESS_SHIFTS) & TRACE_MASK
}

pub struct TraceMachine<Inner: SupportMachine> {
    pub machine: DefaultMachine<Inner>,

    factory: ThreadFactory<DefaultMachine<Inner>>,
    traces: Vec<Trace<DefaultMachine<Inner>>>,
}

impl<Inner: SupportMachine> CoreMachine for TraceMachine<Inner> {
    type REG = <Inner as CoreMachine>::REG;
    type MEM = <Inner as CoreMachine>::MEM;

    fn pc(&self) -> &Self::REG {
        self.machine.pc()
    }

    fn update_pc(&mut self, pc: Self::REG) {
        self.machine.update_pc(pc);
    }

    fn commit_pc(&mut self) {
        self.machine.commit_pc();
    }

    fn memory(&self) -> &Self::MEM {
        self.machine.memory()
    }

    fn memory_mut(&mut self) -> &mut Self::MEM {
        self.machine.memory_mut()
    }

    fn registers(&self) -> &[Self::REG] {
        self.machine.registers()
    }

    fn set_register(&mut self, idx: usize, value: Self::REG) {
        self.machine.set_register(idx, value)
    }

    fn isa(&self) -> u8 {
        self.machine.isa()
    }

    fn version(&self) -> u32 {
        self.machine.version()
    }
}

impl<Inner: SupportMachine> Machine for TraceMachine<Inner> {
    fn ecall(&mut self) -> Result<(), Error> {
        self.machine.ecall()
    }

    fn ebreak(&mut self) -> Result<(), Error> {
        self.machine.ebreak()
    }
}

impl<Inner: SupportMachine> TraceMachine<Inner> {
    pub fn new(machine: DefaultMachine<Inner>) -> Self {
        Self {
            machine,
            factory: ThreadFactory::create(),
            traces: vec![],
        }
    }

    pub fn load_program(
        &mut self,
        program: &Bytes,
        args: impl ExactSizeIterator<Item = Result<Bytes, Error>>,
    ) -> Result<u64, Error> {
        self.machine.load_program(program, args)
    }

    pub fn load_program_with_metadata(
        &mut self,
        program: &Bytes,
        metadata: &ProgramMetadata,
        args: impl ExactSizeIterator<Item = Result<Bytes, Error>>,
    ) -> Result<u64, Error> {
        self.machine
            .load_program_with_metadata(program, metadata, args)
    }

    pub fn set_max_cycles(&mut self, cycles: u64) {
        self.machine.inner_mut().set_max_cycles(cycles)
    }

    pub fn run(&mut self) -> Result<i8, Error> {
        let mut decoder = build_decoder::<Inner::REG>(self.isa(), self.version());
        self.run_with_decoder(&mut decoder)
    }

    pub fn run_with_decoder<D: InstDecoder>(&mut self, decoder: &mut D) -> Result<i8, Error> {
        self.machine.set_running(true);
        // For current trace size this is acceptable, however we might want
        // to tweak the code here if we choose to use a larger trace size or
        // larger trace item length.
        self.traces.resize_with(TRACE_SIZE, Trace::default);
        while self.machine.running() {
            if self.machine.pause.has_interrupted() {
                self.machine.pause.free();
                return Err(Error::Pause);
            }
            if self.machine.reset_signal() {
                decoder.reset_instructions_cache()?;
                for i in self.traces.iter_mut() {
                    *i = Trace::default()
                }
            }
            let pc = self.machine.pc().to_u64();
            let slot = calculate_slot(pc);
            // This is to replicate a bug in x64 VM
            let address_match = if self.machine.version() < VERSION2 {
                (pc as u32 as u64) == self.traces[slot].address
            } else {
                pc == self.traces[slot].address
            };
            if (!address_match) || self.traces[slot].instruction_count == 0 {
                self.traces[slot] = Trace::default();
                let mut current_pc = pc;
                let mut i = 0;
                while i < TRACE_ITEM_LENGTH {
                    let instruction = decoder.decode(self.machine.memory_mut(), current_pc)?;
                    let end_instruction = is_basic_block_end_instruction(instruction);
                    current_pc += u64::from(instruction_length(instruction));
                    self.traces[slot].instructions[i] = instruction;
                    self.traces[slot].threads[i] = self.factory[extract_opcode(instruction)];
                    i += 1;
                    if end_instruction {
                        break;
                    }
                }
                self.traces[slot].address = pc;
                self.traces[slot].length = (current_pc - pc) as usize;
                self.traces[slot].instruction_count = i as u8;
            }
            for i in 0..self.traces[slot].instruction_count {
                let inst = self.traces[slot].instructions[i as usize];
                let cycles = self.machine.instruction_cycle_func()(inst);
                self.machine.add_cycles(cycles)?;
                execute_with_thread(
                    inst,
                    &mut self.machine,
                    &self.traces[slot].threads[i as usize],
                )?;
            }
        }
        Ok(self.machine.exit_code())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_trace_constant_rules() {
        assert!(TRACE_SIZE.is_power_of_two());
        assert_eq!(TRACE_MASK, TRACE_SIZE - 1);
        assert!(TRACE_ITEM_LENGTH.is_power_of_two());
        assert!(TRACE_ITEM_LENGTH <= 255);
    }
}


================================================
File: src/machine/asm/cdefinitions_generated.h
================================================
#define CKB_VM_ASM_RISCV_PAGE_SHIFTS 12
#define CKB_VM_ASM_RISCV_PAGE_SIZE 4096
#define CKB_VM_ASM_RISCV_PAGE_MASK 4095
#define CKB_VM_ASM_MEMORY_FRAME_SHIFTS 18
#define CKB_VM_ASM_MEMORY_FRAMESIZE 262144
#define CKB_VM_ASM_MEMORY_FRAME_PAGE_SHIFTS 6

#define CKB_VM_ASM_MAXIMUM_TRACE_ADDRESS_LENGTH 64

#define CKB_VM_ASM_RET_DECODE_TRACE 1
#define CKB_VM_ASM_RET_ECALL 2
#define CKB_VM_ASM_RET_EBREAK 3
#define CKB_VM_ASM_RET_DYNAMIC_JUMP 4
#define CKB_VM_ASM_RET_MAX_CYCLES_EXCEEDED 5
#define CKB_VM_ASM_RET_CYCLES_OVERFLOW 6
#define CKB_VM_ASM_RET_OUT_OF_BOUND 7
#define CKB_VM_ASM_RET_INVALID_PERMISSION 8
#define CKB_VM_ASM_RET_SLOWPATH 9
#define CKB_VM_ASM_RET_PAUSE 10

#define CKB_VM_ASM_REGISTER_RA 1
#define CKB_VM_ASM_REGISTER_SP 2

#define CKB_VM_ASM_MEMORY_FLAG_FREEZED 1
#define CKB_VM_ASM_MEMORY_FLAG_EXECUTABLE 2
#define CKB_VM_ASM_MEMORY_FLAG_WXORX_BIT 2
#define CKB_VM_ASM_MEMORY_FLAG_WRITABLE 0
#define CKB_VM_ASM_MEMORY_FLAG_DIRTY 4

#define CKB_VM_ASM_FIXED_TRACE_STRUCT_SIZE 296
#define CKB_VM_ASM_TRACE_OFFSET_ADDRESS 0
#define CKB_VM_ASM_TRACE_OFFSET_LENGTH 8
#define CKB_VM_ASM_TRACE_OFFSET_CYCLES 16
#define CKB_VM_ASM_TRACE_OFFSET_THREADS 24

#define CKB_VM_ASM_INVOKE_DATA_OFFSET_PAUSE 0
#define CKB_VM_ASM_INVOKE_DATA_OFFSET_FIXED_TRACES 8
#define CKB_VM_ASM_INVOKE_DATA_OFFSET_FIXED_TRACE_MASK 16

#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_REGISTERS 0
#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_PC 256
#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_CYCLES 280
#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MAX_CYCLES 288
#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_CHAOS_MODE 296
#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_CHAOS_SEED 300
#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_LOAD_RESERVATION_ADDRESS 304
#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_VERSION 316
#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_ERROR_ARG0 320
#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_SIZE 328
#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_FRAMES_SIZE 336
#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_FLAGS_SIZE 344
#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_LAST_READ_FRAME 352
#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_LAST_WRITE_PAGE 360
#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR 368
#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_FLAGS_PTR 376
#define CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_FRAMES_PTR 384

#define CKB_VM_ASM_OP_UNLOADED 16
#define CKB_VM_ASM_OP_ADD 17
#define CKB_VM_ASM_OP_ADDI 18
#define CKB_VM_ASM_OP_ADDIW 19
#define CKB_VM_ASM_OP_ADDW 20
#define CKB_VM_ASM_OP_AND 21
#define CKB_VM_ASM_OP_ANDI 22
#define CKB_VM_ASM_OP_DIV 23
#define CKB_VM_ASM_OP_DIVU 24
#define CKB_VM_ASM_OP_DIVUW 25
#define CKB_VM_ASM_OP_DIVW 26
#define CKB_VM_ASM_OP_LB_VERSION0 27
#define CKB_VM_ASM_OP_LB_VERSION1 28
#define CKB_VM_ASM_OP_LBU_VERSION0 29
#define CKB_VM_ASM_OP_LBU_VERSION1 30
#define CKB_VM_ASM_OP_LD_VERSION0 31
#define CKB_VM_ASM_OP_LD_VERSION1 32
#define CKB_VM_ASM_OP_LH_VERSION0 33
#define CKB_VM_ASM_OP_LH_VERSION1 34
#define CKB_VM_ASM_OP_LHU_VERSION0 35
#define CKB_VM_ASM_OP_LHU_VERSION1 36
#define CKB_VM_ASM_OP_LUI 37
#define CKB_VM_ASM_OP_LW_VERSION0 38
#define CKB_VM_ASM_OP_LW_VERSION1 39
#define CKB_VM_ASM_OP_LWU_VERSION0 40
#define CKB_VM_ASM_OP_LWU_VERSION1 41
#define CKB_VM_ASM_OP_MUL 42
#define CKB_VM_ASM_OP_MULH 43
#define CKB_VM_ASM_OP_MULHSU 44
#define CKB_VM_ASM_OP_MULHU 45
#define CKB_VM_ASM_OP_MULW 46
#define CKB_VM_ASM_OP_OR 47
#define CKB_VM_ASM_OP_ORI 48
#define CKB_VM_ASM_OP_REM 49
#define CKB_VM_ASM_OP_REMU 50
#define CKB_VM_ASM_OP_REMUW 51
#define CKB_VM_ASM_OP_REMW 52
#define CKB_VM_ASM_OP_SB 53
#define CKB_VM_ASM_OP_SD 54
#define CKB_VM_ASM_OP_SH 55
#define CKB_VM_ASM_OP_SLL 56
#define CKB_VM_ASM_OP_SLLI 57
#define CKB_VM_ASM_OP_SLLIW 58
#define CKB_VM_ASM_OP_SLLW 59
#define CKB_VM_ASM_OP_SLT 60
#define CKB_VM_ASM_OP_SLTI 61
#define CKB_VM_ASM_OP_SLTIU 62
#define CKB_VM_ASM_OP_SLTU 63
#define CKB_VM_ASM_OP_SRA 64
#define CKB_VM_ASM_OP_SRAI 65
#define CKB_VM_ASM_OP_SRAIW 66
#define CKB_VM_ASM_OP_SRAW 67
#define CKB_VM_ASM_OP_SRL 68
#define CKB_VM_ASM_OP_SRLI 69
#define CKB_VM_ASM_OP_SRLIW 70
#define CKB_VM_ASM_OP_SRLW 71
#define CKB_VM_ASM_OP_SUB 72
#define CKB_VM_ASM_OP_SUBW 73
#define CKB_VM_ASM_OP_SW 74
#define CKB_VM_ASM_OP_XOR 75
#define CKB_VM_ASM_OP_XORI 76
#define CKB_VM_ASM_OP_LR_W 77
#define CKB_VM_ASM_OP_SC_W 78
#define CKB_VM_ASM_OP_AMOSWAP_W 79
#define CKB_VM_ASM_OP_AMOADD_W 80
#define CKB_VM_ASM_OP_AMOXOR_W 81
#define CKB_VM_ASM_OP_AMOAND_W 82
#define CKB_VM_ASM_OP_AMOOR_W 83
#define CKB_VM_ASM_OP_AMOMIN_W 84
#define CKB_VM_ASM_OP_AMOMAX_W 85
#define CKB_VM_ASM_OP_AMOMINU_W 86
#define CKB_VM_ASM_OP_AMOMAXU_W 87
#define CKB_VM_ASM_OP_LR_D 88
#define CKB_VM_ASM_OP_SC_D 89
#define CKB_VM_ASM_OP_AMOSWAP_D 90
#define CKB_VM_ASM_OP_AMOADD_D 91
#define CKB_VM_ASM_OP_AMOXOR_D 92
#define CKB_VM_ASM_OP_AMOAND_D 93
#define CKB_VM_ASM_OP_AMOOR_D 94
#define CKB_VM_ASM_OP_AMOMIN_D 95
#define CKB_VM_ASM_OP_AMOMAX_D 96
#define CKB_VM_ASM_OP_AMOMINU_D 97
#define CKB_VM_ASM_OP_AMOMAXU_D 98
#define CKB_VM_ASM_OP_ADDUW 99
#define CKB_VM_ASM_OP_ANDN 100
#define CKB_VM_ASM_OP_BCLR 101
#define CKB_VM_ASM_OP_BCLRI 102
#define CKB_VM_ASM_OP_BEXT 103
#define CKB_VM_ASM_OP_BEXTI 104
#define CKB_VM_ASM_OP_BINV 105
#define CKB_VM_ASM_OP_BINVI 106
#define CKB_VM_ASM_OP_BSET 107
#define CKB_VM_ASM_OP_BSETI 108
#define CKB_VM_ASM_OP_CLMUL 109
#define CKB_VM_ASM_OP_CLMULH 110
#define CKB_VM_ASM_OP_CLMULR 111
#define CKB_VM_ASM_OP_CLZ 112
#define CKB_VM_ASM_OP_CLZW 113
#define CKB_VM_ASM_OP_CPOP 114
#define CKB_VM_ASM_OP_CPOPW 115
#define CKB_VM_ASM_OP_CTZ 116
#define CKB_VM_ASM_OP_CTZW 117
#define CKB_VM_ASM_OP_MAX 118
#define CKB_VM_ASM_OP_MAXU 119
#define CKB_VM_ASM_OP_MIN 120
#define CKB_VM_ASM_OP_MINU 121
#define CKB_VM_ASM_OP_ORCB 122
#define CKB_VM_ASM_OP_ORN 123
#define CKB_VM_ASM_OP_REV8 124
#define CKB_VM_ASM_OP_ROL 125
#define CKB_VM_ASM_OP_ROLW 126
#define CKB_VM_ASM_OP_ROR 127
#define CKB_VM_ASM_OP_RORI 128
#define CKB_VM_ASM_OP_RORIW 129
#define CKB_VM_ASM_OP_RORW 130
#define CKB_VM_ASM_OP_SEXTB 131
#define CKB_VM_ASM_OP_SEXTH 132
#define CKB_VM_ASM_OP_SH1ADD 133
#define CKB_VM_ASM_OP_SH1ADDUW 134
#define CKB_VM_ASM_OP_SH2ADD 135
#define CKB_VM_ASM_OP_SH2ADDUW 136
#define CKB_VM_ASM_OP_SH3ADD 137
#define CKB_VM_ASM_OP_SH3ADDUW 138
#define CKB_VM_ASM_OP_SLLIUW 139
#define CKB_VM_ASM_OP_XNOR 140
#define CKB_VM_ASM_OP_ZEXTH 141
#define CKB_VM_ASM_OP_WIDE_MUL 142
#define CKB_VM_ASM_OP_WIDE_MULU 143
#define CKB_VM_ASM_OP_WIDE_MULSU 144
#define CKB_VM_ASM_OP_WIDE_DIV 145
#define CKB_VM_ASM_OP_WIDE_DIVU 146
#define CKB_VM_ASM_OP_ADC 147
#define CKB_VM_ASM_OP_SBB 148
#define CKB_VM_ASM_OP_ADCS 149
#define CKB_VM_ASM_OP_SBBS 150
#define CKB_VM_ASM_OP_ADD3A 151
#define CKB_VM_ASM_OP_ADD3B 152
#define CKB_VM_ASM_OP_ADD3C 153
#define CKB_VM_ASM_OP_CUSTOM_LOAD_UIMM 154
#define CKB_VM_ASM_OP_CUSTOM_LOAD_IMM 155
#define CKB_VM_ASM_OP_AUIPC 156
#define CKB_VM_ASM_OP_BEQ 157
#define CKB_VM_ASM_OP_BGE 158
#define CKB_VM_ASM_OP_BGEU 159
#define CKB_VM_ASM_OP_BLT 160
#define CKB_VM_ASM_OP_BLTU 161
#define CKB_VM_ASM_OP_BNE 162
#define CKB_VM_ASM_OP_EBREAK 163
#define CKB_VM_ASM_OP_ECALL 164
#define CKB_VM_ASM_OP_FENCE 165
#define CKB_VM_ASM_OP_FENCEI 166
#define CKB_VM_ASM_OP_JAL 167
#define CKB_VM_ASM_OP_JALR_VERSION0 168
#define CKB_VM_ASM_OP_JALR_VERSION1 169
#define CKB_VM_ASM_OP_FAR_JUMP_REL 170
#define CKB_VM_ASM_OP_FAR_JUMP_ABS 171
#define CKB_VM_ASM_OP_CUSTOM_ASM_TRACE_JUMP 172

#ifdef CKB_VM_ASM_GENERATE_LABEL_TABLES
#ifdef __APPLE__
.global _ckb_vm_asm_labels
_ckb_vm_asm_labels:
#else
.global ckb_vm_asm_labels
ckb_vm_asm_labels:
#endif
.CKB_VM_ASM_LABEL_TABLE:
	.long	.exit_slowpath - .CKB_VM_ASM_LABEL_TABLE
	.long	.exit_slowpath - .CKB_VM_ASM_LABEL_TABLE
	.long	.exit_slowpath - .CKB_VM_ASM_LABEL_TABLE
	.long	.exit_slowpath - .CKB_VM_ASM_LABEL_TABLE
	.long	.exit_slowpath - .CKB_VM_ASM_LABEL_TABLE
	.long	.exit_slowpath - .CKB_VM_ASM_LABEL_TABLE
	.long	.exit_slowpath - .CKB_VM_ASM_LABEL_TABLE
	.long	.exit_slowpath - .CKB_VM_ASM_LABEL_TABLE
	.long	.exit_slowpath - .CKB_VM_ASM_LABEL_TABLE
	.long	.exit_slowpath - .CKB_VM_ASM_LABEL_TABLE
	.long	.exit_slowpath - .CKB_VM_ASM_LABEL_TABLE
	.long	.exit_slowpath - .CKB_VM_ASM_LABEL_TABLE
	.long	.exit_slowpath - .CKB_VM_ASM_LABEL_TABLE
	.long	.exit_slowpath - .CKB_VM_ASM_LABEL_TABLE
	.long	.exit_slowpath - .CKB_VM_ASM_LABEL_TABLE
	.long	.exit_slowpath - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_UNLOADED - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_ADD - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_ADDI - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_ADDIW - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_ADDW - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_AND - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_ANDI - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_DIV - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_DIVU - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_DIVUW - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_DIVW - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_LB_VERSION0 - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_LB_VERSION1 - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_LBU_VERSION0 - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_LBU_VERSION1 - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_LD_VERSION0 - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_LD_VERSION1 - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_LH_VERSION0 - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_LH_VERSION1 - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_LHU_VERSION0 - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_LHU_VERSION1 - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_LUI - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_LW_VERSION0 - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_LW_VERSION1 - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_LWU_VERSION0 - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_LWU_VERSION1 - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_MUL - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_MULH - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_MULHSU - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_MULHU - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_MULW - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_OR - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_ORI - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_REM - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_REMU - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_REMUW - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_REMW - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SB - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SD - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SH - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SLL - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SLLI - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SLLIW - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SLLW - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SLT - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SLTI - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SLTIU - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SLTU - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SRA - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SRAI - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SRAIW - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SRAW - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SRL - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SRLI - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SRLIW - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SRLW - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SUB - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SUBW - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SW - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_XOR - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_XORI - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_LR_W - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SC_W - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_AMOSWAP_W - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_AMOADD_W - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_AMOXOR_W - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_AMOAND_W - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_AMOOR_W - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_AMOMIN_W - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_AMOMAX_W - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_AMOMINU_W - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_AMOMAXU_W - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_LR_D - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SC_D - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_AMOSWAP_D - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_AMOADD_D - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_AMOXOR_D - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_AMOAND_D - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_AMOOR_D - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_AMOMIN_D - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_AMOMAX_D - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_AMOMINU_D - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_AMOMAXU_D - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_ADDUW - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_ANDN - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_BCLR - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_BCLRI - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_BEXT - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_BEXTI - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_BINV - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_BINVI - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_BSET - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_BSETI - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_CLMUL - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_CLMULH - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_CLMULR - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_CLZ - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_CLZW - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_CPOP - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_CPOPW - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_CTZ - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_CTZW - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_MAX - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_MAXU - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_MIN - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_MINU - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_ORCB - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_ORN - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_REV8 - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_ROL - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_ROLW - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_ROR - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_RORI - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_RORIW - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_RORW - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SEXTB - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SEXTH - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SH1ADD - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SH1ADDUW - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SH2ADD - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SH2ADDUW - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SH3ADD - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SH3ADDUW - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SLLIUW - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_XNOR - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_ZEXTH - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_WIDE_MUL - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_WIDE_MULU - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_WIDE_MULSU - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_WIDE_DIV - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_WIDE_DIVU - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_ADC - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SBB - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_ADCS - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_SBBS - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_ADD3A - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_ADD3B - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_ADD3C - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_CUSTOM_LOAD_UIMM - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_CUSTOM_LOAD_IMM - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_AUIPC - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_BEQ - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_BGE - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_BGEU - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_BLT - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_BLTU - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_BNE - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_EBREAK - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_ECALL - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_FENCE - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_FENCEI - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_JAL - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_JALR_VERSION0 - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_JALR_VERSION1 - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_FAR_JUMP_REL - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_FAR_JUMP_ABS - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_CUSTOM_ASM_TRACE_JUMP - .CKB_VM_ASM_LABEL_TABLE
	.long	.CKB_VM_ASM_LABEL_OP_CUSTOM_TRACE_END - .CKB_VM_ASM_LABEL_TABLE
#endif /* CKB_VM_ASM_GENERATE_LABEL_TABLES */


================================================
File: src/machine/asm/execute_aarch64.S
================================================
#define CKB_VM_ASM_GENERATE_LABEL_TABLES 1
#include "cdefinitions_generated.h"

#define INT64_MIN 0x8000000000000000
#define UINT64_MAX 0xffffffffffffffff

#define MACHINE x0
#define INVOKE_DATA x1

#define TEMP1 x9
#define TEMP1w w9
#define TEMP2 x10
#define TEMP2w w10
#define TEMP3 x11
#define TEMP3w w11
#define TEMP4 x12
#define TEMP4w w12
#define TEMP5 x13
#define TEMP5w w13
#define TRACE x19
#define INST_PC x20
#define INST_ARGS x21

#define RD x22
#define RS1 x23
#define RS1w w23
#define RS2 x24
#define RS2w w24
#define RS3 x25
#define RS3w w25
/*
 * This helps remind us that RS4 and TEMP5 shares the same register.
 * An alternative route is that we can use x14, but that means we will
 * need yet another pair of stp/ldp in PREPCALL/POSTCALL. Since R5 is
 * only used to implement a handful of mop instructions, it might be
 * better start by reusing a temporary register, we can introduce x14
 * later when there is really the need.
 */
#define RS4_TEMP5 x13
#define RS4_TEMP5w w13
#define IMMEDIATE x26
#define IMMEDIATEw w26

#define REGISTER_BASE x28
#define ZERO_VALUE xzr

#define MEMORY_PTR x29

#ifdef __APPLE__
#define SEP %%
#else
#define SEP ;
#endif

#define PREPCALL \
  stp x0, x1, [sp, -64]! SEP \
  stp x9, x10, [sp, 16] SEP \
  stp x11, x12, [sp, 32] SEP \
  stp x13, x14, [sp, 48] SEP \

#define POSTCALL \
  ldp x13, x14, [sp, 48] SEP \
  ldp x11, x12, [sp, 32] SEP \
  ldp x9, x10, [sp, 16] SEP \
  ldp x0, x1, [sp], 64

#define REGISTER_ADDRESS(r) [REGISTER_BASE, r, lsl 3]
#define ZERO_ADDRESS [REGISTER_BASE]
#define RA_ADDRESS [MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_REGISTERS + CKB_VM_ASM_REGISTER_RA * 8]

#define PC_ADDRESS [MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_PC]
#define LOAD_RESERVATION_ADDRESS [MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_LOAD_RESERVATION_ADDRESS]

#define WRITE_RD(v) \
  str v, REGISTER_ADDRESS(RD) SEP \
  str ZERO_VALUE, ZERO_ADDRESS

#define WRITE_RD_V2(v) \
  str v, REGISTER_ADDRESS(RD)

#define WRITE_RS1(v) \
  str v, REGISTER_ADDRESS(RS1)

#define WRITE_RS2(v) \
  str v, REGISTER_ADDRESS(RS2)

#define WRITE_RS3(v) \
  str v, REGISTER_ADDRESS(RS3)

/*
 * This is added to replicate a bug in x64 assembly VM
 */
#define LOAD_PC(reg1, reg1w, reg2, reg2w, temp_regw) \
  ldr reg1, [MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_PC] SEP \
  ubfx reg2, reg1, 0, 32 SEP \
  ldrb temp_regw, [MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_VERSION] SEP \
  cmp temp_regw, 2 SEP \
  csel reg2, reg2, reg1, lo

#define NEXT_INST \
  ldr TEMP1, [INST_ARGS] SEP \
  add INST_ARGS, INST_ARGS, 16 SEP \
  ubfx RD, TEMP1, 8, 8 SEP \
  asr TEMP1, TEMP1, 32 SEP \
  ldr TEMP2, [INST_PC] SEP \
  add INST_PC, INST_PC, 16 SEP \
  br TEMP2

#define NEXT_INST_V2 \
  str ZERO_VALUE, ZERO_ADDRESS SEP \
  NEXT_INST

#define DECODE_R \
  ubfx RS1, TEMP1, 0, 8 SEP \
  ubfx RS2, TEMP1, 8, 8

#define DECODE_I \
  ubfx RS1, TEMP1, 0, 8 SEP \
  asr IMMEDIATE, TEMP1, 8

#define DECODE_S \
  mov RS2, RD SEP \
  ubfx RS1, TEMP1, 0, 8 SEP \
  asr IMMEDIATE, TEMP1, 8

#define DECODE_R4 \
  ubfx RS1, TEMP1, 0, 8 SEP \
  ubfx RS2, TEMP1, 8, 8 SEP \
  asr TEMP1, TEMP1, 16 SEP \
  ubfx RS3, TEMP1, 0, 8

#define DECODE_R5 \
  ubfx RS1, TEMP1, 0, 8 SEP \
  ubfx RS2, TEMP1, 8, 8 SEP \
  asr TEMP1, TEMP1, 16 SEP \
  ubfx RS3, TEMP1, 0, 8 SEP \
  ubfx RS4_TEMP5, TEMP1, 8, 8

#define DECODE_U \
  mov IMMEDIATE, TEMP1

#ifdef __APPLE__
#define CALL_INITED_MEMORY bl _inited_memory
#else
#define CALL_INITED_MEMORY bl inited_memory
#endif

/*
 * This is an internal macro used by other macros, it should not be used
 * in instruction implementation directly.
 */
#define _CHECK_READ_FRAMES(address_reg, length) \
  mov TEMP1, address_reg SEP \
  lsr TEMP1, TEMP1, CKB_VM_ASM_MEMORY_FRAME_SHIFTS SEP \
  str TEMP1, [MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_LAST_READ_FRAME] SEP \
  ldr TEMP4, =CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_FRAMES_PTR SEP \
  ldr TEMP4, [MACHINE, TEMP4] SEP \
  ldrb TEMP2w, [TEMP4, TEMP1] SEP \
  cmp TEMP2, 0 SEP \
  bne 1f SEP \
  mov TEMP3, 1 SEP \
  strb TEMP3w, [TEMP4, TEMP1] SEP \
  PREPCALL SEP \
  mov x1, MACHINE SEP \
  mov x0, TEMP1 SEP \
  CALL_INITED_MEMORY SEP \
  POSTCALL SEP \
1: \
  mov TEMP1, address_reg SEP \
  add TEMP1, TEMP1, length SEP \
  sub TEMP1, TEMP1, 1 SEP \
  lsr TEMP1, TEMP1, CKB_VM_ASM_MEMORY_FRAME_SHIFTS SEP \
  ldrb TEMP2w, [TEMP4, TEMP1] SEP \
  cmp TEMP2, 0 SEP \
  bne 2f SEP \
  strb TEMP3w, [TEMP4, TEMP1] SEP \
  PREPCALL SEP \
  mov x1, MACHINE SEP \
  mov x0, TEMP1 SEP \
  CALL_INITED_MEMORY SEP \
  POSTCALL SEP \
2:

#define CHECK_READ_VERSION0(address_reg, length) \
  mov TEMP1, address_reg SEP \
  lsr TEMP1, TEMP1, CKB_VM_ASM_MEMORY_FRAME_SHIFTS SEP \
  ldr TEMP2, [MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_LAST_READ_FRAME] SEP \
  cmp TEMP1, TEMP2 SEP \
  bne 3f SEP \
  mov TEMP2, address_reg SEP \
  add TEMP2, TEMP2, length SEP \
  lsr TEMP2, TEMP2, CKB_VM_ASM_MEMORY_FRAME_SHIFTS SEP \
  cmp TEMP1, TEMP2 SEP \
  beq 2f SEP \
3: \
  mov TEMP3, address_reg SEP \
  ldr TEMP2, [MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_SIZE] SEP \
  cmp TEMP3, TEMP2 SEP \
  bhs .exit_out_of_bound SEP \
  add TEMP3, TEMP3, length SEP \
  cmp TEMP3, TEMP2 SEP \
  bhs .exit_out_of_bound SEP \
  _CHECK_READ_FRAMES(address_reg, length)

#define CHECK_READ_VERSION1(address_reg, length) \
  mov TEMP1, address_reg SEP \
  lsr TEMP1, TEMP1, CKB_VM_ASM_MEMORY_FRAME_SHIFTS SEP \
  ldr TEMP2, [MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_LAST_READ_FRAME] SEP \
  cmp TEMP1, TEMP2 SEP \
  bne 3f SEP \
  mov TEMP2, address_reg SEP \
  add TEMP2, TEMP2, length SEP \
  lsr TEMP2, TEMP2, CKB_VM_ASM_MEMORY_FRAME_SHIFTS SEP \
  cmp TEMP1, TEMP2 SEP \
  beq 2f SEP \
3: \
  mov TEMP3, address_reg SEP \
  ldr TEMP2, [MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_SIZE] SEP \
  cmp TEMP3, TEMP2 SEP \
  bhs .exit_out_of_bound SEP \
  add TEMP3, TEMP3, length SEP \
  cmp TEMP3, TEMP2 SEP \
  bhi .exit_out_of_bound SEP \
  _CHECK_READ_FRAMES(address_reg, length)

#define CHECK_WRITE(address_reg, length) \
  mov TEMP3, address_reg SEP \
  lsr TEMP1, TEMP3, CKB_VM_ASM_RISCV_PAGE_SHIFTS SEP \
  ldr TEMP2, [MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_LAST_WRITE_PAGE] SEP \
  cmp TEMP1, TEMP2 SEP \
  bne 3f SEP \
  add TEMP2, TEMP3, length SEP \
  lsr TEMP2, TEMP2, CKB_VM_ASM_RISCV_PAGE_SHIFTS SEP \
  cmp TEMP1, TEMP2 SEP \
  beq 2f SEP \
3: \
  str TEMP1, [MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_LAST_WRITE_PAGE] SEP \
  ldr TEMP2, [MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_FLAGS_SIZE] SEP \
  cmp TEMP1, TEMP2 SEP \
  bhs .exit_out_of_bound SEP \
  ldr TEMP5, [MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_FLAGS_PTR] SEP \
  ldrb TEMP3w, [TEMP5, TEMP1] SEP \
  mov TEMP2, TEMP3 SEP \
  and TEMP3, TEMP3, CKB_VM_ASM_MEMORY_FLAG_WXORX_BIT SEP \
  cmp TEMP3, CKB_VM_ASM_MEMORY_FLAG_WRITABLE SEP \
  bne .exit_invalid_permission SEP \
  orr TEMP2, TEMP2, CKB_VM_ASM_MEMORY_FLAG_DIRTY SEP \
  strb TEMP2w, [TEMP5, TEMP1] SEP \
  mov TEMP2, TEMP1 SEP \
  lsr TEMP1, TEMP1, CKB_VM_ASM_MEMORY_FRAME_PAGE_SHIFTS SEP \
  ldr TEMP4, =CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_FRAMES_PTR SEP \
  ldr TEMP5, [MACHINE, TEMP4] SEP \
  ldrb TEMP3w, [TEMP5, TEMP1] SEP \
  cmp TEMP3, 0 SEP \
  bne 1f SEP \
  mov TEMP4, 1 SEP \
  strb TEMP4w, [TEMP5, TEMP1] SEP \
  PREPCALL SEP \
  mov x1, MACHINE SEP \
  mov x0, TEMP1 SEP \
  CALL_INITED_MEMORY SEP \
  POSTCALL SEP \
1: \
  add TEMP1, TEMP2, 1 SEP \
  lsl TEMP1, TEMP1, CKB_VM_ASM_RISCV_PAGE_SHIFTS SEP \
  mov TEMP3, address_reg SEP \
  add TEMP3, TEMP3, length SEP \
  cmp TEMP3, TEMP1 SEP \
  bls 2f SEP \
  lsr TEMP1, TEMP1, CKB_VM_ASM_RISCV_PAGE_SHIFTS SEP \
  ldr TEMP2, [MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_FLAGS_SIZE] SEP \
  cmp TEMP1, TEMP2 SEP \
  bhs .exit_out_of_bound SEP \
  ldr TEMP5, [MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_FLAGS_PTR] SEP \
  ldrb TEMP3w, [TEMP5, TEMP1] SEP \
  mov TEMP2, TEMP3 SEP \
  and TEMP3, TEMP3, CKB_VM_ASM_MEMORY_FLAG_WXORX_BIT SEP \
  cmp TEMP3, CKB_VM_ASM_MEMORY_FLAG_WRITABLE SEP \
  bne .exit_invalid_permission SEP \
  orr TEMP2, TEMP2, CKB_VM_ASM_MEMORY_FLAG_DIRTY SEP \
  strb TEMP2w, [TEMP5, TEMP1] SEP \
  lsr TEMP1, TEMP1, CKB_VM_ASM_MEMORY_FRAME_PAGE_SHIFTS SEP \
  ldr TEMP4, =CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_FRAMES_PTR SEP \
  ldr TEMP5, [MACHINE, TEMP4] SEP \
  ldrb TEMP3w, [TEMP5, TEMP1] SEP \
  cmp TEMP3, 0 SEP \
  bne 2f SEP \
  mov TEMP4, 1 SEP \
  strb TEMP4w, [TEMP5, TEMP1] SEP \
  PREPCALL SEP \
  mov x1, MACHINE SEP \
  mov x0, TEMP1 SEP \
  CALL_INITED_MEMORY SEP \
  POSTCALL SEP \
2:

.p2align 3
#ifdef __APPLE__
.globl _ckb_vm_x64_execute
_ckb_vm_x64_execute:
#else
.globl ckb_vm_x64_execute
ckb_vm_x64_execute:
#endif
  stp x19, x20, [sp, -96]!
  stp x21, x22, [sp, 16]
  stp x23, x24, [sp, 32]
  stp x25, x26, [sp, 48]
  stp x27, x28, [sp, 64]
  stp x29, x30, [sp, 80]
  add REGISTER_BASE, MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_REGISTERS
  ldr MEMORY_PTR, [MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR]

.CKB_VM_ASM_LABEL_OP_CUSTOM_TRACE_END:
  LOAD_PC(TEMP2, TEMP2w, TEMP3, TEMP3w, TEMP4w)
  lsr TEMP2, TEMP2, 2
  ldr TEMP1, [INVOKE_DATA, CKB_VM_ASM_INVOKE_DATA_OFFSET_FIXED_TRACE_MASK]
  and TEMP2, TEMP2, TEMP1
  mov TEMP1, CKB_VM_ASM_FIXED_TRACE_STRUCT_SIZE
  mul TEMP2, TEMP2, TEMP1
  ldr TRACE, [INVOKE_DATA, CKB_VM_ASM_INVOKE_DATA_OFFSET_FIXED_TRACES]
  add TRACE, TRACE, TEMP2
  ldr TEMP4, [TRACE, CKB_VM_ASM_TRACE_OFFSET_ADDRESS]
  cmp TEMP4, TEMP3
  bne .exit_trace
  ldr TEMP3w, [TRACE, CKB_VM_ASM_TRACE_OFFSET_LENGTH]
  cmp TEMP3w, 0
  beq .exit_trace
  ldr TEMP2, [MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_CYCLES]
  ldr TEMP1, [TRACE, CKB_VM_ASM_TRACE_OFFSET_CYCLES]
  add TEMP2, TEMP2, TEMP1
  cmp TEMP2, TEMP1
  bcc .exit_cycles_overflow
  ldr TEMP1, [MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MAX_CYCLES]
  cmp TEMP2, TEMP1
  bhi .exit_max_cycles_exceeded
  str TEMP2, [MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_CYCLES]
  add TEMP3, TEMP3, TEMP4
  str TEMP3, [MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_PC]
  /* Prefetch trace info for the consecutive block, pc is in TEMP3 now */
  lsr TEMP2, TEMP3, 2
  ldr TEMP1, [INVOKE_DATA, CKB_VM_ASM_INVOKE_DATA_OFFSET_FIXED_TRACE_MASK]
  and TEMP2, TEMP2, TEMP1
  mov TEMP1, CKB_VM_ASM_FIXED_TRACE_STRUCT_SIZE
  mul TEMP2, TEMP2, TEMP1
  ldr TEMP1, [INVOKE_DATA, CKB_VM_ASM_INVOKE_DATA_OFFSET_FIXED_TRACES]
  prfm pldl3keep, [TEMP2, TEMP1]
  add INST_PC, TRACE, CKB_VM_ASM_TRACE_OFFSET_THREADS
  add INST_ARGS, INST_PC, 8
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_CUSTOM_ASM_TRACE_JUMP:
  /* Load current instruction as the full trace address */
  ldr TRACE, [INST_ARGS, -16]
  /* Prefetch trace info for the consecutive block, pc is in TEMP3 now */
  prfm pldl3keep, [TRACE, CKB_VM_ASM_TRACE_OFFSET_THREADS]
  ldr TEMP4, [MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_PC]
  ldr TEMP3w, [TRACE, CKB_VM_ASM_TRACE_OFFSET_LENGTH]
  cmp TEMP3w, 0
  beq .exit_trace
  ldr TEMP2, [MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_CYCLES]
  ldr TEMP1, [TRACE, CKB_VM_ASM_TRACE_OFFSET_CYCLES]
  add TEMP2, TEMP2, TEMP1
  cmp TEMP2, TEMP1
  bcc .exit_cycles_overflow
  ldr TEMP1, [MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MAX_CYCLES]
  cmp TEMP2, TEMP1
  bhi .exit_max_cycles_exceeded
  str TEMP2, [MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_CYCLES]
  add TEMP3, TEMP3, TEMP4
  str TEMP3, [MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_PC]
  add INST_PC, TRACE, CKB_VM_ASM_TRACE_OFFSET_THREADS
  add INST_ARGS, INST_PC, 8
  NEXT_INST
.prepare_trace:
  ldr TEMP2, [INVOKE_DATA, CKB_VM_ASM_INVOKE_DATA_OFFSET_PAUSE]
  ldarb TEMP2w, [TEMP2]
  cmp TEMP2, ZERO_VALUE
  bne .exit_pause
  LOAD_PC(TEMP2, TEMP2w, TEMP3, TEMP3w, TEMP4w)
  lsr TEMP2, TEMP2, 2
  ldr TEMP1, [INVOKE_DATA, CKB_VM_ASM_INVOKE_DATA_OFFSET_FIXED_TRACE_MASK]
  and TEMP2, TEMP2, TEMP1
  mov TEMP1, CKB_VM_ASM_FIXED_TRACE_STRUCT_SIZE
  mul TEMP2, TEMP2, TEMP1
  ldr TRACE, [INVOKE_DATA, CKB_VM_ASM_INVOKE_DATA_OFFSET_FIXED_TRACES]
  add TRACE, TRACE, TEMP2
  ldr TEMP4, [TRACE, CKB_VM_ASM_TRACE_OFFSET_ADDRESS]
  cmp TEMP4, TEMP3
  bne .exit_trace
  ldr TEMP3w, [TRACE, CKB_VM_ASM_TRACE_OFFSET_LENGTH]
  cmp TEMP3w, 0
  beq .exit_trace
  ldr TEMP2, [MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_CYCLES]
  ldr TEMP1, [TRACE, CKB_VM_ASM_TRACE_OFFSET_CYCLES]
  add TEMP2, TEMP2, TEMP1
  cmp TEMP2, TEMP1
  bcc .exit_cycles_overflow
  ldr TEMP1, [MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MAX_CYCLES]
  cmp TEMP2, TEMP1
  bhi .exit_max_cycles_exceeded
  str TEMP2, [MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_CYCLES]
  add TEMP3, TEMP3, TEMP4
  str TEMP3, [MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_PC]
  add INST_PC, TRACE, CKB_VM_ASM_TRACE_OFFSET_THREADS
  add INST_ARGS, INST_PC, 8
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_ADDI:
  DECODE_I
  ldr RS1, REGISTER_ADDRESS(RS1)
  add RS1, RS1, IMMEDIATE
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_ADD:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  add RS1, RS1, RS2
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_ADDIW:
  DECODE_I
  ldr RS1, REGISTER_ADDRESS(RS1)
  add RS1, RS1, IMMEDIATE
  sxtw RS1, RS1w
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_ADDW:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  add RS1, RS1, RS2
  sxtw RS1, RS1w
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_AND:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  and RS1, RS1, RS2
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_ANDI:
  DECODE_I
  ldr RS1, REGISTER_ADDRESS(RS1)
  and RS1, RS1, IMMEDIATE
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_AUIPC:
  DECODE_U
  ldr RS1, PC_ADDRESS
  sub RS1, RS1, 4
  add RS1, RS1, IMMEDIATE
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_BEQ:
  DECODE_S
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  cmp RS1, RS2
  beq .i_branch_success
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_BGE:
  DECODE_S
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  cmp RS1, RS2
  bge .i_branch_success
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_BGEU:
  DECODE_S
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  cmp RS1, RS2
  bhs .i_branch_success
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_BLT:
  DECODE_S
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  cmp RS1, RS2
  blt .i_branch_success
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_BLTU:
  DECODE_S
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  cmp RS1, RS2
  blo .i_branch_success
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_BNE:
  DECODE_S
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  cmp RS1, RS2
  bne .i_branch_success
  NEXT_INST
.i_branch_success:
  ldr RS1, PC_ADDRESS
  /* Loading instruction flags */
  ldr TEMP3, [INST_ARGS, -16]
  asr TEMP3, TEMP3, 24
  and TEMP3, TEMP3, 0xF
  lsl TEMP3, TEMP3, 1
  sub RS1, RS1, TEMP3
  add RS1, RS1, IMMEDIATE
  str RS1, PC_ADDRESS
  b .prepare_trace
.CKB_VM_ASM_LABEL_OP_DIV:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  cmp RS2, 0
  bne .div_branch2
  mov RS1, UINT64_MAX
  b .div_branch3
.div_branch2:
  sdiv RS1, RS1, RS2
.div_branch3:
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_DIVU:
  DECODE_R
  ldr RS2, REGISTER_ADDRESS(RS2)
  cmp RS2, 0
  bne .divu_branch1
  mov TEMP1, UINT64_MAX
  WRITE_RD(TEMP1)
  NEXT_INST
.divu_branch1:
  ldr TEMP1, REGISTER_ADDRESS(RS1)
  udiv TEMP1, TEMP1, RS2
  WRITE_RD(TEMP1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_DIVUW:
  DECODE_R
  ldr RS2, REGISTER_ADDRESS(RS2)
  mov RS2w, RS2w
  cmp RS2, 0
  bne .divuw_branch1
  mov TEMP1, UINT64_MAX
  WRITE_RD(TEMP1)
  NEXT_INST
.divuw_branch1:
  ldr TEMP1, REGISTER_ADDRESS(RS1)
  mov TEMP1w, TEMP1w
  udiv TEMP1, TEMP1, RS2
  sxtw TEMP1, TEMP1w
  WRITE_RD(TEMP1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_DIVW:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  sxtw RS1, RS1w
  ldr RS2, REGISTER_ADDRESS(RS2)
  sxtw RS2, RS2w
  cmp RS2, 0
  bne .divw_branch2
  mov RS1, UINT64_MAX
  b .divw_branch3
.divw_branch2:
  sdiv RS1, RS1, RS2
.divw_branch3:
  sxtw RS1, RS1w
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_EBREAK:
  DECODE_U
  mov x0, CKB_VM_ASM_RET_EBREAK
  b .exit
.CKB_VM_ASM_LABEL_OP_ECALL:
  DECODE_U
  mov x0, CKB_VM_ASM_RET_ECALL
  b .exit
.CKB_VM_ASM_LABEL_OP_FENCE:
.CKB_VM_ASM_LABEL_OP_FENCEI:
  DECODE_U
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_JAL:
  DECODE_U
  ldr RS1, PC_ADDRESS
  WRITE_RD(RS1)
  /* Loading instruction flags */
  ldr TEMP3, [INST_ARGS, -16]
  asr TEMP3, TEMP3, 24
  and TEMP3, TEMP3, 0xF
  lsl TEMP3, TEMP3, 1
  sub RS1, RS1, TEMP3
  add RS1, RS1, IMMEDIATE
  str RS1, PC_ADDRESS
  b .prepare_trace
.CKB_VM_ASM_LABEL_OP_JALR_VERSION0:
  DECODE_I
  ldr TEMP1, PC_ADDRESS
  WRITE_RD(TEMP1)
  ldr TEMP1, REGISTER_ADDRESS(RS1)
  add TEMP1, TEMP1, IMMEDIATE
  and TEMP1, TEMP1, -2
  str TEMP1, PC_ADDRESS
  b .prepare_trace
.CKB_VM_ASM_LABEL_OP_JALR_VERSION1:
  DECODE_I
  ldr TEMP2, REGISTER_ADDRESS(RS1)
  ldr TEMP1, PC_ADDRESS
  WRITE_RD(TEMP1)
  add TEMP2, TEMP2, IMMEDIATE
  and TEMP2, TEMP2, -2
  str TEMP2, PC_ADDRESS
  b .prepare_trace
.CKB_VM_ASM_LABEL_OP_LB_VERSION0:
  DECODE_I
  ldr RS1, REGISTER_ADDRESS(RS1)
  add RS1, RS1, IMMEDIATE
  CHECK_READ_VERSION0(RS1, 1)
  ldrsb RS1, [MEMORY_PTR, RS1]
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_LB_VERSION1:
  DECODE_I
  ldr RS1, REGISTER_ADDRESS(RS1)
  add RS1, RS1, IMMEDIATE
  CHECK_READ_VERSION1(RS1, 1)
  ldrsb RS1, [MEMORY_PTR, RS1]
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_LBU_VERSION0:
  DECODE_I
  ldr RS1, REGISTER_ADDRESS(RS1)
  add RS1, RS1, IMMEDIATE
  CHECK_READ_VERSION0(RS1, 1)
  ldrb RS1w, [MEMORY_PTR, RS1]
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_LBU_VERSION1:
  DECODE_I
  ldr RS1, REGISTER_ADDRESS(RS1)
  add RS1, RS1, IMMEDIATE
  CHECK_READ_VERSION1(RS1, 1)
  ldrb RS1w, [MEMORY_PTR, RS1]
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_LD_VERSION0:
  DECODE_I
  ldr RS1, REGISTER_ADDRESS(RS1)
  add RS1, RS1, IMMEDIATE
  CHECK_READ_VERSION0(RS1, 8)
  ldr RS1, [MEMORY_PTR, RS1]
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_LD_VERSION1:
  DECODE_I
  ldr RS1, REGISTER_ADDRESS(RS1)
  add RS1, RS1, IMMEDIATE
  CHECK_READ_VERSION1(RS1, 8)
  ldr RS1, [MEMORY_PTR, RS1]
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_LH_VERSION0:
  DECODE_I
  ldr RS1, REGISTER_ADDRESS(RS1)
  add RS1, RS1, IMMEDIATE
  CHECK_READ_VERSION0(RS1, 2)
  ldrsh RS1, [MEMORY_PTR, RS1]
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_LH_VERSION1:
  DECODE_I
  ldr RS1, REGISTER_ADDRESS(RS1)
  add RS1, RS1, IMMEDIATE
  CHECK_READ_VERSION1(RS1, 2)
  ldrsh RS1, [MEMORY_PTR, RS1]
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_LHU_VERSION0:
  DECODE_I
  ldr RS1, REGISTER_ADDRESS(RS1)
  add RS1, RS1, IMMEDIATE
  CHECK_READ_VERSION0(RS1, 2)
  ldrh RS1w, [MEMORY_PTR, RS1]
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_LHU_VERSION1:
  DECODE_I
  ldr RS1, REGISTER_ADDRESS(RS1)
  add RS1, RS1, IMMEDIATE
  CHECK_READ_VERSION1(RS1, 2)
  ldrh RS1w, [MEMORY_PTR, RS1]
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_LUI:
.CKB_VM_ASM_LABEL_OP_CUSTOM_LOAD_IMM:
  DECODE_U
  WRITE_RD(IMMEDIATE)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_CUSTOM_LOAD_UIMM:
  DECODE_U
  uxtw IMMEDIATE, IMMEDIATEw
  WRITE_RD(IMMEDIATE)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_LW_VERSION0:
  DECODE_I
  ldr RS1, REGISTER_ADDRESS(RS1)
  add RS1, RS1, IMMEDIATE
  CHECK_READ_VERSION0(RS1, 4)
  ldrsw RS1, [MEMORY_PTR, RS1]
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_LW_VERSION1:
  DECODE_I
  ldr RS1, REGISTER_ADDRESS(RS1)
  add RS1, RS1, IMMEDIATE
  CHECK_READ_VERSION1(RS1, 4)
  ldrsw RS1, [MEMORY_PTR, RS1]
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_LWU_VERSION0:
  DECODE_I
  ldr RS1, REGISTER_ADDRESS(RS1)
  add RS1, RS1, IMMEDIATE
  CHECK_READ_VERSION0(RS1, 4)
  ldr RS1w, [MEMORY_PTR, RS1]
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_LWU_VERSION1:
  DECODE_I
  ldr RS1, REGISTER_ADDRESS(RS1)
  add RS1, RS1, IMMEDIATE
  CHECK_READ_VERSION1(RS1, 4)
  ldr RS1w, [MEMORY_PTR, RS1]
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_MUL:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  mul RS1, RS1, RS2
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_MULH:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  smulh RS1, RS1, RS2
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_MULHSU:
  DECODE_R
  ldr TEMP2, REGISTER_ADDRESS(RS1)
  tst TEMP2, TEMP2
  bpl .mulhsu_branch1
  neg TEMP2, TEMP2
  ldr TEMP3, REGISTER_ADDRESS(RS2)
  umulh TEMP1, TEMP2, TEMP3
  mov TEMP4, -1
  eor TEMP1, TEMP1, TEMP4
  ldr TEMP2, REGISTER_ADDRESS(RS1)
  mul TEMP2, TEMP2, TEMP3
  tst TEMP2, TEMP2
  cset TEMP2, eq
  add TEMP1, TEMP1, TEMP2
  WRITE_RD(TEMP1)
  NEXT_INST
.mulhsu_branch1:
  ldr TEMP3, REGISTER_ADDRESS(RS2)
  umulh TEMP2, TEMP2, TEMP3
  WRITE_RD(TEMP2)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_MULHU:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  umulh RS1, RS1, RS2
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_MULW:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  mul RS1, RS1, RS2
  sxtw RS1, RS1w
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_OR:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  orr RS1, RS1, RS2
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_ORI:
  DECODE_I
  ldr RS1, REGISTER_ADDRESS(RS1)
  orr RS1, RS1, IMMEDIATE
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_REM:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  cmp RS2, 0
  bne .rem_branch2
  b .rem_branch3
.rem_branch2:
  sdiv TEMP1, RS1, RS2
  msub RS1, TEMP1, RS2, RS1
.rem_branch3:
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_REMU:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  cmp RS2, 0
  bne .remu_branch2
  WRITE_RD(RS1)
  NEXT_INST
.remu_branch2:
  udiv TEMP1, RS1, RS2
  msub TEMP2, TEMP1, RS2, RS1
  WRITE_RD(TEMP2)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_REMUW:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  mov RS2w, RS2w
  cmp RS2, 0
  bne .remuw_branch2
  sxtw RS1, RS1w
  WRITE_RD(RS1)
  NEXT_INST
.remuw_branch2:
  mov RS1w, RS1w
  udiv TEMP1, RS1, RS2
  msub TEMP2, TEMP1, RS2, RS1
  sxtw TEMP2, TEMP2w
  WRITE_RD(TEMP2)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_REMW:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  sxtw RS1, RS1w
  ldr RS2, REGISTER_ADDRESS(RS2)
  sxtw RS2, RS2w
  cmp RS2, 0
  bne .remw_branch2
  b .remw_branch3
.remw_branch2:
  sdiv TEMP1, RS1, RS2
  msub RS1, TEMP1, RS2, RS1
.remw_branch3:
  sxtw RS1, RS1w
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SB:
  DECODE_S
  ldr RS1, REGISTER_ADDRESS(RS1)
  add RS1, RS1, IMMEDIATE
  CHECK_WRITE(RS1, 1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  strb RS2w, [MEMORY_PTR, RS1]
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SD:
  DECODE_S
  ldr RS1, REGISTER_ADDRESS(RS1)
  add RS1, RS1, IMMEDIATE
  CHECK_WRITE(RS1, 8)
  ldr RS2, REGISTER_ADDRESS(RS2)
  str RS2, [MEMORY_PTR, RS1]
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SH:
  DECODE_S
  ldr RS1, REGISTER_ADDRESS(RS1)
  add RS1, RS1, IMMEDIATE
  CHECK_WRITE(RS1, 2)
  ldr RS2, REGISTER_ADDRESS(RS2)
  strh RS2w, [MEMORY_PTR, RS1]
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SLL:
  DECODE_R
  ldr TEMP1, REGISTER_ADDRESS(RS1)
  ldr TEMP2, REGISTER_ADDRESS(RS2)
  lsl TEMP1, TEMP1, TEMP2
  WRITE_RD(TEMP1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SLLI:
  DECODE_I
  ldr TEMP1, REGISTER_ADDRESS(RS1)
  lsl TEMP1, TEMP1, IMMEDIATE
  WRITE_RD(TEMP1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SLLIW:
  DECODE_I
  ldr TEMP1, REGISTER_ADDRESS(RS1)
  lsl TEMP1, TEMP1, IMMEDIATE
  sxtw TEMP1, TEMP1w
  WRITE_RD(TEMP1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SLLW:
  DECODE_R
  ldr TEMP1, REGISTER_ADDRESS(RS1)
  ldr TEMP2, REGISTER_ADDRESS(RS2)
  and TEMP2, TEMP2, 0x1F
  lsl TEMP1, TEMP1, TEMP2
  sxtw TEMP1, TEMP1w
  WRITE_RD(TEMP1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SLT:
  DECODE_R
  ldr TEMP1, REGISTER_ADDRESS(RS1)
  ldr TEMP2, REGISTER_ADDRESS(RS2)
  cmp TEMP1, TEMP2
  cset TEMP1, lt
  WRITE_RD(TEMP1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SLTI:
  DECODE_I
  ldr TEMP1, REGISTER_ADDRESS(RS1)
  cmp TEMP1, IMMEDIATE
  cset TEMP1, lt
  WRITE_RD(TEMP1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SLTIU:
  DECODE_I
  ldr TEMP1, REGISTER_ADDRESS(RS1)
  cmp TEMP1, IMMEDIATE
  cset TEMP1, lo
  WRITE_RD(TEMP1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SLTU:
  DECODE_R
  ldr TEMP1, REGISTER_ADDRESS(RS1)
  ldr TEMP2, REGISTER_ADDRESS(RS2)
  cmp TEMP1, TEMP2
  cset TEMP1, lo
  WRITE_RD(TEMP1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SRA:
  DECODE_R
  ldr TEMP1, REGISTER_ADDRESS(RS1)
  ldr TEMP2, REGISTER_ADDRESS(RS2)
  asr TEMP1, TEMP1, TEMP2
  WRITE_RD(TEMP1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SRAI:
  DECODE_I
  ldr TEMP1, REGISTER_ADDRESS(RS1)
  asr TEMP1, TEMP1, IMMEDIATE
  WRITE_RD(TEMP1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SRAIW:
  DECODE_I
  ldr TEMP1, REGISTER_ADDRESS(RS1)
  asr TEMP1w, TEMP1w, IMMEDIATEw
  sxtw TEMP1, TEMP1w
  WRITE_RD(TEMP1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SRAW:
  DECODE_R
  ldr TEMP1, REGISTER_ADDRESS(RS1)
  ldr TEMP2, REGISTER_ADDRESS(RS2)
  and TEMP2, TEMP2, 0x1F
  asr TEMP1w, TEMP1w, TEMP2w
  sxtw TEMP1, TEMP1w
  WRITE_RD(TEMP1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SRL:
  DECODE_R
  ldr TEMP1, REGISTER_ADDRESS(RS1)
  ldr TEMP2, REGISTER_ADDRESS(RS2)
  lsr TEMP1, TEMP1, TEMP2
  WRITE_RD(TEMP1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SRLI:
  DECODE_I
  ldr TEMP1, REGISTER_ADDRESS(RS1)
  lsr TEMP1, TEMP1, IMMEDIATE
  WRITE_RD(TEMP1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SRLIW:
  DECODE_I
  ldr TEMP1, REGISTER_ADDRESS(RS1)
  lsr TEMP1w, TEMP1w, IMMEDIATEw
  sxtw TEMP1, TEMP1w
  WRITE_RD(TEMP1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SRLW:
  DECODE_R
  ldr TEMP1, REGISTER_ADDRESS(RS1)
  ldr TEMP2, REGISTER_ADDRESS(RS2)
  and TEMP2, TEMP2, 0x1F
  lsr TEMP1w, TEMP1w, TEMP2w
  sxtw TEMP1, TEMP1w
  WRITE_RD(TEMP1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SUB:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  sub RS1, RS1, RS2
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SUBW:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  sub RS1, RS1, RS2
  sxtw RS1, RS1w
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SW:
  DECODE_S
  ldr RS1, REGISTER_ADDRESS(RS1)
  add RS1, RS1, IMMEDIATE
  CHECK_WRITE(RS1, 4)
  ldr RS2, REGISTER_ADDRESS(RS2)
  str RS2w, [MEMORY_PTR, RS1]
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_XOR:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  eor RS1, RS1, RS2
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_XORI:
  DECODE_I
  ldr RS1, REGISTER_ADDRESS(RS1)
  eor RS1, RS1, IMMEDIATE
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_LR_W:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  CHECK_READ_VERSION1(RS1, 4)
  str RS1, LOAD_RESERVATION_ADDRESS
  ldrsw RS1, [MEMORY_PTR, RS1]
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SC_W:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  CHECK_WRITE(RS1, 4)
  ldr TEMP1, LOAD_RESERVATION_ADDRESS
  mov TEMP2, UINT64_MAX
  str TEMP2, LOAD_RESERVATION_ADDRESS
  ldr TEMP2w, [MEMORY_PTR, RS1]
  cmp RS1, TEMP1
  csel RS2w, RS2w, TEMP2w, eq
  str RS2w, [MEMORY_PTR, RS1]
  mov TEMP2, #1
  csel TEMP1, XZR, TEMP2, eq
  WRITE_RD(TEMP1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_AMOSWAP_W:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  CHECK_WRITE(RS1, 4)
  ldrsw TEMP1, [MEMORY_PTR, RS1]
  WRITE_RD(TEMP1)
  str RS2w, [MEMORY_PTR, RS1]
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_AMOADD_W:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  CHECK_WRITE(RS1, 4)
  ldrsw TEMP1, [MEMORY_PTR, RS1]
  WRITE_RD(TEMP1)
  add RS2, RS2, TEMP1
  str RS2w, [MEMORY_PTR, RS1]
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_AMOXOR_W:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  CHECK_WRITE(RS1, 4)
  ldrsw TEMP1, [MEMORY_PTR, RS1]
  WRITE_RD(TEMP1)
  eor RS2, RS2, TEMP1
  str RS2w, [MEMORY_PTR, RS1]
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_AMOAND_W:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  CHECK_WRITE(RS1, 4)
  ldrsw TEMP1, [MEMORY_PTR, RS1]
  WRITE_RD(TEMP1)
  and RS2, RS2, TEMP1
  str RS2w, [MEMORY_PTR, RS1]
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_AMOOR_W:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  CHECK_WRITE(RS1, 4)
  ldrsw TEMP1, [MEMORY_PTR, RS1]
  WRITE_RD(TEMP1)
  orr RS2, RS2, TEMP1
  str RS2w, [MEMORY_PTR, RS1]
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_AMOMIN_W:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  CHECK_WRITE(RS1, 4)
  ldrsw TEMP1, [MEMORY_PTR, RS1]
  WRITE_RD(TEMP1)
  cmp RS2w, TEMP1w
  csel RS2w, RS2w, TEMP1w, le
  str RS2w, [MEMORY_PTR, RS1]
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_AMOMAX_W:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  CHECK_WRITE(RS1, 4)
  ldrsw TEMP1, [MEMORY_PTR, RS1]
  WRITE_RD(TEMP1)
  cmp RS2w, TEMP1w
  csel RS2w, RS2w, TEMP1w, ge
  str RS2w, [MEMORY_PTR, RS1]
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_AMOMINU_W:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  CHECK_WRITE(RS1, 4)
  ldrsw TEMP1, [MEMORY_PTR, RS1]
  WRITE_RD(TEMP1)
  cmp RS2w, TEMP1w
  csel RS2w, RS2w, TEMP1w, ls
  str RS2w, [MEMORY_PTR, RS1]
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_AMOMAXU_W:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  CHECK_WRITE(RS1, 4)
  ldrsw TEMP1, [MEMORY_PTR, RS1]
  WRITE_RD(TEMP1)
  cmp RS2w, TEMP1w
  csel RS2w, RS2w, TEMP1w, hs
  str RS2w, [MEMORY_PTR, RS1]
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_LR_D:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  CHECK_READ_VERSION1(RS1, 8)
  str RS1, LOAD_RESERVATION_ADDRESS
  ldr RS1, [MEMORY_PTR, RS1]
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SC_D:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  CHECK_WRITE(RS1, 8)
  ldr TEMP1, LOAD_RESERVATION_ADDRESS
  mov TEMP2, UINT64_MAX
  str TEMP2, LOAD_RESERVATION_ADDRESS
  ldr TEMP2, [MEMORY_PTR, RS1]
  cmp RS1, TEMP1
  csel RS2, RS2, TEMP2, eq
  str RS2, [MEMORY_PTR, RS1]
  mov TEMP2, #1
  csel TEMP1, XZR, TEMP2, eq
  WRITE_RD(TEMP1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_AMOSWAP_D:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  CHECK_WRITE(RS1, 8)
  ldr TEMP1, [MEMORY_PTR, RS1]
  WRITE_RD(TEMP1)
  str RS2, [MEMORY_PTR, RS1]
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_AMOADD_D:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  CHECK_WRITE(RS1, 8)
  ldr TEMP1, [MEMORY_PTR, RS1]
  WRITE_RD(TEMP1)
  add RS2, RS2, TEMP1
  str RS2, [MEMORY_PTR, RS1]
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_AMOXOR_D:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  CHECK_WRITE(RS1, 8)
  ldr TEMP1, [MEMORY_PTR, RS1]
  WRITE_RD(TEMP1)
  eor RS2, RS2, TEMP1
  str RS2, [MEMORY_PTR, RS1]
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_AMOAND_D:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  CHECK_WRITE(RS1, 8)
  ldr TEMP1, [MEMORY_PTR, RS1]
  WRITE_RD(TEMP1)
  and RS2, RS2, TEMP1
  str RS2, [MEMORY_PTR, RS1]
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_AMOOR_D:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  CHECK_WRITE(RS1, 8)
  ldr TEMP1, [MEMORY_PTR, RS1]
  WRITE_RD(TEMP1)
  orr RS2, RS2, TEMP1
  str RS2, [MEMORY_PTR, RS1]
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_AMOMIN_D:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  CHECK_WRITE(RS1, 8)
  ldr TEMP1, [MEMORY_PTR, RS1]
  WRITE_RD(TEMP1)
  cmp RS2, TEMP1
  csel RS2, RS2, TEMP1, le
  str RS2, [MEMORY_PTR, RS1]
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_AMOMAX_D:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  CHECK_WRITE(RS1, 8)
  ldr TEMP1, [MEMORY_PTR, RS1]
  WRITE_RD(TEMP1)
  cmp RS2, TEMP1
  csel RS2, RS2, TEMP1, ge
  str RS2, [MEMORY_PTR, RS1]
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_AMOMINU_D:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  CHECK_WRITE(RS1, 8)
  ldr TEMP1, [MEMORY_PTR, RS1]
  WRITE_RD(TEMP1)
  cmp RS2, TEMP1
  csel RS2, RS2, TEMP1, ls
  str RS2, [MEMORY_PTR, RS1]
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_AMOMAXU_D:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  CHECK_WRITE(RS1, 8)
  ldr TEMP1, [MEMORY_PTR, RS1]
  WRITE_RD(TEMP1)
  cmp RS2, TEMP1
  csel RS2, RS2, TEMP1, hs
  str RS2, [MEMORY_PTR, RS1]
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_ADDUW:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  mov RS1w, RS1w
  add RS1, RS1, RS2
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_ANDN:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  mvn RS2, RS2
  and RS1, RS1, RS2
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_BCLR:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  mov TEMP1, 1
  lsl TEMP1, TEMP1, RS2
  mvn TEMP1, TEMP1
  and RS1, RS1, TEMP1
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_BCLRI:
  DECODE_I
  ldr RS1, REGISTER_ADDRESS(RS1)
  mov TEMP1, 1
  lsl TEMP1, TEMP1, IMMEDIATE
  mvn TEMP1, TEMP1
  and RS1, RS1, TEMP1
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_BEXT:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  lsr RS1, RS1, RS2
  and RS1, RS1, 1
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_BEXTI:
  DECODE_I
  ldr RS1, REGISTER_ADDRESS(RS1)
  lsr RS1, RS1, IMMEDIATE
  and RS1, RS1, 1
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_BINV:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  mov TEMP1, 1
  lsl TEMP1, TEMP1, RS2
  eor RS1, RS1, TEMP1
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_BINVI:
  DECODE_I
  ldr RS1, REGISTER_ADDRESS(RS1)
  mov TEMP1, 1
  lsl TEMP1, TEMP1, IMMEDIATE
  eor RS1, RS1, TEMP1
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_BSET:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  mov TEMP1, 1
  lsl TEMP1, TEMP1, RS2
  orr RS1, RS1, TEMP1
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_BSETI:
  DECODE_I
  ldr RS1, REGISTER_ADDRESS(RS1)
  mov TEMP1, 1
  lsl TEMP1, TEMP1, IMMEDIATE
  orr RS1, RS1, TEMP1
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_CLMUL:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  mov TEMP4, 0
  mov TEMP3, 0
.clmul_branch:
  mov TEMP1, RS1
  mov TEMP2, RS2
  lsl TEMP1, TEMP1, TEMP4
  lsr TEMP2, TEMP2, TEMP4
  eor TEMP1, TEMP1, TEMP3
  and TEMP2, TEMP2, 1
  cmp TEMP2, 0
  csel TEMP3, TEMP1, TEMP3, ne
  add TEMP4, TEMP4, 1
  cmp TEMP4, 64
  bne .clmul_branch
  WRITE_RD(TEMP3)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_CLMULH:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  mov RS3, 1
  mov TEMP3, 0
.clmulh_branch:
  mov TEMP1, RS1
  mov TEMP2, RS2
  mov TEMP4, 64
  sub TEMP4, TEMP4, RS3
  lsr TEMP1, TEMP1, TEMP4
  mov TEMP4, RS3
  lsr TEMP2, TEMP2, TEMP4
  eor TEMP1, TEMP1, TEMP3
  and TEMP2, TEMP2, 1
  cmp TEMP2, 0
  csel TEMP3, TEMP1, TEMP3, ne
  add RS3, RS3, 1
  cmp RS3, 64
  bne .clmulh_branch
  WRITE_RD(TEMP3)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_CLMULR:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  mov RS3, 0
  mov TEMP3, 0
.clmulr_branch:
  mov TEMP1, RS1
  mov TEMP2, RS2
  mov TEMP4, 63
  sub TEMP4, TEMP4, RS3
  lsr TEMP1, TEMP1, TEMP4
  mov TEMP4, RS3
  lsr TEMP2, TEMP2, TEMP4
  eor TEMP1, TEMP1, TEMP3
  and TEMP2, TEMP2, 1
  cmp TEMP2, 0
  csel TEMP3, TEMP1, TEMP3, ne
  add RS3, RS3, 1
  cmp RS3, 64
  bne .clmulr_branch
  WRITE_RD(TEMP3)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_CLZ:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  clz RS1, RS1
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_CLZW:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  clz RS1w, RS1w
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_CPOP:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  mov RS2, RS1
  lsr RS2, RS2, 1
  ldr TEMP1, =0x5555555555555555
  and RS2, RS2, TEMP1
  sub RS1, RS1, RS2
  mov RS2, RS1
  ldr TEMP1, =0x3333333333333333
  and RS2, RS2, TEMP1
  lsr RS1, RS1, 2
  and RS1, RS1, TEMP1
  add RS1, RS1, RS2
  mov RS2, RS1
  lsr RS2, RS2, 4
  add RS1, RS1, RS2
  ldr TEMP1, =0x0f0f0f0f0f0f0f0f
  and RS1, RS1, TEMP1
  mov RS2, RS1
  lsr RS2, RS2, 8
  add RS1, RS1, RS2
  mov RS2, RS1
  lsr RS2, RS2, 16
  add RS1, RS1, RS2
  mov RS2, RS1
  lsr RS2, RS2, 32
  add RS1, RS1, RS2
  and RS1, RS1, 0x7f
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_CPOPW:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  mov RS2w, RS1w
  lsr RS2w, RS2w, 1
  and RS2w, RS2w, 0x55555555
  sub RS1w, RS1w, RS2w
  mov RS2w, RS1w
  and RS2w, RS2w, 0x33333333
  lsr RS1w, RS1w, 2
  and RS1w, RS1w, 0x33333333
  add RS1w, RS1w, RS2w
  mov RS2w, RS1w
  lsr RS2w, RS2w, 4
  add RS1w, RS1w, RS2w
  and RS1w, RS1w, 0x0f0f0f0f
  mov RS2w, RS1w
  lsr RS2w, RS2w, 8
  add RS1w, RS1w, RS2w
  mov RS2w, RS1w
  lsr RS2w, RS2w, 16
  add RS1w, RS1w, RS2w
  and RS1w, RS1w, 0x3f
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_CTZ:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  rbit RS1, RS1
  clz RS1, RS1
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_CTZW:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  rbit RS1w, RS1w
  clz RS1w, RS1w
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_MAX:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  cmp RS1, RS2
  csel RS1, RS1, RS2, ge
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_MAXU:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  cmp RS1, RS2
  csel RS1, RS1, RS2, hs
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_MIN:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  cmp RS1, RS2
  csel RS1, RS1, RS2, le
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_MINU:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  cmp RS1, RS2
  csel RS1, RS1, RS2, ls
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_ORCB:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  mov RS2, 0
  ldr TEMP1, =0x00000000000000ff
  mov TEMP2, TEMP1
  and TEMP1, TEMP1, RS1
  cmp TEMP1, 0
  beq .orcb_branch1
  orr RS2, RS2, TEMP2
.orcb_branch1:
  ldr TEMP1, =0x000000000000ff00
  mov TEMP2, TEMP1
  and TEMP1, TEMP1, RS1
  cmp TEMP1, 0
  beq .orcb_branch2
  orr RS2, RS2, TEMP2
.orcb_branch2:
  ldr TEMP1, =0x0000000000ff0000
  mov TEMP2, TEMP1
  and TEMP1, TEMP1, RS1
  cmp TEMP1, 0
  beq .orcb_branch3
  orr RS2, RS2, TEMP2
.orcb_branch3:
  ldr TEMP1, =0x00000000ff000000
  mov TEMP2, TEMP1
  and TEMP1, TEMP1, RS1
  cmp TEMP1, 0
  beq .orcb_branch4
  orr RS2, RS2, TEMP2
.orcb_branch4:
  ldr TEMP1, =0x000000ff00000000
  mov TEMP2, TEMP1
  and TEMP1, TEMP1, RS1
  cmp TEMP1, 0
  beq .orcb_branch5
  orr RS2, RS2, TEMP2
.orcb_branch5:
  ldr TEMP1, =0x0000ff0000000000
  mov TEMP2, TEMP1
  and TEMP1, TEMP1, RS1
  cmp TEMP1, 0
  beq .orcb_branch6
  orr RS2, RS2, TEMP2
.orcb_branch6:
  ldr TEMP1, =0x00ff000000000000
  mov TEMP2, TEMP1
  and TEMP1, TEMP1, RS1
  cmp TEMP1, 0
  beq .orcb_branch7
  orr RS2, RS2, TEMP2
.orcb_branch7:
  ldr TEMP1, =0xff00000000000000
  mov TEMP2, TEMP1
  and TEMP1, TEMP1, RS1
  cmp TEMP1, 0
  beq .orcb_branch8
  orr RS2, RS2, TEMP2
.orcb_branch8:
  WRITE_RD(RS2)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_ORN:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  mvn RS2, RS2
  orr RS1, RS1, RS2
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_REV8:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  rev RS1, RS1
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_ROL:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  mov TEMP1, 64
  sub TEMP1, TEMP1, RS2
  ror RS1, RS1, TEMP1
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_ROLW:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  mov TEMP1, 32
  sub TEMP1, TEMP1, RS2
  ror RS1w, RS1w, TEMP1w
  sxtw RS1, RS1w
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_ROR:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  ror RS1, RS1, RS2
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_RORI:
  DECODE_I
  ldr RS1, REGISTER_ADDRESS(RS1)
  ror RS1, RS1, IMMEDIATE
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_RORIW:
  DECODE_I
  ldr RS1, REGISTER_ADDRESS(RS1)
  ror RS1w, RS1w, IMMEDIATEw
  sxtw RS1, RS1w
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_RORW:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  ror RS1w, RS1w, RS2w
  sxtw RS1, RS1w
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SEXTB:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  sxtb RS1, RS1w
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SEXTH:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  sxth RS1, RS1w
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SH1ADD:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  lsl RS1, RS1, 1
  add RS1, RS1, RS2
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SH1ADDUW:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  mov RS1w, RS1w
  lsl RS1, RS1, 1
  add RS1, RS1, RS2
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SH2ADD:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  lsl RS1, RS1, 2
  add RS1, RS1, RS2
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SH2ADDUW:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  mov RS1w, RS1w
  lsl RS1, RS1, 2
  add RS1, RS1, RS2
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SH3ADD:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  lsl RS1, RS1, 3
  add RS1, RS1, RS2
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SH3ADDUW:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  mov RS1w, RS1w
  lsl RS1, RS1, 3
  add RS1, RS1, RS2
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SLLIUW:
  DECODE_I
  ldr RS1, REGISTER_ADDRESS(RS1)
  mov RS1w, RS1w
  and IMMEDIATE, IMMEDIATE, 0x3f
  lsl RS1, RS1, IMMEDIATE
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_XNOR:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  mvn RS2, RS2
  eor RS1, RS1, RS2
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_ZEXTH:
  DECODE_R
  ldr RS1, REGISTER_ADDRESS(RS1)
  lsl RS1w, RS1w, 16
  lsr RS1w, RS1w, 16
  sxtw RS1, RS1w
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_FAR_JUMP_ABS:
  DECODE_U
  mov RS2, IMMEDIATE
  ldr TEMP1, PC_ADDRESS
  str TEMP1, RA_ADDRESS
  and RS2, RS2, -2
  str RS2, PC_ADDRESS
  b .prepare_trace
.CKB_VM_ASM_LABEL_OP_FAR_JUMP_REL:
  DECODE_U
  ldr RS2, PC_ADDRESS
  /* Loading instruction flags */
  ldr TEMP3, [INST_ARGS, -16]
  asr TEMP3, TEMP3, 24
  and TEMP3, TEMP3, 0xF
  lsl TEMP3, TEMP3, 1
  sub RS2, RS2, TEMP3
  add RS2, RS2, IMMEDIATE
  ldr TEMP1, PC_ADDRESS
  str TEMP1, RA_ADDRESS
  and RS2, RS2, -2
  str RS2, PC_ADDRESS
  b .prepare_trace
.CKB_VM_ASM_LABEL_OP_WIDE_MUL:
  DECODE_R4
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  mul TEMP1, RS1, RS2
  smulh TEMP2, RS1, RS2
  WRITE_RS3(TEMP1)
  WRITE_RD(TEMP2)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_WIDE_MULU:
  DECODE_R4
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  mul TEMP1, RS1, RS2
  umulh TEMP2, RS1, RS2
  WRITE_RS3(TEMP1)
  WRITE_RD(TEMP2)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_WIDE_MULSU:
  DECODE_R4
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  tst RS1, RS1
  bpl .wide_mulsu_branch1
  neg TEMP3, RS1
  umulh TEMP1, TEMP3, RS2
  mov TEMP3, -1
  eor TEMP1, TEMP1, TEMP3
  mul TEMP2, RS1, RS2
  tst TEMP2, TEMP2
  cset TEMP3, eq
  add TEMP1, TEMP1, TEMP3
  WRITE_RS3(TEMP2)
  WRITE_RD(TEMP1)
  NEXT_INST
.wide_mulsu_branch1:
  mul TEMP1, RS1, RS2
  umulh TEMP2, RS1, RS2
  WRITE_RS3(TEMP1)
  WRITE_RD(TEMP2)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_WIDE_DIV:
  DECODE_R4
  mov TEMP2, INT64_MIN
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  cmp RS1, TEMP2
  bne .wide_div_branch1
  cmp RS2, -1
  bne .wide_div_branch1
  mov TEMP1, 0
  b .wide_div_branch3
.wide_div_branch1:
  cmp RS2, 0
  bne .wide_div_branch2
  mov TEMP1, RS1
  mov RS1, UINT64_MAX
  b .wide_div_branch3
.wide_div_branch2:
  sdiv TEMP2, RS1, RS2
  msub TEMP1, TEMP2, RS2, RS1
  mov RS1, TEMP2
.wide_div_branch3:
  WRITE_RS3(TEMP1)
  WRITE_RD(RS1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_WIDE_DIVU:
  DECODE_R4
  ldr RS1, REGISTER_ADDRESS(RS1)
  ldr RS2, REGISTER_ADDRESS(RS2)
  cmp RS2, 0
  bne .wide_divu_branch1
  WRITE_RS3(RS1)
  mov TEMP1, UINT64_MAX
  WRITE_RD(TEMP1)
  NEXT_INST
.wide_divu_branch1:
  udiv TEMP1, RS1, RS2
  msub TEMP2, TEMP1, RS2, RS1
  WRITE_RS3(TEMP2)
  WRITE_RD(TEMP1)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_ADC:
  DECODE_R
  mov TEMP1, 0
  mov TEMP2, 0
  mov TEMP5, 0
  ldr TEMP3, REGISTER_ADDRESS(RD)
  ldr TEMP4, REGISTER_ADDRESS(RS1)
  adds TEMP3, TEMP3, TEMP4
  adc TEMP1, TEMP1, TEMP5
  ldr TEMP4, REGISTER_ADDRESS(RS2)
  adds TEMP3, TEMP3, TEMP4
  adc TEMP2, TEMP2, TEMP5
  orr TEMP1, TEMP1, TEMP2
  WRITE_RS1(TEMP1)
  WRITE_RS2(TEMP2)
  WRITE_RD(TEMP3)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_SBB:
  DECODE_R4
  mov TEMP1, 0
  mov TEMP2, 0
  mov TEMP5, 0
  ldr TEMP3, REGISTER_ADDRESS(RD)
  ldr TEMP4, REGISTER_ADDRESS(RS1)
  subs TEMP3, TEMP3, TEMP4
  adc TEMP1, TEMP1, TEMP5
  eor TEMP1, TEMP1, 1
  ldr TEMP4, REGISTER_ADDRESS(RS2)
  subs TEMP3, TEMP3, TEMP4
  adc TEMP2, TEMP2, TEMP5
  eor TEMP2, TEMP2, 1
  WRITE_RS2(TEMP2)
  WRITE_RS3(TEMP1)
  orr TEMP1, TEMP1, TEMP2
  WRITE_RS1(TEMP1)
  WRITE_RD(TEMP3)
  NEXT_INST
.CKB_VM_ASM_LABEL_OP_ADCS:
  DECODE_R4
  mov TEMP1, 0
  ldr TEMP3, REGISTER_ADDRESS(RS1)
  ldr TEMP4, REGISTER_ADDRESS(RS2)
  adds TEMP3, TEMP3, TEMP4
  adc TEMP1, TEMP1, TEMP1
  WRITE_RD_V2(TEMP3)
  WRITE_RS3(TEMP1)
  NEXT_INST_V2
.CKB_VM_ASM_LABEL_OP_SBBS:
  DECODE_R4
  mov TEMP1, 0
  ldr TEMP3, REGISTER_ADDRESS(RS1)
  ldr TEMP4, REGISTER_ADDRESS(RS2)
  subs TEMP3, TEMP3, TEMP4
  adc TEMP1, TEMP1, TEMP1
  eor TEMP1, TEMP1, 1
  WRITE_RD_V2(TEMP3)
  WRITE_RS3(TEMP1)
  NEXT_INST_V2
.CKB_VM_ASM_LABEL_OP_ADD3A:
  DECODE_R5
  mov TEMP2, 0
  ldr TEMP4, REGISTER_ADDRESS(RD)
  ldr TEMP1, REGISTER_ADDRESS(RS1)
  adds TEMP4, TEMP4, TEMP1
  adc TEMP2, TEMP2, TEMP2
  mov TEMP3, TEMP2
  ldr TEMP1, REGISTER_ADDRESS(RS4_TEMP5)
  add TEMP3, TEMP3, TEMP1
  WRITE_RD_V2(TEMP4)
  WRITE_RS2(TEMP2)
  WRITE_RS3(TEMP3)
  NEXT_INST_V2
.CKB_VM_ASM_LABEL_OP_ADD3B:
  DECODE_R5
  mov TEMP2, 0
  ldr TEMP4, REGISTER_ADDRESS(RS1)
  ldr TEMP1, REGISTER_ADDRESS(RS2)
  adds TEMP4, TEMP4, TEMP1
  adc TEMP2, TEMP2, TEMP2
  mov TEMP3, TEMP2
  ldr TEMP1, REGISTER_ADDRESS(RS4_TEMP5)
  add TEMP3, TEMP3, TEMP1
  WRITE_RD_V2(TEMP4)
  WRITE_RS1(TEMP2)
  WRITE_RS3(TEMP3)
  NEXT_INST_V2
.CKB_VM_ASM_LABEL_OP_ADD3C:
  DECODE_R5
  mov TEMP3, 0
  ldr TEMP1, REGISTER_ADDRESS(RS1)
  ldr TEMP2, REGISTER_ADDRESS(RS2)
  ldr TEMP4, REGISTER_ADDRESS(RS4_TEMP5)
  adds TEMP1, TEMP1, TEMP2
  adc TEMP3, TEMP3, TEMP4
  WRITE_RD_V2(TEMP1)
  WRITE_RS3(TEMP3)
  NEXT_INST_V2
.exit_max_cycles_exceeded:
  mov x0, CKB_VM_ASM_RET_MAX_CYCLES_EXCEEDED
  b .exit
.exit_cycles_overflow:
  mov x0, CKB_VM_ASM_RET_CYCLES_OVERFLOW
  b .exit
.exit_out_of_bound:
  str TEMP3, [MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_ERROR_ARG0]
  mov x0, CKB_VM_ASM_RET_OUT_OF_BOUND
  b .exit
.exit_invalid_permission:
  str TEMP1, [MACHINE, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_ERROR_ARG0]
  mov x0, CKB_VM_ASM_RET_INVALID_PERMISSION
  b .exit
.exit_pause:
  mov x0, CKB_VM_ASM_RET_PAUSE
  b .exit
.exit_trace:
.CKB_VM_ASM_LABEL_OP_UNLOADED:
  DECODE_U
  mov x0, CKB_VM_ASM_RET_DECODE_TRACE
  b .exit
.exit_slowpath:
  DECODE_U
  mov x0, CKB_VM_ASM_RET_SLOWPATH
  b .exit
.exit:
  ldp x29, x30, [sp, 80]
  ldp x27, x28, [sp, 64]
  ldp x25, x26, [sp, 48]
  ldp x23, x24, [sp, 32]
  ldp x21, x22, [sp, 16]
  ldp x19, x20, [sp], 96
  ret


================================================
File: src/machine/asm/execute_x64.S
================================================
#define CKB_VM_ASM_GENERATE_LABEL_TABLES 1
#include "cdefinitions_generated.h"

#ifdef _WIN32
#define IS_WINDOWS 1
#endif

#define INT64_MIN 0x8000000000000000
#define UINT64_MAX 0xffffffffffffffff

#ifdef IS_WINDOWS
#define ARG1 %rcx
#define ARG2 %rdx
#else
#define ARG1 %rdi
#define ARG2 %rsi
#endif

#ifdef IS_WINDOWS
#define PREPCALL \
  push %rdi; \
  push %rsi; \
  push %rax; \
  push %rcx; \
  push %rdx; \
  push %r8; \
  push %r9; \
  push %r10; \
  push %rbp; \
  movq %rsp, %rbp; \
  andq $-16, %rsp; \
  sub $32, %rsp
#define POSTCALL \
  add $32, %rsp; \
  movq %rbp, %rsp; \
  pop %rbp; \
  pop %r10; \
  pop %r9; \
  pop %r8; \
  pop %rdx; \
  pop %rcx; \
  pop %rax; \
  pop %rsi; \
  pop %rdi
#else
#define PREPCALL \
  push %rdi; \
  push %rsi; \
  push %rax; \
  push %rcx; \
  push %rdx; \
  push %r8; \
  push %r9; \
  push %r10; \
  push %rbp; \
  movq %rsp, %rbp; \
  andq $-16, %rsp
#define POSTCALL \
  movq %rbp, %rsp; \
  pop %rbp; \
  pop %r10; \
  pop %r9; \
  pop %r8; \
  pop %rdx; \
  pop %rcx; \
  pop %rax; \
  pop %rsi; \
  pop %rdi
#endif

/* rax is used both in Microsoft x64 and System V AMD64 ABI */
#define ARG_RETd %eax

#define MACHINE %rsi
#define TRACE %rbx
#define MEMORY_SIZE %r13
#define INVOKE_DATA %r14

/*
 * INST_PC contains the current address of decoded Instruction in
 * Trace item, which is different from the RISC-V PC
 */
#define INST_PC %r8
#define INST_ARGS %r9

/*
 * Rules to meet when considering register allocations:
 * * RD and TEMP1 cannot be %rcx to set aside %cl for shifts
 * * RS2r and TEMP1 cannot be %rax to allow using imul and idiv
 * * RS2r cannot be %rdx to allow using idiv
 */
#define RD_RS2s %rax
#define RD RD_RS2s
#define RS1 %rdx
#define RS2r %rbp
#define RS2s RD_RS2s
#define RS3 %r12
#define IMMEDIATE %rcx
#define TEMP1 %rdi
#define TEMP2 %r10
#define TEMP3 %r11
/* This helps remind us that RS4 and TEMP1 shares the same register */
#define RS4_TEMP1 TEMP1

#define RDd_RS2sd %eax
#define RDd RDd_RS2sd
#define RS1d %edx
#define RS1h %dx
#define RS1b %dl
#define RS2rd %ebp
#define RS2rb %bpl
#define RS2sd %eax
#define RS2sb %al
#define RS2sh %ax
#define RS3d %r12d
#define IMMEDIATEb %cl
#define IMMEDIATEd %ecx
#define TEMP1b %dil
#define TEMP1d %edi
#define TEMP2d %r10d
#define TEMP2b %r10b
#define TEMP3d %r11d
#define TEMP3b %r11b
#define RS4_TEMP1d TEMP1d

#define PC_ADDRESS \
  CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_PC(MACHINE)

#define ZERO_ADDRESS \
  CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_REGISTERS(MACHINE)

#define RA_ADDRESS \
  (CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_REGISTERS + CKB_VM_ASM_REGISTER_RA * 8)(MACHINE)

#define SP_ADDRESS \
  (CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_REGISTERS + CKB_VM_ASM_REGISTER_SP * 8)(MACHINE)

#define REGISTER_ADDRESS(r) \
  CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_REGISTERS(MACHINE, r, 8)

#define LOAD_RESERVATION_ADDRESS \
  CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_LOAD_RESERVATION_ADDRESS(MACHINE)

/*
 * Those macros provide slight abstractions over register allocations,
 * they might change when we alter register allocations. For example:
 *
 * * A push operation needs to do nothing if the variable to push is not
 * the register we need to save
 * * A move operation becomes nop if the variable is assigned the same
 * register as the target
 */
#define PUSH_RD_IF_RAX push %rax
#define PUSH_RD_IF_RDX
#define POP_RD_IF_RAX pop %rax
#define POP_RD_IF_RDX
#define PUSH_RS1_IF_RAX
#define PUSH_RS1_IF_RDX push %rdx
#define POP_RS1_IF_RAX
#define POP_RS1_IF_RDX pop %rdx

#define MOV_RS1_TO_RAX movq RS1, %rax
#define MOV_RAX_TO_RS1 movq %rax, RS1
#define MOV_RS2r_TO_RAX movq RS2r, %rax
#define MOV_RAX_TO_RS2r movq %rax, RS2r
#define MOV_RS1_TO_RDX
#define MOV_RDX_TO_RS1
#define MOV_RS2r_TO_RDX movq RS2r, %rdx
#define MOV_RDX_TO_RS2r movq %rdx, RS2r
#define MOV_IMM_TO_RCX
#ifdef IS_WINDOWS
#define MOV_TEMP1_TO_ARG1 movq TEMP1, ARG1
#define MOV_MACHINE_TO_ARG2 movq MACHINE, ARG2
#else
#define MOV_TEMP1_TO_ARG1
#define MOV_MACHINE_TO_ARG2
#endif

#ifdef __APPLE__
#define CALL_INITED_MEMORY call _inited_memory
#elif defined IS_WINDOWS
#define CALL_INITED_MEMORY call inited_memory
#else
#define CALL_INITED_MEMORY call inited_memory@plt
#endif

/*
 * This is an internal macro used by other macros, it should not be used
 * in instruction implementation directly.
 */
#define _CHECK_READ_FRAMES(address_reg, length) \
  movq address_reg, TEMP1; \
  shr $CKB_VM_ASM_MEMORY_FRAME_SHIFTS, TEMP1; \
  movq TEMP1, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_LAST_READ_FRAME(MACHINE); \
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_FRAMES_PTR(MACHINE), TEMP3; \
  movzbl (TEMP3, TEMP1), TEMP2d; \
  cmp $0, TEMP2d; \
  jne 1f; \
  movb $1, (TEMP3, TEMP1); \
  PREPCALL; \
  MOV_TEMP1_TO_ARG1; \
  MOV_MACHINE_TO_ARG2; \
  CALL_INITED_MEMORY; \
  POSTCALL; \
1: \
  movq address_reg, TEMP1; \
  addq $length, TEMP1; \
  subq $1, TEMP1; \
  shr $CKB_VM_ASM_MEMORY_FRAME_SHIFTS, TEMP1; \
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_FRAMES_PTR(MACHINE), TEMP3; \
  movzbl (TEMP3, TEMP1), TEMP2d; \
  cmp $0, TEMP2d; \
  jne 2f; \
  movb $1, (TEMP3, TEMP1);\
  PREPCALL; \
  MOV_TEMP1_TO_ARG1; \
  MOV_MACHINE_TO_ARG2; \
  CALL_INITED_MEMORY; \
  POSTCALL; \
2:

#define CHECK_READ_VERSION0(address_reg, length) \
  movq address_reg, TEMP1; \
  shr $CKB_VM_ASM_MEMORY_FRAME_SHIFTS, TEMP1; \
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_LAST_READ_FRAME(MACHINE), TEMP2; \
  cmp TEMP2, TEMP1; \
  jne 3f; \
  movq address_reg, TEMP2; \
  addq $length, TEMP2; \
  shr $CKB_VM_ASM_MEMORY_FRAME_SHIFTS, TEMP2; \
  cmp TEMP2, TEMP1; \
  je 2f; \
3: ; \
  movq address_reg, TEMP3; \
  cmp MEMORY_SIZE, TEMP3; \
  jae .exit_out_of_bound; \
  addq $length, TEMP3; \
  cmp MEMORY_SIZE, TEMP3; \
  jae .exit_out_of_bound; \
  _CHECK_READ_FRAMES(address_reg, length)

#define CHECK_READ_VERSION1(address_reg, length) \
  movq address_reg, TEMP1; \
  shr $CKB_VM_ASM_MEMORY_FRAME_SHIFTS, TEMP1; \
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_LAST_READ_FRAME(MACHINE), TEMP2; \
  cmp TEMP2, TEMP1; \
  jne 3f; \
  movq address_reg, TEMP2; \
  addq $length, TEMP2; \
  shr $CKB_VM_ASM_MEMORY_FRAME_SHIFTS, TEMP2; \
  cmp TEMP2, TEMP1; \
  je 2f; \
3: ;\
  movq address_reg, TEMP3; \
  cmp MEMORY_SIZE, TEMP3; \
  jae .exit_out_of_bound; \
  addq $length, TEMP3; \
  cmp MEMORY_SIZE, TEMP3; \
  ja .exit_out_of_bound; \
  _CHECK_READ_FRAMES(address_reg, length)

#define CHECK_WRITE(address_reg, temp_regd, length) \
  movq address_reg, TEMP1; \
  shr $CKB_VM_ASM_RISCV_PAGE_SHIFTS, TEMP1; \
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_LAST_WRITE_PAGE(MACHINE), TEMP2; \
  cmp TEMP2, TEMP1; \
  jne 3f;\
  movq address_reg, TEMP2; \
  addq $length, TEMP2; \
  shr $CKB_VM_ASM_RISCV_PAGE_SHIFTS, TEMP2; \
  cmp TEMP2, TEMP1; \
  je 2f;\
3:; \
  movq address_reg, TEMP3; \
  movq TEMP1, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_LAST_WRITE_PAGE(MACHINE); \
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_FLAGS_SIZE(MACHINE), TEMP2; \
  cmp TEMP2, TEMP1; \
  jae .exit_out_of_bound; \
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_FLAGS_PTR(MACHINE), TEMP3; \
  movzbl (TEMP3, TEMP1), temp_regd; \
  mov temp_regd, TEMP2d; \
  and $CKB_VM_ASM_MEMORY_FLAG_WXORX_BIT, temp_regd; \
  cmp $CKB_VM_ASM_MEMORY_FLAG_WRITABLE, temp_regd; \
  jne .exit_invalid_permission; \
  or $CKB_VM_ASM_MEMORY_FLAG_DIRTY, TEMP2b; \
  movb TEMP2b, (TEMP3, TEMP1); \
  movq TEMP1, TEMP2; \
  shr $CKB_VM_ASM_MEMORY_FRAME_PAGE_SHIFTS, TEMP1; \
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_FRAMES_PTR(MACHINE), TEMP3; \
  movzbl (TEMP3, TEMP1), temp_regd; \
  cmp $0, temp_regd; \
  jne 1f; \
  movb $1, (TEMP3, TEMP1); \
  PREPCALL; \
  MOV_TEMP1_TO_ARG1; \
  MOV_MACHINE_TO_ARG2; \
  CALL_INITED_MEMORY; \
  POSTCALL; \
1: \
  movq TEMP2, TEMP1; \
  addq $1, TEMP1; \
  shl $CKB_VM_ASM_RISCV_PAGE_SHIFTS, TEMP1; \
  movq address_reg, TEMP3; \
  addq $length, TEMP3; \
  cmp TEMP1, TEMP3; \
  jbe 2f; \
  shr $CKB_VM_ASM_RISCV_PAGE_SHIFTS, TEMP1; \
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_FLAGS_SIZE(MACHINE), TEMP2; \
  cmp TEMP2, TEMP1; \
  jae .exit_out_of_bound; \
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_FLAGS_PTR(MACHINE), TEMP3; \
  movzbl (TEMP3, TEMP1), temp_regd; \
  mov temp_regd, TEMP2d; \
  and $CKB_VM_ASM_MEMORY_FLAG_WXORX_BIT, temp_regd; \
  cmp $CKB_VM_ASM_MEMORY_FLAG_WRITABLE, temp_regd; \
  jne .exit_invalid_permission; \
  or $CKB_VM_ASM_MEMORY_FLAG_DIRTY, TEMP2b; \
  movb TEMP2b, (TEMP3, TEMP1); \
  shr $CKB_VM_ASM_MEMORY_FRAME_PAGE_SHIFTS, TEMP1; \
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_FRAMES_PTR(MACHINE), TEMP3; \
  movzbl (TEMP3, TEMP1), temp_regd; \
  cmp $0, temp_regd; \
  jne 2f; \
  movb $1, (TEMP3, TEMP1); \
  PREPCALL; \
  MOV_TEMP1_TO_ARG1; \
  MOV_MACHINE_TO_ARG2; \
  CALL_INITED_MEMORY; \
  POSTCALL; \
2:

#define WRITE_RD_VALUE(v, temp_reg) \
  movq v, temp_reg; \
  movq temp_reg, REGISTER_ADDRESS(RD); \
  movq $0, ZERO_ADDRESS

#define WRITE_RD(v) \
  movq v, REGISTER_ADDRESS(RD); \
  movq $0, ZERO_ADDRESS

#define WRITE_RD_V2(v) \
  movq v, REGISTER_ADDRESS(RD); \

#define WRITE_RS1(v) \
  movq v, REGISTER_ADDRESS(RS1); \

#define WRITE_RS2r(v) \
  movq v, REGISTER_ADDRESS(RS2r); \

#define WRITE_RS3(v) \
  movq v, REGISTER_ADDRESS(RS3); \

/*
 * This macro is added to cope with an implementation bug in the x64 assembly code,
 * where address bigger than u32 limit will be truncated unexpectedly.
 *
 * Useful tip: https://stackoverflow.com/a/66416462
 */
#define LOAD_PC(reg1, reg1d, reg2, reg2d, temp_regd) \
  movq PC_ADDRESS, reg1; \
  mov reg1d, reg2d; \
  movzbl CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_VERSION(MACHINE), temp_regd; \
  cmp $2, temp_regd; \
  cmovae reg1, reg2

/*
 * Notice we could replace the last 3 instructions with the following:
 *
 * addq $8, INST_PC
 * jmp *-8(TEMP1)
 *
 * Even though this would save us one instruction to exectue, keeping the jump
 * target in TEMP1 actually aids branch predictor for better performance.
 */
#define NEXT_INST \
  movq (INST_ARGS), %rcx; \
  addq $16, INST_ARGS; \
  movzbl %ch, RDd_RS2sd; \
  sar $32, %rcx; \
  movq (INST_PC), TEMP1; \
  addq $16, INST_PC; \
  jmp *TEMP1

#define NEXT_INST_V2 \
  movq $0, ZERO_ADDRESS; \
  NEXT_INST

#define DECODE_R \
  movzbl %cl, RS1d; \
  movzbl %ch, RS2rd

#define DECODE_I \
  movzbl %cl, RS1d; \
  sar $8, %rcx

#define DECODE_S \
  movzbl %cl, RS1d; \
  sar $8, %rcx

#define DECODE_U

#define DECODE_R4 \
  movzbl %cl, RS1d; \
  movzbl %ch, RS2rd; \
  sar $16, %rcx; \
  movzbl %cl, RS3d

#define DECODE_R5 \
  movzbl %cl, RS1d; \
  movzbl %ch, RS2rd; \
  sar $16, %rcx; \
  movzbl %cl, RS3d; \
  movzbl %ch, RS4_TEMP1d

#ifdef __APPLE__
.globl _ckb_vm_x64_execute
_ckb_vm_x64_execute:
#else
.globl ckb_vm_x64_execute
ckb_vm_x64_execute:
#endif
#ifdef IS_WINDOWS
  push %rsi
  push %rdi
#endif
  push %rbp
  push %rbx
  push %r12
  push %r13
  push %r14
  mov ARG2, INVOKE_DATA
  mov ARG1, MACHINE
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_SIZE(MACHINE), MEMORY_SIZE
.p2align 3
.CKB_VM_ASM_LABEL_OP_CUSTOM_TRACE_END:
  LOAD_PC(%rax, %eax, %rcx, %ecx, TEMP3d)
  shr $2, %eax
  andq CKB_VM_ASM_INVOKE_DATA_OFFSET_FIXED_TRACE_MASK(INVOKE_DATA), %rax
  imul $CKB_VM_ASM_FIXED_TRACE_STRUCT_SIZE, %eax
  movq CKB_VM_ASM_INVOKE_DATA_OFFSET_FIXED_TRACES(INVOKE_DATA), TRACE
  addq %rax, TRACE
  movq CKB_VM_ASM_TRACE_OFFSET_ADDRESS(TRACE), %rdx
  cmp %rcx, %rdx
  jne .exit_trace
  mov CKB_VM_ASM_TRACE_OFFSET_LENGTH(TRACE), %edx
  cmp $0, %rdx
  je .exit_trace
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_CYCLES(MACHINE), %rax
  addq CKB_VM_ASM_TRACE_OFFSET_CYCLES(TRACE), %rax
  jc .exit_cycles_overflow
  cmp CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MAX_CYCLES(MACHINE), %rax
  ja .exit_max_cycles_exceeded
  movq %rax, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_CYCLES(MACHINE)
  addq %rdx, PC_ADDRESS
  /* Prefetch trace info for the consecutive block */
  movq PC_ADDRESS, %rax
  shr $2, %eax
  andq CKB_VM_ASM_INVOKE_DATA_OFFSET_FIXED_TRACE_MASK(INVOKE_DATA), %rax
  imul $CKB_VM_ASM_FIXED_TRACE_STRUCT_SIZE, %eax
  movq CKB_VM_ASM_INVOKE_DATA_OFFSET_FIXED_TRACES(INVOKE_DATA), %rdx
  prefetcht2 0(%rdx, %rax)
  lea CKB_VM_ASM_TRACE_OFFSET_THREADS(TRACE), INST_PC
  mov INST_PC, INST_ARGS
  add $8, INST_ARGS
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_CUSTOM_ASM_TRACE_JUMP:
  /* Load current instruction as the full trace address */
  movq -16(INST_ARGS), TRACE
  /* Prefetch trace info for the consecutive block */
  prefetcht2 CKB_VM_ASM_TRACE_OFFSET_THREADS(TRACE)
  mov CKB_VM_ASM_TRACE_OFFSET_LENGTH(TRACE), %edx
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_CYCLES(MACHINE), %rax
  addq CKB_VM_ASM_TRACE_OFFSET_CYCLES(TRACE), %rax
  jc .exit_cycles_overflow
  cmp CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MAX_CYCLES(MACHINE), %rax
  ja .exit_max_cycles_exceeded
  movq %rax, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_CYCLES(MACHINE)
  addq %rdx, PC_ADDRESS
  lea CKB_VM_ASM_TRACE_OFFSET_THREADS(TRACE), INST_PC
  mov INST_PC, INST_ARGS
  add $8, INST_ARGS
  NEXT_INST
.p2align 3
.prepare_trace:
  movq CKB_VM_ASM_INVOKE_DATA_OFFSET_PAUSE(INVOKE_DATA), %rax
  movzbl 0(%rax), %eax
  cmp $0, %rax
  jnz .exit_pause
  LOAD_PC(%rax, %eax, %rcx, %ecx, TEMP3d)
  shr $2, %eax
  andq CKB_VM_ASM_INVOKE_DATA_OFFSET_FIXED_TRACE_MASK(INVOKE_DATA), %rax
  imul $CKB_VM_ASM_FIXED_TRACE_STRUCT_SIZE, %eax
  movq CKB_VM_ASM_INVOKE_DATA_OFFSET_FIXED_TRACES(INVOKE_DATA), TRACE
  addq %rax, TRACE
  movq CKB_VM_ASM_TRACE_OFFSET_ADDRESS(TRACE), %rdx
  cmp %rcx, %rdx
  jne .exit_trace
  mov CKB_VM_ASM_TRACE_OFFSET_LENGTH(TRACE), %edx
  cmp $0, %rdx
  je .exit_trace
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_CYCLES(MACHINE), %rax
  addq CKB_VM_ASM_TRACE_OFFSET_CYCLES(TRACE), %rax
  jc .exit_cycles_overflow
  cmp CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MAX_CYCLES(MACHINE), %rax
  ja .exit_max_cycles_exceeded
  movq %rax, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_CYCLES(MACHINE)
  addq %rdx, PC_ADDRESS
  lea CKB_VM_ASM_TRACE_OFFSET_THREADS(TRACE), INST_PC
  mov INST_PC, INST_ARGS
  add $8, INST_ARGS
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_ADDI:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), RS1
  addq IMMEDIATE, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_ADD:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  addq REGISTER_ADDRESS(RS2r), RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_ADDIW:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), RS1
  addq IMMEDIATE, RS1
  movslq RS1d, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_ADDW:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  addq REGISTER_ADDRESS(RS2r), RS1
  movslq RS1d, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_AND:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  andq REGISTER_ADDRESS(RS2r), RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_ANDI:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), RS1
  andq IMMEDIATE, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_AUIPC:
  DECODE_U
  movq PC_ADDRESS, RS1
  subq $4, RS1
  addq IMMEDIATE, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_BEQ:
  DECODE_S
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2s), RS2s
  cmpq RS2s, RS1
  je .i_branch_success
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_BGE:
  DECODE_S
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2s), RS2s
  cmpq RS2s, RS1
  jge .i_branch_success
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_BGEU:
  DECODE_S
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2s), RS2s
  cmpq RS2s, RS1
  jae .i_branch_success
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_BLT:
  DECODE_S
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2s), RS2s
  cmpq RS2s, RS1
  jl .i_branch_success
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_BLTU:
  DECODE_S
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2s), RS2s
  cmpq RS2s, RS1
  jb .i_branch_success
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_BNE:
  DECODE_S
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2s), RS2s
  cmpq RS2s, RS1
  jne .i_branch_success
  NEXT_INST
.i_branch_success:
  movq PC_ADDRESS, RS1
  /* Loading flag of current instruction */
  movq -16(INST_ARGS), TEMP3
  sar $24, TEMP3
  andq $0xF, TEMP3
  shl $1, TEMP3
  subq TEMP3, RS1
  addq IMMEDIATE, RS1
  movq RS1, PC_ADDRESS
  jmp .prepare_trace
.p2align 3
.CKB_VM_ASM_LABEL_OP_DIV:
  DECODE_R
  push RD
  movq $INT64_MIN, RD
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  cmp RD, RS1
  jne .div_branch1
  cmp $-1, RS2r
  jne .div_branch1
  jmp .div_branch3
.div_branch1:
  cmp $0, RS2r
  jne .div_branch2
  movq $UINT64_MAX, RS1
  jmp .div_branch3
.div_branch2:
  MOV_RS1_TO_RAX
  cqo
  idivq RS2r
  MOV_RAX_TO_RS1
.div_branch3:
  pop RD
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_DIVU:
  DECODE_R
  movq REGISTER_ADDRESS(RS2r), RS2r
  cmp $0, RS2r
  jne .divu_branch1
  WRITE_RD_VALUE($UINT64_MAX, RS2r)
  NEXT_INST
.divu_branch1:
  PUSH_RD_IF_RAX
  PUSH_RD_IF_RDX
  movq REGISTER_ADDRESS(RS1), %rax
  xorq %rdx, %rdx
  divq RS2r
  mov %rax, RS2r
  POP_RD_IF_RDX
  POP_RD_IF_RAX
  WRITE_RD(RS2r)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_DIVUW:
  DECODE_R
  movq REGISTER_ADDRESS(RS2r), RS2r
  mov RS2rd, RS2rd
  cmp $0, RS2r
  jne .divuw_branch1
  WRITE_RD_VALUE($UINT64_MAX, RS2r)
  NEXT_INST
.divuw_branch1:
  PUSH_RD_IF_RAX
  PUSH_RD_IF_RDX
  movq REGISTER_ADDRESS(RS1), %rax
  mov %eax, %eax
  xorq %rdx, %rdx
  divq RS2r
  mov %rax, RS2r
  POP_RD_IF_RDX
  POP_RD_IF_RAX
  movslq RS2rd, RS2r
  WRITE_RD(RS2r)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_DIVW:
  DECODE_R
  push RD
  movq $INT64_MIN, RD
  movq REGISTER_ADDRESS(RS1), RS1
  movslq RS1d, RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  movslq RS2rd, RS2r
  cmp RD, RS1
  jne .divw_branch1
  cmp $-1, RS2r
  jne .divw_branch1
  jmp .divw_branch3
.divw_branch1:
  cmp $0, RS2r
  jne .divw_branch2
  movq $UINT64_MAX, RS1
  jmp .divw_branch3
.divw_branch2:
  MOV_RS1_TO_RAX
  cqo
  idivq RS2r
  MOV_RAX_TO_RS1
.divw_branch3:
  pop RD
  movslq RS1d, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_EBREAK:
  DECODE_U
  mov $CKB_VM_ASM_RET_EBREAK, ARG_RETd
  jmp .exit
.p2align 3
.CKB_VM_ASM_LABEL_OP_ECALL:
  DECODE_U
  mov $CKB_VM_ASM_RET_ECALL, ARG_RETd
  jmp .exit
.p2align 3
.CKB_VM_ASM_LABEL_OP_FENCE:
.CKB_VM_ASM_LABEL_OP_FENCEI:
  DECODE_U
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_JAL:
  DECODE_U
  movq PC_ADDRESS, RS1
  WRITE_RD(RS1)
  /* Loading flag of current instruction */
  movq -16(INST_ARGS), TEMP3
  sar $24, TEMP3
  andq $0xF, TEMP3
  shl $1, TEMP3
  subq TEMP3, RS1
  addq IMMEDIATE, RS1
  movq RS1, PC_ADDRESS
  jmp .prepare_trace
.p2align 3
.CKB_VM_ASM_LABEL_OP_JALR_VERSION0:
  DECODE_I
  movq PC_ADDRESS, TEMP1
  WRITE_RD(TEMP1)
  movq REGISTER_ADDRESS(RS1), TEMP1
  addq IMMEDIATE, TEMP1
  andq $-2, TEMP1
  movq TEMP1, PC_ADDRESS
  jmp .prepare_trace
/* RS2r is used as a temporary register here */
.p2align 3
.CKB_VM_ASM_LABEL_OP_JALR_VERSION1:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), RS2r
  movq PC_ADDRESS, TEMP1
  WRITE_RD(TEMP1)
  addq IMMEDIATE, RS2r
  andq $-2, RS2r
  movq RS2r, PC_ADDRESS
  jmp .prepare_trace
.p2align 3
.CKB_VM_ASM_LABEL_OP_LB_VERSION0:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), RS1
  addq IMMEDIATE, RS1
  CHECK_READ_VERSION0(RS1, 1)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movsbq (TEMP1, RS1), RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_LB_VERSION1:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), RS1
  addq IMMEDIATE, RS1
  CHECK_READ_VERSION1(RS1, 1)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movsbq (TEMP1, RS1), RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_LBU_VERSION0:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), RS1
  addq IMMEDIATE, RS1
  CHECK_READ_VERSION0(RS1, 1)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movzbq (TEMP1, RS1), RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_LBU_VERSION1:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), RS1
  addq IMMEDIATE, RS1
  CHECK_READ_VERSION1(RS1, 1)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movzbq (TEMP1, RS1), RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_LD_VERSION0:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), RS1
  addq IMMEDIATE, RS1
  CHECK_READ_VERSION0(RS1, 8)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movq (TEMP1, RS1), RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_LD_VERSION1:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), RS1
  addq IMMEDIATE, RS1
  CHECK_READ_VERSION1(RS1, 8)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movq (TEMP1, RS1), RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_LH_VERSION0:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), RS1
  addq IMMEDIATE, RS1
  CHECK_READ_VERSION0(RS1, 2)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movswq (TEMP1, RS1), RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_LH_VERSION1:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), RS1
  addq IMMEDIATE, RS1
  CHECK_READ_VERSION1(RS1, 2)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movswq (TEMP1, RS1), RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_LHU_VERSION0:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), RS1
  addq IMMEDIATE, RS1
  CHECK_READ_VERSION0(RS1, 2)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movzwq (TEMP1, RS1), RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_LHU_VERSION1:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), RS1
  addq IMMEDIATE, RS1
  CHECK_READ_VERSION1(RS1, 2)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movzwq (TEMP1, RS1), RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_LUI:
.CKB_VM_ASM_LABEL_OP_CUSTOM_LOAD_IMM:
  DECODE_U
  WRITE_RD(IMMEDIATE)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_CUSTOM_LOAD_UIMM:
  DECODE_U
  mov IMMEDIATEd, IMMEDIATEd
  WRITE_RD(IMMEDIATE)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_LW_VERSION0:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), RS1
  addq IMMEDIATE, RS1
  CHECK_READ_VERSION0(RS1, 4)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movslq (TEMP1, RS1), RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_LW_VERSION1:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), RS1
  addq IMMEDIATE, RS1
  CHECK_READ_VERSION1(RS1, 4)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movslq (TEMP1, RS1), RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_LWU_VERSION0:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), RS1
  addq IMMEDIATE, RS1
  CHECK_READ_VERSION0(RS1, 4)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  mov (TEMP1, RS1), RS1d
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_LWU_VERSION1:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), RS1
  addq IMMEDIATE, RS1
  CHECK_READ_VERSION1(RS1, 4)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  mov (TEMP1, RS1), RS1d
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_MUL:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  imul REGISTER_ADDRESS(RS2r), RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_MULH:
  DECODE_R
  PUSH_RD_IF_RAX
  PUSH_RD_IF_RDX
  movq REGISTER_ADDRESS(RS1), %rax
  imulq REGISTER_ADDRESS(RS2r)
  MOV_RDX_TO_RS2r
  POP_RD_IF_RDX
  POP_RD_IF_RAX
  WRITE_RD(RS2r)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_MULHSU:
  DECODE_R
  PUSH_RD_IF_RAX
  PUSH_RD_IF_RDX
  PUSH_RS1_IF_RAX
  PUSH_RS1_IF_RDX
  movq REGISTER_ADDRESS(RS1), %rax
  test %rax, %rax
  jns .mulhsu_branch1
  neg %rax
  mulq REGISTER_ADDRESS(RS2r)
  xor $-1, %rdx
  movq %rdx, TEMP1
  POP_RS1_IF_RDX
  POP_RS1_IF_RAX
  movq REGISTER_ADDRESS(RS1), %rax
  imulq REGISTER_ADDRESS(RS2r)
  test %rax, %rax
  setz %al
  movzbl %al, %eax
  addq %rax, TEMP1
  POP_RD_IF_RDX
  POP_RD_IF_RAX
  WRITE_RD(TEMP1)
  NEXT_INST
.mulhsu_branch1:
  mulq REGISTER_ADDRESS(RS2r)
  movq %rdx, TEMP1
  POP_RS1_IF_RDX
  POP_RS1_IF_RAX
  POP_RD_IF_RDX
  POP_RD_IF_RAX
  WRITE_RD(TEMP1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_MULHU:
  DECODE_R
  PUSH_RD_IF_RAX
  PUSH_RD_IF_RDX
  movq REGISTER_ADDRESS(RS1), %rax
  mulq REGISTER_ADDRESS(RS2r)
  movq %rdx, RS2r
  POP_RD_IF_RDX
  POP_RD_IF_RAX
  WRITE_RD(RS2r)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_MULW:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  imul RS2rd, RS1d
  movslq RS1d, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_OR:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  orq REGISTER_ADDRESS(RS2r), RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_ORI:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), RS1
  orq IMMEDIATE, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_REM:
  DECODE_R
  push RD
  movq $INT64_MIN, RD
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  cmp RD, RS1
  jne .rem_branch1
  cmp $-1, RS2r
  jne .rem_branch1
  xorq RS1, RS1
  jmp .rem_branch3
.rem_branch1:
  cmp $0, RS2r
  jne .rem_branch2
  jmp .rem_branch3
.rem_branch2:
  MOV_RS1_TO_RAX
  cqo
  idivq RS2r
  MOV_RDX_TO_RS1
.rem_branch3:
  pop RD
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_REMU:
  DECODE_R
  movq REGISTER_ADDRESS(RS2r), RS2r
  cmp $0, RS2r
  jne .remu_branch2
  movq REGISTER_ADDRESS(RS1), RS1
  WRITE_RD(RS1)
  NEXT_INST
.remu_branch2:
  PUSH_RD_IF_RAX
  PUSH_RD_IF_RDX
  movq REGISTER_ADDRESS(RS1), %rax
  xorq %rdx, %rdx
  divq RS2r
  mov %rdx, RS2r
  POP_RD_IF_RDX
  POP_RD_IF_RAX
  WRITE_RD(RS2r)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_REMUW:
  DECODE_R
  movq REGISTER_ADDRESS(RS2r), RS2r
  mov RS2rd, RS2rd
  cmp $0, RS2r
  jne .remuw_branch2
  movq REGISTER_ADDRESS(RS1), RS1
  movslq RS1d, RS1
  WRITE_RD(RS1)
  NEXT_INST
.remuw_branch2:
  PUSH_RD_IF_RAX
  PUSH_RD_IF_RDX
  movq REGISTER_ADDRESS(RS1), %rax
  mov %eax, %eax
  xorq %rdx, %rdx
  divq RS2r
  mov %rdx, RS2r
  POP_RD_IF_RDX
  POP_RD_IF_RAX
  movslq RS2rd, RS2r
  WRITE_RD(RS2r)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_REMW:
  DECODE_R
  push RD
  movq $INT64_MIN, RD
  movq REGISTER_ADDRESS(RS1), RS1
  movslq RS1d, RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  movslq RS2rd, RS2r
  cmp RD, RS1
  jne .remw_branch1
  cmp $-1, RS2r
  jne .remw_branch1
  xorq RS1, RS1
  jmp .remw_branch3
.remw_branch1:
  cmp $0, RS2r
  jne .remw_branch2
  jmp .remw_branch3
.remw_branch2:
  MOV_RS1_TO_RAX
  cqo
  idivq RS2r
  MOV_RDX_TO_RS1
.remw_branch3:
  pop RD
  movslq RS1d, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SB:
  DECODE_S
  movq REGISTER_ADDRESS(RS1), RS1
  addq IMMEDIATE, RS1
  CHECK_WRITE(RS1, RS2rd, 1)
  movq REGISTER_ADDRESS(RS2s), RS2s
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  mov RS2sb, (TEMP1, RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SD:
  DECODE_S
  movq REGISTER_ADDRESS(RS1), RS1
  addq IMMEDIATE, RS1
  CHECK_WRITE(RS1, RS2rd, 8)
  movq REGISTER_ADDRESS(RS2s), RS2s
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movq RS2s, (TEMP1, RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SH:
  DECODE_S
  movq REGISTER_ADDRESS(RS1), RS1
  addq IMMEDIATE, RS1
  CHECK_WRITE(RS1, RS2rd, 2)
  movq REGISTER_ADDRESS(RS2s), RS2s
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  mov RS2sh, (TEMP1, RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SLL:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), TEMP1
  movq REGISTER_ADDRESS(RS2r), %rcx
  shl %cl, TEMP1
  WRITE_RD(TEMP1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SLLI:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), TEMP1
  MOV_IMM_TO_RCX
  shl %cl, TEMP1
  WRITE_RD(TEMP1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SLLIW:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), TEMP1
  MOV_IMM_TO_RCX
  shl %cl, TEMP1
  movslq TEMP1d, TEMP1
  WRITE_RD(TEMP1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SLLW:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), TEMP1
  movq REGISTER_ADDRESS(RS2r), %rcx
  and $0x1F, %ecx
  shl %cl, TEMP1
  movslq TEMP1d, TEMP1
  WRITE_RD(TEMP1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SLT:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  cmpq RS2r, RS1
  setl RS1b
  movzbl RS1b, RS1d
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SLTI:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), RS1
  cmpq IMMEDIATE, RS1
  setl RS1b
  movzbl RS1b, RS1d
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SLTIU:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), RS1
  cmpq IMMEDIATE, RS1
  setb RS1b
  movzbl RS1b, RS1d
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SLTU:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  cmpq RS2r, RS1
  setb RS1b
  movzbl RS1b, RS1d
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SRA:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), TEMP1
  movq REGISTER_ADDRESS(RS2r), %rcx
  sar %cl, TEMP1
  WRITE_RD(TEMP1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SRAI:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), TEMP1
  MOV_IMM_TO_RCX
  sar %cl, TEMP1
  WRITE_RD(TEMP1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SRAIW:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), TEMP1
  MOV_IMM_TO_RCX
  sar %cl, TEMP1d
  movslq TEMP1d, TEMP1
  WRITE_RD(TEMP1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SRAW:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), TEMP1
  movq REGISTER_ADDRESS(RS2r), %rcx
  and $0x1F, %ecx
  sar %cl, TEMP1d
  movslq TEMP1d, TEMP1
  WRITE_RD(TEMP1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SRL:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), TEMP1
  movq REGISTER_ADDRESS(RS2r), %rcx
  shr %cl, TEMP1
  WRITE_RD(TEMP1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SRLI:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), TEMP1
  MOV_IMM_TO_RCX
  shr %cl, TEMP1
  WRITE_RD(TEMP1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SRLIW:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), TEMP1
  MOV_IMM_TO_RCX
  shr %cl, TEMP1d
  movslq TEMP1d, TEMP1
  WRITE_RD(TEMP1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SRLW:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), TEMP1
  movq REGISTER_ADDRESS(RS2r), %rcx
  and $0x1F, %ecx
  shr %cl, TEMP1d
  movslq TEMP1d, TEMP1
  WRITE_RD(TEMP1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SUB:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  subq REGISTER_ADDRESS(RS2r), RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SUBW:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  subq REGISTER_ADDRESS(RS2r), RS1
  movslq RS1d, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SW:
  DECODE_S
  movq REGISTER_ADDRESS(RS1), RS1
  addq IMMEDIATE, RS1
  CHECK_WRITE(RS1, RS2rd, 4)
  movq REGISTER_ADDRESS(RS2s), RS2s
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  mov RS2sd, (TEMP1, RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_XOR:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  xorq REGISTER_ADDRESS(RS2r), RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_XORI:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), RS1
  xorq IMMEDIATE, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_LR_W:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  CHECK_READ_VERSION1(RS1, 4)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movslq (TEMP1, RS1), TEMP2
  WRITE_RD(TEMP2)
  movq RS1, LOAD_RESERVATION_ADDRESS
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SC_W:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  CHECK_WRITE(RS1, RS3d, 4)
  movq LOAD_RESERVATION_ADDRESS, TEMP1
  movq $UINT64_MAX, LOAD_RESERVATION_ADDRESS
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP2
  cmp RS1, TEMP1
  cmovne (TEMP2, RS1), RS2rd
  mov RS2rd, (TEMP2, RS1)
  setnz TEMP1b
  movzx TEMP1b, TEMP1
  WRITE_RD(TEMP1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_AMOSWAP_W:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  CHECK_WRITE(RS1, RS3d, 4)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movslq (TEMP1, RS1), TEMP2
  WRITE_RD(TEMP2)
  mov RS2rd, (TEMP1, RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_AMOADD_W:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  CHECK_WRITE(RS1, RS3d, 4)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movslq (TEMP1, RS1), TEMP2
  WRITE_RD(TEMP2)
  add TEMP2, RS2r
  mov RS2rd, (TEMP1, RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_AMOXOR_W:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  CHECK_WRITE(RS1, RS3d, 4)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movslq (TEMP1, RS1), TEMP2
  WRITE_RD(TEMP2)
  xor TEMP2, RS2r
  mov RS2rd, (TEMP1, RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_AMOAND_W:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  CHECK_WRITE(RS1, RS3d, 4)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movslq (TEMP1, RS1), TEMP2
  WRITE_RD(TEMP2)
  and TEMP2, RS2r
  mov RS2rd, (TEMP1, RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_AMOOR_W:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  CHECK_WRITE(RS1, RS3d, 4)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movslq (TEMP1, RS1), TEMP2
  WRITE_RD(TEMP2)
  or TEMP2, RS2r
  mov RS2rd, (TEMP1, RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_AMOMIN_W:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  CHECK_WRITE(RS1, RS3d, 4)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movslq (TEMP1, RS1), TEMP2
  WRITE_RD(TEMP2)
  cmp RS2rd, TEMP2d
  cmovle TEMP2d, RS2rd
  mov RS2rd, (TEMP1, RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_AMOMAX_W:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  CHECK_WRITE(RS1, RS3d, 4)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movslq (TEMP1, RS1), TEMP2
  WRITE_RD(TEMP2)
  cmp RS2rd, TEMP2d
  cmovge TEMP2d, RS2rd
  mov RS2rd, (TEMP1, RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_AMOMINU_W:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  CHECK_WRITE(RS1, RS3d, 4)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movslq (TEMP1, RS1), TEMP2
  WRITE_RD(TEMP2)
  cmp RS2rd, TEMP2d
  cmovbe TEMP2d, RS2rd
  mov RS2rd, (TEMP1, RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_AMOMAXU_W:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  CHECK_WRITE(RS1, RS3d, 4)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movslq (TEMP1, RS1), TEMP2
  WRITE_RD(TEMP2)
  cmp RS2rd, TEMP2d
  cmovae TEMP2d, RS2rd
  mov RS2rd, (TEMP1, RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_LR_D:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  CHECK_READ_VERSION1(RS1, 8)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movq (TEMP1, RS1), TEMP2
  movq RS1, LOAD_RESERVATION_ADDRESS
  WRITE_RD(TEMP2)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SC_D:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  CHECK_WRITE(RS1, RS3d, 8)
  movq LOAD_RESERVATION_ADDRESS, TEMP1
  movq $UINT64_MAX, LOAD_RESERVATION_ADDRESS
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP2
  cmp RS1, TEMP1
  cmovne (TEMP2, RS1), RS2r
  movq RS2r, (TEMP2, RS1)
  setnz TEMP1b
  movzx TEMP1b, TEMP1
  WRITE_RD(TEMP1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_AMOSWAP_D:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  CHECK_WRITE(RS1, RS3d, 8)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movq (TEMP1, RS1), TEMP2
  WRITE_RD(TEMP2)
  movq RS2r, (TEMP1, RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_AMOADD_D:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  CHECK_WRITE(RS1, RS3d, 8)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movq (TEMP1, RS1), TEMP2
  WRITE_RD(TEMP2)
  add TEMP2, RS2r
  movq RS2r, (TEMP1, RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_AMOXOR_D:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  CHECK_WRITE(RS1, RS3d, 8)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movq (TEMP1, RS1), TEMP2
  WRITE_RD(TEMP2)
  xor TEMP2, RS2r
  movq RS2r, (TEMP1, RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_AMOAND_D:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  CHECK_WRITE(RS1, RS3d, 8)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movq (TEMP1, RS1), TEMP2
  WRITE_RD(TEMP2)
  and TEMP2, RS2r
  movq RS2r, (TEMP1, RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_AMOOR_D:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  CHECK_WRITE(RS1, RS3d, 8)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movq (TEMP1, RS1), TEMP2
  WRITE_RD(TEMP2)
  or TEMP2, RS2r
  movq RS2r, (TEMP1, RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_AMOMIN_D:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  CHECK_WRITE(RS1, RS3d, 8)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movq (TEMP1, RS1), TEMP2
  WRITE_RD(TEMP2)
  cmp RS2r, TEMP2
  cmovle TEMP2, RS2r
  movq RS2r, (TEMP1, RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_AMOMAX_D:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  CHECK_WRITE(RS1, RS3d, 8)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movq (TEMP1, RS1), TEMP2
  WRITE_RD(TEMP2)
  cmp RS2r, TEMP2
  cmovge TEMP2, RS2r
  movq RS2r, (TEMP1, RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_AMOMINU_D:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  CHECK_WRITE(RS1, RS3d, 8)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movq (TEMP1, RS1), TEMP2
  WRITE_RD(TEMP2)
  cmp RS2r, TEMP2
  cmovbe TEMP2, RS2r
  movq RS2r, (TEMP1, RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_AMOMAXU_D:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  CHECK_WRITE(RS1, RS3d, 8)
  movq CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_MEMORY_PTR(MACHINE), TEMP1
  movq (TEMP1, RS1), TEMP2
  WRITE_RD(TEMP2)
  cmp RS2r, TEMP2
  cmovae TEMP2, RS2r
  movq RS2r, (TEMP1, RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_ADDUW:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  mov RS1d, RS1d
  addq RS2r, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_ANDN:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  not RS2r
  and RS2r, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_BCLR:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), %rcx
  movq $1, TEMP1
  shl %cl, TEMP1
  not TEMP1
  and TEMP1, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_BCLRI:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), RS1
  MOV_IMM_TO_RCX
  movq $1, TEMP1
  shl %cl, TEMP1
  not TEMP1
  and TEMP1, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_BEXT:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), %rcx
  shr %cl, RS1
  and $1, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_BEXTI:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), RS1
  MOV_IMM_TO_RCX
  shr %cl, RS1
  and $1, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_BINV:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), %rcx
  movq $1, TEMP1
  shl %cl, TEMP1
  xor TEMP1, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_BINVI:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), RS1
  MOV_IMM_TO_RCX
  movq $1, TEMP1
  shl %cl, TEMP1
  xor TEMP1, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_BSET:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), %rcx
  movq $1, TEMP1
  shl %cl, TEMP1
  or TEMP1, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_BSETI:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), RS1
  MOV_IMM_TO_RCX
  movq $1, TEMP1
  shl %cl, TEMP1
  or TEMP1, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_CLMUL:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  xor %ecx, %ecx
  xor TEMP3, TEMP3
.clmul_branch:
  movq RS1, TEMP1
  movq RS2r, TEMP2
  shl %cl, TEMP1
  shr %cl, TEMP2
  xor TEMP3, TEMP1
  and $1, TEMP2
  cmovne TEMP1, TEMP3
  add $1, %rcx
  cmp $64, %rcx
  jne .clmul_branch
  WRITE_RD(TEMP3)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_CLMULH:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  movq $1, RS3
  xor TEMP3, TEMP3
.clmulh_branch:
  movq RS1, TEMP1
  movq RS2r, TEMP2
  movq $64, %rcx
  subq RS3, %rcx
  shr %cl, TEMP1
  movq RS3, %rcx
  shr %cl, TEMP2
  xor TEMP3, TEMP1
  and $1, TEMP2
  cmovne TEMP1, TEMP3
  add $1, RS3
  cmp $64, RS3
  jne .clmulh_branch
  WRITE_RD(TEMP3)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_CLMULR:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  xor RS3, RS3
  xor TEMP3, TEMP3
.clmulr_branch:
  movq RS1, TEMP1
  movq RS2r, TEMP2
  movq $63, %rcx
  subq RS3, %rcx
  shr %cl, TEMP1
  movq RS3, %rcx
  shr %cl, TEMP2
  xor TEMP3, TEMP1
  and $1, TEMP2
  cmovne TEMP1, TEMP3
  add $1, RS3
  cmp $64, RS3
  jne .clmulr_branch
  WRITE_RD(TEMP3)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_CLZ:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  cmp $0, RS1
  je .clz_branch
  bsr RS1, RS1
  neg RS1
  addq $63, RS1
  WRITE_RD(RS1)
  NEXT_INST
.clz_branch:
  WRITE_RD($64)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_CLZW:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  cmp $0, RS1d
  je .clzw_branch
  bsr RS1d, RS1d
  neg RS1
  addq $31, RS1
  WRITE_RD(RS1)
  NEXT_INST
.clzw_branch:
  WRITE_RD($32)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_CPOP:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  /* Since we only plan to use SSE2, the popcnt instruction cannot be used.
   * As an alternative, a soft-popcnt is given below, which is described in
   * Hacker's delight Chapter 5, Counting Bits.
   *
   * int popcnt64(uint64_t x)
   * {
   *   x = x - (x >> 1) & 0x5555555555555555;
   *   x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333);
   *   x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f;
   *   x = x + (x >> 8);
   *   x = x + (x >> 16);
   *   x = x + (x >> 32);
   *   return x & 0x7f;
   * }
   */
  movq RS1, RS2r
  shr $1, RS2r
  movabs $0x5555555555555555, TEMP1
  and TEMP1, RS2r
  sub RS2r, RS1
  movq RS1, RS2r
  movabs $0x3333333333333333, TEMP1
  and TEMP1, RS2r
  shr $2, RS1
  and TEMP1, RS1
  add RS2r, RS1
  movq RS1, RS2r
  shr $4, RS2r
  add RS2r, RS1
  movabs $0x0f0f0f0f0f0f0f0f, TEMP1
  and TEMP1, RS1
  movq RS1, RS2r
  shr $8, RS2r
  add RS2r, RS1
  movq RS1, RS2r
  shr $16, RS2r
  add RS2r, RS1
  movq RS1, RS2r
  shr $32, RS2r
  add RS2r, RS1
  and $0x7f, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_CPOPW:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  /*
   * int popcnt32(uint32_t x) {
   *   x = x - ((x >> 1) & 0x55555555);
   *   x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
   *   x = (x + (x >> 4)) & 0x0f0f0f0f;
   *   x = x + (x >> 8);
   *   x = x + (x >> 16);
   *   return x & 0x3f;
   * }
   */
  mov RS1d, RS2rd
  shr $1, RS2rd
  and $0x55555555, RS2rd
  sub RS2rd, RS1d
  mov RS1d, RS2rd
  and $0x33333333, RS2rd
  shr $2, RS1d
  and $0x33333333, RS1d
  add RS2rd, RS1d
  mov RS1d, RS2rd
  shr $4, RS2rd
  add RS2rd, RS1d
  and $0x0f0f0f0f, RS1d
  mov RS1d, RS2rd
  shr $8, RS2rd
  add RS2rd, RS1d
  mov RS1d, RS2rd
  shr $16, RS2rd
  add RS2rd, RS1d
  and $0x3f, RS1d
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_CTZ:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  cmp $0, RS1
  je .ctz_branch
  bsf RS1, RS1
  WRITE_RD(RS1)
  NEXT_INST
.ctz_branch:
  WRITE_RD($64)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_CTZW:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  cmp $0, RS1d
  je .ctzw_branch
  bsf RS1d, RS1d
  WRITE_RD(RS1)
  NEXT_INST
.ctzw_branch:
  WRITE_RD($32)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_MAX:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  cmp RS1, RS2r
  cmovge RS2r, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_MAXU:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  cmp RS1, RS2r
  cmovae RS2r, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_MIN:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  cmp RS1, RS2r
  cmovle RS2r, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_MINU:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  cmp RS1, RS2r
  cmovbe RS2r, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_ORCB:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  xor RS2r, RS2r
  movq $0x00000000000000ff, TEMP1
  movq TEMP1, TEMP2
  andq RS1, TEMP1
  je .orcb_branch1
  orq TEMP2, RS2r
.orcb_branch1:
  movq $0x000000000000ff00, TEMP1
  movq TEMP1, TEMP2
  andq RS1, TEMP1
  je .orcb_branch2
  orq TEMP2, RS2r
.orcb_branch2:
  movq $0x0000000000ff0000, TEMP1
  movq TEMP1, TEMP2
  andq RS1, TEMP1
  je .orcb_branch3
  orq TEMP2, RS2r
.orcb_branch3:
  movq $0x00000000ff000000, TEMP1
  movq TEMP1, TEMP2
  andq RS1, TEMP1
  je .orcb_branch4
  orq TEMP2, RS2r
.orcb_branch4:
  movq $0x000000ff00000000, TEMP1
  movq TEMP1, TEMP2
  andq RS1, TEMP1
  je .orcb_branch5
  orq TEMP2, RS2r
.orcb_branch5:
  movq $0x0000ff0000000000, TEMP1
  movq TEMP1, TEMP2
  andq RS1, TEMP1
  je .orcb_branch6
  orq TEMP2, RS2r
.orcb_branch6:
  movq $0x00ff000000000000, TEMP1
  movq TEMP1, TEMP2
  andq RS1, TEMP1
  je .orcb_branch7
  orq TEMP2, RS2r
.orcb_branch7:
  movq $0xff00000000000000, TEMP1
  movq TEMP1, TEMP2
  andq RS1, TEMP1
  je .orcb_branch8
  orq TEMP2, RS2r
.orcb_branch8:
  WRITE_RD(RS2r)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_ORN:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  not RS2r
  or RS2r, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_REV8:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  xorq RS2r, RS2r
  movq $0x00000000000000ff, TEMP1
  andq RS1, TEMP1
  shl $56, TEMP1
  orq TEMP1, RS2r
  movq $0x000000000000ff00, TEMP1
  andq RS1, TEMP1
  shl $40, TEMP1
  orq TEMP1, RS2r
  movq $0x0000000000ff0000, TEMP1
  andq RS1, TEMP1
  shl $24, TEMP1
  orq TEMP1, RS2r
  movq $0x00000000ff000000, TEMP1
  andq RS1, TEMP1
  shl $8, TEMP1
  orq TEMP1, RS2r
  movq $0x000000ff00000000, TEMP1
  andq RS1, TEMP1
  shr $8, TEMP1
  orq TEMP1, RS2r
  movq $0x0000ff0000000000, TEMP1
  andq RS1, TEMP1
  shr $24, TEMP1
  orq TEMP1, RS2r
  movq $0x00ff000000000000, TEMP1
  andq RS1, TEMP1
  shr $40, TEMP1
  orq TEMP1, RS2r
  movq $0xff00000000000000, TEMP1
  andq RS1, TEMP1
  shr $56, TEMP1
  orq TEMP1, RS2r
  WRITE_RD(RS2r)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_ROL:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), %rcx
  rol %cl, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_ROLW:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), %rcx
  rol %cl, RS1d
  movslq RS1d, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_ROR:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  movb RS2rb, %cl
  ror %cl, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_RORI:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), RS1
  ror IMMEDIATEb, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_RORIW:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), RS1
  ror IMMEDIATEb, RS1d
  movslq RS1d, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_RORW:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), %rcx
  ror %cl, RS1d
  movslq RS1d, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SEXTB:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movsx RS1b, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SEXTH:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movsx RS1h, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SH1ADD:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  shl $1, RS1
  add RS2r, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SH1ADDUW:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  mov RS1d, RS1d
  shl $1, RS1
  add RS2r, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SH2ADD:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  shl $2, RS1
  add RS2r, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SH2ADDUW:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  mov RS1d, RS1d
  shl $2, RS1
  add RS2r, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SH3ADD:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  shl $3, RS1
  add RS2r, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SH3ADDUW:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  mov RS1d, RS1d
  shl $3, RS1
  add RS2r, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SLLIUW:
  DECODE_I
  movq REGISTER_ADDRESS(RS1), RS1
  MOV_IMM_TO_RCX
  mov RS1d, RS1d
  and $0x3f, %cl
  shl %cl, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_XNOR:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  not RS2r
  xor RS2r, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_ZEXTH:
  DECODE_R
  movq REGISTER_ADDRESS(RS1), RS1
  shl $16, RS1d
  shr $16, RS1d
  movslq RS1d, RS1
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_FAR_JUMP_ABS:
  DECODE_U
  movq IMMEDIATE, RS2r
  movq PC_ADDRESS, TEMP1
  movq TEMP1, RA_ADDRESS
  andq $-2, RS2r
  movq RS2r, PC_ADDRESS
  jmp .prepare_trace
.p2align 3
.CKB_VM_ASM_LABEL_OP_FAR_JUMP_REL:
  DECODE_U
  movq PC_ADDRESS, RS2r
  /* Loading flag of current instruction */
  movq -16(INST_ARGS), TEMP3
  sar $24, TEMP3
  andq $0xF, TEMP3
  shl $1, TEMP3
  subq TEMP3, RS2r
  addq IMMEDIATE, RS2r
  movq PC_ADDRESS, TEMP1
  movq TEMP1, RA_ADDRESS
  andq $-2, RS2r
  movq RS2r, PC_ADDRESS
  jmp .prepare_trace
.p2align 3
.CKB_VM_ASM_LABEL_OP_WIDE_MUL:
  DECODE_R4
  PUSH_RD_IF_RAX
  PUSH_RD_IF_RDX
  movq REGISTER_ADDRESS(RS1), %rax
  imulq REGISTER_ADDRESS(RS2r)
  MOV_RDX_TO_RS2r
  movq %rax, TEMP1
  POP_RD_IF_RDX
  POP_RD_IF_RAX
  WRITE_RS3(TEMP1)
  WRITE_RD(RS2r)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_WIDE_MULU:
  DECODE_R4
  PUSH_RD_IF_RAX
  PUSH_RD_IF_RDX
  movq REGISTER_ADDRESS(RS1), %rax
  mulq REGISTER_ADDRESS(RS2r)
  MOV_RDX_TO_RS2r
  movq %rax, TEMP1
  POP_RD_IF_RDX
  POP_RD_IF_RAX
  WRITE_RS3(TEMP1)
  WRITE_RD(RS2r)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_WIDE_MULSU:
  DECODE_R4
  PUSH_RD_IF_RAX
  PUSH_RD_IF_RDX
  PUSH_RS1_IF_RAX
  PUSH_RS1_IF_RDX
  movq REGISTER_ADDRESS(RS1), %rax
  test %rax, %rax
  jns .wide_mulsu_branch1
  neg %rax
  mulq REGISTER_ADDRESS(RS2r)
  xor $-1, %rdx
  movq %rdx, TEMP1
  POP_RS1_IF_RDX
  POP_RS1_IF_RAX
  movq REGISTER_ADDRESS(RS1), %rax
  imulq REGISTER_ADDRESS(RS2r)
  movq %rax, TEMP2
  test %rax, %rax
  setz %al
  movzbl %al, %eax
  addq %rax, TEMP1
  POP_RD_IF_RDX
  POP_RD_IF_RAX
  WRITE_RS3(TEMP2)
  WRITE_RD(TEMP1)
  NEXT_INST
.wide_mulsu_branch1:
  mulq REGISTER_ADDRESS(RS2r)
  MOV_RDX_TO_RS2r
  movq %rax, TEMP1
  POP_RS1_IF_RDX
  POP_RS1_IF_RAX
  POP_RD_IF_RDX
  POP_RD_IF_RAX
  WRITE_RS3(TEMP1)
  WRITE_RD(RS2r)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_WIDE_DIV:
  DECODE_R4
  push RD
  movq $INT64_MIN, RD
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  cmp RD, RS1
  jne .wide_div_branch1
  cmp $-1, RS2r
  jne .wide_div_branch1
  xorq TEMP1, TEMP1
  jmp .wide_div_branch3
.wide_div_branch1:
  cmp $0, RS2r
  jne .wide_div_branch2
  movq RS1, TEMP1
  movq $UINT64_MAX, RS1
  jmp .wide_div_branch3
.wide_div_branch2:
  MOV_RS1_TO_RAX
  cqo
  idivq RS2r
  mov %rdx, TEMP1
  MOV_RAX_TO_RS1
.wide_div_branch3:
  pop RD
  WRITE_RS3(TEMP1)
  WRITE_RD(RS1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_WIDE_DIVU:
  DECODE_R4
  movq REGISTER_ADDRESS(RS1), RS1
  movq REGISTER_ADDRESS(RS2r), RS2r
  cmp $0, RS2r
  jne .wide_divu_branch1
  WRITE_RS3(RS1)
  WRITE_RD_VALUE($UINT64_MAX, RS2r)
  NEXT_INST
.wide_divu_branch1:
  PUSH_RD_IF_RAX
  PUSH_RD_IF_RDX
  movq RS1, %rax
  xorq %rdx, %rdx
  divq RS2r
  mov %rax, TEMP1
  MOV_RDX_TO_RS2r
  POP_RD_IF_RDX
  POP_RD_IF_RAX
  WRITE_RS3(RS2r)
  WRITE_RD(TEMP1)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_ADC:
  DECODE_R
  xor TEMP1, TEMP1
  xor TEMP2, TEMP2
  movq REGISTER_ADDRESS(RD), %rcx
  addq REGISTER_ADDRESS(RS1), %rcx
  adc $0, TEMP1
  addq REGISTER_ADDRESS(RS2r), %rcx
  adc $0, TEMP2
  orq TEMP2, TEMP1
  WRITE_RS1(TEMP1)
  WRITE_RS2r(TEMP2)
  WRITE_RD(%rcx)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_SBB:
  DECODE_R4
  xor TEMP1, TEMP1
  xor TEMP2, TEMP2
  movq REGISTER_ADDRESS(RD), %rcx
  subq REGISTER_ADDRESS(RS1), %rcx
  adc $0, TEMP1
  subq REGISTER_ADDRESS(RS2r), %rcx
  adc $0, TEMP2
  WRITE_RS2r(TEMP2)
  WRITE_RS3(TEMP1)
  orq TEMP2, TEMP1
  WRITE_RS1(TEMP1)
  WRITE_RD(%rcx)
  NEXT_INST
.p2align 3
.CKB_VM_ASM_LABEL_OP_ADCS:
  DECODE_R4
  xor TEMP1, TEMP1
  movq REGISTER_ADDRESS(RS1), %rcx
  addq REGISTER_ADDRESS(RS2r), %rcx
  adc $0, TEMP1
  WRITE_RD_V2(%rcx)
  WRITE_RS3(TEMP1)
  NEXT_INST_V2
.p2align 3
.CKB_VM_ASM_LABEL_OP_SBBS:
  DECODE_R4
  xor TEMP1, TEMP1
  movq REGISTER_ADDRESS(RS1), %rcx
  subq REGISTER_ADDRESS(RS2r), %rcx
  adc $0, TEMP1
  WRITE_RD_V2(%rcx)
  WRITE_RS3(TEMP1)
  NEXT_INST_V2
.p2align 3
.CKB_VM_ASM_LABEL_OP_ADD3A:
  DECODE_R5
  xor TEMP2, TEMP2
  movq REGISTER_ADDRESS(RD), %rcx
  addq REGISTER_ADDRESS(RS1), %rcx
  adc $0, TEMP2
  movq TEMP2, TEMP3
  addq REGISTER_ADDRESS(RS4_TEMP1), TEMP3
  WRITE_RD_V2(%rcx)
  WRITE_RS2r(TEMP2)
  WRITE_RS3(TEMP3)
  NEXT_INST_V2
.p2align 3
.CKB_VM_ASM_LABEL_OP_ADD3B:
  DECODE_R5
  xor TEMP2, TEMP2
  movq REGISTER_ADDRESS(RS1), %rcx
  addq REGISTER_ADDRESS(RS2r), %rcx
  adc $0, TEMP2
  movq TEMP2, TEMP3
  addq REGISTER_ADDRESS(RS4_TEMP1), TEMP3
  WRITE_RD_V2(%rcx)
  WRITE_RS1(TEMP2)
  WRITE_RS3(TEMP3)
  NEXT_INST_V2
.p2align 3
.CKB_VM_ASM_LABEL_OP_ADD3C:
  DECODE_R5
  xor TEMP3, TEMP3
  movq REGISTER_ADDRESS(RS1), %rcx
  addq REGISTER_ADDRESS(RS2r), %rcx
  adcq REGISTER_ADDRESS(RS4_TEMP1), TEMP3
  WRITE_RD_V2(%rcx)
  WRITE_RS3(TEMP3)
  NEXT_INST_V2
.p2align 3
.exit_out_of_bound:
  mov TEMP3, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_ERROR_ARG0(MACHINE)
  mov $CKB_VM_ASM_RET_OUT_OF_BOUND, ARG_RETd
  jmp .exit
.p2align 3
.exit_max_cycles_exceeded:
  mov $CKB_VM_ASM_RET_MAX_CYCLES_EXCEEDED, ARG_RETd
  jmp .exit
.p2align 3
.exit_cycles_overflow:
  mov $CKB_VM_ASM_RET_CYCLES_OVERFLOW, ARG_RETd
  jmp .exit
.p2align 3
.exit_invalid_permission:
  mov TEMP1, CKB_VM_ASM_ASM_CORE_MACHINE_OFFSET_ERROR_ARG0(MACHINE)
  mov $CKB_VM_ASM_RET_INVALID_PERMISSION, ARG_RETd
  jmp .exit
/*
 * Some instructions that are difficult to implement will be interpreted and
 * executed by the rust interpreter
 */
.p2align 3
.exit_slowpath:
  mov $CKB_VM_ASM_RET_SLOWPATH, ARG_RETd
  jmp .exit
.p2align 3
.exit_pause:
  mov $CKB_VM_ASM_RET_PAUSE, ARG_RETd
  jmp .exit
.p2align 3
.exit_trace:
.CKB_VM_ASM_LABEL_OP_UNLOADED:
  DECODE_U
  mov $CKB_VM_ASM_RET_DECODE_TRACE, ARG_RETd
  jmp .exit
.exit:
  pop %r14
  pop %r13
  pop %r12
  pop %rbx
  pop %rbp
#ifdef IS_WINDOWS
  pop %rdi
  pop %rsi
#endif
  retq


================================================
File: src/machine/asm/mod.rs
================================================
pub mod traces;

use byteorder::{ByteOrder, LittleEndian};
use bytes::Bytes;
pub use ckb_vm_definitions::asm::AsmCoreMachine;
use ckb_vm_definitions::{
    asm::{
        FixedTrace, InvokeData, RET_CYCLES_OVERFLOW, RET_DECODE_TRACE, RET_DYNAMIC_JUMP,
        RET_EBREAK, RET_ECALL, RET_INVALID_PERMISSION, RET_MAX_CYCLES_EXCEEDED, RET_OUT_OF_BOUND,
        RET_PAUSE, RET_SLOWPATH,
    },
    ISA_MOP, MEMORY_FRAME_PAGE_SHIFTS, RISCV_GENERAL_REGISTER_NUMBER, RISCV_PAGE_SHIFTS,
};
use rand::{prelude::RngCore, SeedableRng};
use std::os::raw::c_uchar;

use crate::{
    decoder::{build_decoder, InstDecoder},
    elf::ProgramMetadata,
    error::OutOfBoundKind,
    instructions::execute_instruction,
    machine::{
        asm::traces::{decode_fixed_trace, SimpleFixedTraceDecoder, TraceDecoder},
        VERSION0,
    },
    memory::{
        check_no_overflow, fill_page_data, get_page_indices, memset, round_page_down,
        round_page_up, FLAG_DIRTY, FLAG_EXECUTABLE, FLAG_FREEZED, FLAG_WRITABLE, FLAG_WXORX_BIT,
    },
    CoreMachine, DefaultMachine, Error, Machine, Memory, SupportMachine, MEMORY_FRAME_SHIFTS,
    RISCV_PAGESIZE,
};

impl CoreMachine for Box<AsmCoreMachine> {
    type REG = u64;
    type MEM = Self;

    fn pc(&self) -> &Self::REG {
        &self.pc
    }

    fn update_pc(&mut self, pc: Self::REG) {
        self.next_pc = pc;
    }

    fn commit_pc(&mut self) {
        self.pc = self.next_pc;
    }

    fn memory(&self) -> &Self {
        self
    }

    fn memory_mut(&mut self) -> &mut Self {
        self
    }

    fn registers(&self) -> &[Self::REG] {
        &self.registers
    }

    fn set_register(&mut self, idx: usize, value: Self::REG) {
        self.registers[idx] = value;
    }

    fn isa(&self) -> u8 {
        self.isa
    }

    fn version(&self) -> u32 {
        self.version
    }
}

// This function is exported for asm and aot machine.
// Note that the parameter `machine` is after parameter `frame_index`. Generally
// speaking, put `machine` in the first parameter is more human readable,
// but consider that in the asm machine, `frame_index` is stored in `rdi` and `machine`
// is stored in `rsi`, there is no need to exchange the values in the two registers
// in this way.
#[no_mangle]
pub extern "C" fn inited_memory(frame_index: u64, machine: &mut AsmCoreMachine) {
    let addr_from = (frame_index << MEMORY_FRAME_SHIFTS) as usize;
    let slice = cast_ptr_to_slice_mut(
        machine,
        machine.memory_ptr,
        addr_from,
        1 << MEMORY_FRAME_SHIFTS,
    );
    if machine.chaos_mode != 0 {
        let mut gen = rand::rngs::StdRng::seed_from_u64(machine.chaos_seed.into());
        gen.fill_bytes(slice);
        machine.chaos_seed = gen.next_u32();
    } else {
        memset(slice, 0);
    }
}

fn check_memory(machine: &mut AsmCoreMachine, page: u64) {
    let frame_index = page >> MEMORY_FRAME_PAGE_SHIFTS;
    unsafe {
        let frames = machine.frames_ptr as *mut u8;
        let frame_addr = frames.add(frame_index as usize);
        let frame_flag = frame_addr.read();
        if frame_flag == 0 {
            inited_memory(frame_index, machine);
            frame_addr.write(0x01);
        }
    }
}

fn check_permission<M: Memory>(memory: &mut M, page: u64, flag: u8) -> Result<(), Error> {
    let page_flag = memory.fetch_flag(page)?;
    if (page_flag & FLAG_WXORX_BIT) != (flag & FLAG_WXORX_BIT) {
        return Err(Error::MemWriteOnExecutablePage(page));
    }
    Ok(())
}

// check whether a memory address is writable or not and mark it as dirty, `size` should be 1, 2, 4 or 8
fn check_memory_writable(
    machine: &mut Box<AsmCoreMachine>,
    addr: u64,
    size: usize,
) -> Result<(), Error> {
    debug_assert!(size == 1 || size == 2 || size == 4 || size == 8);
    let page = addr >> RISCV_PAGE_SHIFTS;
    if page as usize >= machine.memory_pages() {
        return Err(Error::MemOutOfBound(addr, OutOfBoundKind::Memory));
    }
    check_permission(machine, page, FLAG_WRITABLE)?;
    check_memory(machine, page);
    machine.set_flag(page, FLAG_DIRTY)?;

    // check next page if necessary
    let page_offset = addr as usize % RISCV_PAGESIZE;
    if page_offset + size > RISCV_PAGESIZE {
        let page = page + 1;
        if page as usize >= machine.memory_pages() {
            return Err(Error::MemOutOfBound(
                addr.wrapping_add(size as u64),
                OutOfBoundKind::Memory,
            ));
        } else {
            check_permission(machine, page, FLAG_WRITABLE)?;
            check_memory(machine, page);
            machine.set_flag(page, FLAG_DIRTY)?
        }
    }
    Ok(())
}

// check whether a memory address is executable, `size` should be 2 or 4
fn check_memory_executable(
    machine: &mut Box<AsmCoreMachine>,
    addr: u64,
    size: usize,
) -> Result<(), Error> {
    debug_assert!(size == 2 || size == 4);

    let page = addr >> RISCV_PAGE_SHIFTS;
    if page as usize >= machine.memory_pages() {
        return Err(Error::MemOutOfBound(addr, OutOfBoundKind::Memory));
    }
    check_permission(machine, page, FLAG_EXECUTABLE)?;
    check_memory(machine, page);

    // check next page if necessary
    let page_offset = addr as usize % RISCV_PAGESIZE;
    if page_offset + size > RISCV_PAGESIZE {
        let page = page + 1;
        if page as usize >= machine.memory_pages() {
            return Err(Error::MemOutOfBound(
                addr.wrapping_add(size as u64),
                OutOfBoundKind::Memory,
            ));
        } else {
            check_permission(machine, page, FLAG_EXECUTABLE)?;
            check_memory(machine, page);
        }
    }
    Ok(())
}

// check whether a memory address is initialized, `size` should be 1, 2, 4 or 8
fn check_memory_inited(
    machine: &mut Box<AsmCoreMachine>,
    addr: u64,
    size: usize,
) -> Result<(), Error> {
    debug_assert!(size == 1 || size == 2 || size == 4 || size == 8);
    let page = addr >> RISCV_PAGE_SHIFTS;
    if page as usize >= machine.memory_pages() {
        return Err(Error::MemOutOfBound(addr, OutOfBoundKind::Memory));
    }
    check_memory(machine, page);

    // check next page if necessary
    let page_offset = addr as usize % RISCV_PAGESIZE;
    if page_offset + size > RISCV_PAGESIZE {
        let page = page + 1;
        if page as usize >= machine.memory_pages() {
            return Err(Error::MemOutOfBound(
                addr.wrapping_add(size as u64),
                OutOfBoundKind::Memory,
            ));
        } else {
            check_memory(machine, page);
        }
    }
    Ok(())
}

// A newtype supporting fast store_byte / store_bytes without memory
// permission checking
struct FastMemory<'a>(&'a mut Box<AsmCoreMachine>);

impl<'a> FastMemory<'a> {
    fn prepare_memory(&mut self, addr: u64, size: u64) -> Result<(), Error> {
        check_no_overflow(addr, size, self.0.memory_size)?;
        let frame_start = addr >> MEMORY_FRAME_SHIFTS << MEMORY_FRAME_SHIFTS;
        // There is some memory space between the start of the first memory
        // frame touched, and the starting address of memory to be written. We
        // will need to initialize the last memory frame.
        if frame_start < addr {
            check_memory(self.0, addr >> RISCV_PAGE_SHIFTS);
        }
        let end = addr.wrapping_add(size);
        if end > 0 {
            let aligned_end = round_page_down(end);
            // Note that end is exclusive
            let frame_next_start = (((end - 1) >> MEMORY_FRAME_SHIFTS) + 1) << MEMORY_FRAME_SHIFTS;
            // There is some memory space between the ending address of memory to be
            // written, and the end of the last memory frame touched, we will need to
            // initialize the last memory frame.
            if (aligned_end + RISCV_PAGESIZE as u64) < frame_next_start {
                check_memory(self.0, aligned_end >> RISCV_PAGE_SHIFTS);
            }
        }
        let page_indices = get_page_indices(addr, size);
        for page in page_indices.0..=page_indices.1 {
            let frame_index = page >> MEMORY_FRAME_PAGE_SHIFTS;
            let slice = cast_ptr_to_slice_mut(self.0, self.0.frames_ptr, frame_index as usize, 1);
            slice[0] = 1;
            self.0.set_flag(page, FLAG_DIRTY)?;
        }
        Ok(())
    }
}

impl<'a> Memory for FastMemory<'a> {
    type REG = u64;

    fn store_bytes(&mut self, addr: u64, value: &[u8]) -> Result<(), Error> {
        if value.is_empty() {
            return Ok(());
        }
        self.prepare_memory(addr, value.len() as u64)?;
        let slice = cast_ptr_to_slice_mut(self.0, self.0.memory_ptr, addr as usize, value.len());
        slice.copy_from_slice(value);
        Ok(())
    }

    fn store_byte(&mut self, addr: u64, size: u64, value: u8) -> Result<(), Error> {
        if size == 0 {
            return Ok(());
        }
        self.prepare_memory(addr, size)?;
        let slice = cast_ptr_to_slice_mut(self.0, self.0.memory_ptr, addr as usize, size as usize);
        memset(slice, value);
        Ok(())
    }

    fn reset_memory(&mut self) -> Result<(), Error> {
        unreachable!()
    }

    fn init_pages(
        &mut self,
        _addr: u64,
        _size: u64,
        _flags: u8,
        _source: Option<Bytes>,
        _offset_from_addr: u64,
    ) -> Result<(), Error> {
        unreachable!()
    }

    fn fetch_flag(&mut self, _page: u64) -> Result<u8, Error> {
        unreachable!()
    }

    fn set_flag(&mut self, _page: u64, _flag: u8) -> Result<(), Error> {
        unreachable!()
    }

    fn clear_flag(&mut self, _page: u64, _flag: u8) -> Result<(), Error> {
        unreachable!()
    }

    fn memory_size(&self) -> usize {
        unreachable!()
    }

    fn load_bytes(&mut self, _addr: u64, _size: u64) -> Result<Bytes, Error> {
        unreachable!()
    }

    fn execute_load16(&mut self, _addr: u64) -> Result<u16, Error> {
        unreachable!()
    }

    fn execute_load32(&mut self, _addr: u64) -> Result<u32, Error> {
        unreachable!()
    }

    fn load8(&mut self, _addr: &Self::REG) -> Result<Self::REG, Error> {
        unreachable!()
    }

    fn load16(&mut self, _addr: &Self::REG) -> Result<Self::REG, Error> {
        unreachable!()
    }

    fn load32(&mut self, _addr: &Self::REG) -> Result<Self::REG, Error> {
        unreachable!()
    }

    fn load64(&mut self, _addr: &Self::REG) -> Result<Self::REG, Error> {
        unreachable!()
    }

    fn store8(&mut self, _addr: &Self::REG, _value: &Self::REG) -> Result<(), Error> {
        unreachable!()
    }

    fn store16(&mut self, _addr: &Self::REG, _value: &Self::REG) -> Result<(), Error> {
        unreachable!()
    }

    fn store32(&mut self, _addr: &Self::REG, _value: &Self::REG) -> Result<(), Error> {
        unreachable!()
    }

    fn store64(&mut self, _addr: &Self::REG, _value: &Self::REG) -> Result<(), Error> {
        unreachable!()
    }

    fn lr(&self) -> &Self::REG {
        unreachable!()
    }

    fn set_lr(&mut self, _value: &Self::REG) {
        unreachable!()
    }
}

impl Memory for Box<AsmCoreMachine> {
    type REG = u64;

    fn reset_memory(&mut self) -> Result<(), Error> {
        let slice = cast_ptr_to_slice_mut(self, self.flags_ptr, 0, self.flags_size as usize);
        memset(slice, 0);
        let slice = cast_ptr_to_slice_mut(self, self.frames_ptr, 0, self.frames_size as usize);
        memset(slice, 0);
        self.load_reservation_address = u64::MAX;
        self.last_read_frame = u64::MAX;
        self.last_write_page = u64::MAX;
        Ok(())
    }

    fn init_pages(
        &mut self,
        addr: u64,
        size: u64,
        flags: u8,
        source: Option<Bytes>,
        offset_from_addr: u64,
    ) -> Result<(), Error> {
        if round_page_down(addr) != addr {
            return Err(Error::MemPageUnalignedAccess(addr));
        }
        if round_page_up(size) != size {
            return Err(Error::MemPageUnalignedAccess(addr.wrapping_add(size)));
        }

        if addr > self.memory_size() as u64 {
            return Err(Error::MemOutOfBound(addr, OutOfBoundKind::Memory));
        }
        if size > self.memory_size() as u64 || addr + size > self.memory_size() as u64 {
            return Err(Error::MemOutOfBound(
                addr.wrapping_add(size),
                OutOfBoundKind::Memory,
            ));
        }
        if offset_from_addr > size {
            return Err(Error::MemOutOfBound(
                offset_from_addr,
                OutOfBoundKind::ExternalData,
            ));
        }

        // We benchmarked the code piece here, using while loop this way is
        // actually faster than a for..in solution. The difference is roughly
        // 3% so we are keeping this version.
        let mut current_addr = addr;
        while current_addr < addr + size {
            let page = current_addr / RISCV_PAGESIZE as u64;
            if self.fetch_flag(page)? & FLAG_FREEZED != 0 {
                return Err(Error::MemWriteOnFreezedPage(page));
            }
            current_addr += RISCV_PAGESIZE as u64;
        }
        fill_page_data(&mut FastMemory(self), addr, size, source, offset_from_addr)?;
        current_addr = addr;
        while current_addr < addr + size {
            let page = current_addr / RISCV_PAGESIZE as u64;
            self.set_flag(page, flags)?;
            current_addr += RISCV_PAGESIZE as u64;
        }
        // Clear last read/write page cache
        self.last_read_frame = u64::MAX;
        self.last_write_page = u64::MAX;
        Ok(())
    }

    fn fetch_flag(&mut self, page: u64) -> Result<u8, Error> {
        if page < self.memory_pages() as u64 {
            let slice = cast_ptr_to_slice(self, self.flags_ptr, page as usize, 1);
            Ok(slice[0])
        } else {
            Err(Error::MemOutOfBound(
                page << RISCV_PAGE_SHIFTS,
                OutOfBoundKind::Memory,
            ))
        }
    }

    fn set_flag(&mut self, page: u64, flag: u8) -> Result<(), Error> {
        if page < self.memory_pages() as u64 {
            let slice = cast_ptr_to_slice_mut(self, self.flags_ptr, page as usize, 1);
            slice[0] |= flag;
            // Clear last write page cache
            self.last_write_page = u64::MAX;
            Ok(())
        } else {
            Err(Error::MemOutOfBound(
                page << RISCV_PAGE_SHIFTS,
                OutOfBoundKind::Memory,
            ))
        }
    }

    fn clear_flag(&mut self, page: u64, flag: u8) -> Result<(), Error> {
        if page < self.memory_pages() as u64 {
            let slice = cast_ptr_to_slice_mut(self, self.flags_ptr, page as usize, 1);
            slice[0] &= !flag;
            // Clear last write page cache
            self.last_write_page = u64::MAX;
            Ok(())
        } else {
            Err(Error::MemOutOfBound(
                page << RISCV_PAGE_SHIFTS,
                OutOfBoundKind::Memory,
            ))
        }
    }

    fn memory_size(&self) -> usize {
        self.memory_size as usize
    }

    fn store_bytes(&mut self, addr: u64, value: &[u8]) -> Result<(), Error> {
        if value.is_empty() {
            return Ok(());
        }
        check_no_overflow(addr, value.len() as u64, self.memory_size)?;
        let page_indices = get_page_indices(addr, value.len() as u64);
        for page in page_indices.0..=page_indices.1 {
            check_permission(self, page, FLAG_WRITABLE)?;
            check_memory(self, page);
            self.set_flag(page, FLAG_DIRTY)?;
        }
        let slice = cast_ptr_to_slice_mut(self, self.memory_ptr, addr as usize, value.len());
        slice.copy_from_slice(value);
        Ok(())
    }

    fn store_byte(&mut self, addr: u64, size: u64, value: u8) -> Result<(), Error> {
        if size == 0 {
            return Ok(());
        }
        check_no_overflow(addr, size, self.memory_size)?;
        let page_indices = get_page_indices(addr, size);
        for page in page_indices.0..=page_indices.1 {
            check_permission(self, page, FLAG_WRITABLE)?;
            check_memory(self, page);
            self.set_flag(page, FLAG_DIRTY)?;
        }
        let slice = cast_ptr_to_slice_mut(self, self.memory_ptr, addr as usize, size as usize);
        memset(slice, value);
        Ok(())
    }

    fn load_bytes(&mut self, addr: u64, size: u64) -> Result<Bytes, Error> {
        if size == 0 {
            return Ok(Bytes::new());
        }
        check_no_overflow(addr, size, self.memory_size)?;
        let page_indices = get_page_indices(addr, size);
        for page in page_indices.0..=page_indices.1 {
            check_memory(self, page);
        }
        let slice = unsafe {
            let memory = self.memory_ptr as *mut u8;
            let memory_from = memory.add(addr as usize);
            std::slice::from_raw_parts(memory_from, size as usize)
        };
        Ok(Bytes::from(slice))
    }

    fn execute_load16(&mut self, addr: u64) -> Result<u16, Error> {
        check_memory_executable(self, addr, 2)?;
        let slice = cast_ptr_to_slice(self, self.memory_ptr, addr as usize, 2);
        Ok(LittleEndian::read_u16(slice))
    }

    fn execute_load32(&mut self, addr: u64) -> Result<u32, Error> {
        check_memory_executable(self, addr, 4)?;
        let slice = cast_ptr_to_slice(self, self.memory_ptr, addr as usize, 4);
        Ok(LittleEndian::read_u32(slice))
    }

    fn load8(&mut self, addr: &u64) -> Result<u64, Error> {
        let addr = *addr;
        check_memory_inited(self, addr, 1)?;
        let slice = cast_ptr_to_slice(self, self.memory_ptr, addr as usize, 1);
        Ok(u64::from(slice[0]))
    }

    fn load16(&mut self, addr: &u64) -> Result<u64, Error> {
        let addr = *addr;
        check_memory_inited(self, addr, 2)?;
        let slice = cast_ptr_to_slice(self, self.memory_ptr, addr as usize, 2);
        Ok(u64::from(LittleEndian::read_u16(slice)))
    }

    fn load32(&mut self, addr: &u64) -> Result<u64, Error> {
        let addr = *addr;
        check_memory_inited(self, addr, 4)?;
        let slice = cast_ptr_to_slice(self, self.memory_ptr, addr as usize, 4);
        Ok(u64::from(LittleEndian::read_u32(slice)))
    }

    fn load64(&mut self, addr: &u64) -> Result<u64, Error> {
        let addr = *addr;
        check_memory_inited(self, addr, 8)?;
        let slice = cast_ptr_to_slice(self, self.memory_ptr, addr as usize, 8);
        Ok(LittleEndian::read_u64(slice))
    }

    fn store8(&mut self, addr: &u64, value: &u64) -> Result<(), Error> {
        let addr = *addr;
        check_memory_writable(self, addr, 1)?;
        let slice = cast_ptr_to_slice_mut(self, self.memory_ptr, addr as usize, 1);
        slice[0] = *value as u8;
        Ok(())
    }

    fn store16(&mut self, addr: &u64, value: &u64) -> Result<(), Error> {
        let addr = *addr;
        check_memory_writable(self, addr, 2)?;
        let slice = cast_ptr_to_slice_mut(self, self.memory_ptr, addr as usize, 2);
        LittleEndian::write_u16(slice, *value as u16);
        Ok(())
    }

    fn store32(&mut self, addr: &u64, value: &u64) -> Result<(), Error> {
        let addr = *addr;
        check_memory_writable(self, addr, 4)?;
        let slice = cast_ptr_to_slice_mut(self, self.memory_ptr, addr as usize, 4);
        LittleEndian::write_u32(slice, *value as u32);
        Ok(())
    }

    fn store64(&mut self, addr: &u64, value: &u64) -> Result<(), Error> {
        let addr = *addr;
        check_memory_writable(self, addr, 8)?;
        let slice = cast_ptr_to_slice_mut(self, self.memory_ptr, addr as usize, 8);
        LittleEndian::write_u64(slice, *value as u64);
        Ok(())
    }

    fn lr(&self) -> &Self::REG {
        &self.load_reservation_address
    }

    fn set_lr(&mut self, value: &Self::REG) {
        self.load_reservation_address = *value;
    }
}

impl SupportMachine for Box<AsmCoreMachine> {
    fn cycles(&self) -> u64 {
        self.cycles
    }

    fn set_cycles(&mut self, cycles: u64) {
        self.cycles = cycles;
    }

    fn max_cycles(&self) -> u64 {
        self.max_cycles
    }

    fn set_max_cycles(&mut self, max_cycles: u64) {
        self.max_cycles = max_cycles;
    }

    fn reset(&mut self, max_cycles: u64) -> Result<(), Error> {
        self.registers = [0; RISCV_GENERAL_REGISTER_NUMBER];
        self.pc = 0;
        self.cycles = 0;
        self.max_cycles = max_cycles;
        self.reset_signal = 1;
        self.reset_memory()
    }

    fn reset_signal(&mut self) -> bool {
        let ret = self.reset_signal != 0;
        self.reset_signal = 0;
        ret
    }

    fn running(&self) -> bool {
        self.running == 1
    }

    fn set_running(&mut self, running: bool) {
        self.running = if running { 1 } else { 0 }
    }

    #[cfg(feature = "pprof")]
    fn code(&self) -> &Bytes {
        unreachable!()
    }
}

extern "C" {
    pub fn ckb_vm_x64_execute(m: *mut AsmCoreMachine, d: *const InvokeData) -> c_uchar;
    // We are keeping this as a function here, but at the bottom level this really
    // just points to an array of assembly label offsets for each opcode.
    pub fn ckb_vm_asm_labels();
}

pub struct AsmMachine {
    pub machine: DefaultMachine<Box<AsmCoreMachine>>,
}

impl AsmMachine {
    pub fn new(machine: DefaultMachine<Box<AsmCoreMachine>>) -> Self {
        Self { machine }
    }

    pub fn set_max_cycles(&mut self, cycles: u64) {
        self.machine.inner.max_cycles = cycles;
    }

    pub fn load_program(
        &mut self,
        program: &Bytes,
        args: impl ExactSizeIterator<Item = Result<Bytes, Error>>,
    ) -> Result<u64, Error> {
        self.machine.load_program(program, args)
    }

    pub fn load_program_with_metadata(
        &mut self,
        program: &Bytes,
        metadata: &ProgramMetadata,
        args: impl ExactSizeIterator<Item = Result<Bytes, Error>>,
    ) -> Result<u64, Error> {
        self.machine
            .load_program_with_metadata(program, metadata, args)
    }

    pub fn run(&mut self) -> Result<i8, Error> {
        let decoder = build_decoder::<u64>(self.machine.isa(), self.machine.version());
        let mut decoder = SimpleFixedTraceDecoder::new(decoder);
        self.run_with_decoder(&mut decoder)
    }

    pub fn run_with_decoder<D: TraceDecoder>(&mut self, decoder: &mut D) -> Result<i8, Error> {
        if self.machine.isa() & ISA_MOP != 0 && self.machine.version() == VERSION0 {
            return Err(Error::InvalidVersion);
        }
        self.machine.set_running(true);
        while self.machine.running() {
            if self.machine.reset_signal() {
                decoder.reset()?;
            }
            debug_assert!(decoder.fixed_trace_size().is_power_of_two());
            let result = unsafe {
                let data = InvokeData {
                    pause: self.machine.pause.get_raw_ptr(),
                    fixed_traces: decoder.fixed_traces(),
                    fixed_trace_mask: decoder.fixed_trace_size().wrapping_sub(1),
                };
                ckb_vm_x64_execute(&mut **self.machine.inner_mut(), &data as *const _)
            };
            match result {
                RET_DECODE_TRACE => decoder.prepare_traces(&mut self.machine)?,
                RET_ECALL => self.machine.ecall()?,
                RET_EBREAK => self.machine.ebreak()?,
                RET_DYNAMIC_JUMP => (),
                RET_MAX_CYCLES_EXCEEDED => return Err(Error::CyclesExceeded),
                RET_CYCLES_OVERFLOW => return Err(Error::CyclesOverflow),
                RET_OUT_OF_BOUND => {
                    return Err(Error::MemOutOfBound(
                        self.machine.inner.error_arg0,
                        OutOfBoundKind::Memory,
                    ))
                }
                RET_INVALID_PERMISSION => {
                    return Err(Error::MemWriteOnExecutablePage(
                        self.machine.inner.error_arg0,
                    ))
                }
                RET_SLOWPATH => {
                    let pc = *self.machine.pc() - 4;
                    let instruction = decoder.decode(self.machine.memory_mut(), pc)?;
                    execute_instruction(instruction, &mut self.machine)?;
                }
                RET_PAUSE => {
                    self.machine.pause.free();
                    return Err(Error::Pause);
                }
                _ => return Err(Error::Asm(result)),
            }
        }
        Ok(self.machine.exit_code())
    }

    pub fn step<D: InstDecoder>(&mut self, decoder: &mut D) -> Result<(), Error> {
        // Decode only one instruction into a trace
        let (trace, _) = decode_fixed_trace(decoder, &mut self.machine, Some(1))?;

        let result = unsafe {
            let data = InvokeData {
                pause: self.machine.pause.get_raw_ptr(),
                fixed_traces: &trace as *const FixedTrace,
                fixed_trace_mask: 0,
            };
            ckb_vm_x64_execute(&mut **self.machine.inner_mut(), &data as *const _)
        };
        match result {
            RET_DECODE_TRACE => (),
            RET_ECALL => self.machine.ecall()?,
            RET_EBREAK => self.machine.ebreak()?,
            RET_MAX_CYCLES_EXCEEDED => return Err(Error::CyclesExceeded),
            RET_OUT_OF_BOUND => {
                return Err(Error::MemOutOfBound(
                    self.machine.inner.error_arg0,
                    OutOfBoundKind::Memory,
                ))
            }
            RET_INVALID_PERMISSION => {
                return Err(Error::MemWriteOnExecutablePage(
                    self.machine.inner.error_arg0,
                ))
            }
            RET_SLOWPATH => {
                let pc = *self.machine.pc() - 4;
                let instruction = decoder.decode(self.machine.memory_mut(), pc)?;
                execute_instruction(instruction, &mut self.machine)?;
            }
            _ => return Err(Error::Asm(result)),
        }
        Ok(())
    }
}

// Casts a raw pointer with an offset and size to a byte slice.
// We need machine here for the lifetime.
fn cast_ptr_to_slice(_machine: &AsmCoreMachine, ptr: u64, offset: usize, size: usize) -> &[u8] {
    unsafe {
        let ptr = ptr as *const u8;
        let ptr = ptr.add(offset);
        std::slice::from_raw_parts(ptr, size)
    }
}

// Provides similar functionality to `cast_ptr_to_slice` but returns mut slice.
fn cast_ptr_to_slice_mut(
    _machine: &AsmCoreMachine,
    ptr: u64,
    offset: usize,
    size: usize,
) -> &mut [u8] {
    unsafe {
        let ptr = ptr as *mut u8;
        let ptr = ptr.add(offset);
        std::slice::from_raw_parts_mut(ptr, size)
    }
}

#[cfg(test)]
mod tests {
    use ckb_vm_definitions::asm::TRACE_ITEM_LENGTH;

    #[test]
    fn test_asm_constant_rules() {
        assert!(TRACE_ITEM_LENGTH * 4 < 256);
    }
}


================================================
File: src/machine/asm/traces.rs
================================================
use crate::{
    ckb_vm_definitions::{
        asm::{calculate_slot, FixedTrace, TRACE_ITEM_LENGTH, TRACE_SIZE},
        instructions::{
            Instruction, InstructionOpcode, OP_CUSTOM_ASM_TRACE_JUMP, OP_CUSTOM_TRACE_END,
        },
    },
    decoder::InstDecoder,
    error::Error,
    instructions::{
        blank_instruction, extract_opcode, instruction_length, is_basic_block_end_instruction,
        is_slowpath_instruction,
    },
    machine::{
        asm::{ckb_vm_asm_labels, AsmCoreMachine},
        CoreMachine, DefaultMachine,
    },
    memory::Memory,
};
use std::alloc::{alloc, alloc_zeroed, Layout};
use std::collections::HashMap;

pub trait TraceDecoder: InstDecoder {
    fn fixed_traces(&self) -> *const FixedTrace;
    fn fixed_trace_size(&self) -> u64;
    fn prepare_traces(
        &mut self,
        machine: &mut DefaultMachine<Box<AsmCoreMachine>>,
    ) -> Result<(), Error>;
    fn reset(&mut self) -> Result<(), Error>;
}

pub fn label_from_fastpath_opcode(opcode: InstructionOpcode) -> u64 {
    debug_assert!(!is_slowpath_instruction(blank_instruction(opcode)));
    unsafe {
        u64::from(*(ckb_vm_asm_labels as *const u32).offset(opcode as u8 as isize))
            + (ckb_vm_asm_labels as *const u32 as u64)
    }
}

pub fn decode_fixed_trace<D: InstDecoder>(
    decoder: &mut D,
    machine: &mut DefaultMachine<Box<AsmCoreMachine>>,
    maximum_insts: Option<usize>,
) -> Result<(FixedTrace, usize), Error> {
    let pc = *machine.pc();

    let mut trace = FixedTrace::default();
    let mut current_pc = pc;
    let mut i = 0;

    let size = match maximum_insts {
        Some(items) => std::cmp::min(items, TRACE_ITEM_LENGTH),
        None => TRACE_ITEM_LENGTH,
    };
    while i < size {
        let instruction = decoder.decode(machine.memory_mut(), current_pc)?;
        let end_instruction = is_basic_block_end_instruction(instruction);
        current_pc += u64::from(instruction_length(instruction));
        trace.cycles += machine.instruction_cycle_func()(instruction);
        let opcode = extract_opcode(instruction);
        // Here we are calculating the absolute address used in direct threading
        // from label offsets.
        trace.set_thread(i, instruction, label_from_fastpath_opcode(opcode));
        i += 1;
        if end_instruction {
            break;
        }
    }
    trace.set_thread(
        i,
        blank_instruction(OP_CUSTOM_TRACE_END),
        label_from_fastpath_opcode(OP_CUSTOM_TRACE_END),
    );
    i += 1;
    trace.address = pc;
    trace.length = (current_pc - pc) as u32;
    Ok((trace, i))
}

/// A simple and naive trace decoder that only works with 8192 fixed traces.
/// It serves as the default implementation.
pub struct SimpleFixedTraceDecoder<D: InstDecoder> {
    traces: Box<[FixedTrace; TRACE_SIZE]>,
    decoder: D,
}

impl<D: InstDecoder> SimpleFixedTraceDecoder<D> {
    pub fn new(decoder: D) -> Self {
        let traces = unsafe {
            let layout = Layout::array::<FixedTrace>(TRACE_SIZE).unwrap();
            let raw_allocation = alloc_zeroed(layout) as *mut _;
            Box::from_raw(raw_allocation)
        };
        Self { decoder, traces }
    }

    pub fn clear_traces(&mut self) {
        for i in 0..TRACE_SIZE {
            self.traces[i] = FixedTrace::default();
        }
    }
}

impl<D: InstDecoder> TraceDecoder for SimpleFixedTraceDecoder<D> {
    fn fixed_traces(&self) -> *const FixedTrace {
        self.traces.as_ptr()
    }

    fn fixed_trace_size(&self) -> u64 {
        TRACE_SIZE as u64
    }

    fn prepare_traces(
        &mut self,
        machine: &mut DefaultMachine<Box<AsmCoreMachine>>,
    ) -> Result<(), Error> {
        let (trace, _) = decode_fixed_trace(&mut self.decoder, machine, None)?;
        let slot = calculate_slot(*machine.pc());
        self.traces[slot] = trace;
        Ok(())
    }

    fn reset(&mut self) -> Result<(), Error> {
        self.clear_traces();
        self.decoder.reset_instructions_cache()
    }
}

impl<D: InstDecoder> InstDecoder for SimpleFixedTraceDecoder<D> {
    fn decode<M: Memory>(&mut self, memory: &mut M, pc: u64) -> Result<Instruction, Error> {
        self.decoder.decode(memory, pc)
    }

    fn reset_instructions_cache(&mut self) -> Result<(), Error> {
        self.decoder.reset_instructions_cache()
    }
}

/// A fixed trace decoder that memorizes all traces after the initial decoding
pub struct MemoizedFixedTraceDecoder<D: InstDecoder> {
    inner: SimpleFixedTraceDecoder<D>,
    cache: HashMap<u64, FixedTrace>,
}

impl<D: InstDecoder> MemoizedFixedTraceDecoder<D> {
    pub fn new(decoder: D) -> Self {
        Self {
            inner: SimpleFixedTraceDecoder::new(decoder),
            cache: HashMap::default(),
        }
    }

    pub fn clear_traces(&mut self) {
        self.inner.clear_traces();
    }
}

impl<D: InstDecoder> TraceDecoder for MemoizedFixedTraceDecoder<D> {
    fn fixed_traces(&self) -> *const FixedTrace {
        self.inner.fixed_traces()
    }

    fn fixed_trace_size(&self) -> u64 {
        self.inner.fixed_trace_size()
    }

    fn prepare_traces(
        &mut self,
        machine: &mut DefaultMachine<Box<AsmCoreMachine>>,
    ) -> Result<(), Error> {
        let pc = *machine.pc();
        let slot = calculate_slot(pc);
        let trace = match self.cache.get(&pc) {
            Some(trace) => trace.clone(),
            None => {
                let (trace, _) = decode_fixed_trace(&mut self.inner.decoder, machine, None)?;
                self.cache.insert(pc, trace.clone());
                trace
            }
        };
        self.inner.traces[slot] = trace;
        Ok(())
    }

    fn reset(&mut self) -> Result<(), Error> {
        self.cache.clear();
        self.inner.reset()
    }
}

impl<D: InstDecoder> InstDecoder for MemoizedFixedTraceDecoder<D> {
    fn decode<M: Memory>(&mut self, memory: &mut M, pc: u64) -> Result<Instruction, Error> {
        self.inner.decode(memory, pc)
    }

    fn reset_instructions_cache(&mut self) -> Result<(), Error> {
        self.inner.reset_instructions_cache()
    }
}

/// This is similar to FixedTrace, except that it uses a special pattern
/// named [flexible array member](https://en.wikipedia.org/wiki/Flexible_array_member).
/// The individual fields in this data structure, albeit similar to FixedTrace,
/// are marked as privates so one cannot directly instantiate a struct of
/// DynamicTrace. Instead, all constructions of DynamicTrace are done via
/// DynamicTraceBuilder, which builds `Box<DynamicTrace>`. This is due to the
/// reasons that we might have a variable number of `threads` allocated at the
/// end of this data structure. So on the surface, it might appear that a
/// struct of DynamicTrace is 24 bytes. In reality it is bigger than this:
/// a struct of DynamicTrace containing 30 opcodes could be
/// 24 + 30 * 16 + 16 = 520 bytes long(the final 16 bytes are for OP_CUSTOM_TRACE_END).
/// Using `Box<DynamicTrace>`, together with `DynamicTraceBuilder`, helps us to
/// abstract this details away when we are constructing the types. The underlying
/// assembly code cannot tell the difference between DynamicTrace and FixedTrace.
#[repr(C)]
pub struct DynamicTrace {
    address: u64,
    length: u32,
    cycles: u64,
}

pub struct DynamicTraceBuilder {
    start_address: u64,
    length: u32,
    cycles: u64,
    insts: Vec<(Instruction, u64)>,
}

impl DynamicTraceBuilder {
    pub fn new(start_address: u64) -> Self {
        Self {
            start_address,
            length: 0,
            cycles: 0,
            insts: vec![],
        }
    }

    pub fn next_pc(&self) -> u64 {
        self.start_address + self.length as u64
    }

    pub fn push(&mut self, inst: Instruction, cycles: u64) {
        let opcode = extract_opcode(inst);
        // Here we are calculating the absolute address used in direct threading
        // from label offsets.
        let label = label_from_fastpath_opcode(opcode);
        self.length += u32::from(instruction_length(inst));
        self.cycles += cycles;
        self.insts.push((inst, label));
    }

    pub fn build(mut self) -> Box<DynamicTrace> {
        self.insts.push((
            blank_instruction(OP_CUSTOM_TRACE_END),
            label_from_fastpath_opcode(OP_CUSTOM_TRACE_END),
        ));
        let fixed_size = std::mem::size_of::<DynamicTrace>();
        let total_size = fixed_size + self.insts.len() * 16;
        let p = unsafe {
            let layout = Layout::array::<u8>(total_size).unwrap();
            alloc(layout)
        };
        let threads = unsafe { p.add(fixed_size) } as *mut u64;
        for (i, (inst, label)) in self.insts.iter().enumerate() {
            unsafe {
                threads.offset(i as isize * 2).write(*label);
                threads.offset(i as isize * 2 + 1).write(*inst);
            }
        }
        let mut trace = unsafe { Box::from_raw(p as *mut DynamicTrace) };
        trace.address = self.start_address;
        trace.length = self.length;
        trace.cycles = self.cycles;
        trace
    }
}

/// A memoized trace decoder that also generates DynamicTrace for longer
/// sequential code.
pub struct MemoizedDynamicTraceDecoder<D: InstDecoder> {
    inner: SimpleFixedTraceDecoder<D>,
    fixed_cache: HashMap<u64, FixedTrace>,
    dynamic_cache: HashMap<u64, Box<DynamicTrace>>,
}

impl<D: InstDecoder> MemoizedDynamicTraceDecoder<D> {
    pub fn new(decoder: D) -> Self {
        Self {
            inner: SimpleFixedTraceDecoder::new(decoder),
            fixed_cache: HashMap::default(),
            dynamic_cache: HashMap::default(),
        }
    }

    pub fn clear_traces(&mut self) {
        self.inner.clear_traces();
    }

    fn find_or_build_dynamic_trace(
        &mut self,
        pc: u64,
        machine: &mut DefaultMachine<Box<AsmCoreMachine>>,
    ) -> Result<*const DynamicTrace, Error> {
        if let Some(trace) = self.dynamic_cache.get(&pc) {
            return Ok(trace.as_ref() as *const DynamicTrace);
        }
        let mut builder = DynamicTraceBuilder::new(pc);
        loop {
            let instruction = self.decode(machine.memory_mut(), builder.next_pc())?;
            let end_instruction = is_basic_block_end_instruction(instruction);
            let cycles = machine.instruction_cycle_func()(instruction);
            builder.push(instruction, cycles);
            if end_instruction {
                break;
            }
        }
        let dynamic_trace = builder.build();
        let p = dynamic_trace.as_ref() as *const DynamicTrace;
        self.dynamic_cache.insert(pc, dynamic_trace);
        Ok(p)
    }
}

impl<D: InstDecoder> TraceDecoder for MemoizedDynamicTraceDecoder<D> {
    fn fixed_traces(&self) -> *const FixedTrace {
        self.inner.fixed_traces()
    }

    fn fixed_trace_size(&self) -> u64 {
        self.inner.fixed_trace_size()
    }

    fn prepare_traces(
        &mut self,
        machine: &mut DefaultMachine<Box<AsmCoreMachine>>,
    ) -> Result<(), Error> {
        let pc = *machine.pc();
        let slot = calculate_slot(pc);
        let trace = match self.fixed_cache.get(&pc) {
            Some(trace) => trace.clone(),
            None => {
                let (mut trace, count) =
                    decode_fixed_trace(&mut self.inner.decoder, machine, None)?;
                if let Some((inst, _)) = trace.thread(count.wrapping_sub(2)) {
                    if !is_basic_block_end_instruction(inst) {
                        // Decoded trace is not yet a full basic block, there
                        // are still sequential code left. We can build a dynamic
                        // trace here covering the remaining of the sequential code
                        // to speed up processing
                        let dynamic_trace =
                            self.find_or_build_dynamic_trace(pc + trace.length as u64, machine)?;
                        trace.set_thread(
                            count.wrapping_sub(1),
                            dynamic_trace as u64,
                            label_from_fastpath_opcode(OP_CUSTOM_ASM_TRACE_JUMP),
                        );
                    }
                }
                self.fixed_cache.insert(pc, trace.clone());
                trace
            }
        };
        self.inner.traces[slot] = trace;
        Ok(())
    }

    fn reset(&mut self) -> Result<(), Error> {
        self.fixed_cache.clear();
        self.dynamic_cache.clear();
        self.inner.reset()
    }
}

impl<D: InstDecoder> InstDecoder for MemoizedDynamicTraceDecoder<D> {
    fn decode<M: Memory>(&mut self, memory: &mut M, pc: u64) -> Result<Instruction, Error> {
        self.inner.decode(memory, pc)
    }

    fn reset_instructions_cache(&mut self) -> Result<(), Error> {
        self.inner.reset_instructions_cache()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::mem::{size_of, zeroed};

    #[test]
    fn test_dynamic_trace_has_the_same_layout_as_fixed_trace() {
        let f: FixedTrace = unsafe { zeroed() };
        let f_address = &f as *const FixedTrace as usize;

        let d: DynamicTrace = unsafe { zeroed() };
        let d_address = &d as *const DynamicTrace as usize;

        assert_eq!(
            (&f.address as *const _ as usize) - f_address,
            (&d.address as *const _ as usize) - d_address,
        );
        assert_eq!(
            (&f.length as *const _ as usize) - f_address,
            (&d.length as *const _ as usize) - d_address,
        );
        assert_eq!(
            (&f.cycles as *const _ as usize) - f_address,
            (&d.cycles as *const _ as usize) - d_address,
        );
        assert_eq!(
            (&f._threads as *const _ as usize) - f_address,
            size_of::<DynamicTrace>(),
        );
    }
}


================================================
File: src/memory/flat.rs
================================================
use super::super::{
    error::OutOfBoundKind, Error, Register, DEFAULT_MEMORY_SIZE, RISCV_PAGESIZE, RISCV_PAGE_SHIFTS,
};
use super::{check_no_overflow, fill_page_data, get_page_indices, memset, set_dirty, Memory};

use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};
use bytes::Bytes;
use std::io::{Cursor, Seek, SeekFrom};
use std::marker::PhantomData;
use std::ops::{Deref, DerefMut};

pub struct FlatMemory<R> {
    data: Vec<u8>,
    flags: Vec<u8>,
    memory_size: usize,
    riscv_pages: usize,
    load_reservation_address: R,
    _inner: PhantomData<R>,
}

impl<R> Deref for FlatMemory<R> {
    type Target = Vec<u8>;

    fn deref(&self) -> &Self::Target {
        &self.data
    }
}

impl<R> DerefMut for FlatMemory<R> {
    fn deref_mut(&mut self) -> &mut Vec<u8> {
        &mut self.data
    }
}

impl<R: Register> FlatMemory<R> {
    pub fn new_with_memory(memory_size: usize) -> Self {
        assert!(memory_size % RISCV_PAGESIZE == 0);
        Self {
            data: vec![0; memory_size],
            flags: vec![0; memory_size / RISCV_PAGESIZE],
            memory_size,
            riscv_pages: memory_size / RISCV_PAGESIZE,
            load_reservation_address: R::from_u64(u64::MAX),
            _inner: PhantomData,
        }
    }
}

impl<R: Register> Default for FlatMemory<R> {
    fn default() -> Self {
        Self::new_with_memory(DEFAULT_MEMORY_SIZE)
    }
}

/// A flat chunk of memory used for RISC-V machine, it lacks all the permission
/// checking logic.
impl<R: Register> Memory for FlatMemory<R> {
    type REG = R;

    fn reset_memory(&mut self) -> Result<(), Error> {
        memset(&mut self.data, 0);
        memset(&mut self.flags, 0);
        self.load_reservation_address = R::from_u64(u64::MAX);
        Ok(())
    }

    fn init_pages(
        &mut self,
        addr: u64,
        size: u64,
        _flags: u8,
        source: Option<Bytes>,
        offset_from_addr: u64,
    ) -> Result<(), Error> {
        fill_page_data(self, addr, size, source, offset_from_addr)
    }

    fn fetch_flag(&mut self, page: u64) -> Result<u8, Error> {
        if page < self.riscv_pages as u64 {
            Ok(self.flags[page as usize])
        } else {
            Err(Error::MemOutOfBound(
                page << RISCV_PAGE_SHIFTS,
                OutOfBoundKind::Memory,
            ))
        }
    }

    fn set_flag(&mut self, page: u64, flag: u8) -> Result<(), Error> {
        if page < self.riscv_pages as u64 {
            self.flags[page as usize] |= flag;
            Ok(())
        } else {
            Err(Error::MemOutOfBound(
                page << RISCV_PAGE_SHIFTS,
                OutOfBoundKind::Memory,
            ))
        }
    }

    fn clear_flag(&mut self, page: u64, flag: u8) -> Result<(), Error> {
        if page < self.riscv_pages as u64 {
            self.flags[page as usize] &= !flag;
            Ok(())
        } else {
            Err(Error::MemOutOfBound(
                page << RISCV_PAGE_SHIFTS,
                OutOfBoundKind::Memory,
            ))
        }
    }

    fn memory_size(&self) -> usize {
        self.memory_size
    }

    fn execute_load16(&mut self, addr: u64) -> Result<u16, Error> {
        self.load16(&Self::REG::from_u64(addr)).map(|v| v.to_u16())
    }

    fn execute_load32(&mut self, addr: u64) -> Result<u32, Error> {
        self.load32(&R::from_u64(addr)).map(|v| v.to_u32())
    }

    fn load8(&mut self, addr: &Self::REG) -> Result<Self::REG, Error> {
        let addr = addr.to_u64();
        check_no_overflow(addr, 1, self.memory_size as u64)?;
        let mut reader = Cursor::new(&self.data);
        reader.seek(SeekFrom::Start(addr as u64))?;
        let v = reader.read_u8()?;
        Ok(Self::REG::from_u8(v))
    }

    fn load16(&mut self, addr: &Self::REG) -> Result<Self::REG, Error> {
        let addr = addr.to_u64();
        check_no_overflow(addr, 2, self.memory_size as u64)?;
        let mut reader = Cursor::new(&self.data);
        reader.seek(SeekFrom::Start(addr as u64))?;
        // NOTE: Base RISC-V ISA is defined as a little-endian memory system.
        let v = reader.read_u16::<LittleEndian>()?;
        Ok(Self::REG::from_u16(v))
    }

    fn load32(&mut self, addr: &Self::REG) -> Result<Self::REG, Error> {
        let addr = addr.to_u64();
        check_no_overflow(addr, 4, self.memory_size as u64)?;
        let mut reader = Cursor::new(&self.data);
        reader.seek(SeekFrom::Start(addr as u64))?;
        // NOTE: Base RISC-V ISA is defined as a little-endian memory system.
        let v = reader.read_u32::<LittleEndian>()?;
        Ok(Self::REG::from_u32(v))
    }

    fn load64(&mut self, addr: &Self::REG) -> Result<Self::REG, Error> {
        let addr = addr.to_u64();
        check_no_overflow(addr, 8, self.memory_size as u64)?;
        let mut reader = Cursor::new(&self.data);
        reader.seek(SeekFrom::Start(addr as u64))?;
        // NOTE: Base RISC-V ISA is defined as a little-endian memory system.
        let v = reader.read_u64::<LittleEndian>()?;
        Ok(Self::REG::from_u64(v))
    }

    fn store8(&mut self, addr: &Self::REG, value: &Self::REG) -> Result<(), Error> {
        let addr = addr.to_u64();
        check_no_overflow(addr, 1, self.memory_size as u64)?;
        let page_indices = get_page_indices(addr, 1);
        set_dirty(self, &page_indices)?;
        let mut writer = Cursor::new(&mut self.data);
        writer.seek(SeekFrom::Start(addr as u64))?;
        writer.write_u8(value.to_u8())?;
        Ok(())
    }

    fn store16(&mut self, addr: &Self::REG, value: &Self::REG) -> Result<(), Error> {
        let addr = addr.to_u64();
        check_no_overflow(addr, 2, self.memory_size as u64)?;
        let page_indices = get_page_indices(addr, 2);
        set_dirty(self, &page_indices)?;
        let mut writer = Cursor::new(&mut self.data);
        writer.seek(SeekFrom::Start(addr as u64))?;
        writer.write_u16::<LittleEndian>(value.to_u16())?;
        Ok(())
    }

    fn store32(&mut self, addr: &Self::REG, value: &Self::REG) -> Result<(), Error> {
        let addr = addr.to_u64();
        check_no_overflow(addr, 4, self.memory_size as u64)?;
        let page_indices = get_page_indices(addr, 4);
        set_dirty(self, &page_indices)?;
        let mut writer = Cursor::new(&mut self.data);
        writer.seek(SeekFrom::Start(addr as u64))?;
        writer.write_u32::<LittleEndian>(value.to_u32())?;
        Ok(())
    }

    fn store64(&mut self, addr: &Self::REG, value: &Self::REG) -> Result<(), Error> {
        let addr = addr.to_u64();
        check_no_overflow(addr, 8, self.memory_size as u64)?;
        let page_indices = get_page_indices(addr, 8);
        set_dirty(self, &page_indices)?;
        let mut writer = Cursor::new(&mut self.data);
        writer.seek(SeekFrom::Start(addr as u64))?;
        writer.write_u64::<LittleEndian>(value.to_u64())?;
        Ok(())
    }

    fn store_bytes(&mut self, addr: u64, value: &[u8]) -> Result<(), Error> {
        let size = value.len() as u64;
        if size == 0 {
            return Ok(());
        }
        check_no_overflow(addr, size, self.memory_size as u64)?;
        let page_indices = get_page_indices(addr, size);
        set_dirty(self, &page_indices)?;
        let slice = &mut self[addr as usize..(addr + size) as usize];
        slice.copy_from_slice(value);
        Ok(())
    }

    fn store_byte(&mut self, addr: u64, size: u64, value: u8) -> Result<(), Error> {
        if size == 0 {
            return Ok(());
        }
        check_no_overflow(addr, size, self.memory_size as u64)?;
        let page_indices = get_page_indices(addr, size);
        set_dirty(self, &page_indices)?;
        memset(&mut self[addr as usize..(addr + size) as usize], value);
        Ok(())
    }

    fn load_bytes(&mut self, addr: u64, size: u64) -> Result<Bytes, Error> {
        if size == 0 {
            return Ok(Bytes::new());
        }
        check_no_overflow(addr, size, self.memory_size as u64)?;
        Ok(Bytes::from(
            self[addr as usize..(addr + size) as usize].to_vec(),
        ))
    }

    fn lr(&self) -> &Self::REG {
        &self.load_reservation_address
    }

    fn set_lr(&mut self, value: &Self::REG) {
        self.load_reservation_address = value.clone();
    }
}


================================================
File: src/memory/mod.rs
================================================
use super::{
    bits::{rounddown, roundup},
    error::OutOfBoundKind,
    Error, Register, RISCV_PAGESIZE,
};
use bytes::Bytes;
use std::cmp::min;
use std::ptr;

pub mod flat;
pub mod sparse;
pub mod wxorx;

pub use ckb_vm_definitions::{
    memory::{FLAG_DIRTY, FLAG_EXECUTABLE, FLAG_FREEZED, FLAG_WRITABLE, FLAG_WXORX_BIT},
    DEFAULT_MEMORY_SIZE, MEMORY_FRAME_PAGE_SHIFTS, RISCV_PAGE_SHIFTS,
};

#[inline(always)]
pub fn round_page_down(x: u64) -> u64 {
    rounddown(x, RISCV_PAGESIZE as u64)
}

#[inline(always)]
pub fn round_page_up(x: u64) -> u64 {
    roundup(x, RISCV_PAGESIZE as u64)
}

pub type Page = [u8; RISCV_PAGESIZE];

pub trait Memory {
    type REG: Register;

    fn reset_memory(&mut self) -> Result<(), Error>;

    fn init_pages(
        &mut self,
        addr: u64,
        size: u64,
        flags: u8,
        source: Option<Bytes>,
        offset_from_addr: u64,
    ) -> Result<(), Error>;
    fn fetch_flag(&mut self, page: u64) -> Result<u8, Error>;
    fn set_flag(&mut self, page: u64, flag: u8) -> Result<(), Error>;
    fn clear_flag(&mut self, page: u64, flag: u8) -> Result<(), Error>;
    fn memory_size(&self) -> usize;
    fn memory_pages(&self) -> usize {
        self.memory_size() >> RISCV_PAGE_SHIFTS
    }

    // This is in fact just memset
    fn store_byte(&mut self, addr: u64, size: u64, value: u8) -> Result<(), Error>;
    fn store_bytes(&mut self, addr: u64, value: &[u8]) -> Result<(), Error>;
    fn load_bytes(&mut self, addr: u64, size: u64) -> Result<Bytes, Error>;
    fn execute_load16(&mut self, addr: u64) -> Result<u16, Error>;
    fn execute_load32(&mut self, addr: u64) -> Result<u32, Error>;

    // Methods below are used to implement RISC-V instructions, to make JIT
    // possible, we need to use register type here so as to pass enough
    // information around.
    fn load8(&mut self, addr: &Self::REG) -> Result<Self::REG, Error>;
    fn load16(&mut self, addr: &Self::REG) -> Result<Self::REG, Error>;
    fn load32(&mut self, addr: &Self::REG) -> Result<Self::REG, Error>;
    fn load64(&mut self, addr: &Self::REG) -> Result<Self::REG, Error>;

    fn store8(&mut self, addr: &Self::REG, value: &Self::REG) -> Result<(), Error>;
    fn store16(&mut self, addr: &Self::REG, value: &Self::REG) -> Result<(), Error>;
    fn store32(&mut self, addr: &Self::REG, value: &Self::REG) -> Result<(), Error>;
    fn store64(&mut self, addr: &Self::REG, value: &Self::REG) -> Result<(), Error>;

    // Load reservation address for atomic extension.
    fn lr(&self) -> &Self::REG;
    fn set_lr(&mut self, value: &Self::REG);
}

#[inline(always)]
pub fn fill_page_data<M: Memory>(
    memory: &mut M,
    addr: u64,
    size: u64,
    source: Option<Bytes>,
    offset_from_addr: u64,
) -> Result<(), Error> {
    let mut written_size = 0;
    if offset_from_addr > 0 {
        let real_size = min(size, offset_from_addr);
        memory.store_byte(addr, real_size, 0)?;
        written_size += real_size;
    }
    if let Some(source) = source {
        let real_size = min(size - written_size, source.len() as u64);
        if real_size > 0 {
            memory.store_bytes(addr + written_size, &source[0..real_size as usize])?;
            written_size += real_size;
        }
    }
    if written_size < size {
        memory.store_byte(addr + written_size, size - written_size, 0)?;
    }
    Ok(())
}

pub fn check_no_overflow(addr: u64, size: u64, memory_size: u64) -> Result<(), Error> {
    if addr >= memory_size {
        return Err(Error::MemOutOfBound(addr, OutOfBoundKind::Memory));
    }
    let (addr_end, overflowed) = addr.overflowing_add(size);
    if overflowed || addr_end > memory_size {
        Err(Error::MemOutOfBound(addr_end, OutOfBoundKind::Memory))
    } else {
        Ok(())
    }
}

// `size` should be none zero u64
pub fn get_page_indices(addr: u64, size: u64) -> (u64, u64) {
    debug_assert!(size > 0);
    let addr_end = addr.wrapping_add(size);
    let page = addr >> RISCV_PAGE_SHIFTS;
    let page_end = (addr_end - 1) >> RISCV_PAGE_SHIFTS;
    (page, page_end)
}

pub fn check_permission<M: Memory>(
    memory: &mut M,
    page_indices: &(u64, u64),
    flag: u8,
) -> Result<(), Error> {
    for page in page_indices.0..=page_indices.1 {
        let page_flag = memory.fetch_flag(page)?;
        if (page_flag & FLAG_WXORX_BIT) != (flag & FLAG_WXORX_BIT) {
            return Err(Error::MemWriteOnExecutablePage(page));
        }
    }
    Ok(())
}

pub fn set_dirty<M: Memory>(memory: &mut M, page_indices: &(u64, u64)) -> Result<(), Error> {
    for page in page_indices.0..=page_indices.1 {
        memory.set_flag(page, FLAG_DIRTY)?
    }
    Ok(())
}

// Keep this in a central place to allow for future optimization
#[inline(always)]
pub(crate) fn memset(slice: &mut [u8], value: u8) {
    let p = slice.as_mut_ptr();
    unsafe {
        ptr::write_bytes(p, value, slice.len());
    }
}

pub fn load_c_string_byte_by_byte<M: Memory>(
    memory: &mut M,
    addr: &M::REG,
) -> Result<Bytes, Error> {
    let mut buffer = Vec::new();
    let mut addr = addr.clone();
    loop {
        let byte = memory.load8(&addr)?.to_u8();
        if byte == 0 {
            break;
        }
        buffer.push(byte);
        addr = addr.overflowing_add(&M::REG::from_u8(1));
    }
    Ok(Bytes::from(buffer))
}


================================================
File: src/memory/sparse.rs
================================================
use super::super::{
    error::OutOfBoundKind, Error, Register, DEFAULT_MEMORY_SIZE, RISCV_PAGESIZE, RISCV_PAGE_SHIFTS,
};
use super::{check_no_overflow, fill_page_data, memset, round_page_down, Memory, Page, FLAG_DIRTY};

use bytes::Bytes;
use std::cmp::min;
use std::marker::PhantomData;

const INVALID_PAGE_INDEX: u16 = 0xFFFF;

/// A sparse flat memory implementation, it allocates pages only when requested,
/// but besides that, it does not permission checking.
pub struct SparseMemory<R> {
    // Stores the indices of each page in pages data structure, if a page hasn't
    // been initialized, the corresponding position will be filled with
    // INVALID_PAGE_INDEX. Considering u16 takes 2 bytes, this add an additional
    // of 64KB extra storage cost assuming we have 128MB memory.
    indices: Vec<u16>,
    pages: Vec<Page>,
    flags: Vec<u8>,
    memory_size: usize,
    riscv_pages: usize,
    load_reservation_address: R,
    _inner: PhantomData<R>,
}

impl<R: Register> SparseMemory<R> {
    fn fetch_page(&mut self, aligned_addr: u64) -> Result<&mut Page, Error> {
        let page = aligned_addr / RISCV_PAGESIZE as u64;
        if page >= self.riscv_pages as u64 {
            return Err(Error::MemOutOfBound(aligned_addr, OutOfBoundKind::Memory));
        }
        let mut index = self.indices[page as usize];
        if index == INVALID_PAGE_INDEX {
            self.pages.push([0; RISCV_PAGESIZE]);
            index = (self.pages.len() - 1) as u16;
            self.indices[page as usize] = index;
        }
        Ok(&mut self.pages[index as usize])
    }

    fn load(&mut self, addr: u64, bytes: u64) -> Result<u64, Error> {
        debug_assert!(bytes == 1 || bytes == 2 || bytes == 4 || bytes == 8);
        let page_addr = round_page_down(addr);
        let first_page_bytes = min(bytes, RISCV_PAGESIZE as u64 - (addr - page_addr));
        let mut shift = 0;
        let mut value: u64 = 0;
        {
            let page = self.fetch_page(page_addr)?;
            for &byte in page
                .iter()
                .skip((addr - page_addr) as usize)
                .take(first_page_bytes as usize)
            {
                value |= u64::from(byte) << shift;
                shift += 8;
            }
        }
        let second_page_bytes = bytes - first_page_bytes;
        if second_page_bytes > 0 {
            let second_page = self.fetch_page(page_addr + RISCV_PAGESIZE as u64)?;
            for &byte in second_page.iter().take(second_page_bytes as usize) {
                value |= u64::from(byte) << shift;
                shift += 8;
            }
        }
        Ok(value)
    }

    pub fn new_with_memory(memory_size: usize) -> Self {
        assert!(memory_size % RISCV_PAGESIZE == 0);
        Self {
            indices: vec![INVALID_PAGE_INDEX; memory_size / RISCV_PAGESIZE],
            pages: Vec::new(),
            flags: vec![0; memory_size / RISCV_PAGESIZE],
            memory_size,
            riscv_pages: memory_size / RISCV_PAGESIZE,
            load_reservation_address: R::from_u64(u64::MAX),
            _inner: PhantomData,
        }
    }
}

impl<R: Register> Default for SparseMemory<R> {
    fn default() -> Self {
        Self::new_with_memory(DEFAULT_MEMORY_SIZE)
    }
}

impl<R: Register> Memory for SparseMemory<R> {
    type REG = R;

    fn reset_memory(&mut self) -> Result<(), Error> {
        self.indices = vec![INVALID_PAGE_INDEX; self.indices.len()];
        memset(&mut self.flags, 0);
        self.pages.clear();
        self.load_reservation_address = R::from_u64(u64::MAX);
        Ok(())
    }

    fn init_pages(
        &mut self,
        addr: u64,
        size: u64,
        _flags: u8,
        source: Option<Bytes>,
        offset_from_addr: u64,
    ) -> Result<(), Error> {
        fill_page_data(self, addr, size, source, offset_from_addr)
    }

    fn fetch_flag(&mut self, page: u64) -> Result<u8, Error> {
        if page < self.riscv_pages as u64 {
            Ok(self.flags[page as usize])
        } else {
            Err(Error::MemOutOfBound(
                page << RISCV_PAGE_SHIFTS,
                OutOfBoundKind::Memory,
            ))
        }
    }

    fn set_flag(&mut self, page: u64, flag: u8) -> Result<(), Error> {
        if page < self.riscv_pages as u64 {
            self.flags[page as usize] |= flag;
            Ok(())
        } else {
            Err(Error::MemOutOfBound(
                page << RISCV_PAGE_SHIFTS,
                OutOfBoundKind::Memory,
            ))
        }
    }

    fn clear_flag(&mut self, page: u64, flag: u8) -> Result<(), Error> {
        if page < self.riscv_pages as u64 {
            self.flags[page as usize] &= !flag;
            Ok(())
        } else {
            Err(Error::MemOutOfBound(
                page << RISCV_PAGE_SHIFTS,
                OutOfBoundKind::Memory,
            ))
        }
    }

    fn memory_size(&self) -> usize {
        self.memory_size
    }

    fn load8(&mut self, addr: &Self::REG) -> Result<Self::REG, Error> {
        let v = self.load(addr.to_u64(), 1).map(|v| v as u8)?;
        Ok(Self::REG::from_u8(v))
    }

    fn load16(&mut self, addr: &Self::REG) -> Result<Self::REG, Error> {
        let v = self.load(addr.to_u64(), 2).map(|v| v as u16)?;
        Ok(Self::REG::from_u16(v))
    }

    fn load32(&mut self, addr: &Self::REG) -> Result<Self::REG, Error> {
        let v = self.load(addr.to_u64(), 4).map(|v| v as u32)?;
        Ok(Self::REG::from_u32(v))
    }

    fn load64(&mut self, addr: &Self::REG) -> Result<Self::REG, Error> {
        let v = self.load(addr.to_u64(), 8)?;
        Ok(Self::REG::from_u64(v))
    }

    fn execute_load16(&mut self, addr: u64) -> Result<u16, Error> {
        self.load(addr, 2).map(|v| v as u16)
    }

    fn execute_load32(&mut self, addr: u64) -> Result<u32, Error> {
        self.load(addr, 4).map(|v| v as u32)
    }

    fn store_bytes(&mut self, addr: u64, value: &[u8]) -> Result<(), Error> {
        let mut remaining_data = value;
        let mut current_page_addr = round_page_down(addr);
        let mut current_page_offset = addr - current_page_addr;
        while !remaining_data.is_empty() {
            let page = self.fetch_page(current_page_addr)?;
            let bytes = min(
                RISCV_PAGESIZE as u64 - current_page_offset,
                remaining_data.len() as u64,
            );
            let slice =
                &mut page[current_page_offset as usize..(current_page_offset + bytes) as usize];
            slice.copy_from_slice(&remaining_data[..bytes as usize]);
            self.set_flag(current_page_addr >> RISCV_PAGE_SHIFTS, FLAG_DIRTY)?;

            remaining_data = &remaining_data[bytes as usize..];
            current_page_addr += RISCV_PAGESIZE as u64;
            current_page_offset = 0;
        }
        Ok(())
    }

    fn store_byte(&mut self, addr: u64, size: u64, value: u8) -> Result<(), Error> {
        let mut current_page_addr = round_page_down(addr);
        let mut current_page_offset = addr - current_page_addr;
        let mut remaining_size = size;
        while remaining_size > 0 {
            let page = self.fetch_page(current_page_addr)?;
            let bytes = min(RISCV_PAGESIZE as u64 - current_page_offset, remaining_size);
            memset(
                &mut page[current_page_offset as usize..(current_page_offset + bytes) as usize],
                value,
            );
            self.set_flag(current_page_addr >> RISCV_PAGE_SHIFTS, FLAG_DIRTY)?;

            remaining_size -= bytes;
            current_page_addr += RISCV_PAGESIZE as u64;
            current_page_offset = 0;
        }
        Ok(())
    }

    fn load_bytes(&mut self, addr: u64, size: u64) -> Result<Bytes, Error> {
        if size == 0 {
            return Ok(Bytes::new());
        }
        check_no_overflow(addr, size, self.memory_size() as u64)?;
        let mut current_page_addr = round_page_down(addr);
        let mut current_page_offset = addr - current_page_addr;
        let mut need_read_len = size;
        let mut out_value = Vec::<u8>::with_capacity(size as usize);
        while need_read_len != 0 {
            let page = self.fetch_page(current_page_addr)?;
            let bytes = min(RISCV_PAGESIZE as u64 - current_page_offset, need_read_len);
            out_value.extend(
                &page[current_page_offset as usize..(current_page_offset + bytes) as usize],
            );
            need_read_len -= bytes;
            current_page_addr += RISCV_PAGESIZE as u64;
            current_page_offset = 0;
        }
        Ok(Bytes::from(out_value))
    }

    fn store8(&mut self, addr: &Self::REG, value: &Self::REG) -> Result<(), Error> {
        self.store_bytes(addr.to_u64(), &[value.to_u8()])
    }

    fn store16(&mut self, addr: &Self::REG, value: &Self::REG) -> Result<(), Error> {
        let value = value.to_u16();
        // RISC-V is little-endian by specification
        self.store_bytes(addr.to_u64(), &[(value & 0xFF) as u8, (value >> 8) as u8])
    }

    fn store32(&mut self, addr: &Self::REG, value: &Self::REG) -> Result<(), Error> {
        let value = value.to_u32();
        // RISC-V is little-endian by specification
        self.store_bytes(
            addr.to_u64(),
            &[
                (value & 0xFF) as u8,
                ((value >> 8) & 0xFF) as u8,
                ((value >> 16) & 0xFF) as u8,
                ((value >> 24) & 0xFF) as u8,
            ],
        )
    }

    fn store64(&mut self, addr: &Self::REG, value: &Self::REG) -> Result<(), Error> {
        let value = value.to_u64();
        // RISC-V is little-endian by specification
        self.store_bytes(
            addr.to_u64(),
            &[
                (value & 0xFF) as u8,
                ((value >> 8) & 0xFF) as u8,
                ((value >> 16) & 0xFF) as u8,
                ((value >> 24) & 0xFF) as u8,
                ((value >> 32) & 0xFF) as u8,
                ((value >> 40) & 0xFF) as u8,
                ((value >> 48) & 0xFF) as u8,
                ((value >> 56) & 0xFF) as u8,
            ],
        )
    }

    fn lr(&self) -> &Self::REG {
        &self.load_reservation_address
    }

    fn set_lr(&mut self, value: &Self::REG) {
        self.load_reservation_address = value.clone();
    }
}


================================================
File: src/memory/wxorx.rs
================================================
use super::super::{error::OutOfBoundKind, Error, Register, RISCV_PAGESIZE};
use super::{
    check_no_overflow, check_permission, get_page_indices, round_page_down, round_page_up, Memory,
    FLAG_EXECUTABLE, FLAG_FREEZED, FLAG_WRITABLE,
};

use bytes::Bytes;

pub struct WXorXMemory<M: Memory> {
    inner: M,
}

impl<M: Memory> WXorXMemory<M> {
    pub fn inner_mut(&mut self) -> &mut M {
        &mut self.inner
    }

    pub fn new(inner: M) -> Self {
        Self { inner }
    }
}

impl<M: Memory + Default> Default for WXorXMemory<M> {
    fn default() -> Self {
        Self::new(M::default())
    }
}

impl<M: Memory> Memory for WXorXMemory<M> {
    type REG = M::REG;

    fn reset_memory(&mut self) -> Result<(), Error> {
        self.inner.reset_memory()
    }

    fn init_pages(
        &mut self,
        addr: u64,
        size: u64,
        flags: u8,
        source: Option<Bytes>,
        offset_from_addr: u64,
    ) -> Result<(), Error> {
        if round_page_down(addr) != addr {
            return Err(Error::MemPageUnalignedAccess(addr));
        }
        if round_page_up(size) != size {
            return Err(Error::MemPageUnalignedAccess(addr.wrapping_add(size)));
        }

        if addr > self.memory_size() as u64 {
            return Err(Error::MemOutOfBound(addr, OutOfBoundKind::Memory));
        }
        if size > self.memory_size() as u64 || addr + size > self.memory_size() as u64 {
            return Err(Error::MemOutOfBound(
                addr.wrapping_add(size),
                OutOfBoundKind::Memory,
            ));
        }
        if offset_from_addr > size {
            return Err(Error::MemOutOfBound(
                offset_from_addr,
                OutOfBoundKind::ExternalData,
            ));
        }
        for page_addr in (addr..addr + size).step_by(RISCV_PAGESIZE) {
            let page = page_addr / RISCV_PAGESIZE as u64;
            if self.fetch_flag(page)? & FLAG_FREEZED != 0 {
                return Err(Error::MemWriteOnFreezedPage(page));
            }
            self.set_flag(page, flags)?;
        }
        self.inner
            .init_pages(addr, size, flags, source, offset_from_addr)
    }

    fn fetch_flag(&mut self, page: u64) -> Result<u8, Error> {
        self.inner.fetch_flag(page)
    }

    fn set_flag(&mut self, page: u64, flag: u8) -> Result<(), Error> {
        self.inner.set_flag(page, flag)
    }

    fn clear_flag(&mut self, page: u64, flag: u8) -> Result<(), Error> {
        self.inner.clear_flag(page, flag)
    }

    fn memory_size(&self) -> usize {
        self.inner.memory_size()
    }

    fn execute_load16(&mut self, addr: u64) -> Result<u16, Error> {
        check_no_overflow(addr, 2, self.memory_size() as u64)?;
        let page_indices = get_page_indices(addr, 2);
        check_permission(self, &page_indices, FLAG_EXECUTABLE)?;
        self.inner.execute_load16(addr)
    }

    fn execute_load32(&mut self, addr: u64) -> Result<u32, Error> {
        check_no_overflow(addr, 4, self.memory_size() as u64)?;
        let page_indices = get_page_indices(addr, 4);
        check_permission(self, &page_indices, FLAG_EXECUTABLE)?;
        self.inner.execute_load32(addr)
    }

    fn load8(&mut self, addr: &Self::REG) -> Result<Self::REG, Error> {
        self.inner.load8(addr)
    }

    fn load16(&mut self, addr: &Self::REG) -> Result<Self::REG, Error> {
        self.inner.load16(addr)
    }

    fn load32(&mut self, addr: &Self::REG) -> Result<Self::REG, Error> {
        self.inner.load32(addr)
    }

    fn load64(&mut self, addr: &Self::REG) -> Result<Self::REG, Error> {
        self.inner.load64(addr)
    }

    fn store8(&mut self, addr: &Self::REG, value: &Self::REG) -> Result<(), Error> {
        check_no_overflow(addr.to_u64(), 1, self.memory_size() as u64)?;
        let page_indices = get_page_indices(addr.to_u64(), 1);
        check_permission(self, &page_indices, FLAG_WRITABLE)?;
        self.inner.store8(addr, value)
    }

    fn store16(&mut self, addr: &Self::REG, value: &Self::REG) -> Result<(), Error> {
        check_no_overflow(addr.to_u64(), 2, self.memory_size() as u64)?;
        let page_indices = get_page_indices(addr.to_u64(), 2);
        check_permission(self, &page_indices, FLAG_WRITABLE)?;
        self.inner.store16(addr, value)
    }

    fn store32(&mut self, addr: &Self::REG, value: &Self::REG) -> Result<(), Error> {
        check_no_overflow(addr.to_u64(), 4, self.memory_size() as u64)?;
        let page_indices = get_page_indices(addr.to_u64(), 4);
        check_permission(self, &page_indices, FLAG_WRITABLE)?;
        self.inner.store32(addr, value)
    }

    fn store64(&mut self, addr: &Self::REG, value: &Self::REG) -> Result<(), Error> {
        check_no_overflow(addr.to_u64(), 8, self.memory_size() as u64)?;
        let page_indices = get_page_indices(addr.to_u64(), 8);
        check_permission(self, &page_indices, FLAG_WRITABLE)?;
        self.inner.store64(addr, value)
    }

    fn store_bytes(&mut self, addr: u64, value: &[u8]) -> Result<(), Error> {
        if value.is_empty() {
            return Ok(());
        }
        check_no_overflow(addr.to_u64(), value.len() as u64, self.memory_size() as u64)?;
        let page_indices = get_page_indices(addr, value.len() as u64);
        check_permission(self, &page_indices, FLAG_WRITABLE)?;
        self.inner.store_bytes(addr, value)
    }

    fn store_byte(&mut self, addr: u64, size: u64, value: u8) -> Result<(), Error> {
        if size == 0 {
            return Ok(());
        }
        check_no_overflow(addr.to_u64(), size, self.memory_size() as u64)?;
        let page_indices = get_page_indices(addr, size);
        check_permission(self, &page_indices, FLAG_WRITABLE)?;
        self.inner.store_byte(addr, size, value)
    }

    fn load_bytes(&mut self, addr: u64, size: u64) -> Result<Bytes, Error> {
        // inner.load_bytes will check
        self.inner.load_bytes(addr, size)
    }

    fn lr(&self) -> &Self::REG {
        self.inner.lr()
    }

    fn set_lr(&mut self, value: &Self::REG) {
        self.inner.set_lr(value);
    }
}


================================================
File: src/syscalls/mod.rs
================================================
use super::Error;
use crate::machine::SupportMachine;

pub trait Syscalls<Mac: SupportMachine>: Send + Sync {
    fn initialize(&mut self, machine: &mut Mac) -> Result<(), Error>;
    // Returned bool means if the syscall has been processed, if
    // a module returns false, Machine would continue to leverage
    // the next syscall module to process.
    fn ecall(&mut self, machine: &mut Mac) -> Result<bool, Error>;
}


================================================
File: tests/machine_build.rs
================================================
use bytes::Bytes;
use ckb_vm::cost_model::constant_cycles;
#[cfg(has_asm)]
use ckb_vm::machine::asm::{AsmCoreMachine, AsmMachine};
use ckb_vm::machine::{trace::TraceMachine, DefaultCoreMachine};
use ckb_vm::registers::{A0, A7};
use ckb_vm::{
    DefaultMachineBuilder, Error, Register, SparseMemory, SupportMachine, Syscalls, WXorXMemory,
};

pub struct SleepSyscall {}

impl<Mac: SupportMachine> Syscalls<Mac> for SleepSyscall {
    fn initialize(&mut self, _machine: &mut Mac) -> Result<(), Error> {
        Ok(())
    }

    fn ecall(&mut self, machine: &mut Mac) -> Result<bool, Error> {
        let code = &machine.registers()[A7];
        if code.to_i32() != 1000 {
            return Ok(false);
        }
        let duration = machine.registers()[A0].to_u64();
        std::thread::sleep(std::time::Duration::from_millis(duration));

        machine.set_register(A0, Mac::REG::from_u8(0));
        Ok(true)
    }
}

#[cfg(has_asm)]
pub fn asm(path: &str, args: Vec<Bytes>, version: u32, isa: u8) -> AsmMachine {
    let buffer: Bytes = std::fs::read(path).unwrap().into();
    let asm_core = AsmCoreMachine::new(isa, version, u64::MAX);
    let core = DefaultMachineBuilder::<Box<AsmCoreMachine>>::new(asm_core)
        .instruction_cycle_func(Box::new(constant_cycles))
        .syscall(Box::new(SleepSyscall {}))
        .build();
    let mut machine = AsmMachine::new(core);
    let mut argv = vec![Ok(Bytes::from("main"))];
    argv.extend(args.into_iter().map(Ok));
    machine.load_program(&buffer, argv.into_iter()).unwrap();
    machine
}

pub fn int(
    path: &str,
    args: Vec<Bytes>,
    version: u32,
    isa: u8,
) -> TraceMachine<DefaultCoreMachine<u64, WXorXMemory<SparseMemory<u64>>>> {
    let buffer: Bytes = std::fs::read(path).unwrap().into();
    let core_machine =
        DefaultCoreMachine::<u64, WXorXMemory<SparseMemory<u64>>>::new(isa, version, u64::MAX);
    let mut machine = TraceMachine::new(
        DefaultMachineBuilder::new(core_machine)
            .instruction_cycle_func(Box::new(constant_cycles))
            .syscall(Box::new(SleepSyscall {}))
            .build(),
    );
    let mut argv = vec![Ok(Bytes::from("main"))];
    argv.extend(args.into_iter().map(Ok));
    machine.load_program(&buffer, argv.into_iter()).unwrap();
    machine
}


================================================
File: tests/test_a_extension.rs
================================================
use ckb_vm::{machine::VERSION2, Error, ISA_A, ISA_IMC};
#[cfg(has_asm)]
use ckb_vm::{CoreMachine, Memory};
pub mod machine_build;

#[test]
pub fn test_write_permission_bug() {
    let mut machine = machine_build::int(
        "tests/programs/amo_write_permission",
        vec![],
        VERSION2,
        ISA_IMC | ISA_A,
    );
    let ret = machine.run();
    assert!(ret.is_err());
    assert_eq!(ret.err(), Some(Error::MemWriteOnExecutablePage(16)));

    #[cfg(has_asm)]
    {
        let mut machine_asm = machine_build::asm(
            "tests/programs/amo_write_permission",
            vec![],
            VERSION2,
            ISA_IMC | ISA_A,
        );
        let ret_asm = machine_asm.run();
        assert!(ret_asm.is_err());
        assert_eq!(ret_asm.err(), Some(Error::MemWriteOnExecutablePage(16)));
    }
}

#[test]
pub fn test_sc_after_sc() {
    let mut machine = machine_build::int(
        "tests/programs/sc_after_sc",
        vec![],
        VERSION2,
        ISA_IMC | ISA_A,
    );
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);

    #[cfg(has_asm)]
    {
        let mut machine_asm = machine_build::asm(
            "tests/programs/sc_after_sc",
            vec![],
            VERSION2,
            ISA_IMC | ISA_A,
        );
        let ret_asm = machine_asm.run();
        assert!(ret_asm.is_ok());
        assert_eq!(ret_asm.unwrap(), 0);
    }
}

#[test]
pub fn test_sc_only() {
    let mut machine =
        machine_build::int("tests/programs/sc_only", vec![], VERSION2, ISA_IMC | ISA_A);
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);

    #[cfg(has_asm)]
    {
        let mut machine_asm =
            machine_build::asm("tests/programs/sc_only", vec![], VERSION2, ISA_IMC | ISA_A);
        let ret_asm = machine_asm.run();
        assert!(ret_asm.is_ok());
        assert_eq!(ret_asm.unwrap(), 0);
    }
}

#[test]
pub fn test_amo_compare() {
    let mut machine = machine_build::int(
        "tests/programs/amo_compare",
        vec![],
        VERSION2,
        ISA_IMC | ISA_A,
    );
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);

    #[cfg(has_asm)]
    {
        let mut machine_asm = machine_build::asm(
            "tests/programs/amo_compare",
            vec![],
            VERSION2,
            ISA_IMC | ISA_A,
        );
        let ret_asm = machine_asm.run();
        assert!(ret_asm.is_ok());
        assert_eq!(ret_asm.unwrap(), 0);
    }
}

#[test]
pub fn test_amo_check_write() {
    #[cfg(has_asm)]
    {
        let mut machine_asm = machine_build::asm(
            "tests/programs/amo_check_write",
            vec![],
            VERSION2,
            ISA_IMC | ISA_A,
        );
        let page_a = 0;
        let page_b = 17;
        let flag_a = machine_asm.machine.memory_mut().fetch_flag(page_a).unwrap();
        assert_eq!(flag_a, 0);
        let ret_asm = machine_asm.run();
        assert!(ret_asm.is_ok());
        assert_eq!(ret_asm.unwrap(), 0);
        assert_eq!(machine_asm.machine.inner_mut().last_write_page, page_b);
        let flag_a = machine_asm.machine.memory_mut().fetch_flag(page_a).unwrap();
        assert_eq!(flag_a, 0);
        let flag_b = machine_asm.machine.memory_mut().fetch_flag(page_b).unwrap();
        assert_eq!(flag_b, 4);
    }
}


================================================
File: tests/test_asm.rs
================================================
#![cfg(has_asm)]
use ckb_vm::cost_model::constant_cycles;
use ckb_vm::decoder::build_decoder;
use ckb_vm::error::OutOfBoundKind;
use ckb_vm::machine::asm::traces::{MemoizedDynamicTraceDecoder, MemoizedFixedTraceDecoder};
use ckb_vm::machine::asm::{AsmCoreMachine, AsmMachine};
use ckb_vm::machine::{CoreMachine, VERSION0, VERSION1, VERSION2};
use ckb_vm::memory::Memory;
use ckb_vm::registers::{A0, A1, A2, A3, A4, A5, A7};
use ckb_vm::{Debugger, DefaultMachineBuilder, Error, Register, SupportMachine, Syscalls, ISA_IMC};
use std::fs;
use std::sync::atomic::{AtomicU8, Ordering};
use std::sync::Arc;
use std::thread;
pub mod machine_build;

#[test]
pub fn test_asm_simple64() {
    let buffer = fs::read("tests/programs/simple64").unwrap().into();
    let asm_core = AsmCoreMachine::new(ISA_IMC, VERSION0, u64::MAX);
    let core = DefaultMachineBuilder::new(asm_core).build();
    let mut machine = AsmMachine::new(core);
    machine
        .load_program(&buffer, [Ok("simple".into())].into_iter())
        .unwrap();
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
}

pub struct CustomSyscall {}

impl<Mac: SupportMachine> Syscalls<Mac> for CustomSyscall {
    fn initialize(&mut self, _machine: &mut Mac) -> Result<(), Error> {
        Ok(())
    }

    fn ecall(&mut self, machine: &mut Mac) -> Result<bool, Error> {
        let code = &machine.registers()[A7];
        if code.to_i32() != 1111 {
            return Ok(false);
        }
        let result = machine.registers()[A0]
            .overflowing_add(&machine.registers()[A1])
            .overflowing_add(&machine.registers()[A2])
            .overflowing_add(&machine.registers()[A3])
            .overflowing_add(&machine.registers()[A4])
            .overflowing_add(&machine.registers()[A5]);
        machine.set_register(A0, result);
        Ok(true)
    }
}

#[test]
pub fn test_asm_with_custom_syscall() {
    let buffer = fs::read("tests/programs/syscall64").unwrap().into();
    let asm_core = AsmCoreMachine::new(ISA_IMC, VERSION0, u64::MAX);
    let core = DefaultMachineBuilder::new(asm_core)
        .syscall(Box::new(CustomSyscall {}))
        .build();
    let mut machine = AsmMachine::new(core);
    machine
        .load_program(&buffer, [Ok("syscall".into())].into_iter())
        .unwrap();
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 39);
}

pub struct CustomDebugger {
    pub value: Arc<AtomicU8>,
}

impl<Mac: SupportMachine> Debugger<Mac> for CustomDebugger {
    fn initialize(&mut self, _machine: &mut Mac) -> Result<(), Error> {
        self.value.store(1, Ordering::Relaxed);
        Ok(())
    }

    fn ebreak(&mut self, _machine: &mut Mac) -> Result<(), Error> {
        self.value.store(2, Ordering::Relaxed);
        Ok(())
    }
}

#[test]
pub fn test_asm_ebreak() {
    let buffer = fs::read("tests/programs/ebreak64").unwrap().into();
    let value = Arc::new(AtomicU8::new(0));

    let asm_core = AsmCoreMachine::new(ISA_IMC, VERSION0, u64::MAX);
    let core = DefaultMachineBuilder::new(asm_core)
        .debugger(Box::new(CustomDebugger {
            value: Arc::clone(&value),
        }))
        .build();
    let mut machine = AsmMachine::new(core);
    machine
        .load_program(&buffer, [Ok("ebreak".into())].into_iter())
        .unwrap();
    assert_eq!(value.load(Ordering::Relaxed), 1);
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(value.load(Ordering::Relaxed), 2);
}

#[test]
pub fn test_asm_simple_cycles() {
    let buffer = fs::read("tests/programs/simple64").unwrap().into();
    let asm_core = AsmCoreMachine::new(ISA_IMC, VERSION0, 708);
    let core = DefaultMachineBuilder::new(asm_core)
        .instruction_cycle_func(Box::new(constant_cycles))
        .build();
    let mut machine = AsmMachine::new(core);
    machine
        .load_program(&buffer, [Ok("syscall".into())].into_iter())
        .unwrap();
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);

    assert_eq!(SupportMachine::cycles(&machine.machine), 708);
}

#[test]
pub fn test_asm_simple_max_cycles_reached() {
    let buffer = fs::read("tests/programs/simple64").unwrap().into();
    // Running simple64 should consume 708 cycles using dummy cycle func
    let asm_core = AsmCoreMachine::new(ISA_IMC, VERSION0, 700);
    let core = DefaultMachineBuilder::<Box<AsmCoreMachine>>::new(asm_core)
        .instruction_cycle_func(Box::new(constant_cycles))
        .build();
    let mut machine = AsmMachine::new(core);
    machine
        .load_program(&buffer, [Ok("syscall".into())].into_iter())
        .unwrap();
    let result = machine.run();
    assert!(result.is_err());
    assert_eq!(result.unwrap_err(), Error::CyclesExceeded);
}

#[test]
pub fn test_asm_trace() {
    let buffer = fs::read("tests/programs/trace64").unwrap().into();
    let asm_core = AsmCoreMachine::new(ISA_IMC, VERSION0, u64::MAX);
    let core = DefaultMachineBuilder::new(asm_core).build();
    let mut machine = AsmMachine::new(core);
    machine
        .load_program(&buffer, [Ok("simple".into())].into_iter())
        .unwrap();
    let result = machine.run();
    assert!(result.is_err());
    assert_eq!(result.err(), Some(Error::MemWriteOnExecutablePage(16)));
}

#[test]
pub fn test_asm_jump0() {
    let buffer = fs::read("tests/programs/jump0_64").unwrap().into();
    let asm_core = AsmCoreMachine::new(ISA_IMC, VERSION0, u64::MAX);
    let core = DefaultMachineBuilder::new(asm_core).build();
    let mut machine = AsmMachine::new(core);
    machine
        .load_program(&buffer, [Ok("jump0_64".into())].into_iter())
        .unwrap();
    let result = machine.run();
    assert!(result.is_err());
    assert_eq!(result.err(), Some(Error::MemWriteOnExecutablePage(0)));
}

#[test]
pub fn test_asm_write_large_address() {
    let buffer = fs::read("tests/programs/write_large_address64")
        .unwrap()
        .into();
    let asm_core = AsmCoreMachine::new(ISA_IMC, VERSION0, u64::MAX);
    let core = DefaultMachineBuilder::new(asm_core).build();
    let mut machine = AsmMachine::new(core);
    machine
        .load_program(&buffer, [Ok("write_large_address64".into())].into_iter())
        .unwrap();
    let result = machine.run();
    assert!(result.is_err());
    assert_eq!(
        result.err(),
        Some(Error::MemOutOfBound(0xffffff00, OutOfBoundKind::Memory))
    );
}

#[test]
pub fn test_misaligned_jump64() {
    let buffer = fs::read("tests/programs/misaligned_jump64").unwrap().into();
    let asm_core = AsmCoreMachine::new(ISA_IMC, VERSION0, u64::MAX);
    let core = DefaultMachineBuilder::new(asm_core).build();
    let mut machine = AsmMachine::new(core);
    machine
        .load_program(&buffer, [Ok("misaligned_jump64".into())].into_iter())
        .unwrap();
    let result = machine.run();
    assert!(result.is_ok());
}

#[test]
pub fn test_mulw64() {
    let buffer = fs::read("tests/programs/mulw64").unwrap().into();
    let asm_core = AsmCoreMachine::new(ISA_IMC, VERSION0, u64::MAX);
    let core = DefaultMachineBuilder::new(asm_core).build();
    let mut machine = AsmMachine::new(core);
    machine
        .load_program(&buffer, [Ok("mulw64".into())].into_iter())
        .unwrap();
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
}

#[test]
pub fn test_invalid_read64() {
    let buffer = fs::read("tests/programs/invalid_read64").unwrap().into();
    let asm_core = AsmCoreMachine::new(ISA_IMC, VERSION0, u64::MAX);
    let core = DefaultMachineBuilder::new(asm_core).build();
    let mut machine = AsmMachine::new(core);
    machine
        .load_program(&buffer, [Ok("invalid_read64".into())].into_iter())
        .unwrap();
    let result = machine.run();
    assert!(result.is_err());
    assert_eq!(
        result.err(),
        Some(Error::MemOutOfBound(
            0xffffffffffffffff,
            OutOfBoundKind::Memory
        ))
    );
}

#[test]
pub fn test_asm_load_elf_crash_64() {
    let buffer = fs::read("tests/programs/load_elf_crash_64").unwrap().into();
    let asm_core = AsmCoreMachine::new(ISA_IMC, VERSION0, u64::MAX);
    let core = DefaultMachineBuilder::new(asm_core).build();
    let mut machine = AsmMachine::new(core);
    machine
        .load_program(&buffer, [Ok("load_elf_crash_64".into())].into_iter())
        .unwrap();
    let result = machine.run();
    assert_eq!(result.err(), Some(Error::MemWriteOnExecutablePage(16)));
}

#[test]
pub fn test_asm_wxorx_crash_64() {
    let buffer = fs::read("tests/programs/wxorx_crash_64").unwrap().into();
    let asm_core = AsmCoreMachine::new(ISA_IMC, VERSION0, u64::MAX);
    let core = DefaultMachineBuilder::new(asm_core).build();
    let mut machine = AsmMachine::new(core);
    machine
        .load_program(&buffer, [Ok("wxorx_crash_64".into())].into_iter())
        .unwrap();
    let result = machine.run();
    assert_eq!(
        result.err(),
        Some(Error::MemOutOfBound(
            0xffffffffffffffff,
            OutOfBoundKind::Memory
        ))
    );
}

#[test]
pub fn test_asm_alloc_many() {
    let buffer = fs::read("tests/programs/alloc_many").unwrap().into();
    let asm_core = AsmCoreMachine::new(ISA_IMC, VERSION0, u64::MAX);
    let core = DefaultMachineBuilder::new(asm_core).build();
    let mut machine = AsmMachine::new(core);
    machine
        .load_program(&buffer, [Ok("alloc_many".into())].into_iter())
        .unwrap();
    let result = machine.run();
    assert_eq!(result.unwrap(), 0);
}

#[test]
pub fn test_asm_chaos_seed() {
    let buffer = fs::read("tests/programs/read_memory").unwrap().into();
    let mut asm_core1 = AsmCoreMachine::new(ISA_IMC, VERSION1, u64::MAX);
    asm_core1.chaos_mode = 1;
    asm_core1.chaos_seed = 100;
    let core1 = DefaultMachineBuilder::<Box<AsmCoreMachine>>::new(asm_core1).build();
    let mut machine1 = AsmMachine::new(core1);
    machine1
        .load_program(&buffer, [Ok("read_memory".into())].into_iter())
        .unwrap();
    let result1 = machine1.run();
    let exit1 = result1.unwrap();

    let mut asm_core2 = AsmCoreMachine::new(ISA_IMC, VERSION1, u64::MAX);
    asm_core2.chaos_mode = 1;
    asm_core2.chaos_seed = 100;
    let core2 = DefaultMachineBuilder::<Box<AsmCoreMachine>>::new(asm_core2).build();
    let mut machine2 = AsmMachine::new(core2);
    machine2
        .load_program(&buffer, [Ok("read_memory".into())].into_iter())
        .unwrap();
    let result2 = machine2.run();
    let exit2 = result2.unwrap();

    assert_eq!(exit1, exit2);
    // Read 8 bytes from 0x300000, it is very unlikely that they are both 0.
    assert!(machine1.machine.memory_mut().load64(&0x300000).unwrap() != 0);
    assert!(machine2.machine.memory_mut().load64(&0x300000).unwrap() != 0);
}

#[test]
pub fn test_asm_rvc_pageend() {
    let buffer = fs::read("tests/programs/rvc_pageend").unwrap().into();
    let asm_core = AsmCoreMachine::new(ISA_IMC, VERSION0, u64::MAX);
    let core = DefaultMachineBuilder::new(asm_core).build();
    let mut machine = AsmMachine::new(core);
    machine
        .load_program(&buffer, [Ok("rvc_pageend".into())].into_iter())
        .unwrap();
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
}

pub struct OutOfCyclesSyscall {}

impl<Mac: SupportMachine> Syscalls<Mac> for OutOfCyclesSyscall {
    fn initialize(&mut self, _machine: &mut Mac) -> Result<(), Error> {
        Ok(())
    }

    fn ecall(&mut self, machine: &mut Mac) -> Result<bool, Error> {
        let code = &machine.registers()[A7];
        if code.to_i32() != 1111 {
            return Ok(false);
        }
        machine.add_cycles_no_checking(100)?;
        let result = machine.registers()[A0]
            .overflowing_add(&machine.registers()[A1])
            .overflowing_add(&machine.registers()[A2])
            .overflowing_add(&machine.registers()[A3])
            .overflowing_add(&machine.registers()[A4])
            .overflowing_add(&machine.registers()[A5]);
        machine.set_register(A0, result);
        Ok(true)
    }
}

#[test]
pub fn test_asm_outofcycles_in_syscall() {
    let buffer = fs::read("tests/programs/syscall64").unwrap().into();
    let asm_core = AsmCoreMachine::new(ISA_IMC, VERSION0, 20);
    let core = DefaultMachineBuilder::new(asm_core)
        .instruction_cycle_func(Box::new(constant_cycles))
        .syscall(Box::new(OutOfCyclesSyscall {}))
        .build();
    let mut machine = AsmMachine::new(core);
    machine
        .load_program(&buffer, [Ok("syscall".into())].into_iter())
        .unwrap();
    let result = machine.run();
    assert!(result.is_err());
    assert_eq!(result.unwrap_err(), Error::CyclesExceeded);
    assert_eq!(machine.machine.cycles(), 108);
    assert_eq!(machine.machine.registers()[A0], 39);
}

#[test]
pub fn test_asm_cycles_overflow() {
    let buffer = fs::read("tests/programs/simple64").unwrap().into();
    let asm_core = AsmCoreMachine::new(ISA_IMC, VERSION0, u64::MAX);
    let core = DefaultMachineBuilder::<Box<AsmCoreMachine>>::new(asm_core)
        .instruction_cycle_func(Box::new(constant_cycles))
        .build();
    let mut machine = AsmMachine::new(core);
    machine.machine.set_cycles(u64::MAX - 10);
    machine
        .load_program(&buffer, [Ok("simple64".into())].into_iter())
        .unwrap();
    let result = machine.run();
    assert!(result.is_err());
    assert_eq!(result.unwrap_err(), Error::CyclesOverflow);
}

#[test]
pub fn test_decoder_instructions_cache_pc_out_of_bound_timeout() {
    let buffer = fs::read("tests/programs/decoder_instructions_cache_pc_out_of_bound_timeout")
        .unwrap()
        .into();
    let asm_core = AsmCoreMachine::new(ISA_IMC, VERSION0, u64::MAX);
    let core = DefaultMachineBuilder::<Box<AsmCoreMachine>>::new(asm_core)
        .instruction_cycle_func(Box::new(constant_cycles))
        .build();
    let mut machine = AsmMachine::new(core);
    machine.machine.set_cycles(u64::MAX - 10);
    machine
        .load_program(&buffer, [Ok("simple64".into())].into_iter())
        .unwrap();
    let result = machine.run();
    assert!(result.is_err());
    assert_eq!(
        result.unwrap_err(),
        Error::MemOutOfBound(0x400000, OutOfBoundKind::Memory)
    );
}

#[test]
fn test_asm_step() {
    let buffer = fs::read("tests/programs/simple64").unwrap().into();
    let asm_core = AsmCoreMachine::new(ISA_IMC, VERSION0, u64::MAX);
    let core = DefaultMachineBuilder::new(asm_core).build();
    let mut machine = AsmMachine::new(core);
    machine
        .load_program(&buffer, [Ok("simple64".into())].into_iter())
        .unwrap();

    let result = || -> Result<i8, Error> {
        let mut decoder = build_decoder::<u64>(ISA_IMC, VERSION0);
        machine.machine.set_running(true);
        while machine.machine.running() {
            machine.step(&mut decoder)?;
        }
        Ok(machine.machine.exit_code())
    }();

    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
}

#[test]
fn test_asm_thread_safe() {
    let buffer = fs::read("tests/programs/mulw64").unwrap().into();
    let asm_core = AsmCoreMachine::new(ISA_IMC, VERSION0, u64::MAX);
    let core = DefaultMachineBuilder::new(asm_core).build();
    let mut machine = AsmMachine::new(core);
    machine
        .load_program(&buffer, [Ok("mulw64".into())].into_iter())
        .unwrap();
    let thread_join_handle = thread::spawn(move || {
        let result = machine.run();
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), 0);
    });
    thread_join_handle.join().unwrap();
}

#[test]
fn test_zero_address() {
    let buffer = fs::read("tests/programs/zero_address").unwrap().into();
    let asm_core = AsmCoreMachine::new(ISA_IMC, VERSION1, u64::MAX);
    let core = DefaultMachineBuilder::new(asm_core).build();
    let mut machine = AsmMachine::new(core);
    machine
        .load_program(&buffer, [Ok("zero".into())].into_iter())
        .unwrap();
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
}

#[test]
fn test_memoized_secp256k1() {
    let isa = ISA_IMC;
    let version = VERSION1;
    let buffer = fs::read("benches/data/secp256k1_bench").unwrap().into();
    let asm_core = AsmCoreMachine::new(isa, version, u64::MAX);
    let core = DefaultMachineBuilder::new(asm_core).build();
    let mut machine = AsmMachine::new(core);
    let args = [
            "secp256k1_bench",
            "033f8cf9c4d51a33206a6c1c6b27d2cc5129daa19dbd1fc148d395284f6b26411f",
            "304402203679d909f43f073c7c1dcf8468a485090589079ee834e6eed92fea9b09b06a2402201e46f1075afa18f306715e7db87493e7b7e779569aa13c64ab3d09980b3560a3",
            "foo",
            "bar",
        ].into_iter().map(|a| Ok(a.into()));
    machine.load_program(&buffer, args).unwrap();
    let mut decoder = MemoizedFixedTraceDecoder::new(build_decoder::<u64>(isa, version));
    let result = machine.run_with_decoder(&mut decoder);
    assert_eq!(result.unwrap(), 0);
}

#[test]
fn test_memoized_dynamic_secp256k1() {
    let isa = ISA_IMC;
    let version = VERSION1;
    let buffer = fs::read("benches/data/secp256k1_bench").unwrap().into();
    let asm_core = AsmCoreMachine::new(isa, version, u64::MAX);
    let core = DefaultMachineBuilder::new(asm_core).build();
    let mut machine = AsmMachine::new(core);
    let args = [
            "secp256k1_bench",
            "033f8cf9c4d51a33206a6c1c6b27d2cc5129daa19dbd1fc148d395284f6b26411f",
            "304402203679d909f43f073c7c1dcf8468a485090589079ee834e6eed92fea9b09b06a2402201e46f1075afa18f306715e7db87493e7b7e779569aa13c64ab3d09980b3560a3",
            "foo",
            "bar",
        ].into_iter().map(|a| Ok(a.into()));
    machine.load_program(&buffer, args).unwrap();
    let mut decoder = MemoizedDynamicTraceDecoder::new(build_decoder::<u64>(isa, version));
    let result = machine.run_with_decoder(&mut decoder);
    assert_eq!(result.unwrap(), 0);
}

#[test]
pub fn test_big_binary() {
    let buffer = fs::read("tests/programs/big_binary").unwrap().into();
    let asm_core = AsmCoreMachine::new_with_memory(ISA_IMC, VERSION2, u64::MAX, 1024 * 512);
    let core = DefaultMachineBuilder::new(asm_core).build();
    let mut machine = AsmMachine::new(core);
    let result = machine.load_program(&buffer, [Ok("simple".into())].into_iter());
    assert_eq!(
        result,
        Err(Error::MemOutOfBound(0x111000, OutOfBoundKind::Memory))
    );
}

#[cfg(not(feature = "enable-chaos-mode-by-default"))]
#[test]
fn test_fast_memory_initialization_bug() {
    let isa = ISA_IMC;
    let version = VERSION1;
    let buffer = fs::read("benches/data/secp256k1_bench").unwrap().into();
    let asm_core = AsmCoreMachine::new(isa, version, u64::MAX);
    let core = DefaultMachineBuilder::new(asm_core).build();
    let mut machine = AsmMachine::new(core);
    unsafe {
        let memory = machine.machine.inner_mut().memory_ptr as *mut u8;
        memory.write(0x01);
    }
    machine.load_program(&buffer, [].into_iter()).unwrap();
    assert_eq!(machine.machine.memory_mut().load8(&0).unwrap(), 0);
}

#[test]
pub fn test_memory_load_crash() {
    let buffer = fs::read("tests/programs/memory_crash").unwrap().into();
    let asm_core = AsmCoreMachine::new(ISA_IMC, VERSION0, u64::MAX);
    let core = DefaultMachineBuilder::new(asm_core).build();
    let mut machine = AsmMachine::new(core);
    let result = machine.load_program(&buffer, [Ok("memory_crash".into())].into_iter());
    assert_eq!(result.unwrap_err(), Error::MemWriteOnExecutablePage(1023));
}


================================================
File: tests/test_auipc_fusion.rs
================================================
use ckb_vm::decoder::{build_decoder, Decoder, InstDecoder};
use ckb_vm::instructions::{
    extract_opcode, instruction_length, set_instruction_length_n, Instruction, Utype,
};
#[cfg(has_asm)]
use ckb_vm::machine::asm::{traces::SimpleFixedTraceDecoder, AsmCoreMachine, AsmMachine};
use ckb_vm::machine::VERSION1;
use ckb_vm::{
    CoreMachine, DefaultCoreMachine, DefaultMachineBuilder, Error, Memory, SparseMemory, ISA_IMC,
};
use ckb_vm_definitions::instructions as insts;
use std::fs;

// This is simplified from https://github.com/xxuejie/ckb-vm-contrib/blob/main/src/decoder.rs
pub struct AuxDecoder {
    inner: Decoder,
}

impl AuxDecoder {
    pub fn new(inner: Decoder) -> Self {
        Self { inner }
    }
}

impl InstDecoder for AuxDecoder {
    fn decode<M: Memory>(&mut self, memory: &mut M, pc: u64) -> Result<Instruction, Error> {
        let head_inst = self.inner.decode(memory, pc)?;
        match extract_opcode(head_inst) {
            insts::OP_AUIPC => {
                let i = Utype(head_inst);
                let head_len = instruction_length(head_inst);
                let value = pc.wrapping_add(i64::from(i.immediate_s()) as u64);
                if let Ok(value) = value.try_into() {
                    return Ok(set_instruction_length_n(
                        Utype::new(insts::OP_CUSTOM_LOAD_UIMM, i.rd(), value).0,
                        head_len,
                    ));
                }
            }
            _ => (),
        };

        Ok(head_inst)
    }

    fn reset_instructions_cache(&mut self) -> Result<(), Error> {
        self.inner.reset_instructions_cache()
    }
}

#[test]
pub fn test_rust_auipc_fusion() {
    let buffer = fs::read("tests/programs/auipc_no_sign_extend")
        .unwrap()
        .into();

    let core_machine =
        DefaultCoreMachine::<u64, SparseMemory<u64>>::new(ISA_IMC, VERSION1, u64::MAX);
    let mut machine = DefaultMachineBuilder::new(core_machine).build();
    machine
        .load_program(&buffer, [Ok("auipc_no_sign_extend".into())].into_iter())
        .unwrap();

    let mut decoder = AuxDecoder::new(build_decoder::<u64>(machine.isa(), machine.version()));
    let result = machine.run_with_decoder(&mut decoder).unwrap();
    assert_eq!(result, 0);
}

#[cfg(has_asm)]
#[test]
pub fn test_asm_auipc_fusion() {
    let buffer = fs::read("tests/programs/auipc_no_sign_extend")
        .unwrap()
        .into();

    let asm_core = AsmCoreMachine::new(ISA_IMC, VERSION1, u64::MAX);
    let core = DefaultMachineBuilder::<Box<AsmCoreMachine>>::new(asm_core).build();
    let mut machine = AsmMachine::new(core);
    machine
        .load_program(&buffer, [Ok("auipc_no_sign_extend".into())].into_iter())
        .unwrap();

    let decoder = AuxDecoder::new(build_decoder::<u64>(
        machine.machine.isa(),
        machine.machine.version(),
    ));
    let mut decoder = SimpleFixedTraceDecoder::new(decoder);

    let result = machine.run_with_decoder(&mut decoder).expect("run");
    assert_eq!(result, 0);
}


================================================
File: tests/test_b_extension.rs
================================================
use ckb_vm::{machine::VERSION1, ISA_B, ISA_IMC};

pub mod machine_build;

#[test]
pub fn test_clzw_bug() {
    let mut machine =
        machine_build::int("tests/programs/clzw_bug", vec![], VERSION1, ISA_IMC | ISA_B);
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);

    #[cfg(has_asm)]
    {
        let mut machine_asm =
            machine_build::asm("tests/programs/clzw_bug", vec![], VERSION1, ISA_IMC | ISA_B);
        let ret_asm = machine_asm.run();
        assert!(ret_asm.is_ok());
        assert_eq!(ret_asm.unwrap(), 0);
    }
}

#[test]
pub fn test_sbinvi_aot_load_imm_bug() {
    let mut machine = machine_build::int(
        "tests/programs/sbinvi_aot_load_imm_bug",
        vec![],
        VERSION1,
        ISA_IMC | ISA_B,
    );
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);

    #[cfg(has_asm)]
    {
        let mut machine_asm = machine_build::asm(
            "tests/programs/sbinvi_aot_load_imm_bug",
            vec![],
            VERSION1,
            ISA_IMC | ISA_B,
        );
        let ret_asm = machine_asm.run();
        assert!(ret_asm.is_ok());
        assert_eq!(ret_asm.unwrap(), 0);
    }
}

#[test]
pub fn test_rorw_in_end_of_aot_block() {
    // The 1024th instruction will use one more temporary register than normal.
    let mut machine = machine_build::int(
        "tests/programs/rorw_in_end_of_aot_block",
        vec![],
        VERSION1,
        ISA_IMC | ISA_B,
    );
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);

    #[cfg(has_asm)]
    {
        let mut machine_asm = machine_build::asm(
            "tests/programs/rorw_in_end_of_aot_block",
            vec![],
            VERSION1,
            ISA_IMC | ISA_B,
        );
        let ret_asm = machine_asm.run();
        assert!(ret_asm.is_ok());
        assert_eq!(ret_asm.unwrap(), 0);
    }
}

#[test]
pub fn test_pcnt() {
    let mut machine = machine_build::int("tests/programs/pcnt", vec![], VERSION1, ISA_IMC | ISA_B);
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);

    #[cfg(has_asm)]
    {
        let mut machine_asm =
            machine_build::asm("tests/programs/pcnt", vec![], VERSION1, ISA_IMC | ISA_B);
        let ret_asm = machine_asm.run();
        assert!(ret_asm.is_ok());
        assert_eq!(ret_asm.unwrap(), 0);
    }
}

#[test]
pub fn test_clmul_bug() {
    let mut machine = machine_build::int(
        "tests/programs/clmul_bug",
        vec![],
        VERSION1,
        ISA_IMC | ISA_B,
    );
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);

    #[cfg(has_asm)]
    {
        let mut machine_asm = machine_build::asm(
            "tests/programs/clmul_bug",
            vec![],
            VERSION1,
            ISA_IMC | ISA_B,
        );
        let ret_asm = machine_asm.run();
        assert!(ret_asm.is_ok());
        assert_eq!(ret_asm.unwrap(), 0);
    }
}

#[test]
pub fn test_orc_bug() {
    let mut machine =
        machine_build::int("tests/programs/orc_bug", vec![], VERSION1, ISA_IMC | ISA_B);
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);

    #[cfg(has_asm)]
    {
        let mut machine_asm =
            machine_build::asm("tests/programs/orc_bug", vec![], VERSION1, ISA_IMC | ISA_B);
        let ret_asm = machine_asm.run();
        assert!(ret_asm.is_ok());
        assert_eq!(ret_asm.unwrap(), 0);
    }
}


================================================
File: tests/test_dy_memory.rs
================================================
use ckb_vm::{error::OutOfBoundKind, run_with_memory, FlatMemory, SparseMemory};
#[cfg(has_asm)]
use ckb_vm::{
    machine::{
        asm::{AsmCoreMachine, AsmMachine},
        DefaultMachineBuilder, VERSION0, VERSION2,
    },
    ISA_B, ISA_IMC, ISA_MOP,
};
use std::fs;

fn run_memory_suc(memory_size: usize, bin_path: String, bin_name: String) {
    let buffer = fs::read(bin_path).unwrap().into();
    let result = run_with_memory::<u64, SparseMemory<u64>>(
        &buffer,
        &vec![bin_name.clone().into()],
        SparseMemory::new_with_memory(memory_size),
    );
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);

    let result = run_with_memory::<u64, FlatMemory<u64>>(
        &buffer,
        &vec![bin_name.clone().into()],
        FlatMemory::new_with_memory(memory_size),
    );
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);

    #[cfg(has_asm)]
    {
        let asm_core = AsmCoreMachine::new_with_memory(ISA_IMC, VERSION0, u64::MAX, memory_size);
        let core = DefaultMachineBuilder::new(asm_core).build();
        let mut machine = AsmMachine::new(core);
        machine
            .load_program(&buffer, [Ok(bin_name.into())].into_iter())
            .unwrap();
        let result = machine.run();
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), 0);
    }
}

#[test]
fn test_dy_memory() {
    run_memory_suc(
        1024 * 1024 * 2,
        format!("tests/programs/alloc_many"),
        format!("alloc_many"),
    );
}

#[test]
fn test_memory_out_of_bounds() {
    let memory_size = 1024 * 256;
    let buffer = fs::read("tests/programs/alloc_many").unwrap().into();
    let result = run_with_memory::<u64, SparseMemory<u64>>(
        &buffer,
        &vec!["alloc_many".into()],
        SparseMemory::new_with_memory(memory_size),
    );
    assert!(result.is_err());
    assert_eq!(
        ckb_vm::Error::MemOutOfBound(0xfffffffffff3ffb8, OutOfBoundKind::Memory),
        result.err().unwrap()
    );

    let result = run_with_memory::<u64, FlatMemory<u64>>(
        &buffer,
        &vec!["alloc_many".into()],
        FlatMemory::new_with_memory(memory_size),
    );
    assert!(result.is_err());
    assert_eq!(
        ckb_vm::Error::MemOutOfBound(0xfffffffffff3ffb8, OutOfBoundKind::Memory),
        result.err().unwrap()
    );

    #[cfg(has_asm)]
    {
        let asm_core = AsmCoreMachine::new_with_memory(
            ISA_IMC | ISA_B | ISA_MOP,
            VERSION2,
            u64::MAX,
            memory_size,
        );
        let core = DefaultMachineBuilder::new(asm_core).build();
        let mut machine = AsmMachine::new(core);
        machine
            .load_program(&buffer, [Ok("alloc_many".into())].into_iter())
            .unwrap();
        let result = machine.run();
        assert!(result.is_err());
        assert_eq!(
            ckb_vm::Error::MemOutOfBound(0xfffffffffff3ffb8, OutOfBoundKind::Memory),
            result.err().unwrap()
        );
    }
}

#[test]
fn test_memory_min_size() {
    run_memory_suc(
        1024 * 256,
        format!("tests/programs/mulw64"),
        format!("mulw64"),
    );
}

#[test]
fn test_memory_thread_safe() {}


================================================
File: tests/test_error.rs
================================================
use ckb_vm::error::Error;

#[test]
pub fn test_error() {
    assert_eq!(Error::Asm(0).to_string(), "asm error: 0");
    assert_eq!(
        Error::ElfParseError(String::from("abcd")).to_string(),
        "elf error: abcd"
    );
    assert_eq!(
        Error::ElfSegmentUnreadable(0).to_string(),
        "elf error: segment is unreadable vaddr=0x0"
    );
    assert_eq!(
        Error::InvalidInstruction {
            pc: 0,
            instruction: 1
        }
        .to_string(),
        "invalid instruction pc=0x0 instruction=0x1"
    );
    assert_eq!(
        Error::IO {
            kind: std::io::ErrorKind::AddrInUse,
            data: String::from("abcd")
        }
        .to_string(),
        "I/O error: AddrInUse abcd"
    );
}


================================================
File: tests/test_minimal.rs
================================================
use ckb_vm::{run, SparseMemory};
use std::fs;

#[test]
pub fn test_minimal_with_no_args() {
    let buffer = fs::read("tests/programs/minimal").unwrap().into();
    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec!["minimal".into()]);
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 1);
}

#[test]
pub fn test_minimal_with_a() {
    let buffer = fs::read("tests/programs/minimal").unwrap().into();
    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec!["minimal".into(), "a".into()]);
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 2);
}

#[test]
pub fn test_minimal_with_b() {
    let buffer = fs::read("tests/programs/minimal").unwrap().into();
    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec!["minimal".into(), "".into()]);
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
}


================================================
File: tests/test_misc.rs
================================================
use ckb_vm::cost_model::constant_cycles;
use ckb_vm::error::OutOfBoundKind;
use ckb_vm::machine::{VERSION0, VERSION1, VERSION2};
use ckb_vm::registers::{A0, A1, A2, A3, A4, A5, A7};
use ckb_vm::{
    run, CoreMachine, Debugger, DefaultCoreMachine, DefaultMachineBuilder, Error, FlatMemory,
    Memory, Register, SparseMemory, SupportMachine, Syscalls, WXorXMemory, DEFAULT_MEMORY_SIZE,
    ISA_B, ISA_IMC, RISCV_PAGESIZE,
};
#[cfg(has_asm)]
use ckb_vm_definitions::asm::AsmCoreMachine;
use rand::{thread_rng, Rng};
use std::fs;
use std::sync::atomic::{AtomicU8, Ordering};
use std::sync::Arc;
pub mod machine_build;

#[test]
pub fn test_andi() {
    let buffer = fs::read("tests/programs/andi").unwrap().into();
    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec!["andi".into()]);
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
}

#[test]
pub fn test_nop() {
    let buffer = fs::read("tests/programs/nop").unwrap().into();
    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec!["nop".into()]);
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
}

pub struct CustomSyscall {}

impl<Mac: SupportMachine> Syscalls<Mac> for CustomSyscall {
    fn initialize(&mut self, _machine: &mut Mac) -> Result<(), Error> {
        Ok(())
    }

    fn ecall(&mut self, machine: &mut Mac) -> Result<bool, Error> {
        let code = &machine.registers()[A7];
        if code.to_i32() != 1111 {
            return Ok(false);
        }
        let result = machine.registers()[A0]
            .overflowing_add(&machine.registers()[A1])
            .overflowing_add(&machine.registers()[A2])
            .overflowing_add(&machine.registers()[A3])
            .overflowing_add(&machine.registers()[A4])
            .overflowing_add(&machine.registers()[A5]);
        machine.set_register(A0, result);
        Ok(true)
    }
}

#[test]
pub fn test_custom_syscall() {
    let buffer = fs::read("tests/programs/syscall64").unwrap().into();
    let core_machine =
        DefaultCoreMachine::<u64, SparseMemory<u64>>::new(ISA_IMC, VERSION0, u64::MAX);
    let mut machine = DefaultMachineBuilder::new(core_machine)
        .syscall(Box::new(CustomSyscall {}))
        .build();
    machine
        .load_program(&buffer, [Ok("syscall".into())].into_iter())
        .unwrap();
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 39);
}

pub struct CustomDebugger {
    pub value: Arc<AtomicU8>,
}

impl<Mac: SupportMachine> Debugger<Mac> for CustomDebugger {
    fn initialize(&mut self, _machine: &mut Mac) -> Result<(), Error> {
        self.value.store(1, Ordering::Relaxed);
        Ok(())
    }

    fn ebreak(&mut self, _machine: &mut Mac) -> Result<(), Error> {
        self.value.store(2, Ordering::Relaxed);
        Ok(())
    }
}

#[test]
pub fn test_ebreak() {
    let buffer = fs::read("tests/programs/ebreak64").unwrap().into();
    let value = Arc::new(AtomicU8::new(0));
    let core_machine =
        DefaultCoreMachine::<u64, SparseMemory<u64>>::new(ISA_IMC, VERSION0, u64::MAX);
    let mut machine = DefaultMachineBuilder::new(core_machine)
        .debugger(Box::new(CustomDebugger {
            value: Arc::clone(&value),
        }))
        .build();
    machine
        .load_program(&buffer, [Ok("ebreak".into())].into_iter())
        .unwrap();
    assert_eq!(value.load(Ordering::Relaxed), 1);
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(value.load(Ordering::Relaxed), 2);
}

#[test]
pub fn test_trace() {
    let buffer = fs::read("tests/programs/trace64").unwrap().into();
    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec!["trace64".into()]);
    assert!(result.is_err());
    assert_eq!(result.err(), Some(Error::MemWriteOnExecutablePage(16)));
}

#[test]
pub fn test_jump0() {
    let buffer = fs::read("tests/programs/jump0_64").unwrap().into();
    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec!["jump0_64".into()]);
    assert!(result.is_err());
    assert_eq!(result.err(), Some(Error::MemWriteOnExecutablePage(0)));
}

#[test]
pub fn test_misaligned_jump64() {
    let buffer = fs::read("tests/programs/misaligned_jump64").unwrap().into();
    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec!["misaligned_jump64".into()]);
    assert!(result.is_ok());
}

#[test]
pub fn test_mulw64() {
    let buffer = fs::read("tests/programs/mulw64").unwrap().into();
    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec!["mulw64".into()]);
    assert!(result.is_ok());
}

#[test]
pub fn test_invalid_file_offset64() {
    let buffer = fs::read("tests/programs/invalid_file_offset64")
        .unwrap()
        .into();
    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec!["invalid_file_offset64".into()]);
    assert_eq!(
        result.err(),
        Some(Error::ElfSegmentAddrOrSizeError(0x10000))
    );
}

#[test]
#[cfg_attr(all(miri, feature = "miri-ci"), ignore)]
pub fn test_op_rvc_srli_crash_32() {
    let buffer = fs::read("tests/programs/op_rvc_srli_crash_32")
        .unwrap()
        .into();
    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec!["op_rvc_srli_crash_32".into()]);
    assert_eq!(result.err(), Some(Error::MemWriteOnExecutablePage(0)));
}

#[test]
#[cfg_attr(all(miri, feature = "miri-ci"), ignore)]
pub fn test_op_rvc_srai_crash_32() {
    let buffer = fs::read("tests/programs/op_rvc_srai_crash_32")
        .unwrap()
        .into();
    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec!["op_rvc_srai_crash_32".into()]);
    assert!(result.is_ok());
}

#[test]
#[cfg_attr(all(miri, feature = "miri-ci"), ignore)]
pub fn test_op_rvc_slli_crash_32() {
    let buffer = fs::read("tests/programs/op_rvc_slli_crash_32")
        .unwrap()
        .into();
    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec!["op_rvc_slli_crash_32".into()]);
    assert!(result.is_ok());
}

#[test]
pub fn test_load_elf_crash_64() {
    let buffer = fs::read("tests/programs/load_elf_crash_64").unwrap().into();
    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec!["load_elf_crash_64".into()]);
    assert_eq!(result.err(), Some(Error::MemWriteOnExecutablePage(16)));
}

#[test]
pub fn test_wxorx_crash_64() {
    let buffer = fs::read("tests/programs/wxorx_crash_64").unwrap().into();
    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec!["wxorx_crash_64".into()]);
    assert_eq!(
        result.err(),
        Some(Error::MemOutOfBound(
            0xffffffffffffffff,
            OutOfBoundKind::Memory
        ))
    );
}

#[test]
pub fn test_flat_crash_64() {
    let buffer = fs::read("tests/programs/flat_crash_64").unwrap().into();
    let core_machine = DefaultCoreMachine::<u64, FlatMemory<u64>>::new(ISA_IMC, VERSION0, u64::MAX);
    let mut machine = DefaultMachineBuilder::new(core_machine).build();
    let result = machine.load_program(&buffer, [Ok("flat_crash_64".into())].into_iter());
    assert_eq!(
        result.err(),
        Some(Error::MemOutOfBound(0x1100000000, OutOfBoundKind::Memory))
    );
}

#[test]
pub fn test_memory_store_empty_bytes() {
    assert_memory_store_empty_bytes(&mut FlatMemory::<u64>::default());
    assert_memory_store_empty_bytes(&mut SparseMemory::<u64>::default());
    assert_memory_store_empty_bytes(&mut WXorXMemory::<FlatMemory<u64>>::default());
    #[cfg(has_asm)]
    assert_memory_store_empty_bytes(&mut AsmCoreMachine::new(ISA_IMC, VERSION0, 200_000));
}

fn assert_memory_store_empty_bytes<M: Memory>(memory: &mut M) {
    assert!(memory.store_byte(0, 0, 42).is_ok());
    assert!(memory.store_bytes(0, &[]).is_ok());
}

#[test]
pub fn test_memory_load_bytes() {
    let mut rng = thread_rng();

    assert_memory_load_bytes_all(&mut rng, DEFAULT_MEMORY_SIZE, 1024 * 5, 0);
    assert_memory_load_bytes_all(&mut rng, DEFAULT_MEMORY_SIZE, 1024 * 5, 2);
    assert_memory_load_bytes_all(&mut rng, DEFAULT_MEMORY_SIZE, 1024 * 5, 1024 * 6);
    assert_memory_load_bytes_all(&mut rng, DEFAULT_MEMORY_SIZE, 0, 0);
}

fn assert_memory_load_bytes_all<R: Rng>(
    rng: &mut R,
    max_memory: usize,
    buf_size: usize,
    addr: u64,
) {
    assert_memory_load_bytes(
        rng,
        &mut SparseMemory::<u64>::new_with_memory(max_memory),
        buf_size,
        addr,
    );
    assert_memory_load_bytes(
        rng,
        &mut FlatMemory::<u64>::new_with_memory(max_memory),
        buf_size,
        addr,
    );
    assert_memory_load_bytes(
        rng,
        &mut WXorXMemory::new(FlatMemory::<u64>::new_with_memory(max_memory)),
        buf_size,
        addr,
    );

    #[cfg(has_asm)]
    assert_memory_load_bytes(
        rng,
        &mut AsmCoreMachine::new(ISA_IMC, VERSION0, 200_000),
        buf_size,
        addr,
    );
}

fn assert_memory_load_bytes<R: Rng, M: Memory>(
    rng: &mut R,
    memory: &mut M,
    buffer_size: usize,
    addr: u64,
) {
    let mut buffer_store = Vec::<u8>::new();
    buffer_store.resize(buffer_size, 0);
    rng.fill(buffer_store.as_mut_slice());

    memory
        .store_bytes(addr, &buffer_store.as_slice())
        .expect("store bytes failed");

    let buffer_load = memory
        .load_bytes(addr, buffer_store.len() as u64)
        .expect("load bytes failed")
        .to_vec();

    assert!(buffer_load.cmp(&buffer_store).is_eq());

    // length out of bound
    let outofbound_size = if buffer_store.is_empty() {
        memory.memory_size() + 1
    } else {
        buffer_store.len() + memory.memory_size()
    };
    let ret = memory.load_bytes(addr, outofbound_size as u64);
    assert!(ret.is_err());
    // TODO: For randomized tests, the exact address violating memory out of bound
    // error, is hard to derive(and will also heavily depend on implementation logic),
    // do we really need to assert the exact value causing out-of-bound error here?
    assert!(match ret.unwrap_err() {
        Error::MemOutOfBound(_, kind) => kind == OutOfBoundKind::Memory,
        _ => false,
    });

    // address out of bound
    let ret = memory.load_bytes(
        addr + memory.memory_size() as u64 + 1,
        buffer_store.len() as u64,
    );
    if buffer_store.is_empty() {
        assert!(ret.is_ok())
    } else {
        assert!(ret.is_err());
        assert!(match ret.unwrap_err() {
            Error::MemOutOfBound(_, kind) => kind == OutOfBoundKind::Memory,
            _ => false,
        });
    }

    // addr + size is overflow
    let ret = memory.load_bytes(addr + (0xFFFFFFFFFFFFFF - addr), buffer_store.len() as u64);
    if buffer_store.is_empty() {
        assert!(ret.is_ok());
    } else {
        assert!(ret.is_err());
        assert!(match ret.unwrap_err() {
            Error::MemOutOfBound(_, kind) => kind == OutOfBoundKind::Memory,
            _ => false,
        });
    }
}

pub fn test_contains_ckbforks_section() {
    let buffer = fs::read("tests/programs/ckbforks").unwrap();
    let ckbforks_exists_v0 = || -> bool {
        let elf = goblin_v023::elf::Elf::parse(&buffer).unwrap();
        for section_header in &elf.section_headers {
            if let Some(Ok(r)) = elf.shdr_strtab.get(section_header.sh_name) {
                if r == ".ckb.forks" {
                    return true;
                }
            }
        }
        return false;
    }();
    let ckbforks_exists_v1 = || -> bool {
        let elf = goblin_v040::elf::Elf::parse(&buffer).unwrap();
        for section_header in &elf.section_headers {
            if let Some(Ok(r)) = elf.shdr_strtab.get(section_header.sh_name) {
                if r == ".ckb.forks" {
                    return true;
                }
            }
        }
        return false;
    }();
    assert_eq!(ckbforks_exists_v0, true);
    assert_eq!(ckbforks_exists_v1, true);
}

#[test]
pub fn test_rvc_pageend() {
    // The last instruction of a executable memory page is an RVC instruction.
    let buffer = fs::read("tests/programs/rvc_pageend").unwrap().into();
    let core_machine =
        DefaultCoreMachine::<u64, SparseMemory<u64>>::new(ISA_IMC, VERSION0, u64::MAX);
    let mut machine = DefaultMachineBuilder::new(core_machine).build();
    machine
        .load_program(&buffer, [Ok("rvc_end".into())].into_iter())
        .unwrap();

    let anchor_pc: u64 = 69630;
    // Ensure that anchor_pc is in the end of the page
    assert_eq!(anchor_pc as usize % RISCV_PAGESIZE, RISCV_PAGESIZE - 2);
    let memory = machine.memory_mut();
    // Ensure that the data segment is located at anchor_pc + 2
    let data0 = memory.load16(&(anchor_pc + 2)).unwrap().to_u32();
    assert_eq!(data0, 4);
    let data1 = memory.load16(&(anchor_pc + 6)).unwrap().to_u32();
    assert_eq!(data1, 2);
    // Ensure that the anchor instruction is "c.jr a0"
    let anchor_inst = memory.load16(&anchor_pc).unwrap().to_u16();
    assert_eq!(anchor_inst, 0x8502);

    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
}

pub struct OutOfCyclesSyscall {}

impl<Mac: SupportMachine> Syscalls<Mac> for OutOfCyclesSyscall {
    fn initialize(&mut self, _machine: &mut Mac) -> Result<(), Error> {
        Ok(())
    }

    fn ecall(&mut self, machine: &mut Mac) -> Result<bool, Error> {
        let code = &machine.registers()[A7];
        if code.to_i32() != 1111 {
            return Ok(false);
        }
        machine.add_cycles_no_checking(100)?;
        let result = machine.registers()[A0]
            .overflowing_add(&machine.registers()[A1])
            .overflowing_add(&machine.registers()[A2])
            .overflowing_add(&machine.registers()[A3])
            .overflowing_add(&machine.registers()[A4])
            .overflowing_add(&machine.registers()[A5]);
        machine.set_register(A0, result);
        Ok(true)
    }
}

#[test]
pub fn test_outofcycles_in_syscall() {
    let buffer = fs::read("tests/programs/syscall64").unwrap().into();
    let core_machine = DefaultCoreMachine::<u64, SparseMemory<u64>>::new(ISA_IMC, VERSION0, 20);
    let mut machine = DefaultMachineBuilder::new(core_machine)
        .instruction_cycle_func(Box::new(constant_cycles))
        .syscall(Box::new(OutOfCyclesSyscall {}))
        .build();
    machine
        .load_program(&buffer, [Ok("syscall".into())].into_iter())
        .unwrap();
    let result = machine.run();
    assert!(result.is_err());
    assert_eq!(result.unwrap_err(), Error::CyclesExceeded);
    assert_eq!(machine.cycles(), 108);
    assert_eq!(machine.registers()[A0], 39);
}

#[test]
pub fn test_clang() {
    {
        let mut machine = machine_build::int(
            "tests/programs/clang_sample",
            vec![],
            VERSION1,
            ISA_IMC | ISA_B,
        );
        let ret = machine.run();
        assert!(ret.is_ok());
    }

    #[cfg(has_asm)]
    {
        let mut machine_asm = machine_build::asm(
            "tests/programs/clang_sample",
            vec![],
            VERSION1,
            ISA_IMC | ISA_B,
        );
        let ret_asm = machine_asm.run();
        assert!(ret_asm.is_ok());
    }

    {
        let mut machine = machine_build::int(
            "tests/programs/clang_sample",
            vec![],
            VERSION2,
            ISA_IMC | ISA_B,
        );
        let ret = machine.run();
        assert!(ret.is_ok());
    }

    #[cfg(has_asm)]
    {
        let mut machine_asm = machine_build::asm(
            "tests/programs/clang_sample",
            vec![],
            VERSION2,
            ISA_IMC | ISA_B,
        );
        let ret_asm = machine_asm.run();
        assert!(ret_asm.is_ok());
    }
}


================================================
File: tests/test_mop.rs
================================================
pub mod machine_build;
use bytes::Bytes;
use ckb_vm::error::OutOfBoundKind;
use ckb_vm::machine::{VERSION1, VERSION2};
use ckb_vm::{registers::A0, CoreMachine, Error, SupportMachine, ISA_B, ISA_IMC, ISA_MOP};

#[test]
#[cfg_attr(miri, ignore)]
pub fn test_mop_wide_multiply() {
    let mut machine = machine_build::int(
        "tests/programs/mop_wide_multiply",
        vec![],
        VERSION1,
        ISA_IMC | ISA_B,
    );
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);

    let mut machine = machine_build::int(
        "tests/programs/mop_wide_multiply",
        vec![],
        VERSION1,
        ISA_IMC | ISA_B | ISA_MOP,
    );
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);
    assert_eq!(machine.machine.cycles(), 9192427);

    #[cfg(has_asm)]
    {
        let mut machine_asm = machine_build::asm(
            "tests/programs/mop_wide_multiply",
            vec![],
            VERSION1,
            ISA_IMC | ISA_B | ISA_MOP,
        );
        let ret_asm = machine_asm.run();
        assert!(ret_asm.is_ok());
        assert_eq!(ret_asm.unwrap(), 0);
        assert_eq!(machine_asm.machine.cycles(), 9192427);
    }
}

#[test]
#[cfg_attr(miri, ignore)]
pub fn test_mop_wide_divide() {
    let mut machine = machine_build::int(
        "tests/programs/mop_wide_divide",
        vec![],
        VERSION1,
        ISA_IMC | ISA_B,
    );
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);

    let mut machine = machine_build::int(
        "tests/programs/mop_wide_divide",
        vec![],
        VERSION1,
        ISA_IMC | ISA_B | ISA_MOP,
    );
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);
    assert_eq!(machine.machine.cycles(), 6106583);

    #[cfg(has_asm)]
    {
        let mut machine_asm = machine_build::asm(
            "tests/programs/mop_wide_divide",
            vec![],
            VERSION1,
            ISA_IMC | ISA_B | ISA_MOP,
        );
        let ret_asm = machine_asm.run();
        assert!(ret_asm.is_ok());
        assert_eq!(ret_asm.unwrap(), 0);
        assert_eq!(machine_asm.machine.cycles(), 6106583);
    }
}

#[test]
pub fn test_mop_far_jump() {
    let mut machine = machine_build::int(
        "tests/programs/mop_far_jump",
        vec![],
        VERSION1,
        ISA_IMC | ISA_B,
    );
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);

    let mut machine = machine_build::int(
        "tests/programs/mop_far_jump",
        vec![],
        VERSION1,
        ISA_IMC | ISA_B | ISA_MOP,
    );
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);
    assert_eq!(machine.machine.cycles(), 5);

    #[cfg(has_asm)]
    {
        let mut machine_asm = machine_build::asm(
            "tests/programs/mop_far_jump",
            vec![],
            VERSION1,
            ISA_IMC | ISA_B | ISA_MOP,
        );
        let ret_asm = machine_asm.run();
        assert!(ret_asm.is_ok());
        assert_eq!(ret_asm.unwrap(), 0);
        assert_eq!(machine_asm.machine.cycles(), 5);
    }
}

#[test]
#[cfg_attr(miri, ignore)]
pub fn test_mop_ld_32_constants() {
    let mut machine = machine_build::int(
        "tests/programs/mop_ld_signextend_32",
        vec![],
        VERSION1,
        ISA_IMC | ISA_B,
    );
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);

    let mut machine = machine_build::int(
        "tests/programs/mop_ld_signextend_32",
        vec![],
        VERSION1,
        ISA_IMC | ISA_B | ISA_MOP,
    );
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);

    #[cfg(has_asm)]
    {
        let mut machine_asm = machine_build::asm(
            "tests/programs/mop_ld_signextend_32",
            vec![],
            VERSION1,
            ISA_IMC | ISA_B | ISA_MOP,
        );
        let ret_asm = machine_asm.run();
        assert!(ret_asm.is_ok());
        assert_eq!(ret_asm.unwrap(), 0);
    }
}

#[test]
#[cfg_attr(miri, ignore)]
pub fn test_mop_secp256k1() {
    let args = vec![
        Bytes::from("033f8cf9c4d51a33206a6c1c6b27d2cc5129daa19dbd1fc148d395284f6b26411f"),
        Bytes::from("304402203679d909f43f073c7c1dcf8468a485090589079ee834e6eed92fea9b09b06a2402201e46f1075afa18f306715e7db87493e7b7e779569aa13c64ab3d09980b3560a3"),
        Bytes::from("foo"),
        Bytes::from("bar"),
    ];

    let mut machine = machine_build::int(
        "benches/data/secp256k1_bench",
        args.clone(),
        VERSION1,
        ISA_IMC | ISA_B | ISA_MOP,
    );
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);
    assert_eq!(machine.machine.cycles(), 611871);

    let mut machine = machine_build::int(
        "benches/data/secp256k1_bench",
        args.clone(),
        VERSION2,
        ISA_IMC | ISA_B | ISA_MOP,
    );
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);
    assert_eq!(machine.machine.cycles(), 576608);

    #[cfg(has_asm)]
    {
        let mut machine_asm = machine_build::asm(
            "benches/data/secp256k1_bench",
            args.clone(),
            VERSION1,
            ISA_IMC | ISA_B | ISA_MOP,
        );
        let ret_asm = machine_asm.run();
        assert!(ret_asm.is_ok());
        assert_eq!(ret_asm.unwrap(), 0);
        assert_eq!(machine_asm.machine.cycles(), 611871);

        let mut machine_asm = machine_build::asm(
            "benches/data/secp256k1_bench",
            args.clone(),
            VERSION2,
            ISA_IMC | ISA_B | ISA_MOP,
        );
        let ret_asm = machine_asm.run();
        assert!(ret_asm.is_ok());
        assert_eq!(ret_asm.unwrap(), 0);
        assert_eq!(machine_asm.machine.cycles(), 576608);
    }
}

#[test]
pub fn test_mop_adc() {
    let mut machine =
        machine_build::int("tests/programs/mop_adc", vec![], VERSION1, ISA_IMC | ISA_B);
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);
    assert_eq!(machine.machine.cycles(), 73);

    let mut machine = machine_build::int(
        "tests/programs/mop_adc",
        vec![],
        VERSION1,
        ISA_IMC | ISA_B | ISA_MOP,
    );
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);
    assert_eq!(machine.machine.cycles(), 61);

    #[cfg(has_asm)]
    {
        let mut machine_asm = machine_build::asm(
            "tests/programs/mop_adc",
            vec![],
            VERSION1,
            ISA_IMC | ISA_B | ISA_MOP,
        );
        let ret_asm = machine_asm.run();
        assert!(ret_asm.is_ok());
        assert_eq!(ret_asm.unwrap(), 0);
        assert_eq!(machine_asm.machine.cycles(), 61);
    }
}

#[test]
pub fn test_mop_adcs() {
    let mut machine =
        machine_build::int("tests/programs/mop_adcs", vec![], VERSION1, ISA_IMC | ISA_B);
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);
    assert_eq!(machine.machine.cycles(), 53);

    let mut machine = machine_build::int(
        "tests/programs/mop_adcs",
        vec![],
        VERSION1,
        ISA_IMC | ISA_B | ISA_MOP,
    );
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);
    assert_eq!(machine.machine.cycles(), 53);

    let mut machine = machine_build::int(
        "tests/programs/mop_adcs",
        vec![],
        VERSION2,
        ISA_IMC | ISA_B | ISA_MOP,
    );
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);
    assert_eq!(machine.machine.cycles(), 47);

    #[cfg(has_asm)]
    {
        let mut machine_asm = machine_build::asm(
            "tests/programs/mop_adcs",
            vec![],
            VERSION1,
            ISA_IMC | ISA_B | ISA_MOP,
        );
        let ret_asm = machine_asm.run();
        assert!(ret_asm.is_ok());
        assert_eq!(ret_asm.unwrap(), 0);
        assert_eq!(machine_asm.machine.cycles(), 53);

        let mut machine_asm = machine_build::asm(
            "tests/programs/mop_adcs",
            vec![],
            VERSION2,
            ISA_IMC | ISA_B | ISA_MOP,
        );
        let ret_asm = machine_asm.run();
        assert!(ret_asm.is_ok());
        assert_eq!(ret_asm.unwrap(), 0);
        assert_eq!(machine_asm.machine.cycles(), 47);
    }
}

#[test]
pub fn test_mop_add3() {
    let mut machine =
        machine_build::int("tests/programs/mop_add3", vec![], VERSION1, ISA_IMC | ISA_B);
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0, "Machine state: {}", machine.machine);
    assert_eq!(machine.machine.cycles(), 1047);

    let mut machine = machine_build::int(
        "tests/programs/mop_add3",
        vec![],
        VERSION1,
        ISA_IMC | ISA_B | ISA_MOP,
    );
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);
    assert_eq!(machine.machine.cycles(), 939);

    let mut machine = machine_build::int(
        "tests/programs/mop_add3",
        vec![],
        VERSION2,
        ISA_IMC | ISA_B | ISA_MOP,
    );
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);
    assert_eq!(machine.machine.cycles(), 903);

    #[cfg(has_asm)]
    {
        let mut machine_asm = machine_build::asm(
            "tests/programs/mop_add3",
            vec![],
            VERSION1,
            ISA_IMC | ISA_B | ISA_MOP,
        );
        let ret_asm = machine_asm.run();
        assert!(ret_asm.is_ok());
        assert_eq!(ret_asm.unwrap(), 0);
        assert_eq!(machine_asm.machine.cycles(), 939);

        let mut machine_asm = machine_build::asm(
            "tests/programs/mop_add3",
            vec![],
            VERSION2,
            ISA_IMC | ISA_B | ISA_MOP,
        );
        let ret_asm = machine_asm.run();
        assert!(ret_asm.is_ok());
        assert_eq!(ret_asm.unwrap(), 0);
        assert_eq!(machine_asm.machine.cycles(), 903);
    }
}

#[test]
pub fn test_mop_sbb() {
    let mut machine =
        machine_build::int("tests/programs/mop_sbb", vec![], VERSION1, ISA_IMC | ISA_B);
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);
    assert_eq!(machine.machine.cycles(), 35);

    let mut machine = machine_build::int(
        "tests/programs/mop_sbb",
        vec![],
        VERSION1,
        ISA_IMC | ISA_B | ISA_MOP,
    );
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);
    assert_eq!(machine.machine.cycles(), 27);

    #[cfg(has_asm)]
    {
        let mut machine_asm = machine_build::asm(
            "tests/programs/mop_sbb",
            vec![],
            VERSION1,
            ISA_IMC | ISA_B | ISA_MOP,
        );
        let ret_asm = machine_asm.run();
        assert!(ret_asm.is_ok());
        assert_eq!(ret_asm.unwrap(), 0);
        assert_eq!(machine_asm.machine.cycles(), 27);
    }
}

#[test]
pub fn test_mop_sbbs() {
    let mut machine =
        machine_build::int("tests/programs/mop_sbbs", vec![], VERSION1, ISA_IMC | ISA_B);
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0, "Machine state: {}", machine.machine);
    assert_eq!(machine.machine.cycles(), 87);

    let mut machine = machine_build::int(
        "tests/programs/mop_sbbs",
        vec![],
        VERSION1,
        ISA_IMC | ISA_B | ISA_MOP,
    );
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);
    assert_eq!(machine.machine.cycles(), 81);

    let mut machine = machine_build::int(
        "tests/programs/mop_sbbs",
        vec![],
        VERSION2,
        ISA_IMC | ISA_B | ISA_MOP,
    );
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);
    assert_eq!(machine.machine.cycles(), 76);

    #[cfg(has_asm)]
    {
        let mut machine_asm = machine_build::asm(
            "tests/programs/mop_sbbs",
            vec![],
            VERSION1,
            ISA_IMC | ISA_B | ISA_MOP,
        );
        let ret_asm = machine_asm.run();
        assert!(ret_asm.is_ok());
        assert_eq!(ret_asm.unwrap(), 0);
        assert_eq!(machine_asm.machine.cycles(), 81);

        let mut machine_asm = machine_build::asm(
            "tests/programs/mop_sbbs",
            vec![],
            VERSION2,
            ISA_IMC | ISA_B | ISA_MOP,
        );
        let ret_asm = machine_asm.run();
        assert!(ret_asm.is_ok());
        assert_eq!(ret_asm.unwrap(), 0);
        assert_eq!(machine_asm.machine.cycles(), 76);
    }
}

#[test]
pub fn test_mop_random_adc_sbb() {
    let mut machine = machine_build::int(
        "tests/programs/mop_random_adc_sbb",
        vec![],
        VERSION1,
        ISA_IMC | ISA_B,
    );
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);
    assert_eq!(machine.machine.cycles(), 9458);

    let mut machine = machine_build::int(
        "tests/programs/mop_random_adc_sbb",
        vec![],
        VERSION1,
        ISA_IMC | ISA_B | ISA_MOP,
    );
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);
    assert_eq!(machine.machine.cycles(), 6755);

    let mut machine = machine_build::int(
        "tests/programs/mop_random_adc_sbb",
        vec![],
        VERSION2,
        ISA_IMC | ISA_B | ISA_MOP,
    );
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);
    assert_eq!(machine.machine.cycles(), 6561);

    #[cfg(has_asm)]
    {
        let mut machine_asm = machine_build::asm(
            "tests/programs/mop_random_adc_sbb",
            vec![],
            VERSION1,
            ISA_IMC | ISA_B | ISA_MOP,
        );
        let ret_asm = machine_asm.run();
        assert!(ret_asm.is_ok());
        assert_eq!(ret_asm.unwrap(), 0);
        assert_eq!(machine_asm.machine.cycles(), 6755);

        let mut machine_asm = machine_build::asm(
            "tests/programs/mop_random_adc_sbb",
            vec![],
            VERSION2,
            ISA_IMC | ISA_B | ISA_MOP,
        );
        let ret_asm = machine_asm.run();
        assert!(ret_asm.is_ok());
        assert_eq!(ret_asm.unwrap(), 0);
        assert_eq!(machine_asm.machine.cycles(), 6561);
    }
}

#[test]
pub fn test_mop_ld_signextend_32_overflow_bug() {
    let mut machine = machine_build::int(
        "tests/programs/mop_ld_signextend_32_overflow_bug",
        vec![],
        VERSION1,
        ISA_IMC | ISA_B | ISA_MOP,
    );
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);

    #[cfg(has_asm)]
    {
        let mut machine_asm = machine_build::asm(
            "tests/programs/mop_ld_signextend_32_overflow_bug",
            vec![],
            VERSION1,
            ISA_IMC | ISA_B | ISA_MOP,
        );
        let ret_asm = machine_asm.run();
        assert!(ret_asm.is_ok());
        assert_eq!(ret_asm.unwrap(), 0);
    }
}

#[test]
pub fn test_mop_wide_mul_zero() {
    let mut machine = machine_build::int(
        "tests/programs/mop_wide_mul_zero",
        vec![],
        VERSION1,
        ISA_IMC | ISA_B | ISA_MOP,
    );
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);

    #[cfg(has_asm)]
    {
        let mut machine_asm = machine_build::asm(
            "tests/programs/mop_wide_mul_zero",
            vec![],
            VERSION1,
            ISA_IMC | ISA_B | ISA_MOP,
        );
        let ret_asm = machine_asm.run();
        assert!(ret_asm.is_ok());
        assert_eq!(ret_asm.unwrap(), 0);
    }
}

#[test]
pub fn test_mop_wide_div_zero() {
    let mut machine = machine_build::int(
        "tests/programs/mop_wide_div_zero",
        vec![],
        VERSION1,
        ISA_IMC | ISA_B | ISA_MOP,
    );
    let ret = machine.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);

    #[cfg(has_asm)]
    {
        let mut machine_asm = machine_build::asm(
            "tests/programs/mop_wide_div_zero",
            vec![],
            VERSION1,
            ISA_IMC | ISA_B | ISA_MOP,
        );
        let ret_asm = machine_asm.run();
        assert!(ret_asm.is_ok());
        assert_eq!(ret_asm.unwrap(), 0);
    }
}

#[test]
pub fn test_mop_jump_rel_version1_bug() {
    let mut machine = machine_build::int(
        "tests/programs/mop_jump_rel_version1_bug",
        vec![],
        VERSION1,
        ISA_IMC | ISA_B,
    );
    let ret = machine.run();
    assert_eq!(
        ret,
        Err(Error::MemOutOfBound(
            0xffffffff8000f878,
            OutOfBoundKind::Memory
        ))
    );
    assert_eq!(*machine.pc(), 0xffffffff8000f878);

    let mut machine = machine_build::int(
        "tests/programs/mop_jump_rel_version1_bug",
        vec![],
        VERSION1,
        ISA_IMC | ISA_B | ISA_MOP,
    );
    let ret = machine.run();
    assert_eq!(
        ret,
        Err(Error::MemOutOfBound(0x8000f878, OutOfBoundKind::Memory))
    );
    assert_eq!(*machine.pc(), 0x8000f878);

    let mut machine = machine_build::int(
        "tests/programs/mop_jump_rel_version1_bug",
        vec![],
        VERSION2,
        ISA_IMC | ISA_B | ISA_MOP,
    );
    let ret = machine.run();
    assert_eq!(
        ret,
        Err(Error::MemOutOfBound(
            0xffffffff8000f878,
            OutOfBoundKind::Memory
        ))
    );
    assert_eq!(*machine.pc(), 0xffffffff8000f878);

    #[cfg(has_asm)]
    {
        let mut machine_asm = machine_build::asm(
            "tests/programs/mop_jump_rel_version1_bug",
            vec![],
            VERSION1,
            ISA_IMC | ISA_B | ISA_MOP,
        );
        let ret_asm = machine_asm.run();
        assert_eq!(
            ret_asm,
            Err(Error::MemOutOfBound(0x8000f878, OutOfBoundKind::Memory))
        );
        assert_eq!(*machine_asm.machine.pc(), 0x8000f878);

        let mut machine_asm = machine_build::asm(
            "tests/programs/mop_jump_rel_version1_bug",
            vec![],
            VERSION2,
            ISA_IMC | ISA_B | ISA_MOP,
        );
        let ret_asm = machine_asm.run();
        assert_eq!(
            ret_asm,
            Err(Error::MemOutOfBound(
                0xffffffff8000f878,
                OutOfBoundKind::Memory
            ))
        );
        assert_eq!(*machine_asm.machine.pc(), 0xffffffff8000f878);
    }
}

#[test]
pub fn test_mop_jump_rel_version1_reg_not_updated_bug() {
    let mut machine = machine_build::int(
        "tests/programs/mop_jump_rel_version1_reg_not_updated_bug",
        vec![],
        VERSION1,
        ISA_IMC | ISA_B,
    );
    let ret = machine.run();
    assert_eq!(
        ret,
        Err(Error::MemOutOfBound(0x401054a, OutOfBoundKind::Memory))
    );
    assert_eq!(machine.registers()[A0], 67174520);

    let mut machine = machine_build::int(
        "tests/programs/mop_jump_rel_version1_reg_not_updated_bug",
        vec![],
        VERSION1,
        ISA_IMC | ISA_B | ISA_MOP,
    );
    let ret = machine.run();
    assert_eq!(
        ret,
        Err(Error::MemOutOfBound(0x401054a, OutOfBoundKind::Memory))
    );
    assert_eq!(machine.registers()[A0], 0);

    let mut machine = machine_build::int(
        "tests/programs/mop_jump_rel_version1_reg_not_updated_bug",
        vec![],
        VERSION2,
        ISA_IMC | ISA_B | ISA_MOP,
    );
    let ret = machine.run();
    assert_eq!(
        ret,
        Err(Error::MemOutOfBound(0x401054a, OutOfBoundKind::Memory))
    );
    assert_eq!(machine.registers()[A0], 67174520);

    #[cfg(has_asm)]
    {
        let mut machine_asm = machine_build::asm(
            "tests/programs/mop_jump_rel_version1_reg_not_updated_bug",
            vec![],
            VERSION1,
            ISA_IMC | ISA_B | ISA_MOP,
        );
        let ret_asm = machine_asm.run();
        assert_eq!(
            ret_asm,
            Err(Error::MemOutOfBound(0x401054a, OutOfBoundKind::Memory))
        );
        assert_eq!(machine_asm.machine.registers()[A0], 0);

        let mut machine_asm = machine_build::asm(
            "tests/programs/mop_jump_rel_version1_reg_not_updated_bug",
            vec![],
            VERSION2,
            ISA_IMC | ISA_B | ISA_MOP,
        );
        let ret_asm = machine_asm.run();
        assert_eq!(
            ret_asm,
            Err(Error::MemOutOfBound(0x401054a, OutOfBoundKind::Memory))
        );
        assert_eq!(machine_asm.machine.registers()[A0], 67174520);
    }
}

#[test]
pub fn test_mop_jump_abs_version1_reg_not_updated_bug() {
    let mut machine = machine_build::int(
        "tests/programs/mop_jump_abs_version1_reg_not_updated_bug",
        vec![],
        VERSION1,
        ISA_IMC | ISA_B,
    );
    let ret = machine.run();
    assert_eq!(
        ret,
        Err(Error::MemOutOfBound(0x40004d2, OutOfBoundKind::Memory))
    );
    assert_eq!(machine.registers()[A0], 67108864);

    let mut machine = machine_build::int(
        "tests/programs/mop_jump_abs_version1_reg_not_updated_bug",
        vec![],
        VERSION1,
        ISA_IMC | ISA_B | ISA_MOP,
    );
    let ret = machine.run();
    assert_eq!(
        ret,
        Err(Error::MemOutOfBound(0x40004d2, OutOfBoundKind::Memory))
    );
    assert_eq!(machine.registers()[A0], 0);

    let mut machine = machine_build::int(
        "tests/programs/mop_jump_abs_version1_reg_not_updated_bug",
        vec![],
        VERSION2,
        ISA_IMC | ISA_B | ISA_MOP,
    );
    let ret = machine.run();
    assert_eq!(
        ret,
        Err(Error::MemOutOfBound(0x40004d2, OutOfBoundKind::Memory))
    );
    assert_eq!(machine.registers()[A0], 67108864);

    #[cfg(has_asm)]
    {
        let mut machine_asm = machine_build::asm(
            "tests/programs/mop_jump_abs_version1_reg_not_updated_bug",
            vec![],
            VERSION1,
            ISA_IMC | ISA_B | ISA_MOP,
        );
        let ret_asm = machine_asm.run();
        assert_eq!(
            ret_asm,
            Err(Error::MemOutOfBound(0x40004d2, OutOfBoundKind::Memory))
        );
        assert_eq!(machine_asm.machine.registers()[A0], 0);

        let mut machine_asm = machine_build::asm(
            "tests/programs/mop_jump_abs_version1_reg_not_updated_bug",
            vec![],
            VERSION2,
            ISA_IMC | ISA_B | ISA_MOP,
        );
        let ret_asm = machine_asm.run();
        assert_eq!(
            ret_asm,
            Err(Error::MemOutOfBound(0x40004d2, OutOfBoundKind::Memory))
        );
        assert_eq!(machine_asm.machine.registers()[A0], 67108864);
    }
}


================================================
File: tests/test_reset.rs
================================================
use bytes::Bytes;
use ckb_vm::cost_model::constant_cycles;
#[cfg(has_asm)]
use ckb_vm::machine::asm::{AsmCoreMachine, AsmMachine};
use ckb_vm::machine::{DefaultCoreMachine, DefaultMachineBuilder, VERSION1};
use ckb_vm::{
    registers::A7, Error, Register, SparseMemory, SupportMachine, Syscalls, TraceMachine,
    WXorXMemory, DEFAULT_MEMORY_SIZE, ISA_IMC, ISA_MOP,
};

#[allow(dead_code)]
mod machine_build;

pub struct CustomSyscall {}

impl<Mac: SupportMachine> Syscalls<Mac> for CustomSyscall {
    fn initialize(&mut self, _: &mut Mac) -> Result<(), Error> {
        Ok(())
    }

    fn ecall(&mut self, machine: &mut Mac) -> Result<bool, Error> {
        let code = &machine.registers()[A7];
        if code.to_i32() != 1111 {
            return Ok(false);
        }
        let cycles = machine.cycles();
        machine.reset(machine.max_cycles()).expect("reset");
        machine.set_cycles(cycles);
        let code_data = std::fs::read("tests/programs/reset_callee").unwrap();
        let code = Bytes::from(code_data);
        machine.load_elf(&code, true).unwrap();
        machine.initialize_stack(
            [].into_iter(),
            (DEFAULT_MEMORY_SIZE - DEFAULT_MEMORY_SIZE / 4) as u64,
            (DEFAULT_MEMORY_SIZE / 4) as u64,
        )?;
        Ok(true)
    }
}

#[test]
fn test_reset_int() {
    let code_data = std::fs::read("tests/programs/reset_caller").unwrap();
    let code = Bytes::from(code_data);

    let core_machine = DefaultCoreMachine::<u64, WXorXMemory<SparseMemory<u64>>>::new(
        ISA_IMC | ISA_MOP,
        VERSION1,
        u64::MAX,
    );
    let mut machine = DefaultMachineBuilder::new(core_machine)
        .instruction_cycle_func(Box::new(constant_cycles))
        .syscall(Box::new(CustomSyscall {}))
        .build();
    machine.load_program(&code, [].into_iter()).unwrap();
    let result = machine.run();
    let cycles = machine.cycles();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
    assert_eq!(cycles, 775);
}

#[test]
fn test_reset_int_with_trace() {
    let code_data = std::fs::read("tests/programs/reset_caller").unwrap();
    let code = Bytes::from(code_data);

    let core_machine = DefaultCoreMachine::<u64, WXorXMemory<SparseMemory<u64>>>::new(
        ISA_IMC | ISA_MOP,
        VERSION1,
        u64::MAX,
    );
    let mut machine = TraceMachine::new(
        DefaultMachineBuilder::new(core_machine)
            .instruction_cycle_func(Box::new(constant_cycles))
            .syscall(Box::new(CustomSyscall {}))
            .build(),
    );
    machine.load_program(&code, [].into_iter()).unwrap();
    let result = machine.run();
    let cycles = machine.machine.cycles();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
    assert_eq!(cycles, 775);
}

#[test]
#[cfg(has_asm)]
fn test_reset_asm() {
    let code_data = std::fs::read("tests/programs/reset_caller").unwrap();
    let code = Bytes::from(code_data);

    let asm_core = AsmCoreMachine::new(ISA_IMC | ISA_MOP, VERSION1, u64::MAX);
    let core = DefaultMachineBuilder::<Box<AsmCoreMachine>>::new(asm_core)
        .instruction_cycle_func(Box::new(constant_cycles))
        .syscall(Box::new(CustomSyscall {}))
        .build();
    let mut machine = AsmMachine::new(core);
    machine.load_program(&code, [].into_iter()).unwrap();

    let result = machine.run();
    let cycles = machine.machine.cycles();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
    assert_eq!(cycles, 775);
}


================================================
File: tests/test_resume.rs
================================================
#![cfg(has_asm)]
pub mod machine_build;
use bytes::Bytes;
use ckb_vm::cost_model::constant_cycles;
use ckb_vm::machine::asm::{AsmCoreMachine, AsmMachine};
use ckb_vm::machine::trace::TraceMachine;
use ckb_vm::machine::{
    DefaultCoreMachine, DefaultMachine, SupportMachine, VERSION0, VERSION1, VERSION2,
};
use ckb_vm::memory::{sparse::SparseMemory, wxorx::WXorXMemory};
use ckb_vm::snapshot::{make_snapshot, resume, Snapshot};
use ckb_vm::{DefaultMachineBuilder, Error, ISA_A, ISA_IMC};
use std::fs::File;
use std::io::Read;

#[test]
fn test_resume_interpreter_with_trace_2_asm() {
    resume_interpreter_with_trace_2_asm_inner(VERSION1, 8126917);
    resume_interpreter_with_trace_2_asm_inner(VERSION0, 8126917);
}

#[test]
fn test_resume_interpreter_2_asm() {
    resume_interpreter_2_asm(VERSION1, 8126917);
    resume_interpreter_2_asm(VERSION0, 8126917);
}

#[test]
fn test_resume_interpreter_2_interpreter() {
    resume_interpreter_2_interpreter(VERSION1, 8126917);
    resume_interpreter_2_interpreter(VERSION0, 8126917);
}

#[test]
fn test_resume_asm_2_interpreter() {
    resume_asm_2_interpreter(VERSION1, 8126917);
    resume_asm_2_interpreter(VERSION0, 8126917);
}

#[test]
fn test_resume_asm_2_asm_2_asm() {
    resume_asm_2_asm_2_asm(VERSION1, 8126917);
    resume_asm_2_asm_2_asm(VERSION0, 8126917);
}

#[test]
fn test_resume_asm_2_asm() {
    resume_asm_2_asm(VERSION1, 8126917);
    resume_asm_2_asm(VERSION0, 8126917);
}

pub fn resume_asm_2_asm(version: u32, except_cycles: u64) {
    let buffer = load_program();

    // The cycles required for complete execution is 4194622
    let mut machine1 = MachineTy::Asm.build(version, except_cycles - 30);
    machine1
        .load_program(&buffer, [Ok("alloc_many".into())].into_iter())
        .unwrap();
    let result1 = machine1.run();
    let cycles1 = machine1.cycles();
    assert!(result1.is_err());
    assert_eq!(result1.unwrap_err(), Error::CyclesExceeded);
    let snapshot = machine1.snapshot().unwrap();

    let mut machine2 = MachineTy::Asm.build(version, 40);
    machine2.resume(&snapshot).unwrap();
    let result2 = machine2.run();
    let cycles2 = machine2.cycles();
    assert!(result2.is_ok());
    assert_eq!(result2.unwrap(), 0);
    assert_eq!(cycles1 + cycles2, except_cycles);
}

pub fn resume_asm_2_asm_2_asm(version: u32, except_cycles: u64) {
    let buffer = load_program();

    let mut machine1 = MachineTy::Asm.build(version, 1000000);
    machine1
        .load_program(&buffer, [Ok("alloc_many".into())].into_iter())
        .unwrap();
    let result1 = machine1.run();
    let cycles1 = machine1.cycles();
    assert!(result1.is_err());
    assert_eq!(result1.unwrap_err(), Error::CyclesExceeded);
    let snapshot1 = machine1.snapshot().unwrap();

    let mut machine2 = MachineTy::Asm.build(version, 4000000);
    machine2.resume(&snapshot1).unwrap();
    let result2 = machine2.run();
    let cycles2 = machine2.cycles();
    assert!(result2.is_err());
    assert_eq!(result2.unwrap_err(), Error::CyclesExceeded);
    let snapshot2 = machine2.snapshot().unwrap();

    let mut machine3 = MachineTy::Asm.build(version, 4000000);
    machine3.resume(&snapshot2).unwrap();
    let result3 = machine3.run();
    let cycles3 = machine3.cycles();
    assert!(result3.is_ok());
    assert_eq!(result3.unwrap(), 0);
    assert_eq!(cycles1 + cycles2 + cycles3, except_cycles);
}

pub fn resume_asm_2_interpreter(version: u32, except_cycles: u64) {
    let buffer = load_program();

    let mut machine1 = MachineTy::Asm.build(version, except_cycles - 30);
    machine1
        .load_program(&buffer, [Ok("alloc_many".into())].into_iter())
        .unwrap();
    let result1 = machine1.run();
    let cycles1 = machine1.cycles();
    assert!(result1.is_err());
    assert_eq!(result1.unwrap_err(), Error::CyclesExceeded);
    let snapshot = machine1.snapshot().unwrap();

    let mut machine2 = MachineTy::Interpreter.build(version, 40);
    machine2.resume(&snapshot).unwrap();

    let result2 = machine2.run();
    let cycles2 = machine2.cycles();
    assert!(result2.is_ok());
    assert_eq!(result2.unwrap(), 0);
    assert_eq!(cycles1 + cycles2, except_cycles);
}

pub fn resume_interpreter_2_interpreter(version: u32, except_cycles: u64) {
    let buffer = load_program();

    let mut machine1 = MachineTy::Interpreter.build(version, except_cycles - 30);
    machine1
        .load_program(&buffer, [Ok("alloc_many".into())].into_iter())
        .unwrap();
    let result1 = machine1.run();
    let cycles1 = machine1.cycles();
    assert!(result1.is_err());
    assert_eq!(result1.unwrap_err(), Error::CyclesExceeded);
    let snapshot = machine1.snapshot().unwrap();

    let mut machine2 = MachineTy::Interpreter.build(version, 30);
    machine2.resume(&snapshot).unwrap();
    let result2 = machine2.run();
    let cycles2 = machine2.cycles();
    assert!(result2.is_ok());
    assert_eq!(result2.unwrap(), 0);
    assert_eq!(cycles1 + cycles2, except_cycles);
}

pub fn resume_interpreter_2_asm(version: u32, except_cycles: u64) {
    let buffer = load_program();

    let mut machine1 = MachineTy::Interpreter.build(version, except_cycles - 30);
    machine1
        .load_program(&buffer, [Ok("alloc_many".into())].into_iter())
        .unwrap();
    let result1 = machine1.run();
    let cycles1 = machine1.cycles();
    assert!(result1.is_err());
    assert_eq!(result1.unwrap_err(), Error::CyclesExceeded);
    let snapshot = machine1.snapshot().unwrap();

    let mut machine2 = MachineTy::Asm.build(version, 30);
    machine2.resume(&snapshot).unwrap();
    let result2 = machine2.run();
    let cycles2 = machine2.cycles();
    assert!(result2.is_ok());
    assert_eq!(result2.unwrap(), 0);
    assert_eq!(cycles1 + cycles2, except_cycles);
}

pub fn resume_interpreter_with_trace_2_asm_inner(version: u32, except_cycles: u64) {
    let buffer = load_program();

    let mut machine1 = MachineTy::InterpreterWithTrace.build(version, except_cycles - 30);
    machine1
        .load_program(&buffer, [Ok("alloc_many".into())].into_iter())
        .unwrap();
    let result1 = machine1.run();
    let cycles1 = machine1.cycles();
    assert!(result1.is_err());
    assert_eq!(result1.unwrap_err(), Error::CyclesExceeded);
    let snapshot = machine1.snapshot().unwrap();

    let mut machine2 = MachineTy::Asm.build(version, 30);
    machine2.resume(&snapshot).unwrap();
    let result2 = machine2.run();
    let cycles2 = machine2.cycles();
    assert!(result2.is_ok());
    assert_eq!(result2.unwrap(), 0);
    assert_eq!(cycles1 + cycles2, except_cycles);
}

fn load_program() -> Bytes {
    let mut file = File::open("tests/programs/alloc_many").unwrap();
    let mut buffer = Vec::new();
    file.read_to_end(&mut buffer).unwrap();
    buffer.into()
}

enum MachineTy {
    Asm,
    Interpreter,
    InterpreterWithTrace,
}

impl MachineTy {
    fn build(self, version: u32, max_cycles: u64) -> Machine {
        match self {
            MachineTy::Asm => {
                let asm_core1 = AsmCoreMachine::new(ISA_IMC, version, max_cycles);
                let core1 = DefaultMachineBuilder::<Box<AsmCoreMachine>>::new(asm_core1)
                    .instruction_cycle_func(Box::new(constant_cycles))
                    .build();
                Machine::Asm(AsmMachine::new(core1))
            }
            MachineTy::Interpreter => {
                let core_machine1 = DefaultCoreMachine::<u64, WXorXMemory<SparseMemory<u64>>>::new(
                    ISA_IMC, version, max_cycles,
                );
                Machine::Interpreter(
                    DefaultMachineBuilder::<DefaultCoreMachine<u64, WXorXMemory<SparseMemory<u64>>>>::new(
                        core_machine1,
                    )
                    .instruction_cycle_func(Box::new(constant_cycles))
                    .build(),
                )
            }
            MachineTy::InterpreterWithTrace => {
                let core_machine1 = DefaultCoreMachine::<u64, WXorXMemory<SparseMemory<u64>>>::new(
                    ISA_IMC, version, max_cycles,
                );
                Machine::InterpreterWithTrace(
                    TraceMachine::new(
                        DefaultMachineBuilder::<
                            DefaultCoreMachine<u64, WXorXMemory<SparseMemory<u64>>>,
                        >::new(core_machine1)
                        .instruction_cycle_func(Box::new(constant_cycles))
                        .build(),
                    ),
                )
            }
        }
    }
}

enum Machine {
    Asm(AsmMachine),
    Interpreter(DefaultMachine<DefaultCoreMachine<u64, WXorXMemory<SparseMemory<u64>>>>),
    InterpreterWithTrace(TraceMachine<DefaultCoreMachine<u64, WXorXMemory<SparseMemory<u64>>>>),
}

impl Machine {
    fn load_program(
        &mut self,
        program: &Bytes,
        args: impl ExactSizeIterator<Item = Result<Bytes, Error>>,
    ) -> Result<u64, Error> {
        use Machine::*;
        match self {
            Asm(inner) => inner.load_program(program, args),
            Interpreter(inner) => inner.load_program(program, args),
            InterpreterWithTrace(inner) => inner.load_program(program, args),
        }
    }

    fn run(&mut self) -> Result<i8, Error> {
        use Machine::*;
        match self {
            Asm(inner) => inner.run(),
            Interpreter(inner) => inner.run(),
            InterpreterWithTrace(inner) => inner.run(),
        }
    }

    fn cycles(&self) -> u64 {
        use Machine::*;
        match self {
            Asm(inner) => inner.machine.cycles(),
            Interpreter(inner) => inner.cycles(),
            InterpreterWithTrace(inner) => inner.machine.cycles(),
        }
    }

    fn snapshot(&mut self) -> Result<Snapshot, Error> {
        use Machine::*;
        match self {
            Asm(inner) => make_snapshot(&mut inner.machine),
            Interpreter(inner) => make_snapshot(inner),
            InterpreterWithTrace(inner) => make_snapshot(&mut inner.machine),
        }
    }

    fn resume(&mut self, snap: &Snapshot) -> Result<(), Error> {
        use Machine::*;
        match self {
            Asm(inner) => resume(&mut inner.machine, snap),
            Interpreter(inner) => resume(inner, snap),
            InterpreterWithTrace(inner) => resume(&mut inner.machine, snap),
        }
    }
}

#[test]
pub fn test_sc_after_snapshot() {
    let mut machine = machine_build::int(
        "tests/programs/sc_after_snapshot",
        vec![],
        VERSION2,
        ISA_IMC | ISA_A,
    );
    machine.machine.set_max_cycles(5);
    let ret = machine.run();
    assert!(ret.is_err());
    assert_eq!(ret.unwrap_err(), Error::CyclesExceeded);

    let snap = make_snapshot(&mut machine).unwrap();
    let mut machine_new = TraceMachine::new(
        DefaultMachineBuilder::new(
            DefaultCoreMachine::<u64, WXorXMemory<SparseMemory<u64>>>::new(
                ISA_IMC | ISA_A,
                VERSION2,
                u64::MAX,
            ),
        )
        .instruction_cycle_func(Box::new(constant_cycles))
        .build(),
    );
    resume(&mut machine_new, &snap).unwrap();
    machine_new.machine.set_max_cycles(20);
    let ret = machine_new.run();
    assert!(ret.is_ok());
    assert_eq!(ret.unwrap(), 0);
}


================================================
File: tests/test_resume2.rs
================================================
#![cfg(has_asm)]
pub mod machine_build;
use bytes::Bytes;
use ckb_vm::cost_model::constant_cycles;
use ckb_vm::elf::parse_elf;
use ckb_vm::machine::asm::{AsmCoreMachine, AsmMachine};
use ckb_vm::machine::trace::TraceMachine;
use ckb_vm::machine::{
    CoreMachine, DefaultCoreMachine, DefaultMachine, SupportMachine, VERSION0, VERSION1, VERSION2,
};
use ckb_vm::memory::{sparse::SparseMemory, wxorx::WXorXMemory};
use ckb_vm::registers::{A0, A1, A7};
use ckb_vm::snapshot2::{DataSource, Snapshot2, Snapshot2Context};
#[allow(unused_imports)]
use ckb_vm::Memory;
use ckb_vm::{DefaultMachineBuilder, Error, Register, Syscalls, ISA_A, ISA_IMC};
use std::collections::HashMap;
use std::fs::File;
use std::io::Read;
use std::sync::{Arc, Mutex};

#[test]
fn test_resume2_interpreter_with_trace_2_asm() {
    resume_interpreter_with_trace_2_asm_inner(VERSION1, 8126917);
    resume_interpreter_with_trace_2_asm_inner(VERSION0, 8126917);
}

#[test]
fn test_resume2_interpreter_2_asm() {
    resume_interpreter_2_asm(VERSION1, 8126917);
    resume_interpreter_2_asm(VERSION0, 8126917);
}

#[test]
fn test_resume2_interpreter_2_interpreter() {
    resume_interpreter_2_interpreter(VERSION1, 8126917);
    resume_interpreter_2_interpreter(VERSION0, 8126917);
}

#[test]
fn test_resume2_asm_2_interpreter() {
    resume_asm_2_interpreter(VERSION1, 8126917);
    resume_asm_2_interpreter(VERSION0, 8126917);
}

#[test]
fn test_resume2_asm_2_asm_2_asm() {
    resume_asm_2_asm_2_asm(VERSION1, 8126917);
    resume_asm_2_asm_2_asm(VERSION0, 8126917);
}

#[test]
fn test_resume2_asm_2_asm() {
    resume_asm_2_asm(VERSION1, 8126917);
    resume_asm_2_asm(VERSION0, 8126917);
}

#[test]
fn test_resume2_secp256k1_asm_2_interpreter_2_asm() {
    let data_source = load_program("benches/data/secp256k1_bench");

    let version = VERSION1;
    let except_cycles = 613073;

    let mut machine1 = MachineTy::Asm.build(data_source.clone(), version);
    machine1.set_max_cycles(100000);
    machine1.load_program([
        "secp256k1_bench",
        "033f8cf9c4d51a33206a6c1c6b27d2cc5129daa19dbd1fc148d395284f6b26411f",
        "304402203679d909f43f073c7c1dcf8468a485090589079ee834e6eed92fea9b09b06a2402201e46f1075afa18f306715e7db87493e7b7e779569aa13c64ab3d09980b3560a3",
        "foo",
        "bar",
    ].into_iter().map(|e| Ok(e.into()))).unwrap();
    let result1 = machine1.run();
    assert_eq!(result1.unwrap_err(), Error::CyclesExceeded);
    let snapshot1 = machine1.snapshot().unwrap();
    assert!(!snapshot1.pages_from_source.is_empty());

    let mut machine2 = MachineTy::Interpreter.build(data_source.clone(), version);
    machine2.resume(snapshot1).unwrap();

    assert_eq!(machine1.cycles(), machine2.cycles());
    assert_eq!(machine1.full_registers(), machine2.full_registers());
    #[cfg(not(feature = "enable-chaos-mode-by-default"))]
    assert_eq!(machine1.full_memory(), machine2.full_memory());

    machine2.set_max_cycles(100000 + 200000);
    let result2 = machine2.run();
    assert_eq!(result2.unwrap_err(), Error::CyclesExceeded);
    let snapshot2 = machine2.snapshot().unwrap();
    assert!(!snapshot2.pages_from_source.is_empty());

    let mut machine3 = MachineTy::Asm.build(data_source, version);
    machine3.resume(snapshot2).unwrap();

    assert_eq!(machine2.cycles(), machine3.cycles());
    assert_eq!(machine2.full_registers(), machine3.full_registers());
    #[cfg(not(feature = "enable-chaos-mode-by-default"))]
    assert_eq!(machine2.full_memory(), machine3.full_memory());

    machine3.set_max_cycles(100000 + 200000 + 400000);
    let result3 = machine3.run();
    let cycles3 = machine3.cycles();
    assert_eq!(result3.unwrap(), 0);
    assert_eq!(cycles3, except_cycles);
}

#[test]
fn test_resume2_load_data_asm_2_interpreter() {
    let data_source = load_program("tests/programs/resume2_load_data");

    let version = VERSION1;
    let except_cycles = 1476715;

    let mut machine1 = MachineTy::Asm.build(data_source.clone(), version);
    machine1.set_max_cycles(300000);
    machine1
        .load_program([Ok("resume2_load_data".into())].into_iter())
        .unwrap();
    let result1 = machine1.run();
    assert!(result1.is_err());
    assert_eq!(result1.unwrap_err(), Error::CyclesExceeded);
    let snapshot = machine1.snapshot().unwrap();
    assert!(!snapshot.pages_from_source.is_empty());

    let mut machine2 = MachineTy::Interpreter.build(data_source, version);
    machine2.resume(snapshot).unwrap();

    assert_eq!(machine1.cycles(), machine2.cycles());
    assert_eq!(machine1.full_registers(), machine2.full_registers());
    #[cfg(not(feature = "enable-chaos-mode-by-default"))]
    assert_eq!(machine1.full_memory(), machine2.full_memory());

    machine2.set_max_cycles(except_cycles + 10);

    let result2 = machine2.run();
    let cycles2 = machine2.cycles();
    assert_eq!(result2.unwrap(), 0);
    assert_eq!(cycles2, except_cycles);
}

#[test]
fn test_resume2_load_data_interpreter_2_asm() {
    let data_source = load_program("tests/programs/resume2_load_data");

    let version = VERSION1;
    let except_cycles = 1476715;

    let mut machine1 = MachineTy::Interpreter.build(data_source.clone(), version);
    machine1.set_max_cycles(300000);
    machine1
        .load_program([Ok("resume2_load_data".into())].into_iter())
        .unwrap();
    let result1 = machine1.run();
    assert!(result1.is_err());
    assert_eq!(result1.unwrap_err(), Error::CyclesExceeded);
    let snapshot = machine1.snapshot().unwrap();
    assert!(!snapshot.pages_from_source.is_empty());

    let mut machine2 = MachineTy::Asm.build(data_source, version);
    machine2.resume(snapshot).unwrap();

    assert_eq!(machine1.cycles(), machine2.cycles());
    assert_eq!(machine1.full_registers(), machine2.full_registers());
    #[cfg(not(feature = "enable-chaos-mode-by-default"))]
    assert_eq!(machine1.full_memory(), machine2.full_memory());

    machine2.set_max_cycles(except_cycles + 10);

    let result2 = machine2.run();
    let cycles2 = machine2.cycles();
    assert_eq!(result2.unwrap(), 0);
    assert_eq!(cycles2, except_cycles);
}

pub fn resume_asm_2_asm(version: u32, except_cycles: u64) {
    let data_source = load_program("tests/programs/alloc_many");

    // The cycles required for complete execution is 4194622
    let mut machine1 = MachineTy::Asm.build(data_source.clone(), version);
    machine1.set_max_cycles(except_cycles - 30);
    machine1
        .load_program([Ok("alloc_many".into())].into_iter())
        .unwrap();
    let result1 = machine1.run();
    assert!(result1.is_err());
    assert_eq!(result1.unwrap_err(), Error::CyclesExceeded);
    let snapshot = machine1.snapshot().unwrap();

    let mut machine2 = MachineTy::Asm.build(data_source, version);
    machine2.resume(snapshot).unwrap();
    machine2.set_max_cycles(except_cycles + 10);
    let result2 = machine2.run();
    let cycles2 = machine2.cycles();
    assert_eq!(result2.unwrap(), 0);
    assert_eq!(cycles2, except_cycles);
}

pub fn resume_asm_2_asm_2_asm(version: u32, except_cycles: u64) {
    let data_source = load_program("tests/programs/alloc_many");

    let mut machine1 = MachineTy::Asm.build(data_source.clone(), version);
    machine1.set_max_cycles(1000000);
    machine1
        .load_program([Ok("alloc_many".into())].into_iter())
        .unwrap();
    let result1 = machine1.run();
    assert!(result1.is_err());
    assert_eq!(result1.unwrap_err(), Error::CyclesExceeded);
    let snapshot1 = machine1.snapshot().unwrap();

    let mut machine2 = MachineTy::Asm.build(data_source.clone(), version);
    machine2.resume(snapshot1).unwrap();
    machine2.set_max_cycles(1000000 + 4000000);
    let result2 = machine2.run();
    assert!(result2.is_err());
    assert_eq!(result2.unwrap_err(), Error::CyclesExceeded);
    let snapshot2 = machine2.snapshot().unwrap();

    let mut machine3 = MachineTy::Asm.build(data_source, version);
    machine3.resume(snapshot2).unwrap();
    machine3.set_max_cycles(1000000 + 4000000 + 4000000);
    let result3 = machine3.run();
    let cycles3 = machine3.cycles();
    assert_eq!(result3.unwrap(), 0);
    assert_eq!(cycles3, except_cycles);
}

pub fn resume_asm_2_interpreter(version: u32, except_cycles: u64) {
    let data_source = load_program("tests/programs/alloc_many");

    let mut machine1 = MachineTy::Asm.build(data_source.clone(), version);
    machine1.set_max_cycles(except_cycles - 30);
    machine1
        .load_program([Ok("alloc_many".into())].into_iter())
        .unwrap();
    let result1 = machine1.run();
    assert!(result1.is_err());
    assert_eq!(result1.unwrap_err(), Error::CyclesExceeded);
    let snapshot = machine1.snapshot().unwrap();

    let mut machine2 = MachineTy::Interpreter.build(data_source, version);
    machine2.resume(snapshot).unwrap();
    machine2.set_max_cycles(except_cycles + 10);

    let result2 = machine2.run();
    let cycles2 = machine2.cycles();
    assert_eq!(result2.unwrap(), 0);
    assert_eq!(cycles2, except_cycles);
}

pub fn resume_interpreter_2_interpreter(version: u32, except_cycles: u64) {
    let data_source = load_program("tests/programs/alloc_many");

    let mut machine1 = MachineTy::Interpreter.build(data_source.clone(), version);
    machine1.set_max_cycles(except_cycles - 30);
    machine1
        .load_program([Ok("alloc_many".into())].into_iter())
        .unwrap();
    let result1 = machine1.run();
    assert!(result1.is_err());
    assert_eq!(result1.unwrap_err(), Error::CyclesExceeded);
    let snapshot = machine1.snapshot().unwrap();

    let mut machine2 = MachineTy::Interpreter.build(data_source, version);
    machine2.resume(snapshot).unwrap();
    machine2.set_max_cycles(except_cycles + 10);
    let result2 = machine2.run();
    let cycles2 = machine2.cycles();
    assert_eq!(result2.unwrap(), 0);
    assert_eq!(cycles2, except_cycles);
}

pub fn resume_interpreter_2_asm(version: u32, except_cycles: u64) {
    let data_source = load_program("tests/programs/alloc_many");

    let mut machine1 = MachineTy::Interpreter.build(data_source.clone(), version);
    machine1.set_max_cycles(except_cycles - 30);
    machine1
        .load_program([Ok("alloc_many".into())].into_iter())
        .unwrap();
    let result1 = machine1.run();
    assert!(result1.is_err());
    assert_eq!(result1.unwrap_err(), Error::CyclesExceeded);
    let snapshot = machine1.snapshot().unwrap();

    let mut machine2 = MachineTy::Asm.build(data_source, version);
    machine2.resume(snapshot).unwrap();
    machine2.set_max_cycles(except_cycles);
    let result2 = machine2.run();
    let cycles2 = machine2.cycles();
    assert_eq!(result2.unwrap(), 0);
    assert_eq!(cycles2, except_cycles);
}

pub fn resume_interpreter_with_trace_2_asm_inner(version: u32, except_cycles: u64) {
    let data_source = load_program("tests/programs/alloc_many");

    let mut machine1 = MachineTy::InterpreterWithTrace.build(data_source.clone(), version);
    machine1.set_max_cycles(except_cycles - 30);
    machine1
        .load_program([Ok("alloc_many".into())].into_iter())
        .unwrap();
    let result1 = machine1.run();
    assert!(result1.is_err());
    assert_eq!(result1.unwrap_err(), Error::CyclesExceeded);
    let snapshot = machine1.snapshot().unwrap();

    let mut machine2 = MachineTy::Asm.build(data_source, version);
    machine2.resume(snapshot).unwrap();
    machine2.set_max_cycles(except_cycles);
    let result2 = machine2.run();
    let cycles2 = machine2.cycles();
    assert_eq!(result2.unwrap(), 0);
    assert_eq!(cycles2, except_cycles);
}

fn load_program(name: &str) -> TestSource {
    let mut file = File::open(name).unwrap();
    let mut buffer = Vec::new();
    file.read_to_end(&mut buffer).unwrap();
    let program = buffer.into();

    let mut data = vec![0; 16 * 4096];
    for i in 0..data.len() {
        data[i] = i as u8;
    }

    let mut m = HashMap::default();
    m.insert(DATA_ID, data.into());
    m.insert(PROGRAM_ID, program);

    TestSource(m)
}

const PROGRAM_ID: u64 = 0x1234;
const DATA_ID: u64 = 0x2000;

#[derive(Clone)]
struct TestSource(HashMap<u64, Bytes>);

impl DataSource<u64> for TestSource {
    fn load_data(&self, id: &u64, offset: u64, length: u64) -> Option<(Bytes, u64)> {
        match self.0.get(id) {
            Some(data) => {
                let end = if length > 0 {
                    offset + length
                } else {
                    data.len() as u64
                };
                let full_length = end - offset;
                Some((data.slice(offset as usize..end as usize), full_length))
            }
            None => None,
        }
    }
}

struct InsertDataSyscall(Arc<Mutex<Snapshot2Context<u64, TestSource>>>);

impl<Mac: SupportMachine> Syscalls<Mac> for InsertDataSyscall {
    fn initialize(&mut self, _machine: &mut Mac) -> Result<(), Error> {
        Ok(())
    }

    fn ecall(&mut self, machine: &mut Mac) -> Result<bool, Error> {
        let code = &machine.registers()[A7];
        if code.to_i32() != 1111 {
            return Ok(false);
        }
        let addr = machine.registers()[A0].to_u64();
        let size = machine.registers()[A1].to_u64();

        self.0
            .lock()
            .unwrap()
            .store_bytes(machine, addr, &DATA_ID, 0, size, 0)?;

        machine.add_cycles_no_checking(100000)?;

        machine.set_register(A0, Mac::REG::from_u64(0));
        Ok(true)
    }
}

enum MachineTy {
    Asm,
    Interpreter,
    InterpreterWithTrace,
}

impl MachineTy {
    fn build(self, data_source: TestSource, version: u32) -> Machine {
        match self {
            MachineTy::Asm => {
                let context = Arc::new(Mutex::new(Snapshot2Context::new(data_source)));
                let asm_core1 = AsmCoreMachine::new(ISA_IMC | ISA_A, version, 0);
                let core1 = DefaultMachineBuilder::<Box<AsmCoreMachine>>::new(asm_core1)
                    .instruction_cycle_func(Box::new(constant_cycles))
                    .syscall(Box::new(InsertDataSyscall(context.clone())))
                    .build();
                Machine::Asm(AsmMachine::new(core1), context)
            }
            MachineTy::Interpreter => {
                let context = Arc::new(Mutex::new(Snapshot2Context::new(data_source)));
                let core_machine1 = DefaultCoreMachine::<u64, WXorXMemory<SparseMemory<u64>>>::new(
                    ISA_IMC | ISA_A,
                    version,
                    0,
                );
                Machine::Interpreter(
                    DefaultMachineBuilder::<DefaultCoreMachine<u64, WXorXMemory<SparseMemory<u64>>>>::new(
                        core_machine1,
                    )
                    .instruction_cycle_func(Box::new(constant_cycles))
                    .syscall(Box::new(InsertDataSyscall(context.clone())))
                    .build(),
                    context,
                )
            }
            MachineTy::InterpreterWithTrace => {
                let context = Arc::new(Mutex::new(Snapshot2Context::new(data_source)));
                let core_machine1 = DefaultCoreMachine::<u64, WXorXMemory<SparseMemory<u64>>>::new(
                    ISA_IMC | ISA_A,
                    version,
                    0,
                );
                Machine::InterpreterWithTrace(
                    TraceMachine::new(
                        DefaultMachineBuilder::<
                            DefaultCoreMachine<u64, WXorXMemory<SparseMemory<u64>>>,
                        >::new(core_machine1)
                        .instruction_cycle_func(Box::new(constant_cycles))
                        .syscall(Box::new(InsertDataSyscall(context.clone())))
                        .build(),
                    ),
                    context,
                )
            }
        }
    }
}

enum Machine {
    Asm(AsmMachine, Arc<Mutex<Snapshot2Context<u64, TestSource>>>),
    Interpreter(
        DefaultMachine<DefaultCoreMachine<u64, WXorXMemory<SparseMemory<u64>>>>,
        Arc<Mutex<Snapshot2Context<u64, TestSource>>>,
    ),
    InterpreterWithTrace(
        TraceMachine<DefaultCoreMachine<u64, WXorXMemory<SparseMemory<u64>>>>,
        Arc<Mutex<Snapshot2Context<u64, TestSource>>>,
    ),
}

impl Machine {
    fn load_program(
        &mut self,
        args: impl ExactSizeIterator<Item = Result<Bytes, Error>>,
    ) -> Result<u64, Error> {
        use Machine::*;
        match self {
            Asm(inner, context) => {
                let (program, _) = context
                    .lock()
                    .unwrap()
                    .load_data(&PROGRAM_ID, 0, 0)
                    .unwrap();
                let metadata = parse_elf::<u64>(&program, inner.machine.version())?;
                let bytes = inner.load_program_with_metadata(&program, &metadata, args)?;
                context.lock().unwrap().mark_program(
                    inner.machine.inner_mut(),
                    &metadata,
                    &PROGRAM_ID,
                    0,
                )?;
                Ok(bytes)
            }
            Interpreter(inner, context) => {
                let (program, _) = context
                    .lock()
                    .unwrap()
                    .load_data(&PROGRAM_ID, 0, 0)
                    .unwrap();
                let metadata = parse_elf::<u64>(&program, inner.version())?;
                let bytes = inner.load_program_with_metadata(&program, &metadata, args)?;
                context.lock().unwrap().mark_program(
                    inner.inner_mut(),
                    &metadata,
                    &PROGRAM_ID,
                    0,
                )?;
                Ok(bytes)
            }
            InterpreterWithTrace(inner, context) => {
                let (program, _) = context
                    .lock()
                    .unwrap()
                    .load_data(&PROGRAM_ID, 0, 0)
                    .unwrap();
                let metadata = parse_elf::<u64>(&program, inner.machine.version())?;
                let bytes = inner.load_program_with_metadata(&program, &metadata, args)?;
                context.lock().unwrap().mark_program(
                    inner.machine.inner_mut(),
                    &metadata,
                    &PROGRAM_ID,
                    0,
                )?;
                Ok(bytes)
            }
        }
    }

    fn run(&mut self) -> Result<i8, Error> {
        use Machine::*;
        match self {
            Asm(inner, _) => inner.run(),
            Interpreter(inner, _) => inner.run(),
            InterpreterWithTrace(inner, _) => inner.run(),
        }
    }

    fn set_max_cycles(&mut self, cycles: u64) {
        use Machine::*;
        match self {
            Asm(inner, _) => inner.machine.set_max_cycles(cycles),
            Interpreter(inner, _) => inner.set_max_cycles(cycles),
            InterpreterWithTrace(inner, _) => inner.machine.set_max_cycles(cycles),
        }
    }

    fn cycles(&self) -> u64 {
        use Machine::*;
        match self {
            Asm(inner, _) => inner.machine.cycles(),
            Interpreter(inner, _) => inner.cycles(),
            InterpreterWithTrace(inner, _) => inner.machine.cycles(),
        }
    }

    #[cfg(not(feature = "enable-chaos-mode-by-default"))]
    fn full_memory(&mut self) -> Result<Bytes, Error> {
        use ckb_vm::DEFAULT_MEMORY_SIZE;
        use Machine::*;
        match self {
            Asm(inner, _) => inner
                .machine
                .memory_mut()
                .load_bytes(0, DEFAULT_MEMORY_SIZE as u64),
            Interpreter(inner, _) => inner.memory_mut().load_bytes(0, DEFAULT_MEMORY_SIZE as u64),
            InterpreterWithTrace(inner, _) => inner
                .machine
                .memory_mut()
                .load_bytes(0, DEFAULT_MEMORY_SIZE as u64),
        }
    }

    fn full_registers(&self) -> [u64; 33] {
        use Machine::*;
        let mut regs = [0u64; 33];
        match self {
            Asm(inner, _) => {
                regs[0..32].copy_from_slice(inner.machine.registers());
                regs[32] = *inner.machine.pc();
            }
            Interpreter(inner, _) => {
                regs[0..32].copy_from_slice(inner.registers());
                regs[32] = *inner.pc();
            }
            InterpreterWithTrace(inner, _) => {
                regs[0..32].copy_from_slice(inner.machine.registers());
                regs[32] = *inner.machine.pc();
            }
        };
        regs
    }

    fn snapshot(&mut self) -> Result<Snapshot2<u64>, Error> {
        use Machine::*;
        match self {
            Asm(inner, context) => {
                let context = context.lock().unwrap();
                Ok(context.make_snapshot(inner.machine.inner_mut())?)
            }
            Interpreter(inner, context) => {
                let context = context.lock().unwrap();
                Ok(context.make_snapshot(inner.inner_mut())?)
            }
            InterpreterWithTrace(inner, context) => {
                let context = context.lock().unwrap();
                Ok(context.make_snapshot(inner.machine.inner_mut())?)
            }
        }
    }

    fn resume(&mut self, snap: Snapshot2<u64>) -> Result<(), Error> {
        use Machine::*;
        match self {
            Asm(inner, context) => {
                context
                    .lock()
                    .unwrap()
                    .resume(inner.machine.inner_mut(), &snap)?;
            }
            Interpreter(inner, context) => {
                context.lock().unwrap().resume(inner.inner_mut(), &snap)?;
            }
            InterpreterWithTrace(inner, context) => {
                context
                    .lock()
                    .unwrap()
                    .resume(inner.machine.inner_mut(), &snap)?;
            }
        };
        Ok(())
    }
}

#[test]
pub fn test_sc_after_snapshot2() {
    let data_source = load_program("tests/programs/sc_after_snapshot");

    let mut machine1 = MachineTy::Interpreter.build(data_source.clone(), VERSION2);
    machine1.set_max_cycles(5);
    machine1
        .load_program([Ok("main".into())].into_iter())
        .unwrap();
    let result1 = machine1.run();
    assert!(result1.is_err());
    assert_eq!(result1.unwrap_err(), Error::CyclesExceeded);
    let snapshot = machine1.snapshot().unwrap();

    let mut machine2 = MachineTy::Interpreter.build(data_source, VERSION2);
    machine2.resume(snapshot).unwrap();
    machine2.set_max_cycles(20);
    let result2 = machine2.run();
    assert!(result2.is_ok());
    assert_eq!(result2.unwrap(), 0);
}

#[cfg(not(feature = "enable-chaos-mode-by-default"))]
#[test]
pub fn test_store_bytes_twice() {
    let data_source = load_program("tests/programs/sc_after_snapshot");

    let mut machine = MachineTy::Asm.build(data_source.clone(), VERSION2);
    machine.set_max_cycles(u64::MAX);
    machine
        .load_program([Ok("main".into())].into_iter())
        .unwrap();

    match machine {
        Machine::Asm(ref mut inner, ref ctx) => {
            ctx.lock()
                .unwrap()
                .store_bytes(&mut inner.machine, 0, &DATA_ID, 2, 29186, 0)
                .unwrap();
            ctx.lock()
                .unwrap()
                .store_bytes(&mut inner.machine, 0, &DATA_ID, 0, 11008, 0)
                .unwrap();
        }
        _ => unimplemented!(),
    }
    let mem1 = machine.full_memory().unwrap();

    let snapshot = machine.snapshot().unwrap();
    let mut machine2 = MachineTy::Asm.build(data_source.clone(), VERSION2);
    machine2.resume(snapshot).unwrap();
    machine2.set_max_cycles(u64::MAX);
    let mem2 = machine2.full_memory().unwrap();

    assert_eq!(mem1, mem2);
}

#[cfg(not(feature = "enable-chaos-mode-by-default"))]
#[test]
pub fn test_mixing_snapshot2_writes_with_machine_raw_writes() {
    let data_source = load_program("tests/programs/sc_after_snapshot");

    let mut machine = MachineTy::Asm.build(data_source.clone(), VERSION2);
    machine.set_max_cycles(u64::MAX);
    machine
        .load_program([Ok("main".into())].into_iter())
        .unwrap();

    match machine {
        Machine::Asm(ref mut inner, ref ctx) => {
            ctx.lock()
                .unwrap()
                .store_bytes(&mut inner.machine, 0, &DATA_ID, 0, 29186, 0)
                .unwrap();
            inner
                .machine
                .memory_mut()
                .store_bytes(0, &vec![0x42; 29186])
                .unwrap();
        }
        _ => unimplemented!(),
    }

    let mem1 = machine.full_memory().unwrap();

    let snapshot = machine.snapshot().unwrap();
    let mut machine2 = MachineTy::Asm.build(data_source.clone(), VERSION2);
    machine2.resume(snapshot).unwrap();
    machine2.set_max_cycles(u64::MAX);
    let mem2 = machine2.full_memory().unwrap();

    assert_eq!(mem1, mem2);
}


================================================
File: tests/test_signal_pause.rs
================================================
use ckb_vm::machine::VERSION2;
use ckb_vm::{Error, SupportMachine, ISA_B, ISA_IMC};
use std::sync::atomic::{AtomicU32, Ordering};
use std::sync::Arc;
pub mod machine_build;

#[cfg(has_asm)]
#[test]
pub fn test_asm_pause() {
    use ckb_vm::machine::VERSION2;

    let expect_cycles = {
        let mut machine = machine_build::asm(
            "tests/programs/pause_resume",
            vec![],
            VERSION2,
            ISA_IMC | ISA_B,
        );
        machine.run().unwrap();
        machine.machine.cycles()
    };

    let mut machine = machine_build::asm(
        "tests/programs/pause_resume",
        vec![],
        VERSION2,
        ISA_IMC | ISA_B,
    );
    let branch_pause_cnt = Arc::new(AtomicU32::new(0));
    let branch_pause_cnt_jh = branch_pause_cnt.clone();

    let signal = machine.machine.pause();
    let jh = std::thread::spawn(move || loop {
        let result = machine.run();
        if result == Err(Error::Pause) {
            branch_pause_cnt_jh.fetch_add(1, Ordering::SeqCst);
            continue;
        } else {
            assert!(result.is_ok());
            assert_eq!(result.unwrap(), 0);
            assert_eq!(machine.machine.cycles(), expect_cycles);
            break;
        }
    });
    for _ in 0..10 {
        std::thread::sleep(std::time::Duration::from_millis(100));
        signal.interrupt()
    }
    jh.join().unwrap();
    assert_eq!(branch_pause_cnt.load(Ordering::SeqCst), 10);
}

#[test]
pub fn test_int_pause() {
    let expect_cycles = {
        let mut machine = machine_build::int(
            "tests/programs/pause_resume",
            vec![],
            VERSION2,
            ISA_IMC | ISA_B,
        );
        machine.run().unwrap();
        machine.machine.cycles()
    };

    let mut machine = machine_build::int(
        "tests/programs/pause_resume",
        vec![],
        VERSION2,
        ISA_IMC | ISA_B,
    );
    let branch_pause_cnt = Arc::new(AtomicU32::new(0));
    let branch_pause_cnt_jh = branch_pause_cnt.clone();
    let signal = machine.machine.pause();
    let jh = std::thread::spawn(move || loop {
        let result = machine.run();
        if result == Err(Error::Pause) {
            branch_pause_cnt_jh.fetch_add(1, Ordering::SeqCst);
            continue;
        } else {
            assert!(result.is_ok());
            assert_eq!(result.unwrap(), 0);
            assert_eq!(machine.machine.cycles(), expect_cycles);
            break;
        }
    });
    for _ in 0..10 {
        std::thread::sleep(std::time::Duration::from_millis(100));
        signal.interrupt()
    }
    jh.join().unwrap();
    assert_eq!(branch_pause_cnt.load(Ordering::SeqCst), 10);
}


================================================
File: tests/test_simple.rs
================================================
use ckb_vm::machine::VERSION0;
use ckb_vm::{
    run, DefaultCoreMachine, DefaultMachineBuilder, Error, FlatMemory, Instruction, SparseMemory,
    SupportMachine, ISA_IMC,
};
use std::fs;

#[test]
pub fn test_simple_instructions() {
    let buffer = fs::read("tests/programs/simple").unwrap().into();
    let result = run::<u32, SparseMemory<u32>>(&buffer, &vec!["simple".into()]);
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
}

#[test]
pub fn test_simple_instructions_64() {
    let buffer = fs::read("tests/programs/simple64").unwrap().into();
    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec!["simple".into()]);
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
}

#[test]
pub fn test_simple_instructions_flatmemory() {
    let buffer = fs::read("tests/programs/simple").unwrap().into();
    let result = run::<u32, FlatMemory<u32>>(&buffer, &vec!["simple".into()]);
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
}

fn dummy_cycle_func(_i: Instruction) -> u64 {
    1
}

#[test]
pub fn test_simple_cycles() {
    let buffer = fs::read("tests/programs/simple64").unwrap().into();
    let core_machine = DefaultCoreMachine::<u64, SparseMemory<u64>>::new(ISA_IMC, VERSION0, 708);
    let mut machine =
        DefaultMachineBuilder::<DefaultCoreMachine<u64, SparseMemory<u64>>>::new(core_machine)
            .instruction_cycle_func(Box::new(dummy_cycle_func))
            .build();
    machine
        .load_program(&buffer, [Ok("simple".into())].into_iter())
        .unwrap();
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);

    assert_eq!(SupportMachine::cycles(&machine), 708);
}

#[test]
pub fn test_simple_max_cycles_reached() {
    let buffer = fs::read("tests/programs/simple64").unwrap().into();
    // Running simple64 should consume 708 cycles using dummy cycle func
    let core_machine = DefaultCoreMachine::<u64, SparseMemory<u64>>::new(ISA_IMC, VERSION0, 700);
    let mut machine =
        DefaultMachineBuilder::<DefaultCoreMachine<u64, SparseMemory<u64>>>::new(core_machine)
            .instruction_cycle_func(Box::new(dummy_cycle_func))
            .build();
    machine
        .load_program(&buffer, [Ok("simple".into())].into_iter())
        .unwrap();
    let result = machine.run();
    assert!(result.is_err());
    assert_eq!(result.unwrap_err(), Error::CyclesExceeded);
}

#[test]
pub fn test_simple_invalid_bits() {
    let buffer = fs::read("tests/programs/simple").unwrap().into();
    let result = run::<u64, SparseMemory<u64>>(&buffer, &vec!["simple".into()]);
    assert!(result.is_err());
    assert_eq!(result.unwrap_err(), Error::ElfBits);
}

#[test]
pub fn test_simple_loaded_bytes() {
    let buffer = fs::read("tests/programs/simple64").unwrap().into();
    let core_machine =
        DefaultCoreMachine::<u64, SparseMemory<u64>>::new(ISA_IMC, VERSION0, u64::MAX);
    let mut machine = DefaultMachineBuilder::new(core_machine).build();
    let bytes = machine
        .load_program(&buffer, [Ok("simple".into())].into_iter())
        .unwrap();
    assert_eq!(bytes, 3831);
}

#[test]
pub fn test_simple_cycles_overflow() {
    let buffer = fs::read("tests/programs/simple64").unwrap().into();
    let core_machine =
        DefaultCoreMachine::<u64, SparseMemory<u64>>::new(ISA_IMC, VERSION0, u64::MAX);
    let mut machine =
        DefaultMachineBuilder::<DefaultCoreMachine<u64, SparseMemory<u64>>>::new(core_machine)
            .instruction_cycle_func(Box::new(dummy_cycle_func))
            .build();
    machine.set_cycles(u64::MAX - 10);
    machine
        .load_program(&buffer, [Ok("simple".into())].into_iter())
        .unwrap();
    let result = machine.run();
    assert!(result.is_err());
    assert_eq!(result.unwrap_err(), Error::CyclesOverflow);
}


================================================
File: tests/test_spawn.rs
================================================
use bytes::Bytes;
use ckb_vm::cost_model::constant_cycles;
#[cfg(has_asm)]
use ckb_vm::machine::asm::{AsmCoreMachine, AsmMachine};
use ckb_vm::machine::{trace::TraceMachine, DefaultCoreMachine, VERSION2};
use ckb_vm::memory::load_c_string_byte_by_byte;
use ckb_vm::registers::{A0, A1, A2, A7};
use ckb_vm::{
    DefaultMachineBuilder, Error, FlattenedArgsReader, Register, SparseMemory, SupportMachine,
    Syscalls, WXorXMemory, ISA_B, ISA_IMC, ISA_MOP,
};
use std::sync::{Arc, Mutex};

// There is a spawn system call in ckb, we must ensure that in the worst case, ckb will not crashed by stack overflow.

fn stack_depth() -> u64 {
    let x = 0;
    unsafe {
        let raw: u64 = std::mem::transmute(&x);
        raw
    }
}

pub struct IntSpawnSyscall {
    min_sp: Arc<Mutex<u64>>,
}

impl<Mac: SupportMachine> Syscalls<Mac> for IntSpawnSyscall {
    fn initialize(&mut self, _machine: &mut Mac) -> Result<(), Error> {
        Ok(())
    }

    fn ecall(&mut self, machine: &mut Mac) -> Result<bool, Error> {
        let code = &machine.registers()[A7];
        if code.to_i32() != 1001 {
            return Ok(false);
        }

        {
            let sp = stack_depth();
            let mut min_sp_lock = self.min_sp.lock().unwrap();
            if sp < *min_sp_lock {
                *min_sp_lock = sp
            }
        }

        let addr = machine.registers()[A0].clone();
        let path_byte = load_c_string_byte_by_byte(machine.memory_mut(), &addr).unwrap();
        let path = std::str::from_utf8(&path_byte).unwrap();
        let argc = machine.registers()[A1].clone();
        let argv = machine.registers()[A2].clone();
        let args_iter = FlattenedArgsReader::new(machine.memory_mut(), argc.clone(), argv);
        let buffer: Bytes = std::fs::read(path).unwrap().into();
        let machine_core = DefaultCoreMachine::<u64, WXorXMemory<SparseMemory<u64>>>::new(
            ISA_IMC | ISA_B | ISA_MOP,
            VERSION2,
            u64::MAX,
        );
        let mut machine_child = TraceMachine::new(
            DefaultMachineBuilder::new(machine_core)
                .instruction_cycle_func(Box::new(constant_cycles))
                .syscall(Box::new(IntSpawnSyscall {
                    min_sp: self.min_sp.clone(),
                }))
                .build(),
        );
        machine_child.load_program(&buffer, args_iter).unwrap();
        let exit = machine_child.run().unwrap();
        machine.set_register(A0, Mac::REG::from_i8(exit));
        Ok(true)
    }
}

#[cfg(has_asm)]
pub struct AsmSpawnSyscall {
    min_sp: Arc<Mutex<u64>>,
}

#[cfg(has_asm)]
impl<Mac: SupportMachine> Syscalls<Mac> for AsmSpawnSyscall {
    fn initialize(&mut self, _machine: &mut Mac) -> Result<(), Error> {
        Ok(())
    }

    fn ecall(&mut self, machine: &mut Mac) -> Result<bool, Error> {
        let code = &machine.registers()[A7];
        if code.to_i32() != 1001 {
            return Ok(false);
        }

        {
            let sp = stack_depth();
            let mut min_sp_lock = self.min_sp.lock().unwrap();
            if sp < *min_sp_lock {
                *min_sp_lock = sp
            }
        }

        let addr = machine.registers()[A0].clone();
        let path_byte = load_c_string_byte_by_byte(machine.memory_mut(), &addr).unwrap();
        let path = std::str::from_utf8(&path_byte).unwrap();
        let argc = machine.registers()[A1].clone();
        let argv = machine.registers()[A2].clone();
        let args_iter = FlattenedArgsReader::new(machine.memory_mut(), argc.clone(), argv);
        let buffer: Bytes = std::fs::read(path).unwrap().into();
        let machine_core_asm = AsmCoreMachine::new(ISA_IMC | ISA_B | ISA_MOP, VERSION2, u64::MAX);
        let machine_core = DefaultMachineBuilder::<Box<AsmCoreMachine>>::new(machine_core_asm)
            .instruction_cycle_func(Box::new(constant_cycles))
            .syscall(Box::new(AsmSpawnSyscall {
                min_sp: self.min_sp.clone(),
            }))
            .build();
        let mut machine_child = AsmMachine::new(machine_core);
        machine_child.load_program(&buffer, args_iter).unwrap();
        let exit = machine_child.run().unwrap();
        machine.set_register(A0, Mac::REG::from_i8(exit));
        Ok(true)
    }
}

#[test]
pub fn test_spawn_int() {
    let buffer = std::fs::read("tests/programs/spawn").unwrap().into();
    let cur_sp = stack_depth();
    let min_sp = Arc::new(Mutex::new(u64::MAX));
    let machine_core = DefaultCoreMachine::<u64, WXorXMemory<SparseMemory<u64>>>::new(
        ISA_IMC | ISA_B | ISA_MOP,
        VERSION2,
        u64::MAX,
    );
    let mut machine = TraceMachine::new(
        DefaultMachineBuilder::new(machine_core)
            .instruction_cycle_func(Box::new(constant_cycles))
            .syscall(Box::new(IntSpawnSyscall {
                min_sp: min_sp.clone(),
            }))
            .build(),
    );
    machine
        .load_program(&buffer, [Ok("main".into())].into_iter())
        .unwrap();
    let result = machine.run();
    assert!(result.is_ok());
    assert!(result.unwrap() == 0);
    // When the VM makes 64 recursive calls, make sure the stack is less than 1M.
    println!("stack size: {}", cur_sp - *min_sp.lock().unwrap());
    assert!((cur_sp - *min_sp.lock().unwrap()) < 1024 * 1024);
}

#[cfg(has_asm)]
#[test]
pub fn test_spawn_asm() {
    let buffer = std::fs::read("tests/programs/spawn").unwrap().into();
    let cur_sp = stack_depth();
    let min_sp = Arc::new(Mutex::new(u64::MAX));
    let machine_core_asm = AsmCoreMachine::new(ISA_IMC | ISA_B | ISA_MOP, VERSION2, u64::MAX);
    let machine_core = DefaultMachineBuilder::<Box<AsmCoreMachine>>::new(machine_core_asm)
        .instruction_cycle_func(Box::new(constant_cycles))
        .syscall(Box::new(AsmSpawnSyscall {
            min_sp: min_sp.clone(),
        }))
        .build();
    let mut machine = AsmMachine::new(machine_core);
    machine
        .load_program(&buffer, [Ok("main".into())].into_iter())
        .unwrap();
    let result = machine.run();
    assert!(result.is_ok());
    assert!(result.unwrap() == 0);
    // When the VM makes 64 recursive calls, make sure the stack is less than 1M.
    println!("stack size: {}", cur_sp - *min_sp.lock().unwrap());
    assert!((cur_sp - *min_sp.lock().unwrap()) < 1024 * 1024);
}


================================================
File: tests/test_versions.rs
================================================
#![cfg(has_asm)]
use ckb_vm::cost_model::constant_cycles;
use ckb_vm::error::OutOfBoundKind;
use ckb_vm::machine::asm::{AsmCoreMachine, AsmMachine};
use ckb_vm::machine::{VERSION0, VERSION1, VERSION2};
use ckb_vm::memory::{FLAG_DIRTY, FLAG_FREEZED};
use ckb_vm::{
    CoreMachine, DefaultCoreMachine, DefaultMachine, DefaultMachineBuilder, Error, Memory,
    SparseMemory, TraceMachine, WXorXMemory, ISA_B, ISA_IMC, ISA_MOP, RISCV_PAGESIZE,
};
use std::fs;

type Mem = WXorXMemory<SparseMemory<u64>>;

fn create_rust_machine(
    program: String,
    version: u32,
) -> DefaultMachine<DefaultCoreMachine<u64, Mem>> {
    let path = format!("tests/programs/{}", program);
    let buffer = fs::read(path).unwrap().into();
    let core_machine = DefaultCoreMachine::<u64, Mem>::new(ISA_IMC, version, u64::MAX);
    let mut machine =
        DefaultMachineBuilder::<DefaultCoreMachine<u64, Mem>>::new(core_machine).build();
    machine
        .load_program(&buffer, [Ok(program.into())].into_iter())
        .unwrap();
    machine
}

fn create_asm_machine(program: String, version: u32) -> AsmMachine {
    let path = format!("tests/programs/{}", program);
    let buffer = fs::read(path).unwrap().into();
    let asm_core = AsmCoreMachine::new(ISA_IMC, version, u64::MAX);
    let core = DefaultMachineBuilder::<Box<AsmCoreMachine>>::new(asm_core).build();
    let mut machine = AsmMachine::new(core);
    machine
        .load_program(&buffer, [Ok(program.into())].into_iter())
        .unwrap();
    machine
}

#[test]
pub fn test_rust_version0_argv_null() {
    let mut machine = create_rust_machine("argv_null_test".to_string(), VERSION0);
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 1);
}

#[test]
pub fn test_rust_version0_sp_alignment() {
    let mut machine = create_rust_machine("sp_alignment_test".to_string(), VERSION0);
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 1);
}

#[test]
pub fn test_rust_version0_jalr_bug() {
    let mut machine = create_rust_machine("jalr_bug".to_string(), VERSION0);
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), -1);
}

#[test]
pub fn test_rust_version0_jalr_bug_noc() {
    let mut machine = create_rust_machine("jalr_bug_noc".to_string(), VERSION0);
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), -1);
}

#[test]
pub fn test_rust_version0_read_at_boundary() {
    let mut machine = create_rust_machine("read_at_boundary64".to_string(), VERSION0);
    let result = machine.run();
    assert!(result.is_err());
    assert_eq!(
        result.err(),
        Some(Error::MemOutOfBound(0x400000, OutOfBoundKind::Memory))
    );
}

#[test]
pub fn test_rust_version0_write_at_boundary() {
    let mut machine = create_rust_machine("write_at_boundary64".to_string(), VERSION0);
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
}

#[test]
pub fn test_rust_version1_argv_null() {
    let mut machine = create_rust_machine("argv_null_test".to_string(), VERSION1);
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
}

#[test]
pub fn test_rust_version1_sp_alignment() {
    let mut machine = create_rust_machine("sp_alignment_test".to_string(), VERSION1);
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
}

#[test]
pub fn test_rust_version1_jalr_bug() {
    let mut machine = create_rust_machine("jalr_bug".to_string(), VERSION1);
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
}

#[test]
pub fn test_rust_version1_jalr_bug_noc() {
    let mut machine = create_rust_machine("jalr_bug_noc".to_string(), VERSION1);
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
}

#[test]
pub fn test_rust_version1_read_at_boundary() {
    let mut machine = create_rust_machine("read_at_boundary64".to_string(), VERSION1);
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
}

#[test]
pub fn test_rust_version1_write_at_boundary() {
    let mut machine = create_rust_machine("write_at_boundary64".to_string(), VERSION1);
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
}

#[test]
pub fn test_asm_version0_argv_null() {
    let mut machine = create_asm_machine("argv_null_test".to_string(), VERSION0);
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 1);
}

#[test]
pub fn test_asm_version0_sp_alignment() {
    let mut machine = create_asm_machine("sp_alignment_test".to_string(), VERSION0);
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 1);
}

#[test]
pub fn test_asm_version0_jalr_bug() {
    let mut machine = create_asm_machine("jalr_bug".to_string(), VERSION0);
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), -1);
}

#[test]
pub fn test_asm_version0_jalr_bug_noc() {
    let mut machine = create_asm_machine("jalr_bug_noc".to_string(), VERSION0);
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), -1);
}

#[test]
pub fn test_asm_version0_read_at_boundary() {
    let mut machine = create_asm_machine("read_at_boundary64".to_string(), VERSION0);
    let result = machine.run();
    assert!(result.is_err());
    assert_eq!(
        result.err(),
        Some(Error::MemOutOfBound(0x400000, OutOfBoundKind::Memory))
    );
}

#[test]
pub fn test_asm_version0_write_at_boundary() {
    let mut machine = create_asm_machine("write_at_boundary64".to_string(), VERSION0);
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
}

#[test]
pub fn test_asm_version1_argv_null() {
    let mut machine = create_asm_machine("argv_null_test".to_string(), VERSION1);
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
}

#[test]
pub fn test_asm_version1_sp_alignment() {
    let mut machine = create_asm_machine("sp_alignment_test".to_string(), VERSION1);
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
}

#[test]
pub fn test_asm_version1_jalr_bug() {
    let mut machine = create_asm_machine("jalr_bug".to_string(), VERSION1);
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
}

#[test]
pub fn test_asm_version1_jalr_bug_noc() {
    let mut machine = create_asm_machine("jalr_bug_noc".to_string(), VERSION1);
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
}

#[test]
pub fn test_asm_version1_read_at_boundary() {
    let mut machine = create_asm_machine("read_at_boundary64".to_string(), VERSION1);
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
}

#[test]
pub fn test_asm_version1_write_at_boundary() {
    let mut machine = create_asm_machine("write_at_boundary64".to_string(), VERSION1);
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
}

#[test]
pub fn test_rust_version0_unaligned64() {
    let program = "unaligned64";
    let buffer = fs::read(format!("tests/programs/{}", program))
        .unwrap()
        .into();
    let core_machine = DefaultCoreMachine::<u64, Mem>::new(ISA_IMC, VERSION0, u64::MAX);
    let mut machine =
        DefaultMachineBuilder::<DefaultCoreMachine<u64, Mem>>::new(core_machine).build();
    let result = machine.load_program(&buffer, [Ok(program.into())].into_iter());
    assert!(result.is_err());
    assert_eq!(result.err(), Some(Error::MemWriteOnExecutablePage(16)));
}

#[test]
pub fn test_rust_version1_unaligned64() {
    let mut machine = create_rust_machine("unaligned64".to_string(), VERSION1);
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
}

#[test]
pub fn test_asm_version0_unaligned64() {
    let program = "unaligned64";
    let buffer = fs::read(format!("tests/programs/{}", program))
        .unwrap()
        .into();
    let asm_core = AsmCoreMachine::new(ISA_IMC, VERSION0, u64::MAX);
    let core = DefaultMachineBuilder::<Box<AsmCoreMachine>>::new(asm_core).build();
    let mut machine = AsmMachine::new(core);
    let result = machine.load_program(&buffer, [Ok(program.into())].into_iter());
    assert!(result.is_err());
    assert_eq!(result.err(), Some(Error::MemWriteOnExecutablePage(16)));
}

#[test]
pub fn test_asm_version1_unaligned64() {
    let mut machine = create_asm_machine("unaligned64".to_string(), VERSION1);
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
}

#[test]
pub fn test_asm_version0_writable_page() {
    let mut machine = create_asm_machine("writable_page".to_string(), VERSION0);
    // 0x12000 is the address of the variable "buffer", which can be found from the dump file.
    let page_index = 0x12000 / RISCV_PAGESIZE as u64;
    let flag = machine.machine.memory_mut().fetch_flag(page_index).unwrap();
    assert_eq!(flag, FLAG_DIRTY | FLAG_FREEZED);
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
}

#[test]
pub fn test_asm_version1_writable_page() {
    let mut machine = create_asm_machine("writable_page".to_string(), VERSION1);
    let page_index = 0x12000 / RISCV_PAGESIZE as u64;
    let flag = machine.machine.memory_mut().fetch_flag(page_index).unwrap();
    assert_eq!(flag, FLAG_DIRTY);
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
}

#[test]
pub fn test_asm_version0_goblin_overflow_elf() {
    // This test case only guarantee that the process of loading elf will not crash.
    let machine = create_asm_machine("goblin_overflow_elf".to_string(), VERSION0);
    assert_eq!(machine.machine.version(), VERSION0);
}

#[test]
pub fn test_asm_version1_goblin_overflow_elf() {
    // This test case only guarantee that the process of loading elf will not crash.
    let machine = create_asm_machine("goblin_overflow_elf".to_string(), VERSION1);
    assert_eq!(machine.machine.version(), VERSION1);
}

#[test]
pub fn test_asm_version0_cadd_hints() {
    let mut machine = create_rust_machine("cadd_hints".to_string(), VERSION0);
    let result = machine.run();
    assert!(result.is_err());
    assert_eq!(
        result.unwrap_err(),
        Error::InvalidInstruction {
            pc: 65656,
            instruction: 36906
        }
    );
}

#[test]
pub fn test_asm_version1_cadd_hints() {
    let mut machine = create_rust_machine("cadd_hints".to_string(), VERSION1);
    let result = machine.run();
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 0);
}

#[test]
pub fn test_asm_version1_asm_trace_bug() {
    let buffer = fs::read("tests/programs/asm_trace_bug").unwrap().into();

    let mut machine = {
        let asm_core = AsmCoreMachine::new(ISA_IMC | ISA_B | ISA_MOP, VERSION1, 2000);
        let machine = DefaultMachineBuilder::<Box<AsmCoreMachine>>::new(asm_core)
            .instruction_cycle_func(Box::new(constant_cycles))
            .build();
        AsmMachine::new(machine)
    };
    machine.load_program(&buffer, [].into_iter()).unwrap();
    let result = machine.run();

    assert_eq!(result, Err(Error::CyclesExceeded));
}

#[test]
pub fn test_asm_version2_asm_trace_bug() {
    let buffer = fs::read("tests/programs/asm_trace_bug").unwrap().into();

    let mut machine = {
        let asm_core = AsmCoreMachine::new(ISA_IMC | ISA_B | ISA_MOP, VERSION2, 2000);
        let machine = DefaultMachineBuilder::<Box<AsmCoreMachine>>::new(asm_core)
            .instruction_cycle_func(Box::new(constant_cycles))
            .build();
        AsmMachine::new(machine)
    };
    machine.load_program(&buffer, [].into_iter()).unwrap();
    let result = machine.run();

    assert_eq!(
        result,
        Err(Error::MemOutOfBound(21474836484, OutOfBoundKind::Memory))
    );
}

#[test]
pub fn test_trace_version1_asm_trace_bug() {
    let buffer = fs::read("tests/programs/asm_trace_bug").unwrap().into();

    let mut machine = {
        let core_machine = DefaultCoreMachine::<u64, WXorXMemory<SparseMemory<u64>>>::new(
            ISA_IMC | ISA_B | ISA_MOP,
            VERSION1,
            2000,
        );
        TraceMachine::new(
            DefaultMachineBuilder::new(core_machine)
                .instruction_cycle_func(Box::new(constant_cycles))
                .build(),
        )
    };
    machine.load_program(&buffer, [].into_iter()).unwrap();
    let result = machine.run();

    assert_eq!(result, Err(Error::CyclesExceeded));
}

#[test]
pub fn test_trace_version2_asm_trace_bug() {
    let buffer = fs::read("tests/programs/asm_trace_bug").unwrap().into();

    let mut machine = {
        let core_machine = DefaultCoreMachine::<u64, WXorXMemory<SparseMemory<u64>>>::new(
            ISA_IMC | ISA_B | ISA_MOP,
            VERSION2,
            2000,
        );
        TraceMachine::new(
            DefaultMachineBuilder::new(core_machine)
                .instruction_cycle_func(Box::new(constant_cycles))
                .build(),
        )
    };
    machine.load_program(&buffer, [].into_iter()).unwrap();
    let result = machine.run();

    assert_eq!(
        result,
        Err(Error::MemOutOfBound(21474836484, OutOfBoundKind::Memory))
    );
}


================================================
File: tests/programs/_build_all.sh
================================================
BUILDER_DOCKER="nervos/ckb-riscv-gnu-toolchain:bionic-20210804"

docker run --rm -v `pwd`:/code ${BUILDER_DOCKER} bash -c "cd /code && sh _build_all_native.sh"


================================================
File: tests/programs/_build_all_native.sh
================================================
set -ex

riscv64-unknown-elf-gcc -o resume2_load_data resume2_load_data.c
riscv64-unknown-elf-gcc -o alloc_many alloc_many.c
riscv64-unknown-elf-as -o amo_check_write.o amo_check_write.S && riscv64-unknown-elf-ld -T amo_check_write.lds -o amo_check_write amo_check_write.o && rm amo_check_write.o
riscv64-unknown-elf-as -o amo_compare.o amo_compare.S && riscv64-unknown-elf-ld -T amo_compare.lds -o amo_compare amo_compare.o && rm amo_compare.o
riscv64-unknown-elf-as -o amo_write_permission.o amo_write_permission.S && riscv64-unknown-elf-ld -o amo_write_permission amo_write_permission.o && rm amo_write_permission.o
# SKIP: andi
riscv64-unknown-elf-gcc -o argv_null_test argv_null_test.c
riscv64-unknown-elf-gcc -o big_binary big_binary.c
riscv64-unknown-elf-as -march=rv64imc -o cadd_hints.o cadd_hints.S && riscv64-unknown-elf-ld -o cadd_hints cadd_hints.o && rm cadd_hints.o
riscv64-unknown-elf-as -o ckbforks.o ckbforks.S && riscv64-unknown-elf-ld -o ckbforks ckbforks.o && rm ckbforks.o
# TODO: clzw_bug
# SKIP: decoder_instructions_cache_pc_out_of_bound_timeout
riscv64-unknown-elf-as -o ebreak.o ebreak.S && riscv64-unknown-elf-ld -o ebreak64 ebreak.o && rm ebreak.o
# SKIP: flat_crash_64
# SKIP: goblin_overflow_elf
# SKIP: invalid_file_offset64*
riscv64-unknown-elf-as -o invalid_read.o invalid_read.S && riscv64-unknown-elf-ld -o invalid_read64 invalid_read.o && rm invalid_read.o
riscv64-unknown-elf-as -march=rv64imc -o jalr_bug.o jalr_bug.S && riscv64-unknown-elf-ld -o jalr_bug jalr_bug.o && rm jalr_bug.o
riscv64-unknown-elf-as -o jalr_bug_noc.o jalr_bug_noc.S && riscv64-unknown-elf-ld -o jalr_bug_noc jalr_bug_noc.o && rm jalr_bug_noc.o
riscv64-unknown-elf-as -o jump0.o jump0.S && riscv64-unknown-elf-ld -o jump0_64 jump0.o && rm jump0.o
# SKIP: load_elf_crash_64
# SKIP: load_elf_section_crash_64
# SKIP: load_malformed_elf_crash_64
# SKIP: minimal
riscv64-unknown-elf-as -o misaligned_jump.o misaligned_jump.S && riscv64-unknown-elf-ld -o misaligned_jump64 misaligned_jump.o && rm misaligned_jump.o
riscv64-unknown-elf-as -o mop_adc.o mop_adc.S && riscv64-unknown-elf-ld -o mop_adc mop_adc.o && rm mop_adc.o
riscv64-unknown-elf-as -o mop_adcs.o mop_adcs.S && riscv64-unknown-elf-ld -o mop_adcs mop_adcs.o && rm mop_adcs.o
riscv64-unknown-elf-as -o mop_sbbs.o mop_sbbs.S && riscv64-unknown-elf-ld -o mop_sbbs mop_sbbs.o && rm mop_sbbs.o
riscv64-unknown-elf-as -o mop_add3.o mop_add3.S && riscv64-unknown-elf-ld -o mop_add3 mop_add3.o && rm mop_add3.o
riscv64-unknown-elf-as -march=rv64imc -o mop_far_jump.o mop_far_jump.S && riscv64-unknown-elf-ld -o mop_far_jump mop_far_jump.o && rm mop_far_jump.o
riscv64-unknown-elf-gcc -o mop_ld_signextend_32 mop_ld_signextend_32.c
riscv64-unknown-elf-as -o mop_ld_signextend_32_overflow_bug.o mop_ld_signextend_32_overflow_bug.S && riscv64-unknown-elf-ld -o mop_ld_signextend_32_overflow_bug mop_ld_signextend_32_overflow_bug.o && rm mop_ld_signextend_32_overflow_bug.o
riscv64-unknown-elf-as -o mop_random_adc_sbb.o mop_random_adc_sbb.S && riscv64-unknown-elf-ld -o mop_random_adc_sbb mop_random_adc_sbb.o && rm mop_random_adc_sbb.o
riscv64-unknown-elf-as -o mop_sbb.o mop_sbb.S && riscv64-unknown-elf-ld -o mop_sbb mop_sbb.o && rm mop_sbb.o
riscv64-unknown-elf-as -o mop_wide_div_zero.o mop_wide_div_zero.S && riscv64-unknown-elf-ld -o mop_wide_div_zero mop_wide_div_zero.o && rm mop_wide_div_zero.o
riscv64-unknown-elf-gcc -o mop_wide_divide mop_wide_divide.c
riscv64-unknown-elf-as -o mop_wide_mul_zero.o mop_wide_mul_zero.S && riscv64-unknown-elf-ld -o mop_wide_mul_zero mop_wide_mul_zero.o && rm mop_wide_mul_zero.o
riscv64-unknown-elf-gcc -o mop_wide_multiply mop_wide_multiply.c
riscv64-unknown-elf-as -o mulw.o mulw.S && riscv64-unknown-elf-ld -o mulw64 mulw.o && rm mulw.o
# SKIP: nop
# SKIP: op_rvc_slli_crash_32
# SKIP: op_rvc_srai_crash_32
# SKIP: op_rvc_srli_crash_32
riscv64-unknown-elf-gcc -o pause_resume pause_resume.c
# TODO: pcnt
riscv64-unknown-elf-as -o read_at_boundary.o read_at_boundary.S && riscv64-unknown-elf-ld -o read_at_boundary64 read_at_boundary.o && rm read_at_boundary.o
riscv64-unknown-elf-as -o read_memory.o read_memory.S && riscv64-unknown-elf-ld -o read_memory read_memory.o && rm read_memory.o
riscv64-unknown-elf-gcc -o reset_callee reset_callee.c
riscv64-unknown-elf-gcc -o reset_caller reset_caller.c
riscv64-unknown-elf-as -o rorw_in_end_of_aot_block.o rorw_in_end_of_aot_block.S && riscv64-unknown-elf-ld -o rorw_in_end_of_aot_block rorw_in_end_of_aot_block.o && rm rorw_in_end_of_aot_block.o
sh rvc_pageend.sh
# TODO: sbinvi_aot_load_imm_bug
riscv64-unknown-elf-as -o sc_after_sc.o sc_after_sc.S && riscv64-unknown-elf-ld -T sc_after_sc.lds -o sc_after_sc sc_after_sc.o && rm sc_after_sc.o
riscv64-unknown-elf-as -o sc_after_snapshot.o sc_after_snapshot.S && riscv64-unknown-elf-ld -T sc_after_snapshot.lds -o sc_after_snapshot sc_after_snapshot.o && rm sc_after_snapshot.o
riscv64-unknown-elf-as -o sc_only.o sc_only.S && riscv64-unknown-elf-ld -T sc_only.lds -o sc_only sc_only.o && rm sc_only.o
# SKIP: simple
riscv64-unknown-elf-gcc -o simple64 simple.c
riscv64-unknown-elf-as -o sp_alignment_test.o sp_alignment_test.S && riscv64-unknown-elf-ld -o sp_alignment_test sp_alignment_test.o && rm sp_alignment_test.o
riscv64-unknown-elf-gcc -o spawn spawn.c
riscv64-unknown-elf-as -o syscall.o syscall.S && riscv64-unknown-elf-ld -o syscall64 syscall.o && rm syscall.o
riscv64-unknown-elf-as -o trace.o trace.S && riscv64-unknown-elf-ld -o trace64 trace.o && rm trace.o
# SKIP: unaligned64
riscv64-unknown-elf-gcc -o writable_page writable_page.c && riscv64-unknown-elf-objdump -h writable_page > writable_page.dump
riscv64-unknown-elf-as -o write_at_boundary.o write_at_boundary.S && riscv64-unknown-elf-ld -o write_at_boundary64 write_at_boundary.o && rm write_at_boundary.o
riscv64-unknown-elf-as -o write_large_address.o write_large_address.S && riscv64-unknown-elf-ld -o write_large_address64 write_large_address.o && rm write_large_address.o
# riscv64-unknown-elf-as -march=rv64i_zba_zbb_zbc clmul_bug.S -o clmul_bug.o && riscv64-unknown-elf-ld clmul_bug.o -o clmul_bug && rm clmul_bug.o
# riscv64-unknown-elf-as -march=rv64i_zba_zbb_zbc orc_bug.S -o orc_bug.o && riscv64-unknown-elf-ld orc_bug.o -o orc_bug && rm orc_bug.o
riscv64-unknown-elf-as -o zero_address.o zero_address.S && riscv64-unknown-elf-ld -T zero_address.lds -o zero_address zero_address.o && rm zero_address.o
riscv64-unknown-elf-as -o mop_jump_rel_version1_bug.o mop_jump_rel_version1_bug.S && riscv64-unknown-elf-ld -o mop_jump_rel_version1_bug mop_jump_rel_version1_bug.o && rm mop_jump_rel_version1_bug.o
riscv64-unknown-elf-as -o mop_jump_rel_version1_reg_not_updated_bug.o mop_jump_rel_version1_reg_not_updated_bug.S && riscv64-unknown-elf-ld -o mop_jump_rel_version1_reg_not_updated_bug mop_jump_rel_version1_reg_not_updated_bug.o && rm mop_jump_rel_version1_reg_not_updated_bug.o
riscv64-unknown-elf-as -o mop_jump_abs_version1_reg_not_updated_bug.o mop_jump_abs_version1_reg_not_updated_bug.S && riscv64-unknown-elf-ld -o mop_jump_abs_version1_reg_not_updated_bug mop_jump_abs_version1_reg_not_updated_bug.o && rm mop_jump_abs_version1_reg_not_updated_bug.o
echo "done"


================================================
File: tests/programs/_build_clang.sh
================================================
set -ex

DOCKER="${DOCKER:-docker}"
# docker pull docker.io/cryptape/llvm-n-rust:20240630
DOCKER_IMAGE="${DOCKER_IMAGE:-docker.io/cryptape/llvm-n-rust@sha256:bafaf76d4f342a69b8691c08e77a330b7740631f3d1d9c9bee4ead521b29ee55}"

$DOCKER run --rm -e UID=`id -u` -e GID=`id -g` $DOCKER_RUN_ARGS -v `pwd`:/code $DOCKER_IMAGE bash _build_clang_native.sh


================================================
File: tests/programs/_build_clang_native.sh
================================================
set -ex

ROOT_DIR=$(pwd)
CLANG="${CLANG:-clang-18}"
LD="${CLANG/clang/ld.lld}"
CFLAGS="--target=riscv64 -march=rv64imac_zba_zbb_zbc_zbs -nostdinc -isystem $ROOT_DIR/deps/musl/release/include -c -fdata-sections -ffunction-sections"
LDFLAGS="--gc-sections -nostdlib --sysroot $ROOT_DIR/deps/musl/release -L$ROOT_DIR/deps/musl/release/lib -lc -lgcc"

if [ ! -d deps ]; then
	mkdir deps
fi

if [ ! -d deps/musl ]; then
	cd deps
	git clone https://github.com/xxuejie/musl
	cd musl
	git checkout 603d5e9
	cd ../..
fi

if [ ! -d deps/musl/release ]; then
	cd deps/musl
	CLANG=$CLANG ./ckb/build.sh
	cd -
fi

$CLANG $CFLAGS clang_sample.c -o clang_sample.o && $LD $LDFLAGS clang_sample.o -o clang_sample && rm clang_sample.o


================================================
File: tests/programs/alloc_many.c
================================================
int main() {
    int a[256*1024] = {};
    for (int i = 0; i < 256*1024; i++) {
        if (a[i] != 0) {
            return 1;
        }
    }
    return 0;
}


================================================
File: tests/programs/amo_check_write.S
================================================
.global _start
_start:

    la a0, n0
    li a1, 1
    amoadd.w a2, a1, (a0)

    ld a3, (a0)
    bne a3, a1, fail
    bne a2, zero, fail

done:
    li a0, 0
    li a7, 93
    ecall
fail:
    li a0, 1
    li a7, 93
    ecall

.section .data
n0:
    .dword 0


================================================
File: tests/programs/amo_check_write.lds
================================================
SECTIONS
{
. = 0x100b0;
.text : { *(.text) }
. = 0x11000;
.data : { *(.data) }
}


================================================
File: tests/programs/amo_compare.S
================================================
.global _start
_start:

test_amominu_w:
    la a0, n0
    li a2, 0x00000001
    sw a2, (a0)
    li a3, 0x8000000000000000

    amominu.w a4, a3, (a0)
    li a5, 0x0000000000000001
    bne a4, a5, fail
    lw a6, (a0)
    li a7, 0x0000000000000000
    bne a6, a7, fail

test_amomaxu_w:
    la a0, n0
    li a2, 0x00000001
    sw a2, (a0)
    li a3, 0x8000000000000000

    amomaxu.w a4, a3, (a0)
    li a5, 0x0000000000000001
    bne a4, a5, fail
    lw a6, (a0)
    li a7, 0x0000000000000001
    bne a6, a7, fail

test_amomin_w:
    la a0, n0
    li a2, 0x00000001
    sw a2, (a0)
    li a3, 0x0000000080000000

    amomin.w a4, a3, (a0)
    li a5, 0x0000000000000001
    bne a4, a5, fail
    lw a6, (a0)
    li a7, 0xffffffff80000000
    bne a6, a7, fail

test_amomax_w:
    la a0, n0
    li a2, 0x00000001
    sw a2, (a0)
    li a3, 0x0000000080000000

    amomax.w a4, a3, (a0)
    li a5, 0x0000000000000001
    bne a4, a5, fail
    lw a6, (a0)
    li a7, 0x0000000000000001
    bne a6, a7, fail

done:
    li a0, 0
    li a7, 93
    ecall
fail:
    li a0, 1
    li a7, 93
    ecall
.section .data
n0:
    .dword 0


================================================
File: tests/programs/amo_compare.lds
================================================
SECTIONS
{
. = 0x100b0;
.text : { *(.text) }
. = 0x11000;
.data : { *(.data) }
}


================================================
File: tests/programs/amo_write_permission.S
================================================
.global _start
_start:
  li a3, 0x100b4
  li a1, 1
  amoswap.d a4, a1, (a3)
  li a0, 0
  li a7, 93
  ecall


================================================
File: tests/programs/andi.c
================================================
int main() {
  int a = 0x501;

  int b = a & ~(0x7);

  if (b != 0x500) { return 1; }

  return 0;
}


================================================
File: tests/programs/argv_null_test.c
================================================
/*
 * See https://github.com/nervosnetwork/ckb-vm/issues/98 for more details.
 */
#include <stddef.h>

int main(int argc,  char *argv[]) {
  if (argv[argc] == NULL) {
    return 0;
  }
  return 1;
}


================================================
File: tests/programs/auipc_no_sign_extend.S
================================================
  .global _start
_start:
  auipc gp, 0x0
  addi gp, gp, 6
  auipc a0, 0x7ffff
  sub a0, a0, gp
  lui gp, 0x7ffff
  beq a0, gp, ok
  li a0, 1
  li a7, 93
  ecall
ok:
  li a0, 0
  li a7, 93
  ecall


================================================
File: tests/programs/big_binary.c
================================================
const char array[1024*1024] = {1};

int main() {
    return 0;
}


================================================
File: tests/programs/cadd_hints.S
================================================
.global _start
_start:
  c.add zero, a0
  li a0, 0
  li a7, 93
  ecall


================================================
File: tests/programs/ckbforks.S
================================================
.section .ckb.forks
ver:
  .string "1.0.1"

.text
.global _start
_start:
  li a0, 1
  li a7, 93
  ecall


================================================
File: tests/programs/clang_sample.c
================================================
int main() {
    return 0;
}


================================================
File: tests/programs/clmul_bug.S
================================================
.global _start
_start:
    li a0, 10
    li a1, 20
    clmul a0, a0, a1
    add a0, a0, 120
    li a7, 93
    ecall


================================================
File: tests/programs/clzw_bug.S
================================================
.global _start
_start:
  li a0, 0xffffffffffffffff
  clzw s8, a0
  clz a0, s8
  li a1, 64
  beq a1, a0, ok
  li a0, 1
  li a7, 93
  ecall
ok:
  li a0, 0
  li a7, 93
  ecall


================================================
File: tests/programs/ebreak.S
================================================
  .global _start
_start:
  ebreak
  li a7, 93
  ecall


================================================
File: tests/programs/invalid_read.S
================================================
.global _start
_start:
  li a1, -1
  ld a2, 0(a1)
  li a0, 0
  li a7, 93
  ecall


================================================
File: tests/programs/jalr_bug.S
================================================
.global _start
_start:
  auipc ra, 0
  addi ra, ra, 18
  jalr ra
  li a0, -1
  li a7, 93
  ecall
1:
  li a0, 0
  li a7, 93
  ecall


================================================
File: tests/programs/jalr_bug_noc.S
================================================
.global _start
_start:
  auipc ra, 0
  addi ra, ra, 24
  jalr ra
  li a0, -1
  li a7, 93
  ecall
1:
  li a0, 0
  li a7, 93
  ecall


================================================
File: tests/programs/jump0.S
================================================
.global _start
_start:
  j 0
  li a1, 0
  li a7, 93
  ecall


================================================
File: tests/programs/load_malformed_elf_crash_64
================================================
A simple Hello World might kill you :)


================================================
File: tests/programs/memory_crash.md
================================================
This file comes from a fuzzing test.


================================================
File: tests/programs/minimal.c
================================================
/*
 * First, compile riscv-gnu-toolchain with `--with-arch=rv32imac --with-abi=ilp32`,
 * then compile current file with riscv32-unknown-elf-gcc -o minimal minimal.c
 */
int main(int argc, char* argv[])
{
  if (argc == 1) {
    return 1;
  }
  if (argv[1][0] == 'a') {
    return 2;
  }
  return 0;
}


================================================
File: tests/programs/misaligned_jump.S
================================================
.global _start
_start:
  li a7, 93
  la s2, 1f + 1
  jalr x0, s2, 0
  li a6, 17
1:
  li a5, 45
  la s3, 2f
  jalr x0, s3, 1
  li a4, 5
  li a3, 0
2:
  li a2, 19
  li a1, 0
  ecall


================================================
File: tests/programs/mop_adc.S
================================================
.global _start
_start:
  li a0, 0x7fffffffffffffff
  li a1, 1
  li a2, 0x8000000000000000
  add a0, a0, a1
  sltu a1, a0, a1
  add a0, a0, a2
  sltu a2, a0, a2
  or a1, a1, a2
  li t0, 0
  bne a0, t0, fail
  li t0, 1
  bne a1, t0, fail
  li t0, 1
  bne a2, t0, fail

  li a0, 0x390a5a5fad56f578
  li a1, 0xdd8f0883fdd78883
  li a2, 0x7f6dbfa760006b9e
  add a0, a0, a1
  sltu a1, a0, a1
  add a0, a0, a2
  sltu a2, a0, a2
  or a1, a1, a2
  li t0, 0x9607228b0b2ee999
  bne a0, t0, fail
  li t0, 1
  bne a1, t0, fail
  li t0, 0
  bne a2, t0, fail

  li a1, 1
  li a2, 1
  add zero, zero, a1
  sltu a1, zero, a1
  add zero, zero, a2
  sltu a2, zero, a2
  or a1, a1, a2
  li t0, 1
  bne a1, t0, fail
  li t0, 1
  bne a2, t0, fail

  li a0, 0
  li a7, 93
  ecall
fail:
  li a0, 1
  li a7, 93
  ecall


================================================
File: tests/programs/mop_adcs.S
================================================
.global _start
_start:
  li a0, 0x7fffffffffffffff
  li a1, 1
  add a0, a1, a0
  sltu a1, a0, a1
  li t0, 0x8000000000000000
  bne a0, t0, fail
  li t0, 0
  bne a1, t0, fail

  li a0, 0x7fffffffffffffff
  li a1, 1
  add a0, a0, a1
  sltu a1, a0, a1
  li t0, 0x8000000000000000
  bne a0, t0, fail
  li t0, 0
  bne a1, t0, fail

  li a0, 0xffffffffffffffff
  li a1, 1
  add a0, a1, a0
  sltu a1, a0, a1
  li t0, 0x0
  bne a0, t0, fail
  li t0, 1
  bne a1, t0, fail

  li a0, 0xffffffffffffffff
  li a1, 1
  add a0, a1, a0
  sltu a0, a0, a1
  li t0, 1
  bne a0, t0, fail

  li a0, 0xffffffffffffffff
  li a1, 1
  add a0, a0, a1
  sltu a0, a0, a1
  li t0, 1
  bne a0, t0, fail

  li a1, 0xfffffffffffffff0
  li a2, 2
  add a0, a1, a2
  sltu a3, a0, a1
  li t0, 0xfffffffffffffff2
  bne a0, t0, fail
  li t0, 0
  bne a3, t0, fail

  li a0, 0
  li a7, 93
  ecall
fail:
  li a0, 1
  li a7, 93
  ecall


================================================
File: tests/programs/mop_add3.S
================================================
.global _start
_start:
  /* ADD3A */
  li t0, 0x390a5a5fad56f578
  li t1, 0xdd8f0883fdd78883
  li t4, 0x7f6dbfa760006b9e
  add t0, t1, t0
  sltu t2, t0, t1
  add t3, t2, t4
  li s1, 0x169962e3ab2e7dfb
  li s0, 1
  bne t0, s1, fail
  li s1, 0xdd8f0883fdd78883
  li s0, 2
  bne t1, s1, fail
  li s1, 1
  li s0, 3
  bne t2, s1, fail
  li s1, 0x7f6dbfa760006b9f
  li s0, 4
  bne t3, s1, fail
  li s1, 0x7f6dbfa760006b9e
  li s0, 5
  bne t4, s1, fail

  li t0, 1000
  li t1, 2000
  li t4, 4000
  add t0, t1, t0
  sltu t2, t0, t1
  add t3, t2, t4
  li s1, 3000
  li s0, 6
  bne t0, s1, fail
  li s1, 2000
  li s0, 7
  bne t1, s1, fail
  li s1, 0
  li s0, 8
  bne t2, s1, fail
  li s1, 4000
  li s0, 9
  bne t3, s1, fail
  li s1, 4000
  li s0, 10
  bne t4, s1, fail

  li t0, 0x390a5a5fad56f578
  li t1, 0xdd8f0883fdd78883
  li t4, 0x7f6dbfa760006b9e
  add t0, t1, t0
  sltu t2, t0, t1
  add t4, t2, t4
  li s1, 0x169962e3ab2e7dfb
  li s0, 11
  bne t0, s1, fail
  li s1, 0xdd8f0883fdd78883
  li s0, 12
  bne t1, s1, fail
  li s1, 1
  li s0, 13
  bne t2, s1, fail
  li s1, 0x7f6dbfa760006b9f
  li s0, 14
  bne t4, s1, fail

  li t0, 0x390a5a5fad56f578
  li t1, 0xdd8f0883fdd78883
  li t4, 0x7f6dbfa760006b9e
  add t0, t1, t0
  sltu t0, t0, t1
  add t3, t0, t4
  li s1, 1
  li s0, 15
  bne t0, s1, fail
  li s1, 0xdd8f0883fdd78883
  li s0, 16
  bne t1, s1, fail
  li s1, 0x7f6dbfa760006b9f
  li s0, 17
  bne t3, s1, fail
  li s1, 0x7f6dbfa760006b9e
  li s0, 18
  bne t4, s1, fail

  li t0, 0x390a5a5fad56f578
  li t1, 0xdd8f0883fdd78883
  li t4, 0x7f6dbfa760006b9e
  add t0, t1, t0
  sltu t2, t0, t1
  add t0, t2, t4
  li s1, 0x7f6dbfa760006b9f
  li s0, 19
  bne t0, s1, fail
  li s1, 0xdd8f0883fdd78883
  li s0, 20
  bne t1, s1, fail
  li s1, 1
  li s0, 21
  bne t2, s1, fail
  li s1, 0x7f6dbfa760006b9e
  li s0, 22
  bne t4, s1, fail

  /* ADD3B */
  li t1, 0xdd8f0883fdd78883
  li t2, 0x7f6dbfa760006b9e
  li t4, 0x390a5a5fad56f578
  add t0, t1, t2
  sltu t1, t0, t1
  add t3, t1, t4
  li s1, 0x5cfcc82b5dd7f421
  li s0, 23
  bne t0, s1, fail
  li s1, 1
  li s0, 24
  bne t1, s1, fail
  li s1, 0x7f6dbfa760006b9e
  li s0, 25
  bne t2, s1, fail
  li s1, 0x390a5a5fad56f579
  li s0, 26
  bne t3, s1, fail
  li s1, 0x390a5a5fad56f578
  li s0, 27
  bne t4, s1, fail

  li t1, 3000
  li t2, 2000
  li t4, 4000
  add t0, t1, t2
  sltu t1, t0, t1
  add t3, t1, t4
  li s1, 5000
  li s0, 28
  bne t0, s1, fail
  li s1, 0
  li s0, 29
  bne t1, s1, fail
  li s1, 2000
  li s0, 30
  bne t2, s1, fail
  li s1, 4000
  li s0, 31
  bne t3, s1, fail
  li s1, 4000
  li s0, 32
  bne t4, s1, fail

  /* ADD3B r0 == r2 */
  li t1, 0xdd8f0883fdd78883
  li t0, 0x7f6dbfa760006b9e
  li t4, 0x390a5a5fad56f578
  add t0, t1, t0
  sltu t1, t0, t1
  add t3, t1, t4
  li s1, 0x5cfcc82b5dd7f421
  li s0, 33
  bne t0, s1, fail
  li s1, 1
  li s0, 34
  bne t1, s1, fail
  li s1, 0x390a5a5fad56f579
  li s0, 35
  bne t3, s1, fail
  li s1, 0x390a5a5fad56f578
  li s0, 36
  bne t4, s1, fail

  /* ADD3B r0 == r3 */
  li t1, 0xdd8f0883fdd78883
  li t2, 0x7f6dbfa760006b9e
  li t4, 0x390a5a5fad56f578
  add t0, t1, t2
  sltu t1, t0, t1
  add t0, t1, t4
  li s1, 0x390a5a5fad56f579
  li s0, 37
  bne t0, s1, fail
  li s1, 1
  li s0, 38
  bne t1, s1, fail
  li s1, 0x7f6dbfa760006b9e
  li s0, 39
  bne t2, s1, fail
  li s1, 0x390a5a5fad56f578
  li s0, 40
  bne t4, s1, fail

  /* ADD3B r1 = r3 */
  li t1, 0xdd8f0883fdd78883
  li t2, 0x7f6dbfa760006b9e
  li t4, 0x390a5a5fad56f578
  add t0, t1, t2
  sltu t1, t0, t1
  add t1, t1, t4
  li s1, 0x5cfcc82b5dd7f421
  li s0, 41
  bne t0, s1, fail
  li s1, 0x390a5a5fad56f579
  li s0, 42
  bne t1, s1, fail
  li s1, 0x7f6dbfa760006b9e
  li s0, 43
  bne t2, s1, fail
  li s1, 0x390a5a5fad56f578
  li s0, 44
  bne t4, s1, fail

  /* ADD3B r2 == r3 */
  li t1, 0xdd8f0883fdd78883
  li t2, 0x7f6dbfa760006b9e
  li t4, 0x390a5a5fad56f578
  add t0, t1, t2
  sltu t1, t0, t1
  add t2, t1, t4
  li s1, 0x5cfcc82b5dd7f421
  li s0, 45
  bne t0, s1, fail
  li s1, 1
  li s0, 46
  bne t1, s1, fail
  li s1, 0x390a5a5fad56f579
  li s0, 47
  bne t2, s1, fail
  li s1, 0x390a5a5fad56f578
  li s0, 48
  bne t4, s1, fail

  /* ADD3B r3 == r4 */
  li t1, 0xdd8f0883fdd78883
  li t2, 0x7f6dbfa760006b9e
  li t4, 0x390a5a5fad56f578
  add t0, t1, t2
  sltu t1, t0, t1
  add t4, t1, t4
  li s1, 0x5cfcc82b5dd7f421
  li s0, 49
  bne t0, s1, fail
  li s1, 1
  li s0, 50
  bne t1, s1, fail
  li s1, 0x7f6dbfa760006b9e
  li s0, 51
  bne t2, s1, fail
  li s1, 0x390a5a5fad56f579
  li s0, 52
  bne t4, s1, fail

  /* ADD3C */
  li t1, 0xad8f0883fdd78883
  li t2, 0x7f6db00760006b9e
  li t4, 0x390a5affff56f57f
  add t0, t1, t2
  sltu t3, t0, t1
  add t3, t3, t4
  li s1, 0x2cfcb88b5dd7f421
  li s0, 53
  bne t0, s1, fail
  li s1, 0xad8f0883fdd78883
  li s0, 54
  bne t1, s1, fail
  li s1, 0x7f6db00760006b9e
  li s0, 55
  bne t2, s1, fail
  li s1, 0x390a5affff56f580
  li s0, 56
  bne t3, s1, fail
  li s1, 0x390a5affff56f57f
  li s0, 57
  bne t4, s1, fail

  li t1, 1000
  li t2, 100
  li t4, 200
  add t0, t1, t2
  sltu t3, t0, t1
  add t3, t3, t4
  li s1, 1100
  li s0, 58
  bne t0, s1, fail
  li s1, 1000
  li s0, 59
  bne t1, s1, fail
  li s1, 100
  li s0, 60
  bne t2, s1, fail
  li s1, 200
  li s0, 61
  bne t3, s1, fail
  li s1, 200
  li s0, 62
  bne t4, s1, fail

  /* ADD3C r0 == r2 */
  li t1, 0xad8f0883fdd78883
  li t0, 0x7f6db00760006b9e
  li t4, 0x390a5affff56f57f
  add t0, t1, t0
  sltu t3, t0, t1
  add t3, t3, t4
  li s1, 0x2cfcb88b5dd7f421
  li s0, 63
  bne t0, s1, fail
  li s1, 0xad8f0883fdd78883
  li s0, 64
  bne t1, s1, fail
  li s1, 0x390a5affff56f580
  li s0, 65
  bne t3, s1, fail
  li s1, 0x390a5affff56f57f
  li s0, 66
  bne t4, s1, fail

  /* ADD3C r0 == r3 */
  li t1, 0xad8f0883fdd78883
  li t2, 0x7f6db00760006b9e
  li t4, 0x390a5affff56f57f
  add t0, t1, t2
  sltu t0, t0, t1
  add t0, t0, t4
  li s1, 0x390a5affff56f580
  li s0, 67
  bne t0, s1, fail
  li s1, 0xad8f0883fdd78883
  li s0, 68
  bne t1, s1, fail
  li s1, 0x7f6db00760006b9e
  li s0, 69
  bne t2, s1, fail
  li s1, 0x390a5affff56f57f
  li s0, 70
  bne t4, s1, fail

  /* ADD3C r1 == r3 */
  li t1, 0xad8f0883fdd78883
  li t2, 0x7f6db00760006b9e
  li t4, 0x390a5affff56f57f
  add t0, t1, t2
  sltu t1, t0, t1
  add t1, t1, t4
  li s1, 0x2cfcb88b5dd7f421
  li s0, 53
  bne t0, s1, fail
  li s1, 0x390a5affff56f580
  li s0, 54
  bne t1, s1, fail
  li s1, 0x7f6db00760006b9e
  li s0, 55
  bne t2, s1, fail
  li s1, 0x390a5affff56f57f
  li s0, 57
  bne t4, s1, fail

  /* ADD3C r2 == r3 */
  li t1, 0xad8f0883fdd78883
  li t3, 0x7f6db00760006b9e
  li t4, 0x390a5affff56f57f
  add t0, t1, t3
  sltu t3, t0, t1
  add t3, t3, t4
  li s1, 0x2cfcb88b5dd7f421
  li s0, 53
  bne t0, s1, fail
  li s1, 0xad8f0883fdd78883
  li s0, 54
  bne t1, s1, fail
  li s1, 0x390a5affff56f580
  li s0, 56
  bne t3, s1, fail
  li s1, 0x390a5affff56f57f
  li s0, 57
  bne t4, s1, fail

success:
  li a0, 0
  li a7, 93
  ecall
fail:
  li a0, 1
  li a7, 93
  ecall


================================================
File: tests/programs/mop_far_jump.S
================================================
.global _start
_start:
  auipc ra, 0x00
  jalr ra, ra, 0x08
  lui ra, 0x10
  jalr ra, ra, 0x90
  li a0, 1
  li a7, 93
  ecall
1:
  li a0, 0
  li a7, 93
  ecall


================================================
File: tests/programs/mop_far_jump.dump
================================================

mop_far_jump:     file format elf64-littleriscv


Disassembly of section .text:

0000000000010078 <_start>:
   10078:	00000097          	auipc	ra,0x0
   1007c:	008080e7          	jalr	8(ra) # 10080 <_start+0x8>
   10080:	60c1                	lui	ra,0x10
   10082:	090080e7          	jalr	144(ra) # 10090 <_start+0x18>
   10086:	4505                	li	a0,1
   10088:	05d00893          	li	a7,93
   1008c:	00000073          	ecall
   10090:	4501                	li	a0,0
   10092:	05d00893          	li	a7,93
   10096:	00000073          	ecall


================================================
File: tests/programs/mop_jump_abs_version1_reg_not_updated_bug.S
================================================
/* This test case is contributed by @mohanson */
.global _start
_start:
  lui a0, 0x4000
  jalr ra, a0, 1234


================================================
File: tests/programs/mop_jump_rel_version1_bug.S
================================================
/* This test case is contributed by @mohanson */
.global _start
_start:
  auipc ra, 0x80000
  jalr ra, ra, -0x7ff


================================================
File: tests/programs/mop_jump_rel_version1_reg_not_updated_bug.S
================================================
/* This test case is contributed by @mohanson */
.global _start
_start:
  auipc a0, 0x4000
  jalr ra, a0, 1234


================================================
File: tests/programs/mop_ld_signextend_32.c
================================================
// Use randomly generated numbers to test lui + addiw mop.

#include <stdint.h>

int32_t s = 0;

int main() {
    int32_t x0000 = 1176619451;
    s += x0000;
    int32_t x0001 = 2135832113;
    s += x0001;
    int32_t x0002 = 143853711;
    s += x0002;
    int32_t x0003 = 2070296293;
    s += x0003;
    int32_t x0004 = -1494330178;
    s += x0004;
    int32_t x0005 = 1236456640;
    s += x0005;
    int32_t x0006 = -565215017;
    s += x0006;
    int32_t x0007 = -1345427620;
    s += x0007;
    int32_t x0008 = 687921635;
    s += x0008;
    int32_t x0009 = -1176991959;
    s += x0009;
    int32_t x0010 = 742237362;
    s += x0010;
    int32_t x0011 = -1489771134;
    s += x0011;
    int32_t x0012 = -1307789199;
    s += x0012;
    int32_t x0013 = 1418788252;
    s += x0013;
    int32_t x0014 = 1238818078;
    s += x0014;
    int32_t x0015 = -383710029;
    s += x0015;
    int32_t x0016 = 1254634773;
    s += x0016;
    int32_t x0017 = -1958242233;
    s += x0017;
    int32_t x0018 = 443939464;
    s += x0018;
    int32_t x0019 = 258246648;
    s += x0019;
    int32_t x0020 = 1437725253;
    s += x0020;
    int32_t x0021 = -1912095660;
    s += x0021;
    int32_t x0022 = -101711598;
    s += x0022;
    int32_t x0023 = -1911300582;
    s += x0023;
    int32_t x0024 = -668094062;
    s += x0024;
    int32_t x0025 = -1188899464;
    s += x0025;
    int32_t x0026 = 671956712;
    s += x0026;
    int32_t x0027 = 1863078730;
    s += x0027;
    int32_t x0028 = -1623439818;
    s += x0028;
    int32_t x0029 = 428499149;
    s += x0029;
    int32_t x0030 = 985995692;
    s += x0030;
    int32_t x0031 = -653661394;
    s += x0031;
    int32_t x0032 = 1014512063;
    s += x0032;
    int32_t x0033 = 699001587;
    s += x0033;
    int32_t x0034 = 753901580;
    s += x0034;
    int32_t x0035 = -818587701;
    s += x0035;
    int32_t x0036 = 81834928;
    s += x0036;
    int32_t x0037 = -1407785019;
    s += x0037;
    int32_t x0038 = 1677583394;
    s += x0038;
    int32_t x0039 = 462643097;
    s += x0039;
    int32_t x0040 = 1389135823;
    s += x0040;
    int32_t x0041 = -2092907267;
    s += x0041;
    int32_t x0042 = -1268350094;
    s += x0042;
    int32_t x0043 = 695018865;
    s += x0043;
    int32_t x0044 = 1995280732;
    s += x0044;
    int32_t x0045 = -1947093793;
    s += x0045;
    int32_t x0046 = -913314154;
    s += x0046;
    int32_t x0047 = 1726202036;
    s += x0047;
    int32_t x0048 = -1161063586;
    s += x0048;
    int32_t x0049 = 636729929;
    s += x0049;
    int32_t x0050 = -654514346;
    s += x0050;
    int32_t x0051 = 1692883908;
    s += x0051;
    int32_t x0052 = 1383060652;
    s += x0052;
    int32_t x0053 = 1687321923;
    s += x0053;
    int32_t x0054 = 858271504;
    s += x0054;
    int32_t x0055 = -923691812;
    s += x0055;
    int32_t x0056 = 1783165443;
    s += x0056;
    int32_t x0057 = 1217990997;
    s += x0057;
    int32_t x0058 = -206322417;
    s += x0058;
    int32_t x0059 = 1201394518;
    s += x0059;
    int32_t x0060 = -1982626827;
    s += x0060;
    int32_t x0061 = -1222047922;
    s += x0061;
    int32_t x0062 = -1033654808;
    s += x0062;
    int32_t x0063 = 766817553;
    s += x0063;
    int32_t x0064 = 2044526273;
    s += x0064;
    int32_t x0065 = -1927396468;
    s += x0065;
    int32_t x0066 = -1186245400;
    s += x0066;
    int32_t x0067 = -1725892066;
    s += x0067;
    int32_t x0068 = 536199213;
    s += x0068;
    int32_t x0069 = -1219455257;
    s += x0069;
    int32_t x0070 = -1419845451;
    s += x0070;
    int32_t x0071 = 2082616365;
    s += x0071;
    int32_t x0072 = -954709945;
    s += x0072;
    int32_t x0073 = -1139536492;
    s += x0073;
    int32_t x0074 = 1327215156;
    s += x0074;
    int32_t x0075 = -516514218;
    s += x0075;
    int32_t x0076 = 569264889;
    s += x0076;
    int32_t x0077 = -697834107;
    s += x0077;
    int32_t x0078 = 241213403;
    s += x0078;
    int32_t x0079 = 767279885;
    s += x0079;
    int32_t x0080 = -2139969191;
    s += x0080;
    int32_t x0081 = -1779504254;
    s += x0081;
    int32_t x0082 = -1809272300;
    s += x0082;
    int32_t x0083 = 1874552326;
    s += x0083;
    int32_t x0084 = 2009460185;
    s += x0084;
    int32_t x0085 = 1777420967;
    s += x0085;
    int32_t x0086 = 674557361;
    s += x0086;
    int32_t x0087 = 1392623113;
    s += x0087;
    int32_t x0088 = 1415243215;
    s += x0088;
    int32_t x0089 = -958206037;
    s += x0089;
    int32_t x0090 = 1887643362;
    s += x0090;
    int32_t x0091 = 292912011;
    s += x0091;
    int32_t x0092 = -1662712021;
    s += x0092;
    int32_t x0093 = -1707351408;
    s += x0093;
    int32_t x0094 = -167453866;
    s += x0094;
    int32_t x0095 = 878978324;
    s += x0095;
    int32_t x0096 = -280778986;
    s += x0096;
    int32_t x0097 = -277738370;
    s += x0097;
    int32_t x0098 = 1742172662;
    s += x0098;
    int32_t x0099 = 1398517477;
    s += x0099;
    int32_t x0100 = -722311840;
    s += x0100;
    int32_t x0101 = -2134387899;
    s += x0101;
    int32_t x0102 = 559860047;
    s += x0102;
    int32_t x0103 = -1378246022;
    s += x0103;
    int32_t x0104 = -351585431;
    s += x0104;
    int32_t x0105 = 1402915932;
    s += x0105;
    int32_t x0106 = 1394906984;
    s += x0106;
    int32_t x0107 = -1266856833;
    s += x0107;
    int32_t x0108 = -1189391872;
    s += x0108;
    int32_t x0109 = -1971737814;
    s += x0109;
    int32_t x0110 = 2122720459;
    s += x0110;
    int32_t x0111 = -621952697;
    s += x0111;
    int32_t x0112 = -1928073415;
    s += x0112;
    int32_t x0113 = 1174065225;
    s += x0113;
    int32_t x0114 = -1980482579;
    s += x0114;
    int32_t x0115 = 1220199837;
    s += x0115;
    int32_t x0116 = 308552324;
    s += x0116;
    int32_t x0117 = -724473921;
    s += x0117;
    int32_t x0118 = -835167831;
    s += x0118;
    int32_t x0119 = -1662958358;
    s += x0119;
    int32_t x0120 = -283369697;
    s += x0120;
    int32_t x0121 = 1547384598;
    s += x0121;
    int32_t x0122 = 1442878601;
    s += x0122;
    int32_t x0123 = 560064984;
    s += x0123;
    int32_t x0124 = 481153968;
    s += x0124;
    int32_t x0125 = -2088826089;
    s += x0125;
    int32_t x0126 = -90064540;
    s += x0126;
    int32_t x0127 = -1236617164;
    s += x0127;
    int32_t x0128 = -1117873014;
    s += x0128;
    int32_t x0129 = 897124484;
    s += x0129;
    int32_t x0130 = -699178474;
    s += x0130;
    int32_t x0131 = 159408739;
    s += x0131;
    int32_t x0132 = 1756010962;
    s += x0132;
    int32_t x0133 = -1136224191;
    s += x0133;
    int32_t x0134 = 9557159;
    s += x0134;
    int32_t x0135 = 1811358289;
    s += x0135;
    int32_t x0136 = 2051302441;
    s += x0136;
    int32_t x0137 = 194927410;
    s += x0137;
    int32_t x0138 = 887837031;
    s += x0138;
    int32_t x0139 = -2000193666;
    s += x0139;
    int32_t x0140 = -310247022;
    s += x0140;
    int32_t x0141 = 1605131017;
    s += x0141;
    int32_t x0142 = 1781444025;
    s += x0142;
    int32_t x0143 = -34117479;
    s += x0143;
    int32_t x0144 = -317202724;
    s += x0144;
    int32_t x0145 = 996434744;
    s += x0145;
    int32_t x0146 = 84572233;
    s += x0146;
    int32_t x0147 = 836860807;
    s += x0147;
    int32_t x0148 = 1172150688;
    s += x0148;
    int32_t x0149 = -57586266;
    s += x0149;
    int32_t x0150 = 1236159237;
    s += x0150;
    int32_t x0151 = 1072949891;
    s += x0151;
    int32_t x0152 = 390468750;
    s += x0152;
    int32_t x0153 = -2110807464;
    s += x0153;
    int32_t x0154 = 1766214437;
    s += x0154;
    int32_t x0155 = 1289887280;
    s += x0155;
    int32_t x0156 = -2026882737;
    s += x0156;
    int32_t x0157 = -1609688780;
    s += x0157;
    int32_t x0158 = -1512669645;
    s += x0158;
    int32_t x0159 = -1624423511;
    s += x0159;
    int32_t x0160 = -1538324431;
    s += x0160;
    int32_t x0161 = 1706385333;
    s += x0161;
    int32_t x0162 = -702381527;
    s += x0162;
    int32_t x0163 = 1140813390;
    s += x0163;
    int32_t x0164 = -1074601325;
    s += x0164;
    int32_t x0165 = 565588491;
    s += x0165;
    int32_t x0166 = 403983788;
    s += x0166;
    int32_t x0167 = -1811767297;
    s += x0167;
    int32_t x0168 = -1139148764;
    s += x0168;
    int32_t x0169 = 1423380556;
    s += x0169;
    int32_t x0170 = -1179711849;
    s += x0170;
    int32_t x0171 = 1516411181;
    s += x0171;
    int32_t x0172 = -1571864156;
    s += x0172;
    int32_t x0173 = -1644309172;
    s += x0173;
    int32_t x0174 = 1684714975;
    s += x0174;
    int32_t x0175 = -1479597336;
    s += x0175;
    int32_t x0176 = 590475169;
    s += x0176;
    int32_t x0177 = -1544055181;
    s += x0177;
    int32_t x0178 = 1895044115;
    s += x0178;
    int32_t x0179 = 1690806106;
    s += x0179;
    int32_t x0180 = 1606137210;
    s += x0180;
    int32_t x0181 = -146575742;
    s += x0181;
    int32_t x0182 = 722519786;
    s += x0182;
    int32_t x0183 = 1576861173;
    s += x0183;
    int32_t x0184 = 332034025;
    s += x0184;
    int32_t x0185 = -2006195012;
    s += x0185;
    int32_t x0186 = 324489243;
    s += x0186;
    int32_t x0187 = 1520759239;
    s += x0187;
    int32_t x0188 = -1420912610;
    s += x0188;
    int32_t x0189 = -1079291137;
    s += x0189;
    int32_t x0190 = 1529058141;
    s += x0190;
    int32_t x0191 = -891196252;
    s += x0191;
    int32_t x0192 = -1235562540;
    s += x0192;
    int32_t x0193 = 510452269;
    s += x0193;
    int32_t x0194 = -211217712;
    s += x0194;
    int32_t x0195 = 287507759;
    s += x0195;
    int32_t x0196 = -1046270131;
    s += x0196;
    int32_t x0197 = -50647664;
    s += x0197;
    int32_t x0198 = 513047189;
    s += x0198;
    int32_t x0199 = -18943828;
    s += x0199;
    int32_t x0200 = 124266946;
    s += x0200;
    int32_t x0201 = 1238356103;
    s += x0201;
    int32_t x0202 = 2090751281;
    s += x0202;
    int32_t x0203 = 480087734;
    s += x0203;
    int32_t x0204 = -2108650757;
    s += x0204;
    int32_t x0205 = -248135599;
    s += x0205;
    int32_t x0206 = 769584708;
    s += x0206;
    int32_t x0207 = 1855484705;
    s += x0207;
    int32_t x0208 = -197158573;
    s += x0208;
    int32_t x0209 = 1536148579;
    s += x0209;
    int32_t x0210 = -618671685;
    s += x0210;
    int32_t x0211 = -784711816;
    s += x0211;
    int32_t x0212 = 991621213;
    s += x0212;
    int32_t x0213 = -804572274;
    s += x0213;
    int32_t x0214 = -54443047;
    s += x0214;
    int32_t x0215 = -1632848211;
    s += x0215;
    int32_t x0216 = 1252256079;
    s += x0216;
    int32_t x0217 = 696422026;
    s += x0217;
    int32_t x0218 = -1928420568;
    s += x0218;
    int32_t x0219 = -1885754431;
    s += x0219;
    int32_t x0220 = 1507123797;
    s += x0220;
    int32_t x0221 = -446132367;
    s += x0221;
    int32_t x0222 = 219502213;
    s += x0222;
    int32_t x0223 = 1215008069;
    s += x0223;
    int32_t x0224 = -938402963;
    s += x0224;
    int32_t x0225 = -1671241879;
    s += x0225;
    int32_t x0226 = 2145686470;
    s += x0226;
    int32_t x0227 = 1494307233;
    s += x0227;
    int32_t x0228 = 1530374309;
    s += x0228;
    int32_t x0229 = -455552257;
    s += x0229;
    int32_t x0230 = 846663176;
    s += x0230;
    int32_t x0231 = 2056040069;
    s += x0231;
    int32_t x0232 = -1418637666;
    s += x0232;
    int32_t x0233 = 738344793;
    s += x0233;
    int32_t x0234 = -1678041561;
    s += x0234;
    int32_t x0235 = 405130916;
    s += x0235;
    int32_t x0236 = -318016948;
    s += x0236;
    int32_t x0237 = -274661425;
    s += x0237;
    int32_t x0238 = 1971835264;
    s += x0238;
    int32_t x0239 = -821048710;
    s += x0239;
    int32_t x0240 = -407684050;
    s += x0240;
    int32_t x0241 = -1184337116;
    s += x0241;
    int32_t x0242 = 511872008;
    s += x0242;
    int32_t x0243 = 1041525225;
    s += x0243;
    int32_t x0244 = -677210180;
    s += x0244;
    int32_t x0245 = -623662757;
    s += x0245;
    int32_t x0246 = 135445209;
    s += x0246;
    int32_t x0247 = 1115621953;
    s += x0247;
    int32_t x0248 = 1058834819;
    s += x0248;
    int32_t x0249 = 1971369530;
    s += x0249;
    int32_t x0250 = 2022076084;
    s += x0250;
    int32_t x0251 = -433219464;
    s += x0251;
    int32_t x0252 = -962071004;
    s += x0252;
    int32_t x0253 = -1071701939;
    s += x0253;
    int32_t x0254 = -1213846329;
    s += x0254;
    int32_t x0255 = -1308646098;
    s += x0255;
    int32_t x0256 = 840413844;
    s += x0256;
    int32_t x0257 = -1438695260;
    s += x0257;
    int32_t x0258 = 2140728702;
    s += x0258;
    int32_t x0259 = -1677402700;
    s += x0259;
    int32_t x0260 = 612788461;
    s += x0260;
    int32_t x0261 = -1096861395;
    s += x0261;
    int32_t x0262 = 358413396;
    s += x0262;
    int32_t x0263 = 151751316;
    s += x0263;
    int32_t x0264 = 1645925001;
    s += x0264;
    int32_t x0265 = -1794913645;
    s += x0265;
    int32_t x0266 = 1856475627;
    s += x0266;
    int32_t x0267 = -835849301;
    s += x0267;
    int32_t x0268 = 121421063;
    s += x0268;
    int32_t x0269 = 1707045097;
    s += x0269;
    int32_t x0270 = -1808301459;
    s += x0270;
    int32_t x0271 = 557449106;
    s += x0271;
    int32_t x0272 = -1784050147;
    s += x0272;
    int32_t x0273 = -1661976388;
    s += x0273;
    int32_t x0274 = 1314041632;
    s += x0274;
    int32_t x0275 = -230129536;
    s += x0275;
    int32_t x0276 = 312742681;
    s += x0276;
    int32_t x0277 = -825236362;
    s += x0277;
    int32_t x0278 = 777936219;
    s += x0278;
    int32_t x0279 = -306823307;
    s += x0279;
    int32_t x0280 = -1679410846;
    s += x0280;
    int32_t x0281 = 1249781135;
    s += x0281;
    int32_t x0282 = -996702888;
    s += x0282;
    int32_t x0283 = 428195420;
    s += x0283;
    int32_t x0284 = -1635407251;
    s += x0284;
    int32_t x0285 = -460814765;
    s += x0285;
    int32_t x0286 = -1371069126;
    s += x0286;
    int32_t x0287 = -347364969;
    s += x0287;
    int32_t x0288 = 1488752632;
    s += x0288;
    int32_t x0289 = -110409787;
    s += x0289;
    int32_t x0290 = -1457470693;
    s += x0290;
    int32_t x0291 = 1040545222;
    s += x0291;
    int32_t x0292 = 1893273558;
    s += x0292;
    int32_t x0293 = -1506693698;
    s += x0293;
    int32_t x0294 = -1869430599;
    s += x0294;
    int32_t x0295 = 855436582;
    s += x0295;
    int32_t x0296 = -642105961;
    s += x0296;
    int32_t x0297 = 1181118937;
    s += x0297;
    int32_t x0298 = -788759703;
    s += x0298;
    int32_t x0299 = 640616208;
    s += x0299;
    int32_t x0300 = -2021092486;
    s += x0300;
    int32_t x0301 = 1463912200;
    s += x0301;
    int32_t x0302 = 1626251792;
    s += x0302;
    int32_t x0303 = -783424265;
    s += x0303;
    int32_t x0304 = -1441372069;
    s += x0304;
    int32_t x0305 = 1971448910;
    s += x0305;
    int32_t x0306 = -1386222248;
    s += x0306;
    int32_t x0307 = 621827246;
    s += x0307;
    int32_t x0308 = 1127442564;
    s += x0308;
    int32_t x0309 = -3006862;
    s += x0309;
    int32_t x0310 = 558466208;
    s += x0310;
    int32_t x0311 = -78044843;
    s += x0311;
    int32_t x0312 = 649712868;
    s += x0312;
    int32_t x0313 = 402645635;
    s += x0313;
    int32_t x0314 = -1879662830;
    s += x0314;
    int32_t x0315 = 719657647;
    s += x0315;
    int32_t x0316 = -717491541;
    s += x0316;
    int32_t x0317 = 179308039;
    s += x0317;
    int32_t x0318 = 1505858187;
    s += x0318;
    int32_t x0319 = -1241428529;
    s += x0319;
    int32_t x0320 = -1607183228;
    s += x0320;
    int32_t x0321 = 754556289;
    s += x0321;
    int32_t x0322 = -289105392;
    s += x0322;
    int32_t x0323 = -809713333;
    s += x0323;
    int32_t x0324 = -145676983;
    s += x0324;
    int32_t x0325 = 1780784890;
    s += x0325;
    int32_t x0326 = -155391607;
    s += x0326;
    int32_t x0327 = 243601105;
    s += x0327;
    int32_t x0328 = 1491514410;
    s += x0328;
    int32_t x0329 = -2053702960;
    s += x0329;
    int32_t x0330 = 1647387273;
    s += x0330;
    int32_t x0331 = -1813023746;
    s += x0331;
    int32_t x0332 = 1150661677;
    s += x0332;
    int32_t x0333 = 982171692;
    s += x0333;
    int32_t x0334 = -530238265;
    s += x0334;
    int32_t x0335 = -263614260;
    s += x0335;
    int32_t x0336 = 427000955;
    s += x0336;
    int32_t x0337 = 1468812363;
    s += x0337;
    int32_t x0338 = 2097888727;
    s += x0338;
    int32_t x0339 = 842944851;
    s += x0339;
    int32_t x0340 = 1530215192;
    s += x0340;
    int32_t x0341 = -1538482055;
    s += x0341;
    int32_t x0342 = 1020590585;
    s += x0342;
    int32_t x0343 = 739719685;
    s += x0343;
    int32_t x0344 = 1850267338;
    s += x0344;
    int32_t x0345 = 41638530;
    s += x0345;
    int32_t x0346 = 1268216872;
    s += x0346;
    int32_t x0347 = -412670110;
    s += x0347;
    int32_t x0348 = -1757719772;
    s += x0348;
    int32_t x0349 = 1733113833;
    s += x0349;
    int32_t x0350 = 494404567;
    s += x0350;
    int32_t x0351 = 1444989102;
    s += x0351;
    int32_t x0352 = -1246732870;
    s += x0352;
    int32_t x0353 = -1294582923;
    s += x0353;
    int32_t x0354 = 555969002;
    s += x0354;
    int32_t x0355 = -1938938982;
    s += x0355;
    int32_t x0356 = 456432099;
    s += x0356;
    int32_t x0357 = 2106130529;
    s += x0357;
    int32_t x0358 = -1882455296;
    s += x0358;
    int32_t x0359 = -293166757;
    s += x0359;
    int32_t x0360 = 1500165431;
    s += x0360;
    int32_t x0361 = -1242071022;
    s += x0361;
    int32_t x0362 = -1740452632;
    s += x0362;
    int32_t x0363 = -963433785;
    s += x0363;
    int32_t x0364 = 1857757965;
    s += x0364;
    int32_t x0365 = -1614385295;
    s += x0365;
    int32_t x0366 = 363497148;
    s += x0366;
    int32_t x0367 = 617068467;
    s += x0367;
    int32_t x0368 = 2033543813;
    s += x0368;
    int32_t x0369 = 1127773853;
    s += x0369;
    int32_t x0370 = 2105943176;
    s += x0370;
    int32_t x0371 = -759098285;
    s += x0371;
    int32_t x0372 = 1011615840;
    s += x0372;
    int32_t x0373 = 502078149;
    s += x0373;
    int32_t x0374 = -952998725;
    s += x0374;
    int32_t x0375 = -1586611973;
    s += x0375;
    int32_t x0376 = -1902101740;
    s += x0376;
    int32_t x0377 = -1446271238;
    s += x0377;
    int32_t x0378 = -1950003939;
    s += x0378;
    int32_t x0379 = -541621052;
    s += x0379;
    int32_t x0380 = -1605976090;
    s += x0380;
    int32_t x0381 = 1183855216;
    s += x0381;
    int32_t x0382 = 1545690677;
    s += x0382;
    int32_t x0383 = -71095048;
    s += x0383;
    int32_t x0384 = 1236743643;
    s += x0384;
    int32_t x0385 = -1325146361;
    s += x0385;
    int32_t x0386 = -750194906;
    s += x0386;
    int32_t x0387 = 1449242583;
    s += x0387;
    int32_t x0388 = 332340970;
    s += x0388;
    int32_t x0389 = -1311634495;
    s += x0389;
    int32_t x0390 = -1496297718;
    s += x0390;
    int32_t x0391 = 1710307749;
    s += x0391;
    int32_t x0392 = 746969036;
    s += x0392;
    int32_t x0393 = -972848926;
    s += x0393;
    int32_t x0394 = 1515038370;
    s += x0394;
    int32_t x0395 = 1645286940;
    s += x0395;
    int32_t x0396 = 731914492;
    s += x0396;
    int32_t x0397 = 1116436198;
    s += x0397;
    int32_t x0398 = -1801665436;
    s += x0398;
    int32_t x0399 = -1094007992;
    s += x0399;
    int32_t x0400 = 32356702;
    s += x0400;
    int32_t x0401 = -955392518;
    s += x0401;
    int32_t x0402 = -737707170;
    s += x0402;
    int32_t x0403 = -1101787936;
    s += x0403;
    int32_t x0404 = 82593116;
    s += x0404;
    int32_t x0405 = -914532912;
    s += x0405;
    int32_t x0406 = -290128917;
    s += x0406;
    int32_t x0407 = -758952750;
    s += x0407;
    int32_t x0408 = 1199788948;
    s += x0408;
    int32_t x0409 = -2040243610;
    s += x0409;
    int32_t x0410 = 1225816231;
    s += x0410;
    int32_t x0411 = 623590219;
    s += x0411;
    int32_t x0412 = 1672499414;
    s += x0412;
    int32_t x0413 = -1953054487;
    s += x0413;
    int32_t x0414 = -1419579337;
    s += x0414;
    int32_t x0415 = 1796769990;
    s += x0415;
    int32_t x0416 = -690043348;
    s += x0416;
    int32_t x0417 = 622128022;
    s += x0417;
    int32_t x0418 = -208278140;
    s += x0418;
    int32_t x0419 = 1991492846;
    s += x0419;
    int32_t x0420 = -2005426921;
    s += x0420;
    int32_t x0421 = -382036156;
    s += x0421;
    int32_t x0422 = 906539318;
    s += x0422;
    int32_t x0423 = 1215208791;
    s += x0423;
    int32_t x0424 = 1790858414;
    s += x0424;
    int32_t x0425 = 1784273397;
    s += x0425;
    int32_t x0426 = -1471012686;
    s += x0426;
    int32_t x0427 = -237743071;
    s += x0427;
    int32_t x0428 = 722256629;
    s += x0428;
    int32_t x0429 = -447270363;
    s += x0429;
    int32_t x0430 = -788850087;
    s += x0430;
    int32_t x0431 = 240885222;
    s += x0431;
    int32_t x0432 = -112018968;
    s += x0432;
    int32_t x0433 = -1160427494;
    s += x0433;
    int32_t x0434 = 1581513385;
    s += x0434;
    int32_t x0435 = -690338912;
    s += x0435;
    int32_t x0436 = 579375574;
    s += x0436;
    int32_t x0437 = -110249223;
    s += x0437;
    int32_t x0438 = 2000120699;
    s += x0438;
    int32_t x0439 = 1743751820;
    s += x0439;
    int32_t x0440 = 201327668;
    s += x0440;
    int32_t x0441 = -230097762;
    s += x0441;
    int32_t x0442 = 2121798065;
    s += x0442;
    int32_t x0443 = 905780906;
    s += x0443;
    int32_t x0444 = -691018197;
    s += x0444;
    int32_t x0445 = -236516105;
    s += x0445;
    int32_t x0446 = 740156269;
    s += x0446;
    int32_t x0447 = -968468913;
    s += x0447;
    int32_t x0448 = -990727967;
    s += x0448;
    int32_t x0449 = -2032267214;
    s += x0449;
    int32_t x0450 = 1124887629;
    s += x0450;
    int32_t x0451 = -2080656828;
    s += x0451;
    int32_t x0452 = 739364764;
    s += x0452;
    int32_t x0453 = -1705496842;
    s += x0453;
    int32_t x0454 = 1308742103;
    s += x0454;
    int32_t x0455 = 1473335779;
    s += x0455;
    int32_t x0456 = 491054723;
    s += x0456;
    int32_t x0457 = 1269195492;
    s += x0457;
    int32_t x0458 = 1589962326;
    s += x0458;
    int32_t x0459 = 200969654;
    s += x0459;
    int32_t x0460 = -2033946001;
    s += x0460;
    int32_t x0461 = 156481322;
    s += x0461;
    int32_t x0462 = 1736078970;
    s += x0462;
    int32_t x0463 = -238508725;
    s += x0463;
    int32_t x0464 = -229606535;
    s += x0464;
    int32_t x0465 = -795973664;
    s += x0465;
    int32_t x0466 = -2070332133;
    s += x0466;
    int32_t x0467 = -367380441;
    s += x0467;
    int32_t x0468 = -103299748;
    s += x0468;
    int32_t x0469 = -502295912;
    s += x0469;
    int32_t x0470 = -91496112;
    s += x0470;
    int32_t x0471 = 1109981535;
    s += x0471;
    int32_t x0472 = 1819873571;
    s += x0472;
    int32_t x0473 = -1508141919;
    s += x0473;
    int32_t x0474 = -523051573;
    s += x0474;
    int32_t x0475 = -1438816793;
    s += x0475;
    int32_t x0476 = 628868279;
    s += x0476;
    int32_t x0477 = -1708958637;
    s += x0477;
    int32_t x0478 = -58696139;
    s += x0478;
    int32_t x0479 = -41177328;
    s += x0479;
    int32_t x0480 = -1271498026;
    s += x0480;
    int32_t x0481 = 1304751138;
    s += x0481;
    int32_t x0482 = 425497747;
    s += x0482;
    int32_t x0483 = -1734125230;
    s += x0483;
    int32_t x0484 = 244332927;
    s += x0484;
    int32_t x0485 = 1564517764;
    s += x0485;
    int32_t x0486 = 1701618980;
    s += x0486;
    int32_t x0487 = -358198122;
    s += x0487;
    int32_t x0488 = -1088762786;
    s += x0488;
    int32_t x0489 = -1530474803;
    s += x0489;
    int32_t x0490 = -1504926954;
    s += x0490;
    int32_t x0491 = 1198675347;
    s += x0491;
    int32_t x0492 = -224850960;
    s += x0492;
    int32_t x0493 = 1889375330;
    s += x0493;
    int32_t x0494 = -82037864;
    s += x0494;
    int32_t x0495 = 1569835641;
    s += x0495;
    int32_t x0496 = 766022097;
    s += x0496;
    int32_t x0497 = -586571622;
    s += x0497;
    int32_t x0498 = 1977719332;
    s += x0498;
    int32_t x0499 = 1059288433;
    s += x0499;
    int32_t x0500 = -406769650;
    s += x0500;
    int32_t x0501 = -852744161;
    s += x0501;
    int32_t x0502 = 1069520535;
    s += x0502;
    int32_t x0503 = 1532129648;
    s += x0503;
    int32_t x0504 = 337714502;
    s += x0504;
    int32_t x0505 = -2034404583;
    s += x0505;
    int32_t x0506 = 347066065;
    s += x0506;
    int32_t x0507 = -324678054;
    s += x0507;
    int32_t x0508 = -886340319;
    s += x0508;
    int32_t x0509 = -530008283;
    s += x0509;
    int32_t x0510 = -409339373;
    s += x0510;
    int32_t x0511 = -2131869509;
    s += x0511;
    int32_t x0512 = -909036170;
    s += x0512;
    int32_t x0513 = 138351094;
    s += x0513;
    int32_t x0514 = -593917710;
    s += x0514;
    int32_t x0515 = -132271125;
    s += x0515;
    int32_t x0516 = -388806916;
    s += x0516;
    int32_t x0517 = 2015751408;
    s += x0517;
    int32_t x0518 = -1259510086;
    s += x0518;
    int32_t x0519 = -1799148021;
    s += x0519;
    int32_t x0520 = 620711209;
    s += x0520;
    int32_t x0521 = -215284720;
    s += x0521;
    int32_t x0522 = -145451529;
    s += x0522;
    int32_t x0523 = 2083731192;
    s += x0523;
    int32_t x0524 = -661142891;
    s += x0524;
    int32_t x0525 = -2003842941;
    s += x0525;
    int32_t x0526 = 238222733;
    s += x0526;
    int32_t x0527 = -786863799;
    s += x0527;
    int32_t x0528 = -315311511;
    s += x0528;
    int32_t x0529 = -1195118442;
    s += x0529;
    int32_t x0530 = -846810066;
    s += x0530;
    int32_t x0531 = 1549523364;
    s += x0531;
    int32_t x0532 = -1134156008;
    s += x0532;
    int32_t x0533 = -1691671292;
    s += x0533;
    int32_t x0534 = -566747510;
    s += x0534;
    int32_t x0535 = -1077249386;
    s += x0535;
    int32_t x0536 = -2088559840;
    s += x0536;
    int32_t x0537 = 237358140;
    s += x0537;
    int32_t x0538 = 1112124558;
    s += x0538;
    int32_t x0539 = 1663726463;
    s += x0539;
    int32_t x0540 = 1143109796;
    s += x0540;
    int32_t x0541 = -1205480857;
    s += x0541;
    int32_t x0542 = 1236695455;
    s += x0542;
    int32_t x0543 = 76600079;
    s += x0543;
    int32_t x0544 = -885757504;
    s += x0544;
    int32_t x0545 = -786601867;
    s += x0545;
    int32_t x0546 = 1100642551;
    s += x0546;
    int32_t x0547 = 2088177393;
    s += x0547;
    int32_t x0548 = -1794453084;
    s += x0548;
    int32_t x0549 = -1716765177;
    s += x0549;
    int32_t x0550 = 220519368;
    s += x0550;
    int32_t x0551 = -1945203450;
    s += x0551;
    int32_t x0552 = 119460262;
    s += x0552;
    int32_t x0553 = -1486572249;
    s += x0553;
    int32_t x0554 = -1944194075;
    s += x0554;
    int32_t x0555 = -1020286444;
    s += x0555;
    int32_t x0556 = -1069991969;
    s += x0556;
    int32_t x0557 = 1085302;
    s += x0557;
    int32_t x0558 = -614408597;
    s += x0558;
    int32_t x0559 = 1440606020;
    s += x0559;
    int32_t x0560 = -271120533;
    s += x0560;
    int32_t x0561 = -1893890979;
    s += x0561;
    int32_t x0562 = 1870217905;
    s += x0562;
    int32_t x0563 = 1610056842;
    s += x0563;
    int32_t x0564 = -1356742850;
    s += x0564;
    int32_t x0565 = 910530424;
    s += x0565;
    int32_t x0566 = 184867780;
    s += x0566;
    int32_t x0567 = 268568240;
    s += x0567;
    int32_t x0568 = 614578710;
    s += x0568;
    int32_t x0569 = -1799192892;
    s += x0569;
    int32_t x0570 = -69679336;
    s += x0570;
    int32_t x0571 = 64788129;
    s += x0571;
    int32_t x0572 = -1797794047;
    s += x0572;
    int32_t x0573 = 1865998502;
    s += x0573;
    int32_t x0574 = -962478109;
    s += x0574;
    int32_t x0575 = -45769712;
    s += x0575;
    int32_t x0576 = -975339739;
    s += x0576;
    int32_t x0577 = -1808084902;
    s += x0577;
    int32_t x0578 = -1681436455;
    s += x0578;
    int32_t x0579 = 664249969;
    s += x0579;
    int32_t x0580 = 1110166093;
    s += x0580;
    int32_t x0581 = 773949345;
    s += x0581;
    int32_t x0582 = 1918722448;
    s += x0582;
    int32_t x0583 = 567550740;
    s += x0583;
    int32_t x0584 = 2013637097;
    s += x0584;
    int32_t x0585 = -1221184244;
    s += x0585;
    int32_t x0586 = 1193120237;
    s += x0586;
    int32_t x0587 = -1149344726;
    s += x0587;
    int32_t x0588 = -141976380;
    s += x0588;
    int32_t x0589 = -1316288109;
    s += x0589;
    int32_t x0590 = 1926574050;
    s += x0590;
    int32_t x0591 = -527544827;
    s += x0591;
    int32_t x0592 = 1011499391;
    s += x0592;
    int32_t x0593 = -1594549742;
    s += x0593;
    int32_t x0594 = -1907993762;
    s += x0594;
    int32_t x0595 = -488535819;
    s += x0595;
    int32_t x0596 = 1778539144;
    s += x0596;
    int32_t x0597 = 100594017;
    s += x0597;
    int32_t x0598 = 1253250670;
    s += x0598;
    int32_t x0599 = 2000558179;
    s += x0599;
    int32_t x0600 = -690811017;
    s += x0600;
    int32_t x0601 = -1661777743;
    s += x0601;
    int32_t x0602 = -141939400;
    s += x0602;
    int32_t x0603 = -1006122232;
    s += x0603;
    int32_t x0604 = 25908867;
    s += x0604;
    int32_t x0605 = -1239076169;
    s += x0605;
    int32_t x0606 = 152273519;
    s += x0606;
    int32_t x0607 = 1035824145;
    s += x0607;
    int32_t x0608 = -1946275118;
    s += x0608;
    int32_t x0609 = -1449888395;
    s += x0609;
    int32_t x0610 = -1565923363;
    s += x0610;
    int32_t x0611 = -111843877;
    s += x0611;
    int32_t x0612 = 1929885387;
    s += x0612;
    int32_t x0613 = -378391802;
    s += x0613;
    int32_t x0614 = 1156203739;
    s += x0614;
    int32_t x0615 = -2078544986;
    s += x0615;
    int32_t x0616 = -183790383;
    s += x0616;
    int32_t x0617 = 1889548358;
    s += x0617;
    int32_t x0618 = 1480923932;
    s += x0618;
    int32_t x0619 = -1660744562;
    s += x0619;
    int32_t x0620 = 1761259125;
    s += x0620;
    int32_t x0621 = -1231924214;
    s += x0621;
    int32_t x0622 = -208421651;
    s += x0622;
    int32_t x0623 = 512460054;
    s += x0623;
    int32_t x0624 = -1550511900;
    s += x0624;
    int32_t x0625 = -207803398;
    s += x0625;
    int32_t x0626 = 70152264;
    s += x0626;
    int32_t x0627 = 1179663965;
    s += x0627;
    int32_t x0628 = 1992266579;
    s += x0628;
    int32_t x0629 = -1982564829;
    s += x0629;
    int32_t x0630 = 491015311;
    s += x0630;
    int32_t x0631 = -1674017156;
    s += x0631;
    int32_t x0632 = 1110145244;
    s += x0632;
    int32_t x0633 = 404484283;
    s += x0633;
    int32_t x0634 = 653917737;
    s += x0634;
    int32_t x0635 = 2140249536;
    s += x0635;
    int32_t x0636 = -923318689;
    s += x0636;
    int32_t x0637 = -1744059999;
    s += x0637;
    int32_t x0638 = 1749752323;
    s += x0638;
    int32_t x0639 = -1963518527;
    s += x0639;
    int32_t x0640 = -1422047715;
    s += x0640;
    int32_t x0641 = -1223369738;
    s += x0641;
    int32_t x0642 = 1802700374;
    s += x0642;
    int32_t x0643 = 1586423188;
    s += x0643;
    int32_t x0644 = -84415682;
    s += x0644;
    int32_t x0645 = -2124404808;
    s += x0645;
    int32_t x0646 = 847972913;
    s += x0646;
    int32_t x0647 = -1465433601;
    s += x0647;
    int32_t x0648 = 298973381;
    s += x0648;
    int32_t x0649 = 1790188533;
    s += x0649;
    int32_t x0650 = 92806020;
    s += x0650;
    int32_t x0651 = -1021425507;
    s += x0651;
    int32_t x0652 = 1027184185;
    s += x0652;
    int32_t x0653 = 1885739746;
    s += x0653;
    int32_t x0654 = -1356419166;
    s += x0654;
    int32_t x0655 = 160693317;
    s += x0655;
    int32_t x0656 = -861960261;
    s += x0656;
    int32_t x0657 = 1104985136;
    s += x0657;
    int32_t x0658 = -1871550873;
    s += x0658;
    int32_t x0659 = 556831666;
    s += x0659;
    int32_t x0660 = 1040357193;
    s += x0660;
    int32_t x0661 = -551707681;
    s += x0661;
    int32_t x0662 = 1803808158;
    s += x0662;
    int32_t x0663 = 38487346;
    s += x0663;
    int32_t x0664 = 1759465739;
    s += x0664;
    int32_t x0665 = 34414045;
    s += x0665;
    int32_t x0666 = 1774397926;
    s += x0666;
    int32_t x0667 = -26882999;
    s += x0667;
    int32_t x0668 = 270336619;
    s += x0668;
    int32_t x0669 = 2029927872;
    s += x0669;
    int32_t x0670 = 858024865;
    s += x0670;
    int32_t x0671 = 1932464672;
    s += x0671;
    int32_t x0672 = 766651729;
    s += x0672;
    int32_t x0673 = -1186227798;
    s += x0673;
    int32_t x0674 = 1628804721;
    s += x0674;
    int32_t x0675 = -715650771;
    s += x0675;
    int32_t x0676 = -1482642587;
    s += x0676;
    int32_t x0677 = 2105837253;
    s += x0677;
    int32_t x0678 = -1028058131;
    s += x0678;
    int32_t x0679 = 794021309;
    s += x0679;
    int32_t x0680 = -1803399135;
    s += x0680;
    int32_t x0681 = 1114771468;
    s += x0681;
    int32_t x0682 = -1441174111;
    s += x0682;
    int32_t x0683 = -71250146;
    s += x0683;
    int32_t x0684 = 812895082;
    s += x0684;
    int32_t x0685 = -1819113359;
    s += x0685;
    int32_t x0686 = 1547969597;
    s += x0686;
    int32_t x0687 = 635988671;
    s += x0687;
    int32_t x0688 = -1545361650;
    s += x0688;
    int32_t x0689 = -728656002;
    s += x0689;
    int32_t x0690 = -1869743861;
    s += x0690;
    int32_t x0691 = 1834164791;
    s += x0691;
    int32_t x0692 = -497553096;
    s += x0692;
    int32_t x0693 = 604190840;
    s += x0693;
    int32_t x0694 = -1908440517;
    s += x0694;
    int32_t x0695 = -465682588;
    s += x0695;
    int32_t x0696 = 1516780787;
    s += x0696;
    int32_t x0697 = 1937262593;
    s += x0697;
    int32_t x0698 = 887505153;
    s += x0698;
    int32_t x0699 = 1966698355;
    s += x0699;
    int32_t x0700 = 1704522595;
    s += x0700;
    int32_t x0701 = 746250862;
    s += x0701;
    int32_t x0702 = -1556804393;
    s += x0702;
    int32_t x0703 = -1227444635;
    s += x0703;
    int32_t x0704 = -1890221575;
    s += x0704;
    int32_t x0705 = 391346199;
    s += x0705;
    int32_t x0706 = 164477236;
    s += x0706;
    int32_t x0707 = -1320880617;
    s += x0707;
    int32_t x0708 = -516153164;
    s += x0708;
    int32_t x0709 = -1279381567;
    s += x0709;
    int32_t x0710 = 1440782283;
    s += x0710;
    int32_t x0711 = -202287437;
    s += x0711;
    int32_t x0712 = 2063907176;
    s += x0712;
    int32_t x0713 = 2117924000;
    s += x0713;
    int32_t x0714 = -1264712068;
    s += x0714;
    int32_t x0715 = -925036668;
    s += x0715;
    int32_t x0716 = -1005110683;
    s += x0716;
    int32_t x0717 = -689823598;
    s += x0717;
    int32_t x0718 = -623625090;
    s += x0718;
    int32_t x0719 = 1399557595;
    s += x0719;
    int32_t x0720 = -1078945800;
    s += x0720;
    int32_t x0721 = -981596872;
    s += x0721;
    int32_t x0722 = -1090722151;
    s += x0722;
    int32_t x0723 = 232249795;
    s += x0723;
    int32_t x0724 = -23324740;
    s += x0724;
    int32_t x0725 = 695962908;
    s += x0725;
    int32_t x0726 = 600940680;
    s += x0726;
    int32_t x0727 = -1651765629;
    s += x0727;
    int32_t x0728 = -951130947;
    s += x0728;
    int32_t x0729 = 1525430481;
    s += x0729;
    int32_t x0730 = -237469897;
    s += x0730;
    int32_t x0731 = 1230531203;
    s += x0731;
    int32_t x0732 = -2122869445;
    s += x0732;
    int32_t x0733 = -788993967;
    s += x0733;
    int32_t x0734 = 1364992697;
    s += x0734;
    int32_t x0735 = -2097908977;
    s += x0735;
    int32_t x0736 = -1799066710;
    s += x0736;
    int32_t x0737 = 1308482320;
    s += x0737;
    int32_t x0738 = 2056934352;
    s += x0738;
    int32_t x0739 = -1961192537;
    s += x0739;
    int32_t x0740 = 455926507;
    s += x0740;
    int32_t x0741 = -687162306;
    s += x0741;
    int32_t x0742 = 133733714;
    s += x0742;
    int32_t x0743 = 292552439;
    s += x0743;
    int32_t x0744 = 266912474;
    s += x0744;
    int32_t x0745 = -1665645469;
    s += x0745;
    int32_t x0746 = 620056578;
    s += x0746;
    int32_t x0747 = 414023480;
    s += x0747;
    int32_t x0748 = -1470980328;
    s += x0748;
    int32_t x0749 = 121338880;
    s += x0749;
    int32_t x0750 = -1862550391;
    s += x0750;
    int32_t x0751 = 719665387;
    s += x0751;
    int32_t x0752 = 1566094917;
    s += x0752;
    int32_t x0753 = 104647108;
    s += x0753;
    int32_t x0754 = 776718750;
    s += x0754;
    int32_t x0755 = 1496272427;
    s += x0755;
    int32_t x0756 = 1662162356;
    s += x0756;
    int32_t x0757 = 206215070;
    s += x0757;
    int32_t x0758 = 1700273324;
    s += x0758;
    int32_t x0759 = 1611146104;
    s += x0759;
    int32_t x0760 = 1931277650;
    s += x0760;
    int32_t x0761 = -1451730287;
    s += x0761;
    int32_t x0762 = -632866603;
    s += x0762;
    int32_t x0763 = -1546063136;
    s += x0763;
    int32_t x0764 = 1553054159;
    s += x0764;
    int32_t x0765 = -10999451;
    s += x0765;
    int32_t x0766 = -1742245199;
    s += x0766;
    int32_t x0767 = -581999119;
    s += x0767;
    int32_t x0768 = -157600940;
    s += x0768;
    int32_t x0769 = -704652487;
    s += x0769;
    int32_t x0770 = 120494661;
    s += x0770;
    int32_t x0771 = 1851357293;
    s += x0771;
    int32_t x0772 = 656697032;
    s += x0772;
    int32_t x0773 = -658254460;
    s += x0773;
    int32_t x0774 = 1820840345;
    s += x0774;
    int32_t x0775 = -117033231;
    s += x0775;
    int32_t x0776 = 2074160536;
    s += x0776;
    int32_t x0777 = 1026053232;
    s += x0777;
    int32_t x0778 = 249685501;
    s += x0778;
    int32_t x0779 = 1107640120;
    s += x0779;
    int32_t x0780 = 598972127;
    s += x0780;
    int32_t x0781 = -222211004;
    s += x0781;
    int32_t x0782 = 1960377407;
    s += x0782;
    int32_t x0783 = 1877156601;
    s += x0783;
    int32_t x0784 = 1646029468;
    s += x0784;
    int32_t x0785 = 185591867;
    s += x0785;
    int32_t x0786 = -11203526;
    s += x0786;
    int32_t x0787 = -371926195;
    s += x0787;
    int32_t x0788 = 1451179104;
    s += x0788;
    int32_t x0789 = -1361413492;
    s += x0789;
    int32_t x0790 = -1165123541;
    s += x0790;
    int32_t x0791 = 103820940;
    s += x0791;
    int32_t x0792 = 1973232953;
    s += x0792;
    int32_t x0793 = -1240804939;
    s += x0793;
    int32_t x0794 = -203539957;
    s += x0794;
    int32_t x0795 = 1474414954;
    s += x0795;
    int32_t x0796 = -1425415765;
    s += x0796;
    int32_t x0797 = 1457299064;
    s += x0797;
    int32_t x0798 = 967735661;
    s += x0798;
    int32_t x0799 = -214858050;
    s += x0799;
    int32_t x0800 = 314430825;
    s += x0800;
    int32_t x0801 = -899298571;
    s += x0801;
    int32_t x0802 = -997286375;
    s += x0802;
    int32_t x0803 = 335966876;
    s += x0803;
    int32_t x0804 = 1510387746;
    s += x0804;
    int32_t x0805 = -1239106204;
    s += x0805;
    int32_t x0806 = -1872625004;
    s += x0806;
    int32_t x0807 = -1192456922;
    s += x0807;
    int32_t x0808 = -1780256247;
    s += x0808;
    int32_t x0809 = 2016842333;
    s += x0809;
    int32_t x0810 = -167210877;
    s += x0810;
    int32_t x0811 = -295688890;
    s += x0811;
    int32_t x0812 = -196123152;
    s += x0812;
    int32_t x0813 = -218833279;
    s += x0813;
    int32_t x0814 = -117682689;
    s += x0814;
    int32_t x0815 = 111773366;
    s += x0815;
    int32_t x0816 = 1012430553;
    s += x0816;
    int32_t x0817 = -1791856139;
    s += x0817;
    int32_t x0818 = 407719741;
    s += x0818;
    int32_t x0819 = 738217643;
    s += x0819;
    int32_t x0820 = -350068600;
    s += x0820;
    int32_t x0821 = 1615607304;
    s += x0821;
    int32_t x0822 = -104487544;
    s += x0822;
    int32_t x0823 = 200879664;
    s += x0823;
    int32_t x0824 = 1117444481;
    s += x0824;
    int32_t x0825 = -37504193;
    s += x0825;
    int32_t x0826 = -896331602;
    s += x0826;
    int32_t x0827 = 775523040;
    s += x0827;
    int32_t x0828 = 1614517072;
    s += x0828;
    int32_t x0829 = -1953465577;
    s += x0829;
    int32_t x0830 = 1467440003;
    s += x0830;
    int32_t x0831 = 178002707;
    s += x0831;
    int32_t x0832 = 1936303854;
    s += x0832;
    int32_t x0833 = -1740565736;
    s += x0833;
    int32_t x0834 = -409286935;
    s += x0834;
    int32_t x0835 = -1970426590;
    s += x0835;
    int32_t x0836 = -728968390;
    s += x0836;
    int32_t x0837 = -1327130257;
    s += x0837;
    int32_t x0838 = -1247100134;
    s += x0838;
    int32_t x0839 = -1012144272;
    s += x0839;
    int32_t x0840 = 2093540821;
    s += x0840;
    int32_t x0841 = -709087827;
    s += x0841;
    int32_t x0842 = -1636926579;
    s += x0842;
    int32_t x0843 = 1803971567;
    s += x0843;
    int32_t x0844 = 1131367129;
    s += x0844;
    int32_t x0845 = -698922484;
    s += x0845;
    int32_t x0846 = 2085658087;
    s += x0846;
    int32_t x0847 = 283559153;
    s += x0847;
    int32_t x0848 = -316241203;
    s += x0848;
    int32_t x0849 = 2140418143;
    s += x0849;
    int32_t x0850 = 630237951;
    s += x0850;
    int32_t x0851 = 37333097;
    s += x0851;
    int32_t x0852 = -1879474608;
    s += x0852;
    int32_t x0853 = 666847171;
    s += x0853;
    int32_t x0854 = -458644098;
    s += x0854;
    int32_t x0855 = 1462692780;
    s += x0855;
    int32_t x0856 = -187032304;
    s += x0856;
    int32_t x0857 = 199458698;
    s += x0857;
    int32_t x0858 = 1133435580;
    s += x0858;
    int32_t x0859 = 419647607;
    s += x0859;
    int32_t x0860 = 698100922;
    s += x0860;
    int32_t x0861 = 1884086497;
    s += x0861;
    int32_t x0862 = -268970292;
    s += x0862;
    int32_t x0863 = -1947944068;
    s += x0863;
    int32_t x0864 = 1959724680;
    s += x0864;
    int32_t x0865 = 945243614;
    s += x0865;
    int32_t x0866 = 2045325895;
    s += x0866;
    int32_t x0867 = -1689684537;
    s += x0867;
    int32_t x0868 = 1551350247;
    s += x0868;
    int32_t x0869 = -1367276283;
    s += x0869;
    int32_t x0870 = -1878406179;
    s += x0870;
    int32_t x0871 = 2118926382;
    s += x0871;
    int32_t x0872 = 1323429242;
    s += x0872;
    int32_t x0873 = -1660886845;
    s += x0873;
    int32_t x0874 = 532229058;
    s += x0874;
    int32_t x0875 = -293801820;
    s += x0875;
    int32_t x0876 = -2027379560;
    s += x0876;
    int32_t x0877 = -1596674300;
    s += x0877;
    int32_t x0878 = 2137860624;
    s += x0878;
    int32_t x0879 = 735179232;
    s += x0879;
    int32_t x0880 = -1567172359;
    s += x0880;
    int32_t x0881 = 1904814713;
    s += x0881;
    int32_t x0882 = 510458620;
    s += x0882;
    int32_t x0883 = -1407208550;
    s += x0883;
    int32_t x0884 = -1002689020;
    s += x0884;
    int32_t x0885 = -203022748;
    s += x0885;
    int32_t x0886 = -947730344;
    s += x0886;
    int32_t x0887 = 981526050;
    s += x0887;
    int32_t x0888 = -326767348;
    s += x0888;
    int32_t x0889 = 2037112338;
    s += x0889;
    int32_t x0890 = -587944871;
    s += x0890;
    int32_t x0891 = 1811820205;
    s += x0891;
    int32_t x0892 = 625590673;
    s += x0892;
    int32_t x0893 = -416763514;
    s += x0893;
    int32_t x0894 = -1916175392;
    s += x0894;
    int32_t x0895 = 2138040812;
    s += x0895;
    int32_t x0896 = 1677235388;
    s += x0896;
    int32_t x0897 = -2094893680;
    s += x0897;
    int32_t x0898 = -956753474;
    s += x0898;
    int32_t x0899 = 352177053;
    s += x0899;
    int32_t x0900 = 360132842;
    s += x0900;
    int32_t x0901 = 377042622;
    s += x0901;
    int32_t x0902 = -931619515;
    s += x0902;
    int32_t x0903 = -1841628594;
    s += x0903;
    int32_t x0904 = -465296233;
    s += x0904;
    int32_t x0905 = 352088439;
    s += x0905;
    int32_t x0906 = -1141037799;
    s += x0906;
    int32_t x0907 = 1787759235;
    s += x0907;
    int32_t x0908 = -1952756673;
    s += x0908;
    int32_t x0909 = -452046384;
    s += x0909;
    int32_t x0910 = 1358090555;
    s += x0910;
    int32_t x0911 = 1136437112;
    s += x0911;
    int32_t x0912 = -243343747;
    s += x0912;
    int32_t x0913 = -1094706533;
    s += x0913;
    int32_t x0914 = -277894689;
    s += x0914;
    int32_t x0915 = 957213473;
    s += x0915;
    int32_t x0916 = -1794888549;
    s += x0916;
    int32_t x0917 = -981716596;
    s += x0917;
    int32_t x0918 = 780905371;
    s += x0918;
    int32_t x0919 = -1942153158;
    s += x0919;
    int32_t x0920 = -459330312;
    s += x0920;
    int32_t x0921 = 2019991000;
    s += x0921;
    int32_t x0922 = -324435559;
    s += x0922;
    int32_t x0923 = -2014983887;
    s += x0923;
    int32_t x0924 = -532825168;
    s += x0924;
    int32_t x0925 = 1185754036;
    s += x0925;
    int32_t x0926 = 961947116;
    s += x0926;
    int32_t x0927 = 460735586;
    s += x0927;
    int32_t x0928 = 255277509;
    s += x0928;
    int32_t x0929 = 410956929;
    s += x0929;
    int32_t x0930 = 602458952;
    s += x0930;
    int32_t x0931 = -673187540;
    s += x0931;
    int32_t x0932 = 1277508021;
    s += x0932;
    int32_t x0933 = 2112411825;
    s += x0933;
    int32_t x0934 = 1244360567;
    s += x0934;
    int32_t x0935 = -1987693284;
    s += x0935;
    int32_t x0936 = -1143415711;
    s += x0936;
    int32_t x0937 = -134777615;
    s += x0937;
    int32_t x0938 = 169558441;
    s += x0938;
    int32_t x0939 = -771122109;
    s += x0939;
    int32_t x0940 = -1062274129;
    s += x0940;
    int32_t x0941 = 1760235120;
    s += x0941;
    int32_t x0942 = 212453521;
    s += x0942;
    int32_t x0943 = -891936998;
    s += x0943;
    int32_t x0944 = 1566093375;
    s += x0944;
    int32_t x0945 = -1210728564;
    s += x0945;
    int32_t x0946 = -2023110810;
    s += x0946;
    int32_t x0947 = -1519669611;
    s += x0947;
    int32_t x0948 = 926832692;
    s += x0948;
    int32_t x0949 = -1909116287;
    s += x0949;
    int32_t x0950 = -183059598;
    s += x0950;
    int32_t x0951 = -873006979;
    s += x0951;
    int32_t x0952 = 2060728934;
    s += x0952;
    int32_t x0953 = 1548098301;
    s += x0953;
    int32_t x0954 = 1647057524;
    s += x0954;
    int32_t x0955 = -1945809588;
    s += x0955;
    int32_t x0956 = 1980269573;
    s += x0956;
    int32_t x0957 = -1807555161;
    s += x0957;
    int32_t x0958 = 1184107197;
    s += x0958;
    int32_t x0959 = -2029915972;
    s += x0959;
    int32_t x0960 = 2078591161;
    s += x0960;
    int32_t x0961 = -272230799;
    s += x0961;
    int32_t x0962 = -1367860331;
    s += x0962;
    int32_t x0963 = -2087144400;
    s += x0963;
    int32_t x0964 = -1835931846;
    s += x0964;
    int32_t x0965 = -1203843029;
    s += x0965;
    int32_t x0966 = -1051670257;
    s += x0966;
    int32_t x0967 = 1785836076;
    s += x0967;
    int32_t x0968 = -1166628583;
    s += x0968;
    int32_t x0969 = 1949214122;
    s += x0969;
    int32_t x0970 = -586666326;
    s += x0970;
    int32_t x0971 = 635580445;
    s += x0971;
    int32_t x0972 = 860209134;
    s += x0972;
    int32_t x0973 = 1993666174;
    s += x0973;
    int32_t x0974 = 1970311632;
    s += x0974;
    int32_t x0975 = 350850178;
    s += x0975;
    int32_t x0976 = 1976603829;
    s += x0976;
    int32_t x0977 = 1230913732;
    s += x0977;
    int32_t x0978 = 1355512924;
    s += x0978;
    int32_t x0979 = 1209112255;
    s += x0979;
    int32_t x0980 = 831109957;
    s += x0980;
    int32_t x0981 = 394433941;
    s += x0981;
    int32_t x0982 = -2139342905;
    s += x0982;
    int32_t x0983 = -907326045;
    s += x0983;
    int32_t x0984 = 2068179971;
    s += x0984;
    int32_t x0985 = -1545670624;
    s += x0985;
    int32_t x0986 = -1443345251;
    s += x0986;
    int32_t x0987 = 541252850;
    s += x0987;
    int32_t x0988 = 1084352836;
    s += x0988;
    int32_t x0989 = 827435349;
    s += x0989;
    int32_t x0990 = -1604262752;
    s += x0990;
    int32_t x0991 = 175164597;
    s += x0991;
    int32_t x0992 = 544140976;
    s += x0992;
    int32_t x0993 = -2132576120;
    s += x0993;
    int32_t x0994 = 996466008;
    s += x0994;
    int32_t x0995 = -501421130;
    s += x0995;
    int32_t x0996 = -433655094;
    s += x0996;
    int32_t x0997 = -2016346777;
    s += x0997;
    int32_t x0998 = -1159061032;
    s += x0998;
    int32_t x0999 = 1641487219;
    s += x0999;
    int32_t x1000 = 327452426;
    s += x1000;
    int32_t x1001 = -1217755764;
    s += x1001;
    int32_t x1002 = 1747724039;
    s += x1002;
    int32_t x1003 = -2106277432;
    s += x1003;
    int32_t x1004 = -1380591910;
    s += x1004;
    int32_t x1005 = 1230862669;
    s += x1005;
    int32_t x1006 = 915700332;
    s += x1006;
    int32_t x1007 = -683084549;
    s += x1007;
    int32_t x1008 = -227642215;
    s += x1008;
    int32_t x1009 = 531487114;
    s += x1009;
    int32_t x1010 = -974048827;
    s += x1010;
    int32_t x1011 = 2051458334;
    s += x1011;
    int32_t x1012 = -65734145;
    s += x1012;
    int32_t x1013 = -397763532;
    s += x1013;
    int32_t x1014 = 571159059;
    s += x1014;
    int32_t x1015 = -553395643;
    s += x1015;
    int32_t x1016 = -1939299445;
    s += x1016;
    int32_t x1017 = 1725768289;
    s += x1017;
    int32_t x1018 = 222949802;
    s += x1018;
    int32_t x1019 = -219709483;
    s += x1019;
    int32_t x1020 = -1154782363;
    s += x1020;
    int32_t x1021 = -1094746355;
    s += x1021;
    int32_t x1022 = 1704500053;
    s += x1022;
    int32_t x1023 = -178117115;
    s += x1023;

    return s % 256 - 6;
}


================================================
File: tests/programs/mop_ld_signextend_32_overflow_bug.S
================================================
.global _start
_start:
  lui t0, 0x80000
  addiw t0, t0, -1

  lui t1, 0x80000
  nop
  addiw t1, t1, -1

  bne t0, t1, fail

  li a0, 0
  li a7, 93
  ecall
fail:
  li a0, 1
  li a7, 93
  ecall


================================================
File: tests/programs/mop_random_adc_sbb.S
================================================
.global _start
_start:
    li ra, 0xaa595c5ad603d266
    li sp, 0x9e3ad682cdc25fb
    li gp, 0x4ab9cfc9a41744c4
    li tp, 0xab1389106f05676b
    li t0, 0xb405e978ca4e5b4e
    li t1, 0x4990972c918881b3
    li t2, 0x95c6250c75d8a844
    li s0, 0x34def47f19c65307
    li s1, 0x2e77fadfbcde23
    li a0, 0xd4b514a75f93bd6f
    li a1, 0xfe3eb50d104b606d
    li a2, 0xba9a79792b9c1110
    li a3, 0xdd2966b
    li a4, 0xc3dc0ba693592be4
    li a5, 0x427c7d664f39ad3
    li a6, 0x32aacf8287400b6d
    li a7, 0xd7cfb7761352e279
    li s2, 0x1ed02f5ab0008640
    li s3, 0xa228760f4c638e2f
    li s4, 0x70b50b3d9d1b1fa3
    li s5, 0x129d06b1303d131d
    li s6, 0xeb1a3f6c4566f751
    li s7, 0x857de3741b8f6ada
    li s8, 0xd5132b9ca4fbe7b0
    li s9, 0x3f041a0c095cd14
    li s10, 0xd4f21b0fd18ecc09
    li s11, 0x42fd2c7f478cdf38
    li t3, 0x7e2af96094bcd743
    li t4, 0xe369e90645c47a17
    li t5, 0x6514770694db3a39
    sub s7, s1, s7
    sltu s7, s1, s7
    sub s1, s7, s5
    sltu s5, s7, s1
    or s7, s5, s7
    add t6, t6, s1
    add t6, t6, s7
    add t6, t6, s5
    add t6, t6, s7
    sub s4, t3, s4
    sltu s8, t3, s4
    sub t3, s4, ra
    sltu ra, s4, t3
    or s4, ra, s8
    add t6, t6, t3
    add t6, t6, s4
    add t6, t6, ra
    add t6, t6, s8
    sub s2, s0, s2
    sltu t3, s0, s2
    sub s0, s2, zero
    sltu zero, s2, s0
    or s2, zero, t3
    add t6, t6, s0
    add t6, t6, s2
    add t6, t6, zero
    add t6, t6, t3
    add s3, s3, t0
    sltu t0, s3, t0
    add s3, s3, a6
    sltu a6, s3, a6
    or t0, t0, a6
    add t6, t6, s3
    add t6, t6, t0
    add t6, t6, a3
    add t6, t6, a6
    add s8, s8, s6
    sltu s6, s8, s6
    add s8, s8, s8
    sltu s8, s8, s8
    or s6, s6, s8
    add t6, t6, s8
    add t6, t6, s6
    add t6, t6, a3
    add t6, t6, s8
    add s10, s10, s2
    sltu s2, s10, s2
    add s10, s10, s1
    sltu s1, s10, s1
    or s2, s2, s1
    add t6, t6, s10
    add t6, t6, s2
    add t6, t6, s1
    add t6, t6, s5
    add ra, ra, a1
    sltu a1, ra, a1
    add ra, ra, a6
    sltu a6, ra, a6
    or a1, a1, a6
    add t6, t6, ra
    add t6, t6, a1
    add t6, t6, a6
    add t6, t6, s4
    add tp, tp, zero
    sltu zero, tp, zero
    add tp, tp, t3
    sltu t3, tp, t3
    or zero, zero, t3
    add t6, t6, tp
    add t6, t6, zero
    add t6, t6, t3
    add t6, t6, t2
    add s7, s7, t4
    sltu t4, s7, t4
    add s7, s7, s0
    sltu s0, s7, s0
    or t4, t4, s0
    add t6, t6, s7
    add t6, t6, t4
    add t6, t6, s0
    add t6, t6, s2
    add zero, zero, s4
    sltu s4, zero, s4
    add zero, zero, s2
    sltu s2, zero, s2
    or s4, s4, s2
    add t6, t6, zero
    add t6, t6, s4
    add t6, t6, s2
    add t6, t6, a3
    add t4, t4, s3
    sltu s3, t4, s3
    add t4, t4, s3
    sltu s3, t4, s3
    or s3, s3, s3
    add t6, t6, t4
    add t6, t6, a2
    add t6, t6, s3
    add t6, t6, t0
    sub ra, t5, ra
    sltu s3, t5, ra
    sub t5, ra, a0
    sltu a0, ra, t5
    or ra, a0, s3
    add t6, t6, t5
    add t6, t6, ra
    add t6, t6, a0
    add t6, t6, s3
    sub gp, t0, gp
    sltu s4, t0, gp
    sub t0, gp, s0
    sltu s0, gp, t0
    or gp, s0, s4
    add t6, t6, t0
    add t6, t6, gp
    add t6, t6, s0
    add t6, t6, s4
    add sp, sp, s5
    sltu s5, sp, s5
    add sp, sp, s0
    sltu s0, sp, s0
    or s5, s5, s0
    add t6, t6, sp
    add t6, t6, s5
    add t6, t6, s0
    add t6, t6, s9
    sub s7, s6, s7
    sltu s7, s6, s7
    sub s6, s7, s3
    sltu s3, s7, s6
    or s7, s3, s7
    add t6, t6, s6
    add t6, t6, a3
    add t6, t6, s3
    add t6, t6, s7
    add t5, t5, gp
    sltu gp, t5, gp
    add t5, t5, s7
    sltu s7, t5, s7
    or gp, gp, s7
    add t6, t6, t5
    add t6, t6, gp
    add t6, t6, s7
    add t6, t6, zero
    sub s11, t5, s11
    sltu t1, t5, s11
    sub t5, s11, s3
    sltu s3, s11, t5
    or s11, s3, t1
    add t6, t6, t5
    add t6, t6, s11
    add t6, t6, s3
    add t6, t6, t1
    sub s7, tp, s7
    sltu t1, tp, s7
    sub tp, s7, a1
    sltu a1, s7, tp
    or s7, a1, t1
    add t6, t6, tp
    add t6, t6, s7
    add t6, t6, a1
    add t6, t6, t1
    sub a1, t1, a1
    sltu a1, t1, a1
    sub t1, a1, s1
    sltu s1, a1, t1
    or a1, s1, a1
    add t6, t6, t1
    add t6, t6, a1
    add t6, t6, s1
    add t6, t6, a1
    add a5, a5, a4
    sltu a4, a5, a4
    add a5, a5, a2
    sltu a2, a5, a2
    or a4, a4, a2
    add t6, t6, a5
    add t6, t6, a4
    add t6, t6, a2
    add t6, t6, s3
    add t3, t3, s10
    sltu s10, t3, s10
    add t3, t3, s10
    sltu s10, t3, s10
    or s10, s10, s10
    add t6, t6, t3
    add t6, t6, s10
    add t6, t6, s10
    add t6, t6, s9
    add s9, s9, t0
    sltu t0, s9, t0
    add s9, s9, s0
    sltu s0, s9, s0
    or t0, t0, s0
    add t6, t6, s9
    add t6, t6, t0
    add t6, t6, s0
    add t6, t6, s8
    sub s8, a7, s8
    sltu ra, a7, s8
    sub a7, s8, s0
    sltu s0, s8, a7
    or s8, s0, ra
    add t6, t6, a7
    add t6, t6, s8
    add t6, t6, s0
    add t6, t6, ra
    sub t4, a7, t4
    sltu gp, a7, t4
    sub a7, t4, t4
    sltu t4, t4, a7
    or t4, t4, gp
    add t6, t6, a7
    add t6, t6, a2
    add t6, t6, t4
    add t6, t6, gp
    add t0, t0, s8
    sltu s8, t0, s8
    add t0, t0, s7
    sltu s7, t0, s7
    or s8, s8, s7
    add t6, t6, t0
    add t6, t6, a3
    add t6, t6, s7
    add t6, t6, s8
    add t0, t0, a5
    sltu a5, t0, a5
    add t0, t0, s6
    sltu s6, t0, s6
    or a5, a5, s6
    add t6, t6, t0
    add t6, t6, a5
    add t6, t6, s6
    add t6, t6, a5
    sub t3, s2, t3
    sltu s3, s2, t3
    sub s2, t3, sp
    sltu sp, t3, s2
    or t3, sp, s3
    add t6, t6, s2
    add t6, t6, t3
    add t6, t6, sp
    add t6, t6, s3
    sub s1, t1, s1
    sltu s0, t1, s1
    sub t1, s1, s10
    sltu s10, s1, t1
    or s1, s10, s0
    add t6, t6, t1
    add t6, t6, s1
    add t6, t6, s10
    add t6, t6, s0
    add tp, tp, t0
    sltu t0, tp, t0
    add tp, tp, t1
    sltu t1, tp, t1
    or t0, t0, t1
    add t6, t6, tp
    add t6, t6, t0
    add t6, t6, t1
    add t6, t6, s5
    add tp, tp, zero
    sltu zero, tp, zero
    add tp, tp, t1
    sltu t1, tp, t1
    or zero, zero, t1
    add t6, t6, tp
    add t6, t6, zero
    add t6, t6, t1
    add t6, t6, a5
    sub s4, ra, s4
    sltu s4, ra, s4
    sub ra, s4, a0
    sltu a0, s4, ra
    or s4, a0, s4
    add t6, t6, ra
    add t6, t6, a3
    add t6, t6, a0
    add t6, t6, s4
    add a5, a5, a6
    sltu a6, a5, a6
    add a5, a5, s5
    sltu s5, a5, s5
    or a6, a6, s5
    add t6, t6, a5
    add t6, t6, a6
    add t6, t6, s5
    add t6, t6, s5
    add a5, a5, a5
    sltu a5, a5, a5
    add a5, a5, s9
    sltu s9, a5, s9
    or a5, a5, s9
    add t6, t6, a5
    add t6, t6, a5
    add t6, t6, s9
    add t6, t6, s3
    add a5, a5, s1
    sltu s1, a5, s1
    add a5, a5, a4
    sltu a4, a5, a4
    or s1, s1, a4
    add t6, t6, a5
    add t6, t6, s1
    add t6, t6, a4
    add t6, t6, s7
    add t3, t3, s4
    sltu s4, t3, s4
    add t3, t3, t3
    sltu t3, t3, t3
    or s4, s4, t3
    add t6, t6, t3
    add t6, t6, s4
    add t6, t6, t3
    add t6, t6, t4
    add s6, s6, s7
    sltu s7, s6, s7
    add s6, s6, s6
    sltu s6, s6, s6
    or s7, s7, s6
    add t6, t6, s6
    add t6, t6, s7
    add t6, t6, s6
    add t6, t6, s3
    add ra, ra, a0
    sltu a0, ra, a0
    add ra, ra, t0
    sltu t0, ra, t0
    or a0, a0, t0
    add t6, t6, ra
    add t6, t6, a0
    add t6, t6, t0
    add t6, t6, t2
    sub s5, s11, s5
    sltu s3, s11, s5
    sub s11, s5, sp
    sltu sp, s5, s11
    or s5, sp, s3
    add t6, t6, s11
    add t6, t6, s5
    add t6, t6, sp
    add t6, t6, s3
    sub s3, ra, s3
    sltu t4, ra, s3
    sub ra, s3, a0
    sltu a0, s3, ra
    or s3, a0, t4
    add t6, t6, ra
    add t6, t6, s3
    add t6, t6, a0
    add t6, t6, t4
    sub a6, a6, a6
    sltu s9, a6, a6
    sub a6, a6, a4
    sltu a4, a6, a6
    or a6, a4, s9
    add t6, t6, a1
    add t6, t6, a6
    add t6, t6, a4
    add t6, t6, s9
    sub s8, s1, s8
    sltu ra, s1, s8
    sub s1, s8, ra
    sltu ra, s8, s1
    or s8, ra, ra
    add t6, t6, s1
    add t6, t6, s8
    add t6, t6, a3
    add t6, t6, ra
    add sp, sp, t2
    sltu t2, sp, t2
    add sp, sp, s1
    sltu s1, sp, s1
    or t2, t2, s1
    add t6, t6, sp
    add t6, t6, t2
    add t6, t6, s1
    add t6, t6, a0
    add a4, a4, gp
    sltu gp, a4, gp
    add a4, a4, a0
    sltu a0, a4, a0
    or gp, gp, a0
    add t6, t6, a4
    add t6, t6, gp
    add t6, t6, a0
    add t6, t6, a4
    sub s11, t3, s11
    sltu s1, t3, s11
    sub t3, s11, s1
    sltu s1, s11, t3
    or s11, s1, s1
    add t6, t6, t3
    add t6, t6, s11
    add t6, t6, s1
    add t6, t6, s1
    add s5, s5, a1
    sltu a1, s5, a1
    add s5, s5, t1
    sltu t1, s5, t1
    or a1, a1, t1
    add t6, t6, s5
    add t6, t6, a1
    add t6, t6, t1
    add t6, t6, sp
    sub t1, a0, t1
    sltu t4, a0, t1
    sub a0, t1, zero
    sltu zero, t1, a0
    or t1, zero, t4
    add t6, t6, a0
    add t6, t6, t1
    add t6, t6, zero
    add t6, t6, t4
    sub s0, a4, s0
    sltu gp, a4, s0
    sub a4, s0, s10
    sltu s10, s0, a4
    or s0, s10, gp
    add t6, t6, a4
    add t6, t6, s0
    add t6, t6, s10
    add t6, t6, gp
    add s7, s7, gp
    sltu gp, s7, gp
    add s7, s7, s9
    sltu s9, s7, s9
    or gp, gp, s9
    add t6, t6, s7
    add t6, t6, gp
    add t6, t6, s9
    add t6, t6, t0
    sub s3, s2, s3
    sltu a4, s2, s3
    sub s2, s3, sp
    sltu sp, s3, s2
    or s3, sp, a4
    add t6, t6, s2
    add t6, t6, s3
    add t6, t6, sp
    add t6, t6, a4
    sub s1, s2, s1
    sltu t4, s2, s1
    sub s2, s1, s10
    sltu s10, s1, s2
    or s1, s10, t4
    add t6, t6, s2
    add t6, t6, s1
    add t6, t6, s10
    add t6, t6, t4
    add s8, s8, zero
    sltu zero, s8, zero
    add s8, s8, a7
    sltu a7, s8, a7
    or zero, zero, a7
    add t6, t6, s8
    add t6, t6, zero
    add t6, t6, a7
    add t6, t6, s1
    add s7, s7, a4
    sltu a4, s7, a4
    add s7, s7, s7
    sltu s7, s7, s7
    or a4, a4, s7
    add t6, t6, s7
    add t6, t6, a4
    add t6, t6, s7
    add t6, t6, a2
    add s5, s5, zero
    sltu zero, s5, zero
    add s5, s5, t1
    sltu t1, s5, t1
    or zero, zero, t1
    add t6, t6, s5
    add t6, t6, zero
    add t6, t6, t1
    add t6, t6, s7
    sub t4, t1, t4
    sltu s4, t1, t4
    sub t1, t4, s9
    sltu s9, t4, t1
    or t4, s9, s4
    add t6, t6, t1
    add t6, t6, t4
    add t6, t6, s9
    add t6, t6, s4
    sub t5, a5, t5
    sltu t5, a5, t5
    sub a5, t5, t2
    sltu t2, t5, a5
    or t5, t2, t5
    add t6, t6, a5
    add t6, t6, t5
    add t6, t6, t2
    add t6, t6, t5
    sub s10, s5, s10
    sltu s3, s5, s10
    sub s5, s10, s10
    sltu s10, s10, s5
    or s10, s10, s3
    add t6, t6, s5
    add t6, t6, s10
    add t6, t6, s10
    add t6, t6, s3
    add gp, gp, s4
    sltu s4, gp, s4
    add gp, gp, s4
    sltu s4, gp, s4
    or s4, s4, s4
    add t6, t6, gp
    add t6, t6, a2
    add t6, t6, s4
    add t6, t6, a3
    add s5, s5, t3
    sltu t3, s5, t3
    add s5, s5, t3
    sltu t3, s5, t3
    or t3, t3, t3
    add t6, t6, s5
    add t6, t6, a2
    add t6, t6, t3
    add t6, t6, t2
    sub s9, tp, s9
    sltu a4, tp, s9
    sub tp, s9, a7
    sltu a7, s9, tp
    or s9, a7, a4
    add t6, t6, tp
    add t6, t6, s9
    add t6, t6, a7
    add t6, t6, a4
    sub t4, sp, t4
    sltu s6, sp, t4
    sub sp, t4, a5
    sltu a5, t4, sp
    or t4, a5, s6
    add t6, t6, sp
    add t6, t6, t4
    add t6, t6, a5
    add t6, t6, s6
    sub tp, s6, tp
    sltu s11, s6, tp
    sub s6, tp, s7
    sltu s7, tp, s6
    or tp, s7, s11
    add t6, t6, s6
    add t6, t6, tp
    add t6, t6, s7
    add t6, t6, s11
    add s5, s5, tp
    sltu tp, s5, tp
    add s5, s5, s5
    sltu s5, s5, s5
    or tp, tp, s5
    add t6, t6, s5
    add t6, t6, tp
    add t6, t6, s5
    add t6, t6, s7
    sub a2, s4, a2
    sltu a2, s4, a2
    sub s4, a2, t2
    sltu t2, a2, s4
    or a2, t2, a2
    add t6, t6, s4
    add t6, t6, a3
    add t6, t6, t2
    add t6, t6, a2
    sub t5, sp, t5
    sltu s4, sp, t5
    sub sp, t5, s7
    sltu s7, t5, sp
    or t5, s7, s4
    add t6, t6, sp
    add t6, t6, t5
    add t6, t6, s7
    add t6, t6, s4
    sub s0, tp, s0
    sltu a5, tp, s0
    sub tp, s0, a1
    sltu a1, s0, tp
    or s0, a1, a5
    add t6, t6, tp
    add t6, t6, s0
    add t6, t6, a1
    add t6, t6, a5
    add tp, tp, gp
    sltu gp, tp, gp
    add tp, tp, a6
    sltu a6, tp, a6
    or gp, gp, a6
    add t6, t6, tp
    add t6, t6, gp
    add t6, t6, a6
    add t6, t6, s4
    add zero, zero, t3
    sltu t3, zero, t3
    add zero, zero, sp
    sltu sp, zero, sp
    or t3, t3, sp
    add t6, t6, zero
    add t6, t6, t3
    add t6, t6, sp
    add t6, t6, s8
    add ra, ra, a6
    sltu a6, ra, a6
    add ra, ra, s10
    sltu s10, ra, s10
    or a6, a6, s10
    add t6, t6, ra
    add t6, t6, a6
    add t6, t6, s10
    add t6, t6, a0
    sub s9, s9, s9
    sltu t4, s9, s9
    sub s9, s9, a0
    sltu a0, s9, s9
    or s9, a0, t4
    add t6, t6, s9
    add t6, t6, s9
    add t6, t6, a0
    add t6, t6, t4
    add a5, a5, s11
    sltu s11, a5, s11
    add a5, a5, a5
    sltu a5, a5, a5
    or s11, s11, a5
    add t6, t6, a5
    add t6, t6, s11
    add t6, t6, a5
    add t6, t6, s3
    sub s9, s4, s9
    sltu s5, s4, s9
    sub s4, s9, s9
    sltu s9, s9, s4
    or s9, s9, s5
    add t6, t6, s4
    add t6, t6, a2
    add t6, t6, s9
    add t6, t6, s5
    sub ra, t3, ra
    sltu t1, t3, ra
    sub t3, ra, a7
    sltu a7, ra, t3
    or ra, a7, t1
    add t6, t6, t3
    add t6, t6, ra
    add t6, t6, a7
    add t6, t6, t1
    sub s6, a7, s6
    sltu s8, a7, s6
    sub a7, s6, a2
    sltu a2, s6, a7
    or s6, a2, s8
    add t6, t6, a7
    add t6, t6, s6
    add t6, t6, a2
    add t6, t6, s8
    sub tp, zero, tp
    sltu s1, zero, tp
    sub zero, tp, s4
    sltu s4, tp, zero
    or tp, s4, s1
    add t6, t6, zero
    add t6, t6, tp
    add t6, t6, s4
    add t6, t6, s1
    sub s7, a0, s7
    sltu s4, a0, s7
    sub a0, s7, ra
    sltu ra, s7, a0
    or s7, ra, s4
    add t6, t6, a0
    add t6, t6, s7
    add t6, t6, ra
    add t6, t6, s4
    sub ra, t2, ra
    sltu t2, t2, ra
    sub t2, ra, t2
    sltu t2, ra, t2
    or ra, t2, t2
    add t6, t6, a2
    add t6, t6, ra
    add t6, t6, a3
    add t6, t6, t2
    add a6, a6, t3
    sltu t3, a6, t3
    add a6, a6, a0
    sltu a0, a6, a0
    or t3, t3, a0
    add t6, t6, a6
    add t6, t6, t3
    add t6, t6, a0
    add t6, t6, a5
    add t5, t5, a5
    sltu a5, t5, a5
    add t5, t5, t1
    sltu t1, t5, t1
    or a5, a5, t1
    add t6, t6, t5
    add t6, t6, a5
    add t6, t6, t1
    add t6, t6, s7
    add s9, s9, t1
    sltu t1, s9, t1
    add s9, s9, t0
    sltu t0, s9, t0
    or t1, t1, t0
    add t6, t6, s9
    add t6, t6, t1
    add t6, t6, t0
    add t6, t6, s1
    sub s4, s9, s4
    sltu t1, s9, s4
    sub s9, s4, a0
    sltu a0, s4, s9
    or s4, a0, t1
    add t6, t6, s9
    add t6, t6, s4
    add t6, t6, a0
    add t6, t6, t1
    add s10, s10, gp
    sltu gp, s10, gp
    add s10, s10, s8
    sltu s8, s10, s8
    or gp, gp, s8
    add t6, t6, s10
    add t6, t6, gp
    add t6, t6, s8
    add t6, t6, tp
    add s6, s6, t1
    sltu t1, s6, t1
    add s6, s6, gp
    sltu gp, s6, gp
    or t1, t1, gp
    add t6, t6, s6
    add t6, t6, t1
    add t6, t6, gp
    add t6, t6, s9
    sub sp, s0, sp
    sltu t0, s0, sp
    sub s0, sp, a1
    sltu a1, sp, s0
    or sp, a1, t0
    add t6, t6, s0
    add t6, t6, sp
    add t6, t6, a1
    add t6, t6, t0
    sub zero, s9, zero
    sltu a0, s9, zero
    sub s9, zero, t5
    sltu t5, zero, s9
    or zero, t5, a0
    add t6, t6, s9
    add t6, t6, zero
    add t6, t6, t5
    add t6, t6, a0
    add s1, s1, t3
    sltu t3, s1, t3
    add s1, s1, s5
    sltu s5, s1, s5
    or t3, t3, s5
    add t6, t6, s1
    add t6, t6, t3
    add t6, t6, s5
    add t6, t6, sp
    add t4, t4, a0
    sltu a0, t4, a0
    add t4, t4, gp
    sltu gp, t4, gp
    or a0, a0, gp
    add t6, t6, t4
    add t6, t6, a0
    add t6, t6, gp
    add t6, t6, a4
    add s9, s9, a6
    sltu a6, s9, a6
    add s9, s9, sp
    sltu sp, s9, sp
    or a6, a6, sp
    add t6, t6, s9
    add t6, t6, a6
    add t6, t6, sp
    add t6, t6, s7
    add s10, s10, a5
    sltu a5, s10, a5
    add s10, s10, s5
    sltu s5, s10, s5
    or a5, a5, s5
    add t6, t6, s10
    add t6, t6, a5
    add t6, t6, s5
    add t6, t6, gp
    sub s7, tp, s7
    sltu s6, tp, s7
    sub tp, s7, t2
    sltu t2, s7, tp
    or s7, t2, s6
    add t6, t6, tp
    add t6, t6, s7
    add t6, t6, t2
    add t6, t6, s6
    add t0, t0, a6
    sltu a6, t0, a6
    add t0, t0, s9
    sltu s9, t0, s9
    or a6, a6, s9
    add t6, t6, t0
    add t6, t6, a6
    add t6, t6, s9
    add t6, t6, a4
    sub ra, a0, ra
    sltu s6, a0, ra
    sub a0, ra, sp
    sltu sp, ra, a0
    or ra, sp, s6
    add t6, t6, a0
    add t6, t6, ra
    add t6, t6, sp
    add t6, t6, s6
    add a6, a6, s3
    sltu s3, a6, s3
    add a6, a6, s9
    sltu s9, a6, s9
    or s3, s3, s9
    add t6, t6, a6
    add t6, t6, s3
    add t6, t6, s9
    add t6, t6, a7
    sub s11, a7, s11
    sltu s8, a7, s11
    sub a7, s11, s0
    sltu s0, s11, a7
    or s11, s0, s8
    add t6, t6, a7
    add t6, t6, s11
    add t6, t6, s0
    add t6, t6, s8
    sub a5, a4, a5
    sltu a0, a4, a5
    sub a4, a5, a7
    sltu a7, a5, a4
    or a5, a7, a0
    add t6, t6, a4
    add t6, t6, a5
    add t6, t6, a7
    add t6, t6, a0
    sub s11, ra, s11
    sltu a5, ra, s11
    sub ra, s11, t2
    sltu t2, s11, ra
    or s11, t2, a5
    add t6, t6, ra
    add t6, t6, s11
    add t6, t6, t2
    add t6, t6, a5
    add a6, a6, s3
    sltu s3, a6, s3
    add a6, a6, tp
    sltu tp, a6, tp
    or s3, s3, tp
    add t6, t6, a3
    add t6, t6, s3
    add t6, t6, tp
    add t6, t6, a6
    sub a6, tp, a6
    sltu a1, tp, a6
    sub tp, a6, a6
    sltu a6, a6, tp
    or a6, a6, a1
    add t6, t6, tp
    add t6, t6, a2
    add t6, t6, a6
    add t6, t6, a1
    sub sp, zero, sp
    sltu a2, zero, sp
    sub zero, sp, a2
    sltu a2, sp, zero
    or sp, a2, a2
    add t6, t6, zero
    add t6, t6, sp
    add t6, t6, a3
    add t6, t6, a2
    add zero, zero, tp
    sltu tp, zero, tp
    add zero, zero, t4
    sltu t4, zero, t4
    or tp, tp, t4
    add t6, t6, zero
    add t6, t6, tp
    add t6, t6, t4
    add t6, t6, a3
    add tp, tp, gp
    sltu gp, tp, gp
    add tp, tp, t0
    sltu t0, tp, t0
    or gp, gp, t0
    add t6, t6, tp
    add t6, t6, a3
    add t6, t6, t0
    add t6, t6, gp
    add a7, a7, zero
    sltu zero, a7, zero
    add a7, a7, s1
    sltu s1, a7, s1
    or zero, zero, s1
    add t6, t6, a7
    add t6, t6, zero
    add t6, t6, s1
    add t6, t6, s0
    add a0, a0, s9
    sltu s9, a0, s9
    add a0, a0, s11
    sltu s11, a0, s11
    or s9, s9, s11
    add t6, t6, a0
    add t6, t6, s9
    add t6, t6, s11
    add t6, t6, t3
    add zero, zero, s0
    sltu s0, zero, s0
    add zero, zero, a5
    sltu a5, zero, a5
    or s0, s0, a5
    add t6, t6, zero
    add t6, t6, s0
    add t6, t6, a3
    add t6, t6, a5
    sub s0, gp, s0
    sltu a1, gp, s0
    sub gp, s0, s10
    sltu s10, s0, gp
    or s0, s10, a1
    add t6, t6, gp
    add t6, t6, s0
    add t6, t6, s10
    add t6, t6, a1
    sub s4, s4, s4
    sltu s4, s4, s4
    sub s4, s4, s6
    sltu s6, s4, s4
    or s4, s6, s4
    add t6, t6, s4
    add t6, t6, a3
    add t6, t6, s6
    add t6, t6, s4
    add t3, t3, gp
    sltu gp, t3, gp
    add t3, t3, zero
    sltu zero, t3, zero
    or gp, gp, zero
    add t6, t6, t3
    add t6, t6, gp
    add t6, t6, zero
    add t6, t6, a0
    add s4, s4, a0
    sltu a0, s4, a0
    add s4, s4, s10
    sltu s10, s4, s10
    or a0, a0, s10
    add t6, t6, s4
    add t6, t6, a0
    add t6, t6, s10
    add t6, t6, a6
    add t2, t2, tp
    sltu tp, t2, tp
    add t2, t2, s9
    sltu s9, t2, s9
    or tp, tp, s9
    add t6, t6, t2
    add t6, t6, tp
    add t6, t6, s9
    add t6, t6, zero
    sub s3, s3, s3
    sltu s11, s3, s3
    sub s3, s3, a0
    sltu a0, s3, s3
    or s3, a0, s11
    add t6, t6, a1
    add t6, t6, s3
    add t6, t6, a0
    add t6, t6, s11
    sub s4, a4, s4
    sltu s4, a4, s4
    sub a4, s4, t2
    sltu t2, s4, a4
    or s4, t2, s4
    add t6, t6, a4
    add t6, t6, a3
    add t6, t6, t2
    add t6, t6, s4
    add a0, a0, s3
    sltu s3, a0, s3
    add a0, a0, t4
    sltu t4, a0, t4
    or s3, s3, t4
    add t6, t6, a0
    add t6, t6, s3
    add t6, t6, t4
    add t6, t6, a4
    sub s0, sp, s0
    sltu sp, sp, s0
    sub sp, s0, s4
    sltu s4, s0, sp
    or s0, s4, sp
    add t6, t6, sp
    add t6, t6, s0
    add t6, t6, s4
    add t6, t6, sp
    add a6, a6, t5
    sltu t5, a6, t5
    add a6, a6, a6
    sltu a6, a6, a6
    or t5, t5, a6
    add t6, t6, a6
    add t6, t6, t5
    add t6, t6, a6
    add t6, t6, s2
    sub s4, t4, s4
    sltu t1, t4, s4
    sub t4, s4, t0
    sltu t0, s4, t4
    or s4, t0, t1
    add t6, t6, t4
    add t6, t6, s4
    add t6, t6, t0
    add t6, t6, t1
    add s9, s9, s0
    sltu s0, s9, s0
    add s9, s9, s7
    sltu s7, s9, s7
    or s0, s0, s7
    add t6, t6, s9
    add t6, t6, s0
    add t6, t6, s7
    add t6, t6, s3
    add a5, a5, a5
    sltu a5, a5, a5
    add a5, a5, a2
    sltu a2, a5, a2
    or a5, a5, a2
    add t6, t6, a1
    add t6, t6, a5
    add t6, t6, a2
    add t6, t6, t5
    sub s5, a5, s5
    sltu a2, a5, s5
    sub a5, s5, a5
    sltu a5, s5, a5
    or s5, a5, a2
    add t6, t6, a5
    add t6, t6, s5
    add t6, t6, a5
    add t6, t6, a2
    sub ra, ra, ra
    sltu tp, ra, ra
    sub ra, ra, s2
    sltu s2, ra, ra
    or ra, s2, tp
    add t6, t6, ra
    add t6, t6, ra
    add t6, t6, s2
    add t6, t6, tp
    sub s6, s7, s6
    sltu s2, s7, s6
    sub s7, s6, s8
    sltu s8, s6, s7
    or s6, s8, s2
    add t6, t6, s7
    add t6, t6, s6
    add t6, t6, s8
    add t6, t6, s2
    sub sp, sp, sp
    sltu s1, sp, sp
    sub sp, sp, s5
    sltu s5, sp, sp
    or sp, s5, s1
    add t6, t6, sp
    add t6, t6, sp
    add t6, t6, s5
    add t6, t6, s1
    sub zero, a0, zero
    sltu a4, a0, zero
    sub a0, zero, zero
    sltu zero, zero, a0
    or zero, zero, a4
    add t6, t6, a0
    add t6, t6, zero
    add t6, t6, zero
    add t6, t6, a4
    add zero, zero, t2
    sltu t2, zero, t2
    add zero, zero, s1
    sltu s1, zero, s1
    or t2, t2, s1
    add t6, t6, zero
    add t6, t6, t2
    add t6, t6, s1
    add t6, t6, t4
    sub a5, s0, a5
    sltu a5, s0, a5
    sub s0, a5, a5
    sltu a5, a5, s0
    or a5, a5, a5
    add t6, t6, s0
    add t6, t6, a2
    add t6, t6, a5
    add t6, t6, a5
    sub ra, a4, ra
    sltu a1, a4, ra
    sub a4, ra, t5
    sltu t5, ra, a4
    or ra, t5, a1
    add t6, t6, a4
    add t6, t6, ra
    add t6, t6, t5
    add t6, t6, a1
    add a0, a0, s5
    sltu s5, a0, s5
    add a0, a0, t5
    sltu t5, a0, t5
    or s5, s5, t5
    add t6, t6, a0
    add t6, t6, s5
    add t6, t6, t5
    add t6, t6, t2
    add t4, t4, s2
    sltu s2, t4, s2
    add t4, t4, gp
    sltu gp, t4, gp
    or s2, s2, gp
    add t6, t6, t4
    add t6, t6, s2
    add t6, t6, gp
    add t6, t6, a2
    sub s0, a7, s0
    sltu t5, a7, s0
    sub a7, s0, t3
    sltu t3, s0, a7
    or s0, t3, t5
    add t6, t6, a7
    add t6, t6, s0
    add t6, t6, t3
    add t6, t6, t5
    add a4, a4, t5
    sltu t5, a4, t5
    add a4, a4, a4
    sltu a4, a4, a4
    or t5, t5, a4
    add t6, t6, a2
    add t6, t6, t5
    add t6, t6, a4
    add t6, t6, s2
    sub a6, s6, a6
    sltu s3, s6, a6
    sub s6, a6, t4
    sltu t4, a6, s6
    or a6, t4, s3
    add t6, t6, s6
    add t6, t6, a6
    add t6, t6, t4
    add t6, t6, s3
    sub s0, t1, s0
    sltu a5, t1, s0
    sub t1, s0, a6
    sltu a6, s0, t1
    or s0, a6, a5
    add t6, t6, t1
    add t6, t6, s0
    add t6, t6, a6
    add t6, t6, a5
    add t4, t4, ra
    sltu ra, t4, ra
    add t4, t4, a5
    sltu a5, t4, a5
    or ra, ra, a5
    add t6, t6, t4
    add t6, t6, ra
    add t6, t6, a5
    add t6, t6, s2
    add s5, s5, a1
    sltu a1, s5, a1
    add s5, s5, t3
    sltu t3, s5, t3
    or a1, a1, t3
    add t6, t6, s5
    add t6, t6, a1
    add t6, t6, t3
    add t6, t6, s1
    add a6, a6, a1
    sltu a1, a6, a1
    add a6, a6, a1
    sltu a1, a6, a1
    or a1, a1, a1
    add t6, t6, a6
    add t6, t6, a1
    add t6, t6, a1
    add t6, t6, t0
    sub a0, t1, a0
    sltu s5, t1, a0
    sub t1, a0, zero
    sltu zero, a0, t1
    or a0, zero, s5
    add t6, t6, t1
    add t6, t6, a0
    add t6, t6, zero
    add t6, t6, s5
    sub s5, sp, s5
    sltu a2, sp, s5
    sub sp, s5, a5
    sltu a5, s5, sp
    or s5, a5, a2
    add t6, t6, sp
    add t6, t6, s5
    add t6, t6, a5
    add t6, t6, a2
    sub s4, tp, s4
    sltu a7, tp, s4
    sub tp, s4, a7
    sltu a7, s4, tp
    or s4, a7, a7
    add t6, t6, tp
    add t6, t6, s4
    add t6, t6, a3
    add t6, t6, a7
    add s6, s6, sp
    sltu sp, s6, sp
    add s6, s6, s4
    sltu s4, s6, s4
    or sp, sp, s4
    add t6, t6, s6
    add t6, t6, sp
    add t6, t6, s4
    add t6, t6, s9
    add a6, a6, tp
    sltu tp, a6, tp
    add a6, a6, s8
    sltu s8, a6, s8
    or tp, tp, s8
    add t6, t6, a6
    add t6, t6, tp
    add t6, t6, s8
    add t6, t6, t1
    add s8, s8, s8
    sltu s8, s8, s8
    add s8, s8, t5
    sltu t5, s8, t5
    or s8, s8, t5
    add t6, t6, s8
    add t6, t6, s8
    add t6, t6, t5
    add t6, t6, a3
    sub t2, tp, t2
    sltu s11, tp, t2
    sub tp, t2, s4
    sltu s4, t2, tp
    or t2, s4, s11
    add t6, t6, tp
    add t6, t6, t2
    add t6, t6, s4
    add t6, t6, s11
    add t4, t4, s5
    sltu s5, t4, s5
    add t4, t4, gp
    sltu gp, t4, gp
    or s5, s5, gp
    add t6, t6, t4
    add t6, t6, s5
    add t6, t6, gp
    add t6, t6, a2
    sub a4, s3, a4
    sltu a7, s3, a4
    sub s3, a4, s1
    sltu s1, a4, s3
    or a4, s1, a7
    add t6, t6, s3
    add t6, t6, a4
    add t6, t6, s1
    add t6, t6, a7
    sub t0, s5, t0
    sltu sp, s5, t0
    sub s5, t0, s11
    sltu s11, t0, s5
    or t0, s11, sp
    add t6, t6, s5
    add t6, t6, t0
    add t6, t6, s11
    add t6, t6, sp
    sub ra, s1, ra
    sltu s10, s1, ra
    sub s1, ra, s10
    sltu s10, ra, s1
    or ra, s10, s10
    add t6, t6, s1
    add t6, t6, ra
    add t6, t6, s10
    add t6, t6, s10
    sub ra, t4, ra
    sltu s2, t4, ra
    sub t4, ra, t4
    sltu t4, ra, t4
    or ra, t4, s2
    add t6, t6, a2
    add t6, t6, ra
    add t6, t6, t4
    add t6, t6, s2
    add t2, t2, a5
    sltu a5, t2, a5
    add t2, t2, s7
    sltu s7, t2, s7
    or a5, a5, s7
    add t6, t6, t2
    add t6, t6, a5
    add t6, t6, s7
    add t6, t6, t0
    sub a5, s8, a5
    sltu s5, s8, a5
    sub s8, a5, gp
    sltu gp, a5, s8
    or a5, gp, s5
    add t6, t6, s8
    add t6, t6, a5
    add t6, t6, gp
    add t6, t6, s5
    add t5, t5, zero
    sltu zero, t5, zero
    add t5, t5, t5
    sltu t5, t5, t5
    or zero, zero, t5
    add t6, t6, t5
    add t6, t6, zero
    add t6, t6, t5
    add t6, t6, s3
    add t4, t4, t0
    sltu t0, t4, t0
    add t4, t4, t4
    sltu t4, t4, t4
    or t0, t0, t4
    add t6, t6, t4
    add t6, t6, t0
    add t6, t6, t4
    add t6, t6, t1
    sub a5, gp, a5
    sltu s3, gp, a5
    sub gp, a5, a5
    sltu a5, a5, gp
    or a5, a5, s3
    add t6, t6, gp
    add t6, t6, a2
    add t6, t6, a5
    add t6, t6, s3
    add s9, s9, a2
    sltu a2, s9, a2
    add s9, s9, a2
    sltu a2, s9, a2
    or a2, a2, a2
    add t6, t6, s9
    add t6, t6, a2
    add t6, t6, a2
    add t6, t6, s6
    add t3, t3, zero
    sltu zero, t3, zero
    add t3, t3, t3
    sltu t3, t3, t3
    or zero, zero, t3
    add t6, t6, t3
    add t6, t6, zero
    add t6, t6, t3
    add t6, t6, s7
    add s11, s11, s10
    sltu s10, s11, s10
    add s11, s11, t5
    sltu t5, s11, t5
    or s10, s10, t5
    add t6, t6, s11
    add t6, t6, s10
    add t6, t6, t5
    add t6, t6, ra
    sub t5, s8, t5
    sltu s1, s8, t5
    sub s8, t5, sp
    sltu sp, t5, s8
    or t5, sp, s1
    add t6, t6, s8
    add t6, t6, t5
    add t6, t6, sp
    add t6, t6, s1
    sub s11, s0, s11
    sltu s11, s0, s11
    sub s0, s11, s5
    sltu s5, s11, s0
    or s11, s5, s11
    add t6, t6, s0
    add t6, t6, s11
    add t6, t6, s5
    add t6, t6, s11
    sub t3, a4, t3
    sltu s11, a4, t3
    sub a4, t3, s1
    sltu s1, t3, a4
    or t3, s1, s11
    add t6, t6, a4
    add t6, t6, t3
    add t6, t6, s1
    add t6, t6, s11
    add a5, a5, sp
    sltu sp, a5, sp
    add a5, a5, t0
    sltu t0, a5, t0
    or sp, sp, t0
    add t6, t6, a5
    add t6, t6, sp
    add t6, t6, t0
    add t6, t6, gp
    sub ra, a4, ra
    sltu s1, a4, ra
    sub a4, ra, s4
    sltu s4, ra, a4
    or ra, s4, s1
    add t6, t6, a4
    add t6, t6, ra
    add t6, t6, s4
    add t6, t6, s1
    sub s0, s1, s0
    sltu s1, s1, s0
    sub s1, s0, s9
    sltu s9, s0, s1
    or s0, s9, s1
    add t6, t6, a3
    add t6, t6, s0
    add t6, t6, s9
    add t6, t6, s1
    sub t1, s6, t1
    sltu a3, s6, t1
    sub s6, t1, s0
    sltu s0, t1, s6
    or t1, s0, a3
    add t6, t6, s6
    add t6, t6, t1
    add t6, t6, s0
    add t6, t6, a3
    add s4, s4, a7
    sltu a7, s4, a7
    add s4, s4, a0
    sltu a0, s4, a0
    or a7, a7, a0
    add t6, t6, s4
    add t6, t6, a7
    add t6, t6, a0
    add t6, t6, a6
    add a5, a5, t0
    sltu t0, a5, t0
    add a5, a5, zero
    sltu zero, a5, zero
    or t0, t0, zero
    add t6, t6, a5
    add t6, t6, t0
    add t6, t6, zero
    add t6, t6, a4
    sub a6, s9, a6
    sltu s8, s9, a6
    sub s9, a6, t0
    sltu t0, a6, s9
    or a6, t0, s8
    add t6, t6, s9
    add t6, t6, a6
    add t6, t6, t0
    add t6, t6, s8
    add s3, s3, t0
    sltu t0, s3, t0
    add s3, s3, t0
    sltu t0, s3, t0
    or t0, t0, t0
    add t6, t6, s3
    add t6, t6, a2
    add t6, t6, t0
    add t6, t6, zero
    add t0, t0, s7
    sltu s7, t0, s7
    add t0, t0, zero
    sltu zero, t0, zero
    or s7, s7, zero
    add t6, t6, t0
    add t6, t6, s7
    add t6, t6, zero
    add t6, t6, s11
    add t5, t5, s8
    sltu s8, t5, s8
    add t5, t5, s10
    sltu s10, t5, s10
    or s8, s8, s10
    add t6, t6, t5
    add t6, t6, s8
    add t6, t6, s10
    add t6, t6, t5
    add s9, s9, s3
    sltu s3, s9, s3
    add s9, s9, s3
    sltu s3, s9, s3
    or s3, s3, s3
    add t6, t6, s9
    add t6, t6, s3
    add t6, t6, s3
    add t6, t6, zero
    sub a1, s2, a1
    sltu a1, s2, a1
    sub s2, a1, s2
    sltu s2, a1, s2
    or a1, s2, a1
    add t6, t6, a2
    add t6, t6, a1
    add t6, t6, s2
    add t6, t6, a1
    sub a7, s5, a7
    sltu t0, s5, a7
    sub s5, a7, s3
    sltu s3, a7, s5
    or a7, s3, t0
    add t6, t6, s5
    add t6, t6, a7
    add t6, t6, s3
    add t6, t6, t0
    add t5, t5, a4
    sltu a4, t5, a4
    add t5, t5, s10
    sltu s10, t5, s10
    or a4, a4, s10
    add t6, t6, t5
    add t6, t6, a4
    add t6, t6, s10
    add t6, t6, a5
    add a4, a4, s8
    sltu s8, a4, s8
    add a4, a4, s4
    sltu s4, a4, s4
    or s8, s8, s4
    add t6, t6, a4
    add t6, t6, a3
    add t6, t6, s4
    add t6, t6, s8
    sub a0, s11, a0
    sltu ra, s11, a0
    sub s11, a0, t3
    sltu t3, a0, s11
    or a0, t3, ra
    add t6, t6, s11
    add t6, t6, a0
    add t6, t6, t3
    add t6, t6, ra
    sub s4, s11, s4
    sltu s9, s11, s4
    sub s11, s4, t1
    sltu t1, s4, s11
    or s4, t1, s9
    add t6, t6, s11
    add t6, t6, s4
    add t6, t6, t1
    add t6, t6, s9
    add tp, tp, s0
    sltu s0, tp, s0
    add tp, tp, s0
    sltu s0, tp, s0
    or s0, s0, s0
    add t6, t6, tp
    add t6, t6, a2
    add t6, t6, s0
    add t6, t6, a0
    sub s3, a7, s3
    sltu s3, a7, s3
    sub a7, s3, s7
    sltu s7, s3, a7
    or s3, s7, s3
    add t6, t6, a7
    add t6, t6, s3
    add t6, t6, s7
    add t6, t6, s3
    add s7, s7, s6
    sltu s6, s7, s6
    add s7, s7, s4
    sltu s4, s7, s4
    or s6, s6, s4
    add t6, t6, s7
    add t6, t6, s6
    add t6, t6, s4
    add t6, t6, s3
    add s10, s10, a1
    sltu a1, s10, a1
    add s10, s10, s3
    sltu s3, s10, s3
    or a1, a1, s3
    add t6, t6, s10
    add t6, t6, a1
    add t6, t6, s3
    add t6, t6, s4
    add ra, ra, s4
    sltu s4, ra, s4
    add ra, ra, s5
    sltu s5, ra, s5
    or s4, s4, s5
    add t6, t6, ra
    add t6, t6, s4
    add t6, t6, s5
    add t6, t6, s6
    sub sp, t5, sp
    sltu t4, t5, sp
    sub t5, sp, t5
    sltu t5, sp, t5
    or sp, t5, t4
    add t6, t6, t5
    add t6, t6, sp
    add t6, t6, t5
    add t6, t6, t4
    add gp, gp, sp
    sltu sp, gp, sp
    add gp, gp, a4
    sltu a4, gp, a4
    or sp, sp, a4
    add t6, t6, gp
    add t6, t6, sp
    add t6, t6, a4
    add t6, t6, gp
    add a4, a4, s4
    sltu s4, a4, s4
    add a4, a4, t2
    sltu t2, a4, t2
    or s4, s4, t2
    add t6, t6, a4
    add t6, t6, s4
    add t6, t6, t2
    add t6, t6, a6
    sub s11, s5, s11
    sltu a5, s5, s11
    sub s5, s11, a1
    sltu a1, s11, s5
    or s11, a1, a5
    add t6, t6, s5
    add t6, t6, s11
    add t6, t6, a1
    add t6, t6, a5
    sub t5, a0, t5
    sltu s2, a0, t5
    sub a0, t5, s10
    sltu s10, t5, a0
    or t5, s10, s2
    add t6, t6, a0
    add t6, t6, t5
    add t6, t6, s10
    add t6, t6, s2
    sub gp, s9, gp
    sltu s8, s9, gp
    sub s9, gp, a6
    sltu a6, gp, s9
    or gp, a6, s8
    add t6, t6, s9
    add t6, t6, gp
    add t6, t6, a6
    add t6, t6, s8
    sub s9, sp, s9
    sltu s4, sp, s9
    sub sp, s9, a7
    sltu a7, s9, sp
    or s9, a7, s4
    add t6, t6, sp
    add t6, t6, s9
    add t6, t6, a7
    add t6, t6, s4
    add zero, zero, t4
    sltu t4, zero, t4
    add zero, zero, s0
    sltu s0, zero, s0
    or t4, t4, s0
    add t6, t6, zero
    add t6, t6, t4
    add t6, t6, s0
    add t6, t6, a7
    sub a1, s2, a1
    sltu a4, s2, a1
    sub s2, a1, a1
    sltu a1, a1, s2
    or a1, a1, a4
    add t6, t6, s2
    add t6, t6, a2
    add t6, t6, a1
    add t6, t6, a4
    add s9, s9, s0
    sltu s0, s9, s0
    add s9, s9, s9
    sltu s9, s9, s9
    or s0, s0, s9
    add t6, t6, a2
    add t6, t6, s0
    add t6, t6, s9
    add t6, t6, t5
    sub sp, gp, sp
    sltu a4, gp, sp
    sub gp, sp, a4
    sltu a4, sp, gp
    or sp, a4, a4
    add t6, t6, gp
    add t6, t6, sp
    add t6, t6, a3
    add t6, t6, a4
    add sp, sp, s4
    sltu s4, sp, s4
    add sp, sp, s5
    sltu s5, sp, s5
    or s4, s4, s5
    add t6, t6, sp
    add t6, t6, s4
    add t6, t6, s5
    add t6, t6, a2
    sub zero, s2, zero
    sltu tp, s2, zero
    sub s2, zero, t2
    sltu t2, zero, s2
    or zero, t2, tp
    add t6, t6, s2
    add t6, t6, zero
    add t6, t6, t2
    add t6, t6, tp
    sub s5, t5, s5
    sltu t5, t5, s5
    sub t5, s5, a7
    sltu a7, s5, t5
    or s5, a7, t5
    add t6, t6, t5
    add t6, t6, s5
    add t6, t6, a7
    add t6, t6, t5
    add t3, t3, s6
    sltu s6, t3, s6
    add t3, t3, s2
    sltu s2, t3, s2
    or s6, s6, s2
    add t6, t6, t3
    add t6, t6, s6
    add t6, t6, s2
    add t6, t6, a6
    add s5, s5, s0
    sltu s0, s5, s0
    add s5, s5, tp
    sltu tp, s5, tp
    or s0, s0, tp
    add t6, t6, s5
    add t6, t6, s0
    add t6, t6, tp
    add t6, t6, s11
    add a7, a7, s7
    sltu s7, a7, s7
    add a7, a7, t2
    sltu t2, a7, t2
    or s7, s7, t2
    add t6, t6, a7
    add t6, t6, s7
    add t6, t6, t2
    add t6, t6, a0
    add s9, s9, t2
    sltu t2, s9, t2
    add s9, s9, s11
    sltu s11, s9, s11
    or t2, t2, s11
    add t6, t6, s9
    add t6, t6, t2
    add t6, t6, s11
    add t6, t6, s1
    sub s0, gp, s0
    sltu t2, gp, s0
    sub gp, s0, s2
    sltu s2, s0, gp
    or s0, s2, t2
    add t6, t6, gp
    add t6, t6, s0
    add t6, t6, s2
    add t6, t6, t2
    add a4, a4, s3
    sltu s3, a4, s3
    add a4, a4, t5
    sltu t5, a4, t5
    or s3, s3, t5
    add t6, t6, a4
    add t6, t6, s3
    add t6, t6, t5
    add t6, t6, s9
    sub s7, s3, s7
    sltu s11, s3, s7
    sub s3, s7, s8
    sltu s8, s7, s3
    or s7, s8, s11
    add t6, t6, s3
    add t6, t6, s7
    add t6, t6, s8
    add t6, t6, s11
    add s3, s3, zero
    sltu zero, s3, zero
    add s3, s3, s5
    sltu s5, s3, s5
    or zero, zero, s5
    add t6, t6, s3
    add t6, t6, zero
    add t6, t6, s5
    add t6, t6, gp
    sub a7, zero, a7
    sltu t3, zero, a7
    sub zero, a7, t0
    sltu t0, a7, zero
    or a7, t0, t3
    add t6, t6, zero
    add t6, t6, a7
    add t6, t6, t0
    add t6, t6, t3
    add a5, a5, tp
    sltu tp, a5, tp
    add a5, a5, s5
    sltu s5, a5, s5
    or tp, tp, s5
    add t6, t6, a5
    add t6, t6, tp
    add t6, t6, s5
    add t6, t6, a5
    sub a0, s7, a0
    sltu t0, s7, a0
    sub s7, a0, s0
    sltu s0, a0, s7
    or a0, s0, t0
    add t6, t6, s7
    add t6, t6, a0
    add t6, t6, s0
    add t6, t6, t0
    add a4, a4, s5
    sltu s5, a4, s5
    add a4, a4, s5
    sltu s5, a4, s5
    or s5, s5, s5
    add t6, t6, a4
    add t6, t6, a2
    add t6, t6, a3
    add t6, t6, s5
    sub a5, gp, a5
    sltu a1, gp, a5
    sub gp, a5, a2
    sltu a2, a5, gp
    or a5, a2, a1
    add t6, t6, gp
    add t6, t6, a5
    add t6, t6, a2
    add t6, t6, a1
    sub s7, t2, s7
    sltu s10, t2, s7
    sub t2, s7, s8
    sltu s8, s7, t2
    or s7, s8, s10
    add t6, t6, t2
    add t6, t6, s7
    add t6, t6, s8
    add t6, t6, s10
    sub t3, s2, t3
    sltu s2, s2, t3
    sub s2, t3, zero
    sltu zero, t3, s2
    or t3, zero, s2
    add t6, t6, a3
    add t6, t6, t3
    add t6, t6, zero
    add t6, t6, s2
    add ra, ra, gp
    sltu gp, ra, gp
    add ra, ra, s0
    sltu s0, ra, s0
    or gp, gp, s0
    add t6, t6, ra
    add t6, t6, gp
    add t6, t6, s0
    add t6, t6, t5
    add s5, s5, t1
    sltu t1, s5, t1
    add s5, s5, a7
    sltu a7, s5, a7
    or t1, t1, a7
    add t6, t6, s5
    add t6, t6, t1
    add t6, t6, a7
    add t6, t6, a4
    add sp, sp, s6
    sltu s6, sp, s6
    add sp, sp, t0
    sltu t0, sp, t0
    or s6, s6, t0
    add t6, t6, sp
    add t6, t6, s6
    add t6, t6, t0
    add t6, t6, t0
    add s0, s0, s1
    sltu s1, s0, s1
    add s0, s0, s9
    sltu s9, s0, s9
    or s1, s1, s9
    add t6, t6, s0
    add t6, t6, s1
    add t6, t6, s9
    add t6, t6, ra
    sub a6, a4, a6
    sltu s2, a4, a6
    sub a4, a6, zero
    sltu zero, a6, a4
    or a6, zero, s2
    add t6, t6, a4
    add t6, t6, a6
    add t6, t6, zero
    add t6, t6, s2
    add a5, a5, ra
    sltu ra, a5, ra
    add a5, a5, a6
    sltu a6, a5, a6
    or ra, ra, a6
    add t6, t6, a5
    add t6, t6, ra
    add t6, t6, a6
    add t6, t6, a7
    sub s10, ra, s10
    sltu a4, ra, s10
    sub ra, s10, a4
    sltu a4, s10, ra
    or s10, a4, a4
    add t6, t6, ra
    add t6, t6, s10
    add t6, t6, a3
    add t6, t6, a4
    sub s8, tp, s8
    sltu s6, tp, s8
    sub tp, s8, t3
    sltu t3, s8, tp
    or s8, t3, s6
    add t6, t6, tp
    add t6, t6, s8
    add t6, t6, t3
    add t6, t6, s6
    sub s5, s5, s5
    sltu a5, s5, s5
    sub s5, s5, ra
    sltu ra, s5, s5
    or s5, ra, a5
    add t6, t6, s5
    add t6, t6, s5
    add t6, t6, ra
    add t6, t6, a5
    add ra, ra, tp
    sltu tp, ra, tp
    add ra, ra, s10
    sltu s10, ra, s10
    or tp, tp, s10
    add t6, t6, ra
    add t6, t6, tp
    add t6, t6, s10
    add t6, t6, s2
    sub gp, s2, gp
    sltu t2, s2, gp
    sub s2, gp, s0
    sltu s0, gp, s2
    or gp, s0, t2
    add t6, t6, s2
    add t6, t6, gp
    add t6, t6, s0
    add t6, t6, t2
    add s2, s2, s7
    sltu s7, s2, s7
    add s2, s2, s1
    sltu s1, s2, s1
    or s7, s7, s1
    add t6, t6, s2
    add t6, t6, s7
    add t6, t6, s1
    add t6, t6, s2
    sub s9, a4, s9
    sltu a3, a4, s9
    sub a4, s9, a1
    sltu a1, s9, a4
    or s9, a1, a3
    add t6, t6, a4
    add t6, t6, s9
    add t6, t6, a1
    add t6, t6, a3
    sub sp, t2, sp
    sltu a6, t2, sp
    sub t2, sp, s4
    sltu s4, sp, t2
    or sp, s4, a6
    add t6, t6, t2
    add t6, t6, sp
    add t6, t6, s4
    add t6, t6, a6
    sub t0, s1, t0
    sltu s2, s1, t0
    sub s1, t0, t5
    sltu t5, t0, s1
    or t0, t5, s2
    add t6, t6, s1
    add t6, t6, t0
    add t6, t6, t5
    add t6, t6, s2
    sub s7, ra, s7
    sltu t0, ra, s7
    sub ra, s7, sp
    sltu sp, s7, ra
    or s7, sp, t0
    add t6, t6, ra
    add t6, t6, s7
    add t6, t6, sp
    add t6, t6, t0
    sub a0, s4, a0
    sltu s3, s4, a0
    sub s4, a0, s6
    sltu s6, a0, s4
    or a0, s6, s3
    add t6, t6, s4
    add t6, t6, a0
    add t6, t6, s6
    add t6, t6, s3
    add t3, t3, a4
    sltu a4, t3, a4
    add t3, t3, a2
    sltu a2, t3, a2
    or a4, a4, a2
    add t6, t6, t3
    add t6, t6, a4
    add t6, t6, a2
    add t6, t6, t0
    sub a0, zero, a0
    sltu a5, zero, a0
    sub zero, a0, s3
    sltu s3, a0, zero
    or a0, s3, a5
    add t6, t6, zero
    add t6, t6, a0
    add t6, t6, s3
    add t6, t6, a5
    sub zero, s7, zero
    sltu s3, s7, zero
    sub s7, zero, s6
    sltu s6, zero, s7
    or zero, s6, s3
    add t6, t6, s7
    add t6, t6, zero
    add t6, t6, s6
    add t6, t6, s3
    sub a4, s10, a4
    sltu a4, s10, a4
    sub s10, a4, s10
    sltu s10, a4, s10
    or a4, s10, a4
    add t6, t6, s10
    add t6, t6, a4
    add t6, t6, s10
    add t6, t6, a4
    sub t5, t5, t5
    sltu s1, t5, t5
    sub t5, t5, s1
    sltu s1, t5, t5
    or t5, s1, s1
    add t6, t6, a1
    add t6, t6, t5
    add t6, t6, a3
    add t6, t6, s1
    add a0, a0, s5
    sltu s5, a0, s5
    add a0, a0, s1
    sltu s1, a0, s1
    or s5, s5, s1
    add t6, t6, a0
    add t6, t6, s5
    add t6, t6, s1
    add t6, t6, s4
    sub a0, s7, a0
    sltu s3, s7, a0
    sub s7, a0, s6
    sltu s6, a0, s7
    or a0, s6, s3
    add t6, t6, s7
    add t6, t6, a0
    add t6, t6, s6
    add t6, t6, s3
    add s2, s2, s10
    sltu s10, s2, s10
    add s2, s2, s6
    sltu s6, s2, s6
    or s10, s10, s6
    add t6, t6, s2
    add t6, t6, s10
    add t6, t6, s6
    add t6, t6, a0
    add t5, t5, gp
    sltu gp, t5, gp
    add t5, t5, sp
    sltu sp, t5, sp
    or gp, gp, sp
    add t6, t6, t5
    add t6, t6, gp
    add t6, t6, sp
    add t6, t6, s8
    add t0, t0, s10
    sltu s10, t0, s10
    add t0, t0, gp
    sltu gp, t0, gp
    or s10, s10, gp
    add t6, t6, t0
    add t6, t6, s10
    add t6, t6, gp
    add t6, t6, sp
    add s9, s9, s10
    sltu s10, s9, s10
    add s9, s9, zero
    sltu zero, s9, zero
    or s10, s10, zero
    add t6, t6, s9
    add t6, t6, s10
    add t6, t6, zero
    add t6, t6, s11
    add t2, t2, s7
    sltu s7, t2, s7
    add t2, t2, a7
    sltu a7, t2, a7
    or s7, s7, a7
    add t6, t6, t2
    add t6, t6, s7
    add t6, t6, a7
    add t6, t6, t0
    add s10, s10, s8
    sltu s8, s10, s8
    add s10, s10, s11
    sltu s11, s10, s11
    or s8, s8, s11
    add t6, t6, s10
    add t6, t6, s8
    add t6, t6, s11
    add t6, t6, a2
    add a6, a6, sp
    sltu sp, a6, sp
    add a6, a6, a6
    sltu a6, a6, a6
    or sp, sp, a6
    add t6, t6, a2
    add t6, t6, sp
    add t6, t6, a6
    add t6, t6, a5
    sub a6, s5, a6
    sltu t3, s5, a6
    sub s5, a6, zero
    sltu zero, a6, s5
    or a6, zero, t3
    add t6, t6, s5
    add t6, t6, a6
    add t6, t6, zero
    add t6, t6, t3
    add a4, a4, s9
    sltu s9, a4, s9
    add a4, a4, s7
    sltu s7, a4, s7
    or s9, s9, s7
    add t6, t6, a4
    add t6, t6, s9
    add t6, t6, s7
    add t6, t6, a3
    sub a1, t5, a1
    sltu a0, t5, a1
    sub t5, a1, s2
    sltu s2, a1, t5
    or a1, s2, a0
    add t6, t6, t5
    add t6, t6, a1
    add t6, t6, s2
    add t6, t6, a0
    add s8, s8, a4
    sltu a4, s8, a4
    add s8, s8, s7
    sltu s7, s8, s7
    or a4, a4, s7
    add t6, t6, s8
    add t6, t6, a4
    add t6, t6, s7
    add t6, t6, s11
    sub zero, s9, zero
    sltu a7, s9, zero
    sub s9, zero, t5
    sltu t5, zero, s9
    or zero, t5, a7
    add t6, t6, s9
    add t6, t6, zero
    add t6, t6, t5
    add t6, t6, a7
    add tp, tp, t5
    sltu t5, tp, t5
    add tp, tp, tp
    sltu tp, tp, tp
    or t5, t5, tp
    add t6, t6, tp
    add t6, t6, t5
    add t6, t6, tp
    add t6, t6, s3
    sub s3, a4, s3
    sltu ra, a4, s3
    sub a4, s3, t2
    sltu t2, s3, a4
    or s3, t2, ra
    add t6, t6, a4
    add t6, t6, s3
    add t6, t6, t2
    add t6, t6, ra
    sub t4, s0, t4
    sltu s11, s0, t4
    sub s0, t4, a0
    sltu a0, t4, s0
    or t4, a0, s11
    add t6, t6, s0
    add t6, t6, t4
    add t6, t6, a0
    add t6, t6, s11
    sub s1, s4, s1
    sltu a1, s4, s1
    sub s4, s1, a1
    sltu a1, s1, s4
    or s1, a1, a1
    add t6, t6, s4
    add t6, t6, s1
    add t6, t6, a3
    add t6, t6, a1
    add s1, s1, s9
    sltu s9, s1, s9
    add s1, s1, a4
    sltu a4, s1, a4
    or s9, s9, a4
    add t6, t6, s1
    add t6, t6, s9
    add t6, t6, a4
    add t6, t6, s0
    sub s6, t5, s6
    sltu a1, t5, s6
    sub t5, s6, s10
    sltu s10, s6, t5
    or s6, s10, a1
    add t6, t6, t5
    add t6, t6, s6
    add t6, t6, s10
    add t6, t6, a1
    sub s3, tp, s3
    sltu t2, tp, s3
    sub tp, s3, a7
    sltu a7, s3, tp
    or s3, a7, t2
    add t6, t6, tp
    add t6, t6, s3
    add t6, t6, a7
    add t6, t6, t2
    add s4, s4, t1
    sltu t1, s4, t1
    add s4, s4, s3
    sltu s3, s4, s3
    or t1, t1, s3
    add t6, t6, s4
    add t6, t6, t1
    add t6, t6, s3
    add t6, t6, tp
    add s6, s6, s10
    sltu s10, s6, s10
    add s6, s6, a4
    sltu a4, s6, a4
    or s10, s10, a4
    add t6, t6, s6
    add t6, t6, s10
    add t6, t6, a4
    add t6, t6, s8
    sub t1, s0, t1
    sltu zero, s0, t1
    sub s0, t1, s10
    sltu s10, t1, s0
    or t1, s10, zero
    add t6, t6, s0
    add t6, t6, t1
    add t6, t6, s10
    add t6, t6, zero
    add s9, s9, t0
    sltu t0, s9, t0
    add s9, s9, t0
    sltu t0, s9, t0
    or t0, t0, t0
    add t6, t6, s9
    add t6, t6, a2
    add t6, t6, t0
    add t6, t6, t0
    add s11, s11, t3
    sltu t3, s11, t3
    add s11, s11, a4
    sltu a4, s11, a4
    or t3, t3, a4
    add t6, t6, s11
    add t6, t6, t3
    add t6, t6, a4
    add t6, t6, zero
    add ra, ra, t0
    sltu t0, ra, t0
    add ra, ra, a2
    sltu a2, ra, a2
    or t0, t0, a2
    add t6, t6, ra
    add t6, t6, t0
    add t6, t6, a2
    add t6, t6, sp
    add s8, s8, zero
    sltu zero, s8, zero
    add s8, s8, t0
    sltu t0, s8, t0
    or zero, zero, t0
    add t6, t6, s8
    add t6, t6, zero
    add t6, t6, t0
    add t6, t6, a0
    add tp, tp, gp
    sltu gp, tp, gp
    add tp, tp, ra
    sltu ra, tp, ra
    or gp, gp, ra
    add t6, t6, tp
    add t6, t6, gp
    add t6, t6, ra
    add t6, t6, s3
    sub zero, s3, zero
    sltu t5, s3, zero
    sub s3, zero, s4
    sltu s4, zero, s3
    or zero, s4, t5
    add t6, t6, s3
    add t6, t6, zero
    add t6, t6, s4
    add t6, t6, t5
    sub t5, s3, t5
    sltu a3, s3, t5
    sub s3, t5, a1
    sltu a1, t5, s3
    or t5, a1, a3
    add t6, t6, s3
    add t6, t6, t5
    add t6, t6, a1
    add t6, t6, a3
    sub a2, zero, a2
    sltu s11, zero, a2
    sub zero, a2, a2
    sltu a2, a2, zero
    or a2, a2, s11
    add t6, t6, zero
    add t6, t6, a2
    add t6, t6, a2
    add t6, t6, s11
    add t5, t5, t0
    sltu t0, t5, t0
    add t5, t5, zero
    sltu zero, t5, zero
    or t0, t0, zero
    add t6, t6, t5
    add t6, t6, t0
    add t6, t6, zero
    add t6, t6, t1
    sub s11, s11, s11
    sltu t2, s11, s11
    sub s11, s11, t0
    sltu t0, s11, s11
    or s11, t0, t2
    add t6, t6, s11
    add t6, t6, s11
    add t6, t6, t0
    add t6, t6, t2
    sub s4, t0, s4
    sltu a0, t0, s4
    sub t0, s4, t0
    sltu t0, s4, t0
    or s4, t0, a0
    add t6, t6, t0
    add t6, t6, s4
    add t6, t6, t0
    add t6, t6, a0
    add s11, s11, s0
    sltu s0, s11, s0
    add s11, s11, ra
    sltu ra, s11, ra
    or s0, s0, ra
    add t6, t6, s11
    add t6, t6, a3
    add t6, t6, ra
    add t6, t6, s0
    sub s7, s2, s7
    sltu s8, s2, s7
    sub s2, s7, ra
    sltu ra, s7, s2
    or s7, ra, s8
    add t6, t6, s2
    add t6, t6, s7
    add t6, t6, ra
    add t6, t6, s8
    add t1, t1, s10
    sltu s10, t1, s10
    add t1, t1, a0
    sltu a0, t1, a0
    or s10, s10, a0
    add t6, t6, t1
    add t6, t6, s10
    add t6, t6, a0
    add t6, t6, a0
    add t5, t5, t3
    sltu t3, t5, t3
    add t5, t5, a5
    sltu a5, t5, a5
    or t3, t3, a5
    add t6, t6, t5
    add t6, t6, t3
    add t6, t6, a5
    add t6, t6, s4
    sub a5, t5, a5
    sltu gp, t5, a5
    sub t5, a5, t5
    sltu t5, a5, t5
    or a5, t5, gp
    add t6, t6, t5
    add t6, t6, a5
    add t6, t6, t5
    add t6, t6, gp
    sub t3, s8, t3
    sltu t3, s8, t3
    sub s8, t3, a7
    sltu a7, t3, s8
    or t3, a7, t3
    add t6, t6, s8
    add t6, t6, t3
    add t6, t6, a7
    add t6, t6, t3
    sub s4, s1, s4
    sltu zero, s1, s4
    sub s1, s4, t4
    sltu t4, s4, s1
    or s4, t4, zero
    add t6, t6, s1
    add t6, t6, s4
    add t6, t6, t4
    add t6, t6, zero
    sub s5, tp, s5
    sltu s1, tp, s5
    sub tp, s5, s0
    sltu s0, s5, tp
    or s5, s0, s1
    add t6, t6, tp
    add t6, t6, s5
    add t6, t6, s0
    add t6, t6, s1
    sub s2, s10, s2
    sltu a2, s10, s2
    sub s10, s2, a7
    sltu a7, s2, s10
    or s2, a7, a2
    add t6, t6, s10
    add t6, t6, s2
    add t6, t6, a7
    add t6, t6, a2
    sub zero, ra, zero
    sltu a4, ra, zero
    sub ra, zero, s11
    sltu s11, zero, ra
    or zero, s11, a4
    add t6, t6, ra
    add t6, t6, zero
    add t6, t6, s11
    add t6, t6, a4
    sub s8, s8, s8
    sltu a3, s8, s8
    sub s8, s8, a1
    sltu a1, s8, s8
    or s8, a1, a3
    add t6, t6, a1
    add t6, t6, s8
    add t6, t6, a1
    add t6, t6, a3
    add ra, ra, a0
    sltu a0, ra, a0
    add ra, ra, a5
    sltu a5, ra, a5
    or a0, a0, a5
    add t6, t6, ra
    add t6, t6, a0
    add t6, t6, a5
    add t6, t6, gp
    add gp, gp, t5
    sltu t5, gp, t5
    add gp, gp, s11
    sltu s11, gp, s11
    or t5, t5, s11
    add t6, t6, a3
    add t6, t6, t5
    add t6, t6, s11
    add t6, t6, gp
    add s8, s8, s8
    sltu s8, s8, s8
    add s8, s8, t3
    sltu t3, s8, t3
    or s8, s8, t3
    add t6, t6, s8
    add t6, t6, s8
    add t6, t6, t3
    add t6, t6, gp
    add t0, t0, s1
    sltu s1, t0, s1
    add t0, t0, t3
    sltu t3, t0, t3
    or s1, s1, t3
    add t6, t6, t0
    add t6, t6, s1
    add t6, t6, t3
    add t6, t6, a2
    add s9, s9, t3
    sltu t3, s9, t3
    add s9, s9, s2
    sltu s2, s9, s2
    or t3, t3, s2
    add t6, t6, s9
    add t6, t6, a3
    add t6, t6, s2
    add t6, t6, t3
    add a2, a2, s4
    sltu s4, a2, s4
    add a2, a2, a2
    sltu a2, a2, a2
    or s4, s4, a2
    add t6, t6, a2
    add t6, t6, s4
    add t6, t6, a2
    add t6, t6, t0
    add s3, s3, t1
    sltu t1, s3, t1
    add s3, s3, a7
    sltu a7, s3, a7
    or t1, t1, a7
    add t6, t6, s3
    add t6, t6, t1
    add t6, t6, a7
    add t6, t6, s5
    sub s1, t2, s1
    sltu a5, t2, s1
    sub t2, s1, sp
    sltu sp, s1, t2
    or s1, sp, a5
    add t6, t6, t2
    add t6, t6, s1
    add t6, t6, sp
    add t6, t6, a5
    add s9, s9, a6
    sltu a6, s9, a6
    add s9, s9, gp
    sltu gp, s9, gp
    or a6, a6, gp
    add t6, t6, a3
    add t6, t6, a6
    add t6, t6, gp
    add t6, t6, s9
    sub a1, s3, a1
    sltu s1, s3, a1
    sub s3, a1, s7
    sltu s7, a1, s3
    or a1, s7, s1
    add t6, t6, s3
    add t6, t6, a1
    add t6, t6, s7
    add t6, t6, s1
    add a4, a4, t5
    sltu t5, a4, t5
    add a4, a4, a0
    sltu a0, a4, a0
    or t5, t5, a0
    add t6, t6, a4
    add t6, t6, t5
    add t6, t6, a0
    add t6, t6, t0
    sub s6, ra, s6
    sltu s5, ra, s6
    sub ra, s6, a0
    sltu a0, s6, ra
    or s6, a0, s5
    add t6, t6, ra
    add t6, t6, s6
    add t6, t6, a0
    add t6, t6, s5
    add t1, t1, s2
    sltu s2, t1, s2
    add t1, t1, s5
    sltu s5, t1, s5
    or s2, s2, s5
    add t6, t6, t1
    add t6, t6, s2
    add t6, t6, s5
    add t6, t6, a0
    sub s5, s4, s5
    sltu gp, s4, s5
    sub s4, s5, s5
    sltu s5, s5, s4
    or s5, s5, gp
    add t6, t6, s4
    add t6, t6, a2
    add t6, t6, s5
    add t6, t6, gp
    add s6, s6, s4
    sltu s4, s6, s4
    add s6, s6, tp
    sltu tp, s6, tp
    or s4, s4, tp
    add t6, t6, s6
    add t6, t6, s4
    add t6, t6, tp
    add t6, t6, s0
    sub a4, t0, a4
    sltu a6, t0, a4
    sub t0, a4, a7
    sltu a7, a4, t0
    or a4, a7, a6
    add t6, t6, t0
    add t6, t6, a4
    add t6, t6, a7
    add t6, t6, a6
    sub t0, s11, t0
    sltu s8, s11, t0
    sub s11, t0, a2
    sltu a2, t0, s11
    or t0, a2, s8
    add t6, t6, s11
    add t6, t6, t0
    add t6, t6, a2
    add t6, t6, s8
    add s1, s1, s1
    sltu s1, s1, s1
    add s1, s1, s0
    sltu s0, s1, s0
    or s1, s1, s0
    add t6, t6, a1
    add t6, t6, s1
    add t6, t6, s0
    add t6, t6, t1
    sub gp, t2, gp
    sltu s5, t2, gp
    sub t2, gp, t3
    sltu t3, gp, t2
    or gp, t3, s5
    add t6, t6, t2
    add t6, t6, gp
    add t6, t6, t3
    add t6, t6, s5
    sub s8, t3, s8
    sltu sp, t3, s8
    sub t3, s8, t0
    sltu t0, s8, t3
    or s8, t0, sp
    add t6, t6, t3
    add t6, t6, s8
    add t6, t6, t0
    add t6, t6, sp
    sub a5, s0, a5
    sltu s0, s0, a5
    sub s0, a5, s2
    sltu s2, a5, s0
    or a5, s2, s0
    add t6, t6, a3
    add t6, t6, a5
    add t6, t6, s2
    add t6, t6, s0
    sub tp, ra, tp
    sltu sp, ra, tp
    sub ra, tp, s9
    sltu s9, tp, ra
    or tp, s9, sp
    add t6, t6, ra
    add t6, t6, tp
    add t6, t6, s9
    add t6, t6, sp
    sub s10, a6, s10
    sltu s11, a6, s10
    sub a6, s10, a4
    sltu a4, s10, a6
    or s10, a4, s11
    add t6, t6, a6
    add t6, t6, s10
    add t6, t6, a4
    add t6, t6, s11
    sub s5, s4, s5
    sltu s11, s4, s5
    sub s4, s5, gp
    sltu gp, s5, s4
    or s5, gp, s11
    add t6, t6, s4
    add t6, t6, s5
    add t6, t6, gp
    add t6, t6, s11
    sub a4, t3, a4
    sltu tp, t3, a4
    sub t3, a4, sp
    sltu sp, a4, t3
    or a4, sp, tp
    add t6, t6, t3
    add t6, t6, a4
    add t6, t6, sp
    add t6, t6, tp
    add t1, t1, a0
    sltu a0, t1, a0
    add t1, t1, a1
    sltu a1, t1, a1
    or a0, a0, a1
    add t6, t6, t1
    add t6, t6, a0
    add t6, t6, a1
    add t6, t6, ra
    sub t5, a4, t5
    sltu s4, a4, t5
    sub a4, t5, t1
    sltu t1, t5, a4
    or t5, t1, s4
    add t6, t6, a4
    add t6, t6, t5
    add t6, t6, t1
    add t6, t6, s4
    sub s8, zero, s8
    sltu s11, zero, s8
    sub zero, s8, t0
    sltu t0, s8, zero
    or s8, t0, s11
    add t6, t6, zero
    add t6, t6, s8
    add t6, t6, t0
    add t6, t6, s11
    sub s6, a6, s6
    sltu t3, a6, s6
    sub a6, s6, s1
    sltu s1, s6, a6
    or s6, s1, t3
    add t6, t6, a6
    add t6, t6, s6
    add t6, t6, s1
    add t6, t6, t3
    add s0, s0, a1
    sltu a1, s0, a1
    add s0, s0, s0
    sltu s0, s0, s0
    or a1, a1, s0
    add t6, t6, s0
    add t6, t6, a1
    add t6, t6, s0
    add t6, t6, s1
    sub a0, t0, a0
    sltu s10, t0, a0
    sub t0, a0, s8
    sltu s8, a0, t0
    or a0, s8, s10
    add t6, t6, t0
    add t6, t6, a0
    add t6, t6, s8
    add t6, t6, s10
    sub s7, a0, s7
    sltu t0, a0, s7
    sub a0, s7, a4
    sltu a4, s7, a0
    or s7, a4, t0
    add t6, t6, a0
    add t6, t6, s7
    add t6, t6, a4
    add t6, t6, t0
    add a5, a5, a5
    sltu a5, a5, a5
    add a5, a5, a0
    sltu a0, a5, a0
    or a5, a5, a0
    add t6, t6, a1
    add t6, t6, a5
    add t6, t6, a0
    add t6, t6, sp
    sub s2, t5, s2
    sltu t2, t5, s2
    sub t5, s2, s2
    sltu s2, s2, t5
    or s2, s2, t2
    add t6, t6, t5
    add t6, t6, a2
    add t6, t6, s2
    add t6, t6, t2
    sub s7, a7, s7
    sltu t5, a7, s7
    sub a7, s7, sp
    sltu sp, s7, a7
    or s7, sp, t5
    add t6, t6, a7
    add t6, t6, s7
    add t6, t6, sp
    add t6, t6, t5
    add a6, a6, s3
    sltu s3, a6, s3
    add a6, a6, a6
    sltu a6, a6, a6
    or s3, s3, a6
    add t6, t6, a6
    add t6, t6, s3
    add t6, t6, a6
    add t6, t6, zero
    add a5, a5, s9
    sltu s9, a5, s9
    add a5, a5, s0
    sltu s0, a5, s0
    or s9, s9, s0
    add t6, t6, a5
    add t6, t6, s9
    add t6, t6, s0
    add t6, t6, s0
    add a0, a0, s4
    sltu s4, a0, s4
    add a0, a0, a2
    sltu a2, a0, a2
    or s4, s4, a2
    add t6, t6, a0
    add t6, t6, s4
    add t6, t6, a2
    add t6, t6, sp
    sub sp, t4, sp
    sltu a6, t4, sp
    sub t4, sp, s10
    sltu s10, sp, t4
    or sp, s10, a6
    add t6, t6, t4
    add t6, t6, sp
    add t6, t6, s10
    add t6, t6, a6
    add s1, s1, s1
    sltu s1, s1, s1
    add s1, s1, s5
    sltu s5, s1, s5
    or s1, s1, s5
    add t6, t6, a1
    add t6, t6, s1
    add t6, t6, s5
    add t6, t6, a1
    add s7, s7, t5
    sltu t5, s7, t5
    add s7, s7, tp
    sltu tp, s7, tp
    or t5, t5, tp
    add t6, t6, s7
    add t6, t6, t5
    add t6, t6, tp
    add t6, t6, a7
    sub a5, a5, a5
    sltu a0, a5, a5
    sub a5, a5, s0
    sltu s0, a5, a5
    or a5, s0, a0
    add t6, t6, a1
    add t6, t6, a5
    add t6, t6, s0
    add t6, t6, a0
    sub a7, tp, a7
    sltu t1, tp, a7
    sub tp, a7, t4
    sltu t4, a7, tp
    or a7, t4, t1
    add t6, t6, tp
    add t6, t6, a7
    add t6, t6, t4
    add t6, t6, t1
    sub s5, s7, s5
    sltu zero, s7, s5
    sub s7, s5, zero
    sltu zero, s5, s7
    or s5, zero, zero
    add t6, t6, s7
    add t6, t6, s5
    add t6, t6, a3
    add t6, t6, zero
    add a0, a0, s6
    sltu s6, a0, s6
    add a0, a0, a7
    sltu a7, a0, a7
    or s6, s6, a7
    add t6, t6, a0
    add t6, t6, s6
    add t6, t6, a7
    add t6, t6, a7
    sub sp, sp, sp
    sltu s9, sp, sp
    sub sp, sp, s10
    sltu s10, sp, sp
    or sp, s10, s9
    add t6, t6, a1
    add t6, t6, sp
    add t6, t6, s10
    add t6, t6, s9
    sub t3, tp, t3
    sltu a1, tp, t3
    sub tp, t3, t5
    sltu t5, t3, tp
    or t3, t5, a1
    add t6, t6, tp
    add t6, t6, t3
    add t6, t6, t5
    add t6, t6, a1
    sub t0, s9, t0
    sltu s5, s9, t0
    sub s9, t0, s7
    sltu s7, t0, s9
    or t0, s7, s5
    add t6, t6, s9
    add t6, t6, t0
    add t6, t6, s7
    add t6, t6, s5
    add a4, a4, a0
    sltu a0, a4, a0
    add a4, a4, ra
    sltu ra, a4, ra
    or a0, a0, ra
    add t6, t6, a4
    add t6, t6, a0
    add t6, t6, ra
    add t6, t6, a0
    sub s7, a6, s7
    sltu s2, a6, s7
    sub a6, s7, ra
    sltu ra, s7, a6
    or s7, ra, s2
    add t6, t6, a6
    add t6, t6, s7
    add t6, t6, ra
    add t6, t6, s2
    sub s7, t2, s7
    sltu t1, t2, s7
    sub t2, s7, a6
    sltu a6, s7, t2
    or s7, a6, t1
    add t6, t6, t2
    add t6, t6, s7
    add t6, t6, a6
    add t6, t6, t1
    add ra, ra, ra
    sltu ra, ra, ra
    add ra, ra, gp
    sltu gp, ra, gp
    or ra, ra, gp
    add t6, t6, a1
    add t6, t6, ra
    add t6, t6, gp
    add t6, t6, t5
    sub ra, s4, ra
    sltu t3, s4, ra
    sub s4, ra, t3
    sltu t3, ra, s4
    or ra, t3, t3
    add t6, t6, s4
    add t6, t6, ra
    add t6, t6, t3
    add t6, t6, t3
    sub a6, a4, a6
    sltu s11, a4, a6
    sub a4, a6, sp
    sltu sp, a6, a4
    or a6, sp, s11
    add t6, t6, a4
    add t6, t6, a6
    add t6, t6, sp
    add t6, t6, s11
    add a7, a7, s9
    sltu s9, a7, s9
    add a7, a7, t3
    sltu t3, a7, t3
    or s9, s9, t3
    add t6, t6, a7
    add t6, t6, s9
    add t6, t6, t3
    add t6, t6, s0
    add s10, s10, s10
    sltu s10, s10, s10
    add s10, s10, ra
    sltu ra, s10, ra
    or s10, s10, ra
    add t6, t6, a1
    add t6, t6, s10
    add t6, t6, ra
    add t6, t6, a3
    sub a5, t4, a5
    sltu s6, t4, a5
    sub t4, a5, s11
    sltu s11, a5, t4
    or a5, s11, s6
    add t6, t6, t4
    add t6, t6, a5
    add t6, t6, s11
    add t6, t6, s6
    add t5, t5, gp
    sltu gp, t5, gp
    add t5, t5, t5
    sltu t5, t5, t5
    or gp, gp, t5
    add t6, t6, t5
    add t6, t6, gp
    add t6, t6, t5
    add t6, t6, ra
    sub t3, t1, t3
    sltu a3, t1, t3
    sub t1, t3, a7
    sltu a7, t3, t1
    or t3, a7, a3
    add t6, t6, t1
    add t6, t6, t3
    add t6, t6, a7
    add t6, t6, a3
    sub s7, ra, s7
    sltu s6, ra, s7
    sub ra, s7, s11
    sltu s11, s7, ra
    or s7, s11, s6
    add t6, t6, ra
    add t6, t6, s7
    add t6, t6, s11
    add t6, t6, s6
    add s5, s5, s5
    sltu s5, s5, s5
    add s5, s5, s1
    sltu s1, s5, s1
    or s5, s5, s1
    add t6, t6, s5
    add t6, t6, s5
    add t6, t6, s1
    add t6, t6, a0
    sub t3, a7, t3
    sltu t5, a7, t3
    sub a7, t3, t5
    sltu t5, t3, a7
    or t3, t5, t5
    add t6, t6, a7
    add t6, t6, t3
    add t6, t6, a3
    add t6, t6, t5
    sub s8, a0, s8
    sltu s5, a0, s8
    sub a0, s8, s4
    sltu s4, s8, a0
    or s8, s4, s5
    add t6, t6, a0
    add t6, t6, s8
    add t6, t6, s4
    add t6, t6, s5
    sub a1, a7, a1
    sltu sp, a7, a1
    sub a7, a1, gp
    sltu gp, a1, a7
    or a1, gp, sp
    add t6, t6, a7
    add t6, t6, a1
    add t6, t6, gp
    add t6, t6, sp
    add a4, a4, t5
    sltu t5, a4, t5
    add a4, a4, s5
    sltu s5, a4, s5
    or t5, t5, s5
    add t6, t6, a4
    add t6, t6, t5
    add t6, t6, s5
    add t6, t6, s6
    sub a7, a7, a7
    sltu sp, a7, a7
    sub a7, a7, zero
    sltu zero, a7, a7
    or a7, zero, sp
    add t6, t6, a7
    add t6, t6, a7
    add t6, t6, zero
    add t6, t6, sp
    sub s7, t5, s7
    sltu a2, t5, s7
    sub t5, s7, a6
    sltu a6, s7, t5
    or s7, a6, a2
    add t6, t6, t5
    add t6, t6, s7
    add t6, t6, a6
    add t6, t6, a2
    add s5, s5, s7
    sltu s7, s5, s7
    add s5, s5, s7
    sltu s7, s5, s7
    or s7, s7, s7
    add t6, t6, s5
    add t6, t6, a2
    add t6, t6, s7
    add t6, t6, a2
    sub a4, s10, a4
    sltu a3, s10, a4
    sub s10, a4, s0
    sltu s0, a4, s10
    or a4, s0, a3
    add t6, t6, s10
    add t6, t6, a4
    add t6, t6, s0
    add t6, t6, a3
    add s5, s5, a7
    sltu a7, s5, a7
    add s5, s5, a1
    sltu a1, s5, a1
    or a7, a7, a1
    add t6, t6, s5
    add t6, t6, a7
    add t6, t6, a3
    add t6, t6, a1
    sub tp, t1, tp
    sltu s5, t1, tp
    sub t1, tp, s6
    sltu s6, tp, t1
    or tp, s6, s5
    add t6, t6, t1
    add t6, t6, tp
    add t6, t6, s6
    add t6, t6, s5
    add s2, s2, s9
    sltu s9, s2, s9
    add s2, s2, tp
    sltu tp, s2, tp
    or s9, s9, tp
    add t6, t6, s2
    add t6, t6, s9
    add t6, t6, tp
    add t6, t6, t2
    sub s0, a5, s0
    sltu a4, a5, s0
    sub a5, s0, sp
    sltu sp, s0, a5
    or s0, sp, a4
    add t6, t6, a5
    add t6, t6, s0
    add t6, t6, sp
    add t6, t6, a4
    add a4, a4, s10
    sltu s10, a4, s10
    add a4, a4, s8
    sltu s8, a4, s8
    or s10, s10, s8
    add t6, t6, a4
    add t6, t6, a3
    add t6, t6, s8
    add t6, t6, s10
    add a5, a5, s7
    sltu s7, a5, s7
    add a5, a5, s5
    sltu s5, a5, s5
    or s7, s7, s5
    add t6, t6, a5
    add t6, t6, s7
    add t6, t6, s5
    add t6, t6, a3
    sub s9, a5, s9
    sltu t4, a5, s9
    sub a5, s9, s2
    sltu s2, s9, a5
    or s9, s2, t4
    add t6, t6, a5
    add t6, t6, s9
    add t6, t6, s2
    add t6, t6, t4
    sub sp, s8, sp
    sltu a6, s8, sp
    sub s8, sp, a5
    sltu a5, sp, s8
    or sp, a5, a6
    add t6, t6, s8
    add t6, t6, sp
    add t6, t6, a5
    add t6, t6, a6
    add s6, s6, a4
    sltu a4, s6, a4
    add s6, s6, a6
    sltu a6, s6, a6
    or a4, a4, a6
    add t6, t6, s6
    add t6, t6, a4
    add t6, t6, a6
    add t6, t6, ra
    sub s9, s8, s9
    sltu a4, s8, s9
    sub s8, s9, s9
    sltu s9, s9, s8
    or s9, s9, a4
    add t6, t6, s8
    add t6, t6, s9
    add t6, t6, s9
    add t6, t6, a4
    sub a0, s4, a0
    sltu s3, s4, a0
    sub s4, a0, s5
    sltu s5, a0, s4
    or a0, s5, s3
    add t6, t6, s4
    add t6, t6, a0
    add t6, t6, s5
    add t6, t6, s3
    sub a1, s0, a1
    sltu s8, s0, a1
    sub s0, a1, s9
    sltu s9, a1, s0
    or a1, s9, s8
    add t6, t6, s0
    add t6, t6, a1
    add t6, t6, s9
    add t6, t6, s8
    sub a1, t0, a1
    sltu ra, t0, a1
    sub t0, a1, tp
    sltu tp, a1, t0
    or a1, tp, ra
    add t6, t6, t0
    add t6, t6, a1
    add t6, t6, tp
    add t6, t6, ra
    add s3, s3, a7
    sltu a7, s3, a7
    add s3, s3, t4
    sltu t4, s3, t4
    or a7, a7, t4
    add t6, t6, s3
    add t6, t6, a7
    add t6, t6, t4
    add t6, t6, sp
    sub t1, tp, t1
    sltu s2, tp, t1
    sub tp, t1, t1
    sltu t1, t1, tp
    or t1, t1, s2
    add t6, t6, tp
    add t6, t6, a2
    add t6, t6, t1
    add t6, t6, s2
    sub a5, ra, a5
    sltu sp, ra, a5
    sub ra, a5, a5
    sltu a5, a5, ra
    or a5, a5, sp
    add t6, t6, ra
    add t6, t6, a5
    add t6, t6, a5
    add t6, t6, sp
    sub s1, a4, s1
    sltu a2, a4, s1
    sub a4, s1, a0
    sltu a0, s1, a4
    or s1, a0, a2
    add t6, t6, a4
    add t6, t6, s1
    add t6, t6, a0
    add t6, t6, a2
    sub s10, s7, s10
    sltu s2, s7, s10
    sub s7, s10, t0
    sltu t0, s10, s7
    or s10, t0, s2
    add t6, t6, s7
    add t6, t6, s10
    add t6, t6, t0
    add t6, t6, s2
    sub s0, t0, s0
    sltu s0, t0, s0
    sub t0, s0, t2
    sltu t2, s0, t0
    or s0, t2, s0
    add t6, t6, t0
    add t6, t6, s0
    add t6, t6, t2
    add t6, t6, s0
    add t2, t2, s6
    sltu s6, t2, s6
    add t2, t2, a6
    sltu a6, t2, a6
    or s6, s6, a6
    add t6, t6, t2
    add t6, t6, s6
    add t6, t6, a6
    add t6, t6, s2
    add gp, gp, s9
    sltu s9, gp, s9
    add gp, gp, t5
    sltu t5, gp, t5
    or s9, s9, t5
    add t6, t6, gp
    add t6, t6, s9
    add t6, t6, t5
    add t6, t6, a6
    sub a1, s11, a1
    sltu t0, s11, a1
    sub s11, a1, s7
    sltu s7, a1, s11
    or a1, s7, t0
    add t6, t6, s11
    add t6, t6, a1
    add t6, t6, s7
    add t6, t6, t0
    sub s2, a0, s2
    sltu gp, a0, s2
    sub a0, s2, a0
    sltu a0, s2, a0
    or s2, a0, gp
    add t6, t6, a2
    add t6, t6, s2
    add t6, t6, a0
    add t6, t6, gp
    sub a0, ra, a0
    sltu a5, ra, a0
    sub ra, a0, t2
    sltu t2, a0, ra
    or a0, t2, a5
    add t6, t6, ra
    add t6, t6, a0
    add t6, t6, t2
    add t6, t6, a5
    add s5, s5, s5
    sltu s5, s5, s5
    add s5, s5, s5
    sltu s5, s5, s5
    or s5, s5, s5
    add t6, t6, a2
    add t6, t6, a2
    add t6, t6, s5
    add t6, t6, s0
    add tp, tp, t4
    sltu t4, tp, t4
    add tp, tp, t5
    sltu t5, tp, t5
    or t4, t4, t5
    add t6, t6, tp
    add t6, t6, t4
    add t6, t6, t5
    add t6, t6, s11
    add ra, ra, tp
    sltu tp, ra, tp
    add ra, ra, tp
    sltu tp, ra, tp
    or tp, tp, tp
    add t6, t6, ra
    add t6, t6, tp
    add t6, t6, tp
    add t6, t6, t5
    sub a6, s0, a6
    sltu a4, s0, a6
    sub s0, a6, s2
    sltu s2, a6, s0
    or a6, s2, a4
    add t6, t6, s0
    add t6, t6, a6
    add t6, t6, s2
    add t6, t6, a4
    sub a7, zero, a7
    sltu a5, zero, a7
    sub zero, a7, s9
    sltu s9, a7, zero
    or a7, s9, a5
    add t6, t6, zero
    add t6, t6, a7
    add t6, t6, s9
    add t6, t6, a5
    add s4, s4, a7
    sltu a7, s4, a7
    add s4, s4, a1
    sltu a1, s4, a1
    or a7, a7, a1
    add t6, t6, s4
    add t6, t6, a7
    add t6, t6, a1
    add t6, t6, t0
    add s3, s3, s1
    sltu s1, s3, s1
    add s3, s3, s6
    sltu s6, s3, s6
    or s1, s1, s6
    add t6, t6, s3
    add t6, t6, s1
    add t6, t6, s6
    add t6, t6, s5
    add s3, s3, s2
    sltu s2, s3, s2
    add s3, s3, s9
    sltu s9, s3, s9
    or s2, s2, s9
    add t6, t6, s3
    add t6, t6, s2
    add t6, t6, s9
    add t6, t6, t1
    sub t0, gp, t0
    sltu gp, gp, t0
    sub gp, t0, a4
    sltu a4, t0, gp
    or t0, a4, gp
    add t6, t6, gp
    add t6, t6, t0
    add t6, t6, a4
    add t6, t6, gp
    add t5, t5, gp
    sltu gp, t5, gp
    add t5, t5, ra
    sltu ra, t5, ra
    or gp, gp, ra
    add t6, t6, t5
    add t6, t6, gp
    add t6, t6, ra
    add t6, t6, t3
    sub s5, t0, s5
    sltu t0, t0, s5
    sub t0, s5, ra
    sltu ra, s5, t0
    or s5, ra, t0
    add t6, t6, a3
    add t6, t6, s5
    add t6, t6, ra
    add t6, t6, t0
    add a7, a7, a1
    sltu a1, a7, a1
    add a7, a7, s3
    sltu s3, a7, s3
    or a1, a1, s3
    add t6, t6, a7
    add t6, t6, a3
    add t6, t6, s3
    add t6, t6, a1
    sub gp, a0, gp
    sltu t2, a0, gp
    sub a0, gp, s4
    sltu s4, gp, a0
    or gp, s4, t2
    add t6, t6, a0
    add t6, t6, gp
    add t6, t6, s4
    add t6, t6, t2
    sub tp, a6, tp
    sltu a3, a6, tp
    sub a6, tp, a4
    sltu a4, tp, a6
    or tp, a4, a3
    add t6, t6, a6
    add t6, t6, tp
    add t6, t6, a4
    add t6, t6, a3
    sub a6, s11, a6
    sltu s11, s11, a6
    sub s11, a6, s10
    sltu s10, a6, s11
    or a6, s10, s11
    add t6, t6, a3
    add t6, t6, a6
    add t6, t6, s10
    add t6, t6, s11
    sub a1, t1, a1
    sltu s2, t1, a1
    sub t1, a1, sp
    sltu sp, a1, t1
    or a1, sp, s2
    add t6, t6, t1
    add t6, t6, a1
    add t6, t6, sp
    add t6, t6, s2
    add s2, s2, s1
    sltu s1, s2, s1
    add s2, s2, a2
    sltu a2, s2, a2
    or s1, s1, a2
    add t6, t6, a3
    add t6, t6, s1
    add t6, t6, a2
    add t6, t6, s2
    sub s10, tp, s10
    sltu a3, tp, s10
    sub tp, s10, s7
    sltu s7, s10, tp
    or s10, s7, a3
    add t6, t6, tp
    add t6, t6, s10
    add t6, t6, s7
    add t6, t6, a3
    sub s11, a7, s11
    sltu gp, a7, s11
    sub a7, s11, s3
    sltu s3, s11, a7
    or s11, s3, gp
    add t6, t6, a7
    add t6, t6, s11
    add t6, t6, s3
    add t6, t6, gp
    add t2, t2, zero
    sltu zero, t2, zero
    add t2, t2, t4
    sltu t4, t2, t4
    or zero, zero, t4
    add t6, t6, t2
    add t6, t6, zero
    add t6, t6, t4
    add t6, t6, s2
    add s0, s0, gp
    sltu gp, s0, gp
    add s0, s0, s0
    sltu s0, s0, s0
    or gp, gp, s0
    add t6, t6, a3
    add t6, t6, gp
    add t6, t6, a3
    add t6, t6, s0
    add s9, s9, s1
    sltu s1, s9, s1
    add s9, s9, t1
    sltu t1, s9, t1
    or s1, s1, t1
    add t6, t6, s9
    add t6, t6, s1
    add t6, t6, t1
    add t6, t6, s1
    sub t3, s6, t3
    sltu t3, s6, t3
    sub s6, t3, sp
    sltu sp, t3, s6
    or t3, sp, t3
    add t6, t6, s6
    add t6, t6, t3
    add t6, t6, sp
    add t6, t6, t3
    sub s4, t5, s4
    sltu s6, t5, s4
    sub t5, s4, s7
    sltu s7, s4, t5
    or s4, s7, s6
    add t6, t6, t5
    add t6, t6, s4
    add t6, t6, s7
    add t6, t6, s6
    add a3, a3, t1
    sltu t1, a3, t1
    add a3, a3, a6
    sltu a6, a3, a6
    or t1, t1, a6
    add t6, t6, a3
    add t6, t6, t1
    add t6, t6, a6
    add t6, t6, a3
    add sp, sp, a4
    sltu a4, sp, a4
    add sp, sp, t1
    sltu t1, sp, t1
    or a4, a4, t1
    add t6, t6, sp
    add t6, t6, a4
    add t6, t6, t1
    add t6, t6, s7
    sub s8, ra, s8
    sltu tp, ra, s8
    sub ra, s8, t4
    sltu t4, s8, ra
    or s8, t4, tp
    add t6, t6, ra
    add t6, t6, s8
    add t6, t6, t4
    add t6, t6, tp
    add s7, s7, s11
    sltu s11, s7, s11
    add s7, s7, s11
    sltu s11, s7, s11
    or s11, s11, s11
    add t6, t6, s7
    add t6, t6, s11
    add t6, t6, s11
    add t6, t6, a0
    sub a1, s3, a1
    sltu a0, s3, a1
    sub s3, a1, s5
    sltu s5, a1, s3
    or a1, s5, a0
    add t6, t6, s3
    add t6, t6, a1
    add t6, t6, s5
    add t6, t6, a0
    sub a7, s3, a7
    sltu s5, s3, a7
    sub s3, a7, a7
    sltu a7, a7, s3
    or a7, a7, s5
    add t6, t6, s3
    add t6, t6, a7
    add t6, t6, a7
    add t6, t6, s5
    add t0, t0, a7
    sltu a7, t0, a7
    add t0, t0, s9
    sltu s9, t0, s9
    or a7, a7, s9
    add t6, t6, t0
    add t6, t6, a3
    add t6, t6, s9
    add t6, t6, a7
    sub a1, tp, a1
    sltu s0, tp, a1
    sub tp, a1, s8
    sltu s8, a1, tp
    or a1, s8, s0
    add t6, t6, tp
    add t6, t6, a1
    add t6, t6, s8
    add t6, t6, s0
    sub s1, zero, s1
    sltu zero, zero, s1
    sub zero, s1, s4
    sltu s4, s1, zero
    or s1, s4, zero
    add t6, t6, zero
    add t6, t6, s1
    add t6, t6, s4
    add t6, t6, zero
    add s3, s3, t4
    sltu t4, s3, t4
    add s3, s3, ra
    sltu ra, s3, ra
    or t4, t4, ra
    add t6, t6, s3
    add t6, t6, t4
    add t6, t6, ra
    add t6, t6, t0
    add a4, a4, t5
    sltu t5, a4, t5
    add a4, a4, zero
    sltu zero, a4, zero
    or t5, t5, zero
    add t6, t6, a4
    add t6, t6, t5
    add t6, t6, zero
    add t6, t6, ra
    sub s6, s2, s6
    sltu t2, s2, s6
    sub s2, s6, s1
    sltu s1, s6, s2
    or s6, s1, t2
    add t6, t6, s2
    add t6, t6, s6
    add t6, t6, s1
    add t6, t6, t2
    sub a7, zero, a7
    sltu s9, zero, a7
    sub zero, a7, s11
    sltu s11, a7, zero
    or a7, s11, s9
    add t6, t6, zero
    add t6, t6, a7
    add t6, t6, s11
    add t6, t6, s9
    add sp, sp, s7
    sltu s7, sp, s7
    add sp, sp, t0
    sltu t0, sp, t0
    or s7, s7, t0
    add t6, t6, sp
    add t6, t6, s7
    add t6, t6, t0
    add t6, t6, tp
    sub t1, s4, t1
    sltu s10, s4, t1
    sub s4, t1, a5
    sltu a5, t1, s4
    or t1, a5, s10
    add t6, t6, s4
    add t6, t6, t1
    add t6, t6, a5
    add t6, t6, s10
    add t3, t3, a4
    sltu a4, t3, a4
    add t3, t3, t3
    sltu t3, t3, t3
    or a4, a4, t3
    add t6, t6, a2
    add t6, t6, a4
    add t6, t6, t3
    add t6, t6, s4
    add s11, s11, t0
    sltu t0, s11, t0
    add s11, s11, gp
    sltu gp, s11, gp
    or t0, t0, gp
    add t6, t6, s11
    add t6, t6, t0
    add t6, t6, gp
    add t6, t6, s0
    add s1, s1, s10
    sltu s10, s1, s10
    add s1, s1, s6
    sltu s6, s1, s6
    or s10, s10, s6
    add t6, t6, s1
    add t6, t6, s10
    add t6, t6, s6
    add t6, t6, s4
    add a7, a7, t2
    sltu t2, a7, t2
    add a7, a7, zero
    sltu zero, a7, zero
    or t2, t2, zero
    add t6, t6, a7
    add t6, t6, t2
    add t6, t6, zero
    add t6, t6, ra
    sub s11, a6, s11
    sltu zero, a6, s11
    sub a6, s11, a0
    sltu a0, s11, a6
    or s11, a0, zero
    add t6, t6, a6
    add t6, t6, s11
    add t6, t6, a0
    add t6, t6, zero
    add s2, s2, tp
    sltu tp, s2, tp
    add s2, s2, s10
    sltu s10, s2, s10
    or tp, tp, s10
    add t6, t6, s2
    add t6, t6, tp
    add t6, t6, s10
    add t6, t6, s1
    add s6, s6, t3
    sltu t3, s6, t3
    add s6, s6, sp
    sltu sp, s6, sp
    or t3, t3, sp
    add t6, t6, s6
    add t6, t6, t3
    add t6, t6, sp
    add t6, t6, ra
    add s10, s10, s2
    sltu s2, s10, s2
    add s10, s10, t5
    sltu t5, s10, t5
    or s2, s2, t5
    add t6, t6, s10
    add t6, t6, s2
    add t6, t6, t5
    add t6, t6, a5
    sub a1, t2, a1
    sltu t0, t2, a1
    sub t2, a1, a6
    sltu a6, a1, t2
    or a1, a6, t0
    add t6, t6, t2
    add t6, t6, a1
    add t6, t6, a6
    add t6, t6, t0
    sub t3, s6, t3
    sltu t4, s6, t3
    sub s6, t3, a4
    sltu a4, t3, s6
    or t3, a4, t4
    add t6, t6, s6
    add t6, t6, t3
    add t6, t6, a4
    add t6, t6, t4
    add t2, t2, a7
    sltu a7, t2, a7
    add t2, t2, s0
    sltu s0, t2, s0
    or a7, a7, s0
    add t6, t6, t2
    add t6, t6, a7
    add t6, t6, s0
    add t6, t6, s7
    add s10, s10, a0
    sltu a0, s10, a0
    add s10, s10, t5
    sltu t5, s10, t5
    or a0, a0, t5
    add t6, t6, s10
    add t6, t6, a0
    add t6, t6, t5
    add t6, t6, t4
    add s11, s11, s0
    sltu s0, s11, s0
    add s11, s11, s1
    sltu s1, s11, s1
    or s0, s0, s1
    add t6, t6, s11
    add t6, t6, s0
    add t6, t6, s1
    add t6, t6, t2
    add s3, s3, a7
    sltu a7, s3, a7
    add s3, s3, zero
    sltu zero, s3, zero
    or a7, a7, zero
    add t6, t6, s3
    add t6, t6, a7
    add t6, t6, zero
    add t6, t6, ra
    add s5, s5, t4
    sltu t4, s5, t4
    add s5, s5, s6
    sltu s6, s5, s6
    or t4, t4, s6
    add t6, t6, a3
    add t6, t6, t4
    add t6, t6, s6
    add t6, t6, s5
    sub s10, tp, s10
    sltu t5, tp, s10
    sub tp, s10, t5
    sltu t5, s10, tp
    or s10, t5, t5
    add t6, t6, tp
    add t6, t6, s10
    add t6, t6, a3
    add t6, t6, t5
    add s4, s4, s8
    sltu s8, s4, s8
    add s4, s4, s8
    sltu s8, s4, s8
    or s8, s8, s8
    add t6, t6, s4
    add t6, t6, a2
    add t6, t6, s8
    add t6, t6, tp
    sub s1, s8, s1
    sltu s8, s8, s1
    sub s8, s1, a2
    sltu a2, s1, s8
    or s1, a2, s8
    add t6, t6, a3
    add t6, t6, s1
    add t6, t6, a2
    add t6, t6, s8
    add tp, tp, t5
    sltu t5, tp, t5
    add tp, tp, a0
    sltu a0, tp, a0
    or t5, t5, a0
    add t6, t6, tp
    add t6, t6, t5
    add t6, t6, a0
    add t6, t6, ra
    sub a0, a0, a0
    sltu s4, a0, a0
    sub a0, a0, a5
    sltu a5, a0, a0
    or a0, a5, s4
    add t6, t6, a0
    add t6, t6, a0
    add t6, t6, a5
    add t6, t6, s4
    add s10, s10, zero
    sltu zero, s10, zero
    add s10, s10, ra
    sltu ra, s10, ra
    or zero, zero, ra
    add t6, t6, s10
    add t6, t6, zero
    add t6, t6, ra
    add t6, t6, a2
    add s1, s1, s4
    sltu s4, s1, s4
    add s1, s1, t2
    sltu t2, s1, t2
    or s4, s4, t2
    add t6, t6, s1
    add t6, t6, s4
    add t6, t6, t2
    add t6, t6, a2
    sub a7, a4, a7
    sltu t4, a4, a7
    sub a4, a7, a6
    sltu a6, a7, a4
    or a7, a6, t4
    add t6, t6, a4
    add t6, t6, a7
    add t6, t6, a6
    add t6, t6, t4
    sub s6, a0, s6
    sltu a5, a0, s6
    sub a0, s6, s6
    sltu s6, s6, a0
    or s6, s6, a5
    add t6, t6, a0
    add t6, t6, s6
    add t6, t6, s6
    add t6, t6, a5
    add s1, s1, t4
    sltu t4, s1, t4
    add s1, s1, s2
    sltu s2, s1, s2
    or t4, t4, s2
    add t6, t6, s1
    add t6, t6, t4
    add t6, t6, s2
    add t6, t6, tp
    sub t5, zero, t5
    sltu a4, zero, t5
    sub zero, t5, zero
    sltu zero, t5, zero
    or t5, zero, a4
    add t6, t6, a2
    add t6, t6, t5
    add t6, t6, zero
    add t6, t6, a4
    sub a4, t1, a4
    sltu t1, t1, a4
    sub t1, a4, ra
    sltu ra, a4, t1
    or a4, ra, t1
    add t6, t6, t1
    add t6, t6, a4
    add t6, t6, ra
    add t6, t6, t1
    sub a0, t4, a0
    sltu a6, t4, a0
    sub t4, a0, s3
    sltu s3, a0, t4
    or a0, s3, a6
    add t6, t6, t4
    add t6, t6, a0
    add t6, t6, s3
    add t6, t6, a6
    add t0, t0, s2
    sltu s2, t0, s2
    add t0, t0, t1
    sltu t1, t0, t1
    or s2, s2, t1
    add t6, t6, t0
    add t6, t6, s2
    add t6, t6, t1
    add t6, t6, zero
    sub s2, a7, s2
    sltu a7, a7, s2
    sub a7, s2, a7
    sltu a7, s2, a7
    or s2, a7, a7
    add t6, t6, a2
    add t6, t6, s2
    add t6, t6, a3
    add t6, t6, a7
    sub s0, a0, s0
    sltu s10, a0, s0
    sub a0, s0, t5
    sltu t5, s0, a0
    or s0, t5, s10
    add t6, t6, a0
    add t6, t6, s0
    add t6, t6, t5
    add t6, t6, s10
    add t1, t1, tp
    sltu tp, t1, tp
    add t1, t1, s1
    sltu s1, t1, s1
    or tp, tp, s1
    add t6, t6, t1
    add t6, t6, tp
    add t6, t6, s1
    add t6, t6, a2
    sub t0, sp, t0
    sltu tp, sp, t0
    sub sp, t0, a7
    sltu a7, t0, sp
    or t0, a7, tp
    add t6, t6, sp
    add t6, t6, t0
    add t6, t6, a7
    add t6, t6, tp
    sub t1, a4, t1
    sltu t1, a4, t1
    sub a4, t1, a4
    sltu a4, t1, a4
    or t1, a4, t1
    add t6, t6, a4
    add t6, t6, t1
    add t6, t6, a4
    add t6, t6, t1
    sub s7, s10, s7
    sltu s5, s10, s7
    sub s10, s7, a1
    sltu a1, s7, s10
    or s7, a1, s5
    add t6, t6, s10
    add t6, t6, s7
    add t6, t6, a1
    add t6, t6, s5
    sub s7, s9, s7
    sltu ra, s9, s7
    sub s9, s7, s8
    sltu s8, s7, s9
    or s7, s8, ra
    add t6, t6, s9
    add t6, t6, s7
    add t6, t6, s8
    add t6, t6, ra
    sub s7, t4, s7
    sltu a0, t4, s7
    sub t4, s7, a4
    sltu a4, s7, t4
    or s7, a4, a0
    add t6, t6, t4
    add t6, t6, s7
    add t6, t6, a4
    add t6, t6, a0
    sub s1, a6, s1
    sltu a5, a6, s1
    sub a6, s1, a5
    sltu a5, s1, a6
    or s1, a5, a5
    add t6, t6, a6
    add t6, t6, s1
    add t6, t6, a5
    add t6, t6, a5
    add t0, t0, s8
    sltu s8, t0, s8
    add t0, t0, a5
    sltu a5, t0, a5
    or s8, s8, a5
    add t6, t6, t0
    add t6, t6, s8
    add t6, t6, a5
    add t6, t6, a6
    add t1, t1, t1
    sltu t1, t1, t1
    add t1, t1, s9
    sltu s9, t1, s9
    or t1, t1, s9
    add t6, t6, a1
    add t6, t6, t1
    add t6, t6, s9
    add t6, t6, a5
    add tp, tp, a5
    sltu a5, tp, a5
    add tp, tp, zero
    sltu zero, tp, zero
    or a5, a5, zero
    add t6, t6, a3
    add t6, t6, a5
    add t6, t6, zero
    add t6, t6, tp
    sub a5, t1, a5
    sltu a0, t1, a5
    sub t1, a5, a5
    sltu a5, a5, t1
    or a5, a5, a0
    add t6, t6, t1
    add t6, t6, a2
    add t6, t6, a5
    add t6, t6, a0
    sub s2, s8, s2
    sltu a7, s8, s2
    sub s8, s2, zero
    sltu zero, s2, s8
    or s2, zero, a7
    add t6, t6, s8
    add t6, t6, s2
    add t6, t6, zero
    add t6, t6, a7
    sub s0, s6, s0
    sltu s1, s6, s0
    sub s6, s0, t5
    sltu t5, s0, s6
    or s0, t5, s1
    add t6, t6, s6
    add t6, t6, s0
    add t6, t6, t5
    add t6, t6, s1
    sub s7, s1, s7
    sltu a4, s1, s7
    sub s1, s7, sp
    sltu sp, s7, s1
    or s7, sp, a4
    add t6, t6, s1
    add t6, t6, s7
    add t6, t6, sp
    add t6, t6, a4
    add s9, s9, s3
    sltu s3, s9, s3
    add s9, s9, s9
    sltu s9, s9, s9
    or s3, s3, s9
    add t6, t6, a2
    add t6, t6, s3
    add t6, t6, s9
    add t6, t6, a0
    add s2, s2, gp
    sltu gp, s2, gp
    add s2, s2, s7
    sltu s7, s2, s7
    or gp, gp, s7
    add t6, t6, s2
    add t6, t6, gp
    add t6, t6, s7
    add t6, t6, s7
    sub s1, t5, s1
    sltu a1, t5, s1
    sub t5, s1, s8
    sltu s8, s1, t5
    or s1, s8, a1
    add t6, t6, t5
    add t6, t6, s1
    add t6, t6, s8
    add t6, t6, a1
    sub s1, s4, s1
    sltu t1, s4, s1
    sub s4, s1, s10
    sltu s10, s1, s4
    or s1, s10, t1
    add t6, t6, s4
    add t6, t6, s1
    add t6, t6, s10
    add t6, t6, t1
    sub sp, s7, sp
    sltu s3, s7, sp
    sub s7, sp, s1
    sltu s1, sp, s7
    or sp, s1, s3
    add t6, t6, s7
    add t6, t6, sp
    add t6, t6, s1
    add t6, t6, s3
    add tp, tp, zero
    sltu zero, tp, zero
    add tp, tp, zero
    sltu zero, tp, zero
    or zero, zero, zero
    add t6, t6, tp
    add t6, t6, zero
    add t6, t6, zero
    add t6, t6, a7
    add a4, a4, s0
    sltu s0, a4, s0
    add a4, a4, s3
    sltu s3, a4, s3
    or s0, s0, s3
    add t6, t6, a4
    add t6, t6, s0
    add t6, t6, s3
    add t6, t6, a2
    add s7, s7, ra
    sltu ra, s7, ra
    add s7, s7, t0
    sltu t0, s7, t0
    or ra, ra, t0
    add t6, t6, s7
    add t6, t6, ra
    add t6, t6, t0
    add t6, t6, s11
    sub s4, s2, s4
    sltu sp, s2, s4
    sub s2, s4, a6
    sltu a6, s4, s2
    or s4, a6, sp
    add t6, t6, s2
    add t6, t6, s4
    add t6, t6, a6
    add t6, t6, sp
    sub gp, s4, gp
    sltu s4, s4, gp
    sub s4, gp, s10
    sltu s10, gp, s4
    or gp, s10, s4
    add t6, t6, a3
    add t6, t6, gp
    add t6, t6, s10
    add t6, t6, s4
    add s8, s8, s11
    sltu s11, s8, s11
    add s8, s8, s9
    sltu s9, s8, s9
    or s11, s11, s9
    add t6, t6, s8
    add t6, t6, s11
    add t6, t6, s9
    add t6, t6, a6
    add a5, a5, a5
    sltu a5, a5, a5
    add a5, a5, s3
    sltu s3, a5, s3
    or a5, a5, s3
    add t6, t6, a1
    add t6, t6, a5
    add t6, t6, s3
    add t6, t6, s7
    sub s11, s11, s11
    sltu s6, s11, s11
    sub s11, s11, a7
    sltu a7, s11, s11
    or s11, a7, s6
    add t6, t6, a1
    add t6, t6, s11
    add t6, t6, a7
    add t6, t6, s6
    sub s6, tp, s6
    sltu s4, tp, s6
    sub tp, s6, tp
    sltu tp, s6, tp
    or s6, tp, s4
    add t6, t6, a2
    add t6, t6, s6
    add t6, t6, tp
    add t6, t6, s4
    add t3, t3, t1
    sltu t1, t3, t1
    add t3, t3, s7
    sltu s7, t3, s7
    or t1, t1, s7
    add t6, t6, t3
    add t6, t6, t1
    add t6, t6, s7
    add t6, t6, t2
    sub t2, s11, t2
    sltu s11, s11, t2
    sub s11, t2, zero
    sltu zero, t2, s11
    or t2, zero, s11
    add t6, t6, a3
    add t6, t6, t2
    add t6, t6, zero
    add t6, t6, s11
    sub a7, t4, a7
    sltu s7, t4, a7
    sub t4, a7, a7
    sltu a7, a7, t4
    or a7, a7, s7
    add t6, t6, t4
    add t6, t6, a7
    add t6, t6, a7
    add t6, t6, s7
    sub s0, s2, s0
    sltu t3, s2, s0
    sub s2, s0, s7
    sltu s7, s0, s2
    or s0, s7, t3
    add t6, t6, s2
    add t6, t6, s0
    add t6, t6, s7
    add t6, t6, t3
    sub zero, zero, zero
    sltu sp, zero, zero
    sub zero, zero, s11
    sltu s11, zero, zero
    or zero, s11, sp
    add t6, t6, zero
    add t6, t6, zero
    add t6, t6, s11
    add t6, t6, sp
    sub a7, tp, a7
    sltu s1, tp, a7
    sub tp, a7, t0
    sltu t0, a7, tp
    or a7, t0, s1
    add t6, t6, tp
    add t6, t6, a7
    add t6, t6, t0
    add t6, t6, s1
    add ra, ra, a5
    sltu a5, ra, a5
    add ra, ra, s11
    sltu s11, ra, s11
    or a5, a5, s11
    add t6, t6, ra
    add t6, t6, a5
    add t6, t6, s11
    add t6, t6, t5
    add zero, zero, a4
    sltu a4, zero, a4
    add zero, zero, t2
    sltu t2, zero, t2
    or a4, a4, t2
    add t6, t6, zero
    add t6, t6, a4
    add t6, t6, t2
    add t6, t6, s0
    sub gp, s10, gp
    sltu s0, s10, gp
    sub s10, gp, s0
    sltu s0, gp, s10
    or gp, s0, s0
    add t6, t6, s10
    add t6, t6, gp
    add t6, t6, a3
    add t6, t6, s0
    sub s8, t1, s8
    sltu s0, t1, s8
    sub t1, s8, s5
    sltu s5, s8, t1
    or s8, s5, s0
    add t6, t6, t1
    add t6, t6, s8
    add t6, t6, s5
    add t6, t6, s0
    sub a0, t0, a0
    sltu a0, t0, a0
    sub t0, a0, a0
    sltu a0, a0, t0
    or a0, a0, a0
    add t6, t6, t0
    add t6, t6, a0
    add t6, t6, a0
    add t6, t6, a0
    add t4, t4, a5
    sltu a5, t4, a5
    add t4, t4, a1
    sltu a1, t4, a1
    or a5, a5, a1
    add t6, t6, t4
    add t6, t6, a5
    add t6, t6, a1
    add t6, t6, ra
    sub s4, a6, s4
    sltu s10, a6, s4
    sub a6, s4, a6
    sltu a6, s4, a6
    or s4, a6, s10
    add t6, t6, a6
    add t6, t6, s4
    add t6, t6, a6
    add t6, t6, s10
    sub a6, s1, a6
    sltu s3, s1, a6
    sub s1, a6, ra
    sltu ra, a6, s1
    or a6, ra, s3
    add t6, t6, s1
    add t6, t6, a6
    add t6, t6, ra
    add t6, t6, s3
    sub t5, ra, t5
    sltu a4, ra, t5
    sub ra, t5, zero
    sltu zero, t5, ra
    or t5, zero, a4
    add t6, t6, ra
    add t6, t6, t5
    add t6, t6, zero
    add t6, t6, a4
    sub s9, zero, s9
    sltu a0, zero, s9
    sub zero, s9, a0
    sltu a0, s9, zero
    or s9, a0, a0
    add t6, t6, zero
    add t6, t6, s9
    add t6, t6, a3
    add t6, t6, a0
    sub t0, a4, t0
    sltu s8, a4, t0
    sub a4, t0, zero
    sltu zero, t0, a4
    or t0, zero, s8
    add t6, t6, a4
    add t6, t6, t0
    add t6, t6, zero
    add t6, t6, s8
    add s4, s4, a7
    sltu a7, s4, a7
    add s4, s4, t4
    sltu t4, s4, t4
    or a7, a7, t4
    add t6, t6, s4
    add t6, t6, a7
    add t6, t6, t4
    add t6, t6, s2
    add zero, zero, s0
    sltu s0, zero, s0
    add zero, zero, zero
    sltu zero, zero, zero
    or s0, s0, zero
    add t6, t6, a2
    add t6, t6, s0
    add t6, t6, zero
    add t6, t6, ra
    add s4, s4, t0
    sltu t0, s4, t0
    add s4, s4, a0
    sltu a0, s4, a0
    or t0, t0, a0
    add t6, t6, s4
    add t6, t6, t0
    add t6, t6, a0
    add t6, t6, a1
    sub t3, gp, t3
    sltu a0, gp, t3
    sub gp, t3, t1
    sltu t1, t3, gp
    or t3, t1, a0
    add t6, t6, gp
    add t6, t6, t3
    add t6, t6, t1
    add t6, t6, a0
    add s0, s0, tp
    sltu tp, s0, tp
    add s0, s0, s11
    sltu s11, s0, s11
    or tp, tp, s11
    add t6, t6, s0
    add t6, t6, tp
    add t6, t6, s11
    add t6, t6, s0
    add a5, a5, s7
    sltu s7, a5, s7
    add a5, a5, s0
    sltu s0, a5, s0
    or s7, s7, s0
    add t6, t6, a5
    add t6, t6, s7
    add t6, t6, s0
    add t6, t6, t4
    sub a5, s0, a5
    sltu zero, s0, a5
    sub s0, a5, t5
    sltu t5, a5, s0
    or a5, t5, zero
    add t6, t6, s0
    add t6, t6, a5
    add t6, t6, t5
    add t6, t6, zero
    add t1, t1, s6
    sltu s6, t1, s6
    add t1, t1, s8
    sltu s8, t1, s8
    or s6, s6, s8
    add t6, t6, t1
    add t6, t6, s6
    add t6, t6, s8
    add t6, t6, s10
    add a7, a7, t2
    sltu t2, a7, t2
    add a7, a7, a0
    sltu a0, a7, a0
    or t2, t2, a0
    add t6, t6, a7
    add t6, t6, t2
    add t6, t6, a0
    add t6, t6, zero
    sub s2, gp, s2
    sltu t5, gp, s2
    sub gp, s2, s4
    sltu s4, s2, gp
    or s2, s4, t5
    add t6, t6, gp
    add t6, t6, s2
    add t6, t6, s4
    add t6, t6, t5
    sub s10, s1, s10
    sltu t3, s1, s10
    sub s1, s10, s9
    sltu s9, s10, s1
    or s10, s9, t3
    add t6, t6, s1
    add t6, t6, s10
    add t6, t6, s9
    add t6, t6, t3
    sub t5, zero, t5
    sltu s8, zero, t5
    sub zero, t5, s8
    sltu s8, t5, zero
    or t5, s8, s8
    add t6, t6, zero
    add t6, t6, t5
    add t6, t6, a3
    add t6, t6, s8
    sub sp, a4, sp
    sltu t0, a4, sp
    sub a4, sp, s10
    sltu s10, sp, a4
    or sp, s10, t0
    add t6, t6, a4
    add t6, t6, sp
    add t6, t6, s10
    add t6, t6, t0
    sub gp, s10, gp
    sltu a0, s10, gp
    sub s10, gp, a2
    sltu a2, gp, s10
    or gp, a2, a0
    add t6, t6, s10
    add t6, t6, gp
    add t6, t6, a2
    add t6, t6, a0
    add a0, a0, s1
    sltu s1, a0, s1
    add a0, a0, a2
    sltu a2, a0, a2
    or s1, s1, a2
    add t6, t6, a0
    add t6, t6, s1
    add t6, t6, a2
    add t6, t6, t0
    add s5, s5, s5
    sltu s5, s5, s5
    add s5, s5, a6
    sltu a6, s5, a6
    or s5, s5, a6
    add t6, t6, s5
    add t6, t6, s5
    add t6, t6, a6
    add t6, t6, zero
    add sp, sp, s4
    sltu s4, sp, s4
    add sp, sp, s10
    sltu s10, sp, s10
    or s4, s4, s10
    add t6, t6, a3
    add t6, t6, s4
    add t6, t6, s10
    add t6, t6, sp
    add s11, s11, zero
    sltu zero, s11, zero
    add s11, s11, t5
    sltu t5, s11, t5
    or zero, zero, t5
    add t6, t6, s11
    add t6, t6, zero
    add t6, t6, t5
    add t6, t6, s6
    add a6, a6, a7
    sltu a7, a6, a7
    add a6, a6, t2
    sltu t2, a6, t2
    or a7, a7, t2
    add t6, t6, a6
    add t6, t6, a7
    add t6, t6, t2
    add t6, t6, t5
    sub t2, s7, t2
    sltu t2, s7, t2
    sub s7, t2, s8
    sltu s8, t2, s7
    or t2, s8, t2
    add t6, t6, s7
    add t6, t6, t2
    add t6, t6, s8
    add t6, t6, t2
    add a5, a5, s7
    sltu s7, a5, s7
    add a5, a5, s4
    sltu s4, a5, s4
    or s7, s7, s4
    add t6, t6, a5
    add t6, t6, s7
    add t6, t6, s4
    add t6, t6, a2
    sub s9, a7, s9
    sltu t4, a7, s9
    sub a7, s9, t5
    sltu t5, s9, a7
    or s9, t5, t4
    add t6, t6, a7
    add t6, t6, s9
    add t6, t6, t5
    add t6, t6, t4
    add s4, s4, ra
    sltu ra, s4, ra
    add s4, s4, s6
    sltu s6, s4, s6
    or ra, ra, s6
    add t6, t6, s4
    add t6, t6, ra
    add t6, t6, s6
    add t6, t6, t1
    sub s4, ra, s4
    sltu s3, ra, s4
    sub ra, s4, t0
    sltu t0, s4, ra
    or s4, t0, s3
    add t6, t6, ra
    add t6, t6, s4
    add t6, t6, t0
    add t6, t6, s3
    add s2, s2, tp
    sltu tp, s2, tp
    add s2, s2, t1
    sltu t1, s2, t1
    or tp, tp, t1
    add t6, t6, s2
    add t6, t6, tp
    add t6, t6, t1
    add t6, t6, a1
    sub s0, a5, s0
    sltu t3, a5, s0
    sub a5, s0, s2
    sltu s2, s0, a5
    or s0, s2, t3
    add t6, t6, a5
    add t6, t6, s0
    add t6, t6, s2
    add t6, t6, t3
    sub s5, ra, s5
    sltu s11, ra, s5
    sub ra, s5, s3
    sltu s3, s5, ra
    or s5, s3, s11
    add t6, t6, ra
    add t6, t6, s5
    add t6, t6, s3
    add t6, t6, s11
    add t5, t5, a7
    sltu a7, t5, a7
    add t5, t5, s2
    sltu s2, t5, s2
    or a7, a7, s2
    add t6, t6, t5
    add t6, t6, a7
    add t6, t6, s2
    add t6, t6, a6
    sub s7, s10, s7
    sltu s8, s10, s7
    sub s10, s7, sp
    sltu sp, s7, s10
    or s7, sp, s8
    add t6, t6, s10
    add t6, t6, s7
    add t6, t6, sp
    add t6, t6, s8
    add gp, gp, ra
    sltu ra, gp, ra
    add gp, gp, s2
    sltu s2, gp, s2
    or ra, ra, s2
    add t6, t6, gp
    add t6, t6, ra
    add t6, t6, s2
    add t6, t6, zero
    sub a7, a0, a7
    sltu a6, a0, a7
    sub a0, a7, a6
    sltu a6, a7, a0
    or a7, a6, a6
    add t6, t6, a0
    add t6, t6, a7
    add t6, t6, a6
    add t6, t6, a6
    sub a4, s4, a4
    sltu s10, s4, a4
    sub s4, a4, s2
    sltu s2, a4, s4
    or a4, s2, s10
    add t6, t6, s4
    add t6, t6, a4
    add t6, t6, s2
    add t6, t6, s10
    add s2, s2, t4
    sltu t4, s2, t4
    add s2, s2, a2
    sltu a2, s2, a2
    or t4, t4, a2
    add t6, t6, s2
    add t6, t6, t4
    add t6, t6, a2
    add t6, t6, s4
    add s3, s3, s8
    sltu s8, s3, s8
    add s3, s3, a0
    sltu a0, s3, a0
    or s8, s8, a0
    add t6, t6, s3
    add t6, t6, s8
    add t6, t6, a0
    add t6, t6, t1
    add a7, a7, a4
    sltu a4, a7, a4
    add a7, a7, s2
    sltu s2, a7, s2
    or a4, a4, s2
    add t6, t6, a7
    add t6, t6, a4
    add t6, t6, s2
    add t6, t6, zero
    sub s8, a5, s8
    sltu a6, a5, s8
    sub a5, s8, ra
    sltu ra, s8, a5
    or s8, ra, a6
    add t6, t6, a5
    add t6, t6, s8
    add t6, t6, ra
    add t6, t6, a6
    sub s2, s1, s2
    sltu t3, s1, s2
    sub s1, s2, s8
    sltu s8, s2, s1
    or s2, s8, t3
    add t6, t6, s1
    add t6, t6, s2
    add t6, t6, s8
    add t6, t6, t3
    add t3, t3, a4
    sltu a4, t3, a4
    add t3, t3, sp
    sltu sp, t3, sp
    or a4, a4, sp
    add t6, t6, t3
    add t6, t6, a4
    add t6, t6, sp
    add t6, t6, a6
    add s8, s8, s8
    sltu s8, s8, s8
    add s8, s8, s3
    sltu s3, s8, s3
    or s8, s8, s3
    add t6, t6, s8
    add t6, t6, a3
    add t6, t6, s3
    add t6, t6, s8
    sub a7, gp, a7
    sltu a2, gp, a7
    sub gp, a7, a2
    sltu a2, a7, gp
    or a7, a2, a2
    add t6, t6, gp
    add t6, t6, a7
    add t6, t6, a2
    add t6, t6, a2
    add gp, gp, s0
    sltu s0, gp, s0
    add gp, gp, s8
    sltu s8, gp, s8
    or s0, s0, s8
    add t6, t6, gp
    add t6, t6, s0
    add t6, t6, s8
    add t6, t6, a2
    add s3, s3, s3
    sltu s3, s3, s3
    add s3, s3, s9
    sltu s9, s3, s9
    or s3, s3, s9
    add t6, t6, s3
    add t6, t6, s3
    add t6, t6, s9
    add t6, t6, ra
    add s1, s1, s1
    sltu s1, s1, s1
    add s1, s1, s5
    sltu s5, s1, s5
    or s1, s1, s5
    add t6, t6, s1
    add t6, t6, s1
    add t6, t6, s5
    add t6, t6, s2
    add s4, s4, a6
    sltu a6, s4, a6
    add s4, s4, s1
    sltu s1, s4, s1
    or a6, a6, s1
    add t6, t6, s4
    add t6, t6, a6
    add t6, t6, s1
    add t6, t6, s8
    add t1, t1, s5
    sltu s5, t1, s5
    add t1, t1, a1
    sltu a1, t1, a1
    or s5, s5, a1
    add t6, t6, t1
    add t6, t6, s5
    add t6, t6, a1
    add t6, t6, a7
    sub zero, sp, zero
    sltu a4, sp, zero
    sub sp, zero, s1
    sltu s1, zero, sp
    or zero, s1, a4
    add t6, t6, sp
    add t6, t6, zero
    add t6, t6, s1
    add t6, t6, a4
    add s7, s7, t2
    sltu t2, s7, t2
    add s7, s7, s9
    sltu s9, s7, s9
    or t2, t2, s9
    add t6, t6, s7
    add t6, t6, t2
    add t6, t6, s9
    add t6, t6, a3
    sub s9, s10, s9
    sltu a2, s10, s9
    sub s10, s9, s7
    sltu s7, s9, s10
    or s9, s7, a2
    add t6, t6, s10
    add t6, t6, s9
    add t6, t6, s7
    add t6, t6, a2
    sub a5, s4, a5
    sltu t1, s4, a5
    sub s4, a5, s8
    sltu s8, a5, s4
    or a5, s8, t1
    add t6, t6, s4
    add t6, t6, a5
    add t6, t6, s8
    add t6, t6, t1
    add s0, s0, s1
    sltu s1, s0, s1
    add s0, s0, s4
    sltu s4, s0, s4
    or s1, s1, s4
    add t6, t6, s0
    add t6, t6, s1
    add t6, t6, s4
    add t6, t6, t5
    sub s11, zero, s11
    sltu a5, zero, s11
    sub zero, s11, zero
    sltu zero, s11, zero
    or s11, zero, a5
    add t6, t6, a2
    add t6, t6, s11
    add t6, t6, zero
    add t6, t6, a5
    add gp, gp, s7
    sltu s7, gp, s7
    add gp, gp, s7
    sltu s7, gp, s7
    or s7, s7, s7
    add t6, t6, gp
    add t6, t6, s7
    add t6, t6, s7
    add t6, t6, zero
    sub s11, s4, s11
    sltu t4, s4, s11
    sub s4, s11, t4
    sltu t4, s11, s4
    or s11, t4, t4
    add t6, t6, s4
    add t6, t6, s11
    add t6, t6, a3
    add t6, t6, t4
    add s0, s0, s3
    sltu s3, s0, s3
    add s0, s0, s3
    sltu s3, s0, s3
    or s3, s3, s3
    add t6, t6, s0
    add t6, t6, a2
    add t6, t6, s3
    add t6, t6, sp
    add s6, s6, s5
    sltu s5, s6, s5
    add s6, s6, a0
    sltu a0, s6, a0
    or s5, s5, a0
    add t6, t6, s6
    add t6, t6, s5
    add t6, t6, a0
    add t6, t6, a6
    add a7, a7, s4
    sltu s4, a7, s4
    add a7, a7, t0
    sltu t0, a7, t0
    or s4, s4, t0
    add t6, t6, a7
    add t6, t6, s4
    add t6, t6, t0
    add t6, t6, s6
    add tp, tp, a5
    sltu a5, tp, a5
    add tp, tp, a2
    sltu a2, tp, a2
    or a5, a5, a2
    add t6, t6, tp
    add t6, t6, a5
    add t6, t6, a2
    add t6, t6, t2
    sub tp, s2, tp
    sltu a1, s2, tp
    sub s2, tp, a6
    sltu a6, tp, s2
    or tp, a6, a1
    add t6, t6, s2
    add t6, t6, tp
    add t6, t6, a6
    add t6, t6, a1
    add t4, t4, a1
    sltu a1, t4, a1
    add t4, t4, t5
    sltu t5, t4, t5
    or a1, a1, t5
    add t6, t6, t4
    add t6, t6, a1
    add t6, t6, t5
    add t6, t6, s2
    add s9, s9, s2
    sltu s2, s9, s2
    add s9, s9, s6
    sltu s6, s9, s6
    or s2, s2, s6
    add t6, t6, s9
    add t6, t6, s2
    add t6, t6, s6
    add t6, t6, t2
    add a4, a4, a1
    sltu a1, a4, a1
    add a4, a4, s4
    sltu s4, a4, s4
    or a1, a1, s4
    add t6, t6, a4
    add t6, t6, a1
    add t6, t6, s4
    add t6, t6, a1
    sub t1, gp, t1
    sltu s9, gp, t1
    sub gp, t1, s7
    sltu s7, t1, gp
    or t1, s7, s9
    add t6, t6, gp
    add t6, t6, t1
    add t6, t6, s7
    add t6, t6, s9
    add s9, s9, a7
    sltu a7, s9, a7
    add s9, s9, a0
    sltu a0, s9, a0
    or a7, a7, a0
    add t6, t6, s9
    add t6, t6, a7
    add t6, t6, a3
    add t6, t6, a0
    sub zero, ra, zero
    sltu t4, ra, zero
    sub ra, zero, tp
    sltu tp, zero, ra
    or zero, tp, t4
    add t6, t6, ra
    add t6, t6, zero
    add t6, t6, tp
    add t6, t6, t4
    add s11, s11, sp
    sltu sp, s11, sp
    add s11, s11, a0
    sltu a0, s11, a0
    or sp, sp, a0
    add t6, t6, s11
    add t6, t6, sp
    add t6, t6, a0
    add t6, t6, a5
    sub a7, t2, a7
    sltu a5, t2, a7
    sub t2, a7, s3
    sltu s3, a7, t2
    or a7, s3, a5
    add t6, t6, t2
    add t6, t6, a7
    add t6, t6, s3
    add t6, t6, a5
    add t5, t5, t0
    sltu t0, t5, t0
    add t5, t5, t4
    sltu t4, t5, t4
    or t0, t0, t4
    add t6, t6, t5
    add t6, t6, t0
    add t6, t6, t4
    add t6, t6, a0
    sub t3, s8, t3
    sltu gp, s8, t3
    sub s8, t3, s3
    sltu s3, t3, s8
    or t3, s3, gp
    add t6, t6, s8
    add t6, t6, t3
    add t6, t6, s3
    add t6, t6, gp
    sub gp, ra, gp
    sltu s7, ra, gp
    sub ra, gp, t0
    sltu t0, gp, ra
    or gp, t0, s7
    add t6, t6, ra
    add t6, t6, gp
    add t6, t6, t0
    add t6, t6, s7
    sub t0, s4, t0
    sltu t5, s4, t0
    sub s4, t0, t4
    sltu t4, t0, s4
    or t0, t4, t5
    add t6, t6, s4
    add t6, t6, t0
    add t6, t6, t4
    add t6, t6, t5
    add s11, s11, s9
    sltu s9, s11, s9
    add s11, s11, s7
    sltu s7, s11, s7
    or s9, s9, s7
    add t6, t6, s11
    add t6, t6, s9
    add t6, t6, s7
    add t6, t6, s4
    add t5, t5, s0
    sltu s0, t5, s0
    add t5, t5, a5
    sltu a5, t5, a5
    or s0, s0, a5
    add t6, t6, t5
    add t6, t6, s0
    add t6, t6, a5
    add t6, t6, a5
    add sp, sp, s5
    sltu s5, sp, s5
    add sp, sp, s1
    sltu s1, sp, s1
    or s5, s5, s1
    add t6, t6, sp
    add t6, t6, s5
    add t6, t6, s1
    add t6, t6, s9
    add s5, s5, t2
    sltu t2, s5, t2
    add s5, s5, zero
    sltu zero, s5, zero
    or t2, t2, zero
    add t6, t6, s5
    add t6, t6, t2
    add t6, t6, zero
    add t6, t6, a3
    sub a1, a7, a1
    sltu zero, a7, a1
    sub a7, a1, a1
    sltu a1, a1, a7
    or a1, a1, zero
    add t6, t6, a7
    add t6, t6, a2
    add t6, t6, a1
    add t6, t6, zero
    sub t3, a7, t3
    sltu zero, a7, t3
    sub a7, t3, s11
    sltu s11, t3, a7
    or t3, s11, zero
    add t6, t6, a7
    add t6, t6, t3
    add t6, t6, s11
    add t6, t6, zero
    sub s9, s10, s9
    sltu s3, s10, s9
    sub s10, s9, s11
    sltu s11, s9, s10
    or s9, s11, s3
    add t6, t6, s10
    add t6, t6, s9
    add t6, t6, s11
    add t6, t6, s3
    sub t2, s3, t2
    sltu t4, s3, t2
    sub s3, t2, gp
    sltu gp, t2, s3
    or t2, gp, t4
    add t6, t6, s3
    add t6, t6, t2
    add t6, t6, gp
    add t6, t6, t4
    sub sp, zero, sp
    sltu a2, zero, sp
    sub zero, sp, s0
    sltu s0, sp, zero
    or sp, s0, a2
    add t6, t6, zero
    add t6, t6, sp
    add t6, t6, s0
    add t6, t6, a2
    add s11, s11, s2
    sltu s2, s11, s2
    add s11, s11, s10
    sltu s10, s11, s10
    or s2, s2, s10
    add t6, t6, s11
    add t6, t6, s2
    add t6, t6, s10
    add t6, t6, s11
    add t0, t0, t0
    sltu t0, t0, t0
    add t0, t0, a1
    sltu a1, t0, a1
    or t0, t0, a1
    add t6, t6, t0
    add t6, t6, t0
    add t6, t6, a1
    add t6, t6, s8
    add tp, tp, a6
    sltu a6, tp, a6
    add tp, tp, s3
    sltu s3, tp, s3
    or a6, a6, s3
    add t6, t6, tp
    add t6, t6, a6
    add t6, t6, s3
    add t6, t6, s5
    add s0, s0, t2
    sltu t2, s0, t2
    add s0, s0, zero
    sltu zero, s0, zero
    or t2, t2, zero
    add t6, t6, s0
    add t6, t6, t2
    add t6, t6, zero
    add t6, t6, t1
    add s10, s10, a5
    sltu a5, s10, a5
    add s10, s10, a1
    sltu a1, s10, a1
    or a5, a5, a1
    add t6, t6, s10
    add t6, t6, a5
    add t6, t6, a1
    add t6, t6, ra
    add t5, t5, t5
    sltu t5, t5, t5
    add t5, t5, tp
    sltu tp, t5, tp
    or t5, t5, tp
    add t6, t6, a1
    add t6, t6, t5
    add t6, t6, a3
    add t6, t6, tp
    sub a4, gp, a4
    sltu t4, gp, a4
    sub gp, a4, s1
    sltu s1, a4, gp
    or a4, s1, t4
    add t6, t6, gp
    add t6, t6, a4
    add t6, t6, s1
    add t6, t6, t4
    sub ra, s4, ra
    sltu t5, s4, ra
    sub s4, ra, s11
    sltu s11, ra, s4
    or ra, s11, t5
    add t6, t6, s4
    add t6, t6, ra
    add t6, t6, s11
    add t6, t6, t5
    add t5, t5, gp
    sltu gp, t5, gp
    add t5, t5, t3
    sltu t3, t5, t3
    or gp, gp, t3
    add t6, t6, t5
    add t6, t6, gp
    add t6, t6, t3
    add t6, t6, a5
    add s2, s2, s0
    sltu s0, s2, s0
    add s2, s2, a7
    sltu a7, s2, a7
    or s0, s0, a7
    add t6, t6, s2
    add t6, t6, s0
    add t6, t6, a7
    add t6, t6, s6
    add t2, t2, s11
    sltu s11, t2, s11
    add t2, t2, s0
    sltu s0, t2, s0
    or s11, s11, s0
    add t6, t6, t2
    add t6, t6, s11
    add t6, t6, s0
    add t6, t6, s10
    add t4, t4, s10
    sltu s10, t4, s10
    add t4, t4, s10
    sltu s10, t4, s10
    or s10, s10, s10
    add t6, t6, t4
    add t6, t6, a2
    add t6, t6, s10
    add t6, t6, a5
    add t1, t1, ra
    sltu ra, t1, ra
    add t1, t1, ra
    sltu ra, t1, ra
    or ra, ra, ra
    add t6, t6, t1
    add t6, t6, a2
    add t6, t6, ra
    add t6, t6, t2
    add s3, s3, t2
    sltu t2, s3, t2
    add s3, s3, s10
    sltu s10, s3, s10
    or t2, t2, s10
    add t6, t6, s3
    add t6, t6, t2
    add t6, t6, s10
    add t6, t6, s3
    sub s9, sp, s9
    sltu s1, sp, s9
    sub sp, s9, tp
    sltu tp, s9, sp
    or s9, tp, s1
    add t6, t6, sp
    add t6, t6, s9
    add t6, t6, tp
    add t6, t6, s1
    add t5, t5, s10
    sltu s10, t5, s10
    add t5, t5, sp
    sltu sp, t5, sp
    or s10, s10, sp
    add t6, t6, t5
    add t6, t6, s10
    add t6, t6, sp
    add t6, t6, gp
    sub t3, t2, t3
    sltu t2, t2, t3
    sub t2, t3, s2
    sltu s2, t3, t2
    or t3, s2, t2
    add t6, t6, a3
    add t6, t6, t3
    add t6, t6, s2
    add t6, t6, t2
    sub t2, t2, t2
    sltu t3, t2, t2
    sub t2, t2, tp
    sltu tp, t2, t2
    or t2, tp, t3
    add t6, t6, a1
    add t6, t6, t2
    add t6, t6, tp
    add t6, t6, t3
    add t3, t3, a6
    sltu a6, t3, a6
    add t3, t3, a0
    sltu a0, t3, a0
    or a6, a6, a0
    add t6, t6, t3
    add t6, t6, a6
    add t6, t6, a0
    add t6, t6, zero
    sub t2, s1, t2
    sltu s11, s1, t2
    sub s1, t2, t1
    sltu t1, t2, s1
    or t2, t1, s11
    add t6, t6, s1
    add t6, t6, t2
    add t6, t6, t1
    add t6, t6, s11
    sub t2, t4, t2
    sltu t2, t4, t2
    sub t4, t2, s9
    sltu s9, t2, t4
    or t2, s9, t2
    add t6, t6, t4
    add t6, t6, a3
    add t6, t6, s9
    add t6, t6, t2
    sub s3, a6, s3
    sltu s8, a6, s3
    sub a6, s3, a0
    sltu a0, s3, a6
    or s3, a0, s8
    add t6, t6, a6
    add t6, t6, s3
    add t6, t6, a0
    add t6, t6, s8
    sub a5, s8, a5
    sltu ra, s8, a5
    sub s8, a5, s7
    sltu s7, a5, s8
    or a5, s7, ra
    add t6, t6, s8
    add t6, t6, a5
    add t6, t6, s7
    add t6, t6, ra
    sub s8, s11, s8
    sltu t5, s11, s8
    sub s11, s8, t0
    sltu t0, s8, s11
    or s8, t0, t5
    add t6, t6, s11
    add t6, t6, s8
    add t6, t6, t0
    add t6, t6, t5
    add t3, t3, s0
    sltu s0, t3, s0
    add t3, t3, s8
    sltu s8, t3, s8
    or s0, s0, s8
    add t6, t6, t3
    add t6, t6, s0
    add t6, t6, s8
    add t6, t6, t2
    sub s5, sp, s5
    sltu a7, sp, s5
    sub sp, s5, s0
    sltu s0, s5, sp
    or s5, s0, a7
    add t6, t6, sp
    add t6, t6, s5
    add t6, t6, s0
    add t6, t6, a7
    sub zero, s2, zero
    sltu s0, s2, zero
    sub s2, zero, s0
    sltu s0, zero, s2
    or zero, s0, s0
    add t6, t6, s2
    add t6, t6, zero
    add t6, t6, a3
    add t6, t6, s0
    sub s1, s3, s1
    sltu a1, s3, s1
    sub s3, s1, gp
    sltu gp, s1, s3
    or s1, gp, a1
    add t6, t6, s3
    add t6, t6, s1
    add t6, t6, gp
    add t6, t6, a1
    add a7, a7, s11
    sltu s11, a7, s11
    add a7, a7, s10
    sltu s10, a7, s10
    or s11, s11, s10
    add t6, t6, a7
    add t6, t6, s11
    add t6, t6, s10
    add t6, t6, a6
    add t1, t1, s3
    sltu s3, t1, s3
    add t1, t1, s9
    sltu s9, t1, s9
    or s3, s3, s9
    add t6, t6, t1
    add t6, t6, s3
    add t6, t6, a3
    add t6, t6, s9
    sub s2, s1, s2
    sltu s2, s1, s2
    sub s1, s2, s9
    sltu s9, s2, s1
    or s2, s9, s2
    add t6, t6, s1
    add t6, t6, s2
    add t6, t6, s9
    add t6, t6, s2
    add s2, s2, s11
    sltu s11, s2, s11
    add s2, s2, s0
    sltu s0, s2, s0
    or s11, s11, s0
    add t6, t6, s2
    add t6, t6, s11
    add t6, t6, s0
    add t6, t6, t0
    add t0, t0, s9
    sltu s9, t0, s9
    add t0, t0, a0
    sltu a0, t0, a0
    or s9, s9, a0
    add t6, t6, t0
    add t6, t6, s9
    add t6, t6, a0
    add t6, t6, a2
    sub t4, t4, t4
    sltu a2, t4, t4
    sub t4, t4, s0
    sltu s0, t4, t4
    or t4, s0, a2
    add t6, t6, t4
    add t6, t6, t4
    add t6, t6, s0
    add t6, t6, a2
    sub s5, s5, s5
    sltu sp, s5, s5
    sub s5, s5, s3
    sltu s3, s5, s5
    or s5, s3, sp
    add t6, t6, s5
    add t6, t6, s5
    add t6, t6, s3
    add t6, t6, sp
    add t2, t2, a1
    sltu a1, t2, a1
    add t2, t2, a4
    sltu a4, t2, a4
    or a1, a1, a4
    add t6, t6, t2
    add t6, t6, a1
    add t6, t6, a4
    add t6, t6, ra
    sub a7, ra, a7
    sltu s0, ra, a7
    sub ra, a7, s8
    sltu s8, a7, ra
    or a7, s8, s0
    add t6, t6, ra
    add t6, t6, a7
    add t6, t6, s8
    add t6, t6, s0
    sub t4, t0, t4
    sltu zero, t0, t4
    sub t0, t4, zero
    sltu zero, t4, t0
    or t4, zero, zero
    add t6, t6, t0
    add t6, t6, t4
    add t6, t6, zero
    add t6, t6, zero
    add s11, s11, zero
    sltu zero, s11, zero
    add s11, s11, tp
    sltu tp, s11, tp
    or zero, zero, tp
    add t6, t6, s11
    add t6, t6, zero
    add t6, t6, tp
    add t6, t6, s10
    sub s1, s4, s1
    sltu s4, s4, s1
    sub s4, s1, a2
    sltu a2, s1, s4
    or s1, a2, s4
    add t6, t6, a3
    add t6, t6, s1
    add t6, t6, a2
    add t6, t6, s4
    sub t2, gp, t2
    sltu s9, gp, t2
    sub gp, t2, t4
    sltu t4, t2, gp
    or t2, t4, s9
    add t6, t6, gp
    add t6, t6, t2
    add t6, t6, t4
    add t6, t6, s9
    sub zero, a6, zero
    sltu t3, a6, zero
    sub a6, zero, t4
    sltu t4, zero, a6
    or zero, t4, t3
    add t6, t6, a6
    add t6, t6, zero
    add t6, t6, t4
    add t6, t6, t3
    add t3, t3, s2
    sltu s2, t3, s2
    add t3, t3, s0
    sltu s0, t3, s0
    or s2, s2, s0
    add t6, t6, t3
    add t6, t6, s2
    add t6, t6, s0
    add t6, t6, s4
    add gp, gp, t3
    sltu t3, gp, t3
    add gp, gp, t5
    sltu t5, gp, t5
    or t3, t3, t5
    add t6, t6, gp
    add t6, t6, t3
    add t6, t6, t5
    add t6, t6, s4
    sub s3, ra, s3
    sltu a5, ra, s3
    sub ra, s3, s8
    sltu s8, s3, ra
    or s3, s8, a5
    add t6, t6, ra
    add t6, t6, s3
    add t6, t6, s8
    add t6, t6, a5
    add s2, s2, s9
    sltu s9, s2, s9
    add s2, s2, zero
    sltu zero, s2, zero
    or s9, s9, zero
    add t6, t6, s2
    add t6, t6, s9
    add t6, t6, zero
    add t6, t6, s9
    sub s9, t3, s9
    sltu t1, t3, s9
    sub t3, s9, a0
    sltu a0, s9, t3
    or s9, a0, t1
    add t6, t6, t3
    add t6, t6, s9
    add t6, t6, a0
    add t6, t6, t1
    sub s2, t1, s2
    sltu a7, t1, s2
    sub t1, s2, s10
    sltu s10, s2, t1
    or s2, s10, a7
    add t6, t6, t1
    add t6, t6, s2
    add t6, t6, s10
    add t6, t6, a7
    sub s9, s5, s9
    sltu s11, s5, s9
    sub s5, s9, s8
    sltu s8, s9, s5
    or s9, s8, s11
    add t6, t6, s5
    add t6, t6, s9
    add t6, t6, s8
    add t6, t6, s11
    add s6, s6, s10
    sltu s10, s6, s10
    add s6, s6, s6
    sltu s6, s6, s6
    or s10, s10, s6
    add t6, t6, a2
    add t6, t6, s10
    add t6, t6, s6
    add t6, t6, s6
    add a0, a0, a0
    sltu a0, a0, a0
    add a0, a0, a4
    sltu a4, a0, a4
    or a0, a0, a4
    add t6, t6, a1
    add t6, t6, a3
    add t6, t6, a4
    add t6, t6, a0
    add s3, s3, s3
    sltu s3, s3, s3
    add s3, s3, s5
    sltu s5, s3, s5
    or s3, s3, s5
    add t6, t6, a1
    add t6, t6, a3
    add t6, t6, s5
    add t6, t6, s3
    add t4, t4, sp
    sltu sp, t4, sp
    add t4, t4, a4
    sltu a4, t4, a4
    or sp, sp, a4
    add t6, t6, t4
    add t6, t6, sp
    add t6, t6, a4
    add t6, t6, ra
    add s0, s0, s1
    sltu s1, s0, s1
    add s0, s0, sp
    sltu sp, s0, sp
    or s1, s1, sp
    add t6, t6, s0
    add t6, t6, s1
    add t6, t6, a3
    add t6, t6, sp
    add t4, t4, s1
    sltu s1, t4, s1
    add t4, t4, s2
    sltu s2, t4, s2
    or s1, s1, s2
    add t6, t6, t4
    add t6, t6, s1
    add t6, t6, s2
    add t6, t6, t4
    sub s6, sp, s6
    sltu a6, sp, s6
    sub sp, s6, s8
    sltu s8, s6, sp
    or s6, s8, a6
    add t6, t6, sp
    add t6, t6, s6
    add t6, t6, s8
    add t6, t6, a6
    sub s10, s11, s10
    sltu gp, s11, s10
    sub s11, s10, s10
    sltu s10, s10, s11
    or s10, s10, gp
    add t6, t6, s11
    add t6, t6, a2
    add t6, t6, s10
    add t6, t6, gp
    add s7, s7, s7
    sltu s7, s7, s7
    add s7, s7, s11
    sltu s11, s7, s11
    or s7, s7, s11
    add t6, t6, s7
    add t6, t6, s7
    add t6, t6, s11
    add t6, t6, s6
    sub t1, gp, t1
    sltu a7, gp, t1
    sub gp, t1, t1
    sltu t1, t1, gp
    or t1, t1, a7
    add t6, t6, gp
    add t6, t6, a2
    add t6, t6, t1
    add t6, t6, a7
    sub s4, a4, s4
    sltu s5, a4, s4
    sub a4, s4, a7
    sltu a7, s4, a4
    or s4, a7, s5
    add t6, t6, a4
    add t6, t6, s4
    add t6, t6, a7
    add t6, t6, s5
    add s7, s7, s6
    sltu s6, s7, s6
    add s7, s7, gp
    sltu gp, s7, gp
    or s6, s6, gp
    add t6, t6, s7
    add t6, t6, s6
    add t6, t6, gp
    add t6, t6, s7
    add s2, s2, t4
    sltu t4, s2, t4
    add s2, s2, s11
    sltu s11, s2, s11
    or t4, t4, s11
    add t6, t6, s2
    add t6, t6, t4
    add t6, t6, s11
    add t6, t6, tp
    sub t1, a5, t1
    sltu t2, a5, t1
    sub a5, t1, a7
    sltu a7, t1, a5
    or t1, a7, t2
    add t6, t6, a5
    add t6, t6, t1
    add t6, t6, a7
    add t6, t6, t2
    sub s5, s10, s5
    sltu s2, s10, s5
    sub s10, s5, a7
    sltu a7, s5, s10
    or s5, a7, s2
    add t6, t6, s10
    add t6, t6, s5
    add t6, t6, a7
    add t6, t6, s2
    sub s3, tp, s3
    sltu t0, tp, s3
    sub tp, s3, a0
    sltu a0, s3, tp
    or s3, a0, t0
    add t6, t6, tp
    add t6, t6, s3
    add t6, t6, a0
    add t6, t6, t0
    sub s0, s2, s0
    sltu s2, s2, s0
    sub s2, s0, t4
    sltu t4, s0, s2
    or s0, t4, s2
    add t6, t6, s2
    add t6, t6, s0
    add t6, t6, t4
    add t6, t6, s2
    add t5, t5, gp
    sltu gp, t5, gp
    add t5, t5, a1
    sltu a1, t5, a1
    or gp, gp, a1
    add t6, t6, t5
    add t6, t6, gp
    add t6, t6, a1
    add t6, t6, s5
    add a4, a4, zero
    sltu zero, a4, zero
    add a4, a4, t3
    sltu t3, a4, t3
    or zero, zero, t3
    add t6, t6, a4
    add t6, t6, zero
    add t6, t6, t3
    add t6, t6, a3
    add s10, s10, a1
    sltu a1, s10, a1
    add s10, s10, s1
    sltu s1, s10, s1
    or a1, a1, s1
    add t6, t6, s10
    add t6, t6, a1
    add t6, t6, s1
    add t6, t6, zero
    sub a0, s4, a0
    sltu s7, s4, a0
    sub s4, a0, sp
    sltu sp, a0, s4
    or a0, sp, s7
    add t6, t6, s4
    add t6, t6, a0
    add t6, t6, sp
    add t6, t6, s7
    add s9, s9, s7
    sltu s7, s9, s7
    add s9, s9, s0
    sltu s0, s9, s0
    or s7, s7, s0
    add t6, t6, s9
    add t6, t6, s7
    add t6, t6, s0
    add t6, t6, a4
    add s0, s0, s0
    sltu s0, s0, s0
    add s0, s0, sp
    sltu sp, s0, sp
    or s0, s0, sp
    add t6, t6, s0
    add t6, t6, s0
    add t6, t6, sp
    add t6, t6, t1
    sub s10, s9, s10
    sltu zero, s9, s10
    sub s9, s10, s4
    sltu s4, s10, s9
    or s10, s4, zero
    add t6, t6, s9
    add t6, t6, s10
    add t6, t6, s4
    add t6, t6, zero
    sub t5, s4, t5
    sltu s0, s4, t5
    sub s4, t5, gp
    sltu gp, t5, s4
    or t5, gp, s0
    add t6, t6, s4
    add t6, t6, t5
    add t6, t6, gp
    add t6, t6, s0
    sub a7, t0, a7
    sltu s6, t0, a7
    sub t0, a7, s5
    sltu s5, a7, t0
    or a7, s5, s6
    add t6, t6, t0
    add t6, t6, a7
    add t6, t6, s5
    add t6, t6, s6
    sub s2, a6, s2
    sltu ra, a6, s2
    sub a6, s2, a4
    sltu a4, s2, a6
    or s2, a4, ra
    add t6, t6, a6
    add t6, t6, s2
    add t6, t6, a4
    add t6, t6, ra
    sub t2, a0, t2
    sltu s7, a0, t2
    sub a0, t2, a1
    sltu a1, t2, a0
    or t2, a1, s7
    add t6, t6, a0
    add t6, t6, t2
    add t6, t6, a1
    add t6, t6, s7
    add t3, t3, a4
    sltu a4, t3, a4
    add t3, t3, s1
    sltu s1, t3, s1
    or a4, a4, s1
    add t6, t6, t3
    add t6, t6, a4
    add t6, t6, s1
    add t6, t6, s9
    add s11, s11, a4
    sltu a4, s11, a4
    add s11, s11, ra
    sltu ra, s11, ra
    or a4, a4, ra
    add t6, t6, s11
    add t6, t6, a4
    add t6, t6, ra
    add t6, t6, s9
    sub s11, t4, s11
    sltu s8, t4, s11
    sub t4, s11, a1
    sltu a1, s11, t4
    or s11, a1, s8
    add t6, t6, t4
    add t6, t6, s11
    add t6, t6, a1
    add t6, t6, s8
    add t5, t5, a0
    sltu a0, t5, a0
    add t5, t5, s11
    sltu s11, t5, s11
    or a0, a0, s11
    add t6, t6, t5
    add t6, t6, a0
    add t6, t6, s11
    add t6, t6, s2
    add ra, ra, a7
    sltu a7, ra, a7
    add ra, ra, gp
    sltu gp, ra, gp
    or a7, a7, gp
    add t6, t6, ra
    add t6, t6, a7
    add t6, t6, gp
    add t6, t6, s2
    add s8, s8, s4
    sltu s4, s8, s4
    add s8, s8, a2
    sltu a2, s8, a2
    or s4, s4, a2
    add t6, t6, a3
    add t6, t6, s4
    add t6, t6, a2
    add t6, t6, s8
    add t3, t3, ra
    sltu ra, t3, ra
    add t3, t3, s10
    sltu s10, t3, s10
    or ra, ra, s10
    add t6, t6, t3
    add t6, t6, ra
    add t6, t6, s10
    add t6, t6, s4
    sub t5, sp, t5
    sltu s2, sp, t5
    sub sp, t5, t0
    sltu t0, t5, sp
    or t5, t0, s2
    add t6, t6, sp
    add t6, t6, t5
    add t6, t6, t0
    add t6, t6, s2
    sub t4, s6, t4
    sltu s11, s6, t4
    sub s6, t4, s6
    sltu s6, t4, s6
    or t4, s6, s11
    add t6, t6, a2
    add t6, t6, t4
    add t6, t6, s6
    add t6, t6, s11
    add t3, t3, t1
    sltu t1, t3, t1
    add t3, t3, t2
    sltu t2, t3, t2
    or t1, t1, t2
    add t6, t6, t3
    add t6, t6, t1
    add t6, t6, t2
    add t6, t6, s9
    sub ra, zero, ra
    sltu s2, zero, ra
    sub zero, ra, zero
    sltu zero, ra, zero
    or ra, zero, s2
    add t6, t6, zero
    add t6, t6, ra
    add t6, t6, zero
    add t6, t6, s2
    sub a4, s2, a4
    sltu t3, s2, a4
    sub s2, a4, sp
    sltu sp, a4, s2
    or a4, sp, t3
    add t6, t6, s2
    add t6, t6, a4
    add t6, t6, sp
    add t6, t6, t3
    add t5, t5, s0
    sltu s0, t5, s0
    add t5, t5, t3
    sltu t3, t5, t3
    or s0, s0, t3
    add t6, t6, t5
    add t6, t6, s0
    add t6, t6, t3
    add t6, t6, ra
    add s11, s11, s1
    sltu s1, s11, s1
    add s11, s11, a2
    sltu a2, s11, a2
    or s1, s1, a2
    add t6, t6, s11
    add t6, t6, s1
    add t6, t6, a2
    add t6, t6, s2
    sub s11, s0, s11
    sltu a2, s0, s11
    sub s0, s11, s3
    sltu s3, s11, s0
    or s11, s3, a2
    add t6, t6, s0
    add t6, t6, s11
    add t6, t6, s3
    add t6, t6, a2
    sub s0, t2, s0
    sltu a7, t2, s0
    sub t2, s0, s7
    sltu s7, s0, t2
    or s0, s7, a7
    add t6, t6, t2
    add t6, t6, s0
    add t6, t6, s7
    add t6, t6, a7
    add s6, s6, s8
    sltu s8, s6, s8
    add s6, s6, sp
    sltu sp, s6, sp
    or s8, s8, sp
    add t6, t6, s6
    add t6, t6, s8
    add t6, t6, sp
    add t6, t6, a1
    add s6, s6, a1
    sltu a1, s6, a1
    add s6, s6, a0
    sltu a0, s6, a0
    or a1, a1, a0
    add t6, t6, s6
    add t6, t6, a1
    add t6, t6, a0
    add t6, t6, s11
    add tp, tp, t3
    sltu t3, tp, t3
    add tp, tp, t5
    sltu t5, tp, t5
    or t3, t3, t5
    add t6, t6, tp
    add t6, t6, t3
    add t6, t6, t5
    add t6, t6, s1
    add s2, s2, s0
    sltu s0, s2, s0
    add s2, s2, t4
    sltu t4, s2, t4
    or s0, s0, t4
    add t6, t6, s2
    add t6, t6, s0
    add t6, t6, t4
    add t6, t6, s8
    add sp, sp, t2
    sltu t2, sp, t2
    add sp, sp, t1
    sltu t1, sp, t1
    or t2, t2, t1
    add t6, t6, sp
    add t6, t6, t2
    add t6, t6, t1
    add t6, t6, gp
    sub tp, a6, tp
    sltu s7, a6, tp
    sub a6, tp, s0
    sltu s0, tp, a6
    or tp, s0, s7
    add t6, t6, a6
    add t6, t6, tp
    add t6, t6, s0
    add t6, t6, s7
    sub ra, s7, ra
    sltu s6, s7, ra
    sub s7, ra, ra
    sltu ra, ra, s7
    or ra, ra, s6
    add t6, t6, s7
    add t6, t6, a2
    add t6, t6, ra
    add t6, t6, s6
    add s11, s11, t0
    sltu t0, s11, t0
    add s11, s11, s6
    sltu s6, s11, s6
    or t0, t0, s6
    add t6, t6, s11
    add t6, t6, t0
    add t6, t6, s6
    add t6, t6, s2
    sub zero, s2, zero
    sltu t0, s2, zero
    sub s2, zero, t2
    sltu t2, zero, s2
    or zero, t2, t0
    add t6, t6, s2
    add t6, t6, zero
    add t6, t6, t2
    add t6, t6, t0
    sub s6, zero, s6
    sltu s2, zero, s6
    sub zero, s6, a4
    sltu a4, s6, zero
    or s6, a4, s2
    add t6, t6, zero
    add t6, t6, s6
    add t6, t6, a4
    add t6, t6, s2
    add s10, s10, a6
    sltu a6, s10, a6
    add s10, s10, a2
    sltu a2, s10, a2
    or a6, a6, a2
    add t6, t6, s10
    add t6, t6, a6
    add t6, t6, a2
    add t6, t6, t0
    add t0, t0, sp
    sltu sp, t0, sp
    add t0, t0, t0
    sltu t0, t0, t0
    or sp, sp, t0
    add t6, t6, t0
    add t6, t6, sp
    add t6, t6, t0
    add t6, t6, a6
    sub tp, s2, tp
    sltu a3, s2, tp
    sub s2, tp, tp
    sltu tp, tp, s2
    or tp, tp, a3
    add t6, t6, s2
    add t6, t6, a2
    add t6, t6, tp
    add t6, t6, a3
    sub s0, t5, s0
    sltu t4, t5, s0
    sub t5, s0, t4
    sltu t4, s0, t5
    or s0, t4, t4
    add t6, t6, t5
    add t6, t6, s0
    add t6, t6, a3
    add t6, t6, t4
    sub t1, s4, t1
    sltu t0, s4, t1
    sub s4, t1, a1
    sltu a1, t1, s4
    or t1, a1, t0
    add t6, t6, s4
    add t6, t6, t1
    add t6, t6, a1
    add t6, t6, t0
    sub a7, t1, a7
    sltu a4, t1, a7
    sub t1, a7, t0
    sltu t0, a7, t1
    or a7, t0, a4
    add t6, t6, t1
    add t6, t6, a7
    add t6, t6, t0
    add t6, t6, a4
    add s10, s10, s10
    sltu s10, s10, s10
    add s10, s10, a1
    sltu a1, s10, a1
    or s10, s10, a1
    add t6, t6, s10
    add t6, t6, s10
    add t6, t6, a1
    add t6, t6, ra
    sub s11, zero, s11
    sltu gp, zero, s11
    sub zero, s11, tp
    sltu tp, s11, zero
    or s11, tp, gp
    add t6, t6, zero
    add t6, t6, s11
    add t6, t6, tp
    add t6, t6, gp
    sub zero, a7, zero
    sltu s8, a7, zero
    sub a7, zero, s5
    sltu s5, zero, a7
    or zero, s5, s8
    add t6, t6, a7
    add t6, t6, zero
    add t6, t6, s5
    add t6, t6, s8
    add zero, zero, s3
    sltu s3, zero, s3
    add zero, zero, a0
    sltu a0, zero, a0
    or s3, s3, a0
    add t6, t6, zero
    add t6, t6, s3
    add t6, t6, a0
    add t6, t6, s0
    add s2, s2, s10
    sltu s10, s2, s10
    add s2, s2, a4
    sltu a4, s2, a4
    or s10, s10, a4
    add t6, t6, a3
    add t6, t6, s10
    add t6, t6, a4
    add t6, t6, s2
    sub s7, s0, s7
    sltu s5, s0, s7
    sub s0, s7, ra
    sltu ra, s7, s0
    or s7, ra, s5
    add t6, t6, s0
    add t6, t6, s7
    add t6, t6, ra
    add t6, t6, s5
    sub a5, t5, a5
    sltu s4, t5, a5
    sub t5, a5, s3
    sltu s3, a5, t5
    or a5, s3, s4
    add t6, t6, t5
    add t6, t6, a5
    add t6, t6, s3
    add t6, t6, s4
    sub t1, s0, t1
    sltu s9, s0, t1
    sub s0, t1, s5
    sltu s5, t1, s0
    or t1, s5, s9
    add t6, t6, s0
    add t6, t6, t1
    add t6, t6, s5
    add t6, t6, s9
    add s8, s8, s9
    sltu s9, s8, s9
    add s8, s8, zero
    sltu zero, s8, zero
    or s9, s9, zero
    add t6, t6, s8
    add t6, t6, s9
    add t6, t6, zero
    add t6, t6, t5
    sub t3, s8, t3
    sltu a6, s8, t3
    sub s8, t3, t0
    sltu t0, t3, s8
    or t3, t0, a6
    add t6, t6, s8
    add t6, t6, t3
    add t6, t6, t0
    add t6, t6, a6
    add a7, a7, a4
    sltu a4, a7, a4
    add a7, a7, s2
    sltu s2, a7, s2
    or a4, a4, s2
    add t6, t6, a7
    add t6, t6, a4
    add t6, t6, s2
    add t6, t6, ra
    sub s6, s6, s6
    sltu s6, s6, s6
    sub s6, s6, s10
    sltu s10, s6, s6
    or s6, s10, s6
    add t6, t6, a1
    add t6, t6, s6
    add t6, t6, s10
    add t6, t6, s6
    add tp, tp, a1
    sltu a1, tp, a1
    add tp, tp, s9
    sltu s9, tp, s9
    or a1, a1, s9
    add t6, t6, tp
    add t6, t6, a1
    add t6, t6, s9
    add t6, t6, a6
    sub t2, ra, t2
    sltu s11, ra, t2
    sub ra, t2, s1
    sltu s1, t2, ra
    or t2, s1, s11
    add t6, t6, ra
    add t6, t6, t2
    add t6, t6, s1
    add t6, t6, s11
    sub a6, tp, a6
    sltu tp, tp, a6
    sub tp, a6, s8
    sltu s8, a6, tp
    or a6, s8, tp
    add t6, t6, tp
    add t6, t6, a6
    add t6, t6, s8
    add t6, t6, tp
    add t4, t4, a7
    sltu a7, t4, a7
    add t4, t4, s5
    sltu s5, t4, s5
    or a7, a7, s5
    add t6, t6, t4
    add t6, t6, a7
    add t6, t6, s5
    add t6, t6, t0
    sub s5, s9, s5
    sltu s9, s9, s5
    sub s9, s5, zero
    sltu zero, s5, s9
    or s5, zero, s9
    add t6, t6, a3
    add t6, t6, s5
    add t6, t6, zero
    add t6, t6, s9
    sub s0, t5, s0
    sltu s0, t5, s0
    sub t5, s0, tp
    sltu tp, s0, t5
    or s0, tp, s0
    add t6, t6, t5
    add t6, t6, s0
    add t6, t6, tp
    add t6, t6, s0
    sub s2, t5, s2
    sltu t1, t5, s2
    sub t5, s2, tp
    sltu tp, s2, t5
    or s2, tp, t1
    add t6, t6, t5
    add t6, t6, s2
    add t6, t6, tp
    add t6, t6, t1
    add zero, zero, t4
    sltu t4, zero, t4
    add zero, zero, s6
    sltu s6, zero, s6
    or t4, t4, s6
    add t6, t6, zero
    add t6, t6, t4
    add t6, t6, s6
    add t6, t6, a6
    add t0, t0, t4
    sltu t4, t0, t4
    add t0, t0, s4
    sltu s4, t0, s4
    or t4, t4, s4
    add t6, t6, t0
    add t6, t6, t4
    add t6, t6, s4
    add t6, t6, s10
    sub sp, s1, sp
    sltu a0, s1, sp
    sub s1, sp, s2
    sltu s2, sp, s1
    or sp, s2, a0
    add t6, t6, s1
    add t6, t6, sp
    add t6, t6, s2
    add t6, t6, a0
    add t3, t3, s11
    sltu s11, t3, s11
    add t3, t3, s4
    sltu s4, t3, s4
    or s11, s11, s4
    add t6, t6, t3
    add t6, t6, s11
    add t6, t6, s4
    add t6, t6, sp
    sub gp, t2, gp
    sltu a3, t2, gp
    sub t2, gp, a2
    sltu a2, gp, t2
    or gp, a2, a3
    add t6, t6, t2
    add t6, t6, gp
    add t6, t6, a2
    add t6, t6, a3
    sub tp, sp, tp
    sltu a1, sp, tp
    sub sp, tp, s8
    sltu s8, tp, sp
    or tp, s8, a1
    add t6, t6, sp
    add t6, t6, tp
    add t6, t6, s8
    add t6, t6, a1
    add s11, s11, s5
    sltu s5, s11, s5
    add s11, s11, a1
    sltu a1, s11, a1
    or s5, s5, a1
    add t6, t6, s11
    add t6, t6, s5
    add t6, t6, a1
    add t6, t6, s9
    add tp, tp, t1
    sltu t1, tp, t1
    add tp, tp, s5
    sltu s5, tp, s5
    or t1, t1, s5
    add t6, t6, tp
    add t6, t6, t1
    add t6, t6, s5
    add t6, t6, a4
    sub s1, t5, s1
    sltu s3, t5, s1
    sub t5, s1, s6
    sltu s6, s1, t5
    or s1, s6, s3
    add t6, t6, t5
    add t6, t6, s1
    add t6, t6, s6
    add t6, t6, s3
    sub s5, s4, s5
    sltu s4, s4, s5
    sub s4, s5, t4
    sltu t4, s5, s4
    or s5, t4, s4
    add t6, t6, a3
    add t6, t6, s5
    add t6, t6, t4
    add t6, t6, s4
    add ra, ra, a0
    sltu a0, ra, a0
    add ra, ra, sp
    sltu sp, ra, sp
    or a0, a0, sp
    add t6, t6, ra
    add t6, t6, a0
    add t6, t6, sp
    add t6, t6, a3
    sub a5, s7, a5
    sltu a4, s7, a5
    sub s7, a5, a7
    sltu a7, a5, s7
    or a5, a7, a4
    add t6, t6, s7
    add t6, t6, a5
    add t6, t6, a7
    add t6, t6, a4
    add sp, sp, zero
    sltu zero, sp, zero
    add sp, sp, t4
    sltu t4, sp, t4
    or zero, zero, t4
    add t6, t6, sp
    add t6, t6, zero
    add t6, t6, t4
    add t6, t6, zero
    add t2, t2, s10
    sltu s10, t2, s10
    add t2, t2, sp
    sltu sp, t2, sp
    or s10, s10, sp
    add t6, t6, t2
    add t6, t6, s10
    add t6, t6, sp
    add t6, t6, t5
    sub s8, a0, s8
    sltu sp, a0, s8
    sub a0, s8, s9
    sltu s9, s8, a0
    or s8, s9, sp
    add t6, t6, a0
    add t6, t6, s8
    add t6, t6, s9
    add t6, t6, sp
    sub a1, s10, a1
    sltu a1, s10, a1
    sub s10, a1, s8
    sltu s8, a1, s10
    or a1, s8, a1
    add t6, t6, s10
    add t6, t6, a1
    add t6, t6, s8
    add t6, t6, a1
    add s4, s4, s4
    sltu s4, s4, s4
    add s4, s4, s4
    sltu s4, s4, s4
    or s4, s4, s4
    add t6, t6, a1
    add t6, t6, a2
    add t6, t6, s4
    add t6, t6, ra
    add ra, ra, s1
    sltu s1, ra, s1
    add ra, ra, t2
    sltu t2, ra, t2
    or s1, s1, t2
    add t6, t6, ra
    add t6, t6, s1
    add t6, t6, t2
    add t6, t6, a1
    add s9, s9, s9
    sltu s9, s9, s9
    add s9, s9, tp
    sltu tp, s9, tp
    or s9, s9, tp
    add t6, t6, a1
    add t6, t6, s9
    add t6, t6, tp
    add t6, t6, t0
    sub a4, s3, a4
    sltu gp, s3, a4
    sub s3, a4, s5
    sltu s5, a4, s3
    or a4, s5, gp
    add t6, t6, s3
    add t6, t6, a4
    add t6, t6, s5
    add t6, t6, gp
    add s4, s4, s2
    sltu s2, s4, s2
    add s4, s4, sp
    sltu sp, s4, sp
    or s2, s2, sp
    add t6, t6, s4
    add t6, t6, s2
    add t6, t6, sp
    add t6, t6, s2
    add sp, sp, t4
    sltu t4, sp, t4
    add sp, sp, sp
    sltu sp, sp, sp
    or t4, t4, sp
    add t6, t6, a2
    add t6, t6, t4
    add t6, t6, sp
    add t6, t6, s10
    sub a0, t4, a0
    sltu t1, t4, a0
    sub t4, a0, s4
    sltu s4, a0, t4
    or a0, s4, t1
    add t6, t6, t4
    add t6, t6, a0
    add t6, t6, s4
    add t6, t6, t1
    sub s4, s11, s4
    sltu s11, s11, s4
    sub s11, s4, t5
    sltu t5, s4, s11
    or s4, t5, s11
    add t6, t6, s11
    add t6, t6, s4
    add t6, t6, t5
    add t6, t6, s11
    sub t5, a6, t5
    sltu t1, a6, t5
    sub a6, t5, a5
    sltu a5, t5, a6
    or t5, a5, t1
    add t6, t6, a6
    add t6, t6, t5
    add t6, t6, a5
    add t6, t6, t1
    sub s10, ra, s10
    sltu s2, ra, s10
    sub ra, s10, sp
    sltu sp, s10, ra
    or s10, sp, s2
    add t6, t6, ra
    add t6, t6, s10
    add t6, t6, sp
    add t6, t6, s2
    add s8, s8, a7
    sltu a7, s8, a7
    add s8, s8, a7
    sltu a7, s8, a7
    or a7, a7, a7
    add t6, t6, s8
    add t6, t6, a2
    add t6, t6, a7
    add t6, t6, s2
    add s1, s1, ra
    sltu ra, s1, ra
    add s1, s1, s6
    sltu s6, s1, s6
    or ra, ra, s6
    add t6, t6, a3
    add t6, t6, ra
    add t6, t6, s6
    add t6, t6, s1
    add t2, t2, sp
    sltu sp, t2, sp
    add t2, t2, a5
    sltu a5, t2, a5
    or sp, sp, a5
    add t6, t6, t2
    add t6, t6, sp
    add t6, t6, a5
    add t6, t6, t5
    add a1, a1, s6
    sltu s6, a1, s6
    add a1, a1, a1
    sltu a1, a1, a1
    or s6, s6, a1
    add t6, t6, a2
    add t6, t6, s6
    add t6, t6, a3
    add t6, t6, a1
    add a6, a6, sp
    sltu sp, a6, sp
    add a6, a6, t2
    sltu t2, a6, t2
    or sp, sp, t2
    add t6, t6, a6
    add t6, t6, sp
    add t6, t6, t2
    add t6, t6, t4
    sub t1, t1, t1
    sltu t2, t1, t1
    sub t1, t1, gp
    sltu gp, t1, t1
    or t1, gp, t2
    add t6, t6, t1
    add t6, t6, t1
    add t6, t6, gp
    add t6, t6, t2
    sub s10, s11, s10
    sltu t2, s11, s10
    sub s11, s10, s4
    sltu s4, s10, s11
    or s10, s4, t2
    add t6, t6, s11
    add t6, t6, s10
    add t6, t6, s4
    add t6, t6, t2
    sub s10, t0, s10
    sltu a3, t0, s10
    sub t0, s10, a1
    sltu a1, s10, t0
    or s10, a1, a3
    add t6, t6, t0
    add t6, t6, s10
    add t6, t6, a1
    add t6, t6, a3
    sub zero, zero, zero
    sltu s7, zero, zero
    sub zero, zero, s6
    sltu s6, zero, zero
    or zero, s6, s7
    add t6, t6, a1
    add t6, t6, zero
    add t6, t6, s6
    add t6, t6, s7
    sub s0, s11, s0
    sltu s8, s11, s0
    sub s11, s0, s1
    sltu s1, s0, s11
    or s0, s1, s8
    add t6, t6, s11
    add t6, t6, s0
    add t6, t6, s1
    add t6, t6, s8
    add t4, t4, s4
    sltu s4, t4, s4
    add t4, t4, s3
    sltu s3, t4, s3
    or s4, s4, s3
    add t6, t6, t4
    add t6, t6, s4
    add t6, t6, s3
    add t6, t6, s9
    sub a7, s0, a7
    sltu a2, s0, a7
    sub s0, a7, a5
    sltu a5, a7, s0
    or a7, a5, a2
    add t6, t6, s0
    add t6, t6, a7
    add t6, t6, a5
    add t6, t6, a2
    add t1, t1, t5
    sltu t5, t1, t5
    add t1, t1, a0
    sltu a0, t1, a0
    or t5, t5, a0
    add t6, t6, t1
    add t6, t6, t5
    add t6, t6, a0
    add t6, t6, a2
    add t2, t2, t5
    sltu t5, t2, t5
    add t2, t2, a4
    sltu a4, t2, a4
    or t5, t5, a4
    add t6, t6, t2
    add t6, t6, t5
    add t6, t6, a4
    add t6, t6, a3
    sub tp, s7, tp
    sltu a5, s7, tp
    sub s7, tp, a4
    sltu a4, tp, s7
    or tp, a4, a5
    add t6, t6, s7
    add t6, t6, tp
    add t6, t6, a4
    add t6, t6, a5
    sub s8, s1, s8
    sltu a3, s1, s8
    sub s1, s8, s8
    sltu s8, s8, s1
    or s8, s8, a3
    add t6, t6, s1
    add t6, t6, s8
    add t6, t6, s8
    add t6, t6, a3
    sub sp, s3, sp
    sltu t3, s3, sp
    sub s3, sp, a1
    sltu a1, sp, s3
    or sp, a1, t3
    add t6, t6, s3
    add t6, t6, sp
    add t6, t6, a1
    add t6, t6, t3
    add a7, a7, a7
    sltu a7, a7, a7
    add a7, a7, s6
    sltu s6, a7, s6
    or a7, a7, s6
    add t6, t6, a1
    add t6, t6, a7
    add t6, t6, s6
    add t6, t6, zero
    sub s0, s6, s0
    sltu s6, s6, s0
    sub s6, s0, t1
    sltu t1, s0, s6
    or s0, t1, s6
    add t6, t6, s6
    add t6, t6, s0
    add t6, t6, t1
    add t6, t6, s6
    add s9, s9, s6
    sltu s6, s9, s6
    add s9, s9, t2
    sltu t2, s9, t2
    or s6, s6, t2
    add t6, t6, s9
    add t6, t6, s6
    add t6, t6, t2
    add t6, t6, s11
    sub s1, s2, s1
    sltu s0, s2, s1
    sub s2, s1, t5
    sltu t5, s1, s2
    or s1, t5, s0
    add t6, t6, s2
    add t6, t6, s1
    add t6, t6, t5
    add t6, t6, s0
    add t3, t3, s9
    sltu s9, t3, s9
    add t3, t3, a6
    sltu a6, t3, a6
    or s9, s9, a6
    add t6, t6, t3
    add t6, t6, s9
    add t6, t6, a6
    add t6, t6, t2
    add s3, s3, s0
    sltu s0, s3, s0
    add s3, s3, a6
    sltu a6, s3, a6
    or s0, s0, a6
    add t6, t6, s3
    add t6, t6, s0
    add t6, t6, a6
    add t6, t6, a7
    add s11, s11, s3
    sltu s3, s11, s3
    add s11, s11, s3
    sltu s3, s11, s3
    or s3, s3, s3
    add t6, t6, s11
    add t6, t6, s3
    add t6, t6, s3
    add t6, t6, t3
    add s11, s11, t0
    sltu t0, s11, t0
    add s11, s11, a6
    sltu a6, s11, a6
    or t0, t0, a6
    add t6, t6, s11
    add t6, t6, t0
    add t6, t6, a6
    add t6, t6, a6
    add a7, a7, t3
    sltu t3, a7, t3
    add a7, a7, gp
    sltu gp, a7, gp
    or t3, t3, gp
    add t6, t6, a7
    add t6, t6, t3
    add t6, t6, gp
    add t6, t6, s3
    sub a0, s10, a0
    sltu s6, s10, a0
    sub s10, a0, s6
    sltu s6, a0, s10
    or a0, s6, s6
    add t6, t6, s10
    add t6, t6, a0
    add t6, t6, s6
    add t6, t6, s6
    sub t0, s2, t0
    sltu s1, s2, t0
    sub s2, t0, t0
    sltu t0, t0, s2
    or t0, t0, s1
    add t6, t6, s2
    add t6, t6, t0
    add t6, t6, t0
    add t6, t6, s1
    sub t3, ra, t3
    sltu t3, ra, t3
    sub ra, t3, s5
    sltu s5, t3, ra
    or t3, s5, t3
    add t6, t6, ra
    add t6, t6, t3
    add t6, t6, s5
    add t6, t6, t3
    sub a6, s11, a6
    sltu a4, s11, a6
    sub s11, a6, a4
    sltu a4, a6, s11
    or a6, a4, a4
    add t6, t6, s11
    add t6, t6, a6
    add t6, t6, a3
    add t6, t6, a4
    add t4, t4, a1
    sltu a1, t4, a1
    add t4, t4, zero
    sltu zero, t4, zero
    or a1, a1, zero
    add t6, t6, t4
    add t6, t6, a1
    add t6, t6, zero
    add t6, t6, a5
    sub sp, s0, sp
    sltu sp, s0, sp
    sub s0, sp, t2
    sltu t2, sp, s0
    or sp, t2, sp
    add t6, t6, s0
    add t6, t6, a3
    add t6, t6, t2
    add t6, t6, sp
    sub a7, s9, a7
    sltu s4, s9, a7
    sub s9, a7, gp
    sltu gp, a7, s9
    or a7, gp, s4
    add t6, t6, s9
    add t6, t6, a7
    add t6, t6, gp
    add t6, t6, s4
    add tp, tp, a7
    sltu a7, tp, a7
    add tp, tp, s7
    sltu s7, tp, s7
    or a7, a7, s7
    add t6, t6, tp
    add t6, t6, a7
    add t6, t6, s7
    add t6, t6, a2
    add s4, s4, s8
    sltu s8, s4, s8
    add s4, s4, t3
    sltu t3, s4, t3
    or s8, s8, t3
    add t6, t6, s4
    add t6, t6, s8
    add t6, t6, t3
    add t6, t6, ra
    add s11, s11, t1
    sltu t1, s11, t1
    add s11, s11, gp
    sltu gp, s11, gp
    or t1, t1, gp
    add t6, t6, s11
    add t6, t6, t1
    add t6, t6, gp
    add t6, t6, gp
    add s5, s5, t4
    sltu t4, s5, t4
    add s5, s5, s10
    sltu s10, s5, s10
    or t4, t4, s10
    add t6, t6, s5
    add t6, t6, t4
    add t6, t6, s10
    add t6, t6, a3
    add t2, t2, t1
    sltu t1, t2, t1
    add t2, t2, s2
    sltu s2, t2, s2
    or t1, t1, s2
    add t6, t6, t2
    add t6, t6, t1
    add t6, t6, s2
    add t6, t6, t4
    add a4, a4, a5
    sltu a5, a4, a5
    add a4, a4, s11
    sltu s11, a4, s11
    or a5, a5, s11
    add t6, t6, a4
    add t6, t6, a5
    add t6, t6, s11
    add t6, t6, s3
    sub a0, s9, a0
    sltu sp, s9, a0
    sub s9, a0, gp
    sltu gp, a0, s9
    or a0, gp, sp
    add t6, t6, s9
    add t6, t6, a0
    add t6, t6, gp
    add t6, t6, sp
    sub s0, s6, s0
    sltu s6, s6, s0
    sub s6, s0, t5
    sltu t5, s0, s6
    or s0, t5, s6
    add t6, t6, a3
    add t6, t6, s0
    add t6, t6, t5
    add t6, t6, s6
    sub a5, s2, a5
    sltu t2, s2, a5
    sub s2, a5, t3
    sltu t3, a5, s2
    or a5, t3, t2
    add t6, t6, s2
    add t6, t6, a5
    add t6, t6, t3
    add t6, t6, t2
    sub a6, s3, a6
    sltu ra, s3, a6
    sub s3, a6, s7
    sltu s7, a6, s3
    or a6, s7, ra
    add t6, t6, s3
    add t6, t6, a6
    add t6, t6, s7
    add t6, t6, ra
    add s7, s7, t5
    sltu t5, s7, t5
    add s7, s7, s5
    sltu s5, s7, s5
    or t5, t5, s5
    add t6, t6, s7
    add t6, t6, t5
    add t6, t6, s5
    add t6, t6, a7
    add t3, t3, a1
    sltu a1, t3, a1
    add t3, t3, ra
    sltu ra, t3, ra
    or a1, a1, ra
    add t6, t6, t3
    add t6, t6, a1
    add t6, t6, a3
    add t6, t6, ra
    sub a4, t1, a4
    sltu a7, t1, a4
    sub t1, a4, a7
    sltu a7, a4, t1
    or a4, a7, a7
    add t6, t6, t1
    add t6, t6, a4
    add t6, t6, a3
    add t6, t6, a7
    sub a5, s10, a5
    sltu tp, s10, a5
    sub s10, a5, a2
    sltu a2, a5, s10
    or a5, a2, tp
    add t6, t6, s10
    add t6, t6, a5
    add t6, t6, a2
    add t6, t6, tp
    sub tp, s5, tp
    sltu s7, s5, tp
    sub s5, tp, s4
    sltu s4, tp, s5
    or tp, s4, s7
    add t6, t6, s5
    add t6, t6, tp
    add t6, t6, s4
    add t6, t6, s7
    add t5, t5, t0
    sltu t0, t5, t0
    add t5, t5, s6
    sltu s6, t5, s6
    or t0, t0, s6
    add t6, t6, t5
    add t6, t6, t0
    add t6, t6, s6
    add t6, t6, a2
    add s5, s5, t0
    sltu t0, s5, t0
    add s5, s5, tp
    sltu tp, s5, tp
    or t0, t0, tp
    add t6, t6, s5
    add t6, t6, t0
    add t6, t6, tp
    add t6, t6, a6
    add s6, s6, a0
    sltu a0, s6, a0
    add s6, s6, s2
    sltu s2, s6, s2
    or a0, a0, s2
    add t6, t6, s6
    add t6, t6, a0
    add t6, t6, s2
    add t6, t6, s11
    sub s8, s6, s8
    sltu s6, s6, s8
    sub s6, s8, s2
    sltu s2, s8, s6
    or s8, s2, s6
    add t6, t6, s6
    add t6, t6, s8
    add t6, t6, s2
    add t6, t6, s6
    add t3, t3, t3
    sltu t3, t3, t3
    add t3, t3, a7
    sltu a7, t3, a7
    or t3, t3, a7
    add t6, t6, t3
    add t6, t6, t3
    add t6, t6, a7
    add t6, t6, t0
    add gp, gp, a6
    sltu a6, gp, a6
    add gp, gp, s11
    sltu s11, gp, s11
    or a6, a6, s11
    add t6, t6, gp
    add t6, t6, a6
    add t6, t6, s11
    add t6, t6, s11
    sub a1, s1, a1
    sltu t4, s1, a1
    sub s1, a1, s4
    sltu s4, a1, s1
    or a1, s4, t4
    add t6, t6, s1
    add t6, t6, a1
    add t6, t6, s4
    add t6, t6, t4
    sub tp, s8, tp
    sltu s8, s8, tp
    sub s8, tp, a2
    sltu a2, tp, s8
    or tp, a2, s8
    add t6, t6, a3
    add t6, t6, tp
    add t6, t6, a2
    add t6, t6, s8
    add s1, s1, t4
    sltu t4, s1, t4
    add s1, s1, t1
    sltu t1, s1, t1
    or t4, t4, t1
    add t6, t6, s1
    add t6, t6, t4
    add t6, t6, t1
    add t6, t6, s8
    add t2, t2, s7
    sltu s7, t2, s7
    add t2, t2, a7
    sltu a7, t2, a7
    or s7, s7, a7
    add t6, t6, t2
    add t6, t6, s7
    add t6, t6, a7
    add t6, t6, s10
    add t4, t4, t0
    sltu t0, t4, t0
    add t4, t4, s0
    sltu s0, t4, s0
    or t0, t0, s0
    add t6, t6, t4
    add t6, t6, t0
    add t6, t6, s0
    add t6, t6, t2
    sub a7, s9, a7
    sltu s7, s9, a7
    sub s9, a7, t2
    sltu t2, a7, s9
    or a7, t2, s7
    add t6, t6, s9
    add t6, t6, a7
    add t6, t6, t2
    add t6, t6, s7
    add gp, gp, t2
    sltu t2, gp, t2
    add gp, gp, gp
    sltu gp, gp, gp
    or t2, t2, gp
    add t6, t6, a2
    add t6, t6, t2
    add t6, t6, gp
    add t6, t6, t1
    sub s4, s4, s4
    sltu s0, s4, s4
    sub s4, s4, s1
    sltu s1, s4, s4
    or s4, s1, s0
    add t6, t6, a1
    add t6, t6, s4
    add t6, t6, s1
    add t6, t6, s0
    sub s8, s2, s8
    sltu t4, s2, s8
    sub s2, s8, t4
    sltu t4, s8, s2
    or s8, t4, t4
    add t6, t6, s2
    add t6, t6, s8
    add t6, t6, a3
    add t6, t6, t4
    add s0, s0, a0
    sltu a0, s0, a0
    add s0, s0, s0
    sltu s0, s0, s0
    or a0, a0, s0
    add t6, t6, a2
    add t6, t6, a0
    add t6, t6, s0
    add t6, t6, t0
    sub a1, s2, a1
    sltu a4, s2, a1
    sub s2, a1, a4
    sltu a4, a1, s2
    or a1, a4, a4
    add t6, t6, s2
    add t6, t6, a1
    add t6, t6, a3
    add t6, t6, a4
    add s7, s7, s0
    sltu s0, s7, s0
    add s7, s7, a0
    sltu a0, s7, a0
    or s0, s0, a0
    add t6, t6, s7
    add t6, t6, s0
    add t6, t6, a0
    add t6, t6, tp
    sub zero, a4, zero
    sltu s8, a4, zero
    sub a4, zero, s3
    sltu s3, zero, a4
    or zero, s3, s8
    add t6, t6, a4
    add t6, t6, zero
    add t6, t6, s3
    add t6, t6, s8
    sub a1, s8, a1
    sltu gp, s8, a1
    sub s8, a1, a2
    sltu a2, a1, s8
    or a1, a2, gp
    add t6, t6, s8
    add t6, t6, a1
    add t6, t6, a2
    add t6, t6, gp
    sub s11, s2, s11
    sltu s3, s2, s11
    sub s2, s11, gp
    sltu gp, s11, s2
    or s11, gp, s3
    add t6, t6, s2
    add t6, t6, s11
    add t6, t6, gp
    add t6, t6, s3
    add t0, t0, a7
    sltu a7, t0, a7
    add t0, t0, a7
    sltu a7, t0, a7
    or a7, a7, a7
    add t6, t6, t0
    add t6, t6, a2
    add t6, t6, a7
    add t6, t6, sp
    add a0, a0, s11
    sltu s11, a0, s11
    add a0, a0, a0
    sltu a0, a0, a0
    or s11, s11, a0
    add t6, t6, a0
    add t6, t6, s11
    add t6, t6, a0
    add t6, t6, s4
    add t4, t4, t3
    sltu t3, t4, t3
    add t4, t4, t3
    sltu t3, t4, t3
    or t3, t3, t3
    add t6, t6, t4
    add t6, t6, t3
    add t6, t6, t3
    add t6, t6, ra
    sub t4, s2, t4
    sltu t3, s2, t4
    sub s2, t4, t5
    sltu t5, t4, s2
    or t4, t5, t3
    add t6, t6, s2
    add t6, t6, t4
    add t6, t6, t5
    add t6, t6, t3
    sub zero, s1, zero
    sltu tp, s1, zero
    sub s1, zero, t4
    sltu t4, zero, s1
    or zero, t4, tp
    add t6, t6, s1
    add t6, t6, zero
    add t6, t6, t4
    add t6, t6, tp
    add t3, t3, s3
    sltu s3, t3, s3
    add t3, t3, s1
    sltu s1, t3, s1
    or s3, s3, s1
    add t6, t6, t3
    add t6, t6, s3
    add t6, t6, s1
    add t6, t6, s11
    add s1, s1, a4
    sltu a4, s1, a4
    add s1, s1, s3
    sltu s3, s1, s3
    or a4, a4, s3
    add t6, t6, s1
    add t6, t6, a4
    add t6, t6, s3
    add t6, t6, s6
    add t1, t1, t1
    sltu t1, t1, t1
    add t1, t1, ra
    sltu ra, t1, ra
    or t1, t1, ra
    add t6, t6, a1
    add t6, t6, t1
    add t6, t6, ra
    add t6, t6, s2
    sub s10, sp, s10
    sltu a3, sp, s10
    sub sp, s10, a0
    sltu a0, s10, sp
    or s10, a0, a3
    add t6, t6, sp
    add t6, t6, s10
    add t6, t6, a0
    add t6, t6, a3
    sub s3, s5, s3
    sltu ra, s5, s3
    sub s5, s3, s5
    sltu s5, s3, s5
    or s3, s5, ra
    add t6, t6, s5
    add t6, t6, s3
    add t6, t6, s5
    add t6, t6, ra
    add ra, ra, t3
    sltu t3, ra, t3
    add ra, ra, s2
    sltu s2, ra, s2
    or t3, t3, s2
    add t6, t6, ra
    add t6, t6, t3
    add t6, t6, s2
    add t6, t6, a1
    add gp, gp, s7
    sltu s7, gp, s7
    add gp, gp, t3
    sltu t3, gp, t3
    or s7, s7, t3
    add t6, t6, gp
    add t6, t6, s7
    add t6, t6, t3
    add t6, t6, t2
    add a5, a5, t5
    sltu t5, a5, t5
    add a5, a5, s11
    sltu s11, a5, s11
    or t5, t5, s11
    add t6, t6, a5
    add t6, t6, t5
    add t6, t6, s11
    add t6, t6, s11
    sub t4, zero, t4
    sltu sp, zero, t4
    sub zero, t4, s0
    sltu s0, t4, zero
    or t4, s0, sp
    add t6, t6, zero
    add t6, t6, t4
    add t6, t6, s0
    add t6, t6, sp
    add s2, s2, a7
    sltu a7, s2, a7
    add s2, s2, s5
    sltu s5, s2, s5
    or a7, a7, s5
    add t6, t6, a3
    add t6, t6, a7
    add t6, t6, s5
    add t6, t6, s2
    sub s5, a7, s5
    sltu t1, a7, s5
    sub a7, s5, a4
    sltu a4, s5, a7
    or s5, a4, t1
    add t6, t6, a7
    add t6, t6, s5
    add t6, t6, a4
    add t6, t6, t1
    sub s3, sp, s3
    sltu s4, sp, s3
    sub sp, s3, s5
    sltu s5, s3, sp
    or s3, s5, s4
    add t6, t6, sp
    add t6, t6, s3
    add t6, t6, s5
    add t6, t6, s4
    add a4, a4, sp
    sltu sp, a4, sp
    add a4, a4, a4
    sltu a4, a4, a4
    or sp, sp, a4
    add t6, t6, a4
    add t6, t6, sp
    add t6, t6, a4
    add t6, t6, s11
    add s10, s10, a1
    sltu a1, s10, a1
    add s10, s10, a1
    sltu a1, s10, a1
    or a1, a1, a1
    add t6, t6, s10
    add t6, t6, a2
    add t6, t6, a1
    add t6, t6, a1
    sub s1, ra, s1
    sltu t4, ra, s1
    sub ra, s1, s4
    sltu s4, s1, ra
    or s1, s4, t4
    add t6, t6, ra
    add t6, t6, s1
    add t6, t6, s4
    add t6, t6, t4
    sub t1, zero, t1
    sltu t1, zero, t1
    sub zero, t1, t4
    sltu t4, t1, zero
    or t1, t4, t1
    add t6, t6, zero
    add t6, t6, t1
    add t6, t6, t4
    add t6, t6, t1
    add ra, ra, s4
    sltu s4, ra, s4
    add ra, ra, a1
    sltu a1, ra, a1
    or s4, s4, a1
    add t6, t6, ra
    add t6, t6, s4
    add t6, t6, a1
    add t6, t6, s3
    sub s7, s9, s7
    sltu t1, s9, s7
    sub s9, s7, a4
    sltu a4, s7, s9
    or s7, a4, t1
    add t6, t6, s9
    add t6, t6, s7
    add t6, t6, a4
    add t6, t6, t1
    sub s10, a5, s10
    sltu a5, a5, s10
    sub a5, s10, t1
    sltu t1, s10, a5
    or s10, t1, a5
    add t6, t6, a3
    add t6, t6, s10
    add t6, t6, t1
    add t6, t6, a5
    sub s8, a5, s8
    sltu s11, a5, s8
    sub a5, s8, s2
    sltu s2, s8, a5
    or s8, s2, s11
    add t6, t6, a5
    add t6, t6, s8
    add t6, t6, s2
    add t6, t6, s11
    add s5, s5, t5
    sltu t5, s5, t5
    add s5, s5, t1
    sltu t1, s5, t1
    or t5, t5, t1
    add t6, t6, s5
    add t6, t6, t5
    add t6, t6, t1
    add t6, t6, zero
    add t4, t4, a1
    sltu a1, t4, a1
    add t4, t4, a0
    sltu a0, t4, a0
    or a1, a1, a0
    add t6, t6, t4
    add t6, t6, a1
    add t6, t6, a0
    add t6, t6, t5
    sub s4, s9, s4
    sltu s1, s9, s4
    sub s9, s4, a7
    sltu a7, s4, s9
    or s4, a7, s1
    add t6, t6, s9
    add t6, t6, s4
    add t6, t6, a7
    add t6, t6, s1
    sub s6, t5, s6
    sltu t3, t5, s6
    sub t5, s6, s0
    sltu s0, s6, t5
    or s6, s0, t3
    add t6, t6, t5
    add t6, t6, s6
    add t6, t6, s0
    add t6, t6, t3
    add t3, t3, s0
    sltu s0, t3, s0
    add t3, t3, a5
    sltu a5, t3, a5
    or s0, s0, a5
    add t6, t6, t3
    add t6, t6, s0
    add t6, t6, a5
    add t6, t6, ra
    sub a4, s0, a4
    sltu s10, s0, a4
    sub s0, a4, ra
    sltu ra, a4, s0
    or a4, ra, s10
    add t6, t6, s0
    add t6, t6, a4
    add t6, t6, ra
    add t6, t6, s10
    add s8, s8, s5
    sltu s5, s8, s5
    add s8, s8, s5
    sltu s5, s8, s5
    or s5, s5, s5
    add t6, t6, s8
    add t6, t6, s5
    add t6, t6, s5
    add t6, t6, s7
    sub s8, s8, s8
    sltu t3, s8, s8
    sub s8, s8, a1
    sltu a1, s8, s8
    or s8, a1, t3
    add t6, t6, a1
    add t6, t6, s8
    add t6, t6, a1
    add t6, t6, t3
    add a5, a5, s6
    sltu s6, a5, s6
    add a5, a5, a0
    sltu a0, a5, a0
    or s6, s6, a0
    add t6, t6, a3
    add t6, t6, s6
    add t6, t6, a0
    add t6, t6, a5
    sub a7, sp, a7
    sltu t2, sp, a7
    sub sp, a7, s4
    sltu s4, a7, sp
    or a7, s4, t2
    add t6, t6, sp
    add t6, t6, a7
    add t6, t6, s4
    add t6, t6, t2
    sub s5, t1, s5
    sltu gp, t1, s5
    sub t1, s5, t0
    sltu t0, s5, t1
    or s5, t0, gp
    add t6, t6, t1
    add t6, t6, s5
    add t6, t6, t0
    add t6, t6, gp
    add a7, a7, s6
    sltu s6, a7, s6
    add a7, a7, sp
    sltu sp, a7, sp
    or s6, s6, sp
    add t6, t6, a7
    add t6, t6, s6
    add t6, t6, a3
    add t6, t6, sp
    sub a4, a7, a4
    sltu s3, a7, a4
    sub a7, a4, s3
    sltu s3, a4, a7
    or a4, s3, s3
    add t6, t6, a7
    add t6, t6, a4
    add t6, t6, s3
    add t6, t6, s3
    sub s4, a5, s4
    sltu s3, a5, s4
    sub a5, s4, s3
    sltu s3, s4, a5
    or s4, s3, s3
    add t6, t6, a5
    add t6, t6, s4
    add t6, t6, a3
    add t6, t6, s3
    add s7, s7, t4
    sltu t4, s7, t4
    add s7, s7, s0
    sltu s0, s7, s0
    or t4, t4, s0
    add t6, t6, s7
    add t6, t6, t4
    add t6, t6, s0
    add t6, t6, s11
    add t3, t3, s10
    sltu s10, t3, s10
    add t3, t3, tp
    sltu tp, t3, tp
    or s10, s10, tp
    add t6, t6, t3
    add t6, t6, s10
    add t6, t6, tp
    add t6, t6, s0
    add t3, t3, ra
    sltu ra, t3, ra
    add t3, t3, a4
    sltu a4, t3, a4
    or ra, ra, a4
    add t6, t6, t3
    add t6, t6, ra
    add t6, t6, a4
    add t6, t6, t1
    add t3, t3, gp
    sltu gp, t3, gp
    add t3, t3, s2
    sltu s2, t3, s2
    or gp, gp, s2
    add t6, t6, t3
    add t6, t6, gp
    add t6, t6, s2
    add t6, t6, s1
    sub a4, t4, a4
    sltu s11, t4, a4
    sub t4, a4, a6
    sltu a6, a4, t4
    or a4, a6, s11
    add t6, t6, t4
    add t6, t6, a4
    add t6, t6, a6
    add t6, t6, s11
    add s3, s3, s2
    sltu s2, s3, s2
    add s3, s3, a4
    sltu a4, s3, a4
    or s2, s2, a4
    add t6, t6, s3
    add t6, t6, s2
    add t6, t6, a4
    add t6, t6, s3
    sub s1, t5, s1
    sltu s1, t5, s1
    sub t5, s1, s6
    sltu s6, s1, t5
    or s1, s6, s1
    add t6, t6, t5
    add t6, t6, s1
    add t6, t6, s6
    add t6, t6, s1
    sub a5, sp, a5
    sltu t2, sp, a5
    sub sp, a5, a4
    sltu a4, a5, sp
    or a5, a4, t2
    add t6, t6, sp
    add t6, t6, a5
    add t6, t6, a4
    add t6, t6, t2
    add ra, ra, s9
    sltu s9, ra, s9
    add ra, ra, s9
    sltu s9, ra, s9
    or s9, s9, s9
    add t6, t6, ra
    add t6, t6, a2
    add t6, t6, s9
    add t6, t6, t3
    sub t3, s3, t3
    sltu a7, s3, t3
    sub s3, t3, s8
    sltu s8, t3, s3
    or t3, s8, a7
    add t6, t6, s3
    add t6, t6, t3
    add t6, t6, s8
    add t6, t6, a7
    add t3, t3, ra
    sltu ra, t3, ra
    add t3, t3, s5
    sltu s5, t3, s5
    or ra, ra, s5
    add t6, t6, t3
    add t6, t6, ra
    add t6, t6, s5
    add t6, t6, gp
    add gp, gp, a1
    sltu a1, gp, a1
    add gp, gp, a5
    sltu a5, gp, a5
    or a1, a1, a5
    add t6, t6, gp
    add t6, t6, a1
    add t6, t6, a5
    add t6, t6, s4
    sub s10, s5, s10
    sltu s4, s5, s10
    sub s5, s10, s5
    sltu s5, s10, s5
    or s10, s5, s4
    add t6, t6, a2
    add t6, t6, s10
    add t6, t6, s5
    add t6, t6, s4
    add sp, sp, a1
    sltu a1, sp, a1
    add sp, sp, sp
    sltu sp, sp, sp
    or a1, a1, sp
    add t6, t6, a2
    add t6, t6, a1
    add t6, t6, sp
    add t6, t6, t1
    add zero, zero, t1
    sltu t1, zero, t1
    add zero, zero, ra
    sltu ra, zero, ra
    or t1, t1, ra
    add t6, t6, zero
    add t6, t6, t1
    add t6, t6, ra
    add t6, t6, t3
    sub t2, gp, t2
    sltu a7, gp, t2
    sub gp, t2, s9
    sltu s9, t2, gp
    or t2, s9, a7
    add t6, t6, gp
    add t6, t6, t2
    add t6, t6, s9
    add t6, t6, a7
    add a0, a0, zero
    sltu zero, a0, zero
    add a0, a0, s0
    sltu s0, a0, s0
    or zero, zero, s0
    add t6, t6, a0
    add t6, t6, zero
    add t6, t6, s0
    add t6, t6, t1
    add s7, s7, s8
    sltu s8, s7, s8
    add s7, s7, t3
    sltu t3, s7, t3
    or s8, s8, t3
    add t6, t6, s7
    add t6, t6, s8
    add t6, t6, t3
    add t6, t6, a0
    add s8, s8, a7
    sltu a7, s8, a7
    add s8, s8, s7
    sltu s7, s8, s7
    or a7, a7, s7
    add t6, t6, a3
    add t6, t6, a7
    add t6, t6, s7
    add t6, t6, s8
    sub s10, s7, s10
    sltu a1, s7, s10
    sub s7, s10, s6
    sltu s6, s10, s7
    or s10, s6, a1
    add t6, t6, s7
    add t6, t6, s10
    add t6, t6, s6
    add t6, t6, a1
    add s1, s1, t3
    sltu t3, s1, t3
    add s1, s1, a0
    sltu a0, s1, a0
    or t3, t3, a0
    add t6, t6, s1
    add t6, t6, a3
    add t6, t6, a0
    add t6, t6, t3
    add a0, a0, a0
    sltu a0, a0, a0
    add a0, a0, s9
    sltu s9, a0, s9
    or a0, a0, s9
    add t6, t6, a1
    add t6, t6, a0
    add t6, t6, s9
    add t6, t6, ra
    sub t4, a7, t4
    sltu s11, a7, t4
    sub a7, t4, s3
    sltu s3, t4, a7
    or t4, s3, s11
    add t6, t6, a7
    add t6, t6, t4
    add t6, t6, s3
    add t6, t6, s11
    sub ra, s6, ra
    sltu ra, s6, ra
    sub s6, ra, s1
    sltu s1, ra, s6
    or ra, s1, ra
    add t6, t6, s6
    add t6, t6, ra
    add t6, t6, s1
    add t6, t6, ra
    add a6, a6, a4
    sltu a4, a6, a4
    add a6, a6, s1
    sltu s1, a6, s1
    or a4, a4, s1
    add t6, t6, a6
    add t6, t6, a4
    add t6, t6, a3
    add t6, t6, s1
    add t0, t0, tp
    sltu tp, t0, tp
    add t0, t0, t2
    sltu t2, t0, t2
    or tp, tp, t2
    add t6, t6, t0
    add t6, t6, tp
    add t6, t6, t2
    add t6, t6, s2
    sub sp, tp, sp
    sltu gp, tp, sp
    sub tp, sp, tp
    sltu tp, sp, tp
    or sp, tp, gp
    add t6, t6, a2
    add t6, t6, sp
    add t6, t6, tp
    add t6, t6, gp
    sub s11, a0, s11
    sltu s3, a0, s11
    sub a0, s11, t0
    sltu t0, s11, a0
    or s11, t0, s3
    add t6, t6, a0
    add t6, t6, s11
    add t6, t6, t0
    add t6, t6, s3
    sub gp, a4, gp
    sltu s5, a4, gp
    sub a4, gp, s2
    sltu s2, gp, a4
    or gp, s2, s5
    add t6, t6, a4
    add t6, t6, gp
    add t6, t6, s2
    add t6, t6, s5
    add s10, s10, a0
    sltu a0, s10, a0
    add s10, s10, tp
    sltu tp, s10, tp
    or a0, a0, tp
    add t6, t6, s10
    add t6, t6, a3
    add t6, t6, tp
    add t6, t6, a0
    add a7, a7, a0
    sltu a0, a7, a0
    add a7, a7, a4
    sltu a4, a7, a4
    or a0, a0, a4
    add t6, t6, a7
    add t6, t6, a0
    add t6, t6, a4
    add t6, t6, s6
    add s5, s5, a4
    sltu a4, s5, a4
    add s5, s5, s7
    sltu s7, s5, s7
    or a4, a4, s7
    add t6, t6, s5
    add t6, t6, a4
    add t6, t6, s7
    add t6, t6, s0
    sub a7, t2, a7
    sltu a1, t2, a7
    sub t2, a7, t3
    sltu t3, a7, t2
    or a7, t3, a1
    add t6, t6, t2
    add t6, t6, a7
    add t6, t6, t3
    add t6, t6, a1
    add a6, a6, a0
    sltu a0, a6, a0
    add a6, a6, a4
    sltu a4, a6, a4
    or a0, a0, a4
    add t6, t6, a6
    add t6, t6, a0
    add t6, t6, a4
    add t6, t6, t5
    add t2, t2, a1
    sltu a1, t2, a1
    add t2, t2, s0
    sltu s0, t2, s0
    or a1, a1, s0
    add t6, t6, t2
    add t6, t6, a1
    add t6, t6, a3
    add t6, t6, s0
    sub t4, s7, t4
    sltu tp, s7, t4
    sub s7, t4, t2
    sltu t2, t4, s7
    or t4, t2, tp
    add t6, t6, s7
    add t6, t6, t4
    add t6, t6, t2
    add t6, t6, tp
    sub s9, s9, s9
    sltu a1, s9, s9
    sub s9, s9, s4
    sltu s4, s9, s9
    or s9, s4, a1
    add t6, t6, a1
    add t6, t6, s9
    add t6, t6, s4
    add t6, t6, a1
    sub t4, a5, t4
    sltu tp, a5, t4
    sub a5, t4, a4
    sltu a4, t4, a5
    or t4, a4, tp
    add t6, t6, a5
    add t6, t6, t4
    add t6, t6, a4
    add t6, t6, tp
    sub t1, s6, t1
    sltu t5, s6, t1
    sub s6, t1, s6
    sltu s6, t1, s6
    or t1, s6, t5
    add t6, t6, a2
    add t6, t6, t1
    add t6, t6, s6
    add t6, t6, t5
    sub a0, a6, a0
    sltu a7, a6, a0
    sub a6, a0, s7
    sltu s7, a0, a6
    or a0, s7, a7
    add t6, t6, a6
    add t6, t6, a0
    add t6, t6, s7
    add t6, t6, a7
    sub s7, t2, s7
    sltu gp, t2, s7
    sub t2, s7, t2
    sltu t2, s7, t2
    or s7, t2, gp
    add t6, t6, t2
    add t6, t6, s7
    add t6, t6, t2
    add t6, t6, gp
    sub s9, t2, s9
    sltu t4, t2, s9
    sub t2, s9, s4
    sltu s4, s9, t2
    or s9, s4, t4
    add t6, t6, t2
    add t6, t6, s9
    add t6, t6, s4
    add t6, t6, t4
    sub s11, t3, s11
    sltu s8, t3, s11
    sub t3, s11, sp
    sltu sp, s11, t3
    or s11, sp, s8
    add t6, t6, t3
    add t6, t6, s11
    add t6, t6, sp
    add t6, t6, s8
    sub gp, tp, gp
    sltu ra, tp, gp
    sub tp, gp, a2
    sltu a2, gp, tp
    or gp, a2, ra
    add t6, t6, tp
    add t6, t6, gp
    add t6, t6, a2
    add t6, t6, ra
    sub s11, tp, s11
    sltu sp, tp, s11
    sub tp, s11, s11
    sltu s11, s11, tp
    or s11, s11, sp
    add t6, t6, tp
    add t6, t6, a2
    add t6, t6, s11
    add t6, t6, sp
    sub sp, a5, sp
    sltu a4, a5, sp
    sub a5, sp, t0
    sltu t0, sp, a5
    or sp, t0, a4
    add t6, t6, a5
    add t6, t6, sp
    add t6, t6, t0
    add t6, t6, a4
    add s8, s8, ra
    sltu ra, s8, ra
    add s8, s8, zero
    sltu zero, s8, zero
    or ra, ra, zero
    add t6, t6, s8
    add t6, t6, ra
    add t6, t6, zero
    add t6, t6, t1
    add s1, s1, a7
    sltu a7, s1, a7
    add s1, s1, a2
    sltu a2, s1, a2
    or a7, a7, a2
    add t6, t6, s1
    add t6, t6, a7
    add t6, t6, a2
    add t6, t6, a6
    sub t5, s2, t5
    sltu s4, s2, t5
    sub s2, t5, s5
    sltu s5, t5, s2
    or t5, s5, s4
    add t6, t6, s2
    add t6, t6, t5
    add t6, t6, s5
    add t6, t6, s4
    sub s11, a5, s11
    sltu t2, a5, s11
    sub a5, s11, t2
    sltu t2, s11, a5
    or s11, t2, t2
    add t6, t6, a5
    add t6, t6, s11
    add t6, t6, a3
    add t6, t6, t2
    add zero, zero, a1
    sltu a1, zero, a1
    add zero, zero, t4
    sltu t4, zero, t4
    or a1, a1, t4
    add t6, t6, zero
    add t6, t6, a1
    add t6, t6, t4
    add t6, t6, gp
    add s10, s10, a4
    sltu a4, s10, a4
    add s10, s10, s11
    sltu s11, s10, s11
    or a4, a4, s11
    add t6, t6, s10
    add t6, t6, a4
    add t6, t6, s11
    add t6, t6, s2
    add sp, sp, s9
    sltu s9, sp, s9
    add sp, sp, s3
    sltu s3, sp, s3
    or s9, s9, s3
    add t6, t6, sp
    add t6, t6, s9
    add t6, t6, s3
    add t6, t6, a4
    add a4, a4, a1
    sltu a1, a4, a1
    add a4, a4, s10
    sltu s10, a4, s10
    or a1, a1, s10
    add t6, t6, a4
    add t6, t6, a1
    add t6, t6, s10
    add t6, t6, a1
    sub a5, a7, a5
    sltu a4, a7, a5
    sub a7, a5, t3
    sltu t3, a5, a7
    or a5, t3, a4
    add t6, t6, a7
    add t6, t6, a5
    add t6, t6, t3
    add t6, t6, a4
    add a1, a1, s8
    sltu s8, a1, s8
    add a1, a1, a1
    sltu a1, a1, a1
    or s8, s8, a1
    add t6, t6, a2
    add t6, t6, s8
    add t6, t6, a1
    add t6, t6, a0
    sub a5, t1, a5
    sltu s0, t1, a5
    sub t1, a5, sp
    sltu sp, a5, t1
    or a5, sp, s0
    add t6, t6, t1
    add t6, t6, a5
    add t6, t6, sp
    add t6, t6, s0
    add s6, s6, tp
    sltu tp, s6, tp
    add s6, s6, t3
    sltu t3, s6, t3
    or tp, tp, t3
    add t6, t6, s6
    add t6, t6, tp
    add t6, t6, t3
    add t6, t6, a7
    sub s3, sp, s3
    sltu sp, sp, s3
    sub sp, s3, sp
    sltu sp, s3, sp
    or s3, sp, sp
    add t6, t6, a3
    add t6, t6, s3
    add t6, t6, sp
    add t6, t6, sp
    add s0, s0, t1
    sltu t1, s0, t1
    add s0, s0, a7
    sltu a7, s0, a7
    or t1, t1, a7
    add t6, t6, s0
    add t6, t6, t1
    add t6, t6, a7
    add t6, t6, t0
    sub t4, tp, t4
    sltu t3, tp, t4
    sub tp, t4, a2
    sltu a2, t4, tp
    or t4, a2, t3
    add t6, t6, tp
    add t6, t6, t4
    add t6, t6, a2
    add t6, t6, t3
    add s8, s8, s6
    sltu s6, s8, s6
    add s8, s8, a1
    sltu a1, s8, a1
    or s6, s6, a1
    add t6, t6, s8
    add t6, t6, a3
    add t6, t6, a1
    add t6, t6, s6
    add s7, s7, s0
    sltu s0, s7, s0
    add s7, s7, s9
    sltu s9, s7, s9
    or s0, s0, s9
    add t6, t6, s7
    add t6, t6, s0
    add t6, t6, s9
    add t6, t6, t1
    add s11, s11, t2
    sltu t2, s11, t2
    add s11, s11, ra
    sltu ra, s11, ra
    or t2, t2, ra
    add t6, t6, s11
    add t6, t6, a3
    add t6, t6, ra
    add t6, t6, t2
    sub t5, t3, t5
    sltu a7, t3, t5
    sub t3, t5, s4
    sltu s4, t5, t3
    or t5, s4, a7
    add t6, t6, t3
    add t6, t6, t5
    add t6, t6, s4
    add t6, t6, a7
    sub s6, a5, s6
    sltu s4, a5, s6
    sub a5, s6, gp
    sltu gp, s6, a5
    or s6, gp, s4
    add t6, t6, a5
    add t6, t6, s6
    add t6, t6, gp
    add t6, t6, s4
    sub t0, t5, t0
    sltu ra, t5, t0
    sub t5, t0, s0
    sltu s0, t0, t5
    or t0, s0, ra
    add t6, t6, t5
    add t6, t6, t0
    add t6, t6, s0
    add t6, t6, ra
    sub a7, t2, a7
    sltu a7, t2, a7
    sub t2, a7, s7
    sltu s7, a7, t2
    or a7, s7, a7
    add t6, t6, t2
    add t6, t6, a3
    add t6, t6, s7
    add t6, t6, a7
    sub s9, t4, s9
    sltu a5, t4, s9
    sub t4, s9, a5
    sltu a5, s9, t4
    or s9, a5, a5
    add t6, t6, t4
    add t6, t6, s9
    add t6, t6, a3
    add t6, t6, a5
    add s0, s0, s10
    sltu s10, s0, s10
    add s0, s0, s0
    sltu s0, s0, s0
    or s10, s10, s0
    add t6, t6, a2
    add t6, t6, s10
    add t6, t6, s0
    add t6, t6, s10
    sub s5, a5, s5
    sltu sp, a5, s5
    sub a5, s5, s6
    sltu s6, s5, a5
    or s5, s6, sp
    add t6, t6, a5
    add t6, t6, s5
    add t6, t6, s6
    add t6, t6, sp
    sub s5, t1, s5
    sltu sp, t1, s5
    sub t1, s5, zero
    sltu zero, s5, t1
    or s5, zero, sp
    add t6, t6, t1
    add t6, t6, s5
    add t6, t6, zero
    add t6, t6, sp
    sub s0, s6, s0
    sltu s8, s6, s0
    sub s6, s0, sp
    sltu sp, s0, s6
    or s0, sp, s8
    add t6, t6, s6
    add t6, t6, s0
    add t6, t6, sp
    add t6, t6, s8
    sub a1, ra, a1
    sltu t4, ra, a1
    sub ra, a1, s9
    sltu s9, a1, ra
    or a1, s9, t4
    add t6, t6, ra
    add t6, t6, a1
    add t6, t6, s9
    add t6, t6, t4
    sub s3, t4, s3
    sltu a5, t4, s3
    sub t4, s3, s11
    sltu s11, s3, t4
    or s3, s11, a5
    add t6, t6, t4
    add t6, t6, s3
    add t6, t6, s11
    add t6, t6, a5
    sub s8, s10, s8
    sltu t4, s10, s8
    sub s10, s8, t5
    sltu t5, s8, s10
    or s8, t5, t4
    add t6, t6, s10
    add t6, t6, s8
    add t6, t6, t5
    add t6, t6, t4
    sub s7, a5, s7
    sltu t4, a5, s7
    sub a5, s7, tp
    sltu tp, s7, a5
    or s7, tp, t4
    add t6, t6, a5
    add t6, t6, s7
    add t6, t6, tp
    add t6, t6, t4
    sub s9, t3, s9
    sltu t2, t3, s9
    sub t3, s9, a2
    sltu a2, s9, t3
    or s9, a2, t2
    add t6, t6, t3
    add t6, t6, s9
    add t6, t6, a2
    add t6, t6, t2
    add a6, a6, s2
    sltu s2, a6, s2
    add a6, a6, t4
    sltu t4, a6, t4
    or s2, s2, t4
    add t6, t6, a6
    add t6, t6, s2
    add t6, t6, t4
    add t6, t6, sp
    add sp, sp, t4
    sltu t4, sp, t4
    add sp, sp, sp
    sltu sp, sp, sp
    or t4, t4, sp
    add t6, t6, sp
    add t6, t6, t4
    add t6, t6, sp
    add t6, t6, s0
    add s8, s8, a0
    sltu a0, s8, a0
    add s8, s8, t4
    sltu t4, s8, t4
    or a0, a0, t4
    add t6, t6, s8
    add t6, t6, a0
    add t6, t6, t4
    add t6, t6, s1
    sub s9, s10, s9
    sltu s5, s10, s9
    sub s10, s9, t2
    sltu t2, s9, s10
    or s9, t2, s5
    add t6, t6, s10
    add t6, t6, s9
    add t6, t6, t2
    add t6, t6, s5
    add s6, s6, a7
    sltu a7, s6, a7
    add s6, s6, s11
    sltu s11, s6, s11
    or a7, a7, s11
    add t6, t6, s6
    add t6, t6, a7
    add t6, t6, s11
    add t6, t6, t1
    add t4, t4, s6
    sltu s6, t4, s6
    add t4, t4, a7
    sltu a7, t4, a7
    or s6, s6, a7
    add t6, t6, t4
    add t6, t6, s6
    add t6, t6, a7
    add t6, t6, t1
    sub gp, a4, gp
    sltu a5, a4, gp
    sub a4, gp, a1
    sltu a1, gp, a4
    or gp, a1, a5
    add t6, t6, a4
    add t6, t6, gp
    add t6, t6, a1
    add t6, t6, a5
    sub zero, s0, zero
    sltu t3, s0, zero
    sub s0, zero, s11
    sltu s11, zero, s0
    or zero, s11, t3
    add t6, t6, s0
    add t6, t6, zero
    add t6, t6, s11
    add t6, t6, t3
    add t4, t4, s0
    sltu s0, t4, s0
    add t4, t4, s7
    sltu s7, t4, s7
    or s0, s0, s7
    add t6, t6, t4
    add t6, t6, s0
    add t6, t6, s7
    add t6, t6, t2
    add tp, tp, a5
    sltu a5, tp, a5
    add tp, tp, a2
    sltu a2, tp, a2
    or a5, a5, a2
    add t6, t6, tp
    add t6, t6, a5
    add t6, t6, a2
    add t6, t6, t1
    add a0, a0, s11
    sltu s11, a0, s11
    add a0, a0, s1
    sltu s1, a0, s1
    or s11, s11, s1
    add t6, t6, a0
    add t6, t6, s11
    add t6, t6, s1
    add t6, t6, s10
    sub s9, s8, s9
    sltu a7, s8, s9
    sub s8, s9, t4
    sltu t4, s9, s8
    or s9, t4, a7
    add t6, t6, s8
    add t6, t6, s9
    add t6, t6, t4
    add t6, t6, a7
    sub tp, a5, tp
    sltu sp, a5, tp
    sub a5, tp, s5
    sltu s5, tp, a5
    or tp, s5, sp
    add t6, t6, a5
    add t6, t6, tp
    add t6, t6, s5
    add t6, t6, sp
    add s11, s11, t0
    sltu t0, s11, t0
    add s11, s11, s6
    sltu s6, s11, s6
    or t0, t0, s6
    add t6, t6, s11
    add t6, t6, t0
    add t6, t6, s6
    add t6, t6, t0
    sub s7, gp, s7
    sltu gp, gp, s7
    sub gp, s7, t3
    sltu t3, s7, gp
    or s7, t3, gp
    add t6, t6, gp
    add t6, t6, s7
    add t6, t6, t3
    add t6, t6, gp
    sub t1, s4, t1
    sltu a1, s4, t1
    sub s4, t1, gp
    sltu gp, t1, s4
    or t1, gp, a1
    add t6, t6, s4
    add t6, t6, t1
    add t6, t6, gp
    add t6, t6, a1
    add tp, tp, a6
    sltu a6, tp, a6
    add tp, tp, a0
    sltu a0, tp, a0
    or a6, a6, a0
    add t6, t6, tp
    add t6, t6, a6
    add t6, t6, a0
    add t6, t6, t2
    add s1, s1, ra
    sltu ra, s1, ra
    add s1, s1, ra
    sltu ra, s1, ra
    or ra, ra, ra
    add t6, t6, s1
    add t6, t6, a2
    add t6, t6, ra
    add t6, t6, s7
    sub t4, t3, t4
    sltu s4, t3, t4
    sub t3, t4, a0
    sltu a0, t4, t3
    or t4, a0, s4
    add t6, t6, t3
    add t6, t6, t4
    add t6, t6, a0
    add t6, t6, s4
    add a4, a4, a7
    sltu a7, a4, a7
    add a4, a4, s6
    sltu s6, a4, s6
    or a7, a7, s6
    add t6, t6, a4
    add t6, t6, a7
    add t6, t6, s6
    add t6, t6, s7
    sub s8, t5, s8
    sltu s7, t5, s8
    sub t5, s8, a5
    sltu a5, s8, t5
    or s8, a5, s7
    add t6, t6, t5
    add t6, t6, s8
    add t6, t6, a5
    add t6, t6, s7
    sub t1, s0, t1
    sltu s10, s0, t1
    sub s0, t1, tp
    sltu tp, t1, s0
    or t1, tp, s10
    add t6, t6, s0
    add t6, t6, t1
    add t6, t6, tp
    add t6, t6, s10
    add s0, s0, s5
    sltu s5, s0, s5
    add s0, s0, a7
    sltu a7, s0, a7
    or s5, s5, a7
    add t6, t6, s0
    add t6, t6, s5
    add t6, t6, a3
    add t6, t6, a7
    add a6, a6, a5
    sltu a5, a6, a5
    add a6, a6, t3
    sltu t3, a6, t3
    or a5, a5, t3
    add t6, t6, a6
    add t6, t6, a5
    add t6, t6, t3
    add t6, t6, s5
    sub sp, s9, sp
    sltu t2, s9, sp
    sub s9, sp, t5
    sltu t5, sp, s9
    or sp, t5, t2
    add t6, t6, s9
    add t6, t6, sp
    add t6, t6, t5
    add t6, t6, t2
    add s0, s0, a7
    sltu a7, s0, a7
    add s0, s0, s9
    sltu s9, s0, s9
    or a7, a7, s9
    add t6, t6, s0
    add t6, t6, a7
    add t6, t6, s9
    add t6, t6, a6
    add s4, s4, s4
    sltu s4, s4, s4
    add s4, s4, t1
    sltu t1, s4, t1
    or s4, s4, t1
    add t6, t6, s4
    add t6, t6, s4
    add t6, t6, t1
    add t6, t6, a7
    sub s11, sp, s11
    sltu s2, sp, s11
    sub sp, s11, s11
    sltu s11, s11, sp
    or s11, s11, s2
    add t6, t6, sp
    add t6, t6, a2
    add t6, t6, s11
    add t6, t6, s2
    sub a4, sp, a4
    sltu s6, sp, a4
    sub sp, a4, a1
    sltu a1, a4, sp
    or a4, a1, s6
    add t6, t6, sp
    add t6, t6, a4
    add t6, t6, a1
    add t6, t6, s6
    add a4, a4, a4
    sltu a4, a4, a4
    add a4, a4, s2
    sltu s2, a4, s2
    or a4, a4, s2
    add t6, t6, a4
    add t6, t6, a4
    add t6, t6, s2
    add t6, t6, s11
    add s7, s7, t5
    sltu t5, s7, t5
    add s7, s7, s7
    sltu s7, s7, s7
    or t5, t5, s7
    add t6, t6, a2
    add t6, t6, t5
    add t6, t6, s7
    add t6, t6, a6
    sub ra, zero, ra
    sltu a1, zero, ra
    sub zero, ra, gp
    sltu gp, ra, zero
    or ra, gp, a1
    add t6, t6, zero
    add t6, t6, ra
    add t6, t6, gp
    add t6, t6, a1
    sub s7, t0, s7
    sltu gp, t0, s7
    sub t0, s7, s10
    sltu s10, s7, t0
    or s7, s10, gp
    add t6, t6, t0
    add t6, t6, s7
    add t6, t6, s10
    add t6, t6, gp
    sub ra, a0, ra
    sltu s0, a0, ra
    sub a0, ra, a4
    sltu a4, ra, a0
    or ra, a4, s0
    add t6, t6, a0
    add t6, t6, ra
    add t6, t6, a4
    add t6, t6, s0
    sub t4, t2, t4
    sltu s9, t2, t4
    sub t2, t4, s9
    sltu s9, t4, t2
    or t4, s9, s9
    add t6, t6, t2
    add t6, t6, t4
    add t6, t6, a3
    add t6, t6, s9
    add s8, s8, a0
    sltu a0, s8, a0
    add s8, s8, a4
    sltu a4, s8, a4
    or a0, a0, a4
    add t6, t6, s8
    add t6, t6, a0
    add t6, t6, a4
    add t6, t6, s5
    add s3, s3, a7
    sltu a7, s3, a7
    add s3, s3, t5
    sltu t5, s3, t5
    or a7, a7, t5
    add t6, t6, s3
    add t6, t6, a7
    add t6, t6, t5
    add t6, t6, s3
    add t1, t1, t4
    sltu t4, t1, t4
    add t1, t1, zero
    sltu zero, t1, zero
    or t4, t4, zero
    add t6, t6, t1
    add t6, t6, t4
    add t6, t6, zero
    add t6, t6, a1
    add sp, sp, s11
    sltu s11, sp, s11
    add sp, sp, s0
    sltu s0, sp, s0
    or s11, s11, s0
    add t6, t6, sp
    add t6, t6, s11
    add t6, t6, s0
    add t6, t6, sp
    sub s4, ra, s4
    sltu ra, ra, s4
    sub ra, s4, s4
    sltu s4, s4, ra
    or s4, s4, ra
    add t6, t6, ra
    add t6, t6, a2
    add t6, t6, s4
    add t6, t6, ra
    sub s0, t1, s0
    sltu gp, t1, s0
    sub t1, s0, s1
    sltu s1, s0, t1
    or s0, s1, gp
    add t6, t6, t1
    add t6, t6, s0
    add t6, t6, s1
    add t6, t6, gp
    add s1, s1, a6
    sltu a6, s1, a6
    add s1, s1, t3
    sltu t3, s1, t3
    or a6, a6, t3
    add t6, t6, s1
    add t6, t6, a6
    add t6, t6, t3
    add t6, t6, s3
    sub t5, s6, t5
    sltu a7, s6, t5
    sub s6, t5, t1
    sltu t1, t5, s6
    or t5, t1, a7
    add t6, t6, s6
    add t6, t6, t5
    add t6, t6, t1
    add t6, t6, a7
    sub s6, s8, s6
    sltu a7, s8, s6
    sub s8, s6, a5
    sltu a5, s6, s8
    or s6, a5, a7
    add t6, t6, s8
    add t6, t6, s6
    add t6, t6, a5
    add t6, t6, a7
    sub s8, t5, s8
    sltu a0, t5, s8
    sub t5, s8, a6
    sltu a6, s8, t5
    or s8, a6, a0
    add t6, t6, t5
    add t6, t6, s8
    add t6, t6, a6
    add t6, t6, a0
    sub t3, a0, t3
    sltu a7, a0, t3
    sub a0, t3, s1
    sltu s1, t3, a0
    or t3, s1, a7
    add t6, t6, a0
    add t6, t6, t3
    add t6, t6, s1
    add t6, t6, a7
    add s0, s0, s6
    sltu s6, s0, s6
    add s0, s0, a4
    sltu a4, s0, a4
    or s6, s6, a4
    add t6, t6, s0
    add t6, t6, s6
    add t6, t6, a4
    add t6, t6, s4
    add a5, a5, s3
    sltu s3, a5, s3
    add a5, a5, s10
    sltu s10, a5, s10
    or s3, s3, s10
    add t6, t6, a5
    add t6, t6, a3
    add t6, t6, s10
    add t6, t6, s3
    add t1, t1, a7
    sltu a7, t1, a7
    add t1, t1, t4
    sltu t4, t1, t4
    or a7, a7, t4
    add t6, t6, t1
    add t6, t6, a7
    add t6, t6, t4
    add t6, t6, s11
    add s5, s5, s1
    sltu s1, s5, s1
    add s5, s5, a4
    sltu a4, s5, a4
    or s1, s1, a4
    add t6, t6, s5
    add t6, t6, s1
    add t6, t6, a4
    add t6, t6, t2
    add s5, s5, s4
    sltu s4, s5, s4
    add s5, s5, s5
    sltu s5, s5, s5
    or s4, s4, s5
    add t6, t6, s5
    add t6, t6, s4
    add t6, t6, s5
    add t6, t6, ra
    add s10, s10, ra
    sltu ra, s10, ra
    add s10, s10, sp
    sltu sp, s10, sp
    or ra, ra, sp
    add t6, t6, s10
    add t6, t6, ra
    add t6, t6, sp
    add t6, t6, s2
    add sp, sp, t5
    sltu t5, sp, t5
    add sp, sp, a4
    sltu a4, sp, a4
    or t5, t5, a4
    add t6, t6, sp
    add t6, t6, a3
    add t6, t6, a4
    add t6, t6, t5
    add t4, t4, t3
    sltu t3, t4, t3
    add t4, t4, s0
    sltu s0, t4, s0
    or t3, t3, s0
    add t6, t6, t4
    add t6, t6, t3
    add t6, t6, s0
    add t6, t6, t4
    add s11, s11, ra
    sltu ra, s11, ra
    add s11, s11, a7
    sltu a7, s11, a7
    or ra, ra, a7
    add t6, t6, s11
    add t6, t6, ra
    add t6, t6, a7
    add t6, t6, a7
    add s4, s4, a7
    sltu a7, s4, a7
    add s4, s4, a7
    sltu a7, s4, a7
    or a7, a7, a7
    add t6, t6, s4
    add t6, t6, a2
    add t6, t6, a7
    add t6, t6, s9
    add t4, t4, s7
    sltu s7, t4, s7
    add t4, t4, a7
    sltu a7, t4, a7
    or s7, s7, a7
    add t6, t6, t4
    add t6, t6, s7
    add t6, t6, a7
    add t6, t6, tp
    sub a7, t0, a7
    sltu s0, t0, a7
    sub t0, a7, ra
    sltu ra, a7, t0
    or a7, ra, s0
    add t6, t6, t0
    add t6, t6, a7
    add t6, t6, ra
    add t6, t6, s0
    add s9, s9, s4
    sltu s4, s9, s4
    add s9, s9, t3
    sltu t3, s9, t3
    or s4, s4, t3
    add t6, t6, s9
    add t6, t6, s4
    add t6, t6, t3
    add t6, t6, s8
    sub zero, s4, zero
    sltu a3, s4, zero
    sub s4, zero, s9
    sltu s9, zero, s4
    or zero, s9, a3
    add t6, t6, s4
    add t6, t6, zero
    add t6, t6, s9
    add t6, t6, a3
    sub s3, a5, s3
    sltu ra, a5, s3
    sub a5, s3, t2
    sltu t2, s3, a5
    or s3, t2, ra
    add t6, t6, a5
    add t6, t6, s3
    add t6, t6, t2
    add t6, t6, ra
    sub s11, s2, s11
    sltu tp, s2, s11
    sub s2, s11, zero
    sltu zero, s11, s2
    or s11, zero, tp
    add t6, t6, s2
    add t6, t6, s11
    add t6, t6, zero
    add t6, t6, tp
    add a5, a5, s8
    sltu s8, a5, s8
    add a5, a5, s6
    sltu s6, a5, s6
    or s8, s8, s6
    add t6, t6, a5
    add t6, t6, s8
    add t6, t6, s6
    add t6, t6, a1
    add a6, a6, t5
    sltu t5, a6, t5
    add a6, a6, s6
    sltu s6, a6, s6
    or t5, t5, s6
    add t6, t6, a6
    add t6, t6, t5
    add t6, t6, s6
    add t6, t6, a6
    add t5, t5, sp
    sltu sp, t5, sp
    add t5, t5, a2
    sltu a2, t5, a2
    or sp, sp, a2
    add t6, t6, t5
    add t6, t6, sp
    add t6, t6, a2
    add t6, t6, t4
    sub t1, s1, t1
    sltu tp, s1, t1
    sub s1, t1, t1
    sltu t1, t1, s1
    or t1, t1, tp
    add t6, t6, s1
    add t6, t6, a2
    add t6, t6, t1
    add t6, t6, tp
    add t1, t1, s9
    sltu s9, t1, s9
    add t1, t1, s10
    sltu s10, t1, s10
    or s9, s9, s10
    add t6, t6, t1
    add t6, t6, s9
    add t6, t6, s10
    add t6, t6, s10
    add t2, t2, s11
    sltu s11, t2, s11
    add t2, t2, t3
    sltu t3, t2, t3
    or s11, s11, t3
    add t6, t6, t2
    add t6, t6, s11
    add t6, t6, t3
    add t6, t6, sp
    sub t0, s8, t0
    sltu s9, s8, t0
    sub s8, t0, t3
    sltu t3, t0, s8
    or t0, t3, s9
    add t6, t6, s8
    add t6, t6, t0
    add t6, t6, t3
    add t6, t6, s9
    add s9, s9, s10
    sltu s10, s9, s10
    add s9, s9, zero
    sltu zero, s9, zero
    or s10, s10, zero
    add t6, t6, s9
    add t6, t6, s10
    add t6, t6, zero
    add t6, t6, s5
    sub s5, s2, s5
    sltu a4, s2, s5
    sub s2, s5, t5
    sltu t5, s5, s2
    or s5, t5, a4
    add t6, t6, s2
    add t6, t6, s5
    add t6, t6, t5
    add t6, t6, a4
    sub s8, gp, s8
    sltu a1, gp, s8
    sub gp, s8, s5
    sltu s5, s8, gp
    or s8, s5, a1
    add t6, t6, gp
    add t6, t6, s8
    add t6, t6, s5
    add t6, t6, a1
    add s6, s6, t2
    sltu t2, s6, t2
    add s6, s6, gp
    sltu gp, s6, gp
    or t2, t2, gp
    add t6, t6, a3
    add t6, t6, t2
    add t6, t6, gp
    add t6, t6, s6
    add t1, t1, t0
    sltu t0, t1, t0
    add t1, t1, s10
    sltu s10, t1, s10
    or t0, t0, s10
    add t6, t6, t1
    add t6, t6, t0
    add t6, t6, s10
    add t6, t6, s2
    add t3, t3, tp
    sltu tp, t3, tp
    add t3, t3, zero
    sltu zero, t3, zero
    or tp, tp, zero
    add t6, t6, a3
    add t6, t6, tp
    add t6, t6, zero
    add t6, t6, t3
    sub t5, s2, t5
    sltu s11, s2, t5
    sub s2, t5, s11
    sltu s11, t5, s2
    or t5, s11, s11
    add t6, t6, s2
    add t6, t6, t5
    add t6, t6, a3
    add t6, t6, s11
    add s5, s5, a6
    sltu a6, s5, a6
    add s5, s5, s9
    sltu s9, s5, s9
    or a6, a6, s9
    add t6, t6, s5
    add t6, t6, a6
    add t6, t6, s9
    add t6, t6, s0
    sub s11, tp, s11
    sltu a6, tp, s11
    sub tp, s11, s7
    sltu s7, s11, tp
    or s11, s7, a6
    add t6, t6, tp
    add t6, t6, s11
    add t6, t6, s7
    add t6, t6, a6
    add t3, t3, ra
    sltu ra, t3, ra
    add t3, t3, a2
    sltu a2, t3, a2
    or ra, ra, a2
    add t6, t6, t3
    add t6, t6, ra
    add t6, t6, a2
    add t6, t6, s4
    add s4, s4, s6
    sltu s6, s4, s6
    add s4, s4, a1
    sltu a1, s4, a1
    or s6, s6, a1
    add t6, t6, s4
    add t6, t6, s6
    add t6, t6, a1
    add t6, t6, a3
    sub t3, gp, t3
    sltu t4, gp, t3
    sub gp, t3, a6
    sltu a6, t3, gp
    or t3, a6, t4
    add t6, t6, gp
    add t6, t6, t3
    add t6, t6, a6
    add t6, t6, t4
    sub s10, s11, s10
    sltu a0, s11, s10
    sub s11, s10, s8
    sltu s8, s10, s11
    or s10, s8, a0
    add t6, t6, s11
    add t6, t6, s10
    add t6, t6, s8
    add t6, t6, a0
    sub s8, s1, s8
    sltu s2, s1, s8
    sub s1, s8, s8
    sltu s8, s8, s1
    or s8, s8, s2
    add t6, t6, s1
    add t6, t6, a2
    add t6, t6, s8
    add t6, t6, s2
    add t2, t2, zero
    sltu zero, t2, zero
    add t2, t2, t5
    sltu t5, t2, t5
    or zero, zero, t5
    add t6, t6, t2
    add t6, t6, zero
    add t6, t6, t5
    add t6, t6, s8
    add a4, a4, t2
    sltu t2, a4, t2
    add a4, a4, ra
    sltu ra, a4, ra
    or t2, t2, ra
    add t6, t6, a4
    add t6, t6, t2
    add t6, t6, ra
    add t6, t6, tp
    sub a4, s0, a4
    sltu s8, s0, a4
    sub s0, a4, a0
    sltu a0, a4, s0
    or a4, a0, s8
    add t6, t6, s0
    add t6, t6, a4
    add t6, t6, a0
    add t6, t6, s8
    add a5, a5, t2
    sltu t2, a5, t2
    add a5, a5, t1
    sltu t1, a5, t1
    or t2, t2, t1
    add t6, t6, a5
    add t6, t6, t2
    add t6, t6, t1
    add t6, t6, zero
    add a5, a5, sp
    sltu sp, a5, sp
    add a5, a5, a2
    sltu a2, a5, a2
    or sp, sp, a2
    add t6, t6, a5
    add t6, t6, sp
    add t6, t6, a2
    add t6, t6, zero
    add s9, s9, s10
    sltu s10, s9, s10
    add s9, s9, sp
    sltu sp, s9, sp
    or s10, s10, sp
    add t6, t6, s9
    add t6, t6, s10
    add t6, t6, sp
    add t6, t6, s7
    sub s4, t1, s4
    sltu gp, t1, s4
    sub t1, s4, t4
    sltu t4, s4, t1
    or s4, t4, gp
    add t6, t6, t1
    add t6, t6, s4
    add t6, t6, t4
    add t6, t6, gp
    sub s8, s0, s8
    sltu a0, s0, s8
    sub s0, s8, s10
    sltu s10, s8, s0
    or s8, s10, a0
    add t6, t6, s0
    add t6, t6, s8
    add t6, t6, s10
    add t6, t6, a0
    add a5, a5, s10
    sltu s10, a5, s10
    add a5, a5, s8
    sltu s8, a5, s8
    or s10, s10, s8
    add t6, t6, a5
    add t6, t6, s10
    add t6, t6, a3
    add t6, t6, s8
    sub s9, a6, s9
    sltu a1, a6, s9
    sub a6, s9, sp
    sltu sp, s9, a6
    or s9, sp, a1
    add t6, t6, a6
    add t6, t6, s9
    add t6, t6, sp
    add t6, t6, a1
    add ra, ra, tp
    sltu tp, ra, tp
    add ra, ra, s8
    sltu s8, ra, s8
    or tp, tp, s8
    add t6, t6, ra
    add t6, t6, tp
    add t6, t6, s8
    add t6, t6, s10
    add s6, s6, ra
    sltu ra, s6, ra
    add s6, s6, s6
    sltu s6, s6, s6
    or ra, ra, s6
    add t6, t6, a2
    add t6, t6, ra
    add t6, t6, s6
    add t6, t6, t2
    add zero, zero, s7
    sltu s7, zero, s7
    add zero, zero, sp
    sltu sp, zero, sp
    or s7, s7, sp
    add t6, t6, zero
    add t6, t6, s7
    add t6, t6, sp
    add t6, t6, tp
    sub s5, s2, s5
    sltu a7, s2, s5
    sub s2, s5, sp
    sltu sp, s5, s2
    or s5, sp, a7
    add t6, t6, s2
    add t6, t6, s5
    add t6, t6, sp
    add t6, t6, a7
    add sp, sp, s2
    sltu s2, sp, s2
    add sp, sp, s0
    sltu s0, sp, s0
    or s2, s2, s0
    add t6, t6, sp
    add t6, t6, s2
    add t6, t6, s0
    add t6, t6, s10
    add s10, s10, s0
    sltu s0, s10, s0
    add s10, s10, s10
    sltu s10, s10, s10
    or s0, s0, s10
    add t6, t6, a2
    add t6, t6, s0
    add t6, t6, s10
    add t6, t6, t0
    add ra, ra, t0
    sltu t0, ra, t0
    add ra, ra, s9
    sltu s9, ra, s9
    or t0, t0, s9
    add t6, t6, ra
    add t6, t6, t0
    add t6, t6, s9
    add t6, t6, a0
    add sp, sp, s5
    sltu s5, sp, s5
    add sp, sp, s3
    sltu s3, sp, s3
    or s5, s5, s3
    add t6, t6, sp
    add t6, t6, s5
    add t6, t6, s3
    add t6, t6, s4
    sub a4, ra, a4
    sltu tp, ra, a4
    sub ra, a4, a5
    sltu a5, a4, ra
    or a4, a5, tp
    add t6, t6, ra
    add t6, t6, a4
    add t6, t6, a5
    add t6, t6, tp
    sub zero, s0, zero
    sltu s0, s0, zero
    sub s0, zero, ra
    sltu ra, zero, s0
    or zero, ra, s0
    add t6, t6, a3
    add t6, t6, zero
    add t6, t6, ra
    add t6, t6, s0
    sub s10, t1, s10
    sltu a4, t1, s10
    sub t1, s10, s10
    sltu s10, s10, t1
    or s10, s10, a4
    add t6, t6, t1
    add t6, t6, s10
    add t6, t6, s10
    add t6, t6, a4
    add t5, t5, s10
    sltu s10, t5, s10
    add t5, t5, a2
    sltu a2, t5, a2
    or s10, s10, a2
    add t6, t6, t5
    add t6, t6, s10
    add t6, t6, a2
    add t6, t6, s8
    add zero, zero, s3
    sltu s3, zero, s3
    add zero, zero, t3
    sltu t3, zero, t3
    or s3, s3, t3
    add t6, t6, zero
    add t6, t6, a3
    add t6, t6, t3
    add t6, t6, s3
    add s4, s4, s0
    sltu s0, s4, s0
    add s4, s4, s11
    sltu s11, s4, s11
    or s0, s0, s11
    add t6, t6, s4
    add t6, t6, s0
    add t6, t6, s11
    add t6, t6, a1
    sub tp, zero, tp
    sltu gp, zero, tp
    sub zero, tp, t5
    sltu t5, tp, zero
    or tp, t5, gp
    add t6, t6, zero
    add t6, t6, tp
    add t6, t6, t5
    add t6, t6, gp
    sub s4, s5, s4
    sltu s6, s5, s4
    sub s5, s4, a2
    sltu a2, s4, s5
    or s4, a2, s6
    add t6, t6, s5
    add t6, t6, s4
    add t6, t6, a2
    add t6, t6, s6
    sub s6, zero, s6
    sltu a2, zero, s6
    sub zero, s6, zero
    sltu zero, s6, zero
    or s6, zero, a2
    add t6, t6, a2
    add t6, t6, s6
    add t6, t6, zero
    add t6, t6, a2
    sub a6, s2, a6
    sltu a4, s2, a6
    sub s2, a6, s5
    sltu s5, a6, s2
    or a6, s5, a4
    add t6, t6, s2
    add t6, t6, a6
    add t6, t6, s5
    add t6, t6, a4
    sub s5, sp, s5
    sltu s4, sp, s5
    sub sp, s5, sp
    sltu sp, s5, sp
    or s5, sp, s4
    add t6, t6, sp
    add t6, t6, s5
    add t6, t6, sp
    add t6, t6, s4
    add s2, s2, s2
    sltu s2, s2, s2
    add s2, s2, s10
    sltu s10, s2, s10
    or s2, s2, s10
    add t6, t6, a1
    add t6, t6, s2
    add t6, t6, s10
    add t6, t6, s10
    add t4, t4, t0
    sltu t0, t4, t0
    add t4, t4, t0
    sltu t0, t4, t0
    or t0, t0, t0
    add t6, t6, t4
    add t6, t6, a2
    add t6, t6, t0
    add t6, t6, s8
    add s11, s11, gp
    sltu gp, s11, gp
    add s11, s11, a4
    sltu a4, s11, a4
    or gp, gp, a4
    add t6, t6, s11
    add t6, t6, gp
    add t6, t6, a4
    add t6, t6, s0
    sub sp, s9, sp
    sltu a2, s9, sp
    sub s9, sp, s10
    sltu s10, sp, s9
    or sp, s10, a2
    add t6, t6, s9
    add t6, t6, sp
    add t6, t6, s10
    add t6, t6, a2
    sub t2, a7, t2
    sltu t4, a7, t2
    sub a7, t2, a4
    sltu a4, t2, a7
    or t2, a4, t4
    add t6, t6, a7
    add t6, t6, t2
    add t6, t6, a4
    add t6, t6, t4
    add s5, s5, s6
    sltu s6, s5, s6
    add s5, s5, a1
    sltu a1, s5, a1
    or s6, s6, a1
    add t6, t6, s5
    add t6, t6, s6
    add t6, t6, a1
    add t6, t6, s9
    sub gp, tp, gp
    sltu s8, tp, gp
    sub tp, gp, tp
    sltu tp, gp, tp
    or gp, tp, s8
    add t6, t6, a2
    add t6, t6, gp
    add t6, t6, tp
    add t6, t6, s8
    add s10, s10, a1
    sltu a1, s10, a1
    add s10, s10, s6
    sltu s6, s10, s6
    or a1, a1, s6
    add t6, t6, s10
    add t6, t6, a1
    add t6, t6, s6
    add t6, t6, s9
    sub s5, t3, s5
    sltu s7, t3, s5
    sub t3, s5, a6
    sltu a6, s5, t3
    or s5, a6, s7
    add t6, t6, t3
    add t6, t6, s5
    add t6, t6, a6
    add t6, t6, s7
    sub sp, s5, sp
    sltu gp, s5, sp
    sub s5, sp, s11
    sltu s11, sp, s5
    or sp, s11, gp
    add t6, t6, s5
    add t6, t6, sp
    add t6, t6, s11
    add t6, t6, gp

    li a0, 2117695688626081999
    bne a0, t6, fail

    li a0, 0
    li a7, 93
    ecall
fail:
    li a0, 1
    li a7, 93
    ecall


================================================
File: tests/programs/mop_sbb.S
================================================
.global _start
_start:
  li a0, 1
  li a1, 1
  li a2, 0xffffffffffffffff
  sub a1, a0, a1
  sltu a3, a0, a1
  sub a0, a1, a2
  sltu a2, a1, a0
  or a1, a2, a3
  li t0, 1
  bne a0, t0, fail
  li t0, 1
  bne a1, t0, fail
  li t0, 1
  bne a2, t0, fail
  li t0, 0
  bne a3, t0, fail

  li a0, 0
  li a1, 1
  li a2, 1
  sub a1, a0, a1
  sltu a3, a0, a1
  sub a0, a1, a2
  sltu a2, a1, a0
  or a1, a2, a3
  li t0, 0xfffffffffffffffe
  bne a0, t0, fail
  li t0, 1
  bne a1, t0, fail
  li t0, 0
  bne a2, t0, fail
  li t0, 1
  bne a3, t0, fail

  li a0, 0
  li a7, 93
  ecall
fail:
  li a0, 1
  li a7, 93
  ecall


================================================
File: tests/programs/mop_sbbs.S
================================================
.global _start
_start:
  li t1, 0x7fffffffffffffff
  li t2, 1
  sub t0, t1, t2
  sltu t3, t1, t2
  li s1, 0x7ffffffffffffffe
  li s0, 1
  bne t0, s1, fail
  li s1, 0
  li s0, 2
  bne t3, s1, fail

  li t1, 100
  li t2, 211
  sub t0, t1, t2
  sltu t3, t1, t2
  li s1, -111
  li s0, 3
  bne t0, s1, fail
  li s1, 1
  li s0, 4
  bne t3, s1, fail

  li t1, 0x7fffffffffffffff
  li t2, 1
  sub t0, t1, t2
  sltu t0, t1, t2
  li s1, 0
  li s0, 5
  bne t0, s1, fail

  li t0, 123123412312
  li t1, 0x7fffffffffffffff
  li t2, 1
  sub zero, t1, t2
  sltu t3, t1, t2
  li s1, 123123412312
  li s0, 6
  bne t0, s1, fail
  li s1, 0
  li s0, 7
  bne t3, s1, fail
  li s1, 0
  li s0, 8
  bne zero, s1, fail

  li t0, 32423423
  li t1, 0x7fffffffffffffff
  li t2, 1
  li t3, 1237128937
  sub zero, t1, t2
  sltu zero, t1, t2
  li s1, 32423423
  li s0, 9
  bne t0, s1, fail
  li s1, 0x7fffffffffffffff
  li s0, 10
  bne t1, s1, fail
  li s1, 1
  li s0, 11
  bne t2, s1, fail
  li s1, 1237128937
  li s0, 12
  bne t3, s1, fail
  li s1, 0
  li s0, 13
  bne zero, s1, fail

success:
  li a0, 0
  li a7, 93
  ecall
fail:
  li a0, 1
  li a7, 93
  ecall


================================================
File: tests/programs/mop_wide_div_zero.S
================================================
.global _start
_start:
  li a0, 10
  li a1, 3
  li a2, 0

  div a3, a0, a1
  rem zero, a0, a1
  bne a2, zero, fail

  divu a3, a0, a1
  rem zero, a0, a1
  bne a2, zero, fail

  li a0, 0
  li a7, 93
  ecall
fail:
  li a0, 1
  li a7, 93
  ecall


================================================
File: tests/programs/mop_wide_divide.c
================================================
#include <stdint.h>

uint64_t argc = 128;
uint64_t args[128] = {
  0x0000000000000000LL,
  0x0000000000000001LL,
  0xffffffffffffffffLL,
  0x8000000000000000LL,
  0x0000000000000004LL,
  0x0000000000000040LL,
  0x0000000000000080LL,
  0x0000000000002000LL,
  0x0000000000010000LL,
  0x0000000000400000LL,
  0x0000000001000000LL,
  0x0000000100000000LL,
  0x0000008000000000LL,
  0x0000020000000000LL,
  0x0000800000000000LL,
  0x0010000000000000LL,
  0x0100000000000000LL,
  0x1000000000000000LL,
  0x000000000000000dLL,
  0x0000000000000000LL,
  0x0000000000000067LL,
  0x2e00000000000000LL,
  0x000000000000015bLL,
  0x9420000000000000LL,
  0x00000000000075daLL,
  0xe35a000000000000LL,
  0x000000000003ed82LL,
  0x8b4eb00000000000LL,
  0x000000000000714cLL,
  0xfad4dc0000000000LL,
  0x000000000dd2966bLL,
  0x686f332000000000LL,
  0x00000000a865d7d4LL,
  0x6edd225600000000LL,
  0x0000000380f3cf69LL,
  0xaf29109cc0000000LL,
  0x000000a3714b9ad2LL,
  0x7dc2ae94e4000000LL,
  0x00000bea6a6af755LL,
  0xea2177d8d5100000LL,
  0x00004a9e26b7f794LL,
  0x6d159abfb3030000LL,
  0x00020e6dfbb7c441LL,
  0xd251a40a022b9000LL,
  0x00129af7f2440efeLL,
  0xc7dee68fffbaf900LL,
  0x05ada4e53975b451LL,
  0x63eb500cce126b70LL,
  0x314320aa7da5b1efLL,
  0xd27d2fde3497614cLL,
  0xbe55668178139c8eLL,
  0x9480583abdfb5837LL,
  0x9d8dbb3a5bde4347LL,
  0x61fd04828c93ce01LL,
  0xdf9a26c8470349ddLL,
  0xca9d54bd4e78980eLL,
  0xb1db9b0fecbfaabeLL,
  0xe79541e25d0dba6bLL,
  0xff98837fda2a5bdfLL,
  0xc3bd5e2cd52318a8LL,
  0x02ab7bb54e687499LL,
  0xbebf0929f41aa230LL,
  0x58aee9fdc3f41b74LL,
  0x62daff171a9fae42LL,
  0xe5baa16ee5b5419eLL,
  0x16b3a918e4278c9dLL,
  0x4ab9cfc9a41744c4LL,
  0x86ddce906c8cdb4dLL,
  0x867e3492977cb1bbLL,
  0x3d0e482377794618LL,
  0x90e1bc8ba22d3294LL,
  0xf48119b103954df1LL,
  0x79780d4e5b2b3b2aLL,
  0xb36eb1caa58ee7dcLL,
  0xf0fe55be95a18d13LL,
  0x1234769364d9eac9LL,
  0x31a7445bdf8bcb5cLL,
  0x1735808ee4398bcaLL,
  0x8f09996552504a5dLL,
  0x4fcf7212bebfdd89LL,
  0xdfd3a0870f60e072LL,
  0x25474d793f2c7d32LL,
  0xb9e2a99fdb7b2948LL,
  0x0da24e08451a8d1aLL,
  0x44a705073f90be80LL,
  0x7f2e6910bdea3ffdLL,
  0x7fc92593c865b4c2LL,
  0x0f812a265e560f2bLL,
  0xfecee737556609f5LL,
  0x996d1b60923c18a6LL,
  0x2c1fb5204d248917LL,
  0x4cf560811e3465c5LL,
  0xf2a6b292a535dc4eLL,
  0x3b4de2fabe6d6476LL,
  0xa6a669d1baba633eLL,
  0xa73c905bcbc01878LL,
  0x38be984c83ce8648LL,
  0x262a15662b298944LL,
  0xdf09e5c90a990b56LL,
  0xa8519a5b46242cc0LL,
  0x14d93f0c55095499LL,
  0xbad28e0ca5854070LL,
  0x93d7d7a9d87056f0LL,
  0x3b0d936889b10a5dLL,
  0x0ec6680cabb95f09LL,
  0x27429c30e8b6cff7LL,
  0x6465f271027abfa8LL,
  0xd0abd7d3688aa0d7LL,
  0x986a686578456056LL,
  0xc10a152d71cb3f16LL,
  0x4a6c986967d5ace8LL,
  0x37269c228e8e3db1LL,
  0xf5bad73c74be6d8aLL,
  0x68323fe289df33d1LL,
  0xcb9848f06e9659f6LL,
  0x5052886f7169c8c5LL,
  0xb040414dd8c98a14LL,
  0xea59a91078581c00LL,
  0x7c6bcb08155fac38LL,
  0xbd6192029dd91d60LL,
  0x8a4a182923bdf75aLL,
  0x8c91e2fe14041a34LL,
  0xc9d368e6546c1f00LL,
  0xdfd83d690e5f073eLL,
  0x34f2a050c605b6b0LL,
  0xf3fbe985738811ddLL,
  0x2d21e3da342cd6beLL,
  0x31523358d080e093LL
};

int64_t test_wide_divi_fusion(int64_t rs1, int64_t rs2) {
    int64_t rdr;
    int64_t rdq;
    int64_t expect_rdr;
    int64_t expect_rdq;

    register long t0 asm("t0") = rs1;
    register long t1 asm("t1") = rs2;

    asm volatile (
        "div %0, t0, t1\n"
        "nop\n"
        "rem %1, t0, t1\n"
        : "=r"(expect_rdq), "=r"(expect_rdr)
    );
    asm volatile (
        "div %0, t0, t1\n"
        "rem %1, t0, t1\n"
        : "=r"(rdq), "=r"(rdr)
    );
    if (rdr != expect_rdr || rdq != expect_rdq) {
        return 1;
    }
    return 0;
}

int64_t test_wide_divi_rdq_eq_rs1(int64_t rs1, int64_t rs2) {
    int64_t rdr;
    int64_t expect_rdr;

    register long t0 asm("t0") = rs1;
    register long t1 asm("t1") = rs2;

    asm volatile (
        "div t3, t0, t1\n"
        "rem %0, t3, t1\n"
        : "=r"(expect_rdr)
        :
        :"t3"
    );
    asm volatile (
        "div t0, t0, t1\n"
        "rem %0, t0, t1\n"
        : "=r"(rdr)
    );
    if (rdr != expect_rdr) {
        return 1;
    }
    return 0;
}

int64_t test_wide_divi_rdq_eq_rs2(int64_t rs1, int64_t rs2) {
    int64_t rdr;
    int64_t expect_rdr;

    register long t0 asm("t0") = rs1;
    register long t1 asm("t1") = rs2;

    asm volatile (
        "div t3, t0, t1\n"
        "rem %0, t0, t3\n"
        : "=r"(expect_rdr)
        :
        :"t3"
    );
    asm volatile (
        "div t1, t0, t1\n"
        "rem %0, t0, t1\n"
        : "=r"(rdr)
    );
    if (rdr != expect_rdr) {
        return 1;
    }
    return 0;
}

int64_t test_wide_divi_rdq_eq_rdr(int64_t rs1, int64_t rs2) {
    int64_t rdr;
    int64_t expect_rdr;

    register long t0 asm("t0") = rs1;
    register long t1 asm("t1") = rs2;

    asm volatile (
        "rem  %0, t0, t1\n"
        : "=r"(expect_rdr)
    );
    asm volatile (
        "div %0, t0, t1\n"
        "rem %0, t0, t1\n"
        : "=r"(rdr)
    );
    if (rdr != expect_rdr) {
        return 1;
    }
    return 0;
}

uint64_t test_wide_divu_fusion(uint64_t rs1, uint64_t rs2) {
    uint64_t rdr;
    uint64_t rdq;
    uint64_t expect_rdr;
    uint64_t expect_rdq;

    register long t0 asm("t0") = rs1;
    register long t1 asm("t1") = rs2;

    asm volatile (
        "divu %0, t0, t1\n"
        "nop\n"
        "remu %1, t0, t1\n"
        : "=r"(expect_rdq), "=r"(expect_rdr)
    );
    asm volatile (
        "divu %0, t0, t1\n"
        "remu %1, t0, t1\n"
        : "=r"(rdq), "=r"(rdr)
    );
    if (rdr != expect_rdr || rdq != expect_rdq) {
        return 1;
    }
    return 0;
}

uint64_t test_wide_divu_rdq_eq_rs1(uint64_t rs1, uint64_t rs2) {
    uint64_t rdr;
    uint64_t expect_rdr;

    register long t0 asm("t0") = rs1;
    register long t1 asm("t1") = rs2;

    asm volatile (
        "divu t3, t0, t1\n"
        "remu %0, t3, t1\n"
        : "=r"(expect_rdr)
        :
        :"t3"
    );
    asm volatile (
        "divu t0, t0, t1\n"
        "remu %0, t0, t1\n"
        : "=r"(rdr)
    );
    if (rdr != expect_rdr) {
        return 1;
    }
    return 0;
}

uint64_t test_wide_divu_rdq_eq_rs2(uint64_t rs1, uint64_t rs2) {
    uint64_t rdr;
    uint64_t expect_rdr;

    register long t0 asm("t0") = rs1;
    register long t1 asm("t1") = rs2;

    asm volatile (
        "divu t3, t0, t1\n"
        "remu %0, t0, t3\n"
        : "=r"(expect_rdr)
        :
        :"t3"
    );
    asm volatile (
        "divu t1, t0, t1\n"
        "remu %0, t0, t1\n"
        : "=r"(rdr)
    );
    if (rdr != expect_rdr) {
        return 1;
    }
    return 0;
}

uint64_t test_wide_divu_rdq_eq_rdr(uint64_t rs1, uint64_t rs2) {
    uint64_t rdr;
    uint64_t expect_rdr;

    register long t0 asm("t0") = rs1;
    register long t1 asm("t1") = rs2;

    asm volatile (
        "remu  %0, t0, t1\n"
        : "=r"(expect_rdr)
    );
    asm volatile (
        "divu %0, t0, t1\n"
        "remu %0, t0, t1\n"
        : "=r"(rdr)
    );
    if (rdr != expect_rdr) {
        return 1;
    }
    return 0;
}

int main() {
    for (int i = 0; i < argc; i++)
	for (int j = 0; j < argc; j++)
    if (test_wide_divi_fusion((int64_t)args[i], (int64_t)args[j]) != 0) { return 1; }

    for (int i = 0; i < argc; i++)
	for (int j = 0; j < argc; j++)
    if (test_wide_divi_rdq_eq_rs1((int64_t)args[i], (int64_t)args[j]) != 0) { return 2; }

    for (int i = 0; i < argc; i++)
	for (int j = 0; j < argc; j++)
    if (test_wide_divi_rdq_eq_rs2((int64_t)args[i], (int64_t)args[j]) != 0) { return 3; }

    for (int i = 0; i < argc; i++)
	for (int j = 0; j < argc; j++)
    if (test_wide_divi_rdq_eq_rdr((int64_t)args[i], (int64_t)args[j]) != 0) { return 4; }

    for (int i = 0; i < argc; i++)
	for (int j = 0; j < argc; j++)
    if (test_wide_divu_fusion(args[i], args[j]) != 0) { return 5; }

    for (int i = 0; i < argc; i++)
	for (int j = 0; j < argc; j++)
    if (test_wide_divu_rdq_eq_rs1(args[i], args[j]) != 0) { return 6; }

    for (int i = 0; i < argc; i++)
	for (int j = 0; j < argc; j++)
    if (test_wide_divu_rdq_eq_rs2(args[i], args[j]) != 0) { return 7; }

    for (int i = 0; i < argc; i++)
	for (int j = 0; j < argc; j++)
    if (test_wide_divu_rdq_eq_rdr(args[i], args[j]) != 0) { return 8; }

    return 0;
}


================================================
File: tests/programs/mop_wide_mul_zero.S
================================================
.global _start
_start:
  li a0, 1
  li a1, 1
  li a2, 0

  mulh a3, a0, a1
  mul zero, a0, a1
  bne a2, zero, fail

  mulhu a3, a0, a1
  mul zero, a0, a1
  bne a2, zero, fail

  mulhsu a3, a0, a1
  mul zero, a0, a1
  bne a2, zero, fail

  li a0, 0
  li a7, 93
  ecall
fail:
  li a0, 1
  li a7, 93
  ecall


================================================
File: tests/programs/mop_wide_multiply.c
================================================
#include <stdint.h>

uint64_t argc = 128;
uint64_t args[128] = {
  0x0000000000000000LL,
  0x0000000000000001LL,
  0xffffffffffffffffLL,
  0x8000000000000000LL,
  0x0000000000000004LL,
  0x0000000000000040LL,
  0x0000000000000080LL,
  0x0000000000002000LL,
  0x0000000000010000LL,
  0x0000000000400000LL,
  0x0000000001000000LL,
  0x0000000100000000LL,
  0x0000008000000000LL,
  0x0000020000000000LL,
  0x0000800000000000LL,
  0x0010000000000000LL,
  0x0100000000000000LL,
  0x1000000000000000LL,
  0x000000000000000dLL,
  0x0000000000000000LL,
  0x0000000000000067LL,
  0x2e00000000000000LL,
  0x000000000000015bLL,
  0x9420000000000000LL,
  0x00000000000075daLL,
  0xe35a000000000000LL,
  0x000000000003ed82LL,
  0x8b4eb00000000000LL,
  0x000000000000714cLL,
  0xfad4dc0000000000LL,
  0x000000000dd2966bLL,
  0x686f332000000000LL,
  0x00000000a865d7d4LL,
  0x6edd225600000000LL,
  0x0000000380f3cf69LL,
  0xaf29109cc0000000LL,
  0x000000a3714b9ad2LL,
  0x7dc2ae94e4000000LL,
  0x00000bea6a6af755LL,
  0xea2177d8d5100000LL,
  0x00004a9e26b7f794LL,
  0x6d159abfb3030000LL,
  0x00020e6dfbb7c441LL,
  0xd251a40a022b9000LL,
  0x00129af7f2440efeLL,
  0xc7dee68fffbaf900LL,
  0x05ada4e53975b451LL,
  0x63eb500cce126b70LL,
  0x314320aa7da5b1efLL,
  0xd27d2fde3497614cLL,
  0xbe55668178139c8eLL,
  0x9480583abdfb5837LL,
  0x9d8dbb3a5bde4347LL,
  0x61fd04828c93ce01LL,
  0xdf9a26c8470349ddLL,
  0xca9d54bd4e78980eLL,
  0xb1db9b0fecbfaabeLL,
  0xe79541e25d0dba6bLL,
  0xff98837fda2a5bdfLL,
  0xc3bd5e2cd52318a8LL,
  0x02ab7bb54e687499LL,
  0xbebf0929f41aa230LL,
  0x58aee9fdc3f41b74LL,
  0x62daff171a9fae42LL,
  0xe5baa16ee5b5419eLL,
  0x16b3a918e4278c9dLL,
  0x4ab9cfc9a41744c4LL,
  0x86ddce906c8cdb4dLL,
  0x867e3492977cb1bbLL,
  0x3d0e482377794618LL,
  0x90e1bc8ba22d3294LL,
  0xf48119b103954df1LL,
  0x79780d4e5b2b3b2aLL,
  0xb36eb1caa58ee7dcLL,
  0xf0fe55be95a18d13LL,
  0x1234769364d9eac9LL,
  0x31a7445bdf8bcb5cLL,
  0x1735808ee4398bcaLL,
  0x8f09996552504a5dLL,
  0x4fcf7212bebfdd89LL,
  0xdfd3a0870f60e072LL,
  0x25474d793f2c7d32LL,
  0xb9e2a99fdb7b2948LL,
  0x0da24e08451a8d1aLL,
  0x44a705073f90be80LL,
  0x7f2e6910bdea3ffdLL,
  0x7fc92593c865b4c2LL,
  0x0f812a265e560f2bLL,
  0xfecee737556609f5LL,
  0x996d1b60923c18a6LL,
  0x2c1fb5204d248917LL,
  0x4cf560811e3465c5LL,
  0xf2a6b292a535dc4eLL,
  0x3b4de2fabe6d6476LL,
  0xa6a669d1baba633eLL,
  0xa73c905bcbc01878LL,
  0x38be984c83ce8648LL,
  0x262a15662b298944LL,
  0xdf09e5c90a990b56LL,
  0xa8519a5b46242cc0LL,
  0x14d93f0c55095499LL,
  0xbad28e0ca5854070LL,
  0x93d7d7a9d87056f0LL,
  0x3b0d936889b10a5dLL,
  0x0ec6680cabb95f09LL,
  0x27429c30e8b6cff7LL,
  0x6465f271027abfa8LL,
  0xd0abd7d3688aa0d7LL,
  0x986a686578456056LL,
  0xc10a152d71cb3f16LL,
  0x4a6c986967d5ace8LL,
  0x37269c228e8e3db1LL,
  0xf5bad73c74be6d8aLL,
  0x68323fe289df33d1LL,
  0xcb9848f06e9659f6LL,
  0x5052886f7169c8c5LL,
  0xb040414dd8c98a14LL,
  0xea59a91078581c00LL,
  0x7c6bcb08155fac38LL,
  0xbd6192029dd91d60LL,
  0x8a4a182923bdf75aLL,
  0x8c91e2fe14041a34LL,
  0xc9d368e6546c1f00LL,
  0xdfd83d690e5f073eLL,
  0x34f2a050c605b6b0LL,
  0xf3fbe985738811ddLL,
  0x2d21e3da342cd6beLL,
  0x31523358d080e093LL
};

int64_t test_wide_muli_fusion(int64_t rs1, int64_t rs2) {
    int64_t rdh;
    int64_t rdl;
    int64_t expect_rdh;
    int64_t expect_rdl;

    register long t0 asm("t0") = rs1;
    register long t1 asm("t1") = rs2;

    asm volatile (
        "mulh %0, t0, t1\n"
        "nop\n"
        "mul  %1, t0, t1\n"
        : "=r"(expect_rdh), "=r"(expect_rdl)
    );

    asm volatile (
        "mulh %0, t0, t1\n"
        "mul  %1, t0, t1\n"
        : "=r"(rdh), "=r"(rdl)
    );
    if (rdh != expect_rdh || rdl != expect_rdl) {
        return 1;
    }
    return 0;
}

int64_t test_wide_muli_rdh_eq_rs1(int64_t rs1, int64_t rs2) {
    int64_t rdl;
    int64_t expect_rdl;

    register long t0 asm("t0") = rs1;
    register long t1 asm("t1") = rs2;

    asm volatile (
        "mulh t3, t0, t1\n"
        "mul  %0, t3, t1\n"
        : "=r"(expect_rdl)
        :
        :"t3"
    );

    asm volatile (
        "mulh t0, t0, t1\n"
        "mul  %0, t0, t1\n"
        : "=r"(rdl)
    );

    if (rdl != expect_rdl) {
        return 1;
    }
    return 0;
}

int64_t test_wide_muli_rdh_eq_rs2(int64_t rs1, int64_t rs2) {
    int64_t rdl;
    int64_t expect_rdl;

    register long t0 asm("t0") = rs1;
    register long t1 asm("t1") = rs2;

    asm volatile (
        "mulh t3, t0, t1\n"
        "mul  %0, t0, t3\n"
        : "=r"(expect_rdl)
        :
        :"t3"
    );

    asm volatile (
        "mulh t1, t0, t1\n"
        "mul  %0, t0, t1\n"
        : "=r"(rdl)
    );

    if (rdl != expect_rdl) {
        return 1;
    }
    return 0;
}

int64_t test_wide_muli_rdh_eq_rdl(int64_t rs1, int64_t rs2) {
    int64_t rdl;
    int64_t expect_rdl;

    register long t0 asm("t0") = rs1;
    register long t1 asm("t1") = rs2;

    asm volatile (
        "mul  %0, t0, t1\n"
        : "=r"(expect_rdl)
    );

    asm volatile (
        "mulh %0, t0, t1\n"
        "mul  %0, t0, t1\n"
        : "=r"(rdl)
    );

    if (rdl != expect_rdl) {
        return 1;
    }
    return 0;
}

uint64_t test_wide_mulu_fusion(uint64_t rs1, uint64_t rs2) {
    uint64_t rdh;
    uint64_t rdl;
    uint64_t expect_rdh;
    uint64_t expect_rdl;

    register long t0 asm("t0") = rs1;
    register long t1 asm("t1") = rs2;

    asm volatile (
        "mulhu %0, t0, t1\n"
        "nop\n"
        "mul   %1, t0, t1\n"
        : "=r"(expect_rdh), "=r"(expect_rdl)
    );

    asm volatile (
        "mulhu %0, t0, t1\n"
        "mul   %1, t0, t1\n"
        : "=r"(rdh), "=r"(rdl)
    );
    if (rdh != expect_rdh || rdl != expect_rdl) {
        return 1;
    }
    return 0;
}

uint64_t test_wide_mulu_rdh_eq_rs1(uint64_t rs1, uint64_t rs2) {
    uint64_t rdl;
    uint64_t expect_rdl;

    register long t0 asm("t0") = rs1;
    register long t1 asm("t1") = rs2;

    asm volatile (
        "mulhu t3, t0, t1\n"
        "mul   %0, t3, t1\n"
        : "=r"(expect_rdl)
        :
        :"t3"
    );

    asm volatile (
        "mulhu t0, t0, t1\n"
        "mul   %0, t0, t1\n"
        : "=r"(rdl)
    );

    if (rdl != expect_rdl) {
        return 1;
    }
    return 0;
}

uint64_t test_wide_mulu_rdh_eq_rs2(uint64_t rs1, uint64_t rs2) {
    uint64_t rdl;
    uint64_t expect_rdl;

    register long t0 asm("t0") = rs1;
    register long t1 asm("t1") = rs2;

    asm volatile (
        "mulhu t3, t0, t1\n"
        "mul   %0, t0, t3\n"
        : "=r"(expect_rdl)
        :
        :"t3"
    );

    asm volatile (
        "mulhu t1, t0, t1\n"
        "mul   %0, t0, t1\n"
        : "=r"(rdl)
    );

    if (rdl != expect_rdl) {
        return 1;
    }
    return 0;
}

uint64_t test_wide_mulu_rdh_eq_rdl(uint64_t rs1, uint64_t rs2) {
    uint64_t rdl;
    uint64_t expect_rdl;

    register long t0 asm("t0") = rs1;
    register long t1 asm("t1") = rs2;

    asm volatile (
        "mul  %0, t0, t1\n"
        : "=r"(expect_rdl)
    );

    asm volatile (
        "mulhu %0, t0, t1\n"
        "mul   %0, t0, t1\n"
        : "=r"(rdl)
    );

    if (rdl != expect_rdl) {
        return 1;
    }
    return 0;
}

uint64_t test_wide_mulsu_fusion(uint64_t rs1, uint64_t rs2) {
    uint64_t rdh;
    uint64_t rdl;
    uint64_t expect_rdh;
    uint64_t expect_rdl;

    register long t0 asm("t0") = rs1;
    register long t1 asm("t1") = rs2;

    asm volatile (
        "mulhsu %0, t0, t1\n"
        "nop\n"
        "mul   %1, t0, t1\n"
        : "=r"(expect_rdh), "=r"(expect_rdl)
    );

    asm volatile (
        "mulhsu %0, t0, t1\n"
        "mul   %1, t0, t1\n"
        : "=r"(rdh), "=r"(rdl)
    );
    if (rdh != expect_rdh || rdl != expect_rdl) {
        return 1;
    }
    return 0;
}

uint64_t test_wide_mulsu_rdh_eq_rs1(uint64_t rs1, uint64_t rs2) {
    uint64_t rdl;
    uint64_t expect_rdl;

    register long t0 asm("t0") = rs1;
    register long t1 asm("t1") = rs2;

    asm volatile (
        "mulhsu t3, t0, t1\n"
        "mul   %0, t3, t1\n"
        : "=r"(expect_rdl)
        :
        :"t3"
    );

    asm volatile (
        "mulhsu t0, t0, t1\n"
        "mul   %0, t0, t1\n"
        : "=r"(rdl)
    );

    if (rdl != expect_rdl) {
        return 1;
    }
    return 0;
}

uint64_t test_wide_mulsu_rdh_eq_rs2(uint64_t rs1, uint64_t rs2) {
    uint64_t rdl;
    uint64_t expect_rdl;

    register long t0 asm("t0") = rs1;
    register long t1 asm("t1") = rs2;

    asm volatile (
        "mulhsu t3, t0, t1\n"
        "mul   %0, t0, t3\n"
        : "=r"(expect_rdl)
        :
        :"t3"
    );

    asm volatile (
        "mulhsu t1, t0, t1\n"
        "mul   %0, t0, t1\n"
        : "=r"(rdl)
    );

    if (rdl != expect_rdl) {
        return 1;
    }
    return 0;
}

uint64_t test_wide_mulsu_rdh_eq_rdl(uint64_t rs1, uint64_t rs2) {
    uint64_t rdl;
    uint64_t expect_rdl;

    register long t0 asm("t0") = rs1;
    register long t1 asm("t1") = rs2;

    asm volatile (
        "mul  %0, t0, t1\n"
        : "=r"(expect_rdl)
    );

    asm volatile (
        "mulhsu %0, t0, t1\n"
        "mul   %0, t0, t1\n"
        : "=r"(rdl)
    );

    if (rdl != expect_rdl) {
        return 1;
    }
    return 0;
}

int main() {
    for (int i = 0; i < argc; i++)
	for (int j = 0; j < argc; j++)
    if (test_wide_muli_fusion((int64_t)args[i], (int64_t)args[j]) != 0) { return 1; }

    for (int i = 0; i < argc; i++)
	for (int j = 0; j < argc; j++)
    if (test_wide_muli_rdh_eq_rs1((int64_t)args[i], (int64_t)args[j]) != 0) { return 2; }

    for (int i = 0; i < argc; i++)
	for (int j = 0; j < argc; j++)
    if (test_wide_muli_rdh_eq_rs2((int64_t)args[i], (int64_t)args[j]) != 0) { return 3; }

    for (int i = 0; i < argc; i++)
	for (int j = 0; j < argc; j++)
    if (test_wide_muli_rdh_eq_rdl((int64_t)args[i], (int64_t)args[j]) != 0) { return 4; }

    for (int i = 0; i < argc; i++)
	for (int j = 0; j < argc; j++)
    if (test_wide_mulu_fusion(args[i], args[j]) != 0) { return 5; }

    for (int i = 0; i < argc; i++)
	for (int j = 0; j < argc; j++)
    if (test_wide_mulu_rdh_eq_rs1(args[i], args[j]) != 0) { return 6; }

    for (int i = 0; i < argc; i++)
	for (int j = 0; j < argc; j++)
    if (test_wide_mulu_rdh_eq_rs2(args[i], args[j]) != 0) { return 7; }

    for (int i = 0; i < argc; i++)
	for (int j = 0; j < argc; j++)
    if (test_wide_mulu_rdh_eq_rdl(args[i], args[j]) != 0) { return 8; }

    for (int i = 0; i < argc; i++)
	for (int j = 0; j < argc; j++)
    if (test_wide_mulsu_fusion(args[i], args[j]) != 0) { return 9; }

    for (int i = 0; i < argc; i++)
	for (int j = 0; j < argc; j++)
    if (test_wide_mulsu_rdh_eq_rs1(args[i], args[j]) != 0) { return 10; }

    for (int i = 0; i < argc; i++)
	for (int j = 0; j < argc; j++)
    if (test_wide_mulsu_rdh_eq_rs2(args[i], args[j]) != 0) { return 11; }

    for (int i = 0; i < argc; i++)
	for (int j = 0; j < argc; j++)
    if (test_wide_mulsu_rdh_eq_rdl(args[i], args[j]) != 0) { return 12; }

    return 0;
}


================================================
File: tests/programs/mulw.S
================================================
.global _start
_start:
  li s6, 1
  li s5, -1
  mulw s5, s6, s5
  li t6, -1
  beq s5, t6, ok
  li a0, 1
  li a7, 93
  ecall
ok:
  li a0, 0
  li a7, 93
  ecall


================================================
File: tests/programs/nop.S
================================================
  .global _start
_start:
  nop
  nop
  li a1, 0
  li a2, 0
  li a3, 0
  li a4, 0
  li a5, 0
  li a7, 93
  ecall


================================================
File: tests/programs/orc_bug.S
================================================
.global _start
_start:
    li a1, 0xffffffffffffee00
    orc.b a0, a1
    li a2, 0xffffffffffffff00
    beq a0, a2, ok
    li a0, 1
    li a7, 93
    ecall
ok:
    li a0, 0
    li a7, 93
    ecall


================================================
File: tests/programs/pause_resume.c
================================================
#include <stdint.h>

static inline long __internal_syscall(long n, long _a0, long _a1, long _a2,
                                      long _a3, long _a4, long _a5) {
  register long a0 asm("a0") = _a0;
  register long a1 asm("a1") = _a1;
  register long a2 asm("a2") = _a2;
  register long a3 asm("a3") = _a3;
  register long a4 asm("a4") = _a4;
  register long a5 asm("a5") = _a5;

#ifdef __riscv_32e
  register long syscall_id asm("t0") = n;
#else
  register long syscall_id asm("a7") = n;
#endif

  asm volatile("scall"
               : "+r"(a0)
               : "r"(a1), "r"(a2), "r"(a3), "r"(a4), "r"(a5), "r"(syscall_id));
  return a0;
}

#define syscall(n, a, b, c, d, e, f)                                           \
  __internal_syscall(n, (long)(a), (long)(b), (long)(c), (long)(d), (long)(e), \
                     (long)(f))

int main() {
    for (int i = 0; i < 200; i++) {
        // sleep 10ms.
        syscall(1000, 10, 0, 0, 0, 0, 0);
    }
    return 0;
}


================================================
File: tests/programs/pcnt.c
================================================
// Build: /opt/riscv64b/bin/riscv64-unknown-elf-gcc -o pcnt -march=rv64gb pcnt.c

#include "rvintrin.h"
#include <stdint.h>

// Derived from
// https://github.com/FFmpeg/FFmpeg/blob/master/libavutil/common.h#L454-L461
static int popcnt32(uint32_t x) {
  x -= (x >> 1) & 0x55555555;
  x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
  x = (x + (x >> 4)) & 0x0F0F0F0F;
  x += x >> 8;
  return (x + (x >> 16)) & 0x3F;
}

static int popcnt64(uint64_t x) {
  return popcnt32((uint32_t)x) + popcnt32((uint32_t)(x >> 32));
}

// Test cases are copied from
// https://github.com/gcc-mirror/gcc/blob/16e2427f50c208dfe07d07f18009969502c25dc8/gcc/testsuite/gdc.test/runnable/builtin.d#L83-L104
#define CASES 13
uint64_t test[CASES] = {
    0,
    7,
    0xAA,
    0xFFFF,
    0xCCCC,
    0x7777,
    0x84211248,
    0xFFFFFFFF,
    0xCCCCCCCC,
    0x77777777,
    0xFFFFFFFFFFFFFFFF,
    0xCCCCCCCCCCCCCCCC,
    0x7777777777777777,
};

int main() {
  for (int i = 0; i < CASES; i++) {
    uint64_t n = test[i];
    int a = popcnt64(n);
    int b = _rv64_pcnt(n);
    if (a != b) {
      return 1;
    }
    int c = popcnt32((uint32_t)n);
    int d = _rv32_pcnt((uint32_t)n);
    if (c != d) {
      return 1;
    }
  }
  return 0;
}


================================================
File: tests/programs/read_at_boundary.S
================================================
.global _start
_start:
  li a1, 0x3FFFF8
  ld a2, 0(a1)
  li a0, 0
  li a7, 93
  ecall


================================================
File: tests/programs/read_memory.S
================================================
.global _start
_start:
  li a1, 0x300000
  lbu a0, 0(a1)
  li a7, 93
  ecall


================================================
File: tests/programs/reset_callee.c
================================================
int main() {
    return 0;
}


================================================
File: tests/programs/reset_caller.c
================================================
#include <stdint.h>

static inline long __internal_syscall(long n, long _a0, long _a1, long _a2,
                                      long _a3, long _a4, long _a5) {
  register long a0 asm("a0") = _a0;
  register long a1 asm("a1") = _a1;
  register long a2 asm("a2") = _a2;
  register long a3 asm("a3") = _a3;
  register long a4 asm("a4") = _a4;
  register long a5 asm("a5") = _a5;

#ifdef __riscv_32e
  register long syscall_id asm("t0") = n;
#else
  register long syscall_id asm("a7") = n;
#endif

  asm volatile("scall"
               : "+r"(a0)
               : "r"(a1), "r"(a2), "r"(a3), "r"(a4), "r"(a5), "r"(syscall_id));
  return a0;
}

#define syscall(n, a, b, c, d, e, f)                                           \
  __internal_syscall(n, (long)(a), (long)(b), (long)(c), (long)(d), (long)(e), \
                     (long)(f))

int main() {
    syscall(1111, 0, 0, 0, 0, 0, 0);
    return 1;
}


================================================
File: tests/programs/resume2_load_data.c
================================================
#include <stdint.h>

static inline long __internal_syscall(long n, long _a0, long _a1, long _a2,
                                      long _a3, long _a4, long _a5) {
  register long a0 asm("a0") = _a0;
  register long a1 asm("a1") = _a1;
  register long a2 asm("a2") = _a2;
  register long a3 asm("a3") = _a3;
  register long a4 asm("a4") = _a4;
  register long a5 asm("a5") = _a5;

#ifdef __riscv_32e
  register long syscall_id asm("t0") = n;
#else
  register long syscall_id asm("a7") = n;
#endif

  asm volatile("scall"
               : "+r"(a0)
               : "r"(a1), "r"(a2), "r"(a3), "r"(a4), "r"(a5), "r"(syscall_id));
  return a0;
}

#define syscall(n, a, b, c, d, e, f)                                           \
  __internal_syscall(n, (long)(a), (long)(b), (long)(c), (long)(d), (long)(e), \
                     (long)(f))

#define SIZE (16 * 4096)

int main() {
    volatile char buf[SIZE] = { 0 };
    syscall(1111, (void *) buf, SIZE, 0, 0, 0, 0);

    char ret = 0;
    for (int i = 0; i < SIZE; i++) {
      ret += buf[i];
    }

    return (int) ret;
}


================================================
File: tests/programs/rorw_in_end_of_aot_block.S
================================================
.global _start
_start:
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  rorw s1, a0, s3

  li a0, 0
  li a7, 93
  ecall


================================================
File: tests/programs/rvc_pageend.S
================================================
.section .text
.global _start
_start:
    li a0, 0x100c4
    c.jr a0
    nop
    li a0, 0
    li a7, 93
    ecall
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    li a0, 0x100ba
    c.jr a0
.section .data
n0:
    .word 4
n1:
    .word 2


================================================
File: tests/programs/rvc_pageend.dump
================================================

rvc_pageend:     file format elf64-littleriscv
rvc_pageend
architecture: riscv:rv64, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00000000000100b0

Program Header:
    LOAD off    0x0000000000000000 vaddr 0x0000000000010000 paddr 0x0000000000010000 align 2**12
         filesz 0x0000000000001000 memsz 0x0000000000001000 flags r-x
    LOAD off    0x0000000000001000 vaddr 0x0000000000011000 paddr 0x0000000000011000 align 2**12
         filesz 0x0000000000000008 memsz 0x0000000000000008 flags rw-

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000f50  00000000000100b0  00000000000100b0  000000b0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000008  0000000000011000  0000000000011000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .riscv.attributes 00000033  0000000000000000  0000000000000000  00001008  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00000000000100b0 l    d  .text	0000000000000000 .text
0000000000011000 l    d  .data	0000000000000000 .data
0000000000000000 l    d  .riscv.attributes	0000000000000000 .riscv.attributes
0000000000000000 l    df *ABS*	0000000000000000 rvc_pageend.o
0000000000011000 l       .data	0000000000000000 n0
0000000000011004 l       .data	0000000000000000 n1
00000000000100b0 g       .text	0000000000000000 _start




================================================
File: tests/programs/rvc_pageend.lds
================================================
SECTIONS
{
. = 0x100b0;
.text : { *(.text) }
. = 0x11000;
.data : { *(.data) }
}


================================================
File: tests/programs/rvc_pageend.sh
================================================
riscv64-unknown-elf-as -march=rv64gc -o rvc_pageend.o rvc_pageend.S
riscv64-unknown-elf-ld -o rvc_pageend -T rvc_pageend.lds rvc_pageend.o
rm rvc_pageend.o
riscv64-unknown-elf-objdump -x rvc_pageend > rvc_pageend.dump


================================================
File: tests/programs/sbinvi_aot_load_imm_bug.S
================================================
.global _start
_start:
  li a0, 0xf011f8508554579d
  li a1, 0xf011f8500554579d
  sbinvi a0, a0, 0x1f
  bne a0, a1, fail
  li a0, 0
  li a7, 93
  ecall
fail:
  li a0, 1
  li a7, 93
  ecall


================================================
File: tests/programs/sc_after_sc.S
================================================
.global _start
_start:
_test_case_sc_d_after_success_sc_d:
    la a0, n0         # a0 holds address of memory location n0
    la a1, n1         # a1 holds address of memory location n1
    lr.d a2, (a0)
    sc.d a3, a2, (a0)
    bnez a3, fail     # sc.d must success
    sc.d a3, a2, (a0)
    beqz a3, fail     # sc.d must fail
_test_case_sc_d_after_failure_sc_d:
    la a0, n0         # a0 holds address of memory location n0
    la a1, n1         # a1 holds address of memory location n1
    lr.d a2, (a0)
    sc.d a3, a2, (a1)
    beqz a3, fail     # sc.d must success
    sc.d a3, a2, (a0)
    beqz a3, fail     # sc.d must fail
_test_case_sc_w_after_success_sc_w:
    la a0, n0         # a0 holds address of memory location n0
    la a1, n1         # a1 holds address of memory location n1
    lr.w a2, (a0)
    sc.w a3, a2, (a0)
    bnez a3, fail     # sc.d must success
    sc.w a3, a2, (a0)
    beqz a3, fail     # sc.d must fail
_test_case_sc_w_after_failure_sc_w:
    la a0, n0         # a0 holds address of memory location n0
    la a1, n1         # a1 holds address of memory location n1
    lr.w a2, (a0)
    sc.w a3, a2, (a1)
    beqz a3, fail     # sc.d must success
    sc.w a3, a2, (a0)
    beqz a3, fail     # sc.d must fail
done:
    li a0, 0
    li a7, 93
    ecall
fail:
    li a0, 1
    li a7, 93
    ecall
.section .data
n0:
    .dword 4      # Initialize to 4
n1:
    .dword 4      # Initialize to 4


================================================
File: tests/programs/sc_after_sc.lds
================================================
SECTIONS
{
. = 0x100b0;
.text : { *(.text) }
. = 0x11000;
.data : { *(.data) }
}


================================================
File: tests/programs/sc_after_snapshot.S
================================================
.global _start
_start:
_test_case_sc_after_snapshot:
    la a0, n0         # a0 holds address of memory location n0
    lr.d a2, (a0)
    nop
    nop
    nop
    nop
    sc.d a3, a2, (a0)
    bnez a3, fail     # sc.d must success
done:
    li a0, 0
    li a7, 93
    ecall
fail:
    li a0, 1
    li a7, 93
    ecall
.section .data
n0:
    .dword 4      # Initialize to 4


================================================
File: tests/programs/sc_after_snapshot.lds
================================================
SECTIONS
{
. = 0x100b0;
.text : { *(.text) }
. = 0x11000;
.data : { *(.data) }
}


================================================
File: tests/programs/sc_only.S
================================================
.global _start
_start:
    la a0, n0         # a0 holds address of memory location n0
    sc.d a3, a2, (a0)
    beqz a3, fail     # sc.d must fail
done:
    li a0, 0
    li a7, 93
    ecall
fail:
    li a0, 1
    li a7, 93
    ecall
.section .data
n0:
    .dword 4      # Initialize to 4


================================================
File: tests/programs/sc_only.lds
================================================
SECTIONS
{
. = 0x100b0;
.text : { *(.text) }
. = 0x11000;
.data : { *(.data) }
}


================================================
File: tests/programs/simple.c
================================================
#include <stdint.h>

int main() {
  int small = 0;
  small += 3;
  if (small != 3) { return 1; }

  small *= 3;
  if (small != 9) { return 2; }

  small = small << 3;
  if (small != 72) { return 3; }

  small = small >> 3;
  if (small != 9) { return 4; }

  small = small & 0xffff;
  if (small != 9) { return 5; }

  small = small | 0x2;
  if (small != 11) { return 6; }

  small /= 2;
  if (small != 5) { return 7; }


  uint64_t big = 7;
  big += 3;
  if (big != 10) { return 8; }

  big *= 17;
  if (big != 170) { return 9; }

  big = big << 3;
  if (big != 1360) { return 10; }

  big = big >> 3;
  if (big != 170) { return 11; }

  big = big & 0xffff;
  if (big != 170) { return 12; }

  big = big | 0x5;
  if (big != 175) { return 13; }

  big /= 2;
  if (big != 87) { return 14; }

  int small2 = 8;
  small2 += 2;
  // 5 + 82 = 87
  small += 82;
  if ((small * small2) != 870) { return 15; }
  if ((small / small2) != 8) { return 16; }
  if ((small % small2) != 7) { return 17; }
  if ((small ^ small2) != 93) { return 18; }
  if ((small | small2) != 95) { return 19; }
  if ((small & small2) != 2) { return 20; }

  unsigned int usmall = 5;
  unsigned int usmall2 = 8;
  usmall += 82;
  usmall2 += 2;
  if ((usmall * usmall2) != 870) { return 21; }
  if ((usmall / usmall2) != 8) { return 22; }
  if ((usmall % usmall2) != 7) { return 23; }
  if ((usmall ^ usmall2) != 93) { return 24; }
  if ((usmall | usmall2) != 95) { return 25; }
  if ((usmall & usmall2) != 2) { return 26; }

  int neg_small = 5;
  int neg_small2 = 8;
  neg_small -= 499;
  neg_small2 -= 13;
  if ((neg_small * neg_small2) != 2470) { return 27; }
  if ((neg_small / neg_small2) != 98) { return 28; }
  if ((neg_small % neg_small2) != -4) { return 29; }
  if ((neg_small ^ neg_small2) != 489) { return 30; }
  if ((neg_small | neg_small2) != -5) { return 31; }
  if ((neg_small & neg_small2) != -494) { return 32; }
  return 0;

  int small4 = 8;
  small4 += 13;
  if ((neg_small * small4) != -10374) { return 33; }
  if ((neg_small / small4) != -23) { return 34; }
  if ((neg_small % small4) != 10) { return 35; }
  if ((neg_small ^ small4) != -505) { return 36; }
  if ((neg_small | small4) != -489) { return 37; }
  if ((neg_small & small4) != -16) { return 38; }
  return 0;
}


================================================
File: tests/programs/sp_alignment_test.S
================================================
  .global _start
_start:
  andi a1, sp, 15
  li a2, 0
  beq a1, a2, ok
  li a0, 1
  li a7, 93
  ecall
ok:
  li a0, 0
  li a7, 93
  ecall


================================================
File: tests/programs/spawn.c
================================================
#include <stdint.h>

static inline long __internal_syscall(long n, long _a0, long _a1, long _a2,
                                      long _a3, long _a4, long _a5) {
  register long a0 asm("a0") = _a0;
  register long a1 asm("a1") = _a1;
  register long a2 asm("a2") = _a2;
  register long a3 asm("a3") = _a3;
  register long a4 asm("a4") = _a4;
  register long a5 asm("a5") = _a5;

#ifdef __riscv_32e
  register long syscall_id asm("t0") = n;
#else
  register long syscall_id asm("a7") = n;
#endif

  asm volatile("scall"
               : "+r"(a0)
               : "r"(a1), "r"(a2), "r"(a3), "r"(a4), "r"(a5), "r"(syscall_id));
  return a0;
}

#define syscall(n, a, b, c, d, e, f)                                           \
  __internal_syscall(n, (long)(a), (long)(b), (long)(c), (long)(d), (long)(e), \
                     (long)(f))

int main(int argc, char* argv[]) {
    if (argc == 64) {
        return 0;
    } else {
        char* path = "tests/programs/spawn";
        char* argv[64] = {"a"};
        return syscall(1001, path, argc + 1, argv, 0, 0, 0);
    }
}


================================================
File: tests/programs/syscall.S
================================================
  .global _start
_start:
  li a0, 4
  li a1, 5
  li a2, 6
  li a3, 7
  li a4, 8
  li a5, 9
  li a7, 1111
  ecall
  li a7, 93
  ecall


================================================
File: tests/programs/trace.S
================================================
  .global _start
_start:
  li a0, 7
  li a0, 10
  auipc a1, 0
  addi a1, a1, -4
  lh a2, 0(a1)
  auipc a3, 0
  addi a3, a3, 10
  sh a2, 0(a3)
  li a0, 11
  li a7, 93
  ecall


================================================
File: tests/programs/unaligned64.S
================================================
  .global _start
_start:
  li a2, 0x10000
  ld a1, 0(a2)
  bne a1, x0, invalid
  li a0, 0
  li a7, 93
  ecall
invalid:
  li a0, 1
  li a7, 93
  ecall


================================================
File: tests/programs/writable_page.c
================================================
#include <stdint.h>

uint8_t buffer[4096] __attribute__((aligned(4096))) = {1, 2};

int main() {
    return buffer[0] + buffer[1] - 3;
}


================================================
File: tests/programs/writable_page.dump
================================================

writable_page:     file format elf64-littleriscv

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         000002dc  00000000000100b0  00000000000100b0  000000b0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .eh_frame     00000004  000000000001138c  000000000001138c  0000038c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .init_array   00000010  0000000000011390  0000000000011390  00000390  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  3 .fini_array   00000008  00000000000113a0  00000000000113a0  000003a0  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  4 .data         00001748  0000000000012000  0000000000012000  00001000  2**12
                  CONTENTS, ALLOC, LOAD, DATA
  5 .sdata        00000018  0000000000013748  0000000000013748  00002748  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00000038  0000000000013760  0000000000013760  00002760  2**3
                  ALLOC
  7 .comment      00000012  0000000000000000  0000000000000000  00002760  2**0
                  CONTENTS, READONLY
  8 .riscv.attributes 0000002b  0000000000000000  0000000000000000  00002772  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00000210  0000000000000000  0000000000000000  000027a0  2**4
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_info   0000348a  0000000000000000  0000000000000000  000029b0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_abbrev 00000e63  0000000000000000  0000000000000000  00005e3a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_line   00000b3d  0000000000000000  0000000000000000  00006c9d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_frame  000001d8  0000000000000000  0000000000000000  000077e0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_str    0000072b  0000000000000000  0000000000000000  000079b8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_line_str 000004b5  0000000000000000  0000000000000000  000080e3  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_loclists 000005b6  0000000000000000  0000000000000000  00008598  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_rnglists 000000a3  0000000000000000  0000000000000000  00008b4e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS


================================================
File: tests/programs/write_at_boundary.S
================================================
.global _start
_start:
  li a3, 123
  li a2, 0x3FFFF8
  sd a3, 0(a2)
  li a1, 0
  li a7, 93
  ecall


================================================
File: tests/programs/write_large_address.S
================================================
.global _start
_start:
  li a3, 123
  li a2, 0xFFFFFF00
  sd a3, 0(a2)
  li a1, 0
  li a7, 93
  ecall


================================================
File: tests/programs/zero_address.S
================================================
  .global _start
_start:
  li a0, 0
  li a7, 93
  ecall


================================================
File: tests/programs/zero_address.lds
================================================
SECTIONS
{
. = 0x00;
.text : { *(.text) }
}


================================================
File: .github/CODEOWNERS
================================================
* @nervosnetwork/ckb-vm-code-review


================================================
File: .github/ISSUE_TEMPLATE/bug_report.md
================================================
---
name: Bug report
about: Create a report to help us improve
---

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:
1. Go to '...'
2. Click on '....'
3. Scroll down to '....'
4. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Environment**
 - OS: [e.g. Ubuntu]
 - Version [e.g. v0.1.0]

**Additional context**
Add any other context about the problem here.


================================================
File: .github/workflows/develop.yml
================================================
name: develop

on:
  pull_request:
  push:

jobs:

  linux-x86-deny:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      # https://github.com/EmbarkStudios/cargo-deny-action
      - uses: EmbarkStudios/cargo-deny-action@v1
        with:
          arguments: --all-features
          command: check advisories licenses sources bans

  linux-x86-ci-generated:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Run ci-generated
        run: make ci-generated

  linux-x86-ci:
    strategy:
      matrix:
        os: [ubuntu-latest, ubuntu-24.04-arm]

    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v3
      - uses: actions-rust-lang/setup-rust-toolchain@v1
      - name: Run ci
        run: rustup component add clippy rustfmt && make ci

  linux-native-ci-asm:
    strategy:
      matrix:
        os: [ubuntu-latest, ubuntu-24.04-arm]

    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v3
      - uses: actions-rust-lang/setup-rust-toolchain@v1
      - name: Run ci-asm
        run: make ci-asm

  linux-native-ci-asm-chaos:
    strategy:
      matrix:
        os: [ubuntu-latest, ubuntu-24.04-arm]

    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v3
      - uses: actions-rust-lang/setup-rust-toolchain@v1
      - name: Run ci-asm-chaos
        run: make ci-asm-chaos

  linux-native-test-suite:
    strategy:
      matrix:
        os: [ubuntu-latest, ubuntu-24.04-arm]

    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v3
      - uses: actions-rust-lang/setup-rust-toolchain@v1
      - name: Install dependencies
        run: |
          sudo apt install -y git \
                              build-essential \
                              autoconf \
                              automake \
                              autotools-dev \
                              libmpc-dev \
                              libmpfr-dev \
                              libgmp-dev \
                              gawk \
                              libtool \
                              patchutils \
                              libexpat-dev \
                              zlib1g-dev
      - name: Run test suite
        run: |
          git clone https://github.com/nervosnetwork/ckb-vm-test-suite
          ln -snf .. ckb-vm-test-suite/ckb-vm
          docker run --rm -v `pwd`:/code nervos/ckb-riscv-gnu-toolchain:bionic-20210804 cp -r /riscv /code/riscv
          cd ckb-vm-test-suite
          git checkout 898edc351eeb4de974ca4f0ff8d1e4943a95aecb
          git submodule update --init --recursive
          RISCV=`pwd`/../riscv ./test.sh

  linux-native-test-spawn:
    strategy:
      matrix:
        os: [ubuntu-latest, ubuntu-24.04-arm]

    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v3
      - uses: actions-rust-lang/setup-rust-toolchain@v1
      - name: Run spawn tests in release
        run: cargo test test_spawn --release --features=asm -- --nocapture

  linux-arm-ci-asm:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install dependencies
        run: |
          sudo apt-get update -y
          sudo apt install -y build-essential \
                              autoconf \
                              automake \
                              autotools-dev \
                              libmpc-dev \
                              libmpfr-dev \
                              libgmp-dev \
                              gawk \
                              libtool \
                              patchutils \
                              libexpat-dev \
                              zlib1g-dev \
                              gcc-aarch64-linux-gnu \
                              g++-aarch64-linux-gnu \
                              qemu-user-static
          rustup target add aarch64-unknown-linux-gnu
      - name: Run ci-asm
        run: |
          export CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc &&
          export CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_RUSTFLAGS="-C link-args=-L -C link-args=/usr/lib/gcc-cross/aarch64-linux-gnu/11" &&
          export CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_RUNNER="qemu-aarch64-static -L /usr/aarch64-linux-gnu" &&
          cargo test --features=asm --target aarch64-unknown-linux-gnu

  linux-arm-test-suite:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install dependencies
        run: |
          sudo apt update -y
          sudo apt install -y build-essential \
                              autoconf \
                              automake \
                              autotools-dev \
                              libmpc-dev \
                              libmpfr-dev \
                              libgmp-dev \
                              gawk \
                              libtool \
                              patchutils \
                              libexpat-dev \
                              zlib1g-dev
          rustup target add aarch64-unknown-linux-gnu
      - name: Build test suite
        run: |
          git clone https://github.com/nervosnetwork/ckb-vm-test-suite
          ln -snf .. ckb-vm-test-suite/ckb-vm
          docker run --rm -v `pwd`:/code nervos/ckb-riscv-gnu-toolchain:bionic-20210804 cp -r /riscv /code/riscv
          cd ckb-vm-test-suite
          git checkout 898edc351eeb4de974ca4f0ff8d1e4943a95aecb
          git submodule update --init --recursive
          RISCV=`pwd`/../riscv ./test.sh --build-only
          cd ..
      - name: Run test suite
        run: |
          sudo apt install -y qemu-system binfmt-support qemu-user-static
          sudo apt install -y gcc-multilib
          sudo apt install -y gcc-aarch64-linux-gnu g++-aarch64-linux-gnu clang
          docker run --rm --privileged multiarch/qemu-user-static --reset -p yes
          cd ckb-vm-test-suite
          cd binary && cargo build --release --target=aarch64-unknown-linux-gnu && cd ..
          cd ..
          docker run --rm -v `pwd`:/code -t --platform linux/arm64 arm64v8/rust bash -c "RISCV=/dummy /code/ckb-vm-test-suite/test.sh --prebuilt-prefix aarch64-unknown-linux-gnu"

  macos-x86-ci-asm:
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v3
      - name: Run ci-asm
        run: make ci-asm

  windows-x86-ci-asm:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install dependencies
        shell: pwsh
        # https://github.com/ScoopInstaller/Install#for-admin
        run: |
          iex "& {$(irm get.scoop.sh)} -RunAsAdmin"
          scoop install mingw
      - name: Run ci-asm
        shell: pwsh
        run: |
          make ci-asm


