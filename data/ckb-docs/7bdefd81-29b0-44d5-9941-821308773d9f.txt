Directory structure:
└── ckb-devrel-ccc-locks/
    ├── README.md
    ├── Cargo.toml
    ├── Makefile
    ├── checksums.txt
    ├── rust-toolchain
    ├── contracts/
    │   ├── ccc-btc-lock/
    │   │   ├── README.md
    │   │   ├── Cargo.toml
    │   │   ├── Makefile
    │   │   ├── .gitignore
    │   │   └── src/
    │   │       ├── entry.rs
    │   │       ├── error.rs
    │   │       └── main.rs
    │   ├── ccc-eth-lock/
    │   │   ├── README.md
    │   │   ├── Cargo.toml
    │   │   ├── Makefile
    │   │   ├── .gitignore
    │   │   └── src/
    │   │       ├── entry.rs
    │   │       ├── error.rs
    │   │       └── main.rs
    │   └── ccc-sol-lock/
    │       ├── README.md
    │       ├── Cargo.toml
    │       ├── Makefile
    │       ├── .gitignore
    │       └── src/
    │           ├── entry.rs
    │           ├── error.rs
    │           └── main.rs
    ├── crates/
    │   └── ckb-lock-helper/
    │       ├── Cargo.toml
    │       └── src/
    │           ├── blake2b.rs
    │           ├── error.rs
    │           ├── lib.rs
    │           └── secp256k1_patch.rs
    ├── deployment/
    │   ├── .gitignore
    │   └── testnet/
    │       ├── btc-lock/
    │       │   ├── deployment.toml
    │       │   ├── step-1-gen-txs.sh
    │       │   ├── step-2-sign.sh
    │       │   ├── step-3-apply.sh
    │       │   └── migrations/
    │       │       └── 2024-08-02-064528.json
    │       ├── eth-lock/
    │       │   ├── deployment.toml
    │       │   ├── step-1-gen-txs.sh
    │       │   ├── step-2-sign.sh
    │       │   ├── step-3-apply.sh
    │       │   └── migrations/
    │       │       └── 2024-08-02-064738.json
    │       └── sol-lock/
    │           ├── deployment.toml
    │           ├── step-1-gen-txs.sh
    │           ├── step-2-sign.sh
    │           ├── step-3-apply.sh
    │           └── migrations/
    │               └── 2024-08-02-064926.json
    ├── docs/
    │   ├── btc.md
    │   ├── eth.md
    │   ├── overview.md
    │   └── sol.md
    ├── scripts/
    │   ├── find_clang
    │   └── reproducible_build_docker
    ├── tests/
    │   ├── Cargo.lock
    │   ├── Cargo.toml
    │   ├── rustfmt.toml
    │   └── src/
    │       ├── common.rs
    │       ├── core.rs
    │       ├── lib.rs
    │       ├── test_btc.rs
    │       ├── test_eth.rs
    │       └── test_sol.rs
    └── .github/
        └── workflows/
            └── rust.yml

================================================
File: README.md
================================================
# CCC Locks

[CCC (Common Chains Connector)](https://github.com/ckb-ecofund/ccc) helps
developers interoperate wallets from different chain ecosystems with CKB, fully
enabling CKB's cryptographic freedom power. The lock specifications for
dedicated chains can be found in [docs](./docs/).


## Build

Build on native machine:

```sh
$ make build
```

See [ckb-script-templates](https://github.com/cryptape/ckb-script-templates) for required setup.


Make a reproducible build:

```sh
$ bash scripts/reproducible_build_docker
```

The docker is required.


## Test

```sh
$ cd tests && cargo test
```


================================================
File: Cargo.toml
================================================
[workspace]
resolver = "2"

members = [
  # Please don't remove the following line, we use it to automatically
  # detect insertion point for newly generated crates.
  # @@INSERTION_POINT@@
  "contracts/ccc-sol-lock",
  "contracts/ccc-eth-lock",
  "contracts/ccc-btc-lock",
  "crates/ckb-lock-helper"
]

[profile.release]
overflow-checks = true
opt-level = 3
panic = 'abort'
strip = true
lto = true

[profile.dev]
strip = true
opt-level = 1
debug = false
panic = 'abort'
debug-assertions = true


================================================
File: Makefile
================================================
# We cannot use $(shell pwd), which will return unix path format on Windows,
# making it hard to use.
cur_dir = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))

TOP := $(cur_dir)
# RUSTFLAGS that are likely to be tweaked by developers. For example,
# while we enable debug logs by default here, some might want to strip them
# for minimal code size / consumed cycles.
CUSTOM_RUSTFLAGS := --cfg debug_assertions
# Additional cargo args to append here. For example, one can use
# make test CARGO_ARGS="-- --nocapture" so as to inspect data emitted to
# stdout in unit tests
CARGO_ARGS :=
MODE := release
# Tweak this to change the clang version to use for building C code. By default
# we use a bash script with somes heuristics to find clang in current system.
CLANG := $(shell $(TOP)/scripts/find_clang)
# When this is set, a single contract will be built instead of all contracts
CONTRACT :=
# By default, we would clean build/{release,debug} folder first, in case old
# contracts are mixed together with new ones, if for some reason you want to
# revert this behavior, you can change this to anything other than true
CLEAN_BUILD_DIR_FIRST := true
BUILD_DIR := build/$(MODE)

# Pass setups to child make processes
export CUSTOM_RUSTFLAGS
export TOP
export CARGO_ARGS
export MODE
export CLANG
export BUILD_DIR

default: build test

build:
	@if [ "x$(CLEAN_BUILD_DIR_FIRST)" = "xtrue" ]; then \
		echo "Cleaning $(BUILD_DIR) directory..."; \
		rm -rf $(BUILD_DIR); \
	fi
	mkdir -p $(BUILD_DIR)
	@set -eu; \
	if [ "x$(CONTRACT)" = "x" ]; then \
		for contract in $(wildcard contracts/*); do \
			$(MAKE) -e -C $$contract build; \
		done; \
	else \
		$(MAKE) -e -C contracts/$(CONTRACT) build; \
	fi

# Run a single make task for a specific contract. For example:
#
# make run CONTRACT=stack-reorder TASK=adjust_stack_size STACK_SIZE=0x200000
TASK :=
run:
	$(MAKE) -e -C contracts/$(CONTRACT) $(TASK)

# test, check, clippy and fmt here are provided for completeness,
# there is nothing wrong invoking cargo directly instead of make.
test:
	cargo test $(CARGO_ARGS)

check:
	cargo check $(CARGO_ARGS)

clippy:
	cargo clippy $(CARGO_ARGS)

fmt:
	cargo fmt $(CARGO_ARGS)

# Arbitrary cargo command is supported here. For example:
#
# make cargo CARGO_CMD=expand CARGO_ARGS="--ugly"
#
# Invokes:
# cargo expand --ugly
CARGO_CMD :=
cargo:
	cargo $(CARGO_CMD) $(CARGO_ARGS)

clean:
	rm -rf build
	cargo clean

TEMPLATE_TYPE := --git
TEMPLATE_REPO := https://github.com/cryptape/ckb-script-templates
CRATE :=
TEMPLATE := contract
DESTINATION := contracts
generate:
	@set -eu; \
	if [ "x$(CRATE)" = "x" ]; then \
		cargo generate $(TEMPLATE_TYPE) $(TEMPLATE_REPO) $(TEMPLATE) \
			--destination $(DESTINATION); \
		GENERATED_DIR=$$(ls -dt $(DESTINATION)/* | head -n 1); \
		sed "s,@@INSERTION_POINT@@,@@INSERTION_POINT@@\n  \"$$GENERATED_DIR\"\,," Cargo.toml > Cargo.toml.new; \
		mv Cargo.toml.new Cargo.toml; \
	else \
		cargo generate $(TEMPLATE_TYPE) $(TEMPLATE_REPO) $(TEMPLATE) \
			--destination $(DESTINATION) \
			--name $(CRATE); \
		sed '/@@INSERTION_POINT@@/s/$$/\n  "$(DESTINATION)\/$(CRATE)",/' Cargo.toml > Cargo.toml.new; \
		mv Cargo.toml.new Cargo.toml; \
	fi

prepare:
	rustup target add riscv64imac-unknown-none-elf

# Generate checksum info for reproducible build
CHECKSUM_FILE := build/checksums-$(MODE).txt
checksum: build
	shasum -a 256 build/$(MODE)/* > $(CHECKSUM_FILE)

.PHONY: build test check clippy fmt cargo clean prepare checksum


================================================
File: checksums.txt
================================================
3d659b15f2aad5f9350f55ce471806c6d6ad4f51a555a82b7918e9d88f84f04a  build/release/ccc-btc-lock
a1744f76c77b3ec3f780db12c77b5dab024d3878e8ccc0bcde266e300c3c8de5  build/release/ccc-eth-lock
66bbb7041a10a0b2a2fd51ae2aa9394e9f7ee6e8b2b32dd5d3e4d37c0d4a64b8  build/release/ccc-sol-lock


================================================
File: rust-toolchain
================================================
1.75.0

================================================
File: contracts/ccc-btc-lock/README.md
================================================
# ccc-btc-lock

CCC BTC lock implementation. See [specification](../../docs/btc.md) for more information.


================================================
File: contracts/ccc-btc-lock/Cargo.toml
================================================
[package]
name = "ccc-btc-lock"
version = "0.1.0"
edition = "2021"

[dependencies]
ckb-std = "0.15"
ckb-lock-helper = { path = "../../crates/ckb-lock-helper" }
k256 = { version = "=0.13.1", default-features = false, features = ["arithmetic", "ecdsa", "alloc"] }
hex = { version = "0.4", default-features = false, features = ["alloc"] }
sha2 = { version = "0.10.8", default-features = false }
ripemd = { version = "0.1.3", default-features = false }


================================================
File: contracts/ccc-btc-lock/Makefile
================================================
# We cannot use $(shell pwd), which will return unix path format on Windows,
# making it hard to use.
cur_dir = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))

TOP := $(cur_dir)
# RUSTFLAGS that are likely to be tweaked by developers. For example,
# while we enable debug logs by default here, some might want to strip them
# for minimal code size / consumed cycles.
CUSTOM_RUSTFLAGS := --cfg debug_assertions
# RUSTFLAGS that are less likely to be tweaked by developers. Most likely
# one would want to keep the default values here.
FULL_RUSTFLAGS := -C target-feature=+zba,+zbb,+zbc,+zbs $(CUSTOM_RUSTFLAGS)
# Additional cargo args to append here. For example, one can use
# make test CARGO_ARGS="-- --nocapture" so as to inspect data emitted to
# stdout in unit tests
CARGO_ARGS :=
MODE := release
# Tweak this to change the clang version to use for building C code. By default
# we use a bash script with somes heuristics to find clang in current system.
CLANG := $(shell $(TOP)/scripts/find_clang)
AR := $(subst clang,llvm-ar,$(CLANG))
# When this is set to some value, the generated binaries will be copied over
BUILD_DIR :=
# Generated binaries to copy. By convention, a Rust crate's directory name will
# likely match the crate name, which is also the name of the final binary.
# However if this is not the case, you can tweak this variable. As the name hints,
# more than one binary is supported here.
BINARIES := $(notdir $(shell pwd))

ifeq (release,$(MODE))
	MODE_ARGS := --release
endif

default: build test

build:
	RUSTFLAGS="$(FULL_RUSTFLAGS)" TARGET_CC="$(CLANG)" TARGET_AR="$(AR)" \
		cargo build --target=riscv64imac-unknown-none-elf $(MODE_ARGS) $(CARGO_ARGS)
	@set -eu; \
	if [ "x$(BUILD_DIR)" != "x" ]; then \
		for binary in $(BINARIES); do \
			echo "Copying binary $$binary to build directory"; \
			cp $(TOP)/target/riscv64imac-unknown-none-elf/$(MODE)/$$binary $(TOP)/$(BUILD_DIR); \
		done \
	fi

# test, check, clippy and fmt here are provided for completeness,
# there is nothing wrong invoking cargo directly instead of make.
test:
	cargo test $(CARGO_ARGS)

check:
	cargo check $(CARGO_ARGS)

clippy:
	cargo clippy $(CARGO_ARGS)

fmt:
	cargo fmt $(CARGO_ARGS)

# Arbitrary cargo command is supported here. For example:
#
# make cargo CARGO_CMD=expand CARGO_ARGS="--ugly"
# 
# Invokes:
# cargo expand --ugly
CARGO_CMD :=
cargo:
	cargo $(CARGO_CMD) $(CARGO_ARGS)

clean:
	cargo clean

prepare:
	rustup target add riscv64imac-unknown-none-elf

.PHONY: build test check clippy fmt cargo clean prepare


================================================
File: contracts/ccc-btc-lock/.gitignore
================================================
/build
/target


================================================
File: contracts/ccc-btc-lock/src/entry.rs
================================================
use crate::error::Error;
use alloc::vec::Vec;
use ckb_lock_helper::{generate_sighash_all, println_hex, secp256k1_patch::recover_from_prehash};
use ckb_std::{
    ckb_constants::Source,
    high_level::{load_script, load_witness_args},
};
use k256::ecdsa::{RecoveryId, Signature};
use ripemd::{Digest, Ripemd160};
use sha2::Sha256;

fn ripemd160_sha256(msg: &[u8]) -> [u8; 20] {
    ripemd160(&sha256(msg))
}

fn ripemd160(message: &[u8]) -> [u8; 20] {
    let mut hasher = Ripemd160::new();
    hasher.update(message);
    hasher.finalize().into()
}

fn sha256(msg: &[u8]) -> [u8; 32] {
    let mut hasher = Sha256::new();
    hasher.update(msg);
    hasher.finalize().into()
}

fn sha256_sha256(msg: &[u8]) -> [u8; 32] {
    sha256(&sha256(msg))
}

fn message_hash(msg: &str) -> [u8; 32] {
    // Only 32-bytes hex representation of the hash is allowed.
    assert_eq!(msg.len(), 64);
    // Text used to signify that a signed message follows and to prevent inadvertently signing a transaction.
    const CKB_PREFIX: &str = "Signing a CKB transaction: 0x";
    const CKB_SUFFIX: &str = "\n\nIMPORTANT: Please verify the integrity and authenticity of connected BTC wallet before signing this message\n";
    const BTC_PREFIX: &str = "Bitcoin Signed Message:\n";
    let mut data: Vec<u8> = Vec::new();
    assert_eq!(BTC_PREFIX.len(), 24);
    data.push(24);
    data.extend(BTC_PREFIX.as_bytes());
    data.push((CKB_PREFIX.len() + msg.len() + CKB_SUFFIX.len()) as u8);
    data.extend(CKB_PREFIX.as_bytes());
    data.extend(msg.as_bytes());
    data.extend(CKB_SUFFIX.as_bytes());
    sha256_sha256(&data)
}

pub fn entry() -> Result<(), Error> {
    let script = load_script()?;
    let pubkey_hash_expect = script.args().raw_data();
    if pubkey_hash_expect.len() != 20 {
        return Err(Error::WrongPubkeyHash);
    }
    let sighash_all = generate_sighash_all()?;
    let sighash_all_hex = hex::encode(&sighash_all);
    let digest_hash = message_hash(&sighash_all_hex);
    let witness_args = load_witness_args(0, Source::GroupInput)?;
    let sig_raw = witness_args
        .lock()
        .to_opt()
        .ok_or(Error::WrongSignatureFormat)?
        .raw_data();
    if sig_raw.len() != 65 {
        return Err(Error::WrongSignatureFormat);
    }
    let rec_id = match sig_raw[0] {
        31 | 32 | 33 | 34 => sig_raw[0] - 31,
        39 | 40 | 41 | 42 => sig_raw[0] - 39,
        _ => sig_raw[0],
    };
    let rec_id = RecoveryId::try_from(rec_id).map_err(|_| Error::InvalidRecoverId)?;
    let sig = Signature::from_slice(&sig_raw[1..]).map_err(|_| Error::WrongSignatureFormat)?;
    let pubkey_result = recover_from_prehash(&digest_hash, &sig, rec_id)
        .map_err(|_| Error::CanNotRecover)?
        .to_sec1_bytes();
    assert!(pubkey_result.len() == 33);
    let pubkey_hash_result = ripemd160_sha256(&pubkey_result);
    println_hex("pubkey_hash_result", pubkey_hash_result.as_ref());
    println_hex("pubkey_hash_expect", pubkey_hash_expect.as_ref());
    if pubkey_hash_result.as_ref() != pubkey_hash_expect.as_ref() {
        return Err(Error::PubkeyHashMismatched);
    }
    Ok(())
}


================================================
File: contracts/ccc-btc-lock/src/error.rs
================================================
use ckb_lock_helper::error::Error as HelperError;
use ckb_std::error::SysError;

#[repr(i8)]
pub enum Error {
    IndexOutOfBound = 1,
    ItemMissing,
    LengthNotEnough,
    Encoding,
    Unknown = 30,
    WrongWitnessArgs,
    WrongPubkeyHash,
    PubkeyHashMismatched,
    WrongSignatureFormat,
    InvalidRecoverId,
    CanNotRecover,
}

impl From<HelperError> for Error {
    fn from(value: HelperError) -> Self {
        match value {
            HelperError::IndexOutOfBound => Error::IndexOutOfBound,
            HelperError::ItemMissing => Error::ItemMissing,
            HelperError::LengthNotEnough => Error::LengthNotEnough,
            HelperError::Encoding => Error::Encoding,
            HelperError::Unknown => Error::Unknown,
            HelperError::WrongWitnessArgs => Error::WrongWitnessArgs,
        }
    }
}

impl From<SysError> for Error {
    fn from(err: SysError) -> Self {
        match err {
            SysError::IndexOutOfBound => Self::IndexOutOfBound,
            SysError::ItemMissing => Self::ItemMissing,
            SysError::LengthNotEnough(_) => Self::LengthNotEnough,
            SysError::Encoding => Self::Encoding,
            SysError::Unknown(_) => Self::Unknown,
        }
    }
}


================================================
File: contracts/ccc-btc-lock/src/main.rs
================================================
#![no_std]
#![no_main]

mod entry;
mod error;

use ckb_std::default_alloc;
ckb_std::entry!(program_entry);
default_alloc!(4 * 1024, 1400 * 1024, 64);

use entry::entry;

pub fn program_entry() -> i8 {
    match entry() {
        Ok(_) => 0,
        Err(e) => {
            let result = e as i8;
            assert!(result != 0);
            result
        }
    }
}


================================================
File: contracts/ccc-eth-lock/README.md
================================================
# ccc-eth-lock

CCC ETH lock implementation. See [specification](../../docs/eth.md) for more information.


================================================
File: contracts/ccc-eth-lock/Cargo.toml
================================================
[package]
name = "ccc-eth-lock"
version = "0.1.0"
edition = "2021"

[dependencies]
ckb-std = "0.15"
ckb-lock-helper = { path = "../../crates/ckb-lock-helper" }
hex = { version = "0.4", default-features = false, features = ["alloc"] }
k256 = { version = "=0.13.1", default-features = false, features = ["arithmetic", "ecdsa", "alloc"] }
sha3 = { version = "0.10.8", default-features = false }


================================================
File: contracts/ccc-eth-lock/Makefile
================================================
# We cannot use $(shell pwd), which will return unix path format on Windows,
# making it hard to use.
cur_dir = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))

TOP := $(cur_dir)
# RUSTFLAGS that are likely to be tweaked by developers. For example,
# while we enable debug logs by default here, some might want to strip them
# for minimal code size / consumed cycles.
CUSTOM_RUSTFLAGS := --cfg debug_assertions
# RUSTFLAGS that are less likely to be tweaked by developers. Most likely
# one would want to keep the default values here.
FULL_RUSTFLAGS := -C target-feature=+zba,+zbb,+zbc,+zbs $(CUSTOM_RUSTFLAGS)
# Additional cargo args to append here. For example, one can use
# make test CARGO_ARGS="-- --nocapture" so as to inspect data emitted to
# stdout in unit tests
CARGO_ARGS :=
MODE := release
# Tweak this to change the clang version to use for building C code. By default
# we use a bash script with somes heuristics to find clang in current system.
CLANG := $(shell $(TOP)/scripts/find_clang)
AR := $(subst clang,llvm-ar,$(CLANG))
# When this is set to some value, the generated binaries will be copied over
BUILD_DIR :=
# Generated binaries to copy. By convention, a Rust crate's directory name will
# likely match the crate name, which is also the name of the final binary.
# However if this is not the case, you can tweak this variable. As the name hints,
# more than one binary is supported here.
BINARIES := $(notdir $(shell pwd))

ifeq (release,$(MODE))
	MODE_ARGS := --release
endif

default: build test

build:
	RUSTFLAGS="$(FULL_RUSTFLAGS)" TARGET_CC="$(CLANG)" TARGET_AR="$(AR)" \
		cargo build --target=riscv64imac-unknown-none-elf $(MODE_ARGS) $(CARGO_ARGS)
	@set -eu; \
	if [ "x$(BUILD_DIR)" != "x" ]; then \
		for binary in $(BINARIES); do \
			echo "Copying binary $$binary to build directory"; \
			cp $(TOP)/target/riscv64imac-unknown-none-elf/$(MODE)/$$binary $(TOP)/$(BUILD_DIR); \
		done \
	fi

# test, check, clippy and fmt here are provided for completeness,
# there is nothing wrong invoking cargo directly instead of make.
test:
	cargo test $(CARGO_ARGS)

check:
	cargo check $(CARGO_ARGS)

clippy:
	cargo clippy $(CARGO_ARGS)

fmt:
	cargo fmt $(CARGO_ARGS)

# Arbitrary cargo command is supported here. For example:
#
# make cargo CARGO_CMD=expand CARGO_ARGS="--ugly"
# 
# Invokes:
# cargo expand --ugly
CARGO_CMD :=
cargo:
	cargo $(CARGO_CMD) $(CARGO_ARGS)

clean:
	cargo clean

prepare:
	rustup target add riscv64imac-unknown-none-elf

.PHONY: build test check clippy fmt cargo clean prepare


================================================
File: contracts/ccc-eth-lock/.gitignore
================================================
/build
/target


================================================
File: contracts/ccc-eth-lock/src/entry.rs
================================================
use crate::error::Error;
use alloc::format;
use alloc::vec::Vec;
use ckb_lock_helper::{generate_sighash_all, println_hex, secp256k1_patch::recover_from_prehash};
use ckb_std::{
    ckb_constants::Source,
    high_level::{load_script, load_witness_args},
};
use k256::ecdsa::{RecoveryId, Signature};
use sha3::Digest;

fn keccak(msg: &[u8]) -> [u8; 32] {
    let mut hasher = sha3::Keccak256::new();
    hasher.update(msg);
    hasher.finalize().into()
}

fn keccak160(msg: &[u8]) -> [u8; 20] {
    let mut output = [0u8; 20];
    output.copy_from_slice(&keccak(msg)[12..]);
    output
}

fn message_hash(msg: &str) -> [u8; 32] {
    // Only 32-bytes hex representation of the hash is allowed.
    assert_eq!(msg.len(), 64);
    // Text used to signify that a signed message follows and to prevent inadvertently signing a transaction.
    const CKB_PREFIX: &str = "Signing a CKB transaction: 0x";
    const CKB_SUFFIX: &str = "\n\nIMPORTANT: Please verify the integrity and authenticity of connected Ethereum wallet before signing this message\n";
    const ETH_PREFIX: &str = "Ethereum Signed Message:\n";
    let mut data: Vec<u8> = Vec::new();
    assert_eq!(ETH_PREFIX.len(), 25);
    data.push(25);
    data.extend(ETH_PREFIX.as_bytes());
    data.extend(
        format!(
            "{}",
            (CKB_PREFIX.len() + msg.len() + CKB_SUFFIX.len()) as u8
        )
        .as_bytes(),
    );
    data.extend(CKB_PREFIX.as_bytes());
    data.extend(msg.as_bytes());
    data.extend(CKB_SUFFIX.as_bytes());
    keccak(&data)
}

pub fn entry() -> Result<(), Error> {
    let script = load_script()?;
    let pubkey_hash_expect = script.args().raw_data();
    if pubkey_hash_expect.len() != 20 {
        return Err(Error::WrongPubkeyHash);
    }
    let sighash_all = generate_sighash_all()?;
    let sighash_all_hex = hex::encode(&sighash_all);
    let digest_hash = message_hash(&sighash_all_hex);
    let witness_args = load_witness_args(0, Source::GroupInput)?;
    let sig_raw = witness_args
        .lock()
        .to_opt()
        .ok_or(Error::WrongSignatureFormat)?
        .raw_data();
    if sig_raw.len() != 65 {
        return Err(Error::WrongSignatureFormat);
    }
    let rec_id = sig_raw[64].wrapping_sub(27);
    if rec_id >= 2 {
        return Err(Error::InvalidRecoverId);
    }
    let rec_id = RecoveryId::try_from(rec_id).map_err(|_| Error::InvalidRecoverId)?;
    let sig = Signature::from_slice(&sig_raw[..64]).map_err(|_| Error::WrongSignatureFormat)?;
    let pubkey_result = &recover_from_prehash(&digest_hash, &sig, rec_id)
        .map_err(|_| Error::CanNotRecover)?
        .to_encoded_point(false)
        .to_bytes()[1..];
    assert!(pubkey_result.len() == 64);
    let pubkey_hash_result = keccak160(&pubkey_result);
    println_hex("pubkey_hash_result", pubkey_hash_result.as_ref());
    println_hex("pubkey_hash_expect", pubkey_hash_expect.as_ref());
    if pubkey_hash_result.as_ref() != pubkey_hash_expect.as_ref() {
        return Err(Error::PubkeyHashMismatched);
    }
    Ok(())
}


================================================
File: contracts/ccc-eth-lock/src/error.rs
================================================
use ckb_lock_helper::error::Error as HelperError;
use ckb_std::error::SysError;

#[repr(i8)]
pub enum Error {
    IndexOutOfBound = 1,
    ItemMissing,
    LengthNotEnough,
    Encoding,
    Unknown = 30,
    WrongWitnessArgs,
    WrongPubkeyHash,
    PubkeyHashMismatched,
    WrongSignatureFormat,
    InvalidRecoverId,
    CanNotRecover,
}

impl From<HelperError> for Error {
    fn from(value: HelperError) -> Self {
        match value {
            HelperError::IndexOutOfBound => Error::IndexOutOfBound,
            HelperError::ItemMissing => Error::ItemMissing,
            HelperError::LengthNotEnough => Error::LengthNotEnough,
            HelperError::Encoding => Error::Encoding,
            HelperError::Unknown => Error::Unknown,
            HelperError::WrongWitnessArgs => Error::WrongWitnessArgs,
        }
    }
}

impl From<SysError> for Error {
    fn from(err: SysError) -> Self {
        match err {
            SysError::IndexOutOfBound => Self::IndexOutOfBound,
            SysError::ItemMissing => Self::ItemMissing,
            SysError::LengthNotEnough(_) => Self::LengthNotEnough,
            SysError::Encoding => Self::Encoding,
            SysError::Unknown(_) => Self::Unknown,
        }
    }
}


================================================
File: contracts/ccc-eth-lock/src/main.rs
================================================
#![no_std]
#![no_main]

mod entry;
mod error;

use ckb_std::default_alloc;
ckb_std::entry!(program_entry);
default_alloc!(4 * 1024, 1400 * 1024, 64);

use entry::entry;

pub fn program_entry() -> i8 {
    match entry() {
        Ok(_) => 0,
        Err(e) => {
            let result = e as i8;
            assert!(result != 0);
            result
        }
    }
}


================================================
File: contracts/ccc-sol-lock/README.md
================================================
# ccc-sol-lock

CCC SOL lock implementation. See [specification](../../docs/sol.md) for more information.


================================================
File: contracts/ccc-sol-lock/Cargo.toml
================================================
[package]
name = "ccc-sol-lock"
version = "0.1.0"
edition = "2021"

[dependencies]
ckb-std = "0.15"
ckb-lock-helper = { path = "../../crates/ckb-lock-helper" }
ed25519-dalek = { version = "2.1.1", default-features = false }
hex = { version = "0.4", default-features = false, features = ["alloc"] }


================================================
File: contracts/ccc-sol-lock/Makefile
================================================
# We cannot use $(shell pwd), which will return unix path format on Windows,
# making it hard to use.
cur_dir = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))

TOP := $(cur_dir)
# RUSTFLAGS that are likely to be tweaked by developers. For example,
# while we enable debug logs by default here, some might want to strip them
# for minimal code size / consumed cycles.
CUSTOM_RUSTFLAGS := --cfg debug_assertions
# RUSTFLAGS that are less likely to be tweaked by developers. Most likely
# one would want to keep the default values here.
FULL_RUSTFLAGS := -C target-feature=+zba,+zbb,+zbc,+zbs $(CUSTOM_RUSTFLAGS)
# Additional cargo args to append here. For example, one can use
# make test CARGO_ARGS="-- --nocapture" so as to inspect data emitted to
# stdout in unit tests
CARGO_ARGS :=
MODE := release
# Tweak this to change the clang version to use for building C code. By default
# we use a bash script with somes heuristics to find clang in current system.
CLANG := $(shell $(TOP)/scripts/find_clang)
AR := $(subst clang,llvm-ar,$(CLANG))
# When this is set to some value, the generated binaries will be copied over
BUILD_DIR :=
# Generated binaries to copy. By convention, a Rust crate's directory name will
# likely match the crate name, which is also the name of the final binary.
# However if this is not the case, you can tweak this variable. As the name hints,
# more than one binary is supported here.
BINARIES := $(notdir $(shell pwd))

ifeq (release,$(MODE))
	MODE_ARGS := --release
endif

default: build test

build:
	RUSTFLAGS="$(FULL_RUSTFLAGS)" TARGET_CC="$(CLANG)" TARGET_AR="$(AR)" \
		cargo build --target=riscv64imac-unknown-none-elf $(MODE_ARGS) $(CARGO_ARGS)
	@set -eu; \
	if [ "x$(BUILD_DIR)" != "x" ]; then \
		for binary in $(BINARIES); do \
			echo "Copying binary $$binary to build directory"; \
			cp $(TOP)/target/riscv64imac-unknown-none-elf/$(MODE)/$$binary $(TOP)/$(BUILD_DIR); \
		done \
	fi

# test, check, clippy and fmt here are provided for completeness,
# there is nothing wrong invoking cargo directly instead of make.
test:
	cargo test $(CARGO_ARGS)

check:
	cargo check $(CARGO_ARGS)

clippy:
	cargo clippy $(CARGO_ARGS)

fmt:
	cargo fmt $(CARGO_ARGS)

# Arbitrary cargo command is supported here. For example:
#
# make cargo CARGO_CMD=expand CARGO_ARGS="--ugly"
# 
# Invokes:
# cargo expand --ugly
CARGO_CMD :=
cargo:
	cargo $(CARGO_CMD) $(CARGO_ARGS)

clean:
	cargo clean

prepare:
	rustup target add riscv64imac-unknown-none-elf

.PHONY: build test check clippy fmt cargo clean prepare


================================================
File: contracts/ccc-sol-lock/.gitignore
================================================
/build
/target


================================================
File: contracts/ccc-sol-lock/src/entry.rs
================================================
use crate::error::Error;
use alloc::string::String;
use ckb_lock_helper::{blake2b::blake160, generate_sighash_all};
use ckb_std::{
    ckb_constants::Source,
    high_level::{load_script, load_witness_args},
};
use ed25519_dalek::{Signature, Verifier, VerifyingKey, PUBLIC_KEY_LENGTH};

fn message_wrap(msg: &str) -> String {
    // Only 32-bytes hex representation of the hash is allowed.
    assert_eq!(msg.len(), 64);
    // Text used to signify that a signed message follows and to prevent inadvertently signing a transaction.
    const CKB_PREFIX: &str = "Signing a CKB transaction: 0x";
    const CKB_SUFFIX: &str = "\n\nIMPORTANT: Please verify the integrity and authenticity of connected Solana wallet before signing this message\n";
    [CKB_PREFIX, msg, CKB_SUFFIX].join("")
}

pub fn entry() -> Result<(), Error> {
    let script = load_script()?;
    let pubkey_hash_expect = script.args().raw_data();
    if pubkey_hash_expect.len() != 20 {
        return Err(Error::WrongPubkey);
    }
    let sighash_all = generate_sighash_all()?;
    let sighash_all_hex = hex::encode(&sighash_all);
    let msg = message_wrap(&sighash_all_hex);
    let witness_args = load_witness_args(0, Source::GroupInput)?;
    let witness_args_lock = witness_args
        .lock()
        .to_opt()
        .ok_or(Error::WrongSignatureFormat)?
        .raw_data();
    if witness_args_lock.len() != 96 {
        return Err(Error::WrongSignatureFormat);
    }
    let sig =
        Signature::from_slice(&witness_args_lock[..64]).map_err(|_| Error::WrongSignatureFormat)?;
    let mut pubkey = [0u8; PUBLIC_KEY_LENGTH];
    pubkey.copy_from_slice(&witness_args_lock[64..]);
    let pubkey_hash_result = blake160(&pubkey);
    if pubkey_hash_result.as_ref() != pubkey_hash_expect.as_ref() {
        return Err(Error::WrongPubkey);
    }
    let pubkey = VerifyingKey::from_bytes(&pubkey).map_err(|_| Error::WrongPubkey)?;
    pubkey
        .verify(msg.as_bytes(), &sig)
        .map_err(|_| Error::WrongSignature)?;
    Ok(())
}


================================================
File: contracts/ccc-sol-lock/src/error.rs
================================================
use ckb_lock_helper::error::Error as HelperError;
use ckb_std::error::SysError;

#[repr(i8)]
pub enum Error {
    IndexOutOfBound = 1,
    ItemMissing,
    LengthNotEnough,
    Encoding,
    Unknown = 30,
    WrongWitnessArgs,
    WrongPubkey,
    WrongSignatureFormat,
    WrongSignature,
}

impl From<HelperError> for Error {
    fn from(value: HelperError) -> Self {
        match value {
            HelperError::IndexOutOfBound => Error::IndexOutOfBound,
            HelperError::ItemMissing => Error::ItemMissing,
            HelperError::LengthNotEnough => Error::LengthNotEnough,
            HelperError::Encoding => Error::Encoding,
            HelperError::Unknown => Error::Unknown,
            HelperError::WrongWitnessArgs => Error::WrongWitnessArgs,
        }
    }
}

impl From<SysError> for Error {
    fn from(err: SysError) -> Self {
        match err {
            SysError::IndexOutOfBound => Self::IndexOutOfBound,
            SysError::ItemMissing => Self::ItemMissing,
            SysError::LengthNotEnough(_) => Self::LengthNotEnough,
            SysError::Encoding => Self::Encoding,
            SysError::Unknown(_) => Self::Unknown,
        }
    }
}


================================================
File: contracts/ccc-sol-lock/src/main.rs
================================================
#![no_std]
#![no_main]

mod entry;
mod error;

use ckb_std::default_alloc;
ckb_std::entry!(program_entry);
default_alloc!(4 * 1024, 1400 * 1024, 64);

use entry::entry;

pub fn program_entry() -> i8 {
    match entry() {
        Ok(_) => 0,
        Err(e) => {
            let result = e as i8;
            assert!(result != 0);
            result
        }
    }
}


================================================
File: crates/ckb-lock-helper/Cargo.toml
================================================
[package]
name = "ckb-lock-helper"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
blake2b-ref = "0.3.1"
ckb-std = { version = "0.15", features = ["allocator", "ckb-types", "calc-hash"]}
hex = { version = "0.4", default-features = false, features = ["alloc"]}
k256 = { version = "=0.13.1", default-features = false, features = ["arithmetic", "ecdsa", "alloc"] }


================================================
File: crates/ckb-lock-helper/src/blake2b.rs
================================================
pub use blake2b_ref::{Blake2b, Blake2bBuilder};

pub const CKB_PERSONALIZATION: &[u8] = b"ckb-default-hash";

pub fn new_blake2b() -> Blake2b {
    Blake2bBuilder::new(32)
        .personal(CKB_PERSONALIZATION)
        .build()
}

pub fn new_blake2b_stat() -> Blake2bStatistics {
    Blake2bStatistics::new(new_blake2b())
}

pub fn blake160(data: &[u8]) -> [u8; 20] {
    let mut blake2b = new_blake2b();
    let mut hash = [0u8; 32];
    blake2b.update(data);
    blake2b.finalize(&mut hash);
    let mut ret = [0u8; 20];
    ret.copy_from_slice(&hash[0..20]);
    ret
}

pub struct Blake2bStatistics {
    count: usize,
    blake2b: Blake2b,
}

impl Blake2bStatistics {
    pub fn new(blake2b: Blake2b) -> Self {
        Self { count: 0, blake2b }
    }

    pub fn update(&mut self, data: &[u8]) {
        self.blake2b.update(data);
        self.count += data.len();
    }
    pub fn finalize(self, dst: &mut [u8]) {
        self.blake2b.finalize(dst)
    }
    pub fn count(&self) -> usize {
        self.count
    }
}


================================================
File: crates/ckb-lock-helper/src/error.rs
================================================
use ckb_std::error::SysError;

#[repr(i8)]
pub enum Error {
    IndexOutOfBound = 1,
    ItemMissing,
    LengthNotEnough,
    Encoding,
    Unknown = 10,
    WrongWitnessArgs,
}

impl From<SysError> for Error {
    fn from(err: SysError) -> Self {
        match err {
            SysError::IndexOutOfBound => Self::IndexOutOfBound,
            SysError::ItemMissing => Self::ItemMissing,
            SysError::LengthNotEnough(_) => Self::LengthNotEnough,
            SysError::Encoding => Self::Encoding,
            SysError::Unknown(_) => Self::Unknown,
        }
    }
}


================================================
File: crates/ckb-lock-helper/src/lib.rs
================================================
#![no_std]
#![no_main]
extern crate alloc;
pub mod blake2b;
pub mod error;
pub mod secp256k1_patch;

use crate::blake2b::new_blake2b_stat;
use crate::error::Error;
use alloc::vec;
use ckb_std::ckb_constants::{InputField, Source};
use ckb_std::ckb_types::bytes::Bytes;
use ckb_std::ckb_types::prelude::*;
use ckb_std::debug;
use ckb_std::high_level::{load_tx_hash, load_witness, load_witness_args};
use ckb_std::syscalls::{load_input_by_field, SysError};

pub fn println_hex(name: &str, data: &[u8]) {
    debug!("{}(len={}): {}", name, data.len(), hex::encode(data));
}

pub fn generate_sighash_all() -> Result<[u8; 32], Error> {
    let mut blake2b_ctx = new_blake2b_stat();
    let tx_hash = load_tx_hash()?;
    blake2b_ctx.update(&tx_hash);

    let args = load_witness_args(0, Source::GroupInput)?;
    let lock = args.lock().to_opt().ok_or(Error::WrongWitnessArgs)?;
    let lock: Bytes = lock.unpack();
    let lock: Bytes = vec![0u8; lock.len()].into();
    let args = args.as_builder().lock(Some(lock).pack()).build();
    let first_witness = args.as_bytes();
    blake2b_ctx.update(&(first_witness.len() as u64).to_le_bytes());
    blake2b_ctx.update(&first_witness);

    let mut i = 1;
    loop {
        let ret = load_witness(i, Source::GroupInput);
        match ret {
            Err(SysError::IndexOutOfBound) => break,
            Err(x) => return Err(x.into()),
            Ok(data) => {
                i += 1;
                blake2b_ctx.update(&(data.len() as u64).to_le_bytes());
                blake2b_ctx.update(&data);
            }
        }
    }

    let mut i = calculate_inputs_len()?;

    loop {
        let ret = load_witness(i, Source::Input);
        match ret {
            Err(SysError::IndexOutOfBound) => break,
            Err(x) => return Err(x.into()),
            Ok(data) => {
                i += 1;
                blake2b_ctx.update(&(data.len() as u64).to_le_bytes());
                blake2b_ctx.update(&data);
            }
        }
    }
    let mut sighash_all = [0u8; 32];
    debug!("hashed {} bytes in sighash_all", blake2b_ctx.count());
    blake2b_ctx.finalize(&mut sighash_all);
    println_hex("sighash_all", &sighash_all);
    Ok(sighash_all)
}

fn calculate_inputs_len() -> Result<usize, Error> {
    let mut temp = [0u8; 8];
    let mut i = 0;
    loop {
        let ret = load_input_by_field(&mut temp, 0, i, Source::Input, InputField::Since);
        match ret {
            Err(SysError::IndexOutOfBound) => break,
            Err(x) => return Err(x.into()),
            Ok(_) => i += 1,
        }
    }
    Ok(i)
}


================================================
File: crates/ckb-lock-helper/src/secp256k1_patch.rs
================================================
use k256::ecdsa::hazmat::bits2field;
use k256::ecdsa::signature::Result;
use k256::ecdsa::{Error, RecoveryId, Signature, VerifyingKey};
use k256::elliptic_curve::bigint::CheckedAdd;
use k256::elliptic_curve::ops::{Invert, LinearCombination, Reduce};
use k256::elliptic_curve::point::DecompressPoint;
use k256::elliptic_curve::{AffinePoint, Curve, FieldBytesEncoding, PrimeField, ProjectivePoint};
use k256::{Scalar, Secp256k1};

/// Equivalent to VerifyingKey::recover_from_prehash but the final verification process is removed.
/// Ref: https://github.com/RustCrypto/signatures/issues/751.
#[allow(non_snake_case)]
pub fn recover_from_prehash(
    prehash: &[u8],
    signature: &Signature,
    recovery_id: RecoveryId,
) -> Result<VerifyingKey> {
    let (r, s) = signature.split_scalars();
    let z = <Scalar as Reduce<<Secp256k1 as k256::elliptic_curve::Curve>::Uint>>::reduce_bytes(
        &bits2field::<Secp256k1>(prehash)?,
    );

    let mut r_bytes = r.to_repr();
    if recovery_id.is_x_reduced() {
        match Option::<<Secp256k1 as k256::elliptic_curve::Curve>::Uint>::from(
            <Secp256k1 as k256::elliptic_curve::Curve>::Uint::decode_field_bytes(&r_bytes)
                .checked_add(&Secp256k1::ORDER),
        ) {
            Some(restored) => r_bytes = restored.encode_field_bytes(),
            // No reduction should happen here if r was reduced
            None => return Err(Error::new()),
        };
    }
    let R = AffinePoint::<Secp256k1>::decompress(&r_bytes, u8::from(recovery_id.is_y_odd()).into());

    if R.is_none().into() {
        return Err(Error::new());
    }

    let R = ProjectivePoint::<Secp256k1>::from(R.unwrap());
    let r_inv = *r.invert();
    let u1 = -(r_inv * z);
    let u2 = r_inv * *s;
    let pk = ProjectivePoint::<Secp256k1>::lincomb(
        &ProjectivePoint::<Secp256k1>::GENERATOR,
        &u1,
        &R,
        &u2,
    );
    let vk = VerifyingKey::from_affine(pk.into())?;
    Ok(vk)
}


================================================
File: deployment/.gitignore
================================================
info.json


================================================
File: deployment/testnet/btc-lock/deployment.toml
================================================
[[cells]]
name = "ccc-btc-lock"
enable_type_id = true 
location = { file = "../../../build/release/ccc-btc-lock" }

# The lock script set to output cells
[lock]
code_hash = "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8"
args = "0x9c26427b733e19f774e74312382946db9548093a"
hash_type = "type"


================================================
File: deployment/testnet/btc-lock/step-1-gen-txs.sh
================================================
#!/bin/bash
set -ex
cd ../../.. && shasum -a 256 -c checksums.txt && cd -

ckb-cli --url https://testnet.ckb.dev deploy gen-txs \
    --deployment-config ./deployment.toml \
    --migration-dir ./migrations \
    --fee-rate 3000 \
    --from-address ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsqvuyep8kue7r8mhfe6rzguzj3kmj4yqjwsg8lepn \
    --info-file info.json


================================================
File: deployment/testnet/btc-lock/step-2-sign.sh
================================================
#!/bin/bash
ckb-cli --url https://testnet.ckb.dev deploy sign-txs \
    --from-account ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsqvuyep8kue7r8mhfe6rzguzj3kmj4yqjwsg8lepn \
    --add-signatures \
    --info-file info.json


================================================
File: deployment/testnet/btc-lock/step-3-apply.sh
================================================
#!/bin/bash

ckb-cli --url https://testnet.ckb.dev deploy apply-txs --migration-dir ./migrations --info-file info.json


================================================
File: deployment/testnet/btc-lock/migrations/2024-08-02-064528.json
================================================
{
  "cell_recipes": [
    {
      "name": "ccc-btc-lock",
      "tx_hash": "0xba5a1a77019be0e8942119ad549f01ca3c61fd9f911aa46e27d508a802236614",
      "index": 0,
      "occupied_capacity": 13903000000000,
      "data_hash": "0x3fa562b394f65aac8c2649b6d7d1dea25c677ccfcd4d912e63b272b78bbacb14",
      "type_id": "0x8f026d6113b24800e04bfb33703f98dfaa6db6719097ab5d3050db9cf4fec45e"
    }
  ],
  "dep_group_recipes": []
}

================================================
File: deployment/testnet/eth-lock/deployment.toml
================================================
[[cells]]
name = "ccc-eth-lock"
enable_type_id = true 
location = { file = "../../../build/release/ccc-eth-lock" }

# The lock script set to output cells
[lock]
code_hash = "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8"
args = "0x9c26427b733e19f774e74312382946db9548093a"
hash_type = "type"


================================================
File: deployment/testnet/eth-lock/step-1-gen-txs.sh
================================================
#!/bin/bash
set -ex
cd ../../.. && shasum -a 256 -c checksums.txt && cd -

ckb-cli --url https://testnet.ckb.dev deploy gen-txs \
    --deployment-config ./deployment.toml \
    --migration-dir ./migrations \
    --fee-rate 3000 \
    --from-address ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsqvuyep8kue7r8mhfe6rzguzj3kmj4yqjwsg8lepn \
    --info-file info.json


================================================
File: deployment/testnet/eth-lock/step-2-sign.sh
================================================
#!/bin/bash
ckb-cli --url https://testnet.ckb.dev deploy sign-txs \
    --from-account ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsqvuyep8kue7r8mhfe6rzguzj3kmj4yqjwsg8lepn \
    --add-signatures \
    --info-file info.json


================================================
File: deployment/testnet/eth-lock/step-3-apply.sh
================================================
#!/bin/bash

ckb-cli --url https://testnet.ckb.dev deploy apply-txs --migration-dir ./migrations --info-file info.json


================================================
File: deployment/testnet/eth-lock/migrations/2024-08-02-064738.json
================================================
{
  "cell_recipes": [
    {
      "name": "ccc-eth-lock",
      "tx_hash": "0x2e6a50a9ce96c7b9697ed0fd21bd0a736d3df5e62d25137f728d8354a36cb369",
      "index": 0,
      "occupied_capacity": 12726200000000,
      "data_hash": "0x66be3ce5f50be813bc583e733583db33bc1757b462006258471e52e358aced50",
      "type_id": "0x5b1983cf4242009f72e82b37fb6b36790e6d4858474046fc3c798e5142cf8835"
    }
  ],
  "dep_group_recipes": []
}

================================================
File: deployment/testnet/sol-lock/deployment.toml
================================================
[[cells]]
name = "ccc-sol-lock"
enable_type_id = true 
location = { file = "../../../build/release/ccc-sol-lock" }

# The lock script set to output cells
[lock]
code_hash = "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8"
args = "0x9c26427b733e19f774e74312382946db9548093a"
hash_type = "type"


================================================
File: deployment/testnet/sol-lock/step-1-gen-txs.sh
================================================
#!/bin/bash
set -ex
cd ../../.. && shasum -a 256 -c checksums.txt && cd -

ckb-cli --url https://testnet.ckb.dev deploy gen-txs \
    --deployment-config ./deployment.toml \
    --migration-dir ./migrations \
    --fee-rate 3000 \
    --from-address ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsqvuyep8kue7r8mhfe6rzguzj3kmj4yqjwsg8lepn \
    --info-file info.json


================================================
File: deployment/testnet/sol-lock/step-2-sign.sh
================================================
#!/bin/bash
ckb-cli --url https://testnet.ckb.dev deploy sign-txs \
    --from-account ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsqvuyep8kue7r8mhfe6rzguzj3kmj4yqjwsg8lepn \
    --add-signatures \
    --info-file info.json


================================================
File: deployment/testnet/sol-lock/step-3-apply.sh
================================================
#!/bin/bash

ckb-cli --url https://testnet.ckb.dev deploy apply-txs --migration-dir ./migrations --info-file info.json


================================================
File: deployment/testnet/sol-lock/migrations/2024-08-02-064926.json
================================================
{
  "cell_recipes": [
    {
      "name": "ccc-sol-lock",
      "tx_hash": "0x3fae7df1db56ae21edfd98054995bbbf7331aaebad66c3e1632b84eb50904531",
      "index": 0,
      "occupied_capacity": 8423000000000,
      "data_hash": "0x697ca3d2731f2eca7e1725353ce5b07f30fc4577a6e9250e2232a0f90f97a877",
      "type_id": "0x98870bb4f49768bbd5bcf48b7cd189ab8a2cf2649869715c00a5d3cedd9db86b"
    }
  ],
  "dep_group_recipes": []
}

================================================
File: docs/btc.md
================================================
# CCC BTC Lock Specification
This specification describes a CCC lock script that can interoperate with the
BTC blockchain. Some common designs, definitions, and conventions can be found
in the [overview](./overview.md).

## Lock Script
A CCC BTC lock script has following structure:
```
Code hash: CCC BTC lock script code hash
Hash type: CCC BTC lock script hash type
Args:  <secp256k1 pubkey hash, 20 bytes>
```
This secp256k1 pubkey hash is calculated via SHA-256 and RIPEMD-160 over
compressed secp256k1 pubkey(33 bytes).

## Supported BTC Addresses
The following address types are supported:
- P2PKH
- P2WPKH

The secp256k1 pubkey hash can be decoded from address via base58 or bech32m(bech32).


## Witness
The corresponding witness must be a proper `WitnessArgs` data structure in
molecule format. In the lock field of the WitnessArgs, a 65 bytes secp256k1
signature must be present.

The first byte of the signature is the `header` described in [BIP
0137](https://github.com/bitcoin/bips/blob/master/bip-0137.mediawiki#procedure-for-signingverifying-a-signature).
The `r` and `s` values follow it. The `header` can accept following value ranges:
- 0~3
- 27~30 (P2PKH)
- 39-42 (P2WPKH)

They will be converted into 0~3 as `recId`.


## Unlocking Process
The following bytes are hashed via SHA-256 over SHA-256 (double SHA-256):

1. A byte representing the length of the following string (24).
2. A string with 24 bytes: "Bitcoin Signed Message:\n".
3. A byte representing the length of the following string.
4. A string with bytes:

"Signing a CKB transaction: 0x{sigh_hash}\n\nIMPORTANT: Please verify the integrity and authenticity of connected BTC wallet before signing this message\n"

The `{sighasl_all}` is replaced by `sighash_all` in hexadecimal string, with length 64. The
string in the last part can be displayed in wallet UIs.

After hashing, this hash value is the message used in secp256k1 verification.
The signature with `recId` is used to recover pubkey(compressed), according to
the message above. If the SHA-256 and RIPEMD-160 over recovered compressed
pubkey is identical to script args, then the script is validated successfully.

## Examples

```yaml
CellDeps:
    <vec> CCC BTC lock script cell
Inputs:
    <vec> Cell
        Data: <...>
        Type: <...>
        Lock:
            code_hash: <CCC BTC lock script code hash>
            args: <secp256k1 pubkey hash, 20 bytes>
Outputs:
    <vec> Any cell
Witnesses:
    <vec> WitnessArgs
      Lock: <recId, 1 byte> <r, 32 bytes> <s, 32 bytes>
```



## Notes

An implementation of the lock script spec above has been deployed to CKB mainnet and testnet:

- mainnet

| parameter   | value                                                                |
| ----------- | -------------------------------------------------------------------- |
| `code_hash` | TODO   |
| `hash_type` | `type`                                                               |
| `tx_hash`   | TODO   |
| `index`     | `0x0`                                                                |
| `dep_type`  | `code`                                                               |

- testnet

| parameter   | value                                                                |
| ----------- | -------------------------------------------------------------------- |
| `code_hash` | 0x8f026d6113b24800e04bfb33703f98dfaa6db6719097ab5d3050db9cf4fec45e   |
| `hash_type` | `type`                                                               |
| `tx_hash`   | 0xba5a1a77019be0e8942119ad549f01ca3c61fd9f911aa46e27d508a802236614   |
| `index`     | `0x0`                                                                |
| `dep_type`  | `code`                                                               |

Reproducible build is supported to verify the deployed script. To build the
deployed script above, one can use the following steps:

```bash
git clone https://github.com/ckb-ecofund/ccc-locks.git
cd ccc-locks
git checkout 87ac79
bash scripts/reproducible_build_docker
```



================================================
File: docs/eth.md
================================================
# CCC Ethereum Lock Specification
This specification describes a CCC lock script that can interoperate with the
Ethereum blockchain. Some common designs, definitions, and conventions can be found
in the [overview](./overview.md).

## Lock Script
A CCC Ethereum lock script has following structure:
```
Code hash: CCC Ethereum lock script code hash
Hash type: CCC Ethereum lock script hash type
Args:  <secp256k1 pubkey hash, 20 bytes>
```

The secp256k1 pubkey hash is calculated via the following procedure(referred as keccak160):

1. Perform a [Keccak](https://github.com/ethereum/eth-hash) hash over the uncompressed secp256k1 pubkey (64 bytes).
2. Take the trailing 20 bytes of the hash result.

The secp256k1 pubkey hash can be also decoded from an Ethereum address in
hexadecimal format. 


## Witness
The corresponding witness must be a proper `WitnessArgs` data structure in
molecule format. In the lock field of the WitnessArgs, a 65 bytes secp256k1
signature must be present.

The last byte of the signature is the `v` value described in Ethereum yellow paper
(324). This `v` can only be 27 or 28 and other values are rejected. The `r` and
`s` values precede it. The `recId` is derived from `v` using the formula `v -
27`.

## Unlocking Process
The following bytes are hashed via Keccak hashing:

1. A byte representing the length of the following string (25).
2. A string with 25 bytes: "Ethereum Signed Message:\n".
3. Three bytes representing the length of the following string. It is in decimal
   string format(e.g. "155", "166"). Note that this format is different from the
   length used in step 1.
4. A string with bytes:

"Signing a CKB transaction: 0x{sigh_hash}\n\nIMPORTANT: Please verify the integrity and authenticity of connected Ethereum wallet before signing this message\n"

The `{sighasl_all}` is replaced by `sighash_all` in hexadecimal string, with length 64. The
string in the last part can be displayed in wallet UIs.

After hashing, this hash value is the message used in secp256k1 verification.
The signature with `recId` is used to recover uncompressed pubkey, according to
the message above. If the keccak160 on uncompressed pubkey is identical to
script args, then the script is validated successfully.

## Examples

```yaml
CellDeps:
    <vec> CCC Ethereum lock script cell
Inputs:
    <vec> Cell
        Data: <...>
        Type: <...>
        Lock:
            code_hash: <CCC Ethereum lock script code hash>
            args: <secp256k1 pubkey hash, 20 bytes>
Outputs:
    <vec> Any cell
Witnesses:
    <vec> WitnessArgs
      Lock: <r, 32 bytes> <s, 32 bytes> <v, 1 byte> 
```



## Notes

An implementation of the lock script spec above has been deployed to CKB mainnet and testnet:

- mainnet

| parameter   | value                                                                |
| ----------- | -------------------------------------------------------------------- |
| `code_hash` | TODO   |
| `hash_type` | `type`                                                               |
| `tx_hash`   | TODO   |
| `index`     | `0x0`                                                                |
| `dep_type`  | `code`                                                               |

- testnet

| parameter   | value                                                                |
| ----------- | -------------------------------------------------------------------- |
| `code_hash` | 0x5b1983cf4242009f72e82b37fb6b36790e6d4858474046fc3c798e5142cf8835   |
| `hash_type` | `type`                                                               |
| `tx_hash`   | 0x2e6a50a9ce96c7b9697ed0fd21bd0a736d3df5e62d25137f728d8354a36cb369   |
| `index`     | `0x0`                                                                |
| `dep_type`  | `code`                                                               |

Reproducible build is supported to verify the deployed script. To build the
deployed script above, one can use the following steps:

```bash
git clone https://github.com/ckb-ecofund/ccc-locks.git
cd ccc-locks
git checkout 87ac79
bash scripts/reproducible_build_docker
```



================================================
File: docs/overview.md
================================================
# CCC Locks Overview
## Introduction
[CCC (Common Chains Connector)](https://github.com/ckb-ecofund/ccc) helps
developers interoperate wallets from different chain ecosystems with CKB, fully
enabling CKB's cryptographic freedom power. In this overview specification, we
describe some common designs, definitions, and conventions. The lock
specifications for dedicated chains can be found in other documents. The
definitions and conventions in this section apply to all CCC lock
specifications, including BTC, ETH, and more.


## `ckbhash`
CKB uses blake2b as the default hash algorithm. We use `ckbhash` to denote the
blake2b hash function with following configuration:

- output digest size: 32
- personalization: ckb-default-hash

The `blake160` function is defined to return the leading 20 bytes of the `ckbhash` result.


## sighash_all

A 32-byte `sighash_all` message can be calculated via `ckbhash` with following data:

* Transaction hash
* Witness length and content in same script group covered by inputs, excluding lock field
* Other witness length and content that not covered by inputs

A reference implementation in C can be found [here](https://github.com/nervosnetwork/ckb-system-scripts/blob/a7b7c75662ed950c9bd024e15f83ce702a54996e/c/secp256k1_blake160_sighash_all.c#L219).

## WitnessArgs
When unlocking a CCC lock script, the corresponding witness must be a proper
`WitnessArgs` data structure in molecule format. In the lock field of the
WitnessArgs, a signature must be present. Signatures can be different for
different chains.

## Hexadecimal String
Only lowercase letters can be used in hexadecimal strings. For example, "00" and
"ffee" are valid hexadecimal strings, while "FFEE" and "hello world" are not
valid. 

## Links
- [BTC](./btc.md)
- ETH


================================================
File: docs/sol.md
================================================
# CCC Solana Lock Specification

This specification describes a CCC lock script that can interoperate with the Solana blockchain. Some common designs, definitions, and conventions can be found in the [overview](./overview.md).

## Lock Script

A CCC Solana lock script has following structure:

```
Code hash: CCC Solana lock script code hash
Hash type: CCC Solana lock script hash type
Args:  <ed25519 pubkey hash, 20 bytes>
```

Ed25519 pubkey hash is calculated via blake160 over Ed25519 pubkey (32 bytes). The ed25519 pubkey can be also decoded from an Solana address by base58 decoding.

## Witness

The corresponding witness must be a proper `WitnessArgs` data structure in molecule format. In the lock field of the WitnessArgs, a 64 bytes ed25519 signature and a 32 bytes ed25519 pubkey must be present, totaling 96 bytes.

## Unlocking Process

Ed25519 messages can be of any length and does not require hashing. Specifically, for the CCC Solana lock, the message is:

"Signing a CKB transaction: 0x{sigh_hash}\n\nIMPORTANT: Please verify the integrity and authenticity of connected Solana wallet before signing this message\n"

The `{sighasl_all}` is replaced by `sighash_all` in hexadecimal string, with length 64. The string in the last part can be displayed in wallet UIs.

After verifying that the pubkey and pubkey hash are consistent, for the ed25519 message, signature, and pubkey, the ed25519 verify function is used. If the verification passes, the signature is successfully verified.

## Examples

```yaml
CellDeps:
    <vec> CCC Solana lock script cell
Inputs:
    <vec> Cell
        Data: <...>
        Type: <...>
        Lock:
            code_hash: <CCC Solana lock script code hash>
            args: <ed25519 pubkey hash, 20 bytes>
Outputs:
    <vec> Any cell
Witnesses:
    <vec> WitnessArgs
      Lock: <signature, 64 bytes> + <pubkey, 32 bytes>
```



## Notes

An implementation of the lock script spec above has been deployed to CKB mainnet and testnet:

- mainnet

| parameter   | value                                                                |
| ----------- | -------------------------------------------------------------------- |
| `code_hash` | TODO   |
| `hash_type` | `type`                                                               |
| `tx_hash`   | TODO   |
| `index`     | `0x0`                                                                |
| `dep_type`  | `code`                                                               |

- testnet

| parameter   | value                                                                |
| ----------- | -------------------------------------------------------------------- |
| `code_hash` | 0x98870bb4f49768bbd5bcf48b7cd189ab8a2cf2649869715c00a5d3cedd9db86b   |
| `hash_type` | `type`                                                               |
| `tx_hash`   | 0x3fae7df1db56ae21edfd98054995bbbf7331aaebad66c3e1632b84eb50904531   |
| `index`     | `0x0`                                                                |
| `dep_type`  | `code`                                                               |

Reproducible build is supported to verify the deployed script. To build the deployed script above, one can use the following steps:

```bash
git clone https://github.com/ckb-ecofund/ccc-locks.git
cd ccc-locks
git checkout 87ac79
bash scripts/reproducible_build_docker
```


================================================
File: scripts/find_clang
================================================
#!/usr/bin/env bash
#
# An utility script used to find a binary of clang 16+

if [[ -n "${CLANG}" ]]; then
  echo "${CLANG}"
  exit 0
fi

CANDIDATES=("clang" "clang-16" "clang-17" "clang-18")

BREW_PREFIX=$(brew --prefix 2> /dev/null)
if [[ -n "${BREW_PREFIX}" ]]; then
  CANDIDATES+=(
    "${BREW_PREFIX}/opt/llvm/bin/clang"
    "${BREW_PREFIX}/opt/llvm@16/bin/clang"
    "${BREW_PREFIX}/opt/llvm@17/bin/clang"
    "${BREW_PREFIX}/opt/llvm@18/bin/clang"
  )
fi

for candidate in ${CANDIDATES[@]}; do
  OUTPUT=$($candidate -dumpversion 2> /dev/null | cut -d'.' -f 1)

  if [[ $((OUTPUT)) -ge 16 ]]; then
    echo "$candidate"
    exit 0
  fi
done

>&2 echo "Cannot find clang of version 16+!"
exit 1


================================================
File: scripts/reproducible_build_docker
================================================
#!/usr/bin/env bash
#
# An utility script helping with reproducible script builds via docker.
# Note that this utility serves only as one example, docker is not
# necessarily THE way to do reproducible build, nor is it the best way
# to do reproducible build.
set -ex

DOCKER="${DOCKER:-docker}"
# docker pull docker.io/cryptape/llvm-n-rust:20240630
DOCKER_IMAGE="${DOCKER_IMAGE:-docker.io/cryptape/llvm-n-rust@sha256:bafaf76d4f342a69b8691c08e77a330b7740631f3d1d9c9bee4ead521b29ee55}"
CHECKSUM_FILE_PATH="${CHECKSUM_FILE_PATH:-checksums.txt}"

# We are parsing command line arguments based on tips from:
# https://stackoverflow.com/a/14203146

while [[ $# -gt 0 ]]; do
  case $1 in
    -p|--proxy)
      PROXY="$2"
      shift # past argument
      shift # past value
      ;;
    -u|--update)
      UPDATE="yes"
      shift # past argument
      ;;
    --no-clean)
      NOCLEAN="yes"
      shift # past argument
      ;;
    -*|--*)
      echo "Unknown option $1"
      exit 1
      ;;
    *)
      echo "Unknown argument $1"
      exit 1
      ;;
  esac
done

if [[ -n "${PROXY}" ]]; then
  DOCKER_RUN_ARGS="-e ALL_PROXY=${PROXY} -e HTTPS_PROXY=${PROXY} -e HTTP_PROXY=${PROXY} ${DOCKER_RUN_ARGS}"
fi

TASKS=""
if [[ "${NOCLEAN}" != "yes" ]]; then
  TASKS+=" clean "
fi

if [[ "${UPDATE}" = "yes" ]]; then
  TASKS+=" checksum CHECKSUM_FILE=${CHECKSUM_FILE_PATH} "
else
  TASKS+=" build "
fi

$DOCKER run --rm $DOCKER_RUN_ARGS -v `pwd`:/code $DOCKER_IMAGE make $TASKS
# Reset file ownerships for all files docker might touch
$DOCKER run --rm $DOCKER_RUN_ARGS -e UID=`id -u` -e GID=`id -g` -v `pwd`:/code $DOCKER_IMAGE bash -c 'chown -R -f $UID:$GID checksums.txt build target'

if [[ "${UPDATE}" = "yes" ]]; then
  echo "${CHECKSUM_FILE_PATH} file is updated with latest binary hashes!"
else
  shasum -a 256 -c ${CHECKSUM_FILE_PATH}
fi


================================================
File: tests/Cargo.lock
================================================
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "addr2line"
version = "0.22.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e4503c46a5c0c7844e948c9a4d6acd9f50cccb4de1c48eb9e291ea17470c678"
dependencies = [
 "gimli",
]

[[package]]
name = "adler"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe"

[[package]]
name = "anyhow"
version = "1.0.86"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b3d1d046238990b9cf5bcde22a3fb3584ee5cf65fb2765f454ed428c7a0063da"

[[package]]
name = "autocfg"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0c4b4d0bd25bd0b74681c0ad21497610ce1b7c91b1022cd21c80c6fbdd9476b0"

[[package]]
name = "backtrace"
version = "0.3.73"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5cc23269a4f8976d0a4d2e7109211a419fe30e8d88d677cd60b6bc79c5732e0a"
dependencies = [
 "addr2line",
 "cc",
 "cfg-if",
 "libc",
 "miniz_oxide",
 "object",
 "rustc-demangle",
]

[[package]]
name = "base16ct"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4c7f02d4ea65f2c1853089ffd8d2787bdbc63de2f0d29dedbcf8ccdfa0ccd4cf"

[[package]]
name = "base64"
version = "0.21.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9d297deb1925b89f2ccc13d7635fa0714f12c87adce1c75356b39ca9b7178567"

[[package]]
name = "base64"
version = "0.22.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b3254f16251a8381aa12e40e3c4d2f0199f8c6508fbecb9d91f575e0fbb8c6"

[[package]]
name = "base64ct"
version = "1.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8c3c1a368f70d6cf7302d78f8f7093da241fb8e8807c05cc9e51a125895a6d5b"

[[package]]
name = "bit-vec"
version = "0.6.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "349f9b6a179ed607305526ca489b34ad0a41aed5f7980fa90eb03160b69598fb"

[[package]]
name = "bitflags"
version = "2.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b048fb63fd8b5923fc5aa7b340d8e156aec7ec02f0c78fa8a6ddc2613f6f71de"

[[package]]
name = "blake2b-ref"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "294d17c72e0ba59fad763caa112368d0672083779cdebbb97164f4bb4c1e339a"

[[package]]
name = "blake2b-rs"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a89a8565807f21b913288968e391819e7f9b2f0f46c7b89549c051cccf3a2771"
dependencies = [
 "cc",
 "cty",
]

[[package]]
name = "block-buffer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
dependencies = [
 "generic-array",
]

[[package]]
name = "byteorder"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"

[[package]]
name = "bytes"
version = "1.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a12916984aab3fa6e39d655a33e09c0071eb36d6ab3aea5c2d78551f1df6d952"
dependencies = [
 "serde",
]

[[package]]
name = "cacache"
version = "12.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "142316461ed3a3dfcba10417317472da5bfd0461e4d276bf7c07b330766d9490"
dependencies = [
 "digest",
 "either",
 "futures",
 "hex",
 "libc",
 "memmap2",
 "miette",
 "reflink-copy",
 "serde",
 "serde_derive",
 "serde_json",
 "sha1",
 "sha2",
 "ssri",
 "tempfile",
 "thiserror",
 "tokio",
 "tokio-stream",
 "walkdir",
]

[[package]]
name = "cc"
version = "1.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "324c74f2155653c90b04f25b2a47a8a631360cb908f92a772695f430c7e31052"

[[package]]
name = "ccc-lock-tests"
version = "0.1.0"
dependencies = [
 "base64 0.22.1",
 "blake2b-ref",
 "ckb-chain-spec",
 "ckb-crypto",
 "ckb-error",
 "ckb-jsonrpc-types",
 "ckb-script",
 "ckb-traits",
 "ckb-types",
 "ed25519-dalek",
 "hex",
 "k256",
 "ripemd",
 "serde_json",
 "sha2",
 "sha3",
]

[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "ckb-chain-spec"
version = "0.116.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e955d55380bbd2ca883b4426fb1483e61f06fe65c8b377d5d4bceeb03ecf07bb"
dependencies = [
 "cacache",
 "ckb-constant",
 "ckb-crypto",
 "ckb-dao-utils",
 "ckb-error",
 "ckb-hash",
 "ckb-jsonrpc-types",
 "ckb-logger",
 "ckb-pow",
 "ckb-rational",
 "ckb-resource",
 "ckb-traits",
 "ckb-types",
 "serde",
 "toml",
]

[[package]]
name = "ckb-channel"
version = "0.116.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "853f561e90ff59d858dc87c1ac385fae948984859c874fd8d3bd1bbab335889d"
dependencies = [
 "crossbeam-channel",
]

[[package]]
name = "ckb-constant"
version = "0.116.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5baf91b16a3b8360c85211dfdff3d2adc0a1f3ae571ea6b1637d55d6b227e312"

[[package]]
name = "ckb-crypto"
version = "0.116.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e2094270f5632808cbff1c37a37ffb9b3e79f7a99e78927fb228d8c343793eb"
dependencies = [
 "ckb-fixed-hash",
 "faster-hex",
 "lazy_static",
 "rand",
 "secp256k1",
 "thiserror",
]

[[package]]
name = "ckb-dao-utils"
version = "0.116.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6eb3606c602a424098317bfde4b7d6427d4fe5dfe1a6d4ebc831ce0308508085"
dependencies = [
 "byteorder",
 "ckb-error",
 "ckb-types",
]

[[package]]
name = "ckb-error"
version = "0.116.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "01041f8a1d7eeaf85caca3547bb78d929d6a4d62774509d7eb438b6bc310ba30"
dependencies = [
 "anyhow",
 "ckb-occupied-capacity",
 "derive_more",
 "thiserror",
]

[[package]]
name = "ckb-fixed-hash"
version = "0.116.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a7491f18717b84827923935cc5adb1bcdf9c924e377b478d089f4694e7c779b"
dependencies = [
 "ckb-fixed-hash-core",
 "ckb-fixed-hash-macros",
]

[[package]]
name = "ckb-fixed-hash-core"
version = "0.116.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9509f63fedb9b6e42cfd0db47d3dc5acb6b029da546d5d4451d08afc44c70cf8"
dependencies = [
 "ckb_schemars",
 "faster-hex",
 "serde",
 "thiserror",
]

[[package]]
name = "ckb-fixed-hash-macros"
version = "0.116.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fdd89533a5da746f50798752a46f5f084f110c849335be94baf506790ebee931"
dependencies = [
 "ckb-fixed-hash-core",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "ckb-gen-types"
version = "0.116.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a0f2d0f4224507a027d25d64824dd0dc8d367c8b5bead30289eaffe1381a7fb"
dependencies = [
 "cfg-if",
 "ckb-error",
 "ckb-fixed-hash",
 "ckb-hash",
 "ckb-occupied-capacity",
 "molecule",
 "numext-fixed-uint",
]

[[package]]
name = "ckb-hash"
version = "0.116.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d5754bc49cf76a7e8829fe6a7cf1eea1284cbca9777b521f072c76d6ae28d303"
dependencies = [
 "blake2b-ref",
 "blake2b-rs",
]

[[package]]
name = "ckb-jsonrpc-types"
version = "0.116.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ef7e123043ca3701cf05ba4c3699b34f3b179609109a4c8c3afa68922f722be7"
dependencies = [
 "ckb-types",
 "ckb_schemars",
 "faster-hex",
 "serde",
 "serde_json",
]

[[package]]
name = "ckb-logger"
version = "0.116.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59ebecd56c9acb453bdcb5c39e66b6b7f980bdf72b35515750bc295fa635287d"
dependencies = [
 "log",
]

[[package]]
name = "ckb-merkle-mountain-range"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56ccb671c5921be8a84686e6212ca184cb1d7c51cadcdbfcbd1cc3f042f5dfb8"
dependencies = [
 "cfg-if",
]

[[package]]
name = "ckb-occupied-capacity"
version = "0.116.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee4aa07af7cec38d15cfe4c1ce150514fba5a4e78996bbbd098982106bee7d8d"
dependencies = [
 "ckb-occupied-capacity-core",
 "ckb-occupied-capacity-macros",
]

[[package]]
name = "ckb-occupied-capacity-core"
version = "0.116.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a63ed90996ba24ab26d5ac8ae22fd002a293f4a4e4526042e1adf84b1889e176"
dependencies = [
 "serde",
]

[[package]]
name = "ckb-occupied-capacity-macros"
version = "0.116.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a6aae3f1f8d194cd5bd4328c9c7281f0d7acc73976b2771576cdc06a9ed608f"
dependencies = [
 "ckb-occupied-capacity-core",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "ckb-pow"
version = "0.116.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eb981de6e56107cd3e1660a9105bb07891277b21604946f70bf5097dd03690f7"
dependencies = [
 "byteorder",
 "ckb-hash",
 "ckb-types",
 "eaglesong",
 "log",
 "serde",
]

[[package]]
name = "ckb-rational"
version = "0.116.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed570e816c80fffdfafb58c7c895df8c08c64ba56ce79d824e5ff976dd1a7381"
dependencies = [
 "numext-fixed-uint",
 "serde",
]

[[package]]
name = "ckb-resource"
version = "0.116.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d482493fabf4ce3670277d7dbaa5811872379535031431dc6b19699722c7b846"
dependencies = [
 "ckb-system-scripts",
 "ckb-types",
 "includedir",
 "includedir_codegen",
 "phf",
 "serde",
 "walkdir",
]

[[package]]
name = "ckb-script"
version = "0.116.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a2d6528e95a0f93d4a39e569b1ffffd60cbb0a9ae8f1c96dd465e2576ad510a9"
dependencies = [
 "byteorder",
 "ckb-chain-spec",
 "ckb-error",
 "ckb-hash",
 "ckb-logger",
 "ckb-traits",
 "ckb-types",
 "ckb-vm",
 "faster-hex",
 "serde",
]

[[package]]
name = "ckb-system-scripts"
version = "0.5.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa5c59063142de7a68cfad4449c6b3863563856219a2925dfb8c5f019ec2aa47"
dependencies = [
 "blake2b-rs",
 "faster-hex",
 "includedir",
 "includedir_codegen",
 "phf",
]

[[package]]
name = "ckb-traits"
version = "0.116.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c528f704f3088ec2dd467d374920b64b2bbb9ed9c4e8e12931c069a99150d8bc"
dependencies = [
 "ckb-types",
]

[[package]]
name = "ckb-types"
version = "0.116.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b05cc1c6aab0c40b323b233617b67860f9d679fac431a34d1f1b0853d700e9d"
dependencies = [
 "bit-vec",
 "bytes",
 "ckb-channel",
 "ckb-constant",
 "ckb-error",
 "ckb-fixed-hash",
 "ckb-gen-types",
 "ckb-hash",
 "ckb-merkle-mountain-range",
 "ckb-occupied-capacity",
 "ckb-rational",
 "derive_more",
 "golomb-coded-set",
 "merkle-cbt",
 "molecule",
 "numext-fixed-uint",
 "once_cell",
 "paste",
]

[[package]]
name = "ckb-vm"
version = "0.24.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a2c3d68dc7f891e5555c7ebc054722b28ab005e51c5076f54c20d36002dc8e83"
dependencies = [
 "byteorder",
 "bytes",
 "cc",
 "ckb-vm-definitions",
 "derive_more",
 "goblin 0.2.3",
 "goblin 0.4.0",
 "rand",
 "scroll",
 "serde",
]

[[package]]
name = "ckb-vm-definitions"
version = "0.24.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a2fdf9c8ee14409b2208d23b9ad88828242d7881153ddc04872b66d2e018a52f"
dependencies = [
 "paste",
]

[[package]]
name = "ckb_schemars"
version = "0.8.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f21f99fca82a4eb8708e406e99246987b087ecc1e1babeece1a0b1d5238b1750"
dependencies = [
 "ckb_schemars_derive",
 "dyn-clone",
 "serde",
 "serde_json",
]

[[package]]
name = "ckb_schemars_derive"
version = "0.8.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "40c813b4fadbdd9f33b1cf02a1ddfa9537d955c8d2fbe150d1fc1684dbf78e73"
dependencies = [
 "proc-macro2",
 "quote",
 "serde_derive_internals",
 "syn 1.0.109",
]

[[package]]
name = "const-oid"
version = "0.9.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c2459377285ad874054d797f3ccebf984978aa39129f6eafde5cdc8315b612f8"

[[package]]
name = "convert_case"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6245d59a3e82a7fc217c5828a6692dbc6dfb63a0c8c90495621f7b9d79704a0e"

[[package]]
name = "cpufeatures"
version = "0.2.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "53fe5e26ff1b7aef8bca9c6080520cfb8d9333c7568e1829cef191a9723e5504"
dependencies = [
 "libc",
]

[[package]]
name = "crc32fast"
version = "1.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a97769d94ddab943e4510d138150169a2758b5ef3eb191a9ee688de3e23ef7b3"
dependencies = [
 "cfg-if",
]

[[package]]
name = "crossbeam-channel"
version = "0.5.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "33480d6946193aa8033910124896ca395333cae7e2d1113d1fef6c3272217df2"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-utils"
version = "0.8.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22ec99545bb0ed0ea7bb9b8e1e9122ea386ff8a48c0922e43f36d45ab09e0e80"

[[package]]
name = "crypto-bigint"
version = "0.5.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0dc92fb57ca44df6db8059111ab3af99a63d5d0f8375d9972e319a379c6bab76"
dependencies = [
 "generic-array",
 "rand_core 0.6.4",
 "subtle",
 "zeroize",
]

[[package]]
name = "crypto-common"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3"
dependencies = [
 "generic-array",
 "typenum",
]

[[package]]
name = "cty"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b365fabc795046672053e29c954733ec3b05e4be654ab130fe8f1f94d7051f35"

[[package]]
name = "curve25519-dalek"
version = "4.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97fb8b7c4503de7d6ae7b42ab72a5a59857b4c937ec27a3d4539dba95b5ab2be"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "curve25519-dalek-derive",
 "digest",
 "fiat-crypto",
 "rustc_version",
 "subtle",
 "zeroize",
]

[[package]]
name = "curve25519-dalek-derive"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f46882e17999c6cc590af592290432be3bce0428cb0d5f8b6715e4dc7b383eb3"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.71",
]

[[package]]
name = "der"
version = "0.7.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f55bf8e7b65898637379c1b74eb1551107c8294ed26d855ceb9fd1a09cfc9bc0"
dependencies = [
 "const-oid",
 "zeroize",
]

[[package]]
name = "derive_more"
version = "0.99.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f33878137e4dafd7fa914ad4e259e18a4e8e532b9617a2d0150262bf53abfce"
dependencies = [
 "convert_case",
 "proc-macro2",
 "quote",
 "rustc_version",
 "syn 2.0.71",
]

[[package]]
name = "digest"
version = "0.10.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
dependencies = [
 "block-buffer",
 "const-oid",
 "crypto-common",
 "subtle",
]

[[package]]
name = "dyn-clone"
version = "1.0.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0d6ef0072f8a535281e4876be788938b528e9a1d43900b82c2569af7da799125"

[[package]]
name = "eaglesong"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8d978bd5d343e8ab9b5c0fc8d93ff9c602fdc96616ffff9c05ac7a155419b824"

[[package]]
name = "ecdsa"
version = "0.16.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee27f32b5c5292967d2d4a9d7f1e0b0aed2c15daded5a60300e4abb9d8020bca"
dependencies = [
 "der",
 "digest",
 "elliptic-curve",
 "rfc6979",
 "signature",
 "spki",
]

[[package]]
name = "ed25519"
version = "2.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "115531babc129696a58c64a4fef0a8bf9e9698629fb97e9e40767d235cfbcd53"
dependencies = [
 "pkcs8",
 "signature",
]

[[package]]
name = "ed25519-dalek"
version = "2.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a3daa8e81a3963a60642bcc1f90a670680bd4a77535faa384e9d1c79d620871"
dependencies = [
 "curve25519-dalek",
 "ed25519",
 "serde",
 "sha2",
 "subtle",
 "zeroize",
]

[[package]]
name = "either"
version = "1.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "60b1af1c220855b6ceac025d3f6ecdd2b7c4894bfe9cd9bda4fbb4bc7c0d4cf0"

[[package]]
name = "elliptic-curve"
version = "0.13.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b5e6043086bf7973472e0c7dff2142ea0b680d30e18d9cc40f267efbf222bd47"
dependencies = [
 "base16ct",
 "crypto-bigint",
 "digest",
 "ff",
 "generic-array",
 "group",
 "pkcs8",
 "rand_core 0.6.4",
 "sec1",
 "subtle",
 "zeroize",
]

[[package]]
name = "errno"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "534c5cf6194dfab3db3242765c03bbe257cf92f22b38f6bc0c58d59108a820ba"
dependencies = [
 "libc",
 "windows-sys",
]

[[package]]
name = "faster-hex"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "51e2ce894d53b295cf97b05685aa077950ff3e8541af83217fc720a6437169f8"

[[package]]
name = "fastrand"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9fc0510504f03c51ada170672ac806f1f105a88aa97a5281117e1ddc3368e51a"

[[package]]
name = "ff"
version = "0.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ded41244b729663b1e574f1b4fb731469f69f79c17667b5d776b16cda0479449"
dependencies = [
 "rand_core 0.6.4",
 "subtle",
]

[[package]]
name = "fiat-crypto"
version = "0.2.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "28dea519a9695b9977216879a3ebfddf92f1c08c05d984f8996aecd6ecdc811d"

[[package]]
name = "flate2"
version = "1.0.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f54427cfd1c7829e2a139fcefea601bf088ebca651d2bf53ebc600eac295dae"
dependencies = [
 "crc32fast",
 "miniz_oxide",
]

[[package]]
name = "futures"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "645c6916888f6cb6350d2550b80fb63e734897a8498abe35cfb732b6487804b0"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-executor",
 "futures-io",
 "futures-sink",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-channel"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eac8f7d7865dcb88bd4373ab671c8cf4508703796caa2b1985a9ca867b3fcb78"
dependencies = [
 "futures-core",
 "futures-sink",
]

[[package]]
name = "futures-core"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dfc6580bb841c5a68e9ef15c77ccc837b40a7504914d52e47b8b0e9bbda25a1d"

[[package]]
name = "futures-executor"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a576fc72ae164fca6b9db127eaa9a9dda0d61316034f33a0a0d4eda41f02b01d"
dependencies = [
 "futures-core",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-io"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a44623e20b9681a318efdd71c299b6b222ed6f231972bfe2f224ebad6311f0c1"

[[package]]
name = "futures-macro"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87750cf4b7a4c0625b1529e4c543c2182106e4dedc60a2a6455e00d212c489ac"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.71",
]

[[package]]
name = "futures-sink"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9fb8e00e87438d937621c1c6269e53f536c14d3fbd6a042bb24879e57d474fb5"

[[package]]
name = "futures-task"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38d84fa142264698cdce1a9f9172cf383a0c82de1bddcf3092901442c4097004"

[[package]]
name = "futures-util"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3d6401deb83407ab3da39eba7e33987a73c3df0c82b4bb5813ee871c19c41d48"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-io",
 "futures-macro",
 "futures-sink",
 "futures-task",
 "memchr",
 "pin-project-lite",
 "pin-utils",
 "slab",
]

[[package]]
name = "generic-array"
version = "0.14.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
dependencies = [
 "typenum",
 "version_check",
 "zeroize",
]

[[package]]
name = "getrandom"
version = "0.1.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8fc3cb4d91f53b50155bdcfd23f6a4c39ae1969c2ae85982b135750cccaf5fce"
dependencies = [
 "cfg-if",
 "libc",
 "wasi 0.9.0+wasi-snapshot-preview1",
]

[[package]]
name = "getrandom"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c4567c8db10ae91089c99af84c68c38da3ec2f087c3f82960bcdbf3656b6f4d7"
dependencies = [
 "cfg-if",
 "libc",
 "wasi 0.11.0+wasi-snapshot-preview1",
]

[[package]]
name = "gimli"
version = "0.29.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "40ecd4077b5ae9fd2e9e169b102c6c330d0605168eb0e8bf79952b256dbefffd"

[[package]]
name = "goblin"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d20fd25aa456527ce4f544271ae4fea65d2eda4a6561ea56f39fb3ee4f7e3884"
dependencies = [
 "log",
 "plain",
 "scroll",
]

[[package]]
name = "goblin"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "532a09cd3df2c6bbfc795fb0434bff8f22255d1d07328180e918a2e6ce122d4d"
dependencies = [
 "log",
 "plain",
 "scroll",
]

[[package]]
name = "golomb-coded-set"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "812f314a99fb5b7f0f9d0a8388539578f83f3aca6a65f588b8dbeefb731e2f98"
dependencies = [
 "siphasher",
]

[[package]]
name = "group"
version = "0.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f0f9ef7462f7c099f518d754361858f86d8a07af53ba9af0fe635bbccb151a63"
dependencies = [
 "ff",
 "rand_core 0.6.4",
 "subtle",
]

[[package]]
name = "heapsize"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1679e6ea370dee694f91f1dc469bf94cf8f52051d147aec3e1f9497c6fc22461"
dependencies = [
 "winapi",
]

[[package]]
name = "hex"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"

[[package]]
name = "hmac"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c49c37c09c17a53d937dfbb742eb3a961d65a994e6bcdcf37e7399d0cc8ab5e"
dependencies = [
 "digest",
]

[[package]]
name = "includedir"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "afd126bd778c00c43a9dc76d1609a0894bf4222088088b2217ccc0ce9e816db7"
dependencies = [
 "flate2",
 "phf",
]

[[package]]
name = "includedir_codegen"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0ac1500c9780957c9808c4ec3b94002f35aab01483833f5a8bce7dfb243e3148"
dependencies = [
 "flate2",
 "phf_codegen",
 "walkdir",
]

[[package]]
name = "itoa"
version = "1.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49f1f14873335454500d59611f1cf4a4b0f786f9ac11f4312a78e4cf2566695b"

[[package]]
name = "k256"
version = "0.13.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "956ff9b67e26e1a6a866cb758f12c6f8746208489e3e4a4b5580802f2f0a587b"
dependencies = [
 "cfg-if",
 "ecdsa",
 "elliptic-curve",
 "once_cell",
 "sha2",
 "signature",
]

[[package]]
name = "keccak"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ecc2af9a1119c51f12a14607e783cb977bde58bc069ff0c3da1095e635d70654"
dependencies = [
 "cpufeatures",
]

[[package]]
name = "lazy_static"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"

[[package]]
name = "libc"
version = "0.2.155"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97b3888a4aecf77e811145cadf6eef5901f4782c53886191b2f693f24761847c"

[[package]]
name = "linux-raw-sys"
version = "0.4.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78b3ae25bc7c8c38cec158d1f2757ee79e9b3740fbc7ccf0e59e4b08d793fa89"

[[package]]
name = "log"
version = "0.4.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a7a70ba024b9dc04c27ea2f0c0548feb474ec5c54bba33a7f72f873a39d07b24"

[[package]]
name = "memchr"
version = "2.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78ca9ab1a0babb1e7d5695e3530886289c18cf2f87ec19a575a0abdce112e3a3"

[[package]]
name = "memmap2"
version = "0.5.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "83faa42c0a078c393f6b29d5db232d8be22776a891f8f56e5284faee4a20b327"
dependencies = [
 "libc",
]

[[package]]
name = "merkle-cbt"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "171d2f700835121c3b04ccf0880882987a050fd5c7ae88148abf537d33dd3a56"
dependencies = [
 "cfg-if",
]

[[package]]
name = "miette"
version = "5.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59bb584eaeeab6bd0226ccf3509a69d7936d148cf3d036ad350abe35e8c6856e"
dependencies = [
 "miette-derive",
 "once_cell",
 "thiserror",
 "unicode-width",
]

[[package]]
name = "miette-derive"
version = "5.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49e7bc1560b95a3c4a25d03de42fe76ca718ab92d1a22a55b9b4cf67b3ae635c"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.71",
]

[[package]]
name = "miniz_oxide"
version = "0.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b8a240ddb74feaf34a79a7add65a741f3167852fba007066dcac1ca548d89c08"
dependencies = [
 "adler",
]

[[package]]
name = "molecule"
version = "0.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d4fd9767ab5e5f2ea40f71ff4c8bdb633c50509052e093c2fdd0e390a749dfa3"
dependencies = [
 "bytes",
 "cfg-if",
 "faster-hex",
]

[[package]]
name = "numext-constructor"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "621fe0f044729f810c6815cdd77e8f5e0cd803ce4f6a38380ebfc1322af98661"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "numext-fixed-uint"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c68c76f96d589d1009a666c5072f37f3114d682696505f2cf445f27766c7d70"
dependencies = [
 "numext-fixed-uint-core",
 "numext-fixed-uint-hack",
]

[[package]]
name = "numext-fixed-uint-core"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6aab1d6457b97b49482f22a92f0f58a2f39bdd7f3b2f977eae67e8bc206aa980"
dependencies = [
 "heapsize",
 "numext-constructor",
 "rand",
 "serde",
 "thiserror",
]

[[package]]
name = "numext-fixed-uint-hack"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0200f8d55c36ec1b6a8cf810115be85d4814f045e0097dfd50033ba25adb4c9e"
dependencies = [
 "numext-fixed-uint-core",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "object"
version = "0.36.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "081b846d1d56ddfc18fdf1a922e4f6e07a11768ea1b92dec44e42b72712ccfce"
dependencies = [
 "memchr",
]

[[package]]
name = "once_cell"
version = "1.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3fdb12b2476b595f9358c5161aa467c2438859caa136dec86c26fdd2efe17b92"

[[package]]
name = "paste"
version = "1.0.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "57c0d7b74b563b49d38dae00a0c37d4d6de9b432382b2892f0574ddcae73fd0a"

[[package]]
name = "phf"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3dfb61232e34fcb633f43d12c58f83c1df82962dcdfa565a4e866ffc17dafe12"
dependencies = [
 "phf_shared",
]

[[package]]
name = "phf_codegen"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cbffee61585b0411840d3ece935cce9cb6321f01c45477d30066498cd5e1a815"
dependencies = [
 "phf_generator",
 "phf_shared",
]

[[package]]
name = "phf_generator"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "17367f0cc86f2d25802b2c26ee58a7b23faeccf78a396094c13dced0d0182526"
dependencies = [
 "phf_shared",
 "rand",
]

[[package]]
name = "phf_shared"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c00cf8b9eafe68dde5e9eaa2cef8ee84a9336a47d566ec55ca16589633b65af7"
dependencies = [
 "siphasher",
]

[[package]]
name = "pin-project-lite"
version = "0.2.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bda66fc9667c18cb2758a2ac84d1167245054bcf85d5d1aaa6923f45801bdd02"

[[package]]
name = "pin-utils"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"

[[package]]
name = "pkcs8"
version = "0.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f950b2377845cebe5cf8b5165cb3cc1a5e0fa5cfa3e1f7f55707d8fd82e0a7b7"
dependencies = [
 "der",
 "spki",
]

[[package]]
name = "plain"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b4596b6d070b27117e987119b4dac604f3c58cfb0b191112e24771b2faeac1a6"

[[package]]
name = "ppv-lite86"
version = "0.2.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b40af805b3121feab8a3c29f04d8ad262fa8e0561883e7653e024ae4479e6de"

[[package]]
name = "proc-macro2"
version = "1.0.86"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e719e8df665df0d1c8fbfd238015744736151d4445ec0836b8e628aae103b77"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.36"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fa76aaf39101c457836aec0ce2316dbdc3ab723cdda1c6bd4e6ad4208acaca7"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "rand"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6a6b1679d49b24bbfe0c803429aa1874472f50d9b363131f0e89fc356b544d03"
dependencies = [
 "getrandom 0.1.16",
 "libc",
 "rand_chacha",
 "rand_core 0.5.1",
 "rand_hc",
 "rand_pcg",
]

[[package]]
name = "rand_chacha"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f4c8ed856279c9737206bf725bf36935d8666ead7aa69b52be55af369d193402"
dependencies = [
 "ppv-lite86",
 "rand_core 0.5.1",
]

[[package]]
name = "rand_core"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "90bde5296fc891b0cef12a6d03ddccc162ce7b2aff54160af9338f8d40df6d19"
dependencies = [
 "getrandom 0.1.16",
]

[[package]]
name = "rand_core"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
dependencies = [
 "getrandom 0.2.15",
]

[[package]]
name = "rand_hc"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ca3129af7b92a17112d59ad498c6f81eaf463253766b90396d39ea7a39d6613c"
dependencies = [
 "rand_core 0.5.1",
]

[[package]]
name = "rand_pcg"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "16abd0c1b639e9eb4d7c50c0b8100b0d0f849be2349829c740fe8e6eb4816429"
dependencies = [
 "rand_core 0.5.1",
]

[[package]]
name = "reflink-copy"
version = "0.1.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc31414597d1cd7fdd2422798b7652a6329dda0fe0219e6335a13d5bcaa9aeb6"
dependencies = [
 "cfg-if",
 "rustix",
 "windows",
]

[[package]]
name = "rfc6979"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f8dd2a808d456c4a54e300a23e9f5a67e122c3024119acbfd73e3bf664491cb2"
dependencies = [
 "hmac",
 "subtle",
]

[[package]]
name = "ripemd"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bd124222d17ad93a644ed9d011a40f4fb64aa54275c08cc216524a9ea82fb09f"
dependencies = [
 "digest",
]

[[package]]
name = "rustc-demangle"
version = "0.1.24"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "719b953e2095829ee67db738b3bfa9fa368c94900df327b3f07fe6e794d2fe1f"

[[package]]
name = "rustc_version"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bfa0f585226d2e68097d4f95d113b15b83a82e819ab25717ec0590d9584ef366"
dependencies = [
 "semver",
]

[[package]]
name = "rustix"
version = "0.38.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70dc5ec042f7a43c4a73241207cecc9873a06d45debb38b329f8541d85c2730f"
dependencies = [
 "bitflags",
 "errno",
 "libc",
 "linux-raw-sys",
 "windows-sys",
]

[[package]]
name = "ryu"
version = "1.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f3cb5ba0dc43242ce17de99c180e96db90b235b8a9fdc9543c96d2209116bd9f"

[[package]]
name = "same-file"
version = "1.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93fc1dc3aaa9bfed95e02e6eadabb4baf7e3078b0bd1b4d7b6b0b68378900502"
dependencies = [
 "winapi-util",
]

[[package]]
name = "scroll"
version = "0.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fda28d4b4830b807a8b43f7b0e6b5df875311b3e7621d84577188c175b6ec1ec"
dependencies = [
 "scroll_derive",
]

[[package]]
name = "scroll_derive"
version = "0.10.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aaaae8f38bb311444cfb7f1979af0bc9240d95795f75f9ceddf6a59b79ceffa0"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "sec1"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3e97a565f76233a6003f9f5c54be1d9c5bdfa3eccfb189469f11ec4901c47dc"
dependencies = [
 "base16ct",
 "der",
 "generic-array",
 "pkcs8",
 "subtle",
 "zeroize",
]

[[package]]
name = "secp256k1"
version = "0.24.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6b1629c9c557ef9b293568b338dddfc8208c98a18c59d722a9d53f859d9c9b62"
dependencies = [
 "secp256k1-sys",
]

[[package]]
name = "secp256k1-sys"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "83080e2c2fc1006e625be82e5d1eb6a43b7fd9578b617fcc55814daf286bba4b"
dependencies = [
 "cc",
]

[[package]]
name = "semver"
version = "1.0.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "61697e0a1c7e512e84a621326239844a24d8207b4669b41bc18b32ea5cbf988b"

[[package]]
name = "serde"
version = "1.0.204"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bc76f558e0cbb2a839d37354c575f1dc3fdc6546b5be373ba43d95f231bf7c12"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.204"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e0cd7e117be63d3c3678776753929474f3b04a43a080c744d6b0ae2a8c28e222"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.71",
]

[[package]]
name = "serde_derive_internals"
version = "0.26.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85bf8229e7920a9f636479437026331ce11aa132b4dde37d121944a44d6e5f3c"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "serde_json"
version = "1.0.120"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4e0d21c9a8cae1235ad58a00c11cb40d4b1e5c784f1ef2c537876ed6ffd8b7c5"
dependencies = [
 "itoa",
 "ryu",
 "serde",
]

[[package]]
name = "sha-1"
version = "0.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f5058ada175748e33390e40e872bd0fe59a19f265d0158daa551c5a88a76009c"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "sha1"
version = "0.10.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3bf829a2d51ab4a5ddf1352d8470c140cadc8301b2ae1789db023f01cedd6ba"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "sha2"
version = "0.10.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "793db75ad2bcafc3ffa7c68b215fee268f537982cd901d132f89c6343f3a3dc8"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "sha3"
version = "0.10.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75872d278a8f37ef87fa0ddbda7802605cb18344497949862c0d4dcb291eba60"
dependencies = [
 "digest",
 "keccak",
]

[[package]]
name = "signature"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77549399552de45a898a580c1b41d445bf730df867cc44e6c0233bbc4b8329de"
dependencies = [
 "digest",
 "rand_core 0.6.4",
]

[[package]]
name = "siphasher"
version = "0.3.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38b58827f4464d87d377d175e90bf58eb00fd8716ff0a62f80356b5e61555d0d"

[[package]]
name = "slab"
version = "0.4.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f92a496fb766b417c996b9c5e57daf2f7ad3b0bebe1ccfca4856390e3d3bb67"
dependencies = [
 "autocfg",
]

[[package]]
name = "spki"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d91ed6c858b01f942cd56b37a94b3e0a1798290327d1236e4d9cf4eaca44d29d"
dependencies = [
 "base64ct",
 "der",
]

[[package]]
name = "ssri"
version = "9.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "da7a2b3c2bc9693bcb40870c4e9b5bf0d79f9cb46273321bf855ec513e919082"
dependencies = [
 "base64 0.21.7",
 "digest",
 "hex",
 "miette",
 "serde",
 "sha-1",
 "sha2",
 "thiserror",
 "xxhash-rust",
]

[[package]]
name = "subtle"
version = "2.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13c2bddecc57b384dee18652358fb23172facb8a2c51ccc10d74c157bdea3292"

[[package]]
name = "syn"
version = "1.0.109"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "syn"
version = "2.0.71"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b146dcf730474b4bcd16c311627b31ede9ab149045db4d6088b3becaea046462"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "tempfile"
version = "3.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85b77fafb263dd9d05cbeac119526425676db3784113aa9295c88498cbf8bff1"
dependencies = [
 "cfg-if",
 "fastrand",
 "rustix",
 "windows-sys",
]

[[package]]
name = "thiserror"
version = "1.0.62"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f2675633b1499176c2dff06b0856a27976a8f9d436737b4cf4f312d4d91d8bbb"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "1.0.62"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d20468752b09f49e909e55a5d338caa8bedf615594e9d80bc4c565d30faf798c"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.71",
]

[[package]]
name = "tokio"
version = "1.38.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba4f4a02a7a80d6f274636f0aa95c7e383b912d41fe721a31f29e29698585a4a"
dependencies = [
 "backtrace",
 "bytes",
 "pin-project-lite",
 "tokio-macros",
]

[[package]]
name = "tokio-macros"
version = "2.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f5ae998a069d4b5aba8ee9dad856af7d520c3699e6159b185c2acd48155d39a"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.71",
]

[[package]]
name = "tokio-stream"
version = "0.1.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "267ac89e0bec6e691e5813911606935d77c476ff49024f98abcea3e7b15e37af"
dependencies = [
 "futures-core",
 "pin-project-lite",
 "tokio",
]

[[package]]
name = "toml"
version = "0.5.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f4f7f0dd8d50a853a531c426359045b1998f04219d88799810762cd4ad314234"
dependencies = [
 "serde",
]

[[package]]
name = "typenum"
version = "1.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42ff0bf0c66b8238c6f3b578df37d0b7848e55df8577b3f74f92a69acceeb825"

[[package]]
name = "unicode-ident"
version = "1.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3354b9ac3fae1ff6755cb6db53683adb661634f67557942dea4facebec0fee4b"

[[package]]
name = "unicode-width"
version = "0.1.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0336d538f7abc86d282a4189614dfaa90810dfc2c6f6427eaf88e16311dd225d"

[[package]]
name = "version_check"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f"

[[package]]
name = "walkdir"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "29790946404f91d9c5d06f9874efddea1dc06c5efe94541a7d6863108e3a5e4b"
dependencies = [
 "same-file",
 "winapi-util",
]

[[package]]
name = "wasi"
version = "0.9.0+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cccddf32554fecc6acb585f82a32a72e28b48f8c4c1883ddfeeeaa96f7d8e519"

[[package]]
name = "wasi"
version = "0.11.0+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-util"
version = "0.1.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4d4cc384e1e73b93bafa6fb4f1df8c41695c8a91cf9c4c64358067d15a7b6c6b"
dependencies = [
 "windows-sys",
]

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "windows"
version = "0.58.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dd04d41d93c4992d421894c18c8b43496aa748dd4c081bac0dc93eb0489272b6"
dependencies = [
 "windows-core",
 "windows-targets",
]

[[package]]
name = "windows-core"
version = "0.58.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6ba6d44ec8c2591c134257ce647b7ea6b20335bf6379a27dac5f1641fcf59f99"
dependencies = [
 "windows-implement",
 "windows-interface",
 "windows-result",
 "windows-strings",
 "windows-targets",
]

[[package]]
name = "windows-implement"
version = "0.58.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2bbd5b46c938e506ecbce286b6628a02171d56153ba733b6c741fc627ec9579b"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.71",
]

[[package]]
name = "windows-interface"
version = "0.58.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "053c4c462dc91d3b1504c6fe5a726dd15e216ba718e84a0e46a88fbe5ded3515"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.71",
]

[[package]]
name = "windows-result"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1d1043d8214f791817bab27572aaa8af63732e11bf84aa21a45a78d6c317ae0e"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-strings"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4cd9b125c486025df0eabcb585e62173c6c9eddcec5d117d3b6e8c30e2ee4d10"
dependencies = [
 "windows-result",
 "windows-targets",
]

[[package]]
name = "windows-sys"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm",
 "windows_aarch64_msvc",
 "windows_i686_gnu",
 "windows_i686_gnullvm",
 "windows_i686_msvc",
 "windows_x86_64_gnu",
 "windows_x86_64_gnullvm",
 "windows_x86_64_msvc",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "xxhash-rust"
version = "0.8.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "63658493314859b4dfdf3fb8c1defd61587839def09582db50b8a4e93afca6bb"

[[package]]
name = "zeroize"
version = "1.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ced3678a2879b30306d323f4542626697a464a97c0a07c9aebf7ebca65cd4dde"


================================================
File: tests/Cargo.toml
================================================
[workspace]
resolver = "2"
members = []

[package]
name = "ccc-lock-tests"
version = "0.1.0"
edition = "2021"

[dependencies]
base64 = "0.22"
blake2b-ref = "0.3.1"
ckb-chain-spec = "0.116.0"
ckb-crypto = "0.116.0"
ckb-error = "0.116.0"
ckb-jsonrpc-types = "0.116.0"
ckb-script = "0.116.0"
ckb-traits = "0.116.0"
ckb-types = "0.116.0"
ed25519-dalek = "2.1.1"
hex = "0.4"
k256 = "0.13.1"
ripemd = "0.1.3"
serde_json = "1.0"
sha2 = "0.10.8"
sha3 = "0.10.8"


================================================
File: tests/rustfmt.toml
================================================
max_width = 120
use_small_heuristics = "Max"


================================================
File: tests/src/common.rs
================================================
use crate::core::Resource;
use ckb_types::prelude::{Entity, Unpack};
use sha2::Digest;

pub fn assert_script_error(err: ckb_error::Error, err_code: i8) {
    let error_string = err.to_string();
    assert!(
        error_string.contains(format!("error code {}", err_code).as_str()),
        "error_string: {}, expected_error_code: {}",
        error_string,
        err_code
    );
}

pub fn blake160(data: &[u8]) -> [u8; 20] {
    let mut r = [0u8; 20];
    r.copy_from_slice(&blake2b(data)[..20]);
    r
}

pub fn blake2b(data: &[u8]) -> [u8; 32] {
    let mut blake2b = blake2b_ref::Blake2bBuilder::new(32).personal(b"ckb-default-hash").build();
    let mut hash = [0u8; 32];
    blake2b.update(data);
    blake2b.finalize(&mut hash);
    hash
}

pub fn println_hex(name: &str, data: &[u8]) {
    println!("Tester(........): {}(len={}): {}", name, data.len(), hex::encode(data));
}

pub fn println_log(data: &str) {
    println!("Tester(........): {}", data);
}

pub fn println_rtx(tx_resolved: &ckb_types::core::cell::ResolvedTransaction) {
    let tx_json = ckb_jsonrpc_types::TransactionView::from(tx_resolved.transaction.clone());
    println!("Tester(........): {}", serde_json::to_string_pretty(&tx_json).unwrap());
}

pub fn ripemd160(message: &[u8]) -> [u8; 20] {
    let mut hasher = ripemd::Ripemd160::new();
    hasher.update(message);
    hasher.finalize().into()
}

pub fn ripemd160_sha256(msg: &[u8]) -> [u8; 20] {
    ripemd160(&sha256(msg))
}

pub fn sha256(msg: &[u8]) -> [u8; 32] {
    let mut hasher = sha2::Sha256::new();
    hasher.update(msg);
    hasher.finalize().into()
}

pub fn sha256_sha256(msg: &[u8]) -> [u8; 32] {
    sha256(&sha256(msg))
}

pub fn generate_sighash_all(tx: &ckb_types::core::TransactionView, dl: &Resource, i: usize) -> [u8; 32] {
    let mut sighash_all_data: Vec<u8> = vec![];
    sighash_all_data.extend(&tx.hash().raw_data());
    let input_major_outpoint = &tx.inputs().get_unchecked(i).previous_output();
    let input_major = &dl.cell.get(input_major_outpoint).unwrap().cell_output;
    for input in tx.input_pts_iter().take(i) {
        let input = &dl.cell.get(&input).unwrap().cell_output;
        assert_ne!(input_major.lock(), input.lock());
    }
    let witness: ckb_types::bytes::Bytes = tx.witnesses().get_unchecked(i).unpack();
    let witness_len = witness.len() as u64;
    sighash_all_data.extend(&witness_len.to_le_bytes());
    sighash_all_data.extend(&witness);
    for input in tx.input_pts_iter().skip(i + 1) {
        let input = &dl.cell.get(&input).unwrap().cell_output;
        if input_major.lock() == input.lock() {
            let witness = tx.witnesses().get_unchecked(i);
            let witness_len = witness.len() as u64;
            sighash_all_data.extend(&witness_len.to_le_bytes());
            sighash_all_data.extend(&witness.as_bytes());
        }
    }
    for witness in tx.witnesses().into_iter().skip(tx.inputs().len()) {
        let witness_len = witness.len() as u64;
        sighash_all_data.extend(&witness_len.to_le_bytes());
        sighash_all_data.extend(&witness.as_bytes());
    }
    println_log(&format!("hashed {} bytes in sighash_all", sighash_all_data.len()));
    let sighash_all = blake2b(&sighash_all_data);
    println_hex("sighash_all", &sighash_all);
    sighash_all
}


================================================
File: tests/src/core.rs
================================================
use crate::common::println_log;
use ckb_types::prelude::{Builder, Entity, Pack};

#[derive(Clone, Default)]
pub struct Resource {
    pub cell: std::collections::HashMap<ckb_types::packed::OutPoint, ckb_types::core::cell::CellMeta>,
}

impl ckb_traits::CellDataProvider for Resource {
    fn get_cell_data(&self, out_point: &ckb_types::packed::OutPoint) -> Option<ckb_types::bytes::Bytes> {
        self.cell.get(out_point).and_then(|cell_meta| cell_meta.mem_cell_data.clone())
    }

    fn get_cell_data_hash(&self, out_point: &ckb_types::packed::OutPoint) -> Option<ckb_types::packed::Byte32> {
        self.cell.get(out_point).and_then(|cell_meta| cell_meta.mem_cell_data_hash.clone())
    }
}

impl ckb_traits::HeaderProvider for Resource {
    fn get_header(&self, _: &ckb_types::packed::Byte32) -> Option<ckb_types::core::HeaderView> {
        unimplemented!()
    }
}

impl ckb_traits::ExtensionProvider for Resource {
    fn get_block_extension(&self, _: &ckb_types::packed::Byte32) -> Option<ckb_types::packed::Bytes> {
        unimplemented!()
    }
}

impl ckb_types::core::cell::CellProvider for Resource {
    fn cell(&self, out_point: &ckb_types::packed::OutPoint, eager_load: bool) -> ckb_types::core::cell::CellStatus {
        let _ = eager_load;
        if let Some(data) = self.cell.get(out_point).cloned() {
            ckb_types::core::cell::CellStatus::Live(data)
        } else {
            ckb_types::core::cell::CellStatus::Unknown
        }
    }
}

impl ckb_types::core::cell::HeaderChecker for Resource {
    fn check_valid(&self, _: &ckb_types::packed::Byte32) -> Result<(), ckb_types::core::error::OutPointError> {
        Ok(())
    }
}

#[derive(Clone, Default)]
pub struct Verifier {}

impl Verifier {
    pub fn verify_prior(&self, tx_resolved: &ckb_types::core::cell::ResolvedTransaction, _: &Resource) {
        let a = tx_resolved.transaction.outputs().item_count();
        let b = tx_resolved.transaction.outputs_data().item_count();
        assert_eq!(a, b);
    }

    pub fn verify(
        &self,
        tx_resolved: &ckb_types::core::cell::ResolvedTransaction,
        dl: &Resource,
    ) -> Result<ckb_types::core::Cycle, ckb_error::Error> {
        self.verify_prior(tx_resolved, dl);
        let hardfork = ckb_types::core::hardfork::HardForks {
            ckb2021: ckb_types::core::hardfork::CKB2021::new_dev_default(),
            ckb2023: ckb_types::core::hardfork::CKB2023::new_dev_default(),
        };
        let consensus = ckb_chain_spec::consensus::ConsensusBuilder::default().hardfork_switch(hardfork).build();
        let mut verifier = ckb_script::TransactionScriptsVerifier::new(
            std::sync::Arc::new(tx_resolved.clone()),
            dl.clone(),
            std::sync::Arc::new(consensus),
            std::sync::Arc::new(ckb_script::TxVerifyEnv::new_submit(
                &ckb_types::core::HeaderView::new_advanced_builder()
                    .epoch(ckb_types::core::EpochNumberWithFraction::new(0, 0, 1).pack())
                    .build(),
            )),
        );
        verifier.set_debug_printer(|script: &ckb_types::packed::Byte32, msg: &str| {
            let str = format!("Script({})", hex::encode(&script.as_slice()[..4]));
            println!("{}: {}", str, msg);
        });
        let result = verifier.verify(u64::MAX);
        if result.is_ok() {
            let cycles = (*result.as_ref().unwrap() as f64) / 1024.0 / 1024.0;
            println_log(&format!("cycles is {:.1} M ", cycles));
        }
        result
    }
}

#[derive(Clone, Default)]
pub struct Pickaxer {
    outpoint_hash: ckb_types::packed::Byte32,
    outpoint_i: u32,
}

impl Pickaxer {
    pub fn insert_cell_data(&mut self, dl: &mut Resource, data: &[u8]) -> ckb_types::core::cell::CellMeta {
        let cell_out_point = ckb_types::packed::OutPoint::new(self.outpoint_hash.clone(), self.outpoint_i);
        let cell_output_type = ckb_types::packed::Script::new_builder()
            .args(self.outpoint_i.to_be_bytes().pack())
            .code_hash(ckb_chain_spec::consensus::TYPE_ID_CODE_HASH.pack())
            .hash_type(ckb_types::core::ScriptHashType::Type.into())
            .build();
        let cell_output = ckb_types::packed::CellOutput::new_builder()
            .capacity(ckb_types::core::Capacity::bytes(0).unwrap().pack())
            .type_(Some(cell_output_type).pack())
            .build();
        let cell_data = ckb_types::bytes::Bytes::copy_from_slice(data);
        let cell_meta = ckb_types::core::cell::CellMetaBuilder::from_cell_output(cell_output, cell_data)
            .out_point(cell_out_point.clone())
            .build();
        dl.cell.insert(cell_out_point.clone(), cell_meta.clone());
        self.outpoint_i += 1;
        cell_meta
    }

    pub fn insert_cell_fund(
        &mut self,
        dl: &mut Resource,
        lock: ckb_types::packed::Script,
        kype: Option<ckb_types::packed::Script>,
        data: &[u8],
    ) -> ckb_types::core::cell::CellMeta {
        let cell_out_point = ckb_types::packed::OutPoint::new(self.outpoint_hash.clone(), self.outpoint_i);
        let cell_output = ckb_types::packed::CellOutput::new_builder()
            .capacity(ckb_types::core::Capacity::bytes(0).unwrap().pack())
            .lock(lock)
            .type_(ckb_types::packed::ScriptOpt::new_builder().set(kype).build())
            .build();
        let cell_data = ckb_types::bytes::Bytes::copy_from_slice(data);
        let cell_meta = ckb_types::core::cell::CellMetaBuilder::from_cell_output(cell_output, cell_data)
            .out_point(cell_out_point.clone())
            .build();
        dl.cell.insert(cell_out_point.clone(), cell_meta.clone());
        self.outpoint_i += 1;
        cell_meta
    }

    pub fn create_cell_dep(&self, cell_meta: &ckb_types::core::cell::CellMeta) -> ckb_types::packed::CellDep {
        ckb_types::packed::CellDep::new_builder()
            .out_point(cell_meta.out_point.clone())
            .dep_type(ckb_types::core::DepType::Code.into())
            .build()
    }

    pub fn create_cell_input(&self, cell_meta: &ckb_types::core::cell::CellMeta) -> ckb_types::packed::CellInput {
        ckb_types::packed::CellInput::new(cell_meta.out_point.clone(), 0)
    }

    pub fn create_cell_output(
        &self,
        lock: ckb_types::packed::Script,
        kype: Option<ckb_types::packed::Script>,
    ) -> ckb_types::packed::CellOutput {
        ckb_types::packed::CellOutput::new_builder()
            .capacity(ckb_types::core::Capacity::bytes(0).unwrap().pack())
            .lock(lock)
            .type_(ckb_types::packed::ScriptOpt::new_builder().set(kype).build())
            .build()
    }

    pub fn create_script_by_data(
        &self,
        cell_meta: &ckb_types::core::cell::CellMeta,
        args: &[u8],
    ) -> ckb_types::packed::Script {
        ckb_types::packed::Script::new_builder()
            .args(args.pack())
            .code_hash(cell_meta.mem_cell_data_hash.clone().unwrap())
            .hash_type(ckb_types::core::ScriptHashType::Data1.into())
            .build()
    }

    pub fn create_script_by_type(
        &self,
        cell_meta: &ckb_types::core::cell::CellMeta,
        args: &[u8],
    ) -> ckb_types::packed::Script {
        ckb_types::packed::Script::new_builder()
            .args(args.pack())
            .code_hash(cell_meta.cell_output.type_().to_opt().unwrap().calc_script_hash())
            .hash_type(ckb_types::core::ScriptHashType::Type.into())
            .build()
    }
}


================================================
File: tests/src/lib.rs
================================================
pub mod common;
pub mod core;
#[cfg(test)]
mod test_btc;
#[cfg(test)]
mod test_eth;
#[cfg(test)]
mod test_sol;


================================================
File: tests/src/test_btc.rs
================================================
use crate::common::{assert_script_error, generate_sighash_all, println_hex, ripemd160_sha256, sha256_sha256};
use crate::core::{Pickaxer, Resource, Verifier};
use base64::Engine;
use ckb_types::prelude::{Builder, Entity, Pack};

static BINARY_CCC_LOCK_BTC: &[u8] = include_bytes!("../../build/release/ccc-btc-lock");

fn message_hash(msg: &str) -> [u8; 32] {
    // Only 32-bytes hex representation of the hash is allowed.
    assert_eq!(msg.len(), 64);
    // Text used to signify that a signed message follows and to prevent inadvertently signing a transaction.
    pub const CKB_PREFIX: &str = "Signing a CKB transaction: 0x";
    pub const CKB_SUFFIX: &str = "\n\nIMPORTANT: Please verify the integrity and authenticity of connected BTC wallet before signing this message\n";
    pub const BTC_PREFIX: &str = "Bitcoin Signed Message:\n";
    let mut data: Vec<u8> = Vec::new();
    assert_eq!(BTC_PREFIX.len(), 24);
    data.push(24);
    data.extend(BTC_PREFIX.as_bytes());
    data.push((CKB_PREFIX.len() + msg.len() + CKB_SUFFIX.len()) as u8);
    data.extend(CKB_PREFIX.as_bytes());
    data.extend(msg.as_bytes());
    data.extend(CKB_SUFFIX.as_bytes());
    sha256_sha256(&data)
}

fn message_sign(msg: &str, prikey: &k256::ecdsa::SigningKey) -> [u8; 65] {
    let m = message_hash(msg);
    let sigrec = prikey.sign_prehash_recoverable(&m).unwrap();
    let mut r = [0u8; 65];
    r[0] = sigrec.1.to_byte();
    r[1..65].copy_from_slice(&sigrec.0.to_vec());
    r
}

fn default_tx(dl: &mut Resource, px: &mut Pickaxer) -> ckb_types::core::TransactionView {
    let tx_builder = ckb_types::core::TransactionBuilder::default();
    // Create prior knowledge
    let prikey_byte: [u8; 32] =
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1];
    let prikey = k256::ecdsa::SigningKey::from_slice(&prikey_byte).unwrap();
    let pubkey = prikey.verifying_key();
    let pubkey_hash = ripemd160_sha256(&pubkey.to_sec1_bytes());
    println_hex("pubkey_hash_expect", &pubkey_hash);
    // Create cell meta
    let cell_meta_ccc_lock_btc = px.insert_cell_data(dl, BINARY_CCC_LOCK_BTC);
    let cell_meta_i =
        px.insert_cell_fund(dl, px.create_script_by_type(&cell_meta_ccc_lock_btc, &pubkey_hash), None, &[]);
    // Create cell dep
    let tx_builder = tx_builder.cell_dep(px.create_cell_dep(&cell_meta_ccc_lock_btc));
    // Create input
    let tx_builder = tx_builder.input(px.create_cell_input(&cell_meta_i));
    // Create output
    let tx_builder =
        tx_builder.output(px.create_cell_output(px.create_script_by_type(&cell_meta_ccc_lock_btc, &pubkey_hash), None));
    // Create output data
    let tx_builder = tx_builder.output_data(ckb_types::packed::Bytes::default());
    // Create witness
    let tx_builder = tx_builder.set_witnesses(vec![ckb_types::packed::WitnessArgs::new_builder()
        .lock(Some(ckb_types::bytes::Bytes::from(vec![0u8; 65])).pack())
        .build()
        .as_bytes()
        .pack()]);
    let sighash_all = generate_sighash_all(&tx_builder.clone().build(), &dl, 0);
    let sighash_all_hex = hex::encode(&sighash_all);
    let sig = message_sign(&sighash_all_hex, &prikey);
    let tx_builder = tx_builder.set_witnesses(vec![ckb_types::packed::WitnessArgs::new_builder()
        .lock(Some(ckb_types::bytes::Bytes::copy_from_slice(&sig)).pack())
        .build()
        .as_bytes()
        .pack()]);
    tx_builder.build()
}

#[test]
fn test_success() {
    let mut dl = Resource::default();
    let mut px = Pickaxer::default();
    let tx = default_tx(&mut dl, &mut px);
    let tx_resolved =
        ckb_types::core::cell::resolve_transaction(tx, &mut std::collections::HashSet::new(), &dl, &dl).unwrap();
    let verifier = Verifier::default();
    let cycles = verifier.verify(&tx_resolved, &dl).unwrap();
    assert!(cycles <= 4718592);
}

#[test]
fn test_success_recid_add_31() {
    let mut dl = Resource::default();
    let mut px = Pickaxer::default();
    let tx = default_tx(&mut dl, &mut px);

    let wa = ckb_types::packed::WitnessArgs::new_unchecked(tx.witnesses().get_unchecked(0).raw_data());
    let mut wa_lock = wa.lock().to_opt().unwrap().raw_data().to_vec();
    wa_lock[0] += 31;
    let wa = wa.as_builder().lock(Some(ckb_types::bytes::Bytes::from(wa_lock)).pack()).build();
    let tx = tx.as_advanced_builder().set_witnesses(vec![wa.as_bytes().pack()]).build();

    let tx_resolved =
        ckb_types::core::cell::resolve_transaction(tx, &mut std::collections::HashSet::new(), &dl, &dl).unwrap();
    let verifier = Verifier::default();
    verifier.verify(&tx_resolved, &dl).unwrap();
}

#[test]
fn test_success_recid_add_39() {
    let mut dl = Resource::default();
    let mut px = Pickaxer::default();
    let tx = default_tx(&mut dl, &mut px);

    let wa = ckb_types::packed::WitnessArgs::new_unchecked(tx.witnesses().get_unchecked(0).raw_data());
    let mut wa_lock = wa.lock().to_opt().unwrap().raw_data().to_vec();
    wa_lock[0] += 39;
    let wa = wa.as_builder().lock(Some(ckb_types::bytes::Bytes::from(wa_lock)).pack()).build();
    let tx = tx.as_advanced_builder().set_witnesses(vec![wa.as_bytes().pack()]).build();

    let tx_resolved =
        ckb_types::core::cell::resolve_transaction(tx, &mut std::collections::HashSet::new(), &dl, &dl).unwrap();
    let verifier = Verifier::default();
    verifier.verify(&tx_resolved, &dl).unwrap();
}

#[test]
fn test_failure_witness_args() {
    let mut dl = Resource::default();
    let mut px = Pickaxer::default();
    let tx = default_tx(&mut dl, &mut px);

    let wa = ckb_types::packed::WitnessArgs::new_unchecked(tx.witnesses().get_unchecked(0).raw_data());
    let wa = wa.as_builder().lock(ckb_types::packed::BytesOpt::new_builder().set(None).build()).build();
    let tx = tx.as_advanced_builder().set_witnesses(vec![wa.as_bytes().pack()]).build();

    let tx_resolved =
        ckb_types::core::cell::resolve_transaction(tx, &mut std::collections::HashSet::new(), &dl, &dl).unwrap();
    let verifier = Verifier::default();
    assert_script_error(verifier.verify(&tx_resolved, &dl).unwrap_err(), 31);
}

#[test]
fn test_failure_wrong_pubkey_hash() {
    let mut dl = Resource::default();
    let mut px = Pickaxer::default();
    let tx = default_tx(&mut dl, &mut px);

    let input_outpoint = tx.inputs().get_unchecked(0).previous_output();
    let input_meta = dl.cell.get_mut(&input_outpoint).unwrap();
    let input_cell_output = &input_meta.cell_output;
    let input_cell_output_script = input_cell_output.lock();
    let input_cell_output_script = input_cell_output_script.as_builder().args(vec![0u8; 19].pack()).build();
    let input_cell_output = input_cell_output.clone().as_builder().lock(input_cell_output_script).build();
    input_meta.cell_output = input_cell_output;

    let tx_resolved =
        ckb_types::core::cell::resolve_transaction(tx, &mut std::collections::HashSet::new(), &dl, &dl).unwrap();
    let verifier = Verifier::default();
    assert_script_error(verifier.verify(&tx_resolved, &dl).unwrap_err(), 32);
}

#[test]
fn test_failure_pubkey_hash_mismatched() {
    let mut dl = Resource::default();
    let mut px = Pickaxer::default();
    let tx = default_tx(&mut dl, &mut px);

    let input_outpoint = tx.inputs().get_unchecked(0).previous_output();
    let input_meta = dl.cell.get_mut(&input_outpoint).unwrap();
    let input_cell_output = &input_meta.cell_output;
    let input_cell_output_script = input_cell_output.lock();
    let input_cell_output_script = input_cell_output_script.as_builder().args(vec![0u8; 20].pack()).build();
    let input_cell_output = input_cell_output.clone().as_builder().lock(input_cell_output_script).build();
    input_meta.cell_output = input_cell_output;

    let tx_resolved =
        ckb_types::core::cell::resolve_transaction(tx, &mut std::collections::HashSet::new(), &dl, &dl).unwrap();
    let verifier = Verifier::default();
    assert_script_error(verifier.verify(&tx_resolved, &dl).unwrap_err(), 33);
}

#[test]
fn test_failure_sig_format() {
    let mut dl = Resource::default();
    let mut px = Pickaxer::default();
    let tx = default_tx(&mut dl, &mut px);

    let wa = ckb_types::packed::WitnessArgs::new_unchecked(tx.witnesses().get_unchecked(0).raw_data());
    let mut wa_lock = wa.lock().to_opt().unwrap().raw_data().to_vec();
    wa_lock[0x21..0x41].copy_from_slice(&vec![0u8; 32]);
    let wa = wa.as_builder().lock(Some(ckb_types::bytes::Bytes::from(wa_lock)).pack()).build();
    let tx = tx.as_advanced_builder().set_witnesses(vec![wa.as_bytes().pack()]).build();

    let tx_resolved =
        ckb_types::core::cell::resolve_transaction(tx, &mut std::collections::HashSet::new(), &dl, &dl).unwrap();
    let verifier = Verifier::default();
    assert_script_error(verifier.verify(&tx_resolved, &dl).unwrap_err(), 34);
}

#[test]
fn test_failure_recid() {
    let mut dl = Resource::default();
    let mut px = Pickaxer::default();
    let tx = default_tx(&mut dl, &mut px);

    let wa = ckb_types::packed::WitnessArgs::new_unchecked(tx.witnesses().get_unchecked(0).raw_data());
    let mut wa_lock = wa.lock().to_opt().unwrap().raw_data().to_vec();
    wa_lock[0] = 4;
    let wa = wa.as_builder().lock(Some(ckb_types::bytes::Bytes::from(wa_lock)).pack()).build();
    let tx = tx.as_advanced_builder().set_witnesses(vec![wa.as_bytes().pack()]).build();

    let tx_resolved =
        ckb_types::core::cell::resolve_transaction(tx, &mut std::collections::HashSet::new(), &dl, &dl).unwrap();
    let verifier = Verifier::default();
    assert_script_error(verifier.verify(&tx_resolved, &dl).unwrap_err(), 35);
}

#[test]
fn test_failure_can_not_recover() {
    let mut dl = Resource::default();
    let mut px = Pickaxer::default();
    let tx = default_tx(&mut dl, &mut px);

    let wa = ckb_types::packed::WitnessArgs::new_unchecked(tx.witnesses().get_unchecked(0).raw_data());
    let mut wa_lock = wa.lock().to_opt().unwrap().raw_data().to_vec();
    wa_lock[0] = 3 - wa_lock[0];
    let wa = wa.as_builder().lock(Some(ckb_types::bytes::Bytes::from(wa_lock)).pack()).build();
    let tx = tx.as_advanced_builder().set_witnesses(vec![wa.as_bytes().pack()]).build();

    let tx_resolved =
        ckb_types::core::cell::resolve_transaction(tx, &mut std::collections::HashSet::new(), &dl, &dl).unwrap();
    let verifier = Verifier::default();
    assert_script_error(verifier.verify(&tx_resolved, &dl).unwrap_err(), 36);
}

#[test]
fn test_success_e2e() {
    let mut dl = Resource::default();
    let mut px = Pickaxer::default();
    let tx = default_tx(&mut dl, &mut px);

    // 1. Install Unisat
    // 2. Import account with private key 0x0000000000000000000000000000000000000000000000000000000000000001
    // 3. Open F12
    // 4. Run await unisat.signMessage('Signing a CKB transaction: 0xff934206c421310835b280fd6c9efd98be590f429c2a27a195b
    //        9578bde426cd0\n\nIMPORTANT: Please verify the integrity and authenticity of connected BTC wallet before si
    //        gning this message\n')
    let wa = ckb_types::packed::WitnessArgs::new_unchecked(tx.witnesses().get_unchecked(0).raw_data());
    let mut wa_lock = wa.lock().to_opt().unwrap().raw_data().to_vec();
    wa_lock.copy_from_slice(
        &base64::prelude::BASE64_STANDARD
            .decode("IJIw4RokuCqaS6TBTqJSQWvWJuRRX+0opTmhY6vL88nSOWqULiOXaeZbCtQZJ8lHj3eYoz4+5w9sXrCr5/zfxHA=")
            .unwrap(),
    );
    let wa = wa.as_builder().lock(Some(ckb_types::bytes::Bytes::from(wa_lock)).pack()).build();
    let tx = tx.as_advanced_builder().set_witnesses(vec![wa.as_bytes().pack()]).build();

    let tx_resolved =
        ckb_types::core::cell::resolve_transaction(tx, &mut std::collections::HashSet::new(), &dl, &dl).unwrap();
    let verifier = Verifier::default();
    verifier.verify(&tx_resolved, &dl).unwrap();
}

#[test]
fn test_check_size() {
    assert!(BINARY_CCC_LOCK_BTC.len() <= 150 * 1024);
}


================================================
File: tests/src/test_eth.rs
================================================
use crate::common::{assert_script_error, generate_sighash_all, println_hex};
use crate::core::{Pickaxer, Resource, Verifier};
use ckb_types::prelude::{Builder, Entity, Pack};
use sha3::Digest;

static BINARY_CCC_LOCK_ETH: &[u8] = include_bytes!("../../build/release/ccc-eth-lock");

fn keccak(msg: &[u8]) -> [u8; 32] {
    let mut hasher = sha3::Keccak256::new();
    hasher.update(msg);
    hasher.finalize().into()
}

fn keccak160(msg: &[u8]) -> [u8; 20] {
    let mut output = [0u8; 20];
    output.copy_from_slice(&keccak(msg)[12..]);
    output
}

fn message_hash(msg: &str) -> [u8; 32] {
    // Only 32-bytes hex representation of the hash is allowed.
    assert_eq!(msg.len(), 64);
    // Text used to signify that a signed message follows and to prevent inadvertently signing a transaction.
    const CKB_PREFIX: &str = "Signing a CKB transaction: 0x";
    const CKB_SUFFIX: &str = "\n\nIMPORTANT: Please verify the integrity and authenticity of connected Ethereum wallet before signing this message\n";
    const ETH_PREFIX: &str = "Ethereum Signed Message:\n";
    let mut data: Vec<u8> = Vec::new();
    assert_eq!(ETH_PREFIX.len(), 25);
    data.push(25);
    data.extend(ETH_PREFIX.as_bytes());
    data.extend(format!("{}", (CKB_PREFIX.len() + msg.len() + CKB_SUFFIX.len()) as u8).as_bytes());
    data.extend(CKB_PREFIX.as_bytes());
    data.extend(msg.as_bytes());
    data.extend(CKB_SUFFIX.as_bytes());
    keccak(&data)
}

fn message_sign(msg: &str, prikey: &k256::ecdsa::SigningKey) -> [u8; 65] {
    let m = message_hash(msg);
    let sigrec = prikey.sign_prehash_recoverable(&m).unwrap();
    if sigrec.1.to_byte() > 2 {
        return message_sign(msg, prikey);
    }
    let mut r = [0u8; 65];
    r[..64].copy_from_slice(&sigrec.0.normalize_s().unwrap_or(sigrec.0).to_bytes());
    r[64] = 27 + sigrec.1.to_byte();
    r
}

fn default_tx(dl: &mut Resource, px: &mut Pickaxer) -> ckb_types::core::TransactionView {
    let tx_builder = ckb_types::core::TransactionBuilder::default();
    // Create prior knowledge
    let prikey_byte: [u8; 32] =
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1];
    let prikey = k256::ecdsa::SigningKey::from_slice(&prikey_byte).unwrap();
    let pubkey = prikey.verifying_key();
    let pubkey_hash = keccak160(&pubkey.to_encoded_point(false).to_bytes()[1..]);
    println_hex("pubkey_hash_expect", &pubkey_hash);
    // Create cell meta
    let cell_meta_ccc_lock_eth = px.insert_cell_data(dl, BINARY_CCC_LOCK_ETH);
    let cell_meta_i =
        px.insert_cell_fund(dl, px.create_script_by_type(&cell_meta_ccc_lock_eth, &pubkey_hash), None, &[]);
    // Create cell dep
    let tx_builder = tx_builder.cell_dep(px.create_cell_dep(&cell_meta_ccc_lock_eth));
    // Create input
    let tx_builder = tx_builder.input(px.create_cell_input(&cell_meta_i));
    // Create output
    let tx_builder =
        tx_builder.output(px.create_cell_output(px.create_script_by_type(&cell_meta_ccc_lock_eth, &pubkey_hash), None));
    // Create output data
    let tx_builder = tx_builder.output_data(ckb_types::packed::Bytes::default());
    // Create witness
    let tx_builder = tx_builder.set_witnesses(vec![ckb_types::packed::WitnessArgs::new_builder()
        .lock(Some(ckb_types::bytes::Bytes::from(vec![0u8; 65])).pack())
        .build()
        .as_bytes()
        .pack()]);
    let sighash_all = generate_sighash_all(&tx_builder.clone().build(), &dl, 0);
    let sighash_all_hex = hex::encode(&sighash_all);
    let sig = message_sign(&sighash_all_hex, &prikey);
    let tx_builder = tx_builder.set_witnesses(vec![ckb_types::packed::WitnessArgs::new_builder()
        .lock(Some(ckb_types::bytes::Bytes::copy_from_slice(&sig)).pack())
        .build()
        .as_bytes()
        .pack()]);
    tx_builder.build()
}

#[test]
fn test_success() {
    let mut dl = Resource::default();
    let mut px = Pickaxer::default();
    let tx = default_tx(&mut dl, &mut px);
    let tx_resolved =
        ckb_types::core::cell::resolve_transaction(tx, &mut std::collections::HashSet::new(), &dl, &dl).unwrap();
    let verifier = Verifier::default();
    let cycles = verifier.verify(&tx_resolved, &dl).unwrap();
    assert!(cycles <= 4718592);
}

#[test]
fn test_failure_witness_args() {
    let mut dl = Resource::default();
    let mut px = Pickaxer::default();
    let tx = default_tx(&mut dl, &mut px);

    let wa = ckb_types::packed::WitnessArgs::new_unchecked(tx.witnesses().get_unchecked(0).raw_data());
    let wa = wa.as_builder().lock(ckb_types::packed::BytesOpt::new_builder().set(None).build()).build();
    let tx = tx.as_advanced_builder().set_witnesses(vec![wa.as_bytes().pack()]).build();

    let tx_resolved =
        ckb_types::core::cell::resolve_transaction(tx, &mut std::collections::HashSet::new(), &dl, &dl).unwrap();
    let verifier = Verifier::default();
    assert_script_error(verifier.verify(&tx_resolved, &dl).unwrap_err(), 31);
}

#[test]
fn test_failure_wrong_pubkey_hash() {
    let mut dl = Resource::default();
    let mut px = Pickaxer::default();
    let tx = default_tx(&mut dl, &mut px);

    let input_outpoint = tx.inputs().get_unchecked(0).previous_output();
    let input_meta = dl.cell.get_mut(&input_outpoint).unwrap();
    let input_cell_output = &input_meta.cell_output;
    let input_cell_output_script = input_cell_output.lock();
    let input_cell_output_script = input_cell_output_script.as_builder().args(vec![0u8; 19].pack()).build();
    let input_cell_output = input_cell_output.clone().as_builder().lock(input_cell_output_script).build();
    input_meta.cell_output = input_cell_output;

    let tx_resolved =
        ckb_types::core::cell::resolve_transaction(tx, &mut std::collections::HashSet::new(), &dl, &dl).unwrap();
    let verifier = Verifier::default();
    assert_script_error(verifier.verify(&tx_resolved, &dl).unwrap_err(), 32);
}

#[test]
fn test_failure_pubkey_hash_mismatched() {
    let mut dl = Resource::default();
    let mut px = Pickaxer::default();
    let tx = default_tx(&mut dl, &mut px);

    let input_outpoint = tx.inputs().get_unchecked(0).previous_output();
    let input_meta = dl.cell.get_mut(&input_outpoint).unwrap();
    let input_cell_output = &input_meta.cell_output;
    let input_cell_output_script = input_cell_output.lock();
    let input_cell_output_script = input_cell_output_script.as_builder().args(vec![0u8; 20].pack()).build();
    let input_cell_output = input_cell_output.clone().as_builder().lock(input_cell_output_script).build();
    input_meta.cell_output = input_cell_output;

    let tx_resolved =
        ckb_types::core::cell::resolve_transaction(tx, &mut std::collections::HashSet::new(), &dl, &dl).unwrap();
    let verifier = Verifier::default();
    assert_script_error(verifier.verify(&tx_resolved, &dl).unwrap_err(), 33);
}

#[test]
fn test_failure_sig_format() {
    let mut dl = Resource::default();
    let mut px = Pickaxer::default();
    let tx = default_tx(&mut dl, &mut px);

    let wa = ckb_types::packed::WitnessArgs::new_unchecked(tx.witnesses().get_unchecked(0).raw_data());
    let mut wa_lock = wa.lock().to_opt().unwrap().raw_data().to_vec();
    wa_lock[0x20..0x40].copy_from_slice(&vec![0u8; 32]);
    let wa = wa.as_builder().lock(Some(ckb_types::bytes::Bytes::from(wa_lock)).pack()).build();
    let tx = tx.as_advanced_builder().set_witnesses(vec![wa.as_bytes().pack()]).build();

    let tx_resolved =
        ckb_types::core::cell::resolve_transaction(tx, &mut std::collections::HashSet::new(), &dl, &dl).unwrap();
    let verifier = Verifier::default();
    assert_script_error(verifier.verify(&tx_resolved, &dl).unwrap_err(), 34);
}

#[test]
fn test_failure_recid() {
    let mut dl = Resource::default();
    let mut px = Pickaxer::default();
    let tx = default_tx(&mut dl, &mut px);

    let wa = ckb_types::packed::WitnessArgs::new_unchecked(tx.witnesses().get_unchecked(0).raw_data());
    let mut wa_lock = wa.lock().to_opt().unwrap().raw_data().to_vec();
    wa_lock[64] = 4;
    let wa = wa.as_builder().lock(Some(ckb_types::bytes::Bytes::from(wa_lock)).pack()).build();
    let tx = tx.as_advanced_builder().set_witnesses(vec![wa.as_bytes().pack()]).build();

    let tx_resolved =
        ckb_types::core::cell::resolve_transaction(tx, &mut std::collections::HashSet::new(), &dl, &dl).unwrap();
    let verifier = Verifier::default();
    assert_script_error(verifier.verify(&tx_resolved, &dl).unwrap_err(), 35);
}

#[test]
fn test_success_sig_use_high_s() {
    let mut dl = Resource::default();
    let mut px = Pickaxer::default();
    let tx = default_tx(&mut dl, &mut px);

    let wa = ckb_types::packed::WitnessArgs::new_unchecked(tx.witnesses().get_unchecked(0).raw_data());
    let mut wa_lock = wa.lock().to_opt().unwrap().raw_data().to_vec();
    let l_s = k256::NonZeroScalar::try_from(&wa_lock[32..64]).unwrap();
    let h_s = -l_s;
    wa_lock[32..64].copy_from_slice(&h_s.to_bytes().as_slice());
    wa_lock[64] = 55 - wa_lock[64];
    let wa = wa.as_builder().lock(Some(ckb_types::bytes::Bytes::from(wa_lock)).pack()).build();
    let tx = tx.as_advanced_builder().set_witnesses(vec![wa.as_bytes().pack()]).build();

    let tx_resolved =
        ckb_types::core::cell::resolve_transaction(tx, &mut std::collections::HashSet::new(), &dl, &dl).unwrap();
    let verifier = Verifier::default();
    verifier.verify(&tx_resolved, &dl).unwrap();
}

#[test]
fn test_success_e2e() {
    let mut dl = Resource::default();
    let mut px = Pickaxer::default();
    let tx = default_tx(&mut dl, &mut px);

    // 1. Install Metamask
    // 2. Import account with private key 0x0000000000000000000000000000000000000000000000000000000000000001
    // 3. Open F12
    // 4. Run await ethereum.enable()
    // 5. Run await ethereum.send('personal_sign', ['5369676e696e67206120434b42207472616e73616374696f6e3a203078363665306
    //        4383366303062633332336363316665316530383336653038616234363838653036646537353164366534383133633537383738326
    //        66565363032370a0a494d504f5254414e543a20506c65617365207665726966792074686520696e7465677269747920616e6420617
    //        57468656e746963697479206f6620636f6e6e656374656420457468657265756d2077616c6c6574206265666f7265207369676e696
    //        e672074686973206d6573736167650a', '0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf'])
    let wa = ckb_types::packed::WitnessArgs::new_unchecked(tx.witnesses().get_unchecked(0).raw_data());
    let mut wa_lock = wa.lock().to_opt().unwrap().raw_data().to_vec();
    wa_lock.copy_from_slice(&hex::decode("2291abe57fc51d83a90b3002c3b1994393a56a3cbdfd54a0fd1ece34971607b020eb1c750dbd1f159c631681e7cf1d6e97a0929299b039d6e93a9d7170b6440d1b").unwrap());
    let wa = wa.as_builder().lock(Some(ckb_types::bytes::Bytes::from(wa_lock)).pack()).build();
    let tx = tx.as_advanced_builder().set_witnesses(vec![wa.as_bytes().pack()]).build();

    let tx_resolved =
        ckb_types::core::cell::resolve_transaction(tx, &mut std::collections::HashSet::new(), &dl, &dl).unwrap();
    let verifier = Verifier::default();
    verifier.verify(&tx_resolved, &dl).unwrap();
}

#[test]
fn test_check_size() {
    assert!(BINARY_CCC_LOCK_ETH.len() <= 150 * 1024);
}


================================================
File: tests/src/test_sol.rs
================================================
use crate::common::{assert_script_error, blake160, generate_sighash_all};
use crate::core::{Pickaxer, Resource, Verifier};
use ckb_types::prelude::{Builder, Entity, Pack};
use k256::ecdsa::signature::SignerMut;

static BINARY_CCC_LOCK_SOL: &[u8] = include_bytes!("../../build/release/ccc-sol-lock");

fn message_wrap(msg: &str) -> String {
    // Only 32-bytes hex representation of the hash is allowed.
    assert_eq!(msg.len(), 64);
    // Text used to signify that a signed message follows and to prevent inadvertently signing a transaction.
    const CKB_PREFIX: &str = "Signing a CKB transaction: 0x";
    const CKB_SUFFIX: &str = "\n\nIMPORTANT: Please verify the integrity and authenticity of connected Solana wallet before signing this message\n";
    [CKB_PREFIX, msg, CKB_SUFFIX].join("")
}

fn message_sign(msg: &str, prikey: &mut ed25519_dalek::SigningKey) -> [u8; 64] {
    let msg = message_wrap(msg);
    prikey.sign(msg.as_bytes()).to_bytes()
}

fn default_tx(dl: &mut Resource, px: &mut Pickaxer) -> ckb_types::core::TransactionView {
    let tx_builder = ckb_types::core::TransactionBuilder::default();
    // Create prior knowledge
    let prikey_byte: [u8; 32] =
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1];
    let mut prikey = ed25519_dalek::SigningKey::from_bytes(&prikey_byte);
    let pubkey = prikey.verifying_key();
    let pubkey_byte = pubkey.to_bytes();
    let pubkey_hash = blake160(&pubkey_byte);
    // Create cell meta
    let cell_meta_ccc_lock_sol = px.insert_cell_data(dl, BINARY_CCC_LOCK_SOL);
    let cell_meta_i =
        px.insert_cell_fund(dl, px.create_script_by_type(&cell_meta_ccc_lock_sol, &pubkey_hash), None, &[]);
    // Create cell dep
    let tx_builder = tx_builder.cell_dep(px.create_cell_dep(&cell_meta_ccc_lock_sol));
    // Create input
    let tx_builder = tx_builder.input(px.create_cell_input(&cell_meta_i));
    // Create output
    let tx_builder =
        tx_builder.output(px.create_cell_output(px.create_script_by_type(&cell_meta_ccc_lock_sol, &pubkey_hash), None));
    // Create output data
    let tx_builder = tx_builder.output_data(ckb_types::packed::Bytes::default());
    // Create witness
    let tx_builder = tx_builder.set_witnesses(vec![ckb_types::packed::WitnessArgs::new_builder()
        .lock(Some(ckb_types::bytes::Bytes::from(vec![0u8; 96])).pack())
        .build()
        .as_bytes()
        .pack()]);
    let sighash_all = generate_sighash_all(&tx_builder.clone().build(), &dl, 0);
    let sighash_all_hex = hex::encode(&sighash_all);
    let mut sig = [0u8; 96];
    sig[..64].copy_from_slice(&message_sign(&sighash_all_hex, &mut prikey));
    sig[64..].copy_from_slice(&pubkey_byte);
    let tx_builder = tx_builder.set_witnesses(vec![ckb_types::packed::WitnessArgs::new_builder()
        .lock(Some(ckb_types::bytes::Bytes::copy_from_slice(&sig)).pack())
        .build()
        .as_bytes()
        .pack()]);
    tx_builder.build()
}

#[test]
fn test_success() {
    let mut dl = Resource::default();
    let mut px = Pickaxer::default();
    let tx = default_tx(&mut dl, &mut px);
    let tx_resolved =
        ckb_types::core::cell::resolve_transaction(tx, &mut std::collections::HashSet::new(), &dl, &dl).unwrap();
    let verifier = Verifier::default();
    let cycles = verifier.verify(&tx_resolved, &dl).unwrap();
    assert!(cycles <= 2621440);
}

#[test]
fn test_failure_wrong_pubkey_hash_length() {
    let mut dl = Resource::default();
    let mut px = Pickaxer::default();
    let tx = default_tx(&mut dl, &mut px);

    let input_outpoint = tx.inputs().get_unchecked(0).previous_output();
    let input_meta = dl.cell.get_mut(&input_outpoint).unwrap();
    let input_cell_output = &input_meta.cell_output;
    let input_cell_output_script = input_cell_output.lock();
    let input_cell_output_script_args = input_cell_output_script.args().as_bytes();
    let input_cell_output_script =
        input_cell_output_script.as_builder().args(input_cell_output_script_args[..19].pack()).build();
    let input_cell_output = input_cell_output.clone().as_builder().lock(input_cell_output_script).build();
    input_meta.cell_output = input_cell_output;

    let tx_resolved =
        ckb_types::core::cell::resolve_transaction(tx, &mut std::collections::HashSet::new(), &dl, &dl).unwrap();
    let verifier = Verifier::default();
    assert_script_error(verifier.verify(&tx_resolved, &dl).unwrap_err(), 32);
}

#[test]
fn test_failure_wrong_pubkey_hash() {
    let mut dl = Resource::default();
    let mut px = Pickaxer::default();
    let tx = default_tx(&mut dl, &mut px);

    let input_outpoint = tx.inputs().get_unchecked(0).previous_output();
    let input_meta = dl.cell.get_mut(&input_outpoint).unwrap();
    let input_cell_output = &input_meta.cell_output;
    let input_cell_output_script = input_cell_output.lock();
    let input_cell_output_script = input_cell_output_script.as_builder().args(vec![0u8; 20].pack()).build();
    let input_cell_output = input_cell_output.clone().as_builder().lock(input_cell_output_script).build();
    input_meta.cell_output = input_cell_output;

    let tx_resolved =
        ckb_types::core::cell::resolve_transaction(tx, &mut std::collections::HashSet::new(), &dl, &dl).unwrap();
    let verifier = Verifier::default();
    assert_script_error(verifier.verify(&tx_resolved, &dl).unwrap_err(), 32);
}

#[test]
fn test_failure_wrong_signature_length() {
    let mut dl = Resource::default();
    let mut px = Pickaxer::default();
    let tx = default_tx(&mut dl, &mut px);

    let wa = ckb_types::packed::WitnessArgs::new_unchecked(tx.witnesses().get_unchecked(0).raw_data());
    let mut wa_lock = wa.lock().to_opt().unwrap().raw_data().to_vec();
    wa_lock.pop();
    let wa = wa.as_builder().lock(Some(ckb_types::bytes::Bytes::from(wa_lock)).pack()).build();
    let tx = tx.as_advanced_builder().set_witnesses(vec![wa.as_bytes().pack()]).build();

    let tx_resolved =
        ckb_types::core::cell::resolve_transaction(tx, &mut std::collections::HashSet::new(), &dl, &dl).unwrap();
    let verifier = Verifier::default();
    assert_script_error(verifier.verify(&tx_resolved, &dl).unwrap_err(), 33);
}

#[test]
fn test_failure_wrong_signature() {
    let mut dl = Resource::default();
    let mut px = Pickaxer::default();
    let tx = default_tx(&mut dl, &mut px);

    let wa = ckb_types::packed::WitnessArgs::new_unchecked(tx.witnesses().get_unchecked(0).raw_data());
    let mut wa_lock = wa.lock().to_opt().unwrap().raw_data().to_vec();
    wa_lock[..64].copy_from_slice(&[0u8; 64]);
    let wa = wa.as_builder().lock(Some(ckb_types::bytes::Bytes::from(wa_lock)).pack()).build();
    let tx = tx.as_advanced_builder().set_witnesses(vec![wa.as_bytes().pack()]).build();

    let tx_resolved =
        ckb_types::core::cell::resolve_transaction(tx, &mut std::collections::HashSet::new(), &dl, &dl).unwrap();
    let verifier = Verifier::default();
    assert_script_error(verifier.verify(&tx_resolved, &dl).unwrap_err(), 34);
}

#[test]
fn test_success_e2e() {
    let mut dl = Resource::default();
    let mut px = Pickaxer::default();
    let tx = default_tx(&mut dl, &mut px);

    // 1. Install Phantom
    // 2. Import account with private key AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFMtav2rXn79au8yvzCadhc0mUe1LiFtYafJBrt8KW6KQ==
    // 3. Open F12
    // 4. Run msg = new TextEncoder().encode('Signing a CKB transaction: 0xa5505c5d5261287569fdd26f4061ba7b3ec9bf1ef1baf
    //        6a43426ec115d625d37\n\nIMPORTANT: Please verify the integrity and authenticity of connected Solana wallet
    //        before signing this message\n');
    // 5. Run sig = await phantom.solana.signMessage(msg, 'utf8');
    // 6. Run sig.signature.toString('hex')

    let wa = ckb_types::packed::WitnessArgs::new_unchecked(tx.witnesses().get_unchecked(0).raw_data());
    let mut wa_lock = wa.lock().to_opt().unwrap().raw_data().to_vec();
    wa_lock[..64].copy_from_slice(
        &hex::decode("be179ec911d03817a14b871d5efc3b162651f644c252e16e1e97c1848ccc53784f5205d8aa2ce79774f877330e857cf78375dbdd377dfffb31405329a16dd101").unwrap()
    );
    let wa = wa.as_builder().lock(Some(ckb_types::bytes::Bytes::from(wa_lock)).pack()).build();
    let tx = tx.as_advanced_builder().set_witnesses(vec![wa.as_bytes().pack()]).build();

    let tx_resolved =
        ckb_types::core::cell::resolve_transaction(tx, &mut std::collections::HashSet::new(), &dl, &dl).unwrap();
    let verifier = Verifier::default();
    verifier.verify(&tx_resolved, &dl).unwrap();
}

#[test]
fn test_check_size() {
    assert!(BINARY_CCC_LOCK_SOL.len() <= 100 * 1024);
}


================================================
File: .github/workflows/rust.yml
================================================
name: Rust

on: [push, pull_request]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v1
    - name: Install
      run: make prepare
    - name: Build
      run: bash scripts/reproducible_build_docker
    - name: Run CI
      run: cd tests && cargo test -- --nocapture


