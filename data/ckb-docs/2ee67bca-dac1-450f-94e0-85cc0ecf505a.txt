Directory structure:
└── utxostack-ckb-spv-monit/
    ├── README.md
    ├── Cargo.toml
    ├── rust-toolchain
    ├── scripts/
    │   ├── monit.py
    │   ├── prometheus.py
    │   ├── requirements.txt
    │   ├── .env
    │   ├── .env.btcmain.ckbmainnet
    │   └── .env.btcmain.ckbtestnet
    └── src/
        ├── main.rs
        ├── spv_client_cell_message.rs
        ├── spv_client_rpc.rs
        └── util.rs

================================================
File: README.md
================================================
# ckb-spv-monit

## start CKB PRV 
```angular2html
cargo run 
```

#### get_spv_client

```angular2html
curl -X POST -H "Content-Type: application/json" \
    -d '{"id": 42, "jsonrpc": "2.0", "method": "get_ckb_client_message", "params": ["https://testnet.ckb.dev/", "c8a30fe3e8101cb4163e70b4eb1e42d477ae7094524a30bfdf1c90be41876d28", "3940bc9a03f7d4a92edd2065623a2f6bff96c9924aaf141cce2b2137776998d80a00"]}' \
    http://127.0.0.1:3000


{"jsonrpc":"2.0","result":[{"headers_mmr_root":{"children_hash":"8ff677c88b19693e7cb51eead68487dff3d8fa2a3e6c47e906eec6c95d66a7a9","max_height":837197,"min_height":834624,"partial_chain_work":"926111547494911420326204480"},"id":5,"target_adjust_info":{"next_compact_target":"386097875","start_time":"1711619463"},"tip_block_hash":"0000000000000000000266d8427f15f68c7519211c87d1da596fb2e419311665"},{"headers_mmr_root":{"children_hash":"4f5a248263ecf19df8483487bc2811912c23360724005d8fcb282d6793a638a3","max_height":837196,"min_height":834624,"partial_chain_work":"925754514312027309696104736"},"id":4,"target_adjust_info":{"next_compact_target":"386097875","start_time":"1711619463"},"tip_block_hash":"00000000000000000000c839bae945d1c6d3247a15d23f5241f889ce9da0ab92"},{"headers_mmr_root":{"children_hash":"ae1c4f9c6192a4e155a30457d78128263a589039f0daf9d73b95128ac25654bc","max_height":837194,"min_height":834624,"partial_chain_work":"925040447946259088435905248"},"id":3,"target_adjust_info":{"next_compact_target":"386097875","start_time":"1711619463"},"tip_block_hash":"000000000000000000030565da5f84e33ebcca2202da879774ac05ab892e67ba"},{"headers_mmr_root":{"children_hash":"f2e52a1e391301f0b6d678c6327563bccc285de2ba385c302fb508929e3e5590","max_height":837193,"min_height":834624,"partial_chain_work":"924683414763374977805805504"},"id":2,"target_adjust_info":{"next_compact_target":"386097875","start_time":"1711619463"},"tip_block_hash":"00000000000000000000e0e76462234b84396b825d7dd780e4e3141f53a8ca14"},{"headers_mmr_root":{"children_hash":"6b47b967ca20907432de8ec2f9ffa8d4124ab68e4df1fbf1c996e35188170a5a","max_height":837192,"min_height":834624,"partial_chain_work":"924326381580490867175705760"},"id":1,"target_adjust_info":{"next_compact_target":"386097875","start_time":"1711619463"},"tip_block_hash":"000000000000000000006e9dfcda4887a9f2b2206c683970853a538a98500dc5"},{"headers_mmr_root":{"children_hash":"8af5604dd7230d1a186bf4c37ee790fdf6a8be6ef009efc7b73e55a7463876b8","max_height":837191,"min_height":834624,"partial_chain_work":"923969348397606756545606016"},"id":0,"target_adjust_info":{"next_compact_target":"386097875","start_time":"1711619463"},"tip_block_hash":"00000000000000000002d8efac7e2327870b3cba00e805a165103136a67eb08e"},{"headers_mmr_root":{"children_hash":"3d33bace85629900de7f027ff750564ffd801c511674fc81bd0cbfb1b1fcc55d","max_height":837190,"min_height":834624,"partial_chain_work":"923612315214722645915506272"},"id":9,"target_adjust_info":{"next_compact_target":"386097875","start_time":"1711619463"},"tip_block_hash":"00000000000000000000070a6f73ab2aee52dd75a1a203f745c873293d9bb5c8"},{"headers_mmr_root":{"children_hash":"219923550676def2203cbe9f66ad5ebb0dd15b807c7b1e3a0753881a24861d9a","max_height":837189,"min_height":834624,"partial_chain_work":"923255282031838535285406528"},"id":8,"target_adjust_info":{"next_compact_target":"386097875","start_time":"1711619463"},"tip_block_hash":"000000000000000000002f7e9d25a54413da83a31f442d7049a491b3c0afcd9b"},{"headers_mmr_root":{"children_hash":"d13eef8014c34d57109ac2e68088597c09b3b7a9407dc1c270ceeb572e2ab15e","max_height":837188,"min_height":834624,"partial_chain_work":"922898248848954424655306784"},"id":7,"target_adjust_info":{"next_compact_target":"386097875","start_time":"1711619463"},"tip_block_hash":"000000000000000000010934419aac8cc72344b09f41af891e80d35ee8dcc718"},{"headers_mmr_root":{"children_hash":"4e2247e78d2f93dea5f2501810d9ee1abf430ccdd6e841821df5540eabe4c204","max_height":837187,"min_height":834624,"partial_chain_work":"922541215666070314025207040"},"id":6,"target_adjust_info":{"next_compact_target":"386097875","start_time":"1711619463"},"tip_block_hash":"0000000000000000000026da73f67fe8c0b7a3cb4421c2365755e0b44303256e"}],"id":42}%                                      
```
#### verify
```angular2html
curl -X POST -H "Content-Type: application/json" \
    -d '{"id": 42, "jsonrpc": "2.0", "method": "verify_tx", "params": ["ad03000014000000180000001c000000f90100000000000043c60c00d90100000020812f1ea566fdc775226e60cdd66591bd47c0da8604f4cbea00000000000000000000c2b56d118d869abfe89a12affef3bef141600b76e4b45f3fac0e269ee2f5c07f1c2f0a66d36203176f74ee582b0600000c8374f265338fe97826cc05e675bb1fc1a7edda56a914dca6297d345fd5bed6be23175ae97e32228af6112284502e9b77558c4a00e04e88b722147af2ee38c7309dd70aebe793fcbfda49eac97d7acb3bd6faffa11182b1c7a805d19cc15c5ce9f4ea7123d25f83b9bde9fa34d1758256c2f1e4c8b5527a9a7f2bc89c37fa09310c5bd66d4681aa72735398cad3d56fd631328c9d4dc329764368cb066062d343756123b11d1204226ffd2ef656d2cf714df5be688b92e668730ab66424bebaa9e0324ef5f70db2a5361bbac670348e52cc90c8d6254407bbd6db0eb7fbd04932ae88c2d93f2ef44ad045d62e9921acbb8873d62d38c981ada2f6b05ac35030fbdf8fc781b8e948e8b774eb92984cf5c7dc41b77bd5e6901e839c4a1c78ec5f3f8bb7fe02e39e5b21f665390a060b9d5c2cb42fd973fe8913491279454ceee6c1d38b3e2639f3254f4199bb1788c89cc296aef55e82ca3e6348becb6ff033c49c7e56e1a3a15d2163ee012a154ee68e01082d89c0033ef778deb3b7651de4fb6f03ff0f000600000040bc0c003fc40c0080180f8ef12bbbc6aab7620200000000000000000000000000000000000000006c8ccf5ef0b5d178bdd248d0d7707a3fb27f028f13876acfebcc92f99e7ba49940c40c003fc60c000040365f74723c819d35970000000000000000000000000000000000000000009e5b8daf5bd7b2cfa93fd466e389edc279da5b6d0be5a1dd9791f9d6419abc3442c60c0042c60c00209b2f3a399ec0ce9a4b000000000000000000000000000000000000000000001ea566fdc775226e60cdd66591bd47c0da8604f4cbea0000000000000000000040c60c0041c60c0040365f74723c819d3597000000000000000000000000000000000000000000009a95ea96bd7e4a0d699a9d2241bd3363986e1f1c1fe87c46a32c2211d2703c8244c60c0047c60c00806cbee8e478023b6b2e0100000000000000000000000000000000000000000053ea95a1ab3268374b4e1244ccc83f299b70083321d16f90cbff62438a36b71648c60c004dc60c00c0a21d5d57b583d8a0c501000000000000000000000000000000000000000000447de0c30b05d87526ddbef58bfd8a1e826d27e523722998848dce563eac5b3b", "bed6bed55f347d29a6dc14a956daeda7c11fbb75e605cc2678e98f3365f27483", "0565163119e4b26f59dad1871c2119758cf6157f42d8660200000000000000000040bc0c004dc60c0040d4df1b87458096bf0ffe020000000000000000000000000000000000000000a9a7665dc9c6ee06e9476c3e2afad8f3df8784d6ea1eb57c3e69198bc877f68f873d0566d3620317"]}' \
    http://127.0.0.1:3000

{"jsonrpc":"2.0","result":{"bits":386097875,"merkle_root":"7fc0f5e29e260eac3f5fb4e4760b6041f1bef3feaf129ae8bf9a868d116db5c2","nonce":1492022383,"prev_blockhash":"00000000000000000000eacbf40486dac047bd9165d6cd606e2275c7fd66a51e","time":1711943452,"version":796991488},"id":42}
```

### start monit
add discord `TOKEN` to `scripts/.env`
```angular2html
cd scripts
pip install -r  requirements.txt
python monit.py
```

### start prometheus
```angular2html
cd scripts
python prometheus.py
```


================================================
File: Cargo.toml
================================================
[package]
name = "monit"
version = "0.1.0"
edition = "2021"
license = "MIT"

[dependencies]
prometheus-client = "0.22.2"
tokio = { version = "1", features = ["rt-multi-thread", "net", "macros", "signal", "rt"] }
http = "0.2.12"
warp = "0.3.1"
jsonrpc-utils = { version = "0.2.3", features = ["server", "macros", "axum"] }
async-trait = "0.1.74"
axum = "0.6"
clap = { version = "2.34.0" }
ckb-types = "0.114.0"
ckb-sdk = "3.1.0"
hex = "0.4.3"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
ckb-jsonrpc-types = "0.114.0"
ckb-fixed-hash-core = "0.114.0"
bitcoin = { version = "0.31", features = ["serde"] }

[dependencies.ckb-bitcoin-spv-prover]
version = "0.1.0"
git = "https://github.com/ckb-cell/ckb-bitcoin-spv"
rev = "a6fce4b"

[dependencies.ckb-bitcoin-spv-verifier]
version = "0.1.0"
git = "https://github.com/ckb-cell/ckb-bitcoin-spv"
rev = "a6fce4b"


[patch.crates-io.ckb-sdk]
git = "https://github.com/nervosnetwork/ckb-sdk-rust"
rev = "b792ee7"


================================================
File: rust-toolchain
================================================
1.75.0


================================================
File: scripts/monit.py
================================================
import time
import discord
import asyncio

import json
import requests
from dotenv import dotenv_values
import random

config = dotenv_values(".env")

CHANNEL_ID = config['CHANNEL_ID']
TOKEN = config['TOKEN']
CHECK_INTERVAL = int(config['CHECK_INTERVAL'])

MAX_CONFIRMATIONS = int(config['MAX_CONFIRMATIONS'])
CKB_SPV_MONIT_URL = config['CKB_SPV_MONIT_URL']
CKB_URL = config['CKB_URL']
CONTRACT_CODE_HASH = config['CONTRACT_CODE_HASH']
ARG = config['ARG']
BTC_RPC_URL = config['BTC_RPC_URL']
CKB_SPV_RPC_URL = config['CKB_SPV_RPC_URL']
# error
CLIENT_COUNT_CHANGE = 101
CLIENT_TIP_NUMBER_TOO_LOW = 102
CLIENT_NOT_IN_MAIN_CHAIN = 103
CLIENT_HASH_NOT_FOUND = 104
VALID_TX_VERIFY_FAILED = 105
NOT_IN_CHAIN_TX_VERIFY_SUCCESSFUL = 106
CLIENT_NOT_ORDER = 107
MONIT_SERVER_RPC_ERROR = 108
CKB_URL_ERROR = 109
BTC_PRC_ERROR = 110
CKB_SPV_SERVER_ERROR = 111

intents = discord.Intents.default()
intents.message_content = True
client = discord.Client(intents=intents)


async def send_message(message):
    channel = client.get_channel(int(CHANNEL_ID))
    await channel.send(message)


# Custom function to send message
async def discord_send_message(message):
    await send_message(message)


@client.event
async def on_ready():
    print(f'已登录为 {client.user}')
    await main()
    await client.close()


def convert_int(value):
    try:
        return int(value)
    except ValueError:
        return int(value, base=16)
    except Exception as exp:
        raise exp


class BTCRPCClient:
    def __init__(self, url):
        self.url = url

    def getchaintips(self):
        return call(self.url, "getchaintips", [])

    def getblockheader(self, blockhash):
        return call(self.url, "getblockheader", [blockhash])

    def getblock(self, blockhash):
        return call(self.url, "getblock", [blockhash])


class CKBSPVRPCClient:

    def __init__(self, url):
        self.url = url

    def getTxProof(self, btcId, index, confor):
        return call(self.url, "getTxProof", [btcId, index, confor])


class CKBClient:
    def __init__(self, url):
        self.url = url

    def get_transaction(self, tx):
        return call(self.url, "get_transaction", [tx])


class MonitRPCClient:
    def __init__(self, url):
        self.url = url

    def get_ckb_client_message(self, ckb_url, code_hash, arg):
        return call(self.url, "get_ckb_client_message", [ckb_url, code_hash, arg])

    def verify_tx(self, proof, btc_id, ckb_client_data):
        return call(self.url, "verify_tx", [proof, btc_id, ckb_client_data])


def call(url, method, params, try_count=30):
    headers = {'content-type': 'application/json'}
    data = {
        "id": 42,
        "jsonrpc": "2.0",
        "method": method,
        "params": params
    }

    for i in range(try_count):
        try:
            response = requests.post(url, data=json.dumps(data), headers=headers, timeout=20)
            if response.status_code == 502:
                raise requests.exceptions.ConnectionError("502 ,try again")
            response = response.json()
            if 'error' in response.keys() and response['error'] != None:
                print(f"err request:url:{url},data:\n{json.dumps(data)}")
                print(f"err response:\n{json.dumps(response)}")
                error_message = response['error'].get('message', 'Unknown error')
                raise Exception(f"Error: {error_message}")
            return response.get('result', None)
        except requests.exceptions.ConnectionError as e:
            print(e)
            print(f"err request:url:{url},data:\n{json.dumps(data)}")
            print("request too quickly, wait 2s")
            time.sleep(2)
            continue
        except Exception as e:
            print("Exception:", e)
            raise e
    raise Exception("request time out")


async def discord_send_error_message(error, message):
    message = f"@here {message}"
    print(f"[discord_send_error_message]error:{error},message:{message}")
    await discord_send_message(f"[discord_send_error_message]error:{error},message:{message}")
    with open('failed.txt', 'a') as file:
        file.write(f"[discord_send_error_message]error:{error},message:{message}\n")
    await asyncio.sleep(30)


async def main():
    btcClient = BTCRPCClient(BTC_RPC_URL)
    monitClient = MonitRPCClient(CKB_SPV_MONIT_URL)
    clients = monitClient.get_ckb_client_message(CKB_URL, CONTRACT_CODE_HASH, ARG)
    ckb_spv_client = CKBSPVRPCClient(CKB_SPV_RPC_URL)
    ckb_spv_size = len(clients)
    ckbClient = CKBClient(CKB_URL)
    last_message_time = time.time()
    size = 0
    verify_successful = 0
    while True:
        size += 1
        print(f"------------current :{size}----------")
        try:
            clients = monitClient.get_ckb_client_message(CKB_URL, CONTRACT_CODE_HASH, ARG)
            if ckb_spv_size != len(clients):
                await discord_send_error_message(CLIENT_COUNT_CHANGE,
                                                 f"expected:{ckb_spv_size},but found  :{len(clients)}")
        except Exception as e:
            await discord_send_error_message(MONIT_SERVER_RPC_ERROR, f"{CKB_SPV_MONIT_URL} can't use,err:{e}")
            await asyncio.sleep(60)
            continue

        try:
            blockHeader = btcClient.getblockheader(clients[0]['tip_block_hash'])
        except Exception as e:
            if "Block not found" in e.args:
                await discord_send_error_message(CLIENT_HASH_NOT_FOUND,
                                                 f"block hash not found:{clients[0]['tip_block_hash']}")
                continue
            await discord_send_error_message(BTC_PRC_ERROR,
                                             f"BTC_RPC_URL:{BTC_RPC_URL} can‘t use,err:{e},tip_block_hash:{clients[0]['tip_block_hash']}")
            continue
        # CLIENT_NOT_IN_MAIN_CHAIN
        if blockHeader['confirmations'] == -1:
            await discord_send_error_message(CLIENT_NOT_IN_MAIN_CHAIN, f"client{clients[0]['id']}:{clients[0]['tip_block_hash']} not in main chain")
            continue

        if blockHeader['confirmations'] > MAX_CONFIRMATIONS:
            await discord_send_error_message(CLIENT_TIP_NUMBER_TOO_LOW,
                                             f"client{clients[0]['id']} tip number too low ,confirmations:{blockHeader['confirmations']}")
            continue
        rand_ckb_spv_index = random_number = random.randint(2, ckb_spv_size - 1)
        try:
            block = btcClient.getblock(clients[rand_ckb_spv_index]['tip_block_hash'])
        except Exception as e:
            await discord_send_error_message(BTC_PRC_ERROR,
                                             f"BTC_RPC_URL:{BTC_RPC_URL} can‘t use,err:{e},client[{rand_ckb_spv_index}] tip_block_hash:{clients[rand_ckb_spv_index]['tip_block_hash']}")
            continue

        old_spv_client_transaction = None
        random_verify_count = random.randint(3, 20)
        random_step = int(block['nTx']/random_verify_count)
        if random_step < 1:
            random_step = 2
        for i in range(0, block['nTx'], random_step):
            tx_id = block['tx'][i]
            try:
                tx_proof = ckb_spv_client.getTxProof(tx_id, i, 1)
                await asyncio.sleep(10)
            except Exception as e:
                await discord_send_error_message(CKB_SPV_SERVER_ERROR, f"err:{e},tx id:{tx_id},index:{i}")
                continue
            if old_spv_client_transaction is None:
                old_spv_client_transaction = ckbClient.get_transaction(tx_proof['spv_client']['tx_hash'])
            if tx_proof['spv_client']['tx_hash'] != old_spv_client_transaction['transaction']['hash']:
                old_spv_client_transaction = ckbClient.get_transaction(tx_proof['spv_client']['tx_hash'])
            spv_client_transaction = old_spv_client_transaction
            spv_client_data = spv_client_transaction['transaction']['outputs_data'][1]
            try:
                result = monitClient.verify_tx(tx_proof['proof'].replace("0x", ""), tx_id,
                                               spv_client_data.replace("0x", ""))
            except Exception as e:
                await discord_send_error_message(VALID_TX_VERIFY_FAILED, f"verify_tx failed :{e}")
                continue
            print(f"verify succ:{tx_id},range:{i}/{block['nTx']}")
            verify_successful+=1
            with open('successful.txt', 'a') as file:
                file.write(f"verify succ:{tx_id}\n")

            # add rand block rand txId
        await asyncio.sleep(60)
        elapsed_time = time.time() - last_message_time

        # If one hour has passed without any message sent, send the default message
        if elapsed_time >= CHECK_INTERVAL:
            await discord_send_message(f"current idx:{size},verify:{verify_successful} successful")
            last_message_time = time.time()


if __name__ == '__main__':
    client.run(TOKEN)

================================================
File: scripts/prometheus.py
================================================
import json
import time

import requests

import json
import requests
import prometheus_client
from prometheus_client import Gauge
from prometheus_client.core import CollectorRegistry
from flask import Response, Flask
from dotenv import dotenv_values

config = dotenv_values(".env")

NodeFlask = Flask(__name__)

CKB_SPV_MONIT_URL =config['CKB_SPV_MONIT_URL']
CKB_URL = config['CKB_URL']
CONTRACT_CODE_HASH = config['CONTRACT_CODE_HASH']
ARG = config['ARG']
BTC_RPC_URL = config['BTC_RPC_URL']




def convert_int(value):
    try:
        return int(value)
    except ValueError:
        return int(value, base=16)
    except Exception as exp:
        raise exp


class BTCRPCClient:
    def __init__(self, url):
        self.url = url

    def getchaintips(self):
        return call(self.url, "getchaintips", [])

    def getblockheader(self, blockhash):
        return call(self.url, "getblockheader", [blockhash])


class MonitRPCClient:
    def __init__(self, url):
        self.url = url

    def get_ckb_client_message(self, ckb_url, code_hash, arg):
        return call(self.url, "get_ckb_client_message", [ckb_url, code_hash, arg])


def call(url, method, params, try_count=15):
    headers = {'content-type': 'application/json'}
    data = {
        "id": 42,
        "jsonrpc": "2.0",
        "method": method,
        "params": params
    }
    print(f"request:url:{url},data:\n{json.dumps(data)}")
    for i in range(try_count):
        try:
            response = requests.post(url, data=json.dumps(data), headers=headers).json()
            print(f"response:\n{json.dumps(response)}")
            if 'error' in response.keys() and response['error'] != None:
                error_message = response['error'].get('message', 'Unknown error')
                raise Exception(f"Error: {error_message}")

            return response.get('result', None)
        except requests.exceptions.ConnectionError as e:
            print(e)
            print("request too quickly, wait 2s")
            time.sleep(2)
            continue
        except Exception as e:
            print("Exception:", e)
            raise e
    raise Exception("request time out")


@NodeFlask.route("/")
def Node_Get():
    print("-----beign---")
    CKB_SPV_Chain = CollectorRegistry(auto_describe=False)
    spv_max_height_gauge = Gauge("spv_max_height",
                                 "spv_max_height",
                                 [],
                                 registry=CKB_SPV_Chain)

    spv_current_id_gauge = Gauge("spv_current_id",
                                 "spv_current_id",
                                 [],
                                 registry=CKB_SPV_Chain)

    spv_client_size_gauge = Gauge("spv_client_size",
                                  "spv_client_size",
                                  [],
                                  registry=CKB_SPV_Chain)

    client_height_gauge = Gauge("client_height",
                                "client_height",
                                ['id'],
                                registry=CKB_SPV_Chain)
    btc_tip_height_gauge = Gauge("btc_tip_height", "btc_tip_height", registry=CKB_SPV_Chain)

    get_result = MonitRPCClient(CKB_SPV_MONIT_URL)
    clients = get_result.get_ckb_client_message(CKB_URL, CONTRACT_CODE_HASH, ARG)
    for client in clients:
        client_height_gauge.labels(id=client['id']).set(client['headers_mmr_root']['max_height'])
    client = get_max_height_client(clients)
    spv_max_height_gauge.set(client['headers_mmr_root']['max_height'])
    spv_client_size_gauge.set(len(clients))
    spv_current_id_gauge.set(client['id'])
    tipBlock = BTCRPCClient(BTC_RPC_URL).getblockheader(client['tip_block_hash'])
    tipBlock = BTCRPCClient(BTC_RPC_URL).getchaintips()
    tipHeight = tipBlock[0]['height']
    btc_tip_height_gauge.set(tipHeight)


    # BTCRPCClient(BTC_RPC_URL).get
    # btc_tip_height_gauge.set(chainTips[0]['height'])

    return Response(prometheus_client.generate_latest(CKB_SPV_Chain), mimetype="text/plain")


def get_max_height_client(clients):
    max_height_block = None
    max_height = float('-inf')  # 初始值设置为负无穷大

    for client in clients:
        if client['headers_mmr_root']['max_height'] > max_height:
            max_height = client['headers_mmr_root']['max_height']
            max_height_client = client

    return max_height_client


if __name__ == '__main__':
    NodeFlask.run(host="0.0.0.0", port=8101)


================================================
File: scripts/requirements.txt
================================================
requests
python-dotenv
prometheus_client
flask
discord

================================================
File: scripts/.env
================================================
MAX_CONFIRMATIONS = 3
CKB_SPV_MONIT_URL = "http://localhost:3000"
CKB_URL = "https://testnet.ckb.dev/"
CONTRACT_CODE_HASH = "abc"
ARG = "abc"
BTC_RPC_URL = "https://abc/"
CKB_SPV_RPC_URL = "http://abc"
CHANNEL_ID=11111
TOKEN=""
CHECK_INTERVAL=1111

================================================
File: scripts/.env.btcmain.ckbmainnet
================================================
MAX_CONFIRMATIONS = 3
CKB_SPV_MONIT_URL = "http://localhost:3000"
CKB_URL = "https://abc/"
CONTRACT_CODE_HASH = "abc"
ARG = "abc"
BTC_RPC_URL = "https://abc/"
CKB_SPV_RPC_URL = "https://abc"
CHANNEL_ID=1111
TOKEN=""
CHECK_INTERVAL=1111

================================================
File: scripts/.env.btcmain.ckbtestnet
================================================
MAX_CONFIRMATIONS = 3
CKB_SPV_MONIT_URL = "http://localhost:3000"
CKB_URL = "https://abc/"
CONTRACT_CODE_HASH = "abc"
ARG = "abc"
BTC_RPC_URL = "https://abc/"
CKB_SPV_RPC_URL = "http://abc"
CHANNEL_ID=1111
TOKEN=""
CHECK_INTERVAL=1111

================================================
File: src/main.rs
================================================
mod spv_client_cell_message;
mod spv_client_rpc;
mod util;

use bitcoin::hashes::{sha256d};
use std::str::FromStr;
use clap::{App, Arg};
use async_trait::async_trait;
use jsonrpc_utils::{jsonrpc_core, rpc};
use jsonrpc_utils::axum_utils::jsonrpc_router;
use jsonrpc_utils::jsonrpc_core::MetaIoHandler;
use std::sync::{Arc};
use bitcoin::block::Header;

use ckb_bitcoin_spv_verifier::types::packed::{SpvClientReader, TransactionProofReader};

use ckb_types::prelude::{ Reader};
use jsonrpc_utils::stream::StreamServerConfig;

use jsonrpc_core::{Error, ErrorCode, Value};
use crate::spv_client_cell_message::{get_on_chain_spv_clients};
use crate::spv_client_rpc::SpvClientJsonRpc;
use crate::util::remove_prefix;

#[rpc]
#[async_trait]
trait CkbClientRpc {
    #[rpc(name = "get_ckb_client_message")]
    fn get_client_message(&self, ckb_url: String, code_hash: String, arg: String) -> Result<Vec<SpvClientJsonRpc>, Error>;


    #[rpc(name = "verify_tx")]
    fn verify_tx(&self, proof: String, btc_id: String, ckb_client_data: String) -> Result<Header, Error>;
}

#[derive(Clone)]
pub struct CkbClientRpcImpl {}

#[async_trait]
impl CkbClientRpc for CkbClientRpcImpl {
    fn get_client_message(&self, ckb_url: String, code_hash: String, arg: String) -> Result<Vec<SpvClientJsonRpc>, Error> {
        println!("get_client_message");

        let spv_client_vec = get_on_chain_spv_clients(ckb_url, remove_prefix(arg), remove_prefix(code_hash));
        let clients: Vec<SpvClientJsonRpc> = spv_client_vec.iter().map(|spv_client| SpvClientJsonRpc::from(spv_client.clone())).collect();
        Ok(clients)
    }

    fn verify_tx(&self, proof: String, btc_id: String, ckb_client_data: String) -> Result<Header, Error> {
        let hash = sha256d::Hash::from_str(remove_prefix(btc_id.clone()).as_str()).unwrap();
        let client = remove_prefix(ckb_client_data.clone());
        let proof_bin = hex::decode(remove_prefix(proof.clone())).expect("proof");
        let reader = TransactionProofReader::from_slice(proof_bin.as_slice()).unwrap();
        let client_bin = hex::decode(client.as_bytes()).expect("client");
        let client = SpvClientReader::from_slice(client_bin.as_slice()).unwrap().to_entity();
        let ret = client.verify_transaction(hash.as_ref(), reader, 1);
        match ret {
            Ok(header) => {
                Ok(header)
            }
            Err(err) => {
                let data = err as u8;
                Err(Error {
                    code: ErrorCode::ServerError(1i64),
                    message: "verify failed".to_string(),
                    data: Some(Value::String(format!("err:{data},proof:{proof},btc_id:{btc_id},ckb_client_data:{ckb_client_data}", ))),
                })
            }
        }
    }
}


#[tokio::main]
async fn main() {
    let matches = App::new("JSON-RPC Mock Server")
        .arg(Arg::with_name("bind")
            .short("b")
            .long("bind")
            .default_value("0.0.0.0:3000")
            .help("The address to bind the server to")
        )
        .get_matches();
    let bind_addr = matches.value_of("bind").unwrap();

    let mut rpc = MetaIoHandler::with_compatibility(jsonrpc_core::Compatibility::V2);
    let rpc_impl = CkbClientRpcImpl {};
    add_ckb_client_rpc_methods(&mut rpc, rpc_impl);
    let rpc = Arc::new(rpc);
    let stream_config = StreamServerConfig::default().with_keep_alive(true);
    let app = jsonrpc_router("/", rpc, stream_config);
    axum::Server::bind(&bind_addr.parse().unwrap())
        .serve(app.into_make_service())
        .await
        .unwrap();
}



================================================
File: src/spv_client_cell_message.rs
================================================
use ckb_bitcoin_spv_verifier::molecule;
use ckb_bitcoin_spv_verifier::types::core::{SpvClient, SpvTypeArgs};


use ckb_bitcoin_spv_verifier::types::packed::{SpvClientReader, SpvTypeArgsReader};
use ckb_bitcoin_spv_verifier::types::prelude::Unpack;


use ckb_types::prelude::{Builder, Pack, Reader};


use ckb_sdk::traits::{CellQueryOptions, PrimaryScriptType};
use ckb_types::core::ScriptHashType;
use ckb_types::packed::ScriptBuilder;


use ckb_sdk::CkbRpcClient;
use ckb_sdk::rpc::ckb_indexer::{Cell, Order, SearchKey};


#[derive(Clone)]
pub struct SpvClientCellMessage {
    pub arg: SpvTypeArgs,
    pub data: SpvClient,
}

impl SpvClientCellMessage {
    pub fn new(spv_type_args: SpvTypeArgs, client: SpvClient) -> Self {
        Self {
            arg: spv_type_args,
            data: client,
            // input_type: (),
            // output_type: (),
        }
    }

    pub(crate) fn from_by_cell(cell: Cell) -> Self {
        let (arg, data) = {
            let (arg, data) = get_data(cell);
            let arg = SpvTypeArgsReader::from_slice(&arg).unwrap().to_entity();
            let data = SpvClientReader::from_slice(&data).unwrap().to_entity();
            (arg, data)
        };
        return SpvClientCellMessage::new(arg.unpack(), data.unpack());
    }
}


pub fn get_data(cell: Cell) -> (molecule::bytes::Bytes, molecule::bytes::Bytes) {
    let args = cell.output.type_.unwrap().args.into_bytes();
    let data = cell.output_data.unwrap().into_bytes();
    return (args, data);
}


pub fn get_on_chain_spv_clients(ckb_client_url: String, arg: String, code_hash: String) -> Vec<SpvClient> {
    let ret = tokio::task::block_in_place(|| -> Vec<Cell> {
        let ckb_client = CkbRpcClient::new(ckb_client_url.as_str());
        // Decode hex string argument into binary
        let arg_bin = hex::decode(arg).expect("Failed to decode arg hex string");
        let code_hash = hex::decode(code_hash).expect("failed decode code hash ");
        let mut result = [0u8; 32];
        for i in 0..32 {
            result[i] = code_hash.get(i).unwrap().clone()
        }

        // Build script for SPV type
        let spv_type_script = ScriptBuilder::default()
            .code_hash(result.pack())
            .hash_type(ScriptHashType::Type.into())
            .args(arg_bin.pack())
            .build();

        // Create cell query options
        let query = CellQueryOptions::new(spv_type_script.clone(), PrimaryScriptType::Type);
        let order = Order::Desc;
        let search_key = SearchKey::from(query);
        return ckb_client
            .get_cells(search_key, order, u32::MAX.into(), None)
            .expect("Failed to find cells")
            .objects;
    });


    //  spvInfo cell bytes < 20  ,so should remove it
    ret.into_iter().
        filter(|cell| cell.clone().output_data.unwrap().as_bytes().len() > 20)
        .map(|cell| {
            let client = SpvClientCellMessage::from_by_cell(cell);
            client.data
        })
        .collect()
}



================================================
File: src/spv_client_rpc.rs
================================================
use ckb_bitcoin_spv_verifier::types::core::{SpvClient};
use ckb_bitcoin_spv_verifier::types::prelude::Unpack;
use jsonrpc_utils::jsonrpc_core::serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, PartialEq, Eq, Hash, Debug)]
pub struct SpvClientJsonRpc {
    pub id: usize,
    pub tip_block_hash: String,
    pub headers_mmr_root: HeaderDigestJsonRpc,
    pub target_adjust_info: TargetAdjustInfoJsonRpc,
}

#[derive(Serialize, Deserialize, PartialEq, Eq, Hash, Debug)]
pub struct HeaderDigestJsonRpc {
    pub min_height: usize,
    pub max_height: usize,
    pub partial_chain_work: String,
    pub children_hash: String,
}

#[derive(Serialize, Deserialize, PartialEq, Eq, Hash, Debug)]
pub struct TargetAdjustInfoJsonRpc {
    pub(crate) start_time: String,
    pub(crate) next_compact_target: String,
}

impl SpvClientJsonRpc {
    pub(crate) fn from(client: SpvClient) -> Self {
        return Self {
            id: client.id as usize,
            tip_block_hash: client.tip_block_hash.to_string(),
            headers_mmr_root: HeaderDigestJsonRpc {
                min_height: client.headers_mmr_root.min_height as usize,
                max_height: client.headers_mmr_root.max_height as usize,
                partial_chain_work: client.headers_mmr_root.partial_chain_work.to_string(),
                children_hash: client.headers_mmr_root.children_hash.to_string(),
            },

            target_adjust_info: TargetAdjustInfoJsonRpc {
                start_time: client.target_adjust_info.start_time().unpack().to_string(),
                next_compact_target: client.target_adjust_info.next_compact_target().unpack().to_string(),
            },
        };
    }
}



================================================
File: src/util.rs
================================================
pub fn remove_prefix(input: String) -> String {
    if input.starts_with("0x") {
        input[2..].to_string()
    } else {
        input
    }
}


