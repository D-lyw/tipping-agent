Directory structure:
└── ckb-devrel-pausable-udt/
    ├── README.md
    ├── Cargo.toml
    ├── Makefile
    ├── config.toml
    ├── deployment.toml
    ├── contracts/
    │   └── pausable-udt/
    │       ├── Cargo.lock
    │       ├── Cargo.toml
    │       ├── Makefile
    │       ├── extra.mol
    │       ├── src/
    │       │   ├── config.rs
    │       │   ├── error.rs
    │       │   ├── fallback.rs
    │       │   ├── main.rs
    │       │   ├── modules.rs
    │       │   ├── molecule.rs
    │       │   └── utils.rs
    │       └── tests/
    │           ├── Cargo.toml
    │           └── src/
    │               ├── lib.rs
    │               ├── ssri.rs
    │               ├── tests.rs
    │               ├── tool.rs
    │               └── utils.rs
    └── scripts/
        ├── find_clang
        └── reproducible_build_docker

================================================
File: README.md
================================================
# `pausable-udt`

> [`[EN/CN] Script-Sourced Rich Information - 来源于 Script 的富信息`](https://talk.nervos.org/t/en-cn-script-sourced-rich-information-script/8256): General introduction to SSRI.
>
> [`pausable-udt`](https://github.com/Alive24/pausable-udt): The first fully SSRI compliant and production ready contract that exemplifies all use cases that SSRI protocool covers.
>
> [`pausable-udt` - Audit Report](https://github.com/Alive24/pausable-udt/blob/master/20241224-Pausable-UDT-Final-Audit-Report.pdf)
>
> [`ssri-server`](https://github.com/ckb-devrel/ssri-server): Server for calling SSRI methods.
>
> [`ckb_ssri_sdk`](https://github.com/Alive24/ckb_ssri_sdk) : Toolkit to help developers build SSRI-Compliant smart contracts on CKB by providing public Module Traits which would receive first party infrastructure support across the ecosystem, such as CKB Explorer, JoyID wallet, etc, and useful utility functions and macros to simplify the experience of building SSRI-Compliant contract.
>
> [`ckb_ssri_cli`](https://github.com/Alive24/ckb_ssri_cli): Command Line Interface for general users, moderators, and devs to interact with SSRI-Compliant Contracts deployed on CKB Network. Also exemplifies how to interact with SSRI compliant contract in Node.js.
>
> [`ssri-test`](https://github.com/Hanssen0/ssri-test): First prototype of SSRI-Compliant contract.

This is a SSRI-compliant smart contract that implements a pausable UDT (User-Defined Token) with the SSRI protocol. By maintaining and referring to the `UDTPausableData` , transactions involving UDT would in effect pause minting, transferring, and burning behaviors when any paused lock hash is involved in the transaction. Moreover, the pause list would be publicly accessible and readable to the general public for any decentralized financial arrangements.

## Background

As xUDT is in effect deprecated in terms of providing extensibility for UDT, the need to extend UDT contracts are still to be satisfied; while the programmability of CKB allows great diversities in the way to implement, the inevitable need to index and interact in activities involving UDT assets requires a unified protocol to provide discoverability and predictability for both generic users and developers to explore new possibilities on the basis of trust on the behaviors of the infrastructures and other actors within the CKB and the greater connect ecology.

Pausable UDT is one of the urgent demands of the market that would be good examples of the situation: We would want the smart contracts to validate transactions based on the pause list provided by the project; at the same time, we would need a way for generic users to access the pause list to build trust on the project to invest and trade within.

Based on the experience and insights, as well as the latest updates of utilities and framework including `SSRI`, we would want to design Pausable UDT in a way that is public, intuitive, predicable, and indeed extensible, and develop it in a way that both promises security and functionalities of `Pausable UDT` in the first place and exemplify a more reliable and intuitive way of building smart contracts on CKB-VM.

## Quick Note on SSRI

SSRI stands for `Script Sourced Rich Information`; it is a protocol for strong bindings of relevant information and conventions to the Script itself on CKB. For more information, please read [[EN/CN] Script-Sourced Rich Information - 来源于 Script 的富信息](https://talk.nervos.org/t/en-cn-script-sourced-rich-information-script/8256).

Such bindings would take place in a progressive pattern:

1. On the level of validating transactions, by specifically using Rust Traits, we recognize the purpose (or more specifically, the `Intent` of running the script) (e.g., `minting UDT`, `transferring`) and build relevant validation logics within the scope of the corresponding method.
2. On the level of reading and organizing contract code, by selectively implementing methods of public module traits (e.g. `UDT`, `UDTPausable`) in combinations, generic users and devs would be able to quickly understand and organize functionalities of contracts as well as the relevant adaptations / integrations in dApps , especially in use cases involving multiple distinct contracts (and very likely from different projects) within same transactions.
3. On the level of dApp integration and interactions with `ckb_ssri_cli`, SSRI-Compliant contracts provide predictable interfaces for information query (e.g. generic metadata source for explorer, CCC integration for pubic trait methods such as UDT), transaction generation/completion, and output data calculations which reduces engineering workload significantly by sharing code effectively.

## Interfaces

We will be implementing public module traits `UDT` defined in `ckb_ssri_sdk` . This would be the basis of code organizing, public presenting, and generic integrations to dApps at the moment, and method reflections for SSRI-Calling in the future.

- For methods that we do not plan to implement, we will just simply return `SSRIError::SSRIMethodsNotImplemented` .
- Methods that corresponds to a behavior (e.g. mint, transfer) would return an incomplete `Transaction` while you need to fill in the missing inputs and `CellDeps` with CCC. It can also be provided in the parameters in a way that allows chaining multiple actions.

```rust
pub trait UDT {
    type Error;
    fn balance() -> Result<u128, Self::Error>;
    fn transfer(
        tx: Option<Transaction>,
        to_lock_vec: Vec<Script>,
        to_amount_vec: Vec<u128>,
    ) -> Result<Transaction, Self::Error>;
    fn verify_transfer() -> Result<(), Self::Error>;
    fn name() -> Result<Bytes, Self::Error>;
    fn symbol() -> Result<Bytes, Self::Error>;
    fn decimals() -> Result<u8, Self::Error>;
    fn mint(
        tx: Option<Transaction>,
        to_lock_vec: Vec<Script>,
        to_amount_vec: Vec<u128>,
    ) -> Result<Transaction, Self::Error>;
    fn verify_mint() -> Result<(), Self::Error>;
}

pub enum UDTError {
    InsufficientBalance,
    NoMintPermission,
    NoBurnPermission,
}

pub trait UDTPausable: UDT {
    fn pause(
        tx: Option<Transaction>,
        lock_hashes: &Vec<[u8; 32]>,
    ) -> Result<Transaction, Self::Error>;
    fn unpause(
        tx: Option<Transaction>,
        lock_hashes: &Vec<[u8; 32]>,
    ) -> Result<Transaction, Self::Error>;
    fn is_paused(lock_hashes: &Vec<[u8; 32]>) -> Result<bool, Self::Error>;
    fn enumerate_paused(offset: u64, limit: u64) -> Result<Vec<UDTPausableData>, Self::Error>;
}

pub enum UDTPausableError {
    NoPausePermission,
    NoUnpausePermission,
    AbortedFromPause,
    IncompletePauseList,
    CyclicPauseList,
}
```

## Script `<pausable-udt>`

- This project would only introduce one new `Script` as the asset type script.
- To be compatible with those UDT issuance that would take place before Script `<pausable-udt>` and scheduled to upgrade when it becomes available, we would use the same rule for args definition as what sUDT/xUDT requires: if at least one input cell in the transaction uses owner lock specified by the `pausable-udt`as its cell lock, it enters governance operation and minting would be allowed.
- By default, the contract code itself maintains a pause list of lock hashes that can only be updated by upgrading; if necessary, we can also maintain external lists of lock hashes in extra cell with Type ID implementation and point to them at `UDTPausableData.next_type_script` in a chained pattern.

## Data Structures

```rust
use serde::{Serialize, Deserialize};
use serde_molecule::{to_vec, from_slice};

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct UDTPausableData {
    pub pause_list: Vec<[u8; 32]>,
    pub next_type_script: Option<ScriptLike>
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct ScriptLike {
    pub code_hash: [u8; 32],
    pub hash_type: u8,
    pub args: Vec<u8>,
}
```

## User and Admin Experience

### Recipes

### Transfer

```yaml
Inputs:
    pausable-udt-cell:
        Type:
            code: <pausable-udt>
            args: <owner lock script hash>
        Lock: <User Lock A (Not Paused)>
        Data: <amount>
Dependencies:
    external-pausableData-cell: # Only if external pause list is enabled.
        Data: UDTPausableData
Outputs:
  pausable-udt-cell:
        Type:
            code: <pausable-udt>
            args: <owner lock script hash>
        Lock: <User Lock B (Not Paused)>
        Data: <transferred-amount>
    pausable-udt-cell:
        Type:
            code: <pausable-udt>
            args: <owner lock script hash>
        Lock: <User Lock A (Not Paused)>
        Data: <change-amount>
```

- While transferring, transactions must make sure that none of the user lock script hashes in the transaction is included (“paused”); otherwise, the transaction would return `UDTPausableError::AbortedFromPause` . In case of using external pausable data cell, all transactions must include all the external pausable data cell in the `CellDep` .

### Pause / Unpause (Only Available if using external pausable data cell)

```yaml
Inputs:
    proxy-lock-cell:
      Type:
            code: <Type ID Type>
            args: <Type ID>
        Lock:     <Multisig>
    external-pausable-data-cell:
        Type:
            code: <Type ID Type>
            args: <Type ID>
        Lock:
          code: <Proxy Lock>
          args: <Proxy Lock Cell type hash>
        Data: UDTMetadataData
Dependencies:
Outputs:
  proxy-lock-cell:
      Type:
            code: <Type ID Type>
            args: <Type ID>
        Lock:     <Multisig>
    external-pausable-data-cell:
        Type:
            code: <Type ID Type>
            args: <Type ID>
        Lock:
          code: <Proxy Lock>
          args: <Proxy Lock Type ID>
        Data: UDTMetadataData
```

- By adding / removing lock hashes to the pause list, admins can modify the pausing policies according to the specifications of the project.

## Interacting with `ckb-ssri-cli` (or anything with TypeScript)

- See examples in <https://github.com/Alive24/ckb_ssri_cli>. It would be transferrable to any TypeScript project.
- You would need to run an <https://github.com/Alive24/ssri-server> locally at the moment.

```tsx
// Mint
const payload = {
  id: 2,
  jsonrpc: "2.0",
  method: "run_script_level_script",
  params: [
    codeCellDep.outPoint.txHash,
    Number(codeCellDep.outPoint.index),
    [
      mintPathHex,
      `0x${heldTxEncodedHex}`,
      `0x${toLockArrayEncodedHex}`,
      `0x${toAmountArrayEncodedHex}`,
    ],
    // NOTE: field names are wrong when using udtTypeScript.toBytes()
    {
      code_hash: udtTypeScript.codeHash,
      hash_type: udtTypeScript.hashType,
      args: udtTypeScript.args,
    },
  ],
};

// Transfer
const payload = {
  id: 2,
  jsonrpc: "2.0",
  method: "run_script_level_script",
  params: [
    codeCellDep.outPoint.txHash,
    Number(codeCellDep.outPoint.index),
    // args.index,
    [
      transferPathHex,
      `0x${heldTxEncodedHex}`,
      `0x${toLockArrayEncodedHex}`,
      `0x${toAmountArrayEncodedHex}`,
    ],
    // NOTE: field names are wrong when using udtTypeScript.toBytes()
    {
      code_hash: udtTypeScript.codeHash,
      hash_type: udtTypeScript.hashType,
      args: udtTypeScript.args,
    },
  ],
};

// Pause (Specific Node on the external pausable data cell chain
const payload = {
  id: 2,
  jsonrpc: "2.0",
  method: "run_script_level_cell",
  params: [
    codeCellDep.outPoint.txHash,
    Number(codeCellDep.outPoint.index),
    [pausePathHex, `0x${heldTxEncodedHex}`, `0x${lockHashU832ArrayEncodedHex}`],
    {
      cell_output: {
        capacity: ccc.numToHex(0),
        lock: {
          code_hash: targetPausableDataCell.cellOutput.lock.codeHash,
          args: targetPausableDataCell.cellOutput.lock.args,
          hash_type: targetPausableDataCell.cellOutput.lock.hashType,
        },
        type: {
          code_hash: targetPausableDataCell.cellOutput.type?.codeHash,
          args: targetPausableDataCell.cellOutput.type?.args,
          hash_type: targetPausableDataCell.cellOutput.type?.hashType,
        },
      },
      hex_data: targetPausableDataCell.outputData,
    },
  ],
};

// Pause (Autoredirecting to latest external pausable data cell)
let dummy_typeid_script = await ccc.Script.fromKnownScript(
  client,
  ccc.KnownScript.TypeId,
  "0x"
);
const payload = {
  id: 2,
  jsonrpc: "2.0",
  method: "run_script_level_cell",
  params: [
    codeCellDep.outPoint.txHash,
    Number(codeCellDep.outPoint.index),
    [pausePathHex, `0x${heldTxEncodedHex}`, `0x${lockHashU832ArrayEncodedHex}`],
    {
      cell_output: {
        capacity: `0x0`,
        lock: {
          code_hash: ownerLock.codeHash,
          args: ownerLock.args,
          hash_type: ownerLock.hashType,
        },
        type: {
          code_hash: dummy_typeid_script.codeHash,
          args: dummy_typeid_script.args,
          hash_type: dummy_typeid_script.hashType,
        },
      },
      hex_data: `0x`,
    },
  ],
};

// Unpause
const payload = {
  id: 2,
  jsonrpc: "2.0",
  method: "run_script_level_code",
  params: [
    codeCellDep.outPoint.txHash,
    Number(codeCellDep.outPoint.index),
    [
      unpausePathHex,
      `0x${heldTxEncodedHex}`,
      `0x${lockHashU832ArrayEncodedHex}`,
    ],
  ],
};

// Enumerate Paused
const payload = {
  id: 2,
  jsonrpc: "2.0",
  method: "run_script_level_code",
  params: [
    codeCellDep.outPoint.txHash,
    Number(codeCellDep.outPoint.index),
    [enumeratePausedPathHex, `0x${offsetHex}`, `0x${limitHex}`],
  ],
};

// Is Paused?
const payload = {
  id: 2,
  jsonrpc: "2.0",
  method: "run_script_level_code",
  params: [
    codeCellDep.outPoint.txHash,
    Number(codeCellDep.outPoint.index),
    // args.index,
    [isPausedPathHex, `0x${lockHashU832ArrayEncodedHex}`],
  ],
};

// Decimals
const payload = {
  id: 2,
  jsonrpc: "2.0",
  method: "run_script_level_code",
  params: [
    matchingCellDep.outPoint.txHash,
    Number(matchingCellDep.outPoint.index),
    [decimalPathHex],
  ],
};

// Name
const payload = {
  id: 2,
  jsonrpc: "2.0",
  method: "run_script_level_code",
  params: [
    matchingCellDep.outPoint.txHash,
    Number(matchingCellDep.outPoint.index),
    [namePathHex],
  ],
};

// Symbol
const payload = {
  id: 2,
  jsonrpc: "2.0",
  method: "run_script_level_code",
  params: [
    matchingCellDep.outPoint.txHash,
    Number(matchingCellDep.outPoint.index),
    [symbolPathHex],
  ],
};

// Get transaction and send it
// Send POST request
try {
  const response = await axios.post(process.env.SSRI_SERVER_URL!, payload, {
    headers: { "Content-Type": "application/json" },
  });
  const mintTx = blockchain.Transaction.unpack(response.data.result);
  const cccMintTx = ccc.Transaction.from(mintTx);
  await cccMintTx.completeInputsByCapacity(signer);
  await cccMintTx.completeFeeBy(signer);
  const mintTxHash = await signer.sendTransaction(cccMintTx);
  this.log(
    `Mint ${args.toAmount} ${args.symbol} to ${args.toAddress}. Tx hash: ${mintTxHash}`
  );
} catch (error) {
  console.error("Request failed", error);
}
```

## Testing

- Due to the limitations of `ckb_testtools`, it is recommended to test the same SSRI-Compliant Contract on two level:
  - On-chain Verification: Test with `ckb_testtools`
  - Off-chain Query/Integration, Transaction Generations/Completions: Test with `ckb_ssri_cli` against the latest deployment.

## Deployment and Migration

- Deploy and upgrade with [ckb-cinnabar](https://github.com/ashuralyk/ckb-cinnabar?tab=readme-ov-file#deployment-module) for easier deployment and migration with Type ID.

```bash
ckb-cinnabar deploy --contract-name pausable-udt --tag transaction.v241112 --payer-address ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsqtxe0gs9yvwrsc40znvdc6sg4fehd2mttsngg4t4 --type-id

ckb-cinnabar migrate --contract-name pausable-udt --from-tag v241030.1 --to-tag v241030.2
```

## Roadmaps and Goal

- [x] Equivalent functionalities of sUDT in pure Rust;
- [x] Validations of UDT transactions in fallback function on predefined paused locks hashes;
- [x] First integration with dApps for the purpose of demonstration with CCC.
- [x] Fully supported SSRI protocol


================================================
File: Cargo.toml
================================================
[workspace]
resolver = "2"

members = [
  "contracts/pausable-udt",
  # Please don't remove the following line, we use it to automatically
  # detect insertion point for newly generated crates.
  # @@INSERTION_POINT@@
]

[profile.release]
overflow-checks = true
strip = true
codegen-units = 1


================================================
File: Makefile
================================================
# We cannot use $(shell pwd), which will return unix path format on Windows,
# making it hard to use.
cur_dir = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))

TOP := $(cur_dir)
# RUSTFLAGS that are likely to be tweaked by developers. For example,
# while we enable debug logs by default here, some might want to strip them
# for minimal code size / consumed cycles.
CUSTOM_RUSTFLAGS := --cfg debug_assertions
# Additional cargo args to append here. For example, one can use
# make test CARGO_ARGS="-- --nocapture" so as to inspect data emitted to
# stdout in unit tests
CARGO_ARGS :=
MODE := release
# Tweak this to change the clang version to use for building C code. By default
# we use a bash script with somes heuristics to find clang in current system.
CLANG := $(shell $(TOP)/scripts/find_clang)
# When this is set, a single contract will be built instead of all contracts
CONTRACT :=
# By default, we would clean build/{release,debug} folder first, in case old
# contracts are mixed together with new ones, if for some reason you want to
# revert this behavior, you can change this to anything other than true
CLEAN_BUILD_DIR_FIRST := true
BUILD_DIR := build/$(MODE)

# Pass setups to child make processes
export CUSTOM_RUSTFLAGS
export TOP
export CARGO_ARGS
export MODE
export CLANG
export BUILD_DIR

default: build test

build:
	@if [ "x$(CLEAN_BUILD_DIR_FIRST)" = "xtrue" ]; then \
		echo "Cleaning $(BUILD_DIR) directory..."; \
		rm -rf $(BUILD_DIR); \
	fi
	mkdir -p $(BUILD_DIR)
	@set -eu; \
	if [ "x$(CONTRACT)" = "x" ]; then \
		for contract in $(wildcard contracts/*); do \
			$(MAKE) -e -C $$contract build; \
		done; \
	else \
		$(MAKE) -e -C contracts/$(CONTRACT) build; \
	fi

# Run a single make task for a specific contract. For example:
#
# make run CONTRACT=stack-reorder TASK=adjust_stack_size STACK_SIZE=0x200000
TASK :=
run:
	$(MAKE) -e -C contracts/$(CONTRACT) $(TASK)

# test, check, clippy and fmt here are provided for completeness,
# there is nothing wrong invoking cargo directly instead of make.
test:
	cargo test $(CARGO_ARGS)

check:
	cargo check $(CARGO_ARGS)

clippy:
	cargo clippy $(CARGO_ARGS)

fmt:
	cargo fmt $(CARGO_ARGS)

# Arbitrary cargo command is supported here. For example:
#
# make cargo CARGO_CMD=expand CARGO_ARGS="--ugly"
#
# Invokes:
# cargo expand --ugly
CARGO_CMD :=
cargo:
	cargo $(CARGO_CMD) $(CARGO_ARGS)

clean:
	rm -rf build
	cargo clean

TEMPLATE_TYPE := --git
TEMPLATE_REPO := https://github.com/cryptape/ckb-script-templates
CRATE :=
TEMPLATE := contract
DESTINATION := contracts
generate:
	@set -eu; \
	if [ "x$(CRATE)" = "x" ]; then \
		cargo generate $(TEMPLATE_TYPE) $(TEMPLATE_REPO) $(TEMPLATE) \
			--destination $(DESTINATION); \
		GENERATED_DIR=$$(ls -dt $(DESTINATION)/* | head -n 1); \
		sed "s,@@INSERTION_POINT@@,@@INSERTION_POINT@@\n  \"$$GENERATED_DIR\"\,," Cargo.toml > Cargo.toml.new; \
		mv Cargo.toml.new Cargo.toml; \
	else \
		cargo generate $(TEMPLATE_TYPE) $(TEMPLATE_REPO) $(TEMPLATE) \
			--destination $(DESTINATION) \
			--name $(CRATE); \
		sed '/@@INSERTION_POINT@@/s/$$/\n  "$(DESTINATION)\/$(CRATE)",/' Cargo.toml > Cargo.toml.new; \
		mv Cargo.toml.new Cargo.toml; \
	fi

prepare:
	rustup target add riscv64imac-unknown-none-elf

# Generate checksum info for reproducible build
CHECKSUM_FILE := build/checksums-$(MODE).txt
checksum: build
	shasum -a 256 build/$(MODE)/* > $(CHECKSUM_FILE)

.PHONY: build test check clippy fmt cargo clean prepare checksum


================================================
File: config.toml
================================================
in_contract_pause_list = [ ]

[next_type_script]
code_hash = ""
hash_type = ""
args = ""

[udt_data]
name = "Pausable UDT"
symbol = "PUDT"
decimals = 6
icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDgiIGhlaWdodD0iNDgiIHZpZXdCb3g9IjAgMCA0OCA0OCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMjQiIGN5PSIyNCIgcj0iMjQiIGZpbGw9IiMwNTFGNDQiLz4KPHBhdGggZD0iTTE1LjM5NzQgMjkuOTMyMUMxNC4xNTk0IDI5LjkzMjEgMTMuMDU5IDI5LjI5NjMgMTIuNDQ4MyAyOC4yMjkzQzExLjgzNzYgMjcuMTYyMyAxMS44NTEzIDI1Ljg5NjEgMTIuNDg2OCAyNC44NDI4TDIzLjA2MTcgNy4yNzQzOEwyMy4wNzU0IDcuMjU1MjhDMjMuNjIyOSA2LjQ1NTcyIDI0LjQ3ODQgNiAyNS40MjIgNkMyNi4yODMxIDYgMjcuMTI3NyA2LjM4NzUgMjcuNjgwNiA3LjAzNjk3QzI4LjIxOTggNy42NzI3OSAyOC40MzcxIDguNDkxNDUgMjguMjg4NiA5LjM0Mjg1TDI2LjA0OTMgMjIuMjI4NUwyMS44Njc3IDI0LjMyN0wyMy43Mjc0IDEzLjUxNTNMMTYuNDI5IDI1Ljk5NDRIMjAuMzY1N0wxOS42MjAyIDI5LjkzMjFIMTUuNDAwMUgxNS4zOTc0WiIgZmlsbD0idXJsKCNwYWludDBfbGluZWFyXzMzMzM5XzkzMTcpIi8+CjxwYXRoIGQ9Ik0yMi40NDg0IDQxLjk5OTVDMjEuNTg3MyA0MS45OTk1IDIwLjc0MjcgNDEuNjEyIDIwLjE4OTggNDAuOTYyNUMxOS42NTA2IDQwLjMyNjcgMTkuNDMzMyAzOS41MDggMTkuNTgxOCAzOC42NTY2TDIxLjgyMTEgMjUuNzcxTDI2LjAwMjcgMjMuNjcyNUwyNC4xNDMgMzQuNDg0MkwzMS40NDE0IDIyLjAwNTFIMjcuNTA0N0wyOC4yNTAyIDE4LjA2NzRIMzIuNDcwM0MzMy43MDgyIDE4LjA2NzQgMzQuODA4NiAxOC43MDMyIDM1LjQxOTQgMTkuNzcwMkMzNi4wMzAxIDIwLjgzNzIgMzYuMDE2MyAyMi4xMDM0IDM1LjM4MDkgMjMuMTU2N0wyNC44MDYgNDAuNzI1MUwyNC43OTIyIDQwLjc0NDJDMjQuMjQ0OCA0MS41NDM4IDIzLjM4OTIgNDEuOTk5NSAyMi40NDU2IDQxLjk5OTVIMjIuNDQ4NFoiIGZpbGw9InVybCgjcGFpbnQxX2xpbmVhcl8zMzMzOV85MzE3KSIvPgo8cGF0aCBvcGFjaXR5PSIwLjE1IiBkPSJNMTkuOTk5OSAyNy45MTY4SDE1LjYyM0MxNC4yNzUgMjcuOTE2OCAxMy40NTI1IDI2LjQ0ODYgMTQuMTYyMyAyNS4zMTM0TDI0LjQzMTggOC44NjM4N0MyNC45MzggOC4wNTA2NyAyNi4yMDYyIDguNTA5MTEgMjYuMDY4NiA5LjQ1MzNMMjQuMDY1OSAyMy4yMTc3TDIxLjg2NzggMjQuMzIyOUwyMy43Mjc1IDEzLjUxMTFMMTYuNDI5MSAyNS45OTAySDIwLjM2NThMMjAuMDAyNyAyNy45MTRMMTkuOTk5OSAyNy45MTY4WiIgZmlsbD0id2hpdGUiLz4KPHBhdGggb3BhY2l0eT0iMC4xNSIgZD0iTTI3Ljg4NDMgMjAuMDYyNUgzMi4yNjExQzMzLjYwOTEgMjAuMDYyNSAzNC40MzE3IDIxLjUzMDYgMzMuNzIxOSAyMi42NjU4TDIzLjQ0OTYgMzkuMTE1NEMyMi45NDM1IDM5LjkyODYgMjEuNjc1MiAzOS40NzAxIDIxLjgxMjggMzguNTI2TDIzLjgxNTUgMjQuNzYxNkwyNi4wMTM2IDIzLjY1NjRMMjQuMTUzOSAzNC40NjgxTDMxLjQ1MjMgMjEuOTg5MUgyNy41MTU2TDI3Ljg3ODggMjAuMDY1MkwyNy44ODQzIDIwLjA2MjVaIiBmaWxsPSJ3aGl0ZSIvPgo8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDBfbGluZWFyXzMzMzM5XzkzMTciIHgxPSIyMC4xNjQ5IiB5MT0iMjUuNjM0MSIgeDI9IjIwLjE2NDkiIHkyPSIxLjcwMjA1IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IiMwMDU4RjEiLz4KPHN0b3Agb2Zmc2V0PSIwLjUzIiBzdG9wLWNvbG9yPSIjMDBCMUZGIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzAzQTlGRCIvPgo8L2xpbmVhckdyYWRpZW50Pgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MV9saW5lYXJfMzMzMzlfOTMxNyIgeDE9IjI3LjcwMjgiIHkxPSI0MS45OTk1IiB4Mj0iMjcuNzAyOCIgeTI9IjE4LjA2NzQiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0ZGQUIxMSIvPgo8c3RvcCBvZmZzZXQ9IjAuMDkiIHN0b3AtY29sb3I9IiNGREE0MUEiLz4KPHN0b3Agb2Zmc2V0PSIwLjI0IiBzdG9wLWNvbG9yPSIjRkE5MjMyIi8+CjxzdG9wIG9mZnNldD0iMC40MyIgc3RvcC1jb2xvcj0iI0Y0NzQ1QiIvPgo8c3RvcCBvZmZzZXQ9IjAuNjUiIHN0b3AtY29sb3I9IiNFRDRCOTIiLz4KPHN0b3Agb2Zmc2V0PSIwLjkiIHN0b3AtY29sb3I9IiNFMzE3RDkiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjREYwMEY5Ii8+CjwvbGluZWFyR3JhZGllbnQ+CjwvZGVmcz4KPC9zdmc+Cg=="


================================================
File: deployment.toml
================================================
[[cells]]
name = "pausable-udt"
enable_type_id = true
location = { file = "build/release/pausable-udt" }

# The lock script set to output cells
[lock]
code_hash = "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8"
args = "0x66cbd102918e1c31578a6c6e35045539bb55b5ae"
hash_type = "type"

================================================
File: contracts/pausable-udt/Cargo.lock
================================================
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "blake2b-ref"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "294d17c72e0ba59fad763caa112368d0672083779cdebbb97164f4bb4c1e339a"

[[package]]
name = "blake2b-rs"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a89a8565807f21b913288968e391819e7f9b2f0f46c7b89549c051cccf3a2771"
dependencies = [
 "cc",
 "cty",
]

[[package]]
name = "buddy-alloc"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee741d62dcaf41ca303576ef890989ccb01d5dd77f8ce1a6d6c7846ab5d09efb"

[[package]]
name = "bytes"
version = "1.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "325918d6fe32f23b19878fe4b34794ae41fc19ddbe53b10571a4874d44ffd39b"

[[package]]
name = "cc"
version = "1.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "27f657647bcff5394bf56c7317665bbf790a137a50eaaa5c6bfbb9e27a518f2d"
dependencies = [
 "shlex",
]

[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "ckb-gen-types"
version = "0.119.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bc221d4b9d6d39215b1d62be855861b8b0c8d668ca29874903b0bf5d0b4d9fa"
dependencies = [
 "cfg-if",
 "ckb-hash 0.119.0",
 "molecule",
]

[[package]]
name = "ckb-hash"
version = "0.116.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d5754bc49cf76a7e8829fe6a7cf1eea1284cbca9777b521f072c76d6ae28d303"
dependencies = [
 "blake2b-ref",
 "blake2b-rs",
]

[[package]]
name = "ckb-hash"
version = "0.119.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "99ba7c72f86f239b3e0154f51d6cd5d0d83bbaa8775fdc7b6bcac459ae24b6fd"
dependencies = [
 "blake2b-ref",
]

[[package]]
name = "ckb-std"
version = "0.16.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a673595baadfa1712ff03a36e1519f28015cf9944282410863d5e256336f5b9"
dependencies = [
 "buddy-alloc",
 "cc",
 "ckb-gen-types",
 "gcd",
]

[[package]]
name = "ckb_ssri_sdk"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ef8de7c71eae2dc2aae8b9fb7bf97f2db635f076b53550febd9424922c8f3895"
dependencies = [
 "ckb-std",
 "ckb_ssri_sdk_proc_macro",
 "serde",
 "serde_molecule",
]

[[package]]
name = "ckb_ssri_sdk_proc_macro"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e6e439f89d56a2ac637295ba68ac0dc91b6560c803cdf4f645e21a433eec81d"
dependencies = [
 "ckb-hash 0.116.1",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "cty"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b365fabc795046672053e29c954733ec3b05e4be654ab130fe8f1f94d7051f35"

[[package]]
name = "gcd"
version = "2.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1d758ba1b47b00caf47f24925c0074ecb20d6dfcffe7f6d53395c0465674841a"

[[package]]
name = "molecule"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6efe1c7efcd0bdf4ca590e104bcb13087d9968956ae4ae98e92fb8c1da0f3730"
dependencies = [
 "bytes",
 "cfg-if",
]

[[package]]
name = "pausable-udt"
version = "0.1.0"
dependencies = [
 "ckb-std",
 "ckb_ssri_sdk",
 "ckb_ssri_sdk_proc_macro",
 "serde",
 "serde_molecule",
]

[[package]]
name = "proc-macro2"
version = "1.0.92"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "37d3544b3f2748c54e147655edb5025752e2303145b5aefb3c3ea2c78b973bb0"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.37"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b5b9d34b8991d19d98081b46eacdd8eb58c6f2b201139f7c5f643cc155a633af"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "serde"
version = "1.0.215"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6513c1ad0b11a9376da888e3e0baa0077f1aed55c17f50e7b2397136129fb88f"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.215"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ad1e866f866923f252f05c889987993144fb74e722403468a4ebd70c3cd756c0"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "serde_molecule"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f15166380b1d060472fd8eb7fe3cc58027cf32f7983832db3e2f97ac4ee71740"
dependencies = [
 "serde",
]

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "syn"
version = "2.0.90"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "919d3b74a5dd0ccd15aeb8f93e7006bd9e14c295087c9896a110f490752bcf31"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "unicode-ident"
version = "1.0.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "adb9e6ca4f869e1180728b7950e35922a7fc6397f7b641499e8f3ef06e50dc83"


================================================
File: contracts/pausable-udt/Cargo.toml
================================================
[package]
name = "pausable-udt"
version = "0.1.0"
edition = "2021"

[dependencies]
ckb-std = { version = "0.16.4", features = ["allocator", "ckb-types", "dummy-atomic"] }
ckb-ssri-std = { version = "0.0.1" }
ckb-ssri-std-proc-macro = { version = "0.0.1" }
serde_molecule = { version = "1.1.0", default-features = false, features = ["alloc"] }
serde = { version = "1.0.210", default-features = false, features = ["derive"] }
ckb-hash = { version = "0.120.0", default-features = false, features = ["ckb-contract"] }
molecule = { version = "0.8.0", default-features = false, features = ["bytes_vec"] }
[profile.release]
overflow-checks = true
opt-level = 3
panic = 'abort'
strip = true
lto = true


================================================
File: contracts/pausable-udt/Makefile
================================================
# We cannot use $(shell pwd), which will return unix path format on Windows,
# making it hard to use.
cur_dir = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))

TOP := $(cur_dir)
# RUSTFLAGS that are likely to be tweaked by developers. For example,
# while we enable debug logs by default here, some might want to strip them
# for minimal code size / consumed cycles.
CUSTOM_RUSTFLAGS := --cfg debug_assertions
# RUSTFLAGS that are less likely to be tweaked by developers. Most likely
# one would want to keep the default values here.
FULL_RUSTFLAGS := -C target-feature=+zba,+zbb,+zbc,+zbs,-a $(CUSTOM_RUSTFLAGS)
# Additional cargo args to append here. For example, one can use
# make test CARGO_ARGS="-- --nocapture" so as to inspect data emitted to
# stdout in unit tests
CARGO_ARGS :=
MODE := release
# Tweak this to change the clang version to use for building C code. By default
# we use a bash script with somes heuristics to find clang in current system.
CLANG := $(shell $(TOP)/scripts/find_clang)
AR := $(subst clang,llvm-ar,$(CLANG))
# When this is set to some value, the generated binaries will be copied over
BUILD_DIR :=
# Generated binaries to copy. By convention, a Rust crate's directory name will
# likely match the crate name, which is also the name of the final binary.
# However if this is not the case, you can tweak this variable. As the name hints,
# more than one binary is supported here.
BINARIES := $(notdir $(shell pwd))

ifeq (release,$(MODE))
	MODE_ARGS := --release
endif

default: build test

build:
	RUSTFLAGS="$(FULL_RUSTFLAGS)" TARGET_CC="$(CLANG)" TARGET_AR="$(AR)" \
		cargo build --target=riscv64imac-unknown-none-elf $(MODE_ARGS) $(CARGO_ARGS)
	@set -eu; \
	if [ "x$(BUILD_DIR)" != "x" ]; then \
		for binary in $(BINARIES); do \
			echo "Copying binary $$binary to build directory"; \
			cp $(TOP)/target/riscv64imac-unknown-none-elf/$(MODE)/$$binary $(TOP)/$(BUILD_DIR); \
		done \
	fi

# test, check, clippy and fmt here are provided for completeness,
# there is nothing wrong invoking cargo directly instead of make.
test:
	cargo test $(CARGO_ARGS)

check:
	cargo check $(CARGO_ARGS)

clippy:
	cargo clippy $(CARGO_ARGS)

fmt:
	cargo fmt $(CARGO_ARGS)

# Arbitrary cargo command is supported here. For example:
#
# make cargo CARGO_CMD=expand CARGO_ARGS="--ugly"
# 
# Invokes:
# cargo expand --ugly
CARGO_CMD :=
cargo:
	cargo $(CARGO_CMD) $(CARGO_ARGS)

clean:
	cargo clean

prepare:
	rustup target add riscv64imac-unknown-none-elf

.PHONY: build test check clippy fmt cargo clean prepare


================================================
File: contracts/pausable-udt/extra.mol
================================================
vector ScriptVec <Script>;

table Script {
    code_hash:      Byte32,
    hash_type:      byte,
    args:           Bytes,
}

vector Bytes <byte>;
array Byte32 [byte; 32];

================================================
File: contracts/pausable-udt/src/config.rs
================================================

// Generated by CCC deploy https://github.com/ckb-devrel/ccc-deploy
use ckb_std::ckb_types::core::ScriptHashType;

// List of paused lock hashes
pub const IN_CONTRACT_PAUSED_LOCK_HASHES: &[&str] = &[];

pub const INITIAL_EXTERNAL_DATA_CELL_TYPE_CODE_HASH: &str = "";
pub const INITIAL_EXTERNAL_DATA_CELL_TYPE_HASH_TYPE: ScriptHashType = ScriptHashType::Type;
pub const INITIAL_EXTERNAL_DATA_CELL_TYPE_ARGS: &str = "";

pub const NAME: &str = "Pausable UDT";
pub const SYMBOL: &str = "PUDT";
pub const DECIMALS: u8 = 6;
pub const ICON: &str = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDgiIGhlaWdodD0iNDgiIHZpZXdCb3g9IjAgMCA0OCA0OCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMjQiIGN5PSIyNCIgcj0iMjQiIGZpbGw9IiMwNTFGNDQiLz4KPHBhdGggZD0iTTE1LjM5NzQgMjkuOTMyMUMxNC4xNTk0IDI5LjkzMjEgMTMuMDU5IDI5LjI5NjMgMTIuNDQ4MyAyOC4yMjkzQzExLjgzNzYgMjcuMTYyMyAxMS44NTEzIDI1Ljg5NjEgMTIuNDg2OCAyNC44NDI4TDIzLjA2MTcgNy4yNzQzOEwyMy4wNzU0IDcuMjU1MjhDMjMuNjIyOSA2LjQ1NTcyIDI0LjQ3ODQgNiAyNS40MjIgNkMyNi4yODMxIDYgMjcuMTI3NyA2LjM4NzUgMjcuNjgwNiA3LjAzNjk3QzI4LjIxOTggNy42NzI3OSAyOC40MzcxIDguNDkxNDUgMjguMjg4NiA5LjM0Mjg1TDI2LjA0OTMgMjIuMjI4NUwyMS44Njc3IDI0LjMyN0wyMy43Mjc0IDEzLjUxNTNMMTYuNDI5IDI1Ljk5NDRIMjAuMzY1N0wxOS42MjAyIDI5LjkzMjFIMTUuNDAwMUgxNS4zOTc0WiIgZmlsbD0idXJsKCNwYWludDBfbGluZWFyXzMzMzM5XzkzMTcpIi8+CjxwYXRoIGQ9Ik0yMi40NDg0IDQxLjk5OTVDMjEuNTg3MyA0MS45OTk1IDIwLjc0MjcgNDEuNjEyIDIwLjE4OTggNDAuOTYyNUMxOS42NTA2IDQwLjMyNjcgMTkuNDMzMyAzOS41MDggMTkuNTgxOCAzOC42NTY2TDIxLjgyMTEgMjUuNzcxTDI2LjAwMjcgMjMuNjcyNUwyNC4xNDMgMzQuNDg0MkwzMS40NDE0IDIyLjAwNTFIMjcuNTA0N0wyOC4yNTAyIDE4LjA2NzRIMzIuNDcwM0MzMy43MDgyIDE4LjA2NzQgMzQuODA4NiAxOC43MDMyIDM1LjQxOTQgMTkuNzcwMkMzNi4wMzAxIDIwLjgzNzIgMzYuMDE2MyAyMi4xMDM0IDM1LjM4MDkgMjMuMTU2N0wyNC44MDYgNDAuNzI1MUwyNC43OTIyIDQwLjc0NDJDMjQuMjQ0OCA0MS41NDM4IDIzLjM4OTIgNDEuOTk5NSAyMi40NDU2IDQxLjk5OTVIMjIuNDQ4NFoiIGZpbGw9InVybCgjcGFpbnQxX2xpbmVhcl8zMzMzOV85MzE3KSIvPgo8cGF0aCBvcGFjaXR5PSIwLjE1IiBkPSJNMTkuOTk5OSAyNy45MTY4SDE1LjYyM0MxNC4yNzUgMjcuOTE2OCAxMy40NTI1IDI2LjQ0ODYgMTQuMTYyMyAyNS4zMTM0TDI0LjQzMTggOC44NjM4N0MyNC45MzggOC4wNTA2NyAyNi4yMDYyIDguNTA5MTEgMjYuMDY4NiA5LjQ1MzNMMjQuMDY1OSAyMy4yMTc3TDIxLjg2NzggMjQuMzIyOUwyMy43Mjc1IDEzLjUxMTFMMTYuNDI5MSAyNS45OTAySDIwLjM2NThMMjAuMDAyNyAyNy45MTRMMTkuOTk5OSAyNy45MTY4WiIgZmlsbD0id2hpdGUiLz4KPHBhdGggb3BhY2l0eT0iMC4xNSIgZD0iTTI3Ljg4NDMgMjAuMDYyNUgzMi4yNjExQzMzLjYwOTEgMjAuMDYyNSAzNC40MzE3IDIxLjUzMDYgMzMuNzIxOSAyMi42NjU4TDIzLjQ0OTYgMzkuMTE1NEMyMi45NDM1IDM5LjkyODYgMjEuNjc1MiAzOS40NzAxIDIxLjgxMjggMzguNTI2TDIzLjgxNTUgMjQuNzYxNkwyNi4wMTM2IDIzLjY1NjRMMjQuMTUzOSAzNC40NjgxTDMxLjQ1MjMgMjEuOTg5MUgyNy41MTU2TDI3Ljg3ODggMjAuMDY1MkwyNy44ODQzIDIwLjA2MjVaIiBmaWxsPSJ3aGl0ZSIvPgo8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDBfbGluZWFyXzMzMzM5XzkzMTciIHgxPSIyMC4xNjQ5IiB5MT0iMjUuNjM0MSIgeDI9IjIwLjE2NDkiIHkyPSIxLjcwMjA1IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IiMwMDU4RjEiLz4KPHN0b3Agb2Zmc2V0PSIwLjUzIiBzdG9wLWNvbG9yPSIjMDBCMUZGIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzAzQTlGRCIvPgo8L2xpbmVhckdyYWRpZW50Pgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MV9saW5lYXJfMzMzMzlfOTMxNyIgeDE9IjI3LjcwMjgiIHkxPSI0MS45OTk1IiB4Mj0iMjcuNzAyOCIgeTI9IjE4LjA2NzQiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0ZGQUIxMSIvPgo8c3RvcCBvZmZzZXQ9IjAuMDkiIHN0b3AtY29sb3I9IiNGREE0MUEiLz4KPHN0b3Agb2Zmc2V0PSIwLjI0IiBzdG9wLWNvbG9yPSIjRkE5MjMyIi8+CjxzdG9wIG9mZnNldD0iMC40MyIgc3RvcC1jb2xvcj0iI0Y0NzQ1QiIvPgo8c3RvcCBvZmZzZXQ9IjAuNjUiIHN0b3AtY29sb3I9IiNFRDRCOTIiLz4KPHN0b3Agb2Zmc2V0PSIwLjkiIHN0b3AtY29sb3I9IiNFMzE3RDkiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjREYwMEY5Ii8+CjwvbGluZWFyR3JhZGllbnQ+CjwvZGVmcz4KPC9zdmc+Cg==";


================================================
File: contracts/pausable-udt/src/error.rs
================================================
use core::str::Utf8Error;

use ckb_ssri_std::public_module_traits::udt::{UDTError, UDTPausableError};
use ckb_ssri_std::SSRIError;
use ckb_std::error::SysError;
use serde_molecule;

/// Error
#[repr(i8)]
#[derive(Debug)]
pub enum Error {
    // * CKB Error
    IndexOutOfBound = 1,
    ItemMissing = 2,
    LengthNotEnough,
    Encoding,
    SpawnExceededMaxContentLength,
    SpawnWrongMemoryLimit,
    SpawnExceededMaxPeakMemory,

    // * Rust Error
    Utf8Error,

    // * SSRI Error
    SSRIMethodsNotFound,
    SSRIMethodsArgsInvalid,
    SSRIMethodsNotImplemented,
    SSRIMethodRequireHigherLevel,
    InvalidVmVersion,

    // * Molecule Error
    MoleculeVerificationError,

    // * Serde Molecule Error
    SerdeMoleculeErrorWithMessage,
    /// Contains a general error message as a string.
    /// Occurs when the data length is incorrect while parsing a number or molecule header.
    MismatchedLength,
    /// Occurs when the data length is insufficient while parsing a number or molecule header.
    SerdeMoleculeLengthNotEnough,
    /// Indicates that the method or type is not implemented. Not all types in Rust can be serialized.
    Unimplemented,
    /// Occurs when assembling a molecule fixvec, and the size of each element is inconsistent.
    AssembleFixvec,
    /// Occurs when the header or size is incorrect while parsing a molecule fixvec.
    InvalidFixvec,
    /// Occurs when the field count is mismatched while parsing a molecule table.
    MismatchedTableFieldCount,
    /// Occurs when an overflow happens while parsing a molecule header.
    Overflow,
    /// Indicates an error encountered while parsing a molecule array.
    InvalidArray,
    /// Indicates that non-fixed size fields are not allowed in a molecule struct, e.g., `Option`, `Vec`, `DynVec`, `enum`.
    InvalidStructField,
    /// Indicates that a map should have exactly two fields: a key and a value.
    InvalidMap,
    /// Indicates that the table header is invalid or malformed.
    InvalidTable,
    /// Indicates that the table length is invalid or malformed.
    InvalidTableLength,
    /// Indicates that the table header is invalid or malformed.
    InvalidTableHeader,
    /// Indicates that the field count in serialization is mismatched.
    InvalidTableCount,
    /// Indicates that non-fixed size fields are not allowed in a molecule struct, e.g., `Option`, `Vec`, `DynVec`, `enum`.
    MixTableAndStruct,
    InvalidChar,

    // * UDT Error
    InsufficientBalance,
    NoTransferPermission,
    NoMintPermission,
    NoBurnPermission,

    // * UDT Pausable Error
    NothingToDo,
    NoPausePermission,
    NoUnpausePermission,
    AbortedFromPause,
    IncompletePauseList,
    CyclicPauseList,
    InvalidPauseData,
}

#[allow(non_snake_case, unused)]
impl From<SysError> for Error {
    fn from(err: SysError) -> Self {
        use SysError::*;
        match err {
            IndexOutOfBound => Self::IndexOutOfBound,
            ItemMissing => Self::ItemMissing,
            LengthNotEnough(_) => Self::LengthNotEnough,
            Encoding => Self::Encoding,
            SpawnExceededMaxContentLength => Self::SpawnExceededMaxContentLength,
            SpawnWrongMemoryLimit => Self::SpawnWrongMemoryLimit,
            SpawnExceededMaxPeakMemory => Self::SpawnExceededMaxPeakMemory,
            Unknown(err_code) => panic!("unexpected sys error {}", err_code),
        }
    }
}

impl From<Utf8Error> for Error {
    fn from(_err: Utf8Error) -> Self {
        Self::Utf8Error
    }
}

impl From<serde_molecule::Error> for Error {
    fn from(err: serde_molecule::Error) -> Self {
        use serde_molecule::Error::*;
        match err {
            Message(_string) => Self::SerdeMoleculeErrorWithMessage,
            MismatchedLength => Self::MismatchedLength,
            LengthNotEnough => Self::SerdeMoleculeLengthNotEnough,
            Unimplemented => Self::Unimplemented,
            AssembleFixvec => Self::AssembleFixvec,
            InvalidFixvec => Self::InvalidFixvec,
            MismatchedTableFieldCount => Self::MismatchedTableFieldCount,
            Overflow => Self::Overflow,
            InvalidArray => Self::InvalidArray,
            InvalidStructField => Self::InvalidStructField,
            InvalidMap => Self::InvalidMap,
            InvalidTable => Self::InvalidTable,
            InvalidTableLength => Self::InvalidTableLength,
            InvalidTableHeader => Self::InvalidTableHeader,
            InvalidTableCount => Self::InvalidTableCount,
            MixTableAndStruct => Self::MixTableAndStruct,
            InvalidChar => Self::InvalidChar,
        }
    }
}

impl From<SSRIError> for Error {
    fn from(err: SSRIError) -> Self {
        match err {
            SSRIError::SSRIMethodsNotFound => Self::SSRIMethodsArgsInvalid,
            SSRIError::SSRIMethodsArgsInvalid => Self::SSRIMethodsNotImplemented,
            SSRIError::SSRIMethodsNotImplemented => Self::SSRIMethodsNotImplemented,
            SSRIError::SSRIMethodRequireHigherLevel => Self::SSRIMethodRequireHigherLevel,
            SSRIError::InvalidVmVersion => Self::InvalidVmVersion,
        }
    }
}

impl From<UDTError> for Error {
    fn from(err: UDTError) -> Self {
        match err {
            UDTError::InsufficientBalance => Self::InsufficientBalance,
            UDTError::NoMintPermission => Self::NoMintPermission,
            UDTError::NoBurnPermission => Self::NoBurnPermission,
        }
    }
}

impl From<UDTPausableError> for Error {
    fn from(err: UDTPausableError) -> Self {
        match err {
            UDTPausableError::NoPausePermission => Self::NoPausePermission,
            UDTPausableError::NoUnpausePermission => Self::NoUnpausePermission,
            UDTPausableError::AbortedFromPause => Self::AbortedFromPause,
            UDTPausableError::IncompletePauseList => Self::IncompletePauseList,
            UDTPausableError::CyclicPauseList => Self::CyclicPauseList,
        }
    }
}


================================================
File: contracts/pausable-udt/src/fallback.rs
================================================
use crate::{
    error::Error,
    modules::PausableUDT,
};

use alloc::vec;
use alloc::vec::Vec;
use ckb_std::{
    ckb_constants::Source, debug, high_level::load_cell_lock_hash
};

use ckb_ssri_std::public_module_traits::udt::{UDTPausable, UDT};

pub fn fallback() -> Result<(), Error> {
    debug!("Entered fallback");
    let mut lock_hashes: Vec<[u8; 32]> = vec![];

    let mut index = 0;
    while let Ok(lock_hash) = load_cell_lock_hash(index, Source::Input) {
        lock_hashes.push(lock_hash);
        index += 1;
    }

    index = 0;
    while let Ok(lock_hash) = load_cell_lock_hash(index, Source::Output) {
        lock_hashes.push(lock_hash);
        index += 1;
    }

    if PausableUDT::is_paused(&lock_hashes)?.iter().any(|&b| b) {
        return Err(Error::AbortedFromPause);
    }

    match PausableUDT::verify_mint() {
        Ok(_) => Ok(()),
        Err(_) => match PausableUDT::verify_transfer() {
            Ok(_) => Ok(()),
            Err(e) => Err(e),
        },
    }
}


================================================
File: contracts/pausable-udt/src/main.rs
================================================
#![no_std]
#![cfg_attr(not(test), no_main)]

#[cfg(test)]
extern crate alloc;

use alloc::borrow::Cow;
use alloc::ffi::CString;
use ckb_ssri_std::prelude::decode_u8_32_vector;

use ckb_ssri_std::utils::should_fallback;
use ckb_ssri_std_proc_macro::ssri_methods;
use ckb_std::ckb_types::packed::{Byte32, Bytes, Script, ScriptBuilder, Transaction};
use ckb_std::debug;
#[cfg(not(test))]
use ckb_std::default_alloc;
#[cfg(not(test))]
ckb_std::entry!(program_entry);
#[cfg(not(test))]
default_alloc!();

use ckb_ssri_std::public_module_traits::udt::{ScriptLike, UDTPausable, UDTPausableData, UDT};

use alloc::vec;

use ckb_std::ckb_types::prelude::{Builder, Entity, Pack};
use ckb_std::high_level::decode_hex;
use ckb_std::syscalls::{pipe, write};
use config::*;
use error::Error;

mod config;
mod error;
mod fallback;
mod modules;
mod molecule;
mod utils;
use ::molecule::prelude::Reader;

pub fn get_pausable_data() -> Result<UDTPausableData, Error> {
    debug!("Entered get_pausable_data");
    Ok(UDTPausableData {
        pause_list: utils::format_pause_list(
            IN_CONTRACT_PAUSED_LOCK_HASHES.iter().copied().collect(),
        ),
        next_type_script: if INITIAL_EXTERNAL_DATA_CELL_TYPE_CODE_HASH.is_empty()
            || INITIAL_EXTERNAL_DATA_CELL_TYPE_ARGS.is_empty()
        {
            None
        } else {
            Some(ScriptLike {
                code_hash: decode_hex(
                    &CString::new(INITIAL_EXTERNAL_DATA_CELL_TYPE_CODE_HASH)
                        .map_err(|_| Error::InvalidPauseData)?
                        .as_c_str()[2..],
                )?
                .try_into()
                .map_err(|_| Error::InvalidPauseData)?,
                args: decode_hex(
                    &CString::new(INITIAL_EXTERNAL_DATA_CELL_TYPE_ARGS)
                        .map_err(|_| Error::InvalidPauseData)?
                        .as_c_str()[2..],
                )?,
                hash_type: INITIAL_EXTERNAL_DATA_CELL_TYPE_HASH_TYPE.into(),
            })
        },
    })
}

fn program_entry_wrap() -> Result<(), Error> {
    let argv = ckb_std::env::argv();

    if should_fallback()? {
        return Ok(fallback::fallback()?);
    }

    debug!("Entering ssri_methods");
    // NOTE: The following part is an entry function acting as an controller for all SSRI methods and also handles the deserialization/serialization.
    // In the future, methods can be reflected automatically from traits using procedural macros and entry methods to other methods of the same trait for a more concise and maintainable entry function.
    let res: Cow<'static, [u8]> = ssri_methods!(
        argv: &argv,
        invalid_method: Error::SSRIMethodsNotFound,
        invalid_args: Error::SSRIMethodsArgsInvalid,
        "UDT.name" => Ok(Cow::from(modules::PausableUDT::name()?.to_vec())),
        "UDT.symbol" => Ok(Cow::from(modules::PausableUDT::symbol()?.to_vec())),
        "UDT.decimals" => Ok(Cow::from(modules::PausableUDT::decimals()?.to_le_bytes().to_vec())),
        "UDT.icon" => Ok(Cow::from(modules::PausableUDT::icon()?.to_vec())),
        "UDTPausable.is_paused" => {
            let response = modules::PausableUDT::is_paused(&decode_u8_32_vector(decode_hex(argv[1].as_ref())?).map_err(|_|error::Error::SSRIMethodsArgsInvalid)?)?;
            let response_bytes = response.iter().map(|b| if *b { 1 } else { 0 }).collect::<Vec<u8>>().pack();
            Ok(Cow::from(response_bytes.as_bytes().to_vec()))
        },
        "UDTPausable.enumerate_paused" => {
            let offset = u64::from_le_bytes(decode_hex(argv[1].as_ref())?.try_into().unwrap_or_default());
            let limit = u64::from_le_bytes(decode_hex(argv[2].as_ref())?.try_into().unwrap_or_default());
            let response = modules::PausableUDT::enumerate_paused(offset, limit)?;
            Ok(Cow::from(response.as_bytes().to_vec()))
        },
        "UDT.transfer" => {
            debug!("program_entry_wrap | Entered UDT.transfer");
            let to_lock_vec_molecule = molecule::ScriptVec::from_slice(decode_hex(argv[2].as_ref())?.as_slice()).map_err(|_|Error::MoleculeVerificationError)?;
            let mut to_lock_vec: Vec<Script> = vec![];
            for script in to_lock_vec_molecule.into_iter() {
                let parsed_script = ScriptBuilder::default()
                    .code_hash(Byte32::from_slice(script.as_reader().code_hash().to_entity().as_slice()).map_err(|_|Error::MoleculeVerificationError)?)
                    .hash_type(script.as_reader().hash_type().to_entity())
                    .args(Bytes::from_slice(script.as_reader().args().to_entity().as_slice()).map_err(|_|Error::MoleculeVerificationError)?)
                    .build();
                to_lock_vec.push(parsed_script);
            }

            let to_amount_bytes = decode_hex(argv[3].as_ref())?;
            let to_amount_vec: Vec<u128> = to_amount_bytes[4..]
                .chunks(16)
                .map(|chunk| {
                    return u128::from_le_bytes(chunk.try_into().unwrap())}
                )
                .collect();

            if argv[2].is_empty() || argv[3].is_empty() || to_lock_vec.len() != to_amount_vec.len() {
                Err(Error::SSRIMethodsArgsInvalid)?;
            }

            let tx: Option<Transaction>;
            if argv[1].as_ref().to_str()? == "" {
                tx = None;
            } else {
                let parsed_tx: Transaction = Transaction::from_compatible_slice(&decode_hex(argv[1].as_ref())?).map_err(|_|Error::MoleculeVerificationError)?;
                tx = Some(parsed_tx);
            }

            Ok(Cow::from(modules::PausableUDT::transfer(tx, to_lock_vec, to_amount_vec)?.as_bytes().to_vec()))
        },
        "UDT.mint" => {
            debug!("program_entry_wrap | Entered UDT.mint");
            let to_lock_vec_molecule = molecule::ScriptVec::from_slice(decode_hex(argv[2].as_ref())?.as_slice()).map_err(|_|Error::MoleculeVerificationError)?;
            let mut to_lock_vec: Vec<Script> = vec![];
            for script in to_lock_vec_molecule.into_iter() {
                let parsed_script = ScriptBuilder::default()
                    .code_hash(Byte32::from_slice(script.as_reader().code_hash().to_entity().as_slice()).map_err(|_|Error::MoleculeVerificationError)?)
                    .hash_type(script.as_reader().hash_type().to_entity())
                    .args(Bytes::from_slice(script.as_reader().args().to_entity().as_slice()).map_err(|_|Error::MoleculeVerificationError)?)
                    .build();
                to_lock_vec.push(parsed_script);
            }
            debug!("program_entry_wrap | to_lock_vec: {:?}", to_lock_vec);

            let to_amount_bytes = decode_hex(argv[3].as_ref())?;
            let to_amount_vec: Vec<u128> = to_amount_bytes[4..]
                .chunks(16)
                .map(|chunk| {
                    return u128::from_le_bytes(chunk.try_into().unwrap())}
                )
                .collect();
            debug!("program_entry_wrap | to_amount_vec: {:?}", to_amount_vec);

            if argv[2].is_empty() || argv[3].is_empty() || to_lock_vec.len() != to_amount_vec.len() {
                Err(Error::SSRIMethodsArgsInvalid)?;
            }

            let tx: Option<Transaction>;
            if argv[1].as_ref().to_str()? == ""{
                tx = None;
            } else {
                let parsed_tx: Transaction = Transaction::from_compatible_slice(&decode_hex(argv[1].as_ref())?).map_err(|_|Error::MoleculeVerificationError)?;
                tx = Some(parsed_tx);
            }

            Ok(Cow::from(modules::PausableUDT::mint(tx, to_lock_vec, to_amount_vec)?.as_bytes().to_vec()))
        },
        "UDTPausable.pause" => {
            debug!("program_entry_wrap | Entered UDTPausable.pause");
            let lock_hashes_vec: Vec<[u8; 32]> = decode_u8_32_vector(decode_hex(argv[2].as_ref())?).map_err(|_|error::Error::InvalidArray)?;
            debug!("program_entry_wrap | lock_hashes_vec: {:?}", lock_hashes_vec);

            if argv[2].is_empty() {
                Err(Error::SSRIMethodsArgsInvalid)?;
            }

            let tx: Option<Transaction>;
            if argv[1].as_ref().to_str()? == ""{
                tx = None;
            } else {
                let parsed_tx: Transaction = Transaction::from_compatible_slice(&decode_hex(argv[1].as_ref())?).map_err(|_|Error::MoleculeVerificationError)?;
                tx = Some(parsed_tx);
            }

            Ok(Cow::from(modules::PausableUDT::pause(tx, &lock_hashes_vec)?.as_bytes().to_vec()))
        },
        "UDTPausable.unpause" => {
            debug!("program_entry_wrap | Entered UDTPausable.unpause");
            let lock_hashes_vec: Vec<[u8; 32]> = decode_u8_32_vector(decode_hex(argv[2].as_ref())?).map_err(|_|error::Error::InvalidArray)?;
            debug!("program_entry_wrap | lock_hashes_vec: {:?}", lock_hashes_vec);

            if argv[2].is_empty() {
                Err(Error::SSRIMethodsArgsInvalid)?;
            }

            let tx: Option<Transaction>;
            if argv[1].as_ref().to_str()? == ""{
                tx = None;
            } else {
                let parsed_tx: Transaction = Transaction::from_compatible_slice(&decode_hex(argv[1].as_ref())?).map_err(|_|Error::MoleculeVerificationError)?;
                tx = Some(parsed_tx);
            }
            Ok(Cow::from(modules::PausableUDT::unpause(tx, &lock_hashes_vec)?.as_bytes().to_vec()))
        },
    )?;
    let pipe = pipe()?;
    write(pipe.1, &res)?;
    Ok(())
}

pub fn program_entry() -> i8 {
    match program_entry_wrap() {
        Ok(_) => 0,
        Err(err) => err as i8,
    }
}


================================================
File: contracts/pausable-udt/src/modules.rs
================================================
use crate::error::Error;
use crate::utils::{check_owner_mode, collect_inputs_amount, collect_outputs_amount};
use crate::{get_pausable_data, DECIMALS, ICON, NAME, SYMBOL};
use alloc::borrow::ToOwned;
use alloc::ffi::CString;
use alloc::string::String;
use alloc::vec;
use alloc::vec::Vec;
use ckb_hash::new_blake2b;
use ckb_ssri_std::public_module_traits::udt::{UDTPausable, UDTPausableData, UDT};
use ckb_ssri_std::utils::high_level::{
    find_cell_by_out_point, find_cell_data_by_out_point, find_out_point_by_type,
};
use ckb_ssri_std::utils::should_fallback;
use ckb_std::ckb_constants::Source;
use ckb_std::ckb_types::core::ScriptHashType;
use ckb_std::ckb_types::packed::{
    Byte, Byte32, Byte32Vec, BytesVec, BytesVecBuilder, CellDep, CellDepVec, CellDepVecBuilder,
    CellInput, CellInputVec, CellInputVecBuilder, CellOutput, CellOutputBuilder,
    CellOutputVecBuilder, RawTransactionBuilder, Script, ScriptBuilder, ScriptOptBuilder,
    Transaction, TransactionBuilder, Uint32, Uint64,
};
use ckb_std::ckb_types::{bytes::Bytes, prelude::*};
use ckb_std::debug;
use ckb_std::high_level::{decode_hex, load_cell_data, load_cell_type, load_script};
use serde_molecule::{from_slice, to_vec};

pub struct PausableUDT;

// #[ssri_module]
impl UDT for PausableUDT {
    type Error = Error;
    // #[ssri_method(level = "script", transaction = true)]
    fn transfer(
        tx: Option<Transaction>,
        to_lock_vec: Vec<Script>,
        to_amount_vec: Vec<u128>,
    ) -> Result<Transaction, Error> {
        debug!("Entered UDT::transfer");
        if to_amount_vec.len() != to_lock_vec.len() {
            return Err(Error::SSRIMethodsArgsInvalid);
        }
        let tx_builder = match tx {
            Some(ref tx) => tx.clone().as_builder(),
            None => TransactionBuilder::default(),
        };
        let raw_tx_builder = match tx {
            Some(ref tx) => tx.clone().raw().as_builder(),
            None => RawTransactionBuilder::default(),
        };

        let mut cell_output_vec_builder = match tx {
            Some(ref tx) => tx.clone().raw().outputs().as_builder(),
            None => CellOutputVecBuilder::default(),
        };

        for to_lock in to_lock_vec.iter() {
            let new_transfer_output = CellOutputBuilder::default()
                .type_(
                    ScriptOptBuilder::default()
                        .set(Some(load_script()?))
                        .build(),
                )
                .capacity(Uint64::default())
                .lock(to_lock.clone())
                .build();
            cell_output_vec_builder = cell_output_vec_builder.push(new_transfer_output);
        }

        let mut outputs_data_builder = match tx {
            Some(ref tx) => tx.clone().raw().outputs_data().as_builder(),
            None => BytesVecBuilder::default(),
        };

        for to_amount in to_amount_vec.iter() {
            outputs_data_builder = outputs_data_builder.push(to_amount.pack().as_bytes().pack());
        }

        let mut cell_dep_vec_builder: CellDepVecBuilder = match tx {
            Some(ref tx) => tx.clone().raw().cell_deps().as_builder(),
            None => CellDepVecBuilder::default(),
        };
        let mut current_pausable_data = get_pausable_data()?;
        while let Some(ref next_type_script_like) = current_pausable_data.next_type_script {
            debug!("Next type script like: {:?}", next_type_script_like);
            let next_type_script = ScriptBuilder::default()
                .code_hash(next_type_script_like.clone().code_hash.pack())
                .hash_type(Byte::new(next_type_script_like.clone().hash_type))
                .args(next_type_script_like.clone().args.pack())
                .build();
            let cell_dep = CellDep::new_builder()
                .out_point(find_out_point_by_type(next_type_script.clone())?)
                .build();
            cell_dep_vec_builder = cell_dep_vec_builder.push(cell_dep);
            current_pausable_data = from_slice(
                &find_cell_data_by_out_point(find_out_point_by_type(next_type_script.clone())?)?,
                false,
            )?;
        }

        Ok(tx_builder
            .raw(
                raw_tx_builder
                    .version(
                        tx.clone()
                            .map(|t| t.raw().version())
                            .unwrap_or_else(|| Uint32::default()),
                    )
                    .cell_deps(cell_dep_vec_builder.build())
                    .header_deps(
                        tx.clone()
                            .map(|t| t.raw().header_deps())
                            .unwrap_or_else(|| Byte32Vec::default()),
                    )
                    .inputs(
                        tx.clone()
                            .map(|t| t.raw().inputs())
                            .unwrap_or_else(|| CellInputVec::default()),
                    )
                    .outputs(cell_output_vec_builder.build())
                    .outputs_data(outputs_data_builder.build())
                    .build(),
            )
            .witnesses(
                tx.clone()
                    .map(|t| t.witnesses())
                    .unwrap_or_else(|| BytesVec::default()),
            )
            .build())
    }

    fn verify_transfer() -> Result<(), Self::Error> {
        debug!("Entered UDT::verify_transfer");
        let inputs_amount = collect_inputs_amount()?;
        let outputs_amount = collect_outputs_amount()?;

        if inputs_amount < outputs_amount {
            return Err(Error::InsufficientBalance);
        }
        debug!("inputs_amount: {}", inputs_amount);
        debug!("outputs_amount: {}", outputs_amount);
        Ok(())
    }

    // #[ssri_method(level = "script")]
    fn name() -> Result<Bytes, Self::Error> {
        Ok(Bytes::from(String::from(NAME).into_bytes()))
    }

    // #[ssri_method(level = "script")]
    fn symbol() -> Result<Bytes, Self::Error> {
        Ok(Bytes::from(String::from(SYMBOL).into_bytes()))
    }

    // #[ssri_method(level = "script")]
    fn decimals() -> Result<u8, Self::Error> {
        Ok(DECIMALS)
    }
    // #[ssri_method(level = "script", transaction = true)]
    fn mint(
        tx: Option<Transaction>,
        to_lock_vec: Vec<Script>,
        to_amount_vec: Vec<u128>,
    ) -> Result<Transaction, Error> {
        debug!("Entered UDT::mint");
        let tx_builder = match tx {
            Some(ref tx) => tx.clone().as_builder(),
            None => TransactionBuilder::default(),
        };
        let raw_tx_builder = match tx {
            Some(ref tx) => tx.clone().raw().as_builder(),
            None => RawTransactionBuilder::default(),
        };

        let mut cell_output_vec_builder = match tx {
            Some(ref tx) => tx.clone().raw().outputs().as_builder(),
            None => CellOutputVecBuilder::default(),
        };

        for to_lock in to_lock_vec.iter() {
            let new_mint_output = CellOutputBuilder::default()
                .type_(
                    ScriptOptBuilder::default()
                        .set(Some(load_script()?))
                        .build(),
                )
                .lock(to_lock.clone())
                .build();
            cell_output_vec_builder = cell_output_vec_builder.push(new_mint_output);
        }

        let mut outputs_data_builder = match tx {
            Some(ref tx) => tx.clone().raw().outputs_data().as_builder(),
            None => BytesVecBuilder::default(),
        };

        for to_amount in to_amount_vec.iter() {
            outputs_data_builder = outputs_data_builder.push(to_amount.pack().as_bytes().pack());
        }

        let mut cell_dep_vec_builder: CellDepVecBuilder = match tx {
            Some(ref tx) => tx.clone().raw().cell_deps().as_builder(),
            None => CellDepVecBuilder::default(),
        };
        let mut current_pausable_data = get_pausable_data()?;
        while let Some(ref next_type_script_like) = current_pausable_data.next_type_script {
            debug!("Next type script like: {:?}", next_type_script_like);
            let next_type_script = ScriptBuilder::default()
                .code_hash(next_type_script_like.clone().code_hash.pack())
                .hash_type(Byte::new(next_type_script_like.clone().hash_type))
                .args(next_type_script_like.clone().args.pack())
                .build();
            let cell_dep = CellDep::new_builder()
                .out_point(find_out_point_by_type(next_type_script.clone())?)
                .build();
            cell_dep_vec_builder = cell_dep_vec_builder.push(cell_dep);
            current_pausable_data = from_slice(
                &find_cell_data_by_out_point(find_out_point_by_type(next_type_script.clone())?)?,
                false,
            )?;
        }

        Ok(tx_builder
            .raw(
                raw_tx_builder
                    .version(
                        tx.clone()
                            .map(|t| t.raw().version())
                            .unwrap_or_else(|| Uint32::default()),
                    )
                    .cell_deps(cell_dep_vec_builder.build())
                    .header_deps(
                        tx.clone()
                            .map(|t| t.raw().header_deps())
                            .unwrap_or_else(|| Byte32Vec::default()),
                    )
                    .inputs(
                        tx.clone()
                            .map(|t| t.raw().inputs())
                            .unwrap_or_else(|| CellInputVec::default()),
                    )
                    .outputs(cell_output_vec_builder.build())
                    .outputs_data(outputs_data_builder.build())
                    .build(),
            )
            .witnesses(
                tx.clone()
                    .map(|t| t.witnesses())
                    .unwrap_or_else(|| BytesVec::default()),
            )
            .build())
    }

    fn verify_mint() -> Result<(), Self::Error> {
        debug!("Entered UDT::verify_mint");
        let script = load_script()?;
        let args = script.args().unpack();
        if check_owner_mode(&args)? {
            return Ok(());
        } else {
            return Err(Error::NoMintPermission);
        }
    }
    // #[ssri_method(level = "script")]
    fn icon() -> Result<Bytes, Self::Error> {
        Ok(Bytes::from(ICON.to_owned().into_bytes()))
    }
}

// #[ssri_module(base = "UDT")]
impl UDTPausable for PausableUDT {
    // #[ssri_method(level = "script", transaction = true)]
    fn pause(tx: Option<Transaction>, lock_hashes: &Vec<[u8; 32]>) -> Result<Transaction, Error> {
        let mut deduped_lock_hashes = lock_hashes.clone();
        deduped_lock_hashes.dedup();
        let tx_builder = match tx {
            Some(ref tx) => tx.clone().as_builder(),
            None => TransactionBuilder::default(),
        };
        let raw_tx_builder = match tx {
            Some(ref tx) => tx.clone().raw().as_builder(),
            None => RawTransactionBuilder::default(),
        };

        let mut new_cell_output: CellOutput;
        let new_output_data: UDTPausableData;
        let mut last_cell_type_script: Option<Script> = None;
        let mut new_cell_input: Option<CellInput> = None;

        debug!("Automatically redirect to the last pause list cell.");
        let mut current_pausable_data = get_pausable_data()?;
        // Dedup lock_hashes against current_pausable_data.pause_list
        deduped_lock_hashes = deduped_lock_hashes
            .into_iter()
            .filter(|lock_hash| !current_pausable_data.pause_list.contains(lock_hash))
            .collect();

        while let Some(ref next_type_script_like) = current_pausable_data.next_type_script {
            debug!("Next type script like: {:?}", next_type_script_like);
            let next_type_script = ScriptBuilder::default()
                .code_hash(next_type_script_like.clone().code_hash.pack())
                .hash_type(Byte::new(next_type_script_like.clone().hash_type))
                .args(next_type_script_like.clone().args.pack())
                .build();
            let next_cell_out_point = find_out_point_by_type(next_type_script.clone())?;
            let next_pausable_data: UDTPausableData = from_slice(
                &find_cell_data_by_out_point(next_cell_out_point.clone())?,
                false,
            )?;
            // Dedup lock_hashes against next_pausable_data.pause_list
            deduped_lock_hashes = deduped_lock_hashes
                .into_iter()
                .filter(|lock_hash| !next_pausable_data.pause_list.contains(lock_hash))
                .collect();
            if next_pausable_data.next_type_script.is_none() {
                last_cell_type_script = Some(next_type_script.clone());
            }
            current_pausable_data = next_pausable_data;
        }
        if deduped_lock_hashes.len() == 0 {
            return Err(Error::NothingToDo);
        }
        if last_cell_type_script.is_none() {
            debug!("No pause list cell found. Try to generate the first pause list cell.");
            match tx {
                Some(ref tx) => match tx.raw().inputs().get(0) {
                    Some(first_input_cell_input) => {
                        let first_input_outpoint = first_input_cell_input.previous_output();
                        let first_input_cell =
                            find_cell_by_out_point(first_input_outpoint.clone())?;
                        let mut hasher = new_blake2b();
                        hasher.update(first_input_cell_input.as_slice());
                        let type_id_index = tx.raw().outputs().len();
                        hasher.update(&type_id_index.to_le_bytes());
                        let mut ret = [0; 32];
                        hasher.finalize(&mut ret);
                        let type_id_bytes = ret.to_vec();
                        let type_id_script_code_hash_string =
                            "00000000000000000000000000000000000000000000000000545950455f4944";
                        let cstring = CString::new(type_id_script_code_hash_string)
                            .map_err(|_| Error::InvalidPauseData)?;
                        let type_id_script_code_hash_cstr = &cstring.as_c_str();
                        let new_type_id_script = Script::new_builder()
                            .code_hash(
                                Byte32::from_slice(&decode_hex(type_id_script_code_hash_cstr)?)
                                    .map_err(|_| Error::MoleculeVerificationError)?,
                            )
                            .hash_type(ScriptHashType::Type.into())
                            .args(type_id_bytes.clone().pack())
                            .build();
                        new_cell_output = CellOutput::new_builder()
                            .lock(first_input_cell.lock())
                            .type_(
                                ScriptOptBuilder::default()
                                    .set(Some(new_type_id_script))
                                    .build(),
                            )
                            .build();
                        new_output_data = UDTPausableData {
                            pause_list: deduped_lock_hashes.clone(),
                            next_type_script: None,
                        };
                    }
                    None => return Err(Error::NoPausePermission),
                },
                None => return Err(Error::NoPausePermission),
            }
        } else {
            let last_cell_out_point = find_out_point_by_type(last_cell_type_script.should_be_ok())?;
            new_cell_output = find_cell_by_out_point(last_cell_out_point.clone())?;
            new_cell_output = new_cell_output
                .as_builder()
                .capacity(Uint64::default())
                .build();
            let last_cell_data = find_cell_data_by_out_point(last_cell_out_point.clone())?;
            let mut pausable_data: UDTPausableData = from_slice(&last_cell_data, false)?;
            pausable_data.pause_list.extend(deduped_lock_hashes);
            new_output_data = pausable_data;
            new_cell_input = Some(
                CellInput::new_builder()
                    .previous_output(last_cell_out_point)
                    .build(),
            );
        }

        let cell_output_vec_builder = match tx {
            Some(ref tx) => tx.clone().raw().outputs().as_builder(),
            None => CellOutputVecBuilder::default(),
        }
        .push(new_cell_output);

        let output_data_vec_builder = match tx {
            Some(ref tx) => tx.clone().raw().outputs_data().as_builder(),
            None => BytesVecBuilder::default(),
        }
        .push(to_vec(&new_output_data, false)?.pack());

        let mut input_vec_builder = match tx {
            Some(ref tx) => tx.clone().raw().inputs().as_builder(),
            None => CellInputVecBuilder::default(),
        };

        match new_cell_input {
            Some(new_cell_input) => {
                input_vec_builder = input_vec_builder.push(new_cell_input);
            }
            None => {}
        }

        return Ok(tx_builder
            .raw(
                raw_tx_builder
                    .version(
                        tx.clone()
                            .map(|t| t.raw().version())
                            .unwrap_or_else(|| Uint32::default()),
                    )
                    .cell_deps(
                        tx.clone()
                            .map(|t| t.raw().cell_deps())
                            .unwrap_or_else(|| CellDepVec::default()),
                    )
                    .header_deps(
                        tx.clone()
                            .map(|t| t.raw().header_deps())
                            .unwrap_or_else(|| Byte32Vec::default()),
                    )
                    .inputs(input_vec_builder.build())
                    .outputs(cell_output_vec_builder.build())
                    .outputs_data(output_data_vec_builder.build())
                    .build(),
            )
            .witnesses(
                tx.clone()
                    .map(|t| t.witnesses())
                    .unwrap_or_else(|| BytesVec::default()),
            )
            .build());
    }

    // #[ssri_method(level = "script", transaction = true)]
    fn unpause(tx: Option<Transaction>, lock_hashes: &Vec<[u8; 32]>) -> Result<Transaction, Error> {
        let tx_builder = match tx {
            Some(ref tx) => tx.clone().as_builder(),
            None => TransactionBuilder::default(),
        };
        let raw_tx_builder = match tx {
            Some(ref tx) => tx.clone().raw().as_builder(),
            None => RawTransactionBuilder::default(),
        };

        let mut new_cell_output: CellOutput;
        let mut new_cell_input: Option<CellInput>;
        let mut output_data_vec_builder = match tx {
            Some(ref tx) => tx.clone().raw().outputs_data().as_builder(),
            None => BytesVecBuilder::default(),
        };
        let mut input_vec_builder = match tx {
            Some(ref tx) => tx.clone().raw().inputs().as_builder(),
            None => CellInputVecBuilder::default(),
        };
        let mut cell_output_vec_builder = match tx {
            Some(ref tx) => tx.clone().raw().outputs().as_builder(),
            None => CellOutputVecBuilder::default(),
        };

        let in_contract_pausable_data = get_pausable_data()?;
        if in_contract_pausable_data
            .pause_list
            .iter()
            .find(|x| lock_hashes.contains(x))
            .is_some()
        {
            return Err(Error::NoUnpausePermission)?;
        }
        let mut current_pausable_data = in_contract_pausable_data.clone();
        while current_pausable_data.next_type_script.is_some() {
            let script_like = current_pausable_data
                .next_type_script
                .as_ref()
                .should_be_ok();
            let next_type_script = Script::new_builder()
                .code_hash(script_like.code_hash.pack())
                .hash_type(Byte::new(script_like.hash_type))
                .args(script_like.args.pack())
                .build();
            let next_pausable_data_outpoint = find_out_point_by_type(next_type_script)?;
            let next_pausable_data_outpoint_data =
                find_cell_data_by_out_point(next_pausable_data_outpoint.clone())?;
            let next_pausable_data: UDTPausableData =
                from_slice(&next_pausable_data_outpoint_data, false)?;
            if next_pausable_data
                .pause_list
                .iter()
                .find(|x| lock_hashes.contains(x))
                .is_some()
            {
                new_cell_input = Some(
                    CellInput::new_builder()
                        .previous_output(next_pausable_data_outpoint.clone())
                        .build(),
                );
                new_cell_output = find_cell_by_out_point(next_pausable_data_outpoint.clone())?;
                new_cell_output = new_cell_output
                    .as_builder()
                    .capacity(Uint64::default())
                    .build();
                input_vec_builder = input_vec_builder.push(new_cell_input.should_be_ok());
                cell_output_vec_builder = cell_output_vec_builder.push(new_cell_output);
                let mut new_pausable_data = next_pausable_data.clone();
                new_pausable_data
                    .pause_list
                    .retain(|x| !lock_hashes.contains(x));
                output_data_vec_builder =
                    output_data_vec_builder.push(to_vec(&new_pausable_data, false)?.pack());
            }
            current_pausable_data = next_pausable_data;
        }

        let cell_outputs = cell_output_vec_builder.build();
        if cell_outputs.len() == 0 {
            return Err(Error::NothingToDo);
        }

        return Ok(tx_builder
            .raw(
                raw_tx_builder
                    .version(
                        tx.clone()
                            .map(|t| t.raw().version())
                            .unwrap_or_else(|| Uint32::default()),
                    )
                    .cell_deps(
                        tx.clone()
                            .map(|t| t.raw().cell_deps())
                            .unwrap_or_else(|| CellDepVec::default()),
                    )
                    .header_deps(
                        tx.clone()
                            .map(|t| t.raw().header_deps())
                            .unwrap_or_else(|| Byte32Vec::default()),
                    )
                    .inputs(input_vec_builder.build())
                    .outputs(cell_output_vec_builder.build())
                    .outputs_data(output_data_vec_builder.build())
                    .build(),
            )
            .witnesses(
                tx.clone()
                    .map(|t| t.witnesses())
                    .unwrap_or_else(|| BytesVec::default()),
            )
            .build());
    }

    // #[ssri_method(level = "script")]
    fn is_paused(lock_hashes: &Vec<[u8; 32]>) -> Result<Vec<bool>, Error> {
        debug!("Entered is_paused");
        debug!("lock_hashes: {:?}", lock_hashes);
        // By default all not paused
        let mut result = vec![false; lock_hashes.len()];

        let mut current_pausable_data = get_pausable_data()?;
        let mut seen_type_hashes: Vec<Byte32> = Vec::new();

        loop {
            // Check current pausable data's pause list
            for (idx, lock_hash) in lock_hashes.iter().enumerate() {
                if current_pausable_data.pause_list.contains(lock_hash) {
                    result[idx] = true;
                }
            }

            // Check for next type script in the chain
            match current_pausable_data.next_type_script {
                Some(next_type_script) => {
                    let next_type_script = Script::new_builder()
                        .code_hash(next_type_script.code_hash.pack())
                        .hash_type(Byte::new(next_type_script.hash_type))
                        .args(next_type_script.args.pack())
                        .build();

                    // Prevent infinite loops
                    if seen_type_hashes.contains(&next_type_script.calc_script_hash()) {
                        return Err(Error::CyclicPauseList);
                    }
                    seen_type_hashes.push(next_type_script.calc_script_hash());

                    // Load next pausable data
                    current_pausable_data = match should_fallback()? {
                        true => {
                            // Fallback logic to find next pausable data in cell deps
                            let mut index = 0;
                            loop {
                                match load_cell_type(index, Source::CellDep) {
                                    Ok(Some(next_pausable_cell_type_script))
                                        if next_pausable_cell_type_script == next_type_script =>
                                    {
                                        break from_slice(
                                            &load_cell_data(index, Source::CellDep)?,
                                            false,
                                        )?
                                    }
                                    Ok(Some(_)) | Ok(None) => index += 1,
                                    Err(_) => return Err(Error::IncompletePauseList),
                                }
                            }
                        }
                        false => {
                            // SSRI way to find next pausable data
                            let next_out_point = find_out_point_by_type(next_type_script)?;
                            from_slice(&find_cell_data_by_out_point(next_out_point)?, false)?
                        }
                    };
                }
                None => break, // No more pausable data cells
            }
        }

        Ok(result)
    }

    // #[ssri_method(level = "script")]
    fn enumerate_paused(mut offset: u64, limit: u64) -> Result<Byte32Vec, Error> {
        debug!("Entered enumerate_paused");
        let mut pausable_data_vec: Vec<UDTPausableData> = Vec::new();
        let mut current_pausable_data = get_pausable_data()?;
        let mut seen_type_hashes: Vec<Byte32> = Vec::new();
        let mut entries_counter = 0;

        // Handle initial data
        if current_pausable_data.pause_list.len() < offset as usize {
            offset -= current_pausable_data.pause_list.len() as u64;
        } else {
            let mut modified_data = current_pausable_data.clone();
            modified_data.pause_list = modified_data
                .pause_list
                .into_iter()
                .skip(offset as usize)
                .collect();
            if limit != 0 && modified_data.pause_list.len() as u64 > limit {
                modified_data.pause_list = modified_data
                    .pause_list
                    .into_iter()
                    .take(limit as usize)
                    .collect();
            }
            entries_counter += modified_data.pause_list.len() as u64;
            if entries_counter > 0 {
                pausable_data_vec.push(modified_data);
            }
            offset = 0;
            if limit != 0 && entries_counter >= limit {
                let mut paused_byte32_vec_builder = Byte32Vec::new_builder();
                for item in pausable_data_vec {
                    for paused_lock_hash in item.pause_list {
                        paused_byte32_vec_builder =
                            paused_byte32_vec_builder.push(paused_lock_hash.pack());
                    }
                }
                return Ok(paused_byte32_vec_builder.build());
            }
        }
        debug!("Handling chained data and offset: {}", offset);
        while let Some(ref next_type_script) = current_pausable_data.next_type_script {
            let script_like = next_type_script.clone();
            let next_type_script = Script::new_builder()
                .code_hash(script_like.code_hash.pack())
                .hash_type(Byte::new(script_like.hash_type))
                .args(script_like.args.pack())
                .build();
            let mut next_pausable_data: Option<UDTPausableData> = None;
            match should_fallback()? {
                true => {
                    let mut index = 0;
                    let mut should_continue = true;
                    while should_continue {
                        match load_cell_type(index, Source::CellDep) {
                            Ok(Some(next_pausable_cell_type_script)) => {
                                debug!(
                                    "Loaded cell type script: {:?}",
                                    next_pausable_cell_type_script
                                );
                                if next_pausable_cell_type_script == next_type_script {
                                    should_continue = false;
                                    next_pausable_data = Some(from_slice(
                                        &load_cell_data(index, Source::CellDep)?,
                                        false,
                                    )?);
                                } else {
                                    index += 1;
                                    debug!("Incrementing index: {}", index);
                                }
                            }
                            Ok(None) => {
                                index += 1;
                            }
                            Err(_) => {
                                should_continue = false;
                            }
                        }
                    }
                }
                false => {
                    debug!(
                        "Loading external pause list cell from SSRI Call: {:?}",
                        next_type_script
                    );
                    let next_out_point = find_out_point_by_type(next_type_script.clone())?;
                    debug!("Found out point: {:?}", next_out_point);
                    next_pausable_data = Some(from_slice(
                        &find_cell_data_by_out_point(next_out_point)?,
                        false,
                    )?);
                    debug!("Loaded next pausable data: {:?}", next_pausable_data);
                }
            };
            match next_pausable_data {
                Some(mut next_pausable_data) => {
                    debug!("Loaded next pausable data: {:?}", next_pausable_data);
                    if seen_type_hashes
                        .clone()
                        .into_iter()
                        .any(|x| x == next_type_script.calc_script_hash())
                    {
                        return Err(Error::CyclicPauseList)?;
                    } else {
                        debug!(
                            "Adding next type script to seen list: {:?}",
                            next_type_script
                        );
                        seen_type_hashes.push(next_type_script.calc_script_hash());
                    }

                    if next_pausable_data.pause_list.len() < offset as usize {
                        offset -= next_pausable_data.pause_list.len() as u64;
                        current_pausable_data = next_pausable_data;
                    } else {
                        next_pausable_data.pause_list = next_pausable_data
                            .pause_list
                            .into_iter()
                            .skip(offset as usize)
                            .collect();
                        pausable_data_vec.push(next_pausable_data.clone());
                        entries_counter += next_pausable_data.pause_list.len() as u64;
                        offset = 0;
                        if limit != 0 && entries_counter >= limit {
                            break;
                        }
                        current_pausable_data = next_pausable_data;
                    }
                }
                None => {
                    return Err(Error::IncompletePauseList)?;
                }
            }
        }

        debug!("Handling limit: {}", limit);
        if entries_counter > limit && limit != 0 {
            if let Some(last) = pausable_data_vec.last_mut() {
                last.pause_list = last
                    .pause_list
                    .clone()
                    .into_iter()
                    .take(last.pause_list.len() - (entries_counter - limit) as usize)
                    .collect();
            }
        }
        let mut paused_byte32_vec_builder = Byte32Vec::new_builder();
        for item in pausable_data_vec {
            for paused_lock_hash in item.pause_list {
                paused_byte32_vec_builder = paused_byte32_vec_builder.push(paused_lock_hash.pack());
            }
        }
        Ok(paused_byte32_vec_builder.build())
    }
}


================================================
File: contracts/pausable-udt/src/molecule.rs
================================================
// Generated by Molecule 0.8.0

use molecule :: prelude :: * ;
# [derive (Clone)] pub struct ScriptVec (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for ScriptVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for ScriptVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for ScriptVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl :: core :: default :: Default for ScriptVec { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; ScriptVec :: new_unchecked (v) } } impl ScriptVec { const DEFAULT_VALUE : [u8 ; 4] = [4 , 0 , 0 , 0 ,] ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < Script > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> Script { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { Script :: new_unchecked (self . 0 . slice (start ..)) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; Script :: new_unchecked (self . 0 . slice (start .. end)) } } pub fn as_reader < 'r > (& 'r self) -> ScriptVecReader < 'r > { ScriptVecReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for ScriptVec { type Builder = ScriptVecBuilder ; const NAME : & 'static str = "ScriptVec" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { ScriptVec (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ScriptVecReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ScriptVecReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct ScriptVecReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for ScriptVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for ScriptVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for ScriptVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl < 'r > ScriptVecReader < 'r > { pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < ScriptReader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> ScriptReader < 'r > { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { ScriptReader :: new_unchecked (& self . as_slice () [start ..]) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; ScriptReader :: new_unchecked (& self . as_slice () [start .. end]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for ScriptVecReader < 'r > { type Entity = ScriptVec ; const NAME : & 'static str = "ScriptVecReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { ScriptVecReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len == molecule :: NUMBER_SIZE { return Ok (()) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } for pair in offsets . windows (2) { let start = pair [0] ; let end = pair [1] ; ScriptReader :: verify (& slice [start .. end] , compatible) ? ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct ScriptVecBuilder (pub (crate) Vec < Script >) ; impl ScriptVecBuilder { pub fn set (mut self , v : Vec < Script >) -> Self { self . 0 = v ; self } pub fn push (mut self , v : Script) -> Self { self . 0 . push (v) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = Script >> (mut self , iter : T) -> Self { for elem in iter { self . 0 . push (elem) ; } self } pub fn replace (& mut self , index : usize , v : Script) -> Option < Script > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v)) } } impl molecule :: prelude :: Builder for ScriptVecBuilder { type Entity = ScriptVec ; const NAME : & 'static str = "ScriptVecBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (self . 0 . len () + 1) + self . 0 . iter () . map (| inner | inner . as_slice () . len ()) . sum :: < usize > () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let item_count = self . 0 . len () ; if item_count == 0 { writer . write_all (& molecule :: pack_number (molecule :: NUMBER_SIZE as molecule :: Number ,)) ? ; } else { let (total_size , offsets) = self . 0 . iter () . fold ((molecule :: NUMBER_SIZE * (item_count + 1) , Vec :: with_capacity (item_count) ,) , | (start , mut offsets) , inner | { offsets . push (start) ; (start + inner . as_slice () . len () , offsets) } ,) ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } for inner in self . 0 . iter () { writer . write_all (inner . as_slice ()) ? ; } } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; ScriptVec :: new_unchecked (inner . into ()) } }
pub struct ScriptVecIterator (ScriptVec , usize , usize) ; impl :: core :: iter :: Iterator for ScriptVecIterator { type Item = Script ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for ScriptVecIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for ScriptVec { type Item = Script ; type IntoIter = ScriptVecIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; ScriptVecIterator (self , 0 , len) } } impl < 'r > ScriptVecReader < 'r > { pub fn iter < 't > (& 't self) -> ScriptVecReaderIterator < 't , 'r > { ScriptVecReaderIterator (& self , 0 , self . len ()) } } pub struct ScriptVecReaderIterator < 't , 'r > (& 't ScriptVecReader < 'r > , usize , usize) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for ScriptVecReaderIterator < 't , 'r > { type Item = ScriptReader < 't > ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for ScriptVecReaderIterator < 't , 'r > { fn len (& self) -> usize { self . 2 - self . 1 } }
impl :: core :: iter :: FromIterator < Script > for ScriptVec { fn from_iter < T : IntoIterator < Item = Script >> (iter : T) -> Self { Self :: new_builder () . extend (iter) . build () } }
# [derive (Clone)] pub struct Script (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Script { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Script { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Script { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "code_hash" , self . code_hash ()) ? ; write ! (f , ", {}: {}" , "hash_type" , self . hash_type ()) ? ; write ! (f , ", {}: {}" , "args" , self . args ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for Script { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; Script :: new_unchecked (v) } } impl Script { const DEFAULT_VALUE : [u8 ; 53] = [53 , 0 , 0 , 0 , 16 , 0 , 0 , 0 , 48 , 0 , 0 , 0 , 49 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const FIELD_COUNT : usize = 3 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn code_hash (& self) -> Byte32 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Byte32 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn hash_type (& self) -> Byte { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; Byte :: new_unchecked (self . 0 . slice (start .. end)) } pub fn args (& self) -> Bytes { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [16 ..]) as usize ; Bytes :: new_unchecked (self . 0 . slice (start .. end)) } else { Bytes :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> ScriptReader < 'r > { ScriptReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Script { type Builder = ScriptBuilder ; const NAME : & 'static str = "Script" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Script (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ScriptReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ScriptReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . code_hash (self . code_hash ()) . hash_type (self . hash_type ()) . args (self . args ()) } }
# [derive (Clone , Copy)] pub struct ScriptReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for ScriptReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for ScriptReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for ScriptReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "code_hash" , self . code_hash ()) ? ; write ! (f , ", {}: {}" , "hash_type" , self . hash_type ()) ? ; write ! (f , ", {}: {}" , "args" , self . args ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > ScriptReader < 'r > { pub const FIELD_COUNT : usize = 3 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn code_hash (& self) -> Byte32Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Byte32Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn hash_type (& self) -> ByteReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; ByteReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn args (& self) -> BytesReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [16 ..]) as usize ; BytesReader :: new_unchecked (& self . as_slice () [start .. end]) } else { BytesReader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for ScriptReader < 'r > { type Entity = Script ; const NAME : & 'static str = "ScriptReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { ScriptReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } Byte32Reader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; ByteReader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; BytesReader :: verify (& slice [offsets [2] .. offsets [3]] , compatible) ? ; Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct ScriptBuilder { pub (crate) code_hash : Byte32 , pub (crate) hash_type : Byte , pub (crate) args : Bytes , } impl ScriptBuilder { pub const FIELD_COUNT : usize = 3 ; pub fn code_hash (mut self , v : Byte32) -> Self { self . code_hash = v ; self } pub fn hash_type (mut self , v : Byte) -> Self { self . hash_type = v ; self } pub fn args (mut self , v : Bytes) -> Self { self . args = v ; self } } impl molecule :: prelude :: Builder for ScriptBuilder { type Entity = Script ; const NAME : & 'static str = "ScriptBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . code_hash . as_slice () . len () + self . hash_type . as_slice () . len () + self . args . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . code_hash . as_slice () . len () ; offsets . push (total_size) ; total_size += self . hash_type . as_slice () . len () ; offsets . push (total_size) ; total_size += self . args . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . code_hash . as_slice ()) ? ; writer . write_all (self . hash_type . as_slice ()) ? ; writer . write_all (self . args . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Script :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct Bytes (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Bytes { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Bytes { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Bytes { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl :: core :: default :: Default for Bytes { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; Bytes :: new_unchecked (v) } } impl Bytes { const DEFAULT_VALUE : [u8 ; 4] = [0 , 0 , 0 , 0 ,] ; pub const ITEM_SIZE : usize = 1 ; pub fn total_size (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . item_count () } pub fn item_count (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < Byte > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> Byte { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; Byte :: new_unchecked (self . 0 . slice (start .. end)) } pub fn raw_data (& self) -> molecule :: bytes :: Bytes { self . 0 . slice (molecule :: NUMBER_SIZE ..) } pub fn as_reader < 'r > (& 'r self) -> BytesReader < 'r > { BytesReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Bytes { type Builder = BytesBuilder ; const NAME : & 'static str = "Bytes" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Bytes (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { BytesReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { BytesReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct BytesReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for BytesReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for BytesReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for BytesReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl < 'r > BytesReader < 'r > { pub const ITEM_SIZE : usize = 1 ; pub fn total_size (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . item_count () } pub fn item_count (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < ByteReader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> ByteReader < 'r > { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; ByteReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn raw_data (& self) -> & 'r [u8] { & self . as_slice () [molecule :: NUMBER_SIZE ..] } } impl < 'r > molecule :: prelude :: Reader < 'r > for BytesReader < 'r > { type Entity = Bytes ; const NAME : & 'static str = "BytesReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { BytesReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let item_count = molecule :: unpack_number (slice) as usize ; if item_count == 0 { if slice_len != molecule :: NUMBER_SIZE { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE , slice_len) ; } return Ok (()) ; } let total_size = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * item_count ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct BytesBuilder (pub (crate) Vec < Byte >) ; impl BytesBuilder { pub const ITEM_SIZE : usize = 1 ; pub fn set (mut self , v : Vec < Byte >) -> Self { self . 0 = v ; self } pub fn push (mut self , v : Byte) -> Self { self . 0 . push (v) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = Byte >> (mut self , iter : T) -> Self { for elem in iter { self . 0 . push (elem) ; } self } pub fn replace (& mut self , index : usize , v : Byte) -> Option < Byte > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v)) } } impl molecule :: prelude :: Builder for BytesBuilder { type Entity = Bytes ; const NAME : & 'static str = "BytesBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . 0 . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (& molecule :: pack_number (self . 0 . len () as molecule :: Number)) ? ; for inner in & self . 0 [..] { writer . write_all (inner . as_slice ()) ? ; } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Bytes :: new_unchecked (inner . into ()) } }
pub struct BytesIterator (Bytes , usize , usize) ; impl :: core :: iter :: Iterator for BytesIterator { type Item = Byte ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for BytesIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for Bytes { type Item = Byte ; type IntoIter = BytesIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; BytesIterator (self , 0 , len) } }
impl :: core :: iter :: FromIterator < Byte > for Bytes { fn from_iter < T : IntoIterator < Item = Byte >> (iter : T) -> Self { Self :: new_builder () . extend (iter) . build () } } impl :: core :: iter :: FromIterator < u8 > for Bytes { fn from_iter < T : IntoIterator < Item = u8 >> (iter : T) -> Self { Self :: new_builder () . extend (iter . into_iter () . map (Into :: into)) . build () } }
# [derive (Clone)] pub struct Byte32 (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Byte32 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Byte32 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Byte32 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl :: core :: default :: Default for Byte32 { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; Byte32 :: new_unchecked (v) } } impl Byte32 { const DEFAULT_VALUE : [u8 ; 32] = [0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const TOTAL_SIZE : usize = 32 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 32 ; pub fn nth0 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (0 .. 1)) } pub fn nth1 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (1 .. 2)) } pub fn nth2 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (2 .. 3)) } pub fn nth3 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (3 .. 4)) } pub fn nth4 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (4 .. 5)) } pub fn nth5 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (5 .. 6)) } pub fn nth6 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (6 .. 7)) } pub fn nth7 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (7 .. 8)) } pub fn nth8 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (8 .. 9)) } pub fn nth9 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (9 .. 10)) } pub fn nth10 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (10 .. 11)) } pub fn nth11 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (11 .. 12)) } pub fn nth12 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (12 .. 13)) } pub fn nth13 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (13 .. 14)) } pub fn nth14 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (14 .. 15)) } pub fn nth15 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (15 .. 16)) } pub fn nth16 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (16 .. 17)) } pub fn nth17 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (17 .. 18)) } pub fn nth18 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (18 .. 19)) } pub fn nth19 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (19 .. 20)) } pub fn nth20 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (20 .. 21)) } pub fn nth21 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (21 .. 22)) } pub fn nth22 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (22 .. 23)) } pub fn nth23 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (23 .. 24)) } pub fn nth24 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (24 .. 25)) } pub fn nth25 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (25 .. 26)) } pub fn nth26 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (26 .. 27)) } pub fn nth27 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (27 .. 28)) } pub fn nth28 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (28 .. 29)) } pub fn nth29 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (29 .. 30)) } pub fn nth30 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (30 .. 31)) } pub fn nth31 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (31 .. 32)) } pub fn raw_data (& self) -> molecule :: bytes :: Bytes { self . as_bytes () } pub fn as_reader < 'r > (& 'r self) -> Byte32Reader < 'r > { Byte32Reader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Byte32 { type Builder = Byte32Builder ; const NAME : & 'static str = "Byte32" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Byte32 (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Byte32Reader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Byte32Reader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . set ([self . nth0 () , self . nth1 () , self . nth2 () , self . nth3 () , self . nth4 () , self . nth5 () , self . nth6 () , self . nth7 () , self . nth8 () , self . nth9 () , self . nth10 () , self . nth11 () , self . nth12 () , self . nth13 () , self . nth14 () , self . nth15 () , self . nth16 () , self . nth17 () , self . nth18 () , self . nth19 () , self . nth20 () , self . nth21 () , self . nth22 () , self . nth23 () , self . nth24 () , self . nth25 () , self . nth26 () , self . nth27 () , self . nth28 () , self . nth29 () , self . nth30 () , self . nth31 () ,]) } }
# [derive (Clone , Copy)] pub struct Byte32Reader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for Byte32Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for Byte32Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for Byte32Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl < 'r > Byte32Reader < 'r > { pub const TOTAL_SIZE : usize = 32 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 32 ; pub fn nth0 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [0 .. 1]) } pub fn nth1 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [1 .. 2]) } pub fn nth2 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [2 .. 3]) } pub fn nth3 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [3 .. 4]) } pub fn nth4 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [4 .. 5]) } pub fn nth5 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [5 .. 6]) } pub fn nth6 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [6 .. 7]) } pub fn nth7 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [7 .. 8]) } pub fn nth8 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [8 .. 9]) } pub fn nth9 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [9 .. 10]) } pub fn nth10 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [10 .. 11]) } pub fn nth11 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [11 .. 12]) } pub fn nth12 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [12 .. 13]) } pub fn nth13 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [13 .. 14]) } pub fn nth14 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [14 .. 15]) } pub fn nth15 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [15 .. 16]) } pub fn nth16 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [16 .. 17]) } pub fn nth17 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [17 .. 18]) } pub fn nth18 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [18 .. 19]) } pub fn nth19 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [19 .. 20]) } pub fn nth20 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [20 .. 21]) } pub fn nth21 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [21 .. 22]) } pub fn nth22 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [22 .. 23]) } pub fn nth23 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [23 .. 24]) } pub fn nth24 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [24 .. 25]) } pub fn nth25 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [25 .. 26]) } pub fn nth26 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [26 .. 27]) } pub fn nth27 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [27 .. 28]) } pub fn nth28 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [28 .. 29]) } pub fn nth29 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [29 .. 30]) } pub fn nth30 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [30 .. 31]) } pub fn nth31 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [31 .. 32]) } pub fn raw_data (& self) -> & 'r [u8] { self . as_slice () } } impl < 'r > molecule :: prelude :: Reader < 'r > for Byte32Reader < 'r > { type Entity = Byte32 ; const NAME : & 'static str = "Byte32Reader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { Byte32Reader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len != Self :: TOTAL_SIZE { return ve ! (Self , TotalSizeNotMatch , Self :: TOTAL_SIZE , slice_len) ; } Ok (()) } }
# [derive (Clone)] pub struct Byte32Builder (pub (crate) [Byte ; 32]) ; impl :: core :: fmt :: Debug for Byte32Builder { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:?})" , Self :: NAME , & self . 0 [..]) } } impl :: core :: default :: Default for Byte32Builder { fn default () -> Self { Byte32Builder ([Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () ,]) } } impl Byte32Builder { pub const TOTAL_SIZE : usize = 32 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 32 ; pub fn set (mut self , v : [Byte ; 32]) -> Self { self . 0 = v ; self } pub fn nth0 (mut self , v : Byte) -> Self { self . 0 [0] = v ; self } pub fn nth1 (mut self , v : Byte) -> Self { self . 0 [1] = v ; self } pub fn nth2 (mut self , v : Byte) -> Self { self . 0 [2] = v ; self } pub fn nth3 (mut self , v : Byte) -> Self { self . 0 [3] = v ; self } pub fn nth4 (mut self , v : Byte) -> Self { self . 0 [4] = v ; self } pub fn nth5 (mut self , v : Byte) -> Self { self . 0 [5] = v ; self } pub fn nth6 (mut self , v : Byte) -> Self { self . 0 [6] = v ; self } pub fn nth7 (mut self , v : Byte) -> Self { self . 0 [7] = v ; self } pub fn nth8 (mut self , v : Byte) -> Self { self . 0 [8] = v ; self } pub fn nth9 (mut self , v : Byte) -> Self { self . 0 [9] = v ; self } pub fn nth10 (mut self , v : Byte) -> Self { self . 0 [10] = v ; self } pub fn nth11 (mut self , v : Byte) -> Self { self . 0 [11] = v ; self } pub fn nth12 (mut self , v : Byte) -> Self { self . 0 [12] = v ; self } pub fn nth13 (mut self , v : Byte) -> Self { self . 0 [13] = v ; self } pub fn nth14 (mut self , v : Byte) -> Self { self . 0 [14] = v ; self } pub fn nth15 (mut self , v : Byte) -> Self { self . 0 [15] = v ; self } pub fn nth16 (mut self , v : Byte) -> Self { self . 0 [16] = v ; self } pub fn nth17 (mut self , v : Byte) -> Self { self . 0 [17] = v ; self } pub fn nth18 (mut self , v : Byte) -> Self { self . 0 [18] = v ; self } pub fn nth19 (mut self , v : Byte) -> Self { self . 0 [19] = v ; self } pub fn nth20 (mut self , v : Byte) -> Self { self . 0 [20] = v ; self } pub fn nth21 (mut self , v : Byte) -> Self { self . 0 [21] = v ; self } pub fn nth22 (mut self , v : Byte) -> Self { self . 0 [22] = v ; self } pub fn nth23 (mut self , v : Byte) -> Self { self . 0 [23] = v ; self } pub fn nth24 (mut self , v : Byte) -> Self { self . 0 [24] = v ; self } pub fn nth25 (mut self , v : Byte) -> Self { self . 0 [25] = v ; self } pub fn nth26 (mut self , v : Byte) -> Self { self . 0 [26] = v ; self } pub fn nth27 (mut self , v : Byte) -> Self { self . 0 [27] = v ; self } pub fn nth28 (mut self , v : Byte) -> Self { self . 0 [28] = v ; self } pub fn nth29 (mut self , v : Byte) -> Self { self . 0 [29] = v ; self } pub fn nth30 (mut self , v : Byte) -> Self { self . 0 [30] = v ; self } pub fn nth31 (mut self , v : Byte) -> Self { self . 0 [31] = v ; self } } impl molecule :: prelude :: Builder for Byte32Builder { type Entity = Byte32 ; const NAME : & 'static str = "Byte32Builder" ; fn expected_length (& self) -> usize { Self :: TOTAL_SIZE } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (self . 0 [0] . as_slice ()) ? ; writer . write_all (self . 0 [1] . as_slice ()) ? ; writer . write_all (self . 0 [2] . as_slice ()) ? ; writer . write_all (self . 0 [3] . as_slice ()) ? ; writer . write_all (self . 0 [4] . as_slice ()) ? ; writer . write_all (self . 0 [5] . as_slice ()) ? ; writer . write_all (self . 0 [6] . as_slice ()) ? ; writer . write_all (self . 0 [7] . as_slice ()) ? ; writer . write_all (self . 0 [8] . as_slice ()) ? ; writer . write_all (self . 0 [9] . as_slice ()) ? ; writer . write_all (self . 0 [10] . as_slice ()) ? ; writer . write_all (self . 0 [11] . as_slice ()) ? ; writer . write_all (self . 0 [12] . as_slice ()) ? ; writer . write_all (self . 0 [13] . as_slice ()) ? ; writer . write_all (self . 0 [14] . as_slice ()) ? ; writer . write_all (self . 0 [15] . as_slice ()) ? ; writer . write_all (self . 0 [16] . as_slice ()) ? ; writer . write_all (self . 0 [17] . as_slice ()) ? ; writer . write_all (self . 0 [18] . as_slice ()) ? ; writer . write_all (self . 0 [19] . as_slice ()) ? ; writer . write_all (self . 0 [20] . as_slice ()) ? ; writer . write_all (self . 0 [21] . as_slice ()) ? ; writer . write_all (self . 0 [22] . as_slice ()) ? ; writer . write_all (self . 0 [23] . as_slice ()) ? ; writer . write_all (self . 0 [24] . as_slice ()) ? ; writer . write_all (self . 0 [25] . as_slice ()) ? ; writer . write_all (self . 0 [26] . as_slice ()) ? ; writer . write_all (self . 0 [27] . as_slice ()) ? ; writer . write_all (self . 0 [28] . as_slice ()) ? ; writer . write_all (self . 0 [29] . as_slice ()) ? ; writer . write_all (self . 0 [30] . as_slice ()) ? ; writer . write_all (self . 0 [31] . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Byte32 :: new_unchecked (inner . into ()) } }
impl From < [Byte ; 32usize] > for Byte32 { fn from (value : [Byte ; 32usize]) -> Self { Self :: new_builder () . set (value) . build () } } impl :: core :: convert :: TryFrom < & [Byte] > for Byte32 { type Error = :: core :: array :: TryFromSliceError ; fn try_from (value : & [Byte]) -> Result < Self , :: core :: array :: TryFromSliceError > { Ok (Self :: new_builder () . set (< & [Byte ; 32usize] > :: try_from (value) ? . clone ()) . build ()) } } impl From < Byte32 > for [Byte ; 32usize] { # [track_caller] fn from (value : Byte32) -> Self { [value . nth0 () , value . nth1 () , value . nth2 () , value . nth3 () , value . nth4 () , value . nth5 () , value . nth6 () , value . nth7 () , value . nth8 () , value . nth9 () , value . nth10 () , value . nth11 () , value . nth12 () , value . nth13 () , value . nth14 () , value . nth15 () , value . nth16 () , value . nth17 () , value . nth18 () , value . nth19 () , value . nth20 () , value . nth21 () , value . nth22 () , value . nth23 () , value . nth24 () , value . nth25 () , value . nth26 () , value . nth27 () , value . nth28 () , value . nth29 () , value . nth30 () , value . nth31 () ,] } } impl From < [u8 ; 32usize] > for Byte32 { fn from (value : [u8 ; 32usize]) -> Self { Byte32Reader :: new_unchecked (& value) . to_entity () } } impl :: core :: convert :: TryFrom < & [u8] > for Byte32 { type Error = :: core :: array :: TryFromSliceError ; fn try_from (value : & [u8]) -> Result < Self , :: core :: array :: TryFromSliceError > { Ok (< [u8 ; 32usize] > :: try_from (value) ? . into ()) } } impl From < Byte32 > for [u8 ; 32usize] { # [track_caller] fn from (value : Byte32) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } } impl < 'a > From < Byte32Reader < 'a >> for & 'a [u8 ; 32usize] { # [track_caller] fn from (value : Byte32Reader < 'a >) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } } impl < 'a > From < & 'a Byte32Reader < 'a >> for & 'a [u8 ; 32usize] { # [track_caller] fn from (value : & 'a Byte32Reader < 'a >) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } }


================================================
File: contracts/pausable-udt/src/utils.rs
================================================
use crate::error::Error;
use alloc::{ffi::CString, vec::Vec};
use ckb_ssri_std::public_module_traits::udt::UDT_LEN;
use ckb_std::{
    ckb_constants::Source,
    ckb_types::bytes::Bytes,
    debug,
    high_level::{decode_hex, load_cell_data, load_cell_lock_hash, QueryIter},
};

pub fn collect_inputs_amount() -> Result<u128, Error> {
    debug!("Entered collect_inputs_amount");
    let mut buf = [0u8; UDT_LEN];

    let udt_list = QueryIter::new(load_cell_data, Source::GroupInput)
        .map(|data| {
            if data.len() == UDT_LEN {
                buf.copy_from_slice(&data);
                Ok(u128::from_le_bytes(buf))
            } else {
                Err(Error::Encoding)
            }
        })
        .collect::<Result<Vec<_>, Error>>()?;
    Ok(udt_list.into_iter().sum::<u128>())
}

pub fn collect_outputs_amount() -> Result<u128, Error> {
    debug!("Entered collect_outputs_amount");
    let mut buf = [0u8; UDT_LEN];

    let udt_list = QueryIter::new(load_cell_data, Source::GroupOutput)
        .map(|data| {
            if data.len() == UDT_LEN {
                buf.copy_from_slice(&data);
                // u128 is 16 bytes
                Ok(u128::from_le_bytes(buf))
            } else {
                Err(Error::Encoding)
            }
        })
        .collect::<Result<Vec<_>, Error>>()?;
    Ok(udt_list.into_iter().sum::<u128>())
}

pub fn check_owner_mode(args: &Bytes) -> Result<bool, Error> {
    debug!("Entered check_owner_mode");
    let is_owner_mode = QueryIter::new(load_cell_lock_hash, Source::Input)
        .find(|lock_hash| args[..] == lock_hash[..])
        .is_some();
    debug!("Owner mode: {}", is_owner_mode);
    Ok(is_owner_mode)
}

pub fn format_pause_list(pause_list_str_vec: Vec<&str>) -> Vec<[u8; 32]> {
    let mut formatted_pause_u8_32_vec: Vec<[u8; 32]> = Vec::new();
    pause_list_str_vec.iter().for_each(|lock_hash_hex| {
        formatted_pause_u8_32_vec.push(
            decode_hex(CString::new(&lock_hash_hex[2..]).unwrap().as_c_str())
                .unwrap()
                .try_into()
                .unwrap(),
        );
    });
    formatted_pause_u8_32_vec
}



================================================
File: contracts/pausable-udt/tests/Cargo.toml
================================================
[package]
name = "tests"
version = "0.1.0"
edition = "2021"

[dependencies]
ckb-testtool = "0.14.0"
serde_json = "1.0"
reqwest = { version = "0.11", features = ["json"] }
tokio = { version = "1", features = ["macros"] }  # Required for async tests
ckb-hash = "0.116.1"
ckb-std = { version = "0.16.4", features = [] }
ckb_ssri_sdk = { path = "../ckb_ssri_sdk" }
serde_molecule = { version = "1.1.0", default-features = false, features = ["alloc"] }

================================================
File: contracts/pausable-udt/tests/src/lib.rs
================================================
use ckb_testtool::{
    ckb_error::Error,
    ckb_types::{
        bytes::Bytes,
        core::{Cycle, TransactionView},
    },
    context::Context,
};
use std::env;
use std::fs;
use std::path::PathBuf;
use std::str::FromStr;

#[cfg(test)]
mod ssri;
mod utils;
mod tests;
mod tool;

// The exact same Loader code from capsule's template, except that
// now we use MODE as the environment variable
const TEST_ENV_VAR: &str = "MODE";

pub enum TestEnv {
    Debug,
    Release,
}

impl FromStr for TestEnv {
    type Err = &'static str;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "debug" => Ok(TestEnv::Debug),
            "release" => Ok(TestEnv::Release),
            _ => Err("no match"),
        }
    }
}

pub struct Loader(PathBuf);

impl Default for Loader {
    fn default() -> Self {
        let test_env = match env::var(TEST_ENV_VAR) {
            Ok(val) => val.parse().expect("test env"),
            Err(_) => TestEnv::Release,
        };
        Self::with_test_env(test_env)
    }
}

impl Loader {
    fn with_test_env(env: TestEnv) -> Self {
        let load_prefix = match env {
            TestEnv::Debug => "debug",
            TestEnv::Release => "release",
        };
        let mut base_path = match env::var("TOP") {
            Ok(val) => {
                let mut base_path: PathBuf = val.into();
                base_path.push("build");
                base_path
            }
            Err(_) => {
                let mut base_path = PathBuf::new();
                // cargo may use a different cwd when running tests, for example:
                // when running debug in vscode, it will use workspace root as cwd by default,
                // when running test by `cargo test`, it will use tests directory as cwd,
                // so we need a fallback path
                base_path.push("build");
                if !base_path.exists() {
                    base_path.pop();
                    base_path.push("..");
                    base_path.push("build");
                }
                base_path
            }
        };

        base_path.push(load_prefix);
        Loader(base_path)
    }

    pub fn load_binary(&self, name: &str) -> Bytes {
        let mut path = self.0.clone();
        path.push(name);
        let result = fs::read(&path);
        if result.is_err() {
            panic!("Binary {:?} is missing!", path);
        }
        result.unwrap().into()
    }
}

// This helper method runs Context::verify_tx, but in case error happens,
// it also dumps current transaction to failed_txs folder.
pub fn verify_and_dump_failed_tx(
    context: &Context,
    tx: &TransactionView,
    max_cycles: u64,
) -> Result<Cycle, Error> {
    let result = context.verify_tx(tx, max_cycles);
    if result.is_err() {
        let mut path = env::current_dir().expect("current dir");
        path.push("failed_txs");
        std::fs::create_dir_all(&path).expect("create failed_txs dir");
        let mock_tx = context.dump_tx(tx).expect("dump failed tx");
        let json = serde_json::to_string_pretty(&mock_tx).expect("json");
        path.push(format!("0x{:x}.json", tx.hash()));
        println!("Failed tx written to {:?}", path);
        std::fs::write(path, json).expect("write");
    }
    result
}


================================================
File: contracts/pausable-udt/tests/src/ssri.rs
================================================
// NOTE: These tests currently depends on a running SSRI-server. See https://github.com/ckb-devrel/ssri-server
// NOTE: Due to the limitations of ckb_testtools at the moment (i.e. not able to obtain stable lock hashes), we will test paused sender/receiver transfer in ckb_ssri_cli

use std::ffi::CString;

use ckb_std::high_level::{decode_hex, encode_hex};
use reqwest::Client;
use serde_json::json;

use crate::utils::{get_ssri_response, method_path, method_path_hex};
use ckb_ssri_std::prelude::{decode_u64_vector, encode_u8_32_vector};

#[test]
fn test_method_path() {
    let name = "SSRI.version";
    let method_path = method_path(name);
    println!("Method path: {:?}", method_path);
    let method_path_hex = method_path_hex(name);
    println!("Method path hex: {:?}", method_path_hex);
}

#[tokio::test]
async fn test_get_methods() {
    let url = "http://localhost:9090";

    let get_methods_path_hex = method_path_hex("SSRI.get_methods");
    println!("Get methods path: {}", get_methods_path_hex);
    // Define the JSON payload
    let payload = json!({
        "id": 2,
        "jsonrpc": "2.0",
        "method": "run_script_level_code",
        "params": [
            // TODO: Get outpoint from deployment record
            "0xb99f540caf4b03d152aa27626fbe62bf5559a9166a9ed1984b2d4fcbf063f964",
            0,
            [get_methods_path_hex, "0x0000000000000000", "0x0a00000000000000"]
        ]
    });

    // Create an HTTP client and send the request
    let client = Client::new();
    let response = client
        .post(url)
        .header("Content-Type", "application/json")
        .json(&payload)
        .send()
        .await
        .expect("Request failed");

    assert!(
        response.status().is_success(),
        "Response was not successful"
    );

    let response_json: serde_json::Value = response.json().await.expect("Failed to parse JSON");
    println!("Response JSON: {:?}", response_json);

    let result_string = String::from(response_json["result"].as_str().unwrap())[2..].to_string();
    println!("Result string: {:?}", result_string);

    let result_in_c_string = CString::new(result_string).unwrap();
    let decoded_result = decode_hex(result_in_c_string.as_c_str()).unwrap();
    println!("Decoded result: {:?}", decoded_result);
    println!("Decoded result length: {:?}", decoded_result.len());
    // NOTE: The decoded result is a vector of u64 values as the implementation of SSRI.get_methods has already trimmed the first 4 u8;
    let method_u64_vector = decode_u64_vector(&decoded_result).unwrap();
    println!("Decoded result: {:?}", method_u64_vector);
}

#[tokio::test]
async fn test_version() {
    let url = "http://localhost:9090";

    let version_path_hex = method_path_hex("SSRI.version");
    println!("Version path: {:?}", version_path_hex);

    let payload = json!({
        "id": 2,
        "jsonrpc": "2.0",
        "method": "run_script_level_code",
        "params": [
            "0xb99f540caf4b03d152aa27626fbe62bf5559a9166a9ed1984b2d4fcbf063f964",
            0,
            [version_path_hex]
        ]
    });

    // Create an HTTP client and send the request
    let client = Client::new();
    let response = client
        .post(url)
        .header("Content-Type", "application/json")
        .json(&payload)
        .send()
        .await
        .expect("Request failed");

    assert!(
        response.status().is_success(),
        "Response was not successful"
    );

    let response_json: serde_json::Value = response.json().await.expect("Failed to parse JSON");
    println!("Response JSON: {:?}", response_json);
}

#[tokio::test]
pub async fn test_is_paused() {
    // Note: This is the lock hash of ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsqgtlcnzzna2tqst7jw78egjpujn7hdxpackjmmdp
    let test_lock_hash_hex = "0xd19228c64920eb8c3d79557d8ae59ee7a14b9d7de45ccf8bafacf82c91fc359e";
    let test_lock_hash_u8_32: [u8; 32] =
        decode_hex(CString::new(&test_lock_hash_hex[2..]).unwrap().as_c_str())
            .unwrap()
            .try_into()
            .unwrap();
    let test_lock_hash_array_vector = encode_u8_32_vector(vec![test_lock_hash_u8_32]);
    let test_lock_hash_array_encoded_hex = format!(
        "0x{}",
        encode_hex(&test_lock_hash_array_vector)
            .into_string()
            .unwrap()
    );
    println!("Test lock hash: {:?}", test_lock_hash_u8_32);
    println!("Test lock hash encoded: {:?}", test_lock_hash_array_vector);
    println!(
        "Test lock hash encoded hex: {:?}",
        test_lock_hash_array_encoded_hex
    );

    let is_paused_path_hex = method_path_hex("UDT.is_paused");
    println!("is_paused path hex: {:?}", is_paused_path_hex);

    // Define the JSON payload
    let payload = json!({
        "id": 2,
        "jsonrpc": "2.0",
        "method": "run_script_level_code",
        "params": [
            "0xb99f540caf4b03d152aa27626fbe62bf5559a9166a9ed1984b2d4fcbf063f964",
            0,
            [is_paused_path_hex, test_lock_hash_array_encoded_hex]
        ]
    });

    let response_json: serde_json::Value = get_ssri_response(payload).await;
    println!("Response JSON: {:?}", response_json);
}

#[tokio::test]
pub async fn test_enumerate_paused() {
    let enumerate_paused_path_hex = method_path_hex("UDT.enumerate_paused");
    println!("enumerate_paused path hex: {:?}", enumerate_paused_path_hex);

    let payload = json!({
        "id": 2,
        "jsonrpc": "2.0",
        "method": "run_script_level_code",
        "params": [
            "0xb99f540caf4b03d152aa27626fbe62bf5559a9166a9ed1984b2d4fcbf063f964",
            0,
            [enumerate_paused_path_hex]
        ]
    });

    let response_json: serde_json::Value = get_ssri_response(payload).await;
    println!("Response JSON: {:?}", response_json);
}


================================================
File: contracts/pausable-udt/tests/src/tests.rs
================================================
use ckb_std::ckb_types::prelude::Entity;
use ckb_std::{
    ckb_types::{bytes::Bytes, packed::*, prelude::*},
    high_level::encode_hex,
};
use ckb_testtool::{
    builtin::ALWAYS_SUCCESS,
    ckb_types::{core::TransactionBuilder, packed::*, prelude::*},
    context::Context,
};

use crate::utils::build_test_context;

#[test]
pub fn test_transfer() {
    let mut test_context = build_test_context();

    let wallet_amount: Uint128 = 20000000000u128.pack();
    let transfer_amount: Uint128 = 10000000000u128.pack();
    let change_amount: Uint128 = (20000000000u128 - 10000000000u128).pack();

    let normal_udt_input_outpoint = test_context.context.create_cell(
        CellOutput::new_builder()
            .capacity(100u64.pack())
            .lock(test_context.normal_user_a_lock_script.clone())
            .type_(Some(test_context.pausable_udt_type_script.clone()).pack())
            .build(),
        wallet_amount.as_bytes(),
    );

    let paused_udt_input_outpoint = test_context.context.create_cell(
        CellOutput::new_builder()
            .capacity(100u64.pack())
            .lock(test_context.paused_user_lock_script.clone())
            .type_(Some(test_context.pausable_udt_type_script.clone()).pack())
            .build(),
        wallet_amount.as_bytes(),
    );

    let normal_inputs = vec![CellInput::new_builder()
        .previous_output(normal_udt_input_outpoint.clone())
        .build()];

    // let paused_inputs = vec![CellInput::new_builder()
    //     .previous_output(paused_udt_input_outpoint.clone())
    //     .build()];

    let normal_udt_output = CellOutput::new_builder()
        .capacity(100u64.pack())
        .lock(test_context.normal_user_b_lock_script.clone())
        .type_(Some(test_context.pausable_udt_type_script.clone()).pack())
        .build();

    let paused_udt_output = CellOutput::new_builder()
        .capacity(100u64.pack())
        .lock(test_context.paused_user_lock_script.clone())
        .type_(Some(test_context.pausable_udt_type_script.clone()).pack())
        .build();

    let normal_udt_change_output = CellOutput::new_builder()
        .capacity(100u64.pack())
        .lock(test_context.normal_user_a_lock_script.clone())
        .type_(Some(test_context.pausable_udt_type_script.clone()).pack())
        .build();

    let paused_udt_change_output = CellOutput::new_builder()
        .capacity(100u64.pack())
        .lock(test_context.paused_user_lock_script.clone())
        .type_(Some(test_context.pausable_udt_type_script.clone()).pack())
        .build();

    let normal_outputs = vec![normal_udt_output.clone(), normal_udt_change_output.clone()];

    // let paused_sender_outputs = vec![normal_udt_output.clone(), paused_udt_change_output.clone()];

    // let paused_receiver_outputs = vec![paused_udt_output.clone(), normal_udt_change_output.clone()];

    let outputs_data = vec![transfer_amount.raw_data(), change_amount.raw_data()];

    let normal_transfer_tx = TransactionBuilder::default()
        .inputs(normal_inputs.clone())
        .outputs(normal_outputs.clone())
        .outputs_data(outputs_data.clone().pack())
        .cell_deps(vec![test_context.pausable_udt_dep.clone(), test_context.always_success_dep.clone()])
        .build();

    let normal_transfer_tx = normal_transfer_tx.as_advanced_builder().build();

    let normal_cycles = test_context
        .context
        .verify_tx(&normal_transfer_tx, u64::MAX)
        .expect("Normal Tx Failed");
    println!("Normal Tx cycles: {}", normal_cycles);

    // NOTE: Due to limitations of ckb_testtools at the moment (i.e. not able to obtain stable lock hashes), we will test paused sender/receiver transfer in ckb_ssri_cli
    // let paused_sender_transfer_tx = TransactionBuilder::default()
    //     .inputs(paused_inputs.clone())
    //     .outputs(paused_sender_outputs.clone())
    //     .outputs_data(outputs_data.clone().pack())
    //     .cell_deps(vec![test_context.pausable_udt_dep.clone()])
    //     .build();

    // let paused_sender_transfer_tx = paused_sender_transfer_tx.as_advanced_builder().build();

    // let paused_sender_transfer_err = test_context
    //     .context
    //     .verify_tx(&paused_sender_transfer_tx, u64::MAX)
    //     .unwrap_err();
    // println!(
    //     "Expected Paused Sender Tx Error: {:?}",
    //     paused_sender_transfer_err
    // );

    // let paused_receiver_transfer_tx = TransactionBuilder::default()
    //     .inputs(paused_inputs.clone())
    //     .outputs(paused_receiver_outputs.clone())
    //     .outputs_data(outputs_data.clone().pack())
    //     .cell_deps(vec![test_context.pausable_udt_dep.clone()])
    //     .build();

    // let paused_receiver_transfer_tx = paused_receiver_transfer_tx.as_advanced_builder().build();

    // let paused_receiver_err = test_context
    //     .context
    //     .verify_tx(&paused_receiver_transfer_tx, u64::MAX)
    //     .unwrap_err();

    // println!(
    //     "Expected Paused Receiver Tx Error: {:?}",
    //     paused_receiver_err
    // );
}

#[test]
pub fn test_mint() {
    println!("Entered test_mint");
    let mut test_context = build_test_context();

    let mint_amount: Uint128 = 20000000000u128.pack();

    let admin_out_point = test_context.context.create_cell(
        CellOutput::new_builder()
            .capacity(10000u64.pack())
            .lock(test_context.admin_lock_script.clone())
            .build(),
        Bytes::default(),
    );

    let admin_inputs = vec![CellInput::new_builder()
        .previous_output(admin_out_point.clone())
        .build()];

    let normal_udt_output = CellOutput::new_builder()
        .capacity(100u64.pack())
        .lock(test_context.normal_user_b_lock_script.clone())
        .type_(Some(test_context.pausable_udt_type_script.clone()).pack())
        .build();

    let outputs_data = vec![mint_amount.raw_data()];

    let normal_mint_tx = TransactionBuilder::default()
        .inputs(admin_inputs.clone())
        .output(normal_udt_output.clone())
        .outputs_data(outputs_data.clone().pack())
        .cell_deps(vec![test_context.pausable_udt_dep.clone(), test_context.always_success_dep.clone()])
        .build();

    let normal_mint_tx = normal_mint_tx.as_advanced_builder().build();

    let normal_cycles = test_context
        .context
        .verify_tx(&normal_mint_tx, u64::MAX)
        .expect("Normal Mint Tx Failed");
    println!("Normal Mint Tx cycles: {}", normal_cycles);

    let user_a_out_point = test_context.context.create_cell(
        CellOutput::new_builder()
            .capacity(100u64.pack())
            .lock(test_context.normal_user_a_lock_script.clone())
            .build(),
        mint_amount.as_bytes(),
    );

    let user_a_inputs = vec![CellInput::new_builder()
        .previous_output(user_a_out_point.clone())
        .build()];
    let unauthorized_mint_tx = TransactionBuilder::default()
        .inputs(user_a_inputs.clone())
        .output(normal_udt_output.clone())
        .outputs_data(outputs_data.clone().pack())
        .cell_deps(vec![test_context.pausable_udt_dep.clone(), test_context.always_success_dep.clone()])
        .build();

    let unauthorized_mint_tx = unauthorized_mint_tx.as_advanced_builder().build();

    let unauthorized_mint_err = test_context
        .context
        .verify_tx(&unauthorized_mint_tx, u64::MAX)
        .unwrap_err();

    println!(
        "Expected Unauthorized Mint Tx Error: {:?}",
        unauthorized_mint_err
    );
}


================================================
File: contracts/pausable-udt/tests/src/tool.rs
================================================
use std::ffi::CStr;
use std::ffi::CString;

use ckb_ssri_std::public_module_traits::udt::UDTPausableData;
use ckb_std::ckb_types::packed::Bytes as PackedBytes;
use ckb_std::ckb_types::packed::BytesBuilder as PackedBytesBuilder;
use ckb_std::ckb_types::packed::BytesVec;
use ckb_std::ckb_types::packed::BytesVecBuilder;
use ckb_std::ckb_types::packed::Script;
use ckb_std::ckb_types::packed::ScriptOpt;
use ckb_std::ckb_types::packed::ScriptOptBuilder;
use ckb_std::ckb_types::packed::Uint64;
use ckb_std::{
    ckb_types::packed::{CellOutputBuilder, Uint128},
    high_level::{decode_hex, encode_hex},
};
use ckb_testtool::ckb_types::prelude::{Builder, Entity, Pack, Unpack};
use serde_molecule::to_vec;

// #[test]
// fn decode_hex_tool() {
//     let hex = "";
//     let bytes = decode_hex(hex);
//     println!("Decoded Bytes: {:?}", bytes);
// }

// #[test]
// fn encode_hex_tool() {
//     let data = "";
//     let hex = encode_hex(data.as_bytes());
//     println!("Encoded Hex: {:?}", hex);
// }

#[test]
fn generic_test() {
    let cstring = CString::new("0x0000").unwrap();
    let cstr = cstring.as_c_str();
    println!("CStr: {:?}", cstr);
    let decoded_hex = decode_hex(&cstr[2..]).unwrap();
        
    println!("Decoded Hex: {:?}", decoded_hex);
    // let offset = u64::from_le_bytes(decode_hex(CString::new("0x000000").unwrap().as_c_str()).unwrap().try_into().unwrap_or_default());
    // println!("Offset: {:?}", offset);
    return;
}


================================================
File: contracts/pausable-udt/tests/src/utils.rs
================================================
use ckb_hash::blake2b_256;
use ckb_std::{
    ckb_types::{bytes::Bytes, packed::*, prelude::*},
    high_level::encode_hex,
};
use ckb_testtool::{builtin::ALWAYS_SUCCESS, context::Context};
use reqwest::Client;

use crate::Loader;

pub fn method_path(name: impl AsRef<[u8]>) -> u64 {
    u64::from_le_bytes(blake2b_256(name)[0..8].try_into().unwrap())
}

pub fn method_path_hex(name: impl AsRef<[u8]>) -> String {
    let method_path = method_path(name);
    let method_path_in_bytes = method_path.to_le_bytes();
    let method_path_hex = format!(
        "0x{:?}",
        encode_hex(&method_path_in_bytes).into_string().unwrap()
    )
    .replace("\"", "");
    method_path_hex
}

pub async fn get_ssri_response(payload: serde_json::Value) -> serde_json::Value {
    let url = "http://localhost:9090";

    let client = Client::new();
    let response = client
        .post(url)
        .header("Content-Type", "application/json")
        .json(&payload)
        .send()
        .await
        .expect("Request failed");

    // Assert that the request was successful (status 200)
    assert!(
        response.status().is_success(),
        "Response was not successful"
    );

    let response_json: serde_json::Value = response.json().await.expect("Failed to parse JSON");
    response_json
}

pub struct PausableUDTTestContext {
    pub context: Context,
    pub pausable_udt_out_point: OutPoint,
    pub always_success_dep: CellDep,
    pub pausable_udt_dep: CellDep,
    pub pausable_udt_type_script: Script,
    pub admin_lock_script: Script,
    pub normal_user_a_lock_script: Script,
    pub normal_user_b_lock_script: Script,
    pub paused_user_lock_script: Script,
}

pub fn build_test_context() -> PausableUDTTestContext {
    let admin_args = String::from("00018fd14cc327648651dc0ac81ec6dd63a9ab376e61");
    let normal_user_a_args = String::from("00018fd14cc327648651dc0ac81ec6dd63a9ab376e62");
    let normal_user_b_args = String::from("00018fd14cc327648651dc0ac81ec6dd63a9ab376e63");
    let paused_user_args = String::from("00018fd14cc327648651dc0ac81ec6dd63a9ab376e64");

    let mut context = Context::default();
    let loader = Loader::default();
    let pausable_udt_bin = loader.load_binary("pausable-udt");
    let pausable_udt_out_point = context.deploy_cell(pausable_udt_bin);
    let pausable_udt_dep = CellDep::new_builder()
        .out_point(pausable_udt_out_point.clone())
        .build();
    let always_success_out_point = context.deploy_cell(ALWAYS_SUCCESS.clone());
    let always_success_dep = CellDep::new_builder()
        .out_point(always_success_out_point.clone())
        .build();
    let always_success_script = context
        .build_script(&always_success_out_point, Bytes::default())
        .expect("script");

    let admin_lock_script = context
        .build_script(&&always_success_out_point.clone(), Bytes::from(admin_args))
        .expect("script");
    let normal_user_a_lock_script = context
        .build_script(&always_success_out_point.clone(), Bytes::from(normal_user_a_args))
        .expect("script");
    let normal_user_b_lock_script = context
        .build_script(&always_success_out_point.clone(), Bytes::from(normal_user_b_args))
        .expect("script");
    let paused_user_lock_script = context
        .build_script(&always_success_out_point.clone(), Bytes::from(paused_user_args))
        .expect("script");

    let pausable_udt_type_script = context
        .build_script(
            &pausable_udt_out_point,
            admin_lock_script.calc_script_hash().as_bytes(),
        )
        .expect("script");

    let paused_user_lock_script_hash_byte32 = paused_user_lock_script.calc_script_hash();
    let paused_user_lock_script_hash_hex =
        encode_hex(paused_user_lock_script_hash_byte32.as_slice());

    println!(
        "paused_user_lock_script_hash_hex: {}",
        paused_user_lock_script_hash_hex.into_string().unwrap()
    );

    PausableUDTTestContext {
        context,
        pausable_udt_out_point,
        always_success_dep,
        pausable_udt_dep,
        pausable_udt_type_script,
        admin_lock_script,
        normal_user_a_lock_script,
        normal_user_b_lock_script,
        paused_user_lock_script,
    }
}


================================================
File: scripts/find_clang
================================================
#!/usr/bin/env bash
#
# An utility script used to find a binary of clang 16+

if [[ -n "${CLANG}" ]]; then
  echo "${CLANG}"
  exit 0
fi

CANDIDATES=("clang" "clang-16" "clang-17" "clang-18")

BREW_PREFIX=$(brew --prefix 2> /dev/null)
if [[ -n "${BREW_PREFIX}" ]]; then
  CANDIDATES+=(
    "${BREW_PREFIX}/opt/llvm/bin/clang"
    "${BREW_PREFIX}/opt/llvm@16/bin/clang"
    "${BREW_PREFIX}/opt/llvm@17/bin/clang"
    "${BREW_PREFIX}/opt/llvm@18/bin/clang"
  )
fi

for candidate in ${CANDIDATES[@]}; do
  OUTPUT=$($candidate -dumpversion 2> /dev/null | cut -d'.' -f 1)

  if [[ $((OUTPUT)) -ge 16 ]]; then
    echo "$candidate"
    exit 0
  fi
done

>&2 echo "Cannot find clang of version 16+!"
exit 1


================================================
File: scripts/reproducible_build_docker
================================================
#!/usr/bin/env bash
#
# An utility script helping with reproducible script builds via docker.
# Note that this utility serves only as one example, docker is not
# necessarily THE way to do reproducible build, nor is it the best way
# to do reproducible build.
set -ex

DOCKER="${DOCKER:-docker}"
# docker pull docker.io/cryptape/llvm-n-rust:20240630
DOCKER_IMAGE="${DOCKER_IMAGE:-docker.io/cryptape/llvm-n-rust@sha256:bafaf76d4f342a69b8691c08e77a330b7740631f3d1d9c9bee4ead521b29ee55}"
CHECKSUM_FILE_PATH="${CHECKSUM_FILE_PATH:-checksums.txt}"

# We are parsing command line arguments based on tips from:
# https://stackoverflow.com/a/14203146

while [[ $# -gt 0 ]]; do
  case $1 in
    -p|--proxy)
      PROXY="$2"
      shift # past argument
      shift # past value
      ;;
    -u|--update)
      UPDATE="yes"
      shift # past argument
      ;;
    --no-clean)
      NOCLEAN="yes"
      shift # past argument
      ;;
    -*|--*)
      echo "Unknown option $1"
      exit 1
      ;;
    *)
      echo "Unknown argument $1"
      exit 1
      ;;
  esac
done

if [[ -n "${PROXY}" ]]; then
  DOCKER_RUN_ARGS="-e ALL_PROXY=${PROXY} -e HTTPS_PROXY=${PROXY} -e HTTP_PROXY=${PROXY} ${DOCKER_RUN_ARGS}"
fi

TASKS=""
if [[ "${NOCLEAN}" != "yes" ]]; then
  TASKS+=" clean "
fi

if [[ "${UPDATE}" = "yes" ]]; then
  TASKS+=" checksum CHECKSUM_FILE=${CHECKSUM_FILE_PATH} "
else
  TASKS+=" build "
fi

$DOCKER run --rm $DOCKER_RUN_ARGS -v `pwd`:/code $DOCKER_IMAGE make $TASKS
# Reset file ownerships for all files docker might touch
$DOCKER run --rm $DOCKER_RUN_ARGS -e UID=`id -u` -e GID=`id -g` -v `pwd`:/code $DOCKER_IMAGE bash -c 'chown -R -f $UID:$GID checksums.txt build target'

if [[ "${UPDATE}" = "yes" ]]; then
  echo "${CHECKSUM_FILE_PATH} file is updated with latest binary hashes!"
else
  shasum -a 256 -c ${CHECKSUM_FILE_PATH}
fi


