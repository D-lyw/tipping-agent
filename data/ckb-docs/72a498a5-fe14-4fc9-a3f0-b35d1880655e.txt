Directory structure:
└── ckb-devrel-ssri-server/
    ├── README.md
    ├── Cargo.toml
    ├── Dockerfile
    ├── config.mainnet.toml
    ├── config.toml
    ├── test.sh
    ├── .dockerignore
    └── src/
        ├── error.rs
        ├── main.rs
        ├── rpc_client.rs
        ├── ssri_vm.rs
        └── types.rs

================================================
File: README.md
================================================
# SSRI Server

Start server with

```sh
RUST_LOG=ssri_server=debug cargo run
```

Run a script with

```sh
echo '{
    "id": 2,
    "jsonrpc": "2.0",
    "method": "run_script_level_code",
    "params": ["0x900afcf79235e88f7bdf8a5d320365b7912f8074f4489a68405f43586fc51e5c", 0, ["0x58f02409de9de7b1", "0x0000000000000000", "0x0a00000000000000"]]
}' \
| curl -H 'content-type: application/json' -d @- \
http://localhost:8090
```

## Obtaining the Correct Params

Currently, obtaining the correct params for calling SSRI methods depends on `ckb_std::high_level::decode_hex`.

For example, you get the param to call "SSRI.get_methods" by running the following code in the script:

```rust
  let get_methods_path = method_path("SSRI.get_methods");
  let get_methods_path_in_bytes = get_methods_path.to_le_bytes();
  let get_methods_path_path_hex = encode_hex(&get_methods_path_in_bytes);
  // get_methods_path_hex is `0x58f02409de9de7b1`
```


# Attempt for WASM
https://github.com/rustwasm/wasm-bindgen/issues/2753
Due to the limitations of WASM and browser related runtime that are single-threaded, as CKB-VM currently requires `Sync` and `Send` for trait `Syscall`, it is not promising to implement running CKB-VM in the browser with WASM. Attempt suspended.


================================================
File: Cargo.toml
================================================
[package]
name = "ssri-server"
version = "0.1.0"
edition = "2021"

[dependencies]
anyhow = "1.0.86"
ckb-jsonrpc-types = "0.116.1"
ckb-sdk = "3.2.1"
ckb-types = "0.116.1"
ckb-hash = "0.116.1"
ckb-vm = "0.24.9"
hex = { version = "0.4.3", features = ["serde"] }
jsonrpc-core = "18.0.0"
jsonrpsee = { version = "0.24.7", features = ["server", "macros"] }
reqwest = { version = "0.12.5", features = ["json", "blocking"] }
serde = { version = "1.0", features = ["derive"] }
toml = "0.8"
tokio = { version = "1.38.1", features = ["signal"] }
tracing-subscriber = { version = "0.3.18", features = ["env-filter"] }
tower-http = { version = "0.6.2", features = ['full'] }
hyper = { version = "1.5.2" }
tower = { version = "0.4.13", features = ['full'] }
config = "0.15.4"


================================================
File: Dockerfile
================================================
FROM rust:1-alpine AS builder

RUN apk add --no-cache musl-dev pkgconfig openssl-dev
ENV OPENSSL_DIR=/usr
ENV RUSTFLAGS='-C target-feature=-crt-static'

WORKDIR /
RUN cargo new app

# Install dependencies for cache
WORKDIR /app
RUN --mount=type=bind,source=Cargo.toml,target=Cargo.toml \
  --mount=type=bind,source=Cargo.lock,target=Cargo.lock \
  cargo build --release

COPY . .
RUN touch src/main.rs; cargo build --release

FROM alpine:3
RUN apk add --no-cache libgcc

COPY --link --from=builder /app/target/release/ssri-server /app/ssri-server

WORKDIR /app
EXPOSE 8090
CMD ["/app/ssri-server"]


================================================
File: config.mainnet.toml
================================================
ckb_rpc = "https://mainnet.ckb.dev/"
server_addr = "0.0.0.0:9090"

script_debug = false

================================================
File: config.toml
================================================
ckb_rpc = "https://testnet.ckb.dev/"
server_addr = "0.0.0.0:9090"

script_debug = false

================================================
File: test.sh
================================================
    echo '{
    "id": 2,
    "jsonrpc": "2.0",
    "method": "run_script_level_code",
    "params": ["0x900afcf79235e88f7bdf8a5d320365b7912f8074f4489a68405f43586fc51e5c", 0, ["0x58f02409de9de7b1", "0x0000000000000000", "0x0a00000000000000"]]
}' \
| curl -H 'content-type: application/json' -d @- \
http://localhost:9090

================================================
File: .dockerignore
================================================
.git*

*docker-compose*
*Dockerfile*
.dockerignore

target
config.*

README.md
.vscode


================================================
File: src/error.rs
================================================
use jsonrpsee::types::ErrorObjectOwned;
use std::fmt::Display;

#[derive(Debug)]
#[repr(i32)]
#[allow(clippy::enum_variant_names)]
pub enum Error {
    JsonRpcRequestError = 1000,
    Encoding(&'static str),
    InvalidRequest(&'static str),
    Script(i8),
    Vm(String),
}

impl From<Error> for ErrorObjectOwned {
    fn from(error: Error) -> Self {
        let code = match error {
            Error::JsonRpcRequestError => 1000,
            Error::Encoding(_) => 1001,
            Error::InvalidRequest(_) => 1002,
            Error::Script(_) => 1003,
            Error::Vm(_) => 1004,
        };
        let msg = match error {
            Error::JsonRpcRequestError => "".to_owned(),
            Error::Encoding(msg) | Error::InvalidRequest(msg) => msg.to_owned(),
            Error::Vm(msg) => msg,
            Error::Script(code) => format!("Script returns {}", code),
        };

        ErrorObjectOwned::owned(code, msg, None::<()>)
    }
}

impl Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::JsonRpcRequestError => write!(f, "JsonRpcRequestError"),
            Error::Encoding(msg) => write!(f, "Encoding error: {}", msg),
            Error::InvalidRequest(msg) => write!(f, "Invalid request: {}", msg),
            Error::Script(code) => write!(f, "Script returns {}", code),
            Error::Vm(msg) => write!(f, "VM error: {}", msg),
        }
    }
}


================================================
File: src/main.rs
================================================
use ckb_jsonrpc_types::{Script, TransactionView};
use ckb_types::H256;
use error::Error;
use jsonrpsee::core::async_trait;
use jsonrpsee::proc_macros::rpc;
use jsonrpsee::server::Server;
use jsonrpsee::tracing;
use jsonrpsee::types::ErrorObjectOwned;

mod error;
mod rpc_client;
mod ssri_vm;
mod types;

use hyper::Method;
use rpc_client::RpcClient;
use serde::Deserialize;
use tower_http::cors::{Any, CorsLayer};
use types::{CellOutputWithData, Hex, VmResult};

use ssri_vm::execute_riscv_binary;

#[derive(Debug, Deserialize, Clone)]
pub struct Config {
    ckb_rpc: String,
    server_addr: String,
    script_debug: bool,
}

impl Default for Config {
    fn default() -> Self {
        Self {
            ckb_rpc: "https://testnet.ckb.dev/".to_string(),
            server_addr: "0.0.0.0:9090".to_string(),
            script_debug: true,
        }
    }
}

#[rpc(server)]
pub trait Rpc {
    #[method(name = "run_script_level_code")]
    async fn run_script_level_code(
        &self,
        tx_hash: H256,
        index: u32,
        args: Vec<Hex>,
    ) -> Result<VmResult, ErrorObjectOwned>;

    #[method(name = "run_script_level_script")]
    async fn run_script_level_script(
        &self,
        tx_hash: H256,
        index: u32,
        args: Vec<Hex>,
        script: Script,
    ) -> Result<VmResult, ErrorObjectOwned>;

    #[method(name = "run_script_level_cell")]
    async fn run_script_level_cell(
        &self,
        tx_hash: H256,
        index: u32,
        args: Vec<Hex>,
        cell: CellOutputWithData,
    ) -> Result<VmResult, ErrorObjectOwned>;

    #[method(name = "run_script_level_tx")]
    async fn run_script_level_tx(
        &self,
        tx_hash: H256,
        index: u32,
        args: Vec<Hex>,
        tx: TransactionView,
    ) -> Result<VmResult, ErrorObjectOwned>;
}

pub struct RpcServerImpl {
    config: Config,
}

impl RpcServerImpl {
    pub fn new(config: Config) -> Self {
        Self { config }
    }

    async fn run_script(
        &self,
        tx_hash: H256,
        index: u32,
        args: Vec<Hex>,
        script: Option<Script>,
        cell: Option<CellOutputWithData>,
        tx: Option<TransactionView>,
    ) -> Result<VmResult, ErrorObjectOwned> {
        let config = self.config.clone();
        tokio::runtime::Handle::current()
            .spawn_blocking(move || -> Result<VmResult, ErrorObjectOwned>{
        let rpc = RpcClient::new(&config.ckb_rpc);
                let ssri_binary = rpc
                    .get_cell(&tx_hash, index)?
                    .ok_or(Error::InvalidRequest("Cell not found"))?
                    .1
                    .into_bytes();

        let script = script.map(Into::into);
        let cell = cell.map(Into::into);
        let tx = tx.map(|v| v.inner.into());
        let description = format!(
            "Script {tx_hash}:{index} with args {args:?} context\nscript: {script:?}\ncell: {cell:?}\ntx: {tx:?}"
        );

        let args = args.into_iter().map(|v| v.hex.into()).collect();
        let res = execute_riscv_binary(config, rpc, ssri_binary, args, script, cell, tx)?;
        tracing::info!("{description}\nresult {res:?}");
        Ok(res)
            })
            .await.unwrap()
    }
}

#[async_trait]
impl RpcServer for RpcServerImpl {
    async fn run_script_level_code(
        &self,
        tx_hash: H256,
        index: u32,
        args: Vec<Hex>,
    ) -> Result<VmResult, ErrorObjectOwned> {
        self.run_script(tx_hash, index, args, None, None, None)
            .await
    }

    async fn run_script_level_script(
        &self,
        tx_hash: H256,
        index: u32,
        args: Vec<Hex>,
        script: Script,
    ) -> Result<VmResult, ErrorObjectOwned> {
        self.run_script(tx_hash, index, args, Some(script), None, None)
            .await
    }

    async fn run_script_level_cell(
        &self,
        tx_hash: H256,
        index: u32,
        args: Vec<Hex>,
        cell: CellOutputWithData,
    ) -> Result<VmResult, ErrorObjectOwned> {
        self.run_script(tx_hash, index, args, None, Some(cell), None)
            .await
    }

    async fn run_script_level_tx(
        &self,
        tx_hash: H256,
        index: u32,
        args: Vec<Hex>,
        tx: TransactionView,
    ) -> Result<VmResult, ErrorObjectOwned> {
        self.run_script(tx_hash, index, args, None, None, Some(tx))
            .await
    }
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    tracing_subscriber::FmtSubscriber::builder()
        .with_env_filter(tracing_subscriber::EnvFilter::from_default_env())
        .try_init()
        .expect("setting default subscriber failed");

    // Start with default config
    let mut config = Config::default();

    // Try to load from config file
    if let Ok(file_config) = config::Config::builder()
        .add_source(config::File::with_name("config"))
        .build()
    {
        if let Ok(deserialized_config) = file_config.try_deserialize::<Config>() {
            config = deserialized_config;
        }
    }

    println!(
        "CKB RPC URI: {}\nListening on: {}\nScript debug {}",
        config.ckb_rpc,
        config.server_addr,
        if config.script_debug {
            "enabled"
        } else {
            "disabled"
        }
    );
    run_server(config).await?;
    Ok(())
}

async fn run_server(config: Config) -> anyhow::Result<()> {
    let cors = CorsLayer::new()
        // Allow `POST` when accessing the resource
        .allow_methods([Method::POST])
        // Allow requests from any origin
        .allow_origin(Any)
        .allow_headers([hyper::header::CONTENT_TYPE]);
    let middleware = tower::ServiceBuilder::new().layer(cors);
    let server = Server::builder()
        .set_http_middleware(middleware)
        .build(&config.server_addr)
        .await?;

    let handle = server.start(RpcServerImpl::new(config).into_rpc());

    tokio::signal::ctrl_c().await.unwrap();
    handle.stop().unwrap();

    Ok(())
}


================================================
File: src/rpc_client.rs
================================================
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::Arc;

use ckb_jsonrpc_types::{CellOutput, Either, JsonBytes, TransactionWithStatusResponse, Uint32};
use ckb_sdk::rpc::ckb_indexer::{Cell, Order, Pagination, SearchKey};
use ckb_types::H256;
use jsonrpc_core::serde_json;
use reqwest::blocking::Client;
use reqwest::Url;

use crate::error::Error;

macro_rules! jsonrpc {
    ($method:expr, $self:ident, $return:ty$(, $params:ident$(,)?)*) => {{
        let data = format!(
            r#"{{"id": {}, "jsonrpc": "2.0", "method": "{}", "params": {}}}"#,
            $self.id.load(Ordering::Relaxed),
            $method,
            serde_json::to_value(($($params,)*)).unwrap()
        );
        $self.id.fetch_add(1, Ordering::Relaxed);

        let req_json: serde_json::Value = serde_json::from_str(&data).unwrap();

        let c = $self.raw.post($self.uri.clone()).json(&req_json);
        let resp = c
            .send()
            .map_err::<Error, _>(|_| Error::JsonRpcRequestError)?;
        let output = resp
            .json::<jsonrpc_core::response::Output>()
            .map_err::<Error, _>(|_| Error::JsonRpcRequestError)?;

        match output {
            jsonrpc_core::response::Output::Success(success) => {
                Ok(serde_json::from_value::<$return>(success.result).unwrap())
            }
            jsonrpc_core::response::Output::Failure(_) => {
                Err(Error::JsonRpcRequestError)
            }
        }
    }}
}

#[derive(Clone)]
pub struct RpcClient {
    raw: Client,
    uri: Url,
    id: Arc<AtomicU64>,
}

impl RpcClient {
    pub fn new(ckb_uri: &str) -> Self {
        let uri = Url::parse(ckb_uri).expect("ckb uri, e.g. \"http://127.0.0.1:8114\"");

        RpcClient {
            raw: Client::new(),
            uri,
            id: Arc::new(AtomicU64::new(0)),
        }
    }
}

impl RpcClient {
    pub fn get_cells(
        &self,
        search_key: SearchKey,
        order: Order,
        limit: u32,
        cursor: Option<JsonBytes>,
    ) -> Result<Pagination<Cell>, Error> {
        let limit = Uint32::from(limit);
        jsonrpc!(
            "get_cells",
            self,
            Pagination<Cell>,
            search_key,
            order,
            limit,
            cursor,
        )
    }

    pub fn get_cell(
        &self,
        tx_hash: &H256,
        index: u32,
    ) -> Result<Option<(CellOutput, JsonBytes)>, Error> {
        let tx = self.get_transaction(tx_hash)?;
        let tx = match tx {
            Some(TransactionWithStatusResponse {
                transaction: Some(tx),
                ..
            }) => tx.inner,
            _ => return Ok(None),
        };

        let tx = match tx {
            Either::Left(view) => view,
            Either::Right(bytes) => match serde_json::from_slice(&bytes.into_bytes()) {
                Err(_) => return Ok(None),
                Ok(view) => view,
            },
        }
        .inner;

        let output = tx.outputs.get(index as usize);
        let data = tx.outputs_data.get(index as usize);
        match (output, data) {
            (Some(output), Some(data)) => Ok(Some((output.clone(), data.clone()))),
            _ => Ok(None),
        }
    }

    pub fn get_transaction(
        &self,
        hash: &H256,
    ) -> Result<Option<TransactionWithStatusResponse>, Error> {
        jsonrpc!(
            "get_transaction",
            self,
            Option<TransactionWithStatusResponse>,
            hash,
        )
    }
}


================================================
File: src/ssri_vm.rs
================================================
// refer to https://github.com/nervosnetwork/ckb-vm/blob/develop/examples/ckb-vm-runner.rs

use std::collections::HashSet;
use std::sync::{Arc, Mutex};

use ckb_hash::blake2b_256;
use ckb_sdk::rpc::ckb_indexer::Order;
use ckb_sdk::traits::CellQueryOptions;
use ckb_types::core::Capacity;
use ckb_types::packed::{CellOutput, OutPoint, Script, Transaction};
use ckb_types::prelude::{Entity, Unpack};
use ckb_vm::cost_model::estimate_cycles;
use ckb_vm::registers::{A0, A1, A2, A3, A4, A5, A7};
use ckb_vm::{Bytes, Memory, Register, SupportMachine, Syscalls};
use hex::encode;
use jsonrpsee::tracing;

use crate::error::Error;
use crate::rpc_client::RpcClient;
use crate::types::{CellOutputWithData, Hex, VmResult};
use crate::Config;

macro_rules! error {
    ($err:expr) => {{
        let error = $err.to_string();
        #[cfg(test)]
        println!("[ERROR] {error}");
        ckb_vm::error::Error::Unexpected(error)
    }};
}

macro_rules! output {
    ($machine:ident, $len_addr:ident, $bytes:expr, $addr:ident, $offset:expr, $len:ident) => {
        $machine
            .memory_mut()
            .store64(&$len_addr, &($bytes.len() as u64))?;
        if $len > 0 {
            let begin = $offset as usize;
            let end = ($offset + $len) as usize;
            $machine
                .memory_mut()
                .store_bytes($addr, &$bytes[begin..end])?;
        }
    };
}

#[allow(unused)]
#[repr(u64)]
pub enum Source {
    Input = 1,
    Output = 2,
    CellDep = 3,
    HeaderDep = 4,
    GroupInput = 72_057_594_037_927_937,
    GroupOutput = 72_057_594_037_927_938,
}

#[allow(unused)]
#[repr(u64)]
pub enum CellField {
    Capacity = 0,
    DataHash = 1,
    Lock = 2,
    LockHash = 3,
    Type = 4,
    TypeHash = 5,
    OccupiedCapacity = 6,
}

impl TryFrom<u64> for CellField {
    type Error = ckb_vm::error::Error;

    fn try_from(value: u64) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(CellField::Capacity),
            1 => Ok(CellField::DataHash),
            2 => Ok(CellField::Lock),
            3 => Ok(CellField::LockHash),
            4 => Ok(CellField::Type),
            5 => Ok(CellField::TypeHash),
            6 => Ok(CellField::OccupiedCapacity),
            _ => Err(ckb_vm::error::Error::Unexpected(format!(
                "Invalid cell field {}",
                value
            ))),
        }
    }
}

#[derive(Clone)]
struct Context {
    config: Config,
    content: Arc<Mutex<Option<Bytes>>>,
    cell_deps: Arc<Mutex<HashSet<OutPoint>>>,
    rpc: RpcClient,
    script: Option<Script>,
    cell: Option<CellOutputWithData>,
    // wait for second phase to do with ckb transaction
    _tx: Option<Transaction>,
}

impl Context {
    pub fn new(
        config: Config,
        rpc: RpcClient,
        script: Option<Script>,
        cell: Option<CellOutputWithData>,
        tx: Option<Transaction>,
    ) -> Self {
        Self {
            config,
            content: Arc::new(Mutex::new(None)),
            cell_deps: Arc::new(Mutex::new(HashSet::new())),
            rpc,
            script,
            cell,
            _tx: tx,
        }
    }
}

impl Context {
    fn load_script(
        &self,
        machine: &mut impl SupportMachine<REG = u64>,
    ) -> Result<(), ckb_vm::error::Error> {
        let script = self.script.as_ref().ok_or(error!("Script is missing"))?;
        let addr = machine.registers()[A0].to_u64();
        let len_addr = machine.registers()[A1];
        let offset = machine.registers()[A2];

        let bytes = script.as_slice().to_vec();
        let len = bytes.len() as u64;
        output!(machine, len_addr, bytes, addr, offset, len);
        machine.set_register(A0, 0);
        Ok(())
    }

    fn load_script_hash(
        &self,
        machine: &mut impl SupportMachine<REG = u64>,
    ) -> Result<(), ckb_vm::error::Error> {
        let script = self.script.as_ref().ok_or(error!("Script is missing"))?;
        let addr = machine.registers()[A0].to_u64();
        let len_addr = machine.registers()[A1];
        let offset = machine.registers()[A2];

        let bytes = script.calc_script_hash().raw_data().to_vec();
        let len = bytes.len() as u64;
        output!(machine, len_addr, bytes, addr, offset, len);
        machine.set_register(A0, 0);
        Ok(())
    }

    fn load_cell(
        &self,
        machine: &mut impl SupportMachine<REG = u64>,
    ) -> Result<(), ckb_vm::error::Error> {
        let cell = self.cell.clone().ok_or(error!("Cell is missing"))?;
        let addr = machine.registers()[A0].to_u64();
        let len_addr = machine.registers()[A1];
        let offset = machine.registers()[A2];
        let index = machine.registers()[A3];
        let source = machine.registers()[A4];

        if index != 0 || source != Source::GroupInput as u64 {
            return Err(error!("Invalid index or source"));
        }

        let bytes = CellOutput::from(cell.cell_output).as_slice().to_vec();
        let len = bytes.len() as u64;
        output!(machine, len_addr, bytes, addr, offset, len);
        machine.set_register(A0, 0);
        Ok(())
    }

    fn load_cell_data(
        &self,
        machine: &mut impl SupportMachine<REG = u64>,
    ) -> Result<(), ckb_vm::error::Error> {
        let cell = self.cell.clone().ok_or(error!("Cell is missing"))?;
        let addr = machine.registers()[A0].to_u64();
        let len_addr = machine.registers()[A1];
        let offset = machine.registers()[A2];
        let index = machine.registers()[A3];
        let source = machine.registers()[A4];

        if index != 0 || source != Source::GroupInput as u64 {
            return Err(error!("Invalid index or source"));
        }

        let bytes = cell.hex_data.ok_or(error!("Cell data is missing"))?.hex;
        let len = bytes.len() as u64;
        output!(machine, len_addr, bytes, addr, offset, len);
        machine.set_register(A0, 0);
        Ok(())
    }

    fn load_cell_by_field(
        &self,
        machine: &mut impl SupportMachine<REG = u64>,
    ) -> Result<(), ckb_vm::error::Error> {
        let cell = self.cell.clone().ok_or(error!("Cell is missing"))?;
        let addr = machine.registers()[A0].to_u64();
        let len_addr = machine.registers()[A1];
        let offset = machine.registers()[A2];
        let index = machine.registers()[A3];
        let source = machine.registers()[A4];
        let field = machine.registers()[A5];

        if index != 0 || source != Source::GroupInput as u64 {
            return Err(error!("Invalid index or source"));
        }

        let bytes = match field.try_into()? {
            CellField::DataHash => blake2b_256(
                hex::decode(cell.hex_data.ok_or(error!("Cell data is missing"))?.hex)
                    .map_err(|_| error!("Invalid hexed cell data "))?,
            )
            .to_vec(),
            CellField::Lock => Script::from(cell.cell_output.lock).as_slice().to_vec(),
            CellField::Type => cell
                .cell_output
                .type_
                .map(|type_| Script::from(type_).as_slice().to_vec())
                .unwrap_or_default(),
            CellField::LockHash => Script::from(cell.cell_output.lock)
                .calc_script_hash()
                .raw_data()
                .to_vec(),
            CellField::TypeHash => cell
                .cell_output
                .type_
                .map(|type_| Script::from(type_).calc_script_hash().raw_data().to_vec())
                .unwrap_or_default(),
            CellField::Capacity => u64::from(cell.cell_output.capacity).to_le_bytes().to_vec(),
            CellField::OccupiedCapacity => {
                let data_len = cell
                    .hex_data
                    .ok_or(error!("Cell data is missing"))?
                    .hex
                    .len()
                    / 2;
                CellOutput::from(cell.cell_output)
                    .occupied_capacity(Capacity::bytes(data_len).unwrap())
                    .unwrap()
                    .as_u64()
                    .to_le_bytes()
                    .to_vec()
            }
        };
        let len = bytes.len() as u64;

        output!(machine, len_addr, bytes, addr, offset, len);
        machine.set_register(A0, 0);
        Ok(())
    }

    fn find_out_point_by_type(
        &self,
        machine: &mut impl SupportMachine<REG = u64>,
    ) -> Result<(), ckb_vm::error::Error> {
        let addr = machine.registers()[A0].to_u64();
        let len_addr = machine.registers()[A1];
        let script_addr = machine.registers()[A2];
        let script_len = machine.registers()[A3];

        let script = Script::from_slice(&machine.memory_mut().load_bytes(script_addr, script_len)?)
            .map_err(|_| error!("Invalid type script"))?;

        let cell = self
            .rpc
            .get_cells(
                CellQueryOptions::new_type(script).into(),
                Order::Asc,
                1,
                None,
            )
            .map_err(|_| error!("Failed to find cells"))?
            .objects
            .into_iter()
            .next()
            .ok_or(error!("Cell not found"))?;
        let out_point = OutPoint::from(cell.out_point);
        let len: u64 = out_point.as_slice().len() as u64;
        output!(machine, len_addr, out_point.as_slice(), addr, 0, len);
        machine.set_register(A0, 0);
        Ok(())
    }

    fn find_cell_by_out_point(
        &self,
        machine: &mut impl SupportMachine<REG = u64>,
    ) -> Result<(), ckb_vm::error::Error> {
        let addr = machine.registers()[A0].to_u64();
        let len_addr = machine.registers()[A1];
        let outpoint_addr = machine.registers()[A2];

        let out_point = OutPoint::from_slice(
            &machine
                .memory_mut()
                .load_bytes(outpoint_addr, OutPoint::TOTAL_SIZE as u64)?,
        )
        .map_err(|_| error!("Invalid type script"))?;
        self.cell_deps
            .clone()
            .lock()
            .unwrap()
            .insert(out_point.clone());

        let (cell, _) = self
            .rpc
            .get_cell(&out_point.tx_hash().unpack(), out_point.index().unpack())
            .map_err(|_| error!("Failed to get cell from RPC"))?
            .ok_or(error!("Cell not found"))?;

        let cell = CellOutput::from(cell);
        let len: u64 = cell.as_slice().len() as u64;
        output!(machine, len_addr, cell.as_slice(), addr, 0, len);
        machine.set_register(A0, 0);
        Ok(())
    }

    fn find_cell_data_by_out_point(
        &self,
        machine: &mut impl SupportMachine<REG = u64>,
    ) -> Result<(), ckb_vm::error::Error> {
        let addr = machine.registers()[A0].to_u64();
        let len_addr = machine.registers()[A1];
        let outpoint_addr = machine.registers()[A2];

        let out_point = OutPoint::from_slice(
            &machine
                .memory_mut()
                .load_bytes(outpoint_addr, OutPoint::TOTAL_SIZE as u64)?,
        )
        .map_err(|_| error!("Invalid type script"))?;
        self.cell_deps
            .clone()
            .lock()
            .unwrap()
            .insert(out_point.clone());

        let (_, data) = self
            .rpc
            .get_cell(&out_point.tx_hash().unpack(), out_point.index().unpack())
            .map_err(|_| error!("Failed to get cell from RPC"))?
            .ok_or(error!("Cell not found"))?;
        let data = data.as_bytes();

        let len: u64 = data.len() as u64;
        output!(machine, len_addr, data, addr, 0, len);
        machine.set_register(A0, 0);
        Ok(())
    }
    // In this way, pipe() would always return [0, 0].
    fn pipe(
        &self,
        machine: &mut impl SupportMachine<REG = u64>,
    ) -> Result<(), ckb_vm::error::Error> {
        machine.set_register(A0, 0);
        Ok(())
    }
}

impl<M: SupportMachine<REG = u64>> Syscalls<M> for Context {
    fn initialize(&mut self, _machine: &mut M) -> Result<(), ckb_vm::error::Error> {
        Ok(())
    }

    fn ecall(&mut self, machine: &mut M) -> Result<bool, ckb_vm::error::Error> {
        match machine.registers()[A7].to_u64() {
            // version - code
            2041 => machine.set_register(A0, u64::MAX),

            // load_script - script
            2052 => self.load_script(machine)?,
            // load_script_hash - script
            2061 => self.load_script_hash(machine)?,
            // load_cell - cell
            2071 => self.load_cell(machine)?,
            // load_cell_data - cell
            2092 => self.load_cell_data(machine)?,
            // load_cell_by_field - cell
            2081 => self.load_cell_by_field(machine)?,
            // find_out_point_by_type - code
            2277 => self.find_out_point_by_type(machine)?,
            // find_cell_by_out_point - code
            2287 => self.find_cell_by_out_point(machine)?,
            // find_cell_data_by_out_point - code
            2297 => self.find_cell_data_by_out_point(machine)?,

            // set_content - code
            // 2103 => {
            //     let addr = machine.registers()[A0].to_u64();
            //     let len = machine.registers()[A1];
            //     let len = machine.memory_mut().load64(&len)?;

            //     *self.content.clone().lock().unwrap() =
            //         Some(machine.memory_mut().load_bytes(addr, len)?);
            // }
            // pipe - code
            2604 => self.pipe(machine)?,
            // write - code
            // NOTE: This would be working in the set_content way but using write for compatibility
            2605 => {
                let addr = machine.registers()[A1].to_u64();
                let len = machine.registers()[A2];
                let len = machine.memory_mut().load64(&len)?;

                *self.content.clone().lock().unwrap() =
                    Some(machine.memory_mut().load_bytes(addr, len)?);
            }
            // debug - code
            2177 => {
                if !self.config.script_debug {
                    return Ok(true);
                }
                let mut addr = machine.registers()[A0];
                let mut buffer = Vec::new();

                loop {
                    let byte = machine.memory_mut().load8(&addr)?.to_u8();
                    if byte == 0 {
                        break;
                    }
                    buffer.push(byte);
                    addr += 1;
                }

                tracing::info!("[Script Debug] {}", String::from_utf8(buffer).unwrap());
            }
            _ => return Ok(false),
        };

        Ok(true)
    }
}

pub fn execute_riscv_binary(
    config: Config,
    rpc: RpcClient,
    code: Bytes,
    args: Vec<Bytes>,
    script: Option<Script>,
    cell: Option<CellOutputWithData>,
    tx: Option<Transaction>,
) -> Result<VmResult, Error> {
    let context = Context::new(config, rpc, script, cell, tx);

    let asm_core = ckb_vm::machine::asm::AsmCoreMachine::new(
        ckb_vm::ISA_IMC | ckb_vm::ISA_B | ckb_vm::ISA_MOP | ckb_vm::ISA_A,
        ckb_vm::machine::VERSION2,
        7_000_000_000,
    );
    let core = ckb_vm::DefaultMachineBuilder::new(asm_core)
        .instruction_cycle_func(Box::new(estimate_cycles))
        .syscall(Box::new(context.clone()))
        .build();
    let mut machine = ckb_vm::machine::asm::AsmMachine::new(core);

    let args = args
        .into_iter()
        .map(|arg| Bytes::copy_from_slice(encode(arg).as_bytes()))
        .collect::<Vec<Bytes>>();
    machine
        .load_program(&code, &args)
        .map_err(|err| Error::Vm(format!("Failed to load program: {err}")))?;
    let error_code = machine
        .run()
        .map_err(|err| Error::Vm(format!("Failed to run program: {err}")))?;
    if error_code != 0 {
        return Err(Error::Script(error_code));
    }

    let content = context.content.lock().unwrap().clone();
    let cell_deps = context.cell_deps.lock().unwrap().clone();
    Ok(VmResult {
        content: content.map(|v| v.into()).unwrap_or(Hex { hex: Vec::new() }),
        cell_deps: cell_deps.into_iter().map(|v| v.into()).collect(),
    })
}


================================================
File: src/types.rs
================================================
use core::marker::PhantomData;
use std::fmt::Debug;

use ckb_jsonrpc_types::{CellOutput, OutPoint};
use ckb_vm::Bytes;
use core::fmt;
use hex::{FromHex, ToHex};
use serde::{
    de::{Error, Visitor},
    Deserialize, Deserializer, Serialize, Serializer,
};

pub fn serialize<S, T>(data: T, serializer: S) -> Result<S::Ok, S::Error>
where
    S: Serializer,
    T: ToHex,
{
    let s = format!("0x{}", data.encode_hex::<String>());
    serializer.serialize_str(&s)
}

pub fn deserialize<'de, D, T>(deserializer: D) -> Result<T, D::Error>
where
    D: Deserializer<'de>,
    T: FromHex,
    <T as FromHex>::Error: fmt::Display,
{
    struct HexStrVisitor<T>(PhantomData<T>);

    impl<'de, T> Visitor<'de> for HexStrVisitor<T>
    where
        T: FromHex,
        <T as FromHex>::Error: fmt::Display,
    {
        type Value = T;

        fn expecting(&self, f: &mut fmt::Formatter) -> fmt::Result {
            write!(f, "a 0x-prefixed hex encoded string")
        }

        fn visit_str<E>(self, data: &str) -> Result<Self::Value, E>
        where
            E: Error,
        {
            if !data.starts_with("0x") {
                Err(Error::custom("expected a 0x-prefixed hex encoded string"))
            } else {
                FromHex::from_hex(&data[2..]).map_err(Error::custom)
            }
        }

        fn visit_borrowed_str<E>(self, data: &'de str) -> Result<Self::Value, E>
        where
            E: Error,
        {
            if !data.starts_with("0x") {
                Err(Error::custom("expected a 0x-prefixed hex encoded string"))
            } else {
                FromHex::from_hex(&data[2..]).map_err(Error::custom)
            }
        }
    }

    deserializer.deserialize_str(HexStrVisitor(PhantomData))
}

#[derive(Serialize, Deserialize, Clone)]
#[serde(transparent)]
pub struct Hex {
    #[serde(serialize_with = "serialize", deserialize_with = "deserialize")]
    pub hex: Vec<u8>,
}

impl Debug for Hex {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "0x{}", self.hex.encode_hex::<String>())
    }
}

impl From<Bytes> for Hex {
    fn from(value: Bytes) -> Self {
        Self {
            hex: value.to_vec(),
        }
    }
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CellOutputWithData {
    pub cell_output: CellOutput,
    pub hex_data: Option<Hex>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct VmResult {
    pub content: Hex,
    pub cell_deps: Vec<OutPoint>,
}


