Directory structure:
└── sporeprotocol-dob-decoder-standalone-server/
    ├── README.md
    ├── Cargo.toml
    ├── Dockerfile
    ├── settings.mainnet.toml
    ├── settings.toml
    ├── .dockerignore
    ├── cache/
    │   ├── decoders/
    │   │   ├── code_hash_13cac78ad8482202f18f9df4ea707611c35f994375fa03ae79121312dda9925c.bin
    │   │   ├── code_hash_1c84212ebd817e9de09d2a79f85cc421b684eda63409cfa75688f98716e77b5f.bin
    │   │   ├── code_hash_32f29aba4b17f3d05bec8cec55d50ef86766fd0bf82fdedaa14269f344d3784a.bin
    │   │   ├── code_hash_b82abd59ade361a014f0abb692f71b0feb880693c3ccb95b9137b73551d872ce.bin
    │   │   ├── code_hash_da3525549b72970b4c95f5b5749357f20d1293d335710b674f09c32f7d54b6dc.bin
    │   │   └── code_hash_df2030642f219db0a06f6ee4b160142cc4d668790616b1dc1bdd4e3ff7e3a814.bin
    │   └── dobs/
    │       └── .gitkeep
    └── src/
        ├── client.rs
        ├── lib.rs
        ├── main.rs
        ├── server.rs
        ├── types.rs
        ├── vm.rs
        ├── decoder/
        │   ├── helpers.rs
        │   └── mod.rs
        └── tests/
            ├── mod.rs
            ├── dob0/
            │   ├── decoder.rs
            │   ├── legacy_decoder.rs
            │   └── mod.rs
            └── dob1/
                ├── decoder.rs
                └── mod.rs

================================================
File: README.md
================================================
# DOB-Decoder-Standalone-Server

Provide an one-step DOB rendering service to squash a batch of complex steps that from DNA fetching to DOB traits rendering.

Online features:

- [x] embeded `ckb-vm` executor
- [x] executable standalone JsonRpc server
- [x] decoder binaries temporary cache
- [x] render result temporary cache
- [x] library exported for 3rd-party integration

## `ckb-vm` executor

Embeded VM executor is integrating a standalone `ckb-vm` in project to execute decoder binary files, and the corresponding feature is `embeded_vm` which is marked in [default](https://github.com/sporeprotocol/dob-decoder-standalone-server/blob/master/Cargo.toml#L27). We recommend embeded mode for fresh users, because in contrast, the native mode is more like an advanced usage for providing flexibility for user-defined VM environments.

## Decoder binaries cache

Considering there would be plenty of decoders under DOB protocol in upcoming days, caching on-chain decoders for once in cache directory, which is marked [here](https://github.com/sporeprotocol/dob-decoder-standalone-server/blob/master/settings.toml#L14), is more reasonable rather than downloading them in repeat.

Since decoder binary has two `location` types according to the requirement from DOB protocol, which are respectively the `code_hash` (name file in `code_hash_<hash>.bin` format) and `type_id` (name file in `type_id_<hash>.bin` format). For example, decoder binary file `code_hash_edbb2d19515ebbf69be66b2178b0c4c0884fdb33878bd04a5ad68736a6af74f8.dob` indicates the location type is `code_hash`, and with `edbb2d19515ebbf69be66b2178b0c4c0884fdb33878bd04a5ad68736a6af74f8` for its blake2b hash of the entire content.

The `code_hash` location type requires user to compile out all of interested decoder RISC-V binaries in advance, and then, place them into project's decoder cache directory (in `code_hash_<hash>.bin` format). In contrast, the `type_id` location type has no extra demands, since these sort of decoder binaries have been already deployed into on-chain decoder cells which the project will automatically download from and persist into cache directory (in `type_id_<hash>.bin` format).

## Render cache

Considering the immutability of Spore and Cluster cell, the DNA string in Spore cell is immutable as well, so the rendering result of DNA is indeed immutable at the same time.

Rendering output can be stored in cache directory for shorting down server response time for the same decoding requests, which is marked [here](https://github.com/sporeprotocol/dob-decoder-standalone-server/blob/master/settings.toml#L17).

## Launch JsonRpc server

Running a JsonRpc server requires project to be built under feature `standalone_server` opened, which is marked in [default](https://github.com/sporeprotocol/dob-decoder-standalone-server/blob/master/Cargo.toml#L27).

Steps to run a server:

```bash
$ RUST_LOG=dob_decoder_server=debug cargo run
```

And then, try it out:

```bash
$ echo '{
    "id": 2,
    "jsonrpc": "2.0",
    "method": "dob_decode",
    "params": [
        "<spore_id in hex format without 0x prefix>"
    ]
}' \
| curl -H 'content-type: application/json' -d @- \
http://localhost:8090
```

## Protocol version

Spore DOB protocol has unique version identifier (like ERC721 or ERC1155), however, different versions may have totally different behaviors in decoding operation, so that we come out a regulation that one server instance only serves under one specific DOB protocol version, which is marked [here](https://github.com/sporeprotocol/dob-decoder-standalone-server/blob/master/settings.toml#L2).

## Error codes

refer to error definitions [here](https://github.com/sporeprotocol/dob-decoder-standalone-server/blob/master/src/types.rs#L13).


================================================
File: Cargo.toml
================================================
[package]
name = "dob-decoder-server"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
ckb-sdk = "3.2.0"
ckb-types = "0.116.1"
ckb-jsonrpc-types = "0.116.1"
ckb-hash = "0.116.1"
thiserror = "1.0"
serde_json = "1.0"
hex = "0.4.3"
reqwest = { version = "0.12.4", features = ["json"] }
jsonrpc-core = "18.0"
serde = { version = "1.0", features = ["serde_derive"] }
futures = "0.3"
lazy_static = { version = "1.4" }
ckb-vm = { version = "0.24", features = ["asm"] }

spore-types = { git = "https://github.com/sporeprotocol/spore-contract", rev = "81315ca" }

jsonrpsee = { version = "0.22.3", features = ["server", "macros"], optional = true }
toml = { version = "0.8.2", optional = true }
tokio = { version = "1.37", features = ["rt", "signal"], optional = true }
tracing-subscriber = { version = "0.3.18", features = ["fmt", "env-filter"], optional = true }

[features]
default = ["standalone_server", "render_debug"]
standalone_server = ["jsonrpsee", "toml", "tokio", "tracing-subscriber"]
render_debug = []


================================================
File: Dockerfile
================================================
FROM rust:1-alpine AS builder

RUN apk add --no-cache musl-dev pkgconfig openssl-dev
ENV OPENSSL_DIR=/usr
ENV RUSTFLAGS='-C target-feature=-crt-static'

WORKDIR /
RUN cargo new app

# Install dependencies for cache
WORKDIR /app
RUN --mount=type=bind,source=Cargo.toml,target=Cargo.toml \
  --mount=type=bind,source=Cargo.lock,target=Cargo.lock \
  cargo build --release

COPY . .
RUN touch src/main.rs; cargo build --release

FROM alpine:3
RUN apk add --no-cache libgcc

COPY --link --from=builder /app/target/release/dob-decoder-server /app/dob-decoder-server

WORKDIR /app
RUN mkdir -p cache/decoders cache/dobs
EXPOSE 8090
CMD ["/app/dob-decoder-server"]


================================================
File: settings.mainnet.toml
================================================
# identifier of specific DOB protocol versions
protocol_versions = [
    "dob/0",
    "dob/1",
]

# connect to the RPC of CKB node
ckb_rpc = "https://mainnet.ckb.dev/"

# address that rpc server running at in case of standalone server mode
rpc_server_address = "0.0.0.0:8090"

# directory that stores decoders on hard-disk, including on-chain and off-chain binary files
decoders_cache_directory = "cache/decoders"

# directory that stores DOBs rendering results on hard-disk
dobs_cache_directory = "cache/dobs"

# expiration time indicator for cleaning whole dobs cache, zero means never clean
dobs_cache_expiration_sec = 300

# all deployed on-chain Spore contracts binary hash (order from new to old)
# refer to: https://github.com/sporeprotocol/spore-contract/blob/master/docs/VERSIONS.md
[[available_spores]]
code_hash = "0x4a4dce1df3dffff7f8b2cd7dff7303df3b6150c9788cb75dcf6747247132b9f5"
hash_type = "data1"

[[available_spores]]
code_hash = "0xcfba73b58b6f30e70caed8a999748781b164ef9a1e218424a6fb55ebf641cb33"
hash_type = "type"

# all deployed on-chain Cluster contracts binary hash (order from new to old)
# refer to: https://github.com/sporeprotocol/spore-contract/blob/master/docs/VERSIONS.md
[[available_clusters]]
code_hash = "0x7366a61534fa7c7e6225ecc0d828ea3b5366adec2b58206f2ee84995fe030075"
hash_type = "data1"

# associate `code_hash` with the corresponding onchain information about `tx_hash` and `out_index`
# server will firstly search onchain decoders by `code_hash` in this configuration, if not found, cache will be used instead
[[onchain_decoder_deployment]]
code_hash = "0xb82abd59ade361a014f0abb692f71b0feb880693c3ccb95b9137b73551d872ce"
tx_hash = "0xa0bb58aa58778d63275e6f77856c30d82c46b9b86785a422e25ac3a362e5b2cd"
out_index = 0

[[onchain_decoder_deployment]]
code_hash = "0x1c84212ebd817e9de09d2a79f85cc421b684eda63409cfa75688f98716e77b5f"
tx_hash = "0xa84f9426f378109dfa717cb3a29fb79b764bf466a7c2588aebcdecc874bcc984"
out_index = 0

# DOB/0
[[onchain_decoder_deployment]]
code_hash = "0x13cac78ad8482202f18f9df4ea707611c35f994375fa03ae79121312dda9925c"
tx_hash = "0x71023885a2178648be6a7f138ee49379000a82cda98dd8adabee99eaaca42fde"
out_index = 0

# DOB/1 commit:0bbbfd74966a7d3d4dcadc3d70979855b9e478de
[[onchain_decoder_deployment]]
code_hash = "0xda3525549b72970b4c95f5b5749357f20d1293d335710b674f09c32f7d54b6dc"
tx_hash = "0x99cc81b5e4c311519173f3f6f771dff64a2f64c97f5f724877c4352cd1b3b32c"
out_index = 0


================================================
File: settings.toml
================================================
# identifier of specific DOB protocol versions
protocol_versions = [
    "dob/0",
    "dob/1",
]

# connect to the RPC of CKB node
ckb_rpc = "https://testnet.ckbapp.dev/"

# address that rpc server running at in case of standalone server mode
rpc_server_address = "0.0.0.0:8090"

# directory that stores decoders on hard-disk, including on-chain and off-chain binary files
decoders_cache_directory = "cache/decoders"

# directory that stores DOBs rendering results on hard-disk
dobs_cache_directory = "cache/dobs"

# expiration time indicator for cleaning whole dobs cache, zero means never clean
dobs_cache_expiration_sec = 300

# all deployed on-chain Spore contracts binary hash (order from new to old)
# refer to: https://github.com/sporeprotocol/spore-contract/blob/master/docs/VERSIONS.md
[[available_spores]]
code_hash = "0x685a60219309029d01310311dba953d67029170ca4848a4ff638e57002130a0d"
hash_type = "data1"

[[available_spores]]
code_hash = "0x5e063b4c0e7abeaa6a428df3b693521a3050934cf3b0ae97a800d1bc31449398"
hash_type = "data1"

[[available_spores]]
code_hash = "0x0b1f412fbae26853ff7d082d422c2bdd9e2ff94ee8aaec11240a5b34cc6e890f"
hash_type = "type"

# all deployed on-chain Cluster contracts binary hash (order from new to old)
# refer to: https://github.com/sporeprotocol/spore-contract/blob/master/docs/VERSIONS.md
[[available_clusters]]
code_hash = "0x0bbe768b519d8ea7b96d58f1182eb7e6ef96c541fbd9526975077ee09f049058"
hash_type = "data1"

[[available_clusters]]
code_hash = "0x7366a61534fa7c7e6225ecc0d828ea3b5366adec2b58206f2ee84995fe030075"
hash_type = "data1"

# associate `code_hash` with the corresponding onchain information about `tx_hash` and `out_index`
# server will firstly search onchain decoders by `code_hash` in this configuration, if not found, cache will be used instead
[[onchain_decoder_deployment]]
code_hash = "0xb82abd59ade361a014f0abb692f71b0feb880693c3ccb95b9137b73551d872ce"
tx_hash = "0xb2497dc3e616055125ef8276be7ee21986d2cd4b2ce90992725386cabcb6ea7f"
out_index = 0

[[onchain_decoder_deployment]]
code_hash = "0x32f29aba4b17f3d05bec8cec55d50ef86766fd0bf82fdedaa14269f344d3784a"
tx_hash = "0x8725f0c9a1c634acfd783749c6bdd394c9085aaf4bd2b1ed88f5eb7ed11dfe95"
out_index = 0

[[onchain_decoder_deployment]]
code_hash = "0x1c84212ebd817e9de09d2a79f85cc421b684eda63409cfa75688f98716e77b5f"
tx_hash = "0xc877aca405da6a3038054cb5da20f2db0ed46bb643007d4e0b1d3fe7da155bf0"
out_index = 0

# DOB/0
[[onchain_decoder_deployment]]
code_hash = "0x13cac78ad8482202f18f9df4ea707611c35f994375fa03ae79121312dda9925c"
tx_hash = "0x4a8a0d079f8438bed89e0ece1b14e67ab68e2aa7688a5f4917a59a185e0f8fd5"
out_index = 0

# DOB/1 commit:0bbbfd74966a7d3d4dcadc3d70979855b9e478de
[[onchain_decoder_deployment]]
code_hash = "0xda3525549b72970b4c95f5b5749357f20d1293d335710b674f09c32f7d54b6dc"
tx_hash = "0x18c8f1d55906cf9932c5a72ae4dc039e51e41089db6829edb3f92078c6520bc8"
out_index = 0


================================================
File: .dockerignore
================================================
.git*

*docker-compose*
*Dockerfile*
.dockerignore

target
cache

README.md

settings.*


================================================
File: src/client.rs
================================================
use std::future::Future;
use std::pin::Pin;
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::Arc;

use ckb_jsonrpc_types::{
    CellWithStatus, JsonBytes, OutPoint, TransactionWithStatusResponse, Uint32,
};
use ckb_sdk::rpc::ckb_indexer::{Cell, Order, Pagination, SearchKey, Tx};
use ckb_types::H256;
use jsonrpc_core::futures::FutureExt;
use reqwest::{Client, Url};

use crate::types::Error;

pub type Rpc<T> = Pin<Box<dyn Future<Output = Result<T, Error>> + Send + 'static>>;

#[allow(clippy::upper_case_acronyms)]
enum Target {
    CKB,
    Indexer,
}

macro_rules! jsonrpc {
    ($method:expr, $id:expr, $self:ident, $return:ty$(, $params:ident$(,)?)*) => {{
        let data = format!(
            r#"{{"id": {}, "jsonrpc": "2.0", "method": "{}", "params": {}}}"#,
            $self.id.load(Ordering::Relaxed),
            $method,
            serde_json::to_value(($($params,)*)).unwrap()
        );
        $self.id.fetch_add(1, Ordering::Relaxed);

        let req_json: serde_json::Value = serde_json::from_str(&data).unwrap();

        let url = match $id {
            Target::CKB => $self.ckb_uri.clone(),
            Target::Indexer => $self.indexer_uri.clone(),
        };
        let c = $self.raw.post(url).json(&req_json);
        async {
            let resp = c
                .send()
                .await
                .map_err::<Error, _>(|e| Error::JsonRpcRequestError(e.to_string()))?;
            let output = resp
                .json::<jsonrpc_core::response::Output>()
                .await
                .map_err::<Error, _>(|e| Error::JsonRpcRequestError(e.to_string()))?;

            match output {
                jsonrpc_core::response::Output::Success(success) => {
                    Ok(serde_json::from_value::<$return>(success.result).unwrap())
                }
                jsonrpc_core::response::Output::Failure(e) => {
                    Err(Error::JsonRpcRequestError(e.error.to_string()))
                }
            }
        }
    }}
}

#[derive(Clone)]
pub struct RpcClient {
    raw: Client,
    ckb_uri: Url,
    indexer_uri: Url,
    id: Arc<AtomicU64>,
}

impl RpcClient {
    pub fn new(ckb_uri: &str, indexer_uri: &str) -> Self {
        let ckb_uri = Url::parse(ckb_uri).expect("ckb uri, e.g. \"http://127.0.0.1:8114\"");
        let indexer_uri = Url::parse(indexer_uri).expect("ckb uri, e.g. \"http://127.0.0.1:8116\"");

        RpcClient {
            raw: Client::new(),
            ckb_uri,
            indexer_uri,
            id: Arc::new(AtomicU64::new(0)),
        }
    }
}

impl RpcClient {
    pub fn get_live_cell(&self, out_point: &OutPoint, with_data: bool) -> Rpc<CellWithStatus> {
        jsonrpc!(
            "get_live_cell",
            Target::CKB,
            self,
            CellWithStatus,
            out_point,
            with_data
        )
        .boxed()
    }

    pub fn get_cells(
        &self,
        search_key: SearchKey,
        limit: u32,
        cursor: Option<JsonBytes>,
    ) -> Rpc<Pagination<Cell>> {
        let order = Order::Asc;
        let limit = Uint32::from(limit);

        jsonrpc!(
            "get_cells",
            Target::Indexer,
            self,
            Pagination<Cell>,
            search_key,
            order,
            limit,
            cursor,
        )
        .boxed()
    }

    pub fn get_transactions(
        &self,
        search_key: SearchKey,
        limit: u32,
        cursor: Option<JsonBytes>,
    ) -> Rpc<Pagination<Tx>> {
        let order = Order::Asc;
        let limit = Uint32::from(limit);

        jsonrpc!(
            "get_transactions",
            Target::Indexer,
            self,
            Pagination<Tx>,
            search_key,
            order,
            limit,
            cursor,
        )
        .boxed()
    }

    pub fn get_transaction(&self, hash: &H256) -> Rpc<Option<TransactionWithStatusResponse>> {
        jsonrpc!(
            "get_transaction",
            Target::CKB,
            self,
            Option<TransactionWithStatusResponse>,
            hash,
        )
        .boxed()
    }
}


================================================
File: src/lib.rs
================================================
#[cfg(test)]
mod tests;
mod vm;

pub mod client;
pub mod decoder;
pub mod types;


================================================
File: src/main.rs
================================================
use std::fs;

use jsonrpsee::{server::ServerBuilder, tracing};
use server::DecoderRpcServer;
use tracing_subscriber::EnvFilter;

mod client;
mod decoder;
mod server;
mod types;
mod vm;

const SETTINGS_FILE: &str = "./settings.toml";

#[tokio::main]
async fn main() {
    tracing_subscriber::fmt()
        .with_env_filter(EnvFilter::from_default_env())
        .init();

    tracing::info!("loading settings file from {SETTINGS_FILE}");
    let settings_file = fs::read_to_string(SETTINGS_FILE).expect("read settings.toml");
    let settings: types::Settings = toml::from_str(&settings_file).expect("parse settings.toml");
    tracing::debug!(
        "server settings: {}",
        serde_json::to_string_pretty(&settings).unwrap()
    );
    let rpc_server_address = settings.rpc_server_address.clone();
    let cache_expiration = settings.dobs_cache_expiration_sec;
    let decoder = decoder::DOBDecoder::new(settings);

    tracing::info!("running decoder server at {}", rpc_server_address);
    let http_server = ServerBuilder::new()
        .http_only()
        .build(rpc_server_address)
        .await
        .expect("build http_server");

    let rpc_methods = server::DecoderStandaloneServer::new(decoder, cache_expiration);
    let handler = http_server.start(rpc_methods.into_rpc());

    tokio::signal::ctrl_c().await.unwrap();
    tracing::info!("stopping decoder server");
    handler.stop().unwrap();
}


================================================
File: src/server.rs
================================================
use std::fs;
use std::path::PathBuf;
use std::time::{Duration, SystemTime, UNIX_EPOCH};

use jsonrpsee::core::async_trait;
use jsonrpsee::{proc_macros::rpc, tracing, types::error::ErrorObjectOwned};
use serde::Serialize;
use serde_json::Value;

use crate::decoder::helpers::{decode_cluster_data, decode_spore_data};
use crate::decoder::DOBDecoder;
use crate::types::Error;

// decoding result contains rendered result from native decoder and DNA string for optional use
#[derive(Serialize, Clone, Debug)]
pub struct ServerDecodeResult {
    render_output: String,
    dob_content: Value,
}

#[rpc(server)]
trait DecoderRpc {
    #[method(name = "dob_protocol_version")]
    async fn protocol_versions(&self) -> Vec<String>;

    #[method(name = "dob_decode")]
    async fn decode(&self, hexed_spore_id: String) -> Result<String, ErrorObjectOwned>;

    #[method(name = "dob_batch_decode")]
    async fn batch_decode(
        &self,
        hexed_spore_ids: Vec<String>,
    ) -> Result<Vec<String>, ErrorObjectOwned>;

    #[method(name = "dob_raw_decode")]
    async fn raw_decode(
        &self,
        spore_data: String,
        cluster_data: String,
    ) -> Result<String, ErrorObjectOwned>;
}

pub struct DecoderStandaloneServer {
    decoder: DOBDecoder,
    cache_expiration: u64,
}

impl DecoderStandaloneServer {
    pub fn new(decoder: DOBDecoder, cache_expiration: u64) -> Self {
        Self {
            decoder,
            cache_expiration,
        }
    }

    async fn cache_decode(
        &self,
        spore_id: [u8; 32],
        cache_path: PathBuf,
    ) -> Result<(String, Value), Error> {
        let (content, dna, metadata) = self.decoder.fetch_decode_ingredients(spore_id).await?;
        let render_output = self.decoder.decode_dna(&dna, metadata).await?;
        write_dob_to_cache(&render_output, &content, cache_path, self.cache_expiration)?;
        Ok((render_output, content))
    }
}

#[async_trait]
impl DecoderRpcServer for DecoderStandaloneServer {
    async fn protocol_versions(&self) -> Vec<String> {
        self.decoder.protocol_versions()
    }

    // decode DNA in particular spore DOB cell
    async fn decode(&self, hexed_spore_id: String) -> Result<String, ErrorObjectOwned> {
        tracing::info!("decoding spore_id {hexed_spore_id}");
        let spore_id: [u8; 32] = hex::decode(trim_0x(&hexed_spore_id))
            .map_err(|_| Error::HexedSporeIdParseError)?
            .try_into()
            .map_err(|_| Error::SporeIdLengthInvalid)?;
        let mut cache_path = self.decoder.setting().dobs_cache_directory.clone();
        cache_path.push(format!("{}.dob", hex::encode(spore_id)));
        let (render_output, dob_content) =
            if let Some(cache) = read_dob_from_cache(cache_path.clone(), self.cache_expiration)? {
                cache
            } else {
                self.cache_decode(spore_id, cache_path).await?
            };
        let result = serde_json::to_string(&ServerDecodeResult {
            render_output,
            dob_content,
        })
        .unwrap();
        tracing::info!("spore_id {hexed_spore_id}, result: {result}");
        Ok(result)
    }

    // decode DNA from a set
    async fn batch_decode(
        &self,
        hexed_spore_ids: Vec<String>,
    ) -> Result<Vec<String>, ErrorObjectOwned> {
        let mut await_results = Vec::new();
        for hexed_spore_id in hexed_spore_ids {
            await_results.push(self.decode(hexed_spore_id));
        }
        let results = futures::future::join_all(await_results)
            .await
            .into_iter()
            .map(|result| match result {
                Ok(result) => result,
                Err(error) => format!("server error: {error}"),
            })
            .collect();
        Ok(results)
    }

    // decode directly from spore and cluster data
    async fn raw_decode(
        &self,
        hexed_spore_data: String,
        hexed_cluster_data: String,
    ) -> Result<String, ErrorObjectOwned> {
        let spore_data =
            hex::decode(trim_0x(&hexed_spore_data)).map_err(|_| Error::SporeDataUncompatible)?;
        let cluster_data = hex::decode(trim_0x(&hexed_cluster_data))
            .map_err(|_| Error::ClusterDataUncompatible)?;
        let dob = decode_spore_data(&spore_data)?;
        let dob_metadata = decode_cluster_data(&cluster_data)?;
        let render_output = self.decoder.decode_dna(&dob.dna, dob_metadata).await?;
        let result = serde_json::to_string(&ServerDecodeResult {
            render_output,
            dob_content: dob.content,
        })
        .unwrap();
        tracing::info!("raw, result: {result}");
        Ok(result)
    }
}

fn trim_0x(hexed: &str) -> &str {
    hexed.trim_start_matches("0x")
}

fn read_dob_from_cache(
    cache_path: PathBuf,
    mut expiration: u64,
) -> Result<Option<(String, Value)>, Error> {
    if !cache_path.exists() {
        return Ok(None);
    }
    let file_content = fs::read_to_string(&cache_path)
        .map_err(|_| Error::DOBRenderCacheNotFound(cache_path.clone()))?;
    let mut lines = file_content.split('\n');
    let (Some(result), Some(content), timestamp) = (lines.next(), lines.next(), lines.next())
    else {
        return Err(Error::DOBRenderCacheModified(cache_path));
    };
    if let Some(value) = timestamp {
        if !value.is_empty() {
            expiration = value
                .parse::<u64>()
                .map_err(|_| Error::DOBRenderCacheModified(cache_path.clone()))?;
        }
    }
    match serde_json::from_str(content) {
        Ok(content) => {
            if expiration > 0 && now()? > Duration::from_secs(expiration) {
                Ok(None)
            } else {
                Ok(Some((result.to_string(), content)))
            }
        }
        Err(_) => Err(Error::DOBRenderCacheModified(cache_path)),
    }
}

fn write_dob_to_cache(
    render_result: &str,
    dob_content: &Value,
    cache_path: PathBuf,
    cache_expiration: u64,
) -> Result<(), Error> {
    let expiration_timestamp = if cache_expiration > 0 {
        now()?
            .checked_add(Duration::from_secs(cache_expiration))
            .ok_or(Error::SystemTimeError)?
            .as_secs()
    } else {
        0 // zero means always read from cache
    };
    let json_dob_content = serde_json::to_string(dob_content).unwrap();
    let file_content = format!("{render_result}\n{json_dob_content}\n{expiration_timestamp}");
    fs::write(&cache_path, file_content).map_err(|_| Error::DOBRenderCacheNotFound(cache_path))?;
    Ok(())
}

fn now() -> Result<Duration, Error> {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .map_err(|_| Error::SystemTimeError)
}


================================================
File: src/types.rs
================================================
use std::path::PathBuf;

use ckb_jsonrpc_types::Script;
use ckb_types::{core::ScriptHashType, H256};
use serde::{ser::SerializeMap, Deserialize};
use serde_json::Value;

#[cfg(feature = "standalone_server")]
use jsonrpsee::types::ErrorObjectOwned;
#[cfg(feature = "standalone_server")]
use serde::Serialize;

#[allow(clippy::enum_variant_names)]
#[derive(thiserror::Error, Debug)]
pub enum Error {
    #[error("DOB version number only support 0 and 1, please check your cluster config")]
    DOBVersionNumberUndefined,
    #[error("spore id byte length should be equal to 32")]
    SporeIdLengthInvalid,
    #[error("decoder of spore dob is not set into server's configuration")]
    NativeDecoderNotFound,
    #[error("spore id not found from ckb network")]
    SporeIdNotFound(String),
    #[error("spore data is not in format of spore protocol")]
    SporeDataUncompatible,
    #[error("content type of spore is not in utf-8 format")]
    SporeDataContentTypeUncompatible,
    #[error("declared dob version `{0}` isn't set into server's configuration")]
    DOBVersionUnexpected(String),
    #[error("cluster id not found in spore data")]
    ClusterIdNotSet,
    #[error("cluster id `{0}` not found from ckb network")]
    ClusterIdNotFound(String),
    #[error("cluster data is not in format of spore protocol")]
    ClusterDataUncompatible,
    #[error("decoder script configured in cluster not found from ckb network")]
    DecoderIdNotFound,
    #[error("output of decoder program not in format json")]
    DecoderOutputInvalid,
    #[error("decoder program outputs nothing, please check decoder program code")]
    DecoderOutputEmpty,
    #[error("spore id string is not in hex format")]
    HexedSporeIdParseError,
    #[error("configured decoder binary persistence path is unwriteable")]
    DecoderBinaryPathInvalid,
    #[error("execute_riscv_binary call failed: {0}")]
    DecoderExecutionError(String),
    #[error("decoder program triggered an error code: {0}")]
    DecoderExecutionInternalError(i8),
    #[error("get_cells or get_live_cell rpc failed: {0}")]
    FetchLiveCellsError(String),
    #[error("get_transaction or get_transactions rpc failed: {0}")]
    FetchTransactionError(String),
    #[error("decoder cell not found in outpoint({0}:{1})")]
    DecoderCellNotFound(String, u32),
    #[error("spore content doesn't follow the specs of DOB protocol")]
    DOBContentUnexpected,
    #[error("cluster description doesn't follow the specs of DOB protocol")]
    DOBMetadataUnexpected,
    #[error("configured DOB render cache file `{0}` is unwriteable or unreadable")]
    DOBRenderCacheNotFound(PathBuf),
    #[error("DOB render cache file `{0}` has been mannually modified")]
    DOBRenderCacheModified(PathBuf),
    #[error("cached decoder binary file `{0}` has modified")]
    DecoderBinaryHashInvalid(PathBuf),
    #[error("deployed decoder cell has empty cell data")]
    DecoderBinaryNotFoundInCell,
    #[error("JSON-RPC requesting error: {0}")]
    JsonRpcRequestError(String),
    #[error("system time calculation error")]
    SystemTimeError,
    #[error("decoder in cluster used code_hash or type_id type, but no `hash` field found")]
    DecoderHashNotFound,
    #[error("decoder in cluster used type_script type, but no `script` field found")]
    DecoderScriptNotFound,
    #[error("decoders configured in cluster are empty, please check your cluster config")]
    DecoderChainIsEmpty,
}

pub enum Dob<'a> {
    V0(&'a DOBClusterFormatV0),
    V1(&'a DOBClusterFormatV1),
}

#[cfg(feature = "standalone_server")]
impl From<Error> for ErrorObjectOwned {
    fn from(value: Error) -> Self {
        let message = value.to_string();
        Self::owned::<serde_json::Value>(-1, message, None)
    }
}

// value on `description` field in Cluster data, adapting for DOB protocol in JSON format
#[derive(Deserialize)]
#[cfg_attr(test, derive(serde::Serialize, PartialEq, Debug))]
pub struct ClusterDescriptionField {
    pub description: String,
    pub dob: DOBClusterFormat,
}

impl ClusterDescriptionField {
    pub fn unbox_dob(&self) -> Result<Dob, Error> {
        match self.dob.ver {
            Some(0) | None => {
                let dob0 = self
                    .dob
                    .dob_ver_0
                    .as_ref()
                    .ok_or(Error::ClusterDataUncompatible)?;
                Ok(Dob::V0(dob0))
            }
            Some(1) => {
                let dob1 = self
                    .dob
                    .dob_ver_1
                    .as_ref()
                    .ok_or(Error::ClusterDataUncompatible)?;
                Ok(Dob::V1(dob1))
            }
            _ => Err(Error::DOBVersionNumberUndefined),
        }
    }
}

pub struct DOBSporeFormat {
    pub content_type: String,
    pub content: Value,
    pub dna: String,
    pub cluster_id: [u8; 32],
}

// contains `decoder` and `pattern` identifiers
//
// note: if `ver` is empty, `dob_ver_0` must uniquely exist
#[derive(Deserialize)]
#[cfg_attr(feature = "standalone_server", derive(Serialize))]
#[cfg_attr(test, derive(PartialEq, Debug))]
pub struct DOBClusterFormat {
    #[serde(default)]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ver: Option<u8>,
    #[serde(flatten)]
    pub dob_ver_0: Option<DOBClusterFormatV0>,
    #[serde(flatten)]
    pub dob_ver_1: Option<DOBClusterFormatV1>,
}

#[derive(Deserialize)]
#[cfg_attr(feature = "standalone_server", derive(Serialize))]
#[cfg_attr(test, derive(PartialEq, Debug))]
pub struct DOBClusterFormatV0 {
    pub decoder: DOBDecoderFormat,
    pub pattern: Value,
}

#[derive(Deserialize)]
#[cfg_attr(feature = "standalone_server", derive(Serialize))]
#[cfg_attr(test, derive(PartialEq, Debug))]
pub struct DOBClusterFormatV1 {
    pub decoders: Vec<DOBClusterFormatV0>,
}

#[cfg(feature = "standalone_server")]
impl DOBClusterFormat {
    #[allow(dead_code)]
    pub fn new_dob0(dob_ver_0: DOBClusterFormatV0) -> Self {
        Self {
            ver: Some(0),
            dob_ver_0: Some(dob_ver_0),
            dob_ver_1: None,
        }
    }

    #[allow(dead_code)]
    pub fn new_dob1(dob_ver_1: DOBClusterFormatV1) -> Self {
        Self {
            ver: Some(1),
            dob_ver_0: None,
            dob_ver_1: Some(dob_ver_1),
        }
    }
}

// restricted decoder locator type
#[derive(Deserialize)]
#[cfg_attr(feature = "standalone_server", derive(Serialize))]
#[cfg_attr(test, derive(PartialEq, Debug))]
pub enum DecoderLocationType {
    #[serde(rename(serialize = "type_id", deserialize = "type_id"))]
    TypeId,
    #[serde(rename(serialize = "code_hash", deserialize = "code_hash"))]
    CodeHash,
    #[serde(rename(serialize = "type_script", deserialize = "type_script"))]
    TypeScript,
}

// decoder location information
#[derive(Deserialize)]
#[cfg_attr(feature = "standalone_server", derive(Serialize))]
#[cfg_attr(test, derive(PartialEq, Debug))]
pub struct DOBDecoderFormat {
    #[serde(rename(serialize = "type", deserialize = "type"))]
    pub location: DecoderLocationType,
    pub hash: Option<H256>,
    // only exists when `location` is `TypeScript`
    pub script: Option<Script>,
}

// asscoiate `code_hash` of decoder binary with its onchain deployment information
#[cfg_attr(feature = "standalone_server", derive(Serialize, Deserialize))]
#[cfg_attr(test, derive(Default))]
pub struct OnchainDecoderDeployment {
    pub code_hash: H256,
    pub tx_hash: H256,
    pub out_index: u32,
}

#[cfg_attr(feature = "standalone_server", derive(Serialize, Deserialize))]
#[cfg_attr(test, derive(Default))]
pub enum HashType {
    #[serde(rename(serialize = "data", deserialize = "data"))]
    #[cfg_attr(test, default)]
    Data,
    #[serde(rename(serialize = "data1", deserialize = "data1"))]
    Data1,
    #[serde(rename(serialize = "data2", deserialize = "data2"))]
    Data2,
    #[serde(rename(serialize = "type", deserialize = "type"))]
    Type,
}

impl From<&HashType> for ScriptHashType {
    fn from(value: &HashType) -> Self {
        match value {
            HashType::Data => ScriptHashType::Data,
            HashType::Data1 => ScriptHashType::Data1,
            HashType::Data2 => ScriptHashType::Data2,
            HashType::Type => ScriptHashType::Type,
        }
    }
}

#[cfg_attr(feature = "standalone_server", derive(Serialize, Deserialize))]
#[cfg_attr(test, derive(Default))]
pub struct ScriptId {
    pub code_hash: H256,
    pub hash_type: HashType,
}

// standalone server settings in TOML format
#[cfg_attr(feature = "standalone_server", derive(Serialize, Deserialize))]
#[cfg_attr(test, derive(Default))]
pub struct Settings {
    pub protocol_versions: Vec<String>,
    pub ckb_rpc: String,
    pub rpc_server_address: String,
    pub decoders_cache_directory: PathBuf,
    pub dobs_cache_directory: PathBuf,
    pub dobs_cache_expiration_sec: u64,
    pub onchain_decoder_deployment: Vec<OnchainDecoderDeployment>,
    pub available_spores: Vec<ScriptId>,
    pub available_clusters: Vec<ScriptId>,
}

#[cfg_attr(feature = "standalone_server", derive(Serialize, Deserialize))]
#[derive(Default, Clone)]
pub struct StandardDOBOutput {
    pub name: String,
    pub traits: Vec<ParsedTrait>,
}

#[derive(Clone)]
pub struct ParsedTrait {
    pub type_: String,
    pub value: Value,
}

impl Serialize for ParsedTrait {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut map = serializer.serialize_map(Some(1))?;
        map.serialize_entry(&self.type_, &self.value)?;
        map.end()
    }
}

impl<'de> Deserialize<'de> for ParsedTrait {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let map: Value = Deserialize::deserialize(deserializer)?;
        map.as_object()
            .and_then(|map| map.iter().next())
            .map(|(type_, value)| {
                Ok(Self {
                    type_: type_.to_string(),
                    value: value.clone(),
                })
            })
            .unwrap_or_else(|| Err(serde::de::Error::custom("invalid ParsedTrait")))
    }
}


================================================
File: src/vm.rs
================================================
// refer to https://github.com/nervosnetwork/ckb-vm/blob/develop/examples/ckb-vm-runner.rs

use std::sync::{Arc, Mutex};

use ckb_vm::cost_model::estimate_cycles;
use ckb_vm::registers::{A0, A7};
use ckb_vm::{Bytes, Memory, Register, SupportMachine, Syscalls};

struct DebugSyscall {
    output: Arc<Mutex<Vec<String>>>,
}

impl<Mac: SupportMachine> Syscalls<Mac> for DebugSyscall {
    fn initialize(&mut self, _machine: &mut Mac) -> Result<(), ckb_vm::error::Error> {
        Ok(())
    }

    fn ecall(&mut self, machine: &mut Mac) -> Result<bool, ckb_vm::error::Error> {
        let code = &machine.registers()[A7];
        if code.to_i32() != 2177 {
            return Ok(false);
        }

        let mut addr = machine.registers()[A0].to_u64();
        let mut buffer = Vec::new();

        loop {
            let byte = machine
                .memory_mut()
                .load8(&Mac::REG::from_u64(addr))?
                .to_u8();
            if byte == 0 {
                break;
            }
            buffer.push(byte);
            addr += 1;
        }

        self.output
            .clone()
            .lock()
            .unwrap()
            .push(String::from_utf8(buffer).unwrap());

        Ok(true)
    }
}

fn main_asm(
    code: Bytes,
    args: Vec<Bytes>,
) -> Result<(i8, Vec<String>), Box<dyn std::error::Error>> {
    let debug_result = Arc::new(Mutex::new(Vec::new()));
    let debug = Box::new(DebugSyscall {
        output: debug_result.clone(),
    });

    let asm_core = ckb_vm::machine::asm::AsmCoreMachine::new(
        ckb_vm::ISA_IMC | ckb_vm::ISA_B | ckb_vm::ISA_MOP | ckb_vm::ISA_A,
        ckb_vm::machine::VERSION2,
        u64::MAX,
    );
    let core = ckb_vm::DefaultMachineBuilder::new(asm_core)
        .instruction_cycle_func(Box::new(estimate_cycles))
        .syscall(debug)
        .build();
    let mut machine = ckb_vm::machine::asm::AsmMachine::new(core);
    machine.load_program(&code, &args)?;

    let error_code = machine.run()?;
    let result = debug_result.lock().unwrap().clone();
    Ok((error_code, result))
}

pub fn execute_riscv_binary(
    binary_path: &str,
    args: Vec<Bytes>,
) -> Result<(i8, Vec<String>), Box<dyn std::error::Error>> {
    let code = std::fs::read(binary_path)?.into();
    main_asm(code, args)
}


================================================
File: src/decoder/helpers.rs
================================================
use std::path::PathBuf;

use ckb_jsonrpc_types::Either;
use ckb_sdk::{constants::TYPE_ID_CODE_HASH, rpc::ckb_indexer::Tx, traits::CellQueryOptions};
use ckb_types::{
    core::ScriptHashType,
    packed::{OutPoint, Script},
    prelude::{Builder, Entity, Pack},
    H256,
};
use serde_json::Value;
use spore_types::{generated::spore::ClusterData, SporeData};

use crate::{
    client::RpcClient,
    types::{
        ClusterDescriptionField, DOBDecoderFormat, DOBSporeFormat, DecoderLocationType, Error,
        ScriptId, Settings,
    },
};

fn build_type_id_search_option(type_id_args: [u8; 32]) -> CellQueryOptions {
    let type_script = Script::new_builder()
        .code_hash(TYPE_ID_CODE_HASH.0.pack())
        .hash_type(ScriptHashType::Type.into())
        .args(type_id_args.to_vec().pack())
        .build();
    CellQueryOptions::new_type(type_script)
}

fn build_type_script_search_option(type_script: Script) -> CellQueryOptions {
    CellQueryOptions::new_type(type_script)
}

fn build_batch_search_options(
    type_args: &[u8; 32],
    available_script_ids: &[ScriptId],
) -> Vec<CellQueryOptions> {
    available_script_ids
        .iter()
        .map(
            |ScriptId {
                 code_hash,
                 hash_type,
             }| {
                let hash_type: ScriptHashType = hash_type.into();
                let type_script = Script::new_builder()
                    .code_hash(code_hash.0.pack())
                    .hash_type(hash_type.into())
                    .args(type_args.to_vec().pack())
                    .build();
                CellQueryOptions::new_type(type_script)
            },
        )
        .collect()
}

pub fn decode_spore_data(spore_data: &[u8]) -> Result<DOBSporeFormat, Error> {
    let molecule_spore_data =
        SporeData::from_compatible_slice(spore_data).map_err(|_| Error::SporeDataUncompatible)?;
    let content_type = String::from_utf8(molecule_spore_data.content_type().raw_data().to_vec())
        .map_err(|_| Error::SporeDataContentTypeUncompatible)?;
    let cluster_id = molecule_spore_data
        .cluster_id()
        .to_opt()
        .ok_or(Error::ClusterIdNotSet)?
        .raw_data();
    let (content, dna) = decode_spore_content(&molecule_spore_data.content().raw_data())?;
    Ok(DOBSporeFormat {
        content_type,
        content,
        dna,
        cluster_id: cluster_id.to_vec().try_into().unwrap(),
    })
}

pub fn decode_spore_content(content: &[u8]) -> Result<(Value, String), Error> {
    if content[0] == 0u8 {
        let dna = hex::encode(&content[1..]);
        return Ok((serde_json::Value::String(dna.clone()), dna));
    }

    let value: Value = serde_json::from_slice(content).map_err(|_| Error::DOBContentUnexpected)?;
    let dna = match &value {
        serde_json::Value::String(_) => &value,
        serde_json::Value::Array(array) => array.first().ok_or(Error::DOBContentUnexpected)?,
        serde_json::Value::Object(object) => {
            object.get("dna").ok_or(Error::DOBContentUnexpected)?
        }
        _ => return Err(Error::DOBContentUnexpected),
    };
    let dna = match dna {
        serde_json::Value::String(string) => string.to_owned(),
        _ => return Err(Error::DOBContentUnexpected),
    };

    Ok((value, dna))
}

// search on-chain spore cell and return its content field, which represents dob content
pub async fn fetch_dob_content(
    rpc: &RpcClient,
    settings: &Settings,
    spore_id: [u8; 32],
) -> Result<DOBSporeFormat, Error> {
    let mut spore_cell_data = None;
    for spore_search_option in build_batch_search_options(&spore_id, &settings.available_spores) {
        let spore_mint_tx = rpc
            .get_transactions(spore_search_option.into(), 1, None)
            .await
            .map_err(|e| Error::FetchTransactionError(e.to_string()))?
            .objects
            .first()
            .cloned();
        if let Some(Tx::Ungrouped(mint)) = spore_mint_tx {
            let Some(tx) = rpc
                .get_transaction(&mint.tx_hash)
                .await
                .map_err(|e| Error::FetchTransactionError(e.to_string()))?
            else {
                continue;
            };
            let Some(tx) = tx.transaction else {
                continue;
            };
            let tx = match tx.inner {
                Either::Left(view) => view,
                Either::Right(bytes) => serde_json::from_slice(&bytes.into_bytes())
                    .map_err(|e| Error::FetchTransactionError(e.to_string()))?,
            };
            spore_cell_data = Some(
                tx.inner
                    .outputs_data
                    .get(mint.io_index.value() as usize)
                    .cloned()
                    .unwrap_or_default(),
            );
            break;
        }
    }
    let Some(spore_cell_data) = spore_cell_data else {
        return Err(Error::SporeIdNotFound(hex::encode(spore_id)));
    };
    let dob = decode_spore_data(spore_cell_data.as_bytes())?;
    if !dob.content_type.is_empty()
        && !settings
            .protocol_versions
            .iter()
            .any(|version| dob.content_type.starts_with(version))
    {
        return Err(Error::DOBVersionUnexpected(dob.content_type));
    }
    Ok(dob)
}

// search on-chain cluster cell and return its description field, which contains dob metadata
pub async fn fetch_dob_metadata(
    rpc: &RpcClient,
    settings: &Settings,
    cluster_id: [u8; 32],
) -> Result<ClusterDescriptionField, Error> {
    let mut cluster_cell = None;
    for cluster_search_option in
        build_batch_search_options(&cluster_id, &settings.available_clusters)
    {
        cluster_cell = rpc
            .get_cells(cluster_search_option.into(), 1, None)
            .await
            .map_err(|e| Error::FetchLiveCellsError(e.to_string()))?
            .objects
            .first()
            .cloned();
        if cluster_cell.is_some() {
            break;
        }
    }
    let Some(cluster_cell) = cluster_cell else {
        return Err(Error::ClusterIdNotFound(hex::encode(cluster_id)));
    };
    decode_cluster_data(cluster_cell.output_data.unwrap_or_default().as_bytes())
}

pub fn decode_cluster_data(cluster_data: &[u8]) -> Result<ClusterDescriptionField, Error> {
    let molecule_cluster_data = ClusterData::from_compatible_slice(cluster_data)
        .map_err(|_| Error::ClusterDataUncompatible)?;
    let dob_metadata = serde_json::from_slice(&molecule_cluster_data.description().raw_data())
        .map_err(|_| Error::DOBMetadataUnexpected)?;
    Ok(dob_metadata)
}

// search on-chain decoder cell, deployed with type_id feature enabled
async fn fetch_decoder_binary(
    rpc: &RpcClient,
    decoder_search_option: CellQueryOptions,
) -> Result<Vec<u8>, Error> {
    let decoder_cell = rpc
        .get_cells(decoder_search_option.into(), 1, None)
        .await
        .map_err(|e| Error::FetchLiveCellsError(e.to_string()))?
        .objects
        .first()
        .cloned()
        .ok_or(Error::DecoderIdNotFound)?;
    Ok(decoder_cell
        .output_data
        .unwrap_or_default()
        .as_bytes()
        .into())
}

// search on-chain decoder cell, directly by its tx_hash and out_index
async fn fetch_decoder_binary_directly(
    rpc: &RpcClient,
    tx_hash: H256,
    out_index: u32,
) -> Result<Vec<u8>, Error> {
    let decoder_cell = rpc
        .get_live_cell(&OutPoint::new(tx_hash.pack(), out_index).into(), true)
        .await
        .map_err(|e| Error::FetchLiveCellsError(e.to_string()))?;
    let decoder_binary = decoder_cell
        .cell
        .ok_or(Error::DecoderCellNotFound(hex::encode(tx_hash), out_index))?
        .data
        .ok_or(Error::DecoderBinaryNotFoundInCell)?
        .content;
    Ok(decoder_binary.as_bytes().to_vec())
}

pub async fn parse_decoder_path(
    rpc: &RpcClient,
    decoder: &DOBDecoderFormat,
    settings: &Settings,
) -> Result<PathBuf, Error> {
    let mut decoder_path = settings.decoders_cache_directory.clone();
    match decoder.location {
        DecoderLocationType::CodeHash => {
            let hash = decoder.hash.as_ref().ok_or(Error::DecoderHashNotFound)?;
            decoder_path.push(format!("code_hash_{}.bin", hex::encode(hash)));
            if !decoder_path.exists() {
                let onchain_decoder =
                    settings
                        .onchain_decoder_deployment
                        .iter()
                        .find_map(|deployment| {
                            if &deployment.code_hash == hash {
                                Some(fetch_decoder_binary_directly(
                                    rpc,
                                    deployment.tx_hash.clone(),
                                    deployment.out_index,
                                ))
                            } else {
                                None
                            }
                        });
                let Some(decoder_binary) = onchain_decoder else {
                    return Err(Error::NativeDecoderNotFound);
                };
                let decoder_file_content = decoder_binary.await?;
                if ckb_hash::blake2b_256(&decoder_file_content) != hash.0 {
                    return Err(Error::DecoderBinaryHashInvalid(decoder_path));
                }
                std::fs::write(decoder_path.clone(), decoder_file_content)
                    .map_err(|_| Error::DecoderBinaryPathInvalid)?;
            }
        }
        DecoderLocationType::TypeId => {
            let hash = decoder.hash.as_ref().ok_or(Error::DecoderHashNotFound)?;
            decoder_path.push(format!("type_id_{}.bin", hex::encode(hash)));
            if !decoder_path.exists() {
                let decoder_search_option = build_type_id_search_option(hash.clone().into());
                let decoder_binary = fetch_decoder_binary(rpc, decoder_search_option).await?;
                std::fs::write(decoder_path.clone(), decoder_binary)
                    .map_err(|_| Error::DecoderBinaryPathInvalid)?;
            }
        }
        DecoderLocationType::TypeScript => {
            let script: Script = decoder
                .script
                .clone()
                .ok_or(Error::DecoderScriptNotFound)?
                .into();
            decoder_path.push(format!(
                "type_script_{}.bin",
                hex::encode(script.calc_script_hash().raw_data())
            ));
            if !decoder_path.exists() {
                let decoder_search_option = build_type_script_search_option(script);
                let decoder_binary = fetch_decoder_binary(rpc, decoder_search_option).await?;
                std::fs::write(decoder_path.clone(), decoder_binary)
                    .map_err(|_| Error::DecoderBinaryPathInvalid)?;
            }
        }
    };
    Ok(decoder_path)
}


================================================
File: src/decoder/mod.rs
================================================
use serde_json::Value;

use crate::{
    client::RpcClient,
    types::{
        ClusterDescriptionField, DOBClusterFormatV0, DOBClusterFormatV1, Dob, Error, Settings,
        StandardDOBOutput,
    },
};

pub(crate) mod helpers;
use helpers::*;

pub struct DOBDecoder {
    rpc: RpcClient,
    settings: Settings,
}

impl DOBDecoder {
    pub fn new(settings: Settings) -> Self {
        Self {
            rpc: RpcClient::new(&settings.ckb_rpc, &settings.ckb_rpc),
            settings,
        }
    }

    pub fn protocol_versions(&self) -> Vec<String> {
        self.settings.protocol_versions.clone()
    }

    pub fn setting(&self) -> &Settings {
        &self.settings
    }

    pub async fn fetch_decode_ingredients(
        &self,
        spore_id: [u8; 32],
    ) -> Result<(Value, String, ClusterDescriptionField), Error> {
        let spore = fetch_dob_content(&self.rpc, &self.settings, spore_id).await?;
        let dob_metadata = fetch_dob_metadata(&self.rpc, &self.settings, spore.cluster_id).await?;
        Ok((spore.content, spore.dna, dob_metadata))
    }

    // decode DNA under target spore_id
    pub async fn decode_dna(
        &self,
        dna: &str,
        dob_metadata: ClusterDescriptionField,
    ) -> Result<String, Error> {
        let dob = dob_metadata.unbox_dob()?;
        match dob {
            Dob::V0(dob0) => self.decode_dob0_dna(dna, dob0).await,
            Dob::V1(dob1) => self.decode_dob1_dna(dna, dob1).await,
        }
    }

    // decode specificly for objects under DOB/0 protocol
    async fn decode_dob0_dna(&self, dna: &str, dob0: &DOBClusterFormatV0) -> Result<String, Error> {
        let decoder_path = parse_decoder_path(&self.rpc, &dob0.decoder, &self.settings).await?;
        let pattern = match &dob0.pattern {
            Value::String(string) => string.to_owned(),
            pattern => pattern.to_string(),
        };
        let raw_render_result = {
            let (exit_code, outputs) = crate::vm::execute_riscv_binary(
                &decoder_path.to_string_lossy(),
                vec![dna.to_owned().into(), pattern.into()],
            )
            .map_err(|e| Error::DecoderExecutionError(e.to_string()))?;
            #[cfg(feature = "render_debug")]
            {
                println!("\n-------- DOB/0 DECODE RESULT ({exit_code}) ---------");
                outputs.iter().for_each(|output| println!("{output}"));
                println!("-------- DOB/0 DECODE RESULT END ---------");
            }
            if exit_code != 0 {
                return Err(Error::DecoderExecutionInternalError(exit_code));
            }
            outputs.first().ok_or(Error::DecoderOutputEmpty)?.clone()
        };
        Ok(raw_render_result)
    }

    // decode specificly for objects under DOB/1 protocol
    async fn decode_dob1_dna(&self, dna: &str, dob1: &DOBClusterFormatV1) -> Result<String, Error> {
        let mut output = Option::<Vec<StandardDOBOutput>>::None;
        for (i, value) in dob1.decoders.iter().enumerate() {
            let decoder_path =
                parse_decoder_path(&self.rpc, &value.decoder, &self.settings).await?;
            let pattern = match &value.pattern {
                Value::String(string) => string.to_owned(),
                pattern => pattern.to_string(),
            };
            let raw_render_result = {
                let args = if let Some(previous_output) = &output {
                    vec![
                        dna.to_owned().into(),
                        pattern.into(),
                        serde_json::to_string(previous_output)
                            .expect("parsed_dna")
                            .into(),
                    ]
                } else {
                    vec![dna.to_owned().into(), pattern.into()]
                };
                let (exit_code, outputs) =
                    crate::vm::execute_riscv_binary(&decoder_path.to_string_lossy(), args)
                        .map_err(|e| Error::DecoderExecutionError(e.to_string()))?;
                #[cfg(feature = "render_debug")]
                {
                    println!("\n-------- DOB/1 DECODE RESULT ({i} => {exit_code}) ---------");
                    outputs.iter().for_each(|output| println!("{output}"));
                    println!("-------- DOB/1 DECODE RESULT END ---------");
                }
                if exit_code != 0 {
                    return Err(Error::DecoderExecutionInternalError(exit_code));
                }
                outputs.first().ok_or(Error::DecoderOutputEmpty)?.clone()
            };
            output = Some(
                serde_json::from_str(&raw_render_result)
                    .map_err(|_| Error::DecoderOutputInvalid)?,
            );
        }
        let Some(output) = output else {
            return Err(Error::DecoderChainIsEmpty);
        };
        Ok(serde_json::to_string(&output).unwrap())
    }
}


================================================
File: src/tests/mod.rs
================================================
use ckb_types::h256;

use crate::types::{HashType, OnchainDecoderDeployment, ScriptId, Settings};

mod dob0;
mod dob1;

fn prepare_settings(version: &str) -> Settings {
    Settings {
        ckb_rpc: "https://testnet.ckbapp.dev/".to_string(),
        protocol_versions: vec![version.to_string()],
        decoders_cache_directory: "cache/decoders".parse().unwrap(),
        dobs_cache_directory: "cache/dobs".parse().unwrap(),
        available_spores: vec![
            ScriptId {
                code_hash: h256!(
                    "0x685a60219309029d01310311dba953d67029170ca4848a4ff638e57002130a0d"
                ),
                hash_type: HashType::Data1,
            },
            ScriptId {
                code_hash: h256!(
                    "0x5e063b4c0e7abeaa6a428df3b693521a3050934cf3b0ae97a800d1bc31449398"
                ),
                hash_type: HashType::Data1,
            },
        ],
        available_clusters: vec![
            ScriptId {
                code_hash: h256!(
                    "0x0bbe768b519d8ea7b96d58f1182eb7e6ef96c541fbd9526975077ee09f049058"
                ),
                hash_type: HashType::Data1,
            },
            ScriptId {
                code_hash: h256!(
                    "0x7366a61534fa7c7e6225ecc0d828ea3b5366adec2b58206f2ee84995fe030075"
                ),
                hash_type: HashType::Data1,
            },
        ],
        onchain_decoder_deployment: vec![
            OnchainDecoderDeployment {
                code_hash: h256!(
                    "0xb82abd59ade361a014f0abb692f71b0feb880693c3ccb95b9137b73551d872ce"
                ),
                tx_hash: h256!(
                    "0xb2497dc3e616055125ef8276be7ee21986d2cd4b2ce90992725386cabcb6ea7f"
                ),
                out_index: 0,
            },
            OnchainDecoderDeployment {
                code_hash: h256!(
                    "0x32f29aba4b17f3d05bec8cec55d50ef86766fd0bf82fdedaa14269f344d3784a"
                ),
                tx_hash: h256!(
                    "0x987cf95d129a2dcc2cdf7bd387c1bd888fa407e3c5a3d511fd80c80dcf6c6b67"
                ),
                out_index: 0,
            },
        ],
        ..Default::default()
    }
}


================================================
File: src/tests/dob0/decoder.rs
================================================
use ckb_types::{h256, H256};
use serde_json::{json, Value};

use crate::decoder::DOBDecoder;
use crate::tests::prepare_settings;
use crate::types::{
    ClusterDescriptionField, DOBClusterFormat, DOBClusterFormatV0, DOBDecoderFormat,
    DecoderLocationType,
};

const EXPECTED_UNICORN_RENDER_RESULT: &str = "[{\"name\":\"wuxing_yinyang\",\"traits\":[{\"String\":\"3<_>\"}]},{\"name\":\"prev.bgcolor\",\"traits\":[{\"String\":\"(%wuxing_yinyang):['#DBAB00', '#09D3FF', '#A028E9', '#FF3939', '#(135deg, #FE4F4F, #66C084, #00E2E2, #E180E2, #F4EC32)']\"}]},{\"name\":\"prev<%v>\",\"traits\":[{\"String\":\"(%wuxing_yinyang):['#000000', '#000000', '#000000', '#000000', '#000000', '#FFFFFF', '#FFFFFF', '#FFFFFF', '#FFFFFF', '#FFFFFF'])\"}]},{\"name\":\"Spirits\",\"traits\":[{\"String\":\"(%wuxing_yinyang):['Metal, Golden Body', 'Wood, Blue Body', 'Water, White Body', 'Fire, Red Body', 'Earth, Colorful Body']\"}]},{\"name\":\"Yin Yang\",\"traits\":[{\"String\":\"(%wuxing_yinyang):['Yin, Long hair', 'Yin, Long hair', 'Yin, Long hair', 'Yin, Long hair', 'Yin, Long hair', 'Yang, Short Hair', 'Yang, Short Hair', 'Yang, Short Hair', 'Yang, Short Hair', 'Yang, Short Hair']\"}]},{\"name\":\"Talents\",\"traits\":[{\"String\":\"(%wuxing_yinyang):['Guard<~>', 'Death<~>', 'Forget<~>', 'Curse<~>', 'Hermit<~>', 'Attack<~>', 'Revival<~>', 'Summon<~>', 'Prophet<~>', 'Crown<~>']\"}]},{\"name\":\"Horn\",\"traits\":[{\"String\":\"(%wuxing_yinyang):['Praetorian Horn', 'Hel Horn', 'Lethe Horn', 'Necromancer Horn', 'Lao Tsu Horn', 'Warrior Horn', 'Shaman Horn', 'Bard Horn', 'Sibyl Horn', 'Caesar Horn']\"}]},{\"name\":\"Wings\",\"traits\":[{\"String\":\"Sun Wings\"}]},{\"name\":\"Tail\",\"traits\":[{\"String\":\"Meteor Tail\"}]},{\"name\":\"Horseshoes\",\"traits\":[{\"String\":\"Silver Horseshoes\"}]},{\"name\":\"Destiny Number\",\"traits\":[{\"Number\":65321}]},{\"name\":\"Lucky Number\",\"traits\":[{\"Number\":35}]}]";
const EXPECTED_EXAMPLE_RENDER_RESULT: &str = "[{\"name\":\"Name\",\"traits\":[{\"String\":\"Ethan\"}]},{\"name\":\"Age\",\"traits\":[{\"Number\":23}]},{\"name\":\"Score\",\"traits\":[{\"Number\":136}]},{\"name\":\"DNA\",\"traits\":[{\"String\":\"0xaabbcc\"}]},{\"name\":\"URL\",\"traits\":[{\"String\":\"http://127.0.0.1:8090\"}]},{\"name\":\"Value\",\"traits\":[{\"Number\":13417386}]}]";

const UNICORN_SPORE_ID: H256 =
    h256!("0x4f7fb83a65dae9b95c21e55d5776a84f17bb6377681befeedb20a077ce1d8aad");
const EXAMPLE_SPORE_ID: H256 =
    h256!("0x683d0362a2e67d6edc80e3bf16136fae8a7fba21f6cb013931c5994c9ddb8d70");

fn generate_unicorn_dob_ingredients(onchain_decoder: bool) -> (Value, ClusterDescriptionField) {
    let unicorn_content = json!({
        "block_number": 120,
        "cell_id": 11844,
        "dna": "df4ffcb5e7a283ea7e6f09a504d0e256",
    });
    let decoder = if onchain_decoder {
        DOBDecoderFormat {
            location: DecoderLocationType::TypeId,
            hash: Some(h256!(
                "0x564870fab22ae50ac2bf1e986f21f34d5c9b50a30ec5c7bd5bf9f29aafb21a76"
            )),
            script: None,
        }
    } else {
        DOBDecoderFormat {
            location: DecoderLocationType::CodeHash,
            hash: Some(h256!(
                "0x32f29aba4b17f3d05bec8cec55d50ef86766fd0bf82fdedaa14269f344d3784a"
            )),
            script: None,
        }
    };
    let unicorn_metadata = ClusterDescriptionField {
            description: "Unicorns are the first series of digital objects generated based on time and space on CKB. Combining the Birth Time-location Determining Destiny Theory, Five Element Theory and YinYang Theory, it provide a special way for people to get Unicorn's on-chain DNA. Now all the seeds(DNAs) are on chain, and a magic world can expand.".to_string(),
            dob: DOBClusterFormat::new_dob0(DOBClusterFormatV0 {
                decoder,
                pattern: serde_json::from_str("[[\"wuxing_yinyang\",\"string\",0,1,\"options\",[\"0<_>\",\"1<_>\",\"2<_>\",\"3<_>\",\"4<_>\",\"5<_>\",\"6<_>\",\"7<_>\",\"8<_>\",\"9<_>\"]],[\"prev.bgcolor\",\"string\",1,1,\"options\",[\"(%wuxing_yinyang):['#DBAB00', '#09D3FF', '#A028E9', '#FF3939', '#(135deg, #FE4F4F, #66C084, #00E2E2, #E180E2, #F4EC32)']\"]],[\"prev<%v>\",\"string\",2,1,\"options\",[\"(%wuxing_yinyang):['#000000', '#000000', '#000000', '#000000', '#000000', '#FFFFFF', '#FFFFFF', '#FFFFFF', '#FFFFFF', '#FFFFFF'])\"]],[\"Spirits\",\"string\",3,1,\"options\",[\"(%wuxing_yinyang):['Metal, Golden Body', 'Wood, Blue Body', 'Water, White Body', 'Fire, Red Body', 'Earth, Colorful Body']\"]],[\"Yin Yang\",\"string\",4,1,\"options\",[\"(%wuxing_yinyang):['Yin, Long hair', 'Yin, Long hair', 'Yin, Long hair', 'Yin, Long hair', 'Yin, Long hair', 'Yang, Short Hair', 'Yang, Short Hair', 'Yang, Short Hair', 'Yang, Short Hair', 'Yang, Short Hair']\"]],[\"Talents\",\"string\",5,1,\"options\",[\"(%wuxing_yinyang):['Guard<~>', 'Death<~>', 'Forget<~>', 'Curse<~>', 'Hermit<~>', 'Attack<~>', 'Revival<~>', 'Summon<~>', 'Prophet<~>', 'Crown<~>']\"]],[\"Horn\",\"string\",6,1,\"options\",[\"(%wuxing_yinyang):['Praetorian Horn', 'Hel Horn', 'Lethe Horn', 'Necromancer Horn', 'Lao Tsu Horn', 'Warrior Horn', 'Shaman Horn', 'Bard Horn', 'Sibyl Horn', 'Caesar Horn']\"]],[\"Wings\",\"string\",7,1,\"options\",[\"Wind Wings\",\"Night Shadow Wings\",\"Lightning Wings\",\"Sun Wings\",\"Golden Wings\",\"Cloud Wings\",\"Morning Glow Wings\",\"Star Wings\",\"Spring Wings\",\"Moon Wings\",\"Angel Wings\"]],[\"Tail\",\"string\",8,1,\"options\",[\"Meteor Tail\",\"Rainbow Tail\",\"Willow Tail\",\"Phoenix Tail\",\"Sunset Shadow Tail\",\"Socrates Tail\",\"Dumbledore Tail\",\"Venus Tail\",\"Gaia Tail\"]],[\"Horseshoes\",\"string\",9,1,\"options\",[\"Ice Horseshoes\",\"Crystal Horseshoes\",\"Maple Horseshoes\",\"Flame Horseshoes\",\"Thunder Horseshoes\",\"Lotus Horseshoes\",\"Silver Horseshoes\"]],[\"Destiny Number\",\"number\",10,4,\"range\",[50000,100000]],[\"Lucky Number\",\"number\",14,1,\"range\",[1,49]]]").unwrap(),
            }),
        };
    (unicorn_content, unicorn_metadata)
}

fn generate_example_dob_ingredients(onchain_decoder: bool) -> (Value, ClusterDescriptionField) {
    let example_content = json!({
        "block_number": 120,
        "cell_id": 11844,
        "dna": "df4ffcb5e7a283ea7e6f09a504d0e256"
    });
    let decoder = if onchain_decoder {
        DOBDecoderFormat {
            location: DecoderLocationType::TypeId,
            hash: Some(h256!(
                "0x564870fab22ae50ac2bf1e986f21f34d5c9b50a30ec5c7bd5bf9f29aafb21a76"
            )),
            script: None,
        }
    } else {
        DOBDecoderFormat {
            location: DecoderLocationType::CodeHash,
            hash: Some(h256!(
                "0x32f29aba4b17f3d05bec8cec55d50ef86766fd0bf82fdedaa14269f344d3784a"
            )),
            script: None,
        }
    };
    let example_metadata = ClusterDescriptionField {
            description: "DOB/0 example.".to_string(),
            dob: DOBClusterFormat::new_dob0(DOBClusterFormatV0 {
                decoder,
                pattern: serde_json::from_str("[[\"Name\",\"string\",0,1,\"options\",[\"Alice\",\"Bob\",\"Charlie\",\"David\",\"Ethan\",\"Florence\",\"Grace\",\"Helen\"]],[\"Age\",\"number\",1,1,\"range\",[0,100]],[\"Score\",\"number\",2,1,\"raw\"],[\"DNA\",\"string\",3,3,\"raw\"],[\"URL\",\"string\",6,21,\"utf8\"],[\"Value\",\"number\",3,3,\"raw\"]]").unwrap(),
            }),
        };
    (example_content, example_metadata)
}

#[tokio::test]
async fn test_fetch_and_decode_unicorn_dna() {
    let settings = prepare_settings("text/plain");
    let decoder = DOBDecoder::new(settings);
    let (_, dna, dob_metadata) = decoder
        .fetch_decode_ingredients(UNICORN_SPORE_ID.into())
        .await
        .expect("fetch");
    let render_result = decoder
        .decode_dna(&dna, dob_metadata)
        // array type
        .await
        .expect("decode");
    assert_eq!(render_result, EXPECTED_UNICORN_RENDER_RESULT);
}

#[test]
fn test_unicorn_json_serde() {
    let (unicorn_content, unicorn_metadata) = generate_unicorn_dob_ingredients(false);
    let json_unicorn_content = serde_json::to_string(&unicorn_content).unwrap();
    let json_unicorn_metadata = serde_json::to_string(&unicorn_metadata).unwrap();
    println!("[spore_content] = {json_unicorn_content}");
    println!("[cluster_description] = {json_unicorn_metadata}");
    let deser_unicorn_content: Value =
        serde_json::from_slice(json_unicorn_content.as_bytes()).unwrap();
    let deser_unicorn_metadata: ClusterDescriptionField =
        serde_json::from_slice(json_unicorn_metadata.as_bytes()).unwrap();
    assert_eq!(unicorn_content, deser_unicorn_content);
    assert_eq!(unicorn_metadata, deser_unicorn_metadata);
}

#[tokio::test]
async fn test_fetch_and_decode_example_dna() {
    let settings = prepare_settings("text/plain");
    let decoder = DOBDecoder::new(settings);
    let (_, dna, dob_metadata) = decoder
        .fetch_decode_ingredients(EXAMPLE_SPORE_ID.into())
        .await
        .expect("fetch");
    let render_result = decoder
        .decode_dna(&dna, dob_metadata)
        // array type
        .await
        .expect("decode");
    assert_eq!(render_result, EXPECTED_EXAMPLE_RENDER_RESULT);
}

#[test]
fn test_example_json_serde() {
    let (content, metadata) = generate_example_dob_ingredients(false);
    let json_content = serde_json::to_string(&content).unwrap();
    let json_metadata = serde_json::to_string(&metadata).unwrap();
    println!("[spore_content] = {json_content}");
    println!("[cluster_description] = {json_metadata}");
}


================================================
File: src/tests/dob0/legacy_decoder.rs
================================================
use ckb_types::{h256, H256};

use crate::decoder::{helpers::decode_spore_content, DOBDecoder};
use crate::tests::prepare_settings;
use crate::types::{
    ClusterDescriptionField, DOBClusterFormat, DOBClusterFormatV0, DOBDecoderFormat,
    DecoderLocationType,
};
use serde_json::{json, Value};

const EXPECTED_UNICORN_RENDER_RESULT: &str = "[{\"name\":\"wuxing_yinyang\",\"traits\":[{\"String\":\"3<_>\"}]},{\"name\":\"prev.bgcolor\",\"traits\":[{\"String\":\"(%wuxing_yinyang):['#DBAB00', '#09D3FF', '#A028E9', '#FF3939', '#(135deg, #FE4F4F, #66C084, #00E2E2, #E180E2, #F4EC32)']\"}]},{\"name\":\"prev<%v>\",\"traits\":[{\"String\":\"(%wuxing_yinyang):['#000000', '#000000', '#000000', '#000000', '#000000', '#FFFFFF', '#FFFFFF', '#FFFFFF', '#FFFFFF', '#FFFFFF'])\"}]},{\"name\":\"Spirits\",\"traits\":[{\"String\":\"(%wuxing_yinyang):['Metal, Golden Body', 'Wood, Blue Body', 'Water, White Body', 'Fire, Red Body', 'Earth, Colorful Body']\"}]},{\"name\":\"Yin Yang\",\"traits\":[{\"String\":\"(%wuxing_yinyang):['Yin, Long hair', 'Yin, Long hair', 'Yin, Long hair', 'Yin, Long hair', 'Yin, Long hair', 'Yang, Short Hair', 'Yang, Short Hair', 'Yang, Short Hair', 'Yang, Short Hair', 'Yang, Short Hair']\"}]},{\"name\":\"Talents\",\"traits\":[{\"String\":\"(%wuxing_yinyang):['Guard<~>', 'Death<~>', 'Forget<~>', 'Curse<~>', 'Hermit<~>', 'Attack<~>', 'Revival<~>', 'Summon<~>', 'Prophet<~>', 'Crown<~>']\"}]},{\"name\":\"Horn\",\"traits\":[{\"String\":\"(%wuxing_yinyang):['Praetorian Horn', 'Hel Horn', 'Lethe Horn', 'Necromancer Horn', 'Lao Tsu Horn', 'Warrior Horn', 'Shaman Horn', 'Bard Horn', 'Sibyl Horn', 'Caesar Horn']\"}]},{\"name\":\"Wings\",\"traits\":[{\"String\":\"Sun Wings\"}]},{\"name\":\"Tails\",\"traits\":[{\"String\":\"Meteor Tail\"}]},{\"name\":\"Horseshoes\",\"traits\":[{\"String\":\"Silver Horseshoes\"}]},{\"name\":\"Destiny Number\",\"traits\":[{\"Number\":59616}]},{\"name\":\"Lucky Number\",\"traits\":[{\"Number\":35}]}]";
const EXPECTED_NERVAPE_RENDER_RESULT: &str = "[{\"name\":\"prev.type\",\"traits\":[{\"String\":\"text\"}]},{\"name\":\"prev.bg\",\"traits\":[{\"String\":\"btcfs://59e87ca177ef0fd457e87e9f93627660022cf519b531e1f4e3a6dda9e5e33827i0\"}]},{\"name\":\"prev.bgcolor\",\"traits\":[{\"String\":\"#CEBAF7\"}]},{\"name\":\"Background\",\"traits\":[{\"Number\":170}]},{\"name\":\"Suit\",\"traits\":[{\"Number\":236}]},{\"name\":\"Upper body\",\"traits\":[{\"Number\":53}]},{\"name\":\"Lower body\",\"traits\":[{\"Number\":189}]},{\"name\":\"Headwear\",\"traits\":[{\"Number\":175}]},{\"name\":\"Mask\",\"traits\":[{\"Number\":153}]},{\"name\":\"Eyewear\",\"traits\":[{\"Number\":126}]},{\"name\":\"Mouth\",\"traits\":[{\"Number\":14}]},{\"name\":\"Ears\",\"traits\":[{\"Number\":165}]},{\"name\":\"Tattoo\",\"traits\":[{\"Number\":231}]},{\"name\":\"Accessory\",\"traits\":[{\"Number\":78}]},{\"name\":\"Handheld\",\"traits\":[{\"Number\":240}]},{\"name\":\"Special\",\"traits\":[{\"Number\":70}]}]";
const NERVAPE_SPORE_ID: H256 =
    h256!("0x9dd9604d44d6640d1533c9f97f89438f17526e645f6c35aa08d8c7d844578580");

fn generate_nervape_dob_ingredients(onchain_decoder: bool) -> (Value, ClusterDescriptionField) {
    let nervape_content = json!({
        "id": 145,
        "dna": "cde3feaaec35bdaf997e0ea5e74ef046",
    });
    let decoder = if onchain_decoder {
        DOBDecoderFormat {
            location: DecoderLocationType::TypeId,
            hash: Some(h256!(
                "0x11b80e7161c4eed1101e52a5835e9f58008334bc75d5561fefcc62ccc56221cf"
            )),
            script: None,
        }
    } else {
        DOBDecoderFormat {
            location: DecoderLocationType::CodeHash,
            hash: Some(h256!(
                "0xb82abd59ade361a014f0abb692f71b0feb880693c3ccb95b9137b73551d872ce"
            )),
            script: None,
        }
    };
    let nervape_metadata = ClusterDescriptionField {
            description: "Nervape, multi-chain composable digital objects built on Bitcoin.".to_string(),
            dob: DOBClusterFormat::new_dob0(DOBClusterFormatV0 {
                decoder,
                pattern: Value::String("830900004400000087000000370500004206000085060000c2060000050700004807000089070000c6070000060800004408000081080000c00800000209000043090000430000000c0000001900000009000000707265762e747970652a00000008000000220000000c0000000d0000000100000000110000000800000005000000696d616765b00400000c0000001700000007000000707265762e62679904000008000000910400000c0000000d0000000100000000800400003c0000008a000000d80000002601000074010000c2010000100200005e020000ac020000fa0200004803000096030000e4030000320400004a00000062746366733a2f2f3162633234333531613064663265363836353734636431623633343661316635356638316366663061326535323037386136653361643061333563666238333369304a00000062746366733a2f2f3634663536326431366532613461323965386334383231333730666666343733656466613232633236656635383038616462323430346533396463303133653569304a00000062746366733a2f2f6332396665636436643764376565633063623361326233646664636236616132363038316462386639383531313130623763323061306633633631373239396169304a00000062746366733a2f2f3539653837636131373765663066643435376538376539663933363237363630303232636635313962353331653166346533613664646139653565333338323769304a00000062746366733a2f2f6133353839646463663462376133633664613532666536616534656433323936663165646531333966653931323766323639376365306463663237303362363169304a00000062746366733a2f2f3739393732396666366131366464366166353764623161386361363134366435363733613330616439613539373664643836316433343861356565633238633469304a00000062746366733a2f2f3838646432616230356262386639633732646134326166633730363737616330356634373665313765306631363535316463303036333561653765393534366569304a00000062746366733a2f2f6233326533626262373363623837376339623431313532393933306135623665623332383039323762323832633132343836636532363930316233633232393169304a00000062746366733a2f2f6138623139646461623333386462306335326639613238346237643935666665616130646533346530623837343137373930316562393265306639663964386469304a00000062746366733a2f2f6261386231626239643862616565346266323461303666616132356235363934313066326462393662343633396638653038636362656330356338386437396269304a00000062746366733a2f2f6161383938366630656636363738303764346232333937306536343834346464653366303632323534326237396135633330323533396465306333356233316569304a00000062746366733a2f2f3130306637653066303936356463353435313561333833316133323038383133313563663563613634616430316265643262343232363136623135666433313469304a00000062746366733a2f2f6238346563306337373061613139363161336439343938656138613637653132383235333239313366633163313365336561663561343864653231363466623969304a00000062746366733a2f2f6130366261326531363134613530393931373665356363346439356465373663626562343730356138626437653134323333363237386562633239306664623369300b0100000c0000001c0000000c000000707265762e6267636f6c6f72ef00000008000000e70000000c0000000d0000000100000000d60000003c00000047000000520000005d00000068000000730000007e00000089000000940000009f000000aa000000b5000000c0000000cb00000007000000234646453345420700000023464643324645070000002343454241463707000000234237453646390700000023414246344430070000002345304446424407000000234639463741370700000023453242453931070000002346394336363207000000234637443642320700000023464341383633070000002346394143414307000000234530453145320700000023413341374141430000000c0000001a0000000a0000004261636b67726f756e642900000008000000210000000c0000000d00000001030000000000000000000000ff000000000000003d0000000c0000001400000004000000537569742900000008000000210000000c0000000d00000001030000000000000000000000ff00000000000000430000000c0000001a0000000a000000557070657220626f64792900000008000000210000000c0000000d00000001030000000000000000000000ff00000000000000430000000c0000001a0000000a0000004c6f77657220626f64792900000008000000210000000c0000000d00000001030000000000000000000000ff00000000000000410000000c000000180000000800000048656164776561722900000008000000210000000c0000000d00000001030000000000000000000000ff000000000000003d0000000c00000014000000040000004d61736b2900000008000000210000000c0000000d00000001030000000000000000000000ff00000000000000400000000c0000001700000007000000457965776561722900000008000000210000000c0000000d00000001030000000000000000000000ff000000000000003e0000000c00000015000000050000004d6f7574682900000008000000210000000c0000000d00000001030000000000000000000000ff000000000000003d0000000c0000001400000004000000456172732900000008000000210000000c0000000d00000001030000000000000000000000ff000000000000003f0000000c0000001600000006000000546174746f6f2900000008000000210000000c0000000d00000001030000000000000000000000ff00000000000000420000000c00000019000000090000004163636573736f72792900000008000000210000000c0000000d00000001030000000000000000000000ff00000000000000410000000c000000180000000800000048616e6468656c642900000008000000210000000c0000000d00000001030000000000000000000000ff00000000000000400000000c00000017000000070000005370656369616c2900000008000000210000000c0000000d00000001030000000000000000000000ff00000000000000".to_string()),
            }),
        };
    (nervape_content, nervape_metadata)
}

fn generate_unicorn_dob_ingredients(onchain_decoder: bool) -> (Value, ClusterDescriptionField) {
    let unicorn_content = json!({
        "block_number": 120,
        "cell_id": 11844,
        "dna": "df4ffcb5e7a283ea7e6f09a504d0e256"
    });
    let decoder = if onchain_decoder {
        DOBDecoderFormat {
            location: DecoderLocationType::TypeId,
            hash: Some(h256!(
                "0x11b80e7161c4eed1101e52a5835e9f58008334bc75d5561fefcc62ccc56221cf"
            )),
            script: None,
        }
    } else {
        DOBDecoderFormat {
            location: DecoderLocationType::CodeHash,
            hash: Some(h256!(
                "0xb82abd59ade361a014f0abb692f71b0feb880693c3ccb95b9137b73551d872ce"
            )),
            script: None,
        }
    };
    let unicorn_metadata = ClusterDescriptionField {
            description: "Unicorns are the first series of digital objects generated based on time and space on CKB. Combining the Birth Time-location Determining Destiny Theory, Five Element Theory and YinYang Theory, it provide a special way for people to get Unicorn's on-chain DNA. Now all the seeds(DNAs) are on chain, and a magic world can expand.".to_string(),
            dob: DOBClusterFormat::new_dob0(DOBClusterFormatV0 {
                decoder,
                pattern: Value::String("3d09000034000000e7000000a00100005e0200001403000021040000ef040000d4050000e6060000cf070000b1080000f8080000b30000000c0000001e0000000e000000777578696e675f79696e79616e6795000000080000008d0000000c0000000d00000001000000007c0000002c000000340000003c000000440000004c000000540000005c000000640000006c0000007400000004000000303c5f3e04000000313c5f3e04000000323c5f3e04000000333c5f3e04000000343c5f3e04000000353c5f3e04000000363c5f3e04000000373c5f3e04000000383c5f3e04000000393c5f3eb90000000c0000001c0000000c000000707265762e6267636f6c6f729d00000008000000950000000c0000000d00000001000000008400000008000000780000002825777578696e675f79696e79616e67293a5b2723444241423030272c202723303944334646272c202723413032384539272c202723464633393339272c202723283133356465672c20234645344634462c20233636433038342c20233030453245322c20234531383045322c202346344543333229275dbe0000000c0000001800000008000000707265763c25763ea6000000080000009e0000000c0000000d00000001000000008d00000008000000810000002825777578696e675f79696e79616e67293a5b2723303030303030272c202723303030303030272c202723303030303030272c202723303030303030272c202723303030303030272c202723464646464646272c202723464646464646272c202723464646464646272c202723464646464646272c202723464646464646275d29b60000000c0000001700000007000000537069726974739f00000008000000970000000c0000000d000000010000000086000000080000007a0000002825777578696e675f79696e79616e67293a5b274d6574616c2c20476f6c64656e20426f6479272c2027576f6f642c20426c756520426f6479272c202757617465722c20576869746520426f6479272c2027466972652c2052656420426f6479272c202745617274682c20436f6c6f7266756c20426f6479275d0d0100000c000000180000000800000059696e2059616e67f500000008000000ed0000000c0000000d0000000100000000dc00000008000000d00000002825777578696e675f79696e79616e67293a5b2759696e2c204c6f6e672068616972272c202759696e2c204c6f6e672068616972272c202759696e2c204c6f6e672068616972272c202759696e2c204c6f6e672068616972272c202759696e2c204c6f6e672068616972272c202759616e672c2053686f72742048616972272c202759616e672c2053686f72742048616972272c202759616e672c2053686f72742048616972272c202759616e672c2053686f72742048616972272c202759616e672c2053686f72742048616972275dce0000000c000000170000000700000054616c656e7473b700000008000000af0000000c0000000d00000001000000009e00000008000000920000002825777578696e675f79696e79616e67293a5b2747756172643c7e3e272c202744656174683c7e3e272c2027466f726765743c7e3e272c202743757273653c7e3e272c20274865726d69743c7e3e272c202741747461636b3c7e3e272c20275265766976616c3c7e3e272c202753756d6d6f6e3c7e3e272c202750726f706865743c7e3e272c202743726f776e3c7e3e275de50000000c0000001400000004000000486f726ed100000008000000c90000000c0000000d0000000100000000b800000008000000ac0000002825777578696e675f79696e79616e67293a5b2750726165746f7269616e20486f726e272c202748656c20486f726e272c20274c6574686520486f726e272c20274e6563726f6d616e63657220486f726e272c20274c616f2054737520486f726e272c202757617272696f7220486f726e272c20275368616d616e20486f726e272c20274261726420486f726e272c2027536962796c20486f726e272c202743616573617220486f726e275d120100000c000000150000000500000057696e6773fd00000008000000f50000000c0000000d0000000100000000e4000000300000003e0000005400000067000000740000008400000093000000a9000000b7000000c7000000d50000000a00000057696e642057696e6773120000004e6967687420536861646f772057696e67730f0000004c696768746e696e672057696e67730900000053756e2057696e67730c000000476f6c64656e2057696e67730b000000436c6f75642057696e6773120000004d6f726e696e6720476c6f772057696e67730a000000537461722057696e67730c000000537072696e672057696e67730a0000004d6f6f6e2057696e67730b000000416e67656c2057696e6773e90000000c00000015000000050000005461696c73d400000008000000cc0000000c0000000d0000000100000000bb00000028000000370000004700000056000000660000007c0000008d000000a0000000ae0000000b0000004d6574656f72205461696c0c0000005261696e626f77205461696c0b00000057696c6c6f77205461696c0c00000050686f656e6978205461696c1200000053756e73657420536861646f77205461696c0d000000536f637261746573205461696c0f00000044756d626c65646f7265205461696c0a00000056656e7573205461696c0900000047616961205461696ce20000000c0000001a0000000a000000486f72736573686f6573c800000008000000c00000000c0000000d0000000100000000af0000002000000032000000480000005c00000070000000860000009a0000000e00000049636520486f72736573686f6573120000004372797374616c20486f72736573686f6573100000004d61706c6520486f72736573686f657310000000466c616d6520486f72736573686f6573120000005468756e64657220486f72736573686f6573100000004c6f74757320486f72736573686f65731100000053696c76657220486f72736573686f6573470000000c0000001e0000000e00000044657374696e79204e756d6265722900000008000000210000000c0000000d000000040300000050c3000000000000a086010000000000450000000c0000001c0000000c0000004c75636b79204e756d6265722900000008000000210000000c0000000d000000010300000001000000000000003100000000000000".to_string()),
            }),
        };
    (unicorn_content, unicorn_metadata)
}

async fn decode_unicorn_dna(onchain_decoder: bool) -> String {
    let settings = prepare_settings("text/plain");
    let decoder = DOBDecoder::new(settings);
    let (unicorn_content, unicorn_metadata) = generate_unicorn_dob_ingredients(onchain_decoder);
    decoder
        .decode_dna(&unicorn_content["dna"].as_str().unwrap(), unicorn_metadata)
        .await
        .expect("decode")
}

#[tokio::test]
async fn test_decode_unicorn_dna() {
    let render_result = decode_unicorn_dna(false).await;
    assert_eq!(render_result, EXPECTED_UNICORN_RENDER_RESULT);

    let render_result = decode_unicorn_dna(true).await;
    assert_eq!(render_result, EXPECTED_UNICORN_RENDER_RESULT);
}

#[tokio::test]
async fn test_fetch_and_decode_nervape_dna() {
    let settings = prepare_settings("text/plain");
    let decoder = DOBDecoder::new(settings);
    let (_, dna, dob_metadata) = decoder
        .fetch_decode_ingredients(NERVAPE_SPORE_ID.into())
        .await
        .expect("fetch");
    let render_result = decoder
        .decode_dna(&dna, dob_metadata)
        // array type
        .await
        .expect("decode");
    assert_eq!(render_result, EXPECTED_NERVAPE_RENDER_RESULT);
}

#[tokio::test]
#[should_panic = "fetch: DOBVersionUnexpected"]
async fn test_fetch_onchain_dob_failed() {
    let settings = prepare_settings("dob/0");
    DOBDecoder::new(settings)
        .fetch_decode_ingredients(NERVAPE_SPORE_ID.into())
        .await
        .expect("fetch");
}

#[test]
fn test_nervape_json_serde() {
    let (nervape_content, nervape_metadata) = generate_nervape_dob_ingredients(false);
    let json_unicorn_content = serde_json::to_string(&nervape_content).unwrap();
    let json_unicorn_metadata = serde_json::to_string(&nervape_metadata).unwrap();
    println!("[spore_content] = {json_unicorn_content}");
    println!("[cluster_description] = {json_unicorn_metadata}");
    let deser_unicorn_content: Value =
        serde_json::from_slice(json_unicorn_content.as_bytes()).unwrap();
    let deser_unicorn_metadata: ClusterDescriptionField =
        serde_json::from_slice(json_unicorn_metadata.as_bytes()).unwrap();
    assert_eq!(nervape_content, deser_unicorn_content);
    assert_eq!(nervape_metadata, deser_unicorn_metadata);
}

#[test]
fn test_unicorn_json_serde() {
    let (unicorn_content, unicorn_metadata) = generate_unicorn_dob_ingredients(false);
    let json_unicorn_content = serde_json::to_string(&unicorn_content).unwrap();
    let json_unicorn_metadata = serde_json::to_string(&unicorn_metadata).unwrap();
    println!("[spore_content] = {json_unicorn_content}");
    println!("[cluster_description] = {json_unicorn_metadata}");
    let deser_unicorn_content: Value =
        serde_json::from_slice(json_unicorn_content.as_bytes()).unwrap();
    let deser_unicorn_metadata: ClusterDescriptionField =
        serde_json::from_slice(json_unicorn_metadata.as_bytes()).unwrap();
    assert_eq!(unicorn_content, deser_unicorn_content);
    assert_eq!(unicorn_metadata, deser_unicorn_metadata);
}

#[test]
fn test_decode_multiple_spore_data() {
    let dna = "eda7a47a751d2dc42d4b724e47cfd67a";
    [
        format!("{{\"dna\": \"{dna}\"}}"), // object type
        format!("[\"{dna}\"]"),            // array type
        format!("\"{dna}\""),              // string type
    ]
    .into_iter()
    .enumerate()
    .for_each(|(i, spore_data)| {
        let (_, v) =
            decode_spore_content(spore_data.as_bytes()).expect(&format!("assert type index {i}"));
        assert_eq!(v, dna, "object type comparison failed");
    });
}


================================================
File: src/tests/dob0/mod.rs
================================================
mod decoder;
mod legacy_decoder;


================================================
File: src/tests/dob1/decoder.rs
================================================
use ckb_types::h256;
use serde_json::{json, Value};

use crate::{
    decoder::DOBDecoder,
    tests::prepare_settings,
    types::{
        ClusterDescriptionField, DOBClusterFormat, DOBClusterFormatV0, DOBClusterFormatV1,
        DOBDecoderFormat, DecoderLocationType,
    },
};

fn generate_dob1_ingredients() -> (Value, ClusterDescriptionField) {
    let content = json!({
        "dna": "ac7b88aabbcc687474703a2f2f3132372e302e302e313a383039300000"
    });
    let metadata = ClusterDescriptionField {
        description: "DOB/1 SVG Test".to_string(),
        dob: DOBClusterFormat::new_dob1(DOBClusterFormatV1 {
            decoders: vec![
                DOBClusterFormatV0 {
                    decoder: DOBDecoderFormat {
                        location: DecoderLocationType::CodeHash,
                        hash: Some(h256!(
                            "0x13cac78ad8482202f18f9df4ea707611c35f994375fa03ae79121312dda9925c"
                        )),
                        script: None
                    },
                    pattern: serde_json::from_str("[[\"Name\",\"String\",0,1,\"options\",[\"Alice\",\"Bob\",\"Charlie\",\"David\",\"Ethan\",\"Florence\",\"Grace\",\"Helen\"]],[\"Age\",\"Number\",1,1,\"range\",[0,100]],[\"Score\",\"Number\",2,1,\"rawNumber\"],[\"_DNA\",\"String\",3,3,\"rawString\"],[\"_URL\",\"string\",6,21,\"utf8\"],[\"Value\",\"Number\",3,3,\"rawNumber\"]]").unwrap(),
                },
                DOBClusterFormatV0 {
                    decoder: DOBDecoderFormat {
                        location: DecoderLocationType::TypeScript,
                        script: Some(serde_json::from_str(r#"
                        {
                            "code_hash": "0x00000000000000000000000000000000000000000000000000545950455f4944",
                            "hash_type": "type",
                            "args": "0x784e32cef202b9d4759ea96e80d806f94051e8069fd34d761f452553700138d7"
                        }
                        "#).unwrap()
                        ),
                        hash: None,
                    },
                    pattern: serde_json::from_str("[[\"IMAGE.0\",\"attributes\",\"\",\"raw\",\"width='200' height='200' xmlns='http://www.w3.org/2000/svg'\"],[\"IMAGE.0\",\"elements\",\"Name\",\"options\",[[\"Alice\",\"<rect fill='#0000FF' width='200' height='200' />\"],[\"Bob\",\"<rect fill='#00FF00' width='200' height='200' />\"],[\"Ethan\",\"<rect fill='#FF0000' width='200' height='200' />\"],[[\"*\"],\"<rect fill='#FFFFFF' width='200' height='200' />\"]]],[\"IMAGE.0\",\"elements\",\"Age\",\"range\",[[[0,50],\"<image width='200' height='200' href='btcfs://b2f4560f17679d3e3fca66209ac425c660d28a252ef72444c3325c6eb0364393i0' />\"],[[51,100],\"<image width='200' height='200' href='btcfs://eb3910b3e32a5ed9460bd0d75168c01ba1b8f00cc0faf83e4d8b67b48ea79676i0' />\"],[[\"*\"],\"<image width='200' height='200' href='btcfs://11b6303eb7d887d7ade459ac27959754cd55f9f9e50345ced8e1e8f47f4581fai0' />\"]]],[\"IMAGE.1\",\"attributes\",\"\",\"raw\",\"xmlns='http://www.w3.org/2000/svg'\"],[\"IMAGE.1\",\"elements\",\"Score\",\"range\",[[[0,1000],\"<image width='200' height='200' href='ipfs://QmeQ6TfqzsjJCMtYmpbyZeMxiSzQGc6Aqg6NyJTeLYrrJr' />\"],[[\"*\"],\"<image width='200' height='200' href='ipfs://QmWjv41cCvGn6sf1zh8pAokX1Nf5oShz8EtLaxxKQLyJfW' />\"]]]]").unwrap(),
                }
            ],
        }),
    };
    (content, metadata)
}

#[test]
fn test_print_dob1_ingreidents() {
    let (_, dob_metadata) = generate_dob1_ingredients();
    println!(
        "cluster_description: {}",
        serde_json::to_string(&dob_metadata).unwrap()
    );
}

#[tokio::test]
async fn test_dob1_basic_decode() {
    let settings = prepare_settings("dob/1");
    let (content, dob_metadata) = generate_dob1_ingredients();
    let decoder = DOBDecoder::new(settings);
    let dna = content.get("dna").unwrap().as_str().unwrap();
    let render_result = decoder.decode_dna(dna, dob_metadata).await.expect("decode");
    println!("\nrender_result: {}", render_result);
}


================================================
File: src/tests/dob1/mod.rs
================================================
mod decoder;


