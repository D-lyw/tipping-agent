Directory structure:
└── ashuralyk-ckb-cinnabar/
    ├── README.md
    ├── Cargo.toml
    ├── assets/
    ├── calculate/
    │   ├── Cargo.toml
    │   └── src/
    │       ├── address.rs
    │       ├── indexer.rs
    │       ├── lib.rs
    │       ├── rpc.rs
    │       ├── skeleton.rs
    │       ├── instruction/
    │       │   ├── mod.rs
    │       │   └── predefined.rs
    │       ├── operation/
    │       │   ├── basic.rs
    │       │   ├── component.rs
    │       │   ├── dao.rs
    │       │   ├── mod.rs
    │       │   └── spore/
    │       │       ├── mod.rs
    │       │       └── generated/
    │       │           ├── mod.rs
    │       │           └── molecule.rs
    │       └── simulation/
    │           ├── mod.rs
    │           ├── operation.rs
    │           ├── rpc.rs
    │           └── simulator.rs
    ├── examples/
    │   ├── dao.rs
    │   ├── secp256k1_transfer.rs
    │   └── spore.rs
    ├── src/
    │   ├── command.rs
    │   ├── lib.rs
    │   ├── main.rs
    │   ├── object.rs
    │   └── handle/
    │       ├── helper.rs
    │       └── mod.rs
    └── verify/
        ├── Cargo.toml
        └── src/
            ├── error.rs
            ├── lib.rs
            ├── utils.rs
            └── verification.rs

================================================
File: README.md
================================================
# Cinnabar

> A bright red mineral consisting of mercury sulfide. It is the only important ore of mercury and is sometimes used as a pigment.

Cinnabar is a framework that aims to find a most reasonable way to bring CKB a better programming experience.

In a short, Cinnabar takes advantage of `Calculate` and `Verify` separation design, which is the core concept of CKB Cell model, to fill in the missing parts of existing CKB programming. 

## Background

### The Counter-intuitive of CKB

In contrast of Account model based block chains, like Ethereum and Solana, `Calculate` and `Verify` are fully on-chain implemented and not separated, thus the contract takes the responsibility of processing calculation and verification logic simultanously, because of that, the transaction, which can be recognized as the contract trigger, is so simple that only contains several commands or intentions.

However, CKB is an UTXO based block chain, which `Calculate` and `Verify` are separated here, and only put `Verify` part on-chain, so the contract only takes the responsibility of verification but throws the responsibility of calculation out off-chain. For most programmers, this is counterintuitive.

For above reason, transaction of CKB has high cognitive cost, it's not as simple as a container of multiple commands or intentions, but the `RESULT` of off-chain calculation, this is the core barrier for most programmers to understand CKB programming. 

### Turn Counter-intuitive into Intuitive

CKB contracts act as a role of on-chain verifier to verify the result of off-chain calculation, which is the transaction, but the responsibility of assembling transaction misses its taker, in most cases, this responsiblity unreasonably gives to the terminal programmers.

Terminal programmers are not only programmers, but more importantly our customers, they should be given the least burden and take the best experience. In a most reasonable way, the responsibility of transaction assembly should be given to contract writters, just like those from Ethereum and Solana.

However, like Bitcoin UTXO model, the advanced CKB Cell model allows a transaction to have maximum flexibility and composability, but in contrast, the contract writters only define minimum operating conditions about successfully running a transaction. So considering this paradox, we need to intruduce a transaction assembly framework that splits composability into pieces.

### Simplicity

Current toolchains and SDKs in CKB ecosystem lack simplicity, for instance, writting and deploying CKB contracts are always challenging for most newcommers, and it's a nightmare testing contracts as well.

## Modules in Cinnabar 

Cinnabar framework provides `Calculate` module and `Verify` module, in addition, contract deployment related commands are also integrated, known as `Deployment` module.

### Calculate Module

CKB transaction contains few fields, they are:
- CellDeps
- HeaderDeps
- Inputs
- Outputs
- Witnesses

The calculation is to assembly transaction with a set of instructions about fulfilling fields with proper data, for example, a typical calculation instruction comes up with the input and output, filling into `Inputs` and `Outputs` fields respectively.

A transaction can contain multiple instructions, like creating Spore DOBs or transfering xUDT assets, they are totally settled by a batch of transaction fields fullfill operations. So, a complete process of transaction assembly can be parsed into below format:

* Transaction calculation
  * Instruction 1: create one Spore DOB asset for user A
    * Operation 1: add an existing cell owned by user A into "Inputs" field
    * Operation 2: add a Spore DOB cell into "Outputs" field
    * Operation 3: add the existing Spore Cluster cell into "Inputs" and "Outputs" fields
    * Operation 4: add Spore and Cluster contract cells into "CellDeps" field
  * Instruction 2: transfer xUDT asset from user A to user B
    * Operation 1: add an existing xUDT cells from user A into "Inputs" field
    * Operation 2: add a xUDT cell of user B into "Outputs" field
    * Operation 3: add xUDT contract cell into "CellDeps" field
  * Instruction 3: balance transaction
    * Operation 1: add existing cells of user A into "Inputs" field
    * Operation 2: add change cell of user A into "Outputs" field
  * Instruction 4: sign transaction
    * Operation 1: sign transaction with user A
    * Operation 2: put signature into "Witnesses" field

As shown above, the calculation of a transaction is a set of instructions, and an instruction is a set of operations, finally, an operation indicates how to fullfill transaciton's fields.

Contract writters should provide instructions to cover up their contracts assembly requirement details for terminal programmers, and no need to worry about the next, because the responsibility of composing instructions to generate transaction is for those terminal programmers.

A diagram of Calculate module design:

![alt text](assets/calculate.png)

Run [tranfer](examples/secp256k1_transfer.rs) example:
```bash
$ cargo run --example secp256k1_transfer ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsqfqmf4hphl9jkrw3934mwe6m3a2nx88rzgdlw820 ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsqtz32u8mgzk57zdtt6n62z4y2zyh8egkdcahyxk3 1000.0 <secret_key>

# if no <secret_key> provided, then need `ckb-cli` to be installed
```

Run [spore](examples/spore.rs) example:
```bash
$ cargo run --example spore -- spore mint --minter ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsqfqmf4hphl9jkrw3934mwe6m3a2nx88rzgdlw820 --content-type "text/plain" --content "hello, cinnabar"

# other commands please see help
$ cargo run --example spore
```

Run DAO example:
```bash
$ cargo run --example dao -- --operator ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsqfqmf4hphl9jkrw3934mwe6m3a2nx88rzgdlw820 deposit --ckb 1000.0

# other commands please see help
$ cargo run --example dao
```

> note: Instruction can be compared to the interface provided by contracts from those Account model based block chains.

## Verify Module

Writting a contract is to verify wether the structure of a transaction is valid, generally speaking, this isn't difficult, but when the transaction structure becoming complex, contract code might be bloated.

If contract writters want to better manage their scripts code, modulization is essential and cannot be ignored. Here would introduce a practical modulization method from Cinnabar, it's called the `Verification Tree`.

Verification tree needs to split a whole verification process into multiple small pieces, and then manage them in a tree structure, working like a flowchart.

For example, a simplified version of flowchart for verifying a Spore creation transaction:

![alt text](assets/spore.png)

Each flowchart node on diagram can be treated as a tree node from verification tree:

```rust
#![no_main]
#![no_std]

use ckb_cinnabar_verifier::{
    cinnabar_main, define_errors, Result, Verification, CUSTOM_ERROR_START, TREE_ROOT
};
use ckb_std::debug;

define_errors!(
    SporeError,
    {
        InvalidSporeId = CUSTOM_ERROR_START 
        NoClusterOwnerExists,
        NoClusterProxyExists,
        NoClusterProxyOwnerExists,
    }
);

#[derive(Default)]
struct Context {
    // ...
}

#[derive(Default)]
struct CheckSporeId {}

impl Verification<Context> for CheckSporeId {
    fn verify(&mut self, name: &str, ctx: &mut Context) -> Result<Option<&str>> {
        debug!("verify: {name}");
        // ...
        // if spore id is valid
        Ok(Some("check_cluster"))
        // else
        Err(SporeError::InvalidSporeId)
    }
}

#[derive(Default)]
struct CheckCluster {}

impl Verification<Context> for CheckCluster {
    fn verify(&mut self, name: &str, ctx: &mut Context) -> Result<Option<&str>> {
        debug!("verify: {name}");
        // ...
        // if no cluster
        Ok(None)
        // if cluster not exists in CellDep
        Ok(Some("check_proxy"))
        // if cluster owner exists in Inputs and Outputs
        Ok(None)
        // else
        Err(SporeError::NoClusterOwnerExists)
    }
}

#[derive(Default)]
struct CheckClusterProxy {}

impl Verification<Context> for CheckClusterProxy {
    fn verify(&mut self, name: &str, ctx: &mut Context) -> Result<Option<&str>> {
        debug!("verify: {name}");
        // ...
        // if cluster proxy not exists in CellDep
        Err(SporeError::NoClusterProxyExists)
        // if cluster proxy owner exists in Inputs and Outputs
        Err(SporeError::NoClusterProxyOwnerExists)
        // else
        Ok(None)
    }
}

cinnabar_main!(
    Context,
    (TREE_ROOT, CheckSporeId),
    ("check_cluster", CheckCluster),
    ("check_proxy", CheckClusterProxy)
)
```

It's very easy to distinguish how a CKB contract works because of the clear modular design. 

## Deployment Module

Install Cinnabar binary:

```bash
$ git clone https://github.com/ashuralyk/ckb-cinnabar
$ cd ckb-cinnabar
$ cargo install --path .

# need to install ckb-cli to sign transaction if use Cinnabar to deploy contract
$ git clone https://github.com/nervosnetwork/ckb-cli
$ cd ckb-cli
$ cargo install --path .

# or install from https://github.com/nervosnetwork/ckb-cli/releases
```

Run help:

```bash
$ ckb-cinnabar

Usage: ckb-cinnabar [OPTIONS] <COMMAND>

Commands:
  deploy   Upload contract to CKB
  migrate  Update on-chain contract from old version to new version
  consume  Consume on-chain contract to release the capacity
  help     Print this message or the help of the given subcommand(s)

Options:
  -n, --network <NETWORK>
          CKB network, options are `mainnet`, `testnet` or URL (e.g. http://localhost:8114) [default: testnet]
      --deployment-path <DEPLOYMENT_PATH>
          Directory of the contract deployment information [default: deployment]
      --contract-path <CONTRACT_PATH>
          Directory of the compiled contract binary [default: build/release]
  -h, --help
          Print help
  -V, --version
          Print version
```

Examples:

```bash
# deploy a new compiled contract with type_id
$ ckb-cinnabar deploy --contract-name my_contract --tag v0.1.1 --payer-address ckt1qzda0cr08m85hc8jlnfp3zer7xulejywt49kt2rr0vthywaa50xwsq28phxutezqvjgfv5q38gn5kwek4m9km3cmajeqs --type-id

# upgrade an existing contract with type_id removed
$ ckb-cinnabar migrate --contract-name my_contract --from-tag v0.1.1 --to-tag v0.1.2 --type-id-mode remove

# consume an existing contract
$ ckb-cinnabar consume --contract-name my_contract --tag v0.1.2
```

> note: Comparing to Capsule, Cinnabar deployment module only uses `ckb-cli` to sign transaction without creating the `deployment.toml` file as prerequisites.

For specific usage scenarios, please refer to [demos](https://github.com/ashuralyk/cinnabar-examples).


================================================
File: Cargo.toml
================================================
[workspace]
resolver = "2"

members = [
    "calculate",
    "verify",
]

[package]
name = "ckb-cinnabar"
version = "0.1.0"
edition = "2021"

[dependencies]
chrono = "0.4.38"
hex = "0.4.3"
serde_json = "1.0"
reqwest = "0.12.5"

ckb-cinnabar-calculator = { path = "calculate" }
clap = { version = "4.5.13", features = ["derive"] }
tokio = { version = "1.43.0", features = ["rt-multi-thread", "macros"] }
serde = { version = "1.0", features = ["derive"] }


================================================
File: calculate/Cargo.toml
================================================
[package]
name = "ckb-cinnabar-calculator"
version = "0.1.0"
edition = "2021"

[dependencies]
async-trait = "0.1.81"
bech32 = "0.8.1"
ckb-always-success-script = "0.0.1"
ckb-types = "0.117.0"
ckb-jsonrpc-types = "0.117.0"
eyre = "0.6.12"
futures = "0.3.30"
hex = "0.4.3"
serde_json = "1.0"
rand = "0.8.5"
molecule = "0.8.0"
lazy_static = "1.5.0"

ckb-hash = { version = "0.117.0", features = ["ckb-contract"] }
getrandom = { version = "0.2", features = ["js"] }
serde = { version = "1.0", features = ["derive"] }
secp256k1 = { version = "0.29", features = ["recovery", "rand-std"] }
tokio = { version = "1.43.0", default-features = false, features = ["rt", "macros", "time"] }

[target.'cfg(not(target_family = "wasm"))'.dependencies]
ckb-chain-spec = "0.117.0"
ckb-traits = "0.117.0"
ckb-script = "0.117.0"
ckb-sdk = "3.3.0"
rpassword = "7.3.1"
reqwest = { version = "0.12.5", features = ["json", "native-tls"] }

[target.'cfg(target_family = "wasm")'.dependencies]
reqwest = { version = "0.12.5", default-features = false, features = ["json", "rustls-tls-webpki-roots"] }


================================================
File: calculate/src/address.rs
================================================
use std::convert::{TryFrom, TryInto};
use std::fmt;
use std::str::FromStr;

use bech32::{self, convert_bits, ToBase32, Variant};
use ckb_types::{
    bytes::Bytes,
    core::ScriptHashType,
    packed::{Byte32, Script},
    prelude::*,
};

use crate::rpc::Network;

#[derive(Hash, Eq, PartialEq, Clone)]
pub struct AddressPayload {
    hash_type: ScriptHashType,
    code_hash: Byte32,
    args: Bytes,
}

impl AddressPayload {
    pub fn new_full(hash_type: ScriptHashType, code_hash: Byte32, args: Bytes) -> AddressPayload {
        Self {
            hash_type,
            code_hash,
            args,
        }
    }

    pub fn hash_type(&self) -> ScriptHashType {
        self.hash_type
    }

    pub fn code_hash(&self) -> Byte32 {
        self.code_hash.clone()
    }

    pub fn args(&self) -> Bytes {
        self.args.clone()
    }

    pub fn display_with_network(&self, network: &Network) -> String {
        // payload = 0x00 | code_hash | hash_type | args
        let code_hash = self.code_hash();
        let hash_type = self.hash_type();
        let args = self.args();
        let mut data = vec![0u8; 34 + args.len()];
        data[0] = 0x00;
        data[1..33].copy_from_slice(code_hash.as_slice());
        data[33] = hash_type as u8;
        data[34..].copy_from_slice(args.as_ref());
        bech32::encode(
            network.to_prefix(),
            data.to_base32(),
            bech32::Variant::Bech32m,
        )
        .unwrap_or_else(|_| panic!("Encode address failed: payload={:?}", self))
    }
}

impl fmt::Debug for AddressPayload {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let hash_type = match self.hash_type() {
            ScriptHashType::Type => "type",
            ScriptHashType::Data => "data",
            ScriptHashType::Data1 => "data1",
            ScriptHashType::Data2 => "data2",
        };
        f.debug_struct("AddressPayload")
            .field("hash_type", &hash_type)
            .field("code_hash", &self.code_hash())
            .field("args", &self.args())
            .finish()
    }
}

impl From<&AddressPayload> for Script {
    fn from(payload: &AddressPayload) -> Script {
        Script::new_builder()
            .hash_type(payload.hash_type().into())
            .code_hash(payload.code_hash())
            .args(payload.args().pack())
            .build()
    }
}

impl From<Script> for AddressPayload {
    fn from(lock: Script) -> AddressPayload {
        let hash_type: ScriptHashType = lock.hash_type().try_into().expect("Invalid hash_type");
        let code_hash = lock.code_hash();
        let args = lock.args().raw_data();
        Self {
            hash_type,
            code_hash,
            args,
        }
    }
}

#[derive(Hash, Eq, PartialEq, Clone)]
pub struct Address {
    network: Network,
    payload: AddressPayload,
}

impl Address {
    pub fn new(network: Network, payload: AddressPayload) -> Address {
        Address { network, payload }
    }

    pub fn network(&self) -> &Network {
        &self.network
    }

    pub fn payload(&self) -> &AddressPayload {
        &self.payload
    }
}

impl fmt::Debug for Address {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let hash_type = match self.payload.hash_type() {
            ScriptHashType::Type => "type",
            ScriptHashType::Data => "data",
            ScriptHashType::Data1 => "data1",
            ScriptHashType::Data2 => "data2",
        };
        f.debug_struct("Address")
            .field("network", &self.network)
            .field("hash_type", &hash_type)
            .field("code_hash", &self.payload.code_hash())
            .field("args", &self.payload.args())
            .finish()
    }
}

impl From<&Address> for Script {
    fn from(addr: &Address) -> Script {
        Script::new_builder()
            .hash_type(addr.payload.hash_type().into())
            .code_hash(addr.payload.code_hash())
            .args(addr.payload.args().pack())
            .build()
    }
}

impl fmt::Display for Address {
    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {
        write!(f, "{}", self.payload.display_with_network(&self.network))
    }
}

impl FromStr for Address {
    type Err = String;

    fn from_str(input: &str) -> Result<Self, Self::Err> {
        let (hrp, data, variant) = bech32::decode(input).map_err(|err| err.to_string())?;
        let network = Network::from_prefix(&hrp).ok_or_else(|| format!("Invalid hrp: {}", hrp))?;
        let data = convert_bits(&data, 5, 8, false).unwrap();
        if variant != Variant::Bech32m {
            return Err("ckb2021 format full address must use bech32m encoding".to_string());
        }
        if data.len() < 34 {
            return Err(format!("Insufficient data length: {}", data.len()));
        }
        let code_hash = Byte32::from_slice(&data[1..33]).unwrap();
        let hash_type = ScriptHashType::try_from(data[33]).map_err(|err| err.to_string())?;
        let args = Bytes::from(data[34..].to_vec());
        let payload = AddressPayload {
            hash_type,
            code_hash,
            args,
        };
        Ok(Address { network, payload })
    }
}


================================================
File: calculate/src/indexer.rs
================================================
use ckb_types::{
    bytes::Bytes,
    packed::{CellOutput, OutPoint, Script},
    H256,
};

mod json_stuff {
    use super::*;
    use ckb_jsonrpc_types::{
        BlockNumber, Capacity, CellOutput, JsonBytes, OutPoint, Script, Uint32, Uint64,
    };
    use serde::{Deserialize, Serialize};

    #[derive(Serialize, Deserialize, Clone, Debug)]
    pub struct SearchKey {
        pub script: Script,
        pub script_type: ScriptType,
        pub script_search_mode: Option<SearchMode>,
        pub filter: Option<SearchKeyFilter>,
        pub with_data: Option<bool>,
        pub group_by_transaction: Option<bool>,
    }

    #[derive(Serialize, Deserialize, Clone, Debug, Eq, PartialEq, Hash)]
    #[serde(rename_all = "snake_case")]
    pub enum SearchMode {
        Prefix,
        Exact,
        Partial,
    }

    impl Default for SearchMode {
        fn default() -> Self {
            Self::Prefix
        }
    }

    #[derive(Serialize, Deserialize, Default, Clone, Debug)]
    pub struct SearchKeyFilter {
        pub script: Option<Script>,
        pub script_len_range: Option<[Uint64; 2]>,
        pub output_data: Option<JsonBytes>,
        pub output_data_filter_mode: Option<SearchMode>,
        pub output_data_len_range: Option<[Uint64; 2]>,
        pub output_capacity_range: Option<[Uint64; 2]>,
        pub block_range: Option<[BlockNumber; 2]>,
    }

    impl From<CellQueryOptions> for SearchKey {
        fn from(opts: CellQueryOptions) -> SearchKey {
            let convert_range =
                |range: ValueRangeOption| [Uint64::from(range.start), Uint64::from(range.end)];
            let filter = if opts.secondary_script.is_none()
                && opts.secondary_script_len_range.is_none()
                && opts.data_len_range.is_none()
                && opts.capacity_range.is_none()
                && opts.block_range.is_none()
            {
                None
            } else {
                Some(SearchKeyFilter {
                    script: opts.secondary_script.map(|v| v.into()),
                    script_len_range: opts.secondary_script_len_range.map(convert_range),
                    output_data: None,
                    output_data_filter_mode: None,
                    output_data_len_range: opts.data_len_range.map(convert_range),
                    output_capacity_range: opts.capacity_range.map(convert_range),
                    block_range: opts.block_range.map(convert_range),
                })
            };
            SearchKey {
                script: opts.primary_script.into(),
                script_type: opts.primary_type.into(),
                script_search_mode: opts.script_search_mode,
                filter,
                with_data: opts.with_data,
                group_by_transaction: None,
            }
        }
    }

    #[derive(Serialize, Deserialize, Clone, Debug)]
    #[serde(rename_all = "snake_case")]
    pub enum ScriptType {
        Lock,
        Type,
    }

    impl From<PrimaryScriptType> for ScriptType {
        fn from(t: PrimaryScriptType) -> ScriptType {
            match t {
                PrimaryScriptType::Lock => ScriptType::Lock,
                PrimaryScriptType::Type => ScriptType::Type,
            }
        }
    }

    #[derive(Serialize, Deserialize, Clone, Debug)]
    #[serde(rename_all = "snake_case")]
    pub enum Order {
        Desc,
        Asc,
    }

    #[derive(Serialize, Deserialize, Clone, Debug)]
    pub struct Tip {
        pub block_hash: H256,
        pub block_number: BlockNumber,
    }

    #[derive(Serialize, Deserialize, Clone, Debug)]
    pub struct CellsCapacity {
        pub capacity: Capacity,
        pub block_hash: H256,
        pub block_number: BlockNumber,
    }

    #[derive(Serialize, Deserialize, Clone, Debug)]
    pub struct Cell {
        pub output: CellOutput,
        pub output_data: Option<JsonBytes>,
        pub out_point: OutPoint,
        pub block_number: BlockNumber,
        pub tx_index: Uint32,
    }

    impl From<Cell> for LiveCell {
        fn from(cell: Cell) -> LiveCell {
            LiveCell {
                output: cell.output.into(),
                output_data: cell
                    .output_data
                    .map(|data| data.into_bytes())
                    .unwrap_or_default(),
                out_point: cell.out_point.into(),
                block_number: cell.block_number.value(),
                tx_index: cell.tx_index.value(),
            }
        }
    }

    #[derive(Serialize, Deserialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum Tx {
        Ungrouped(TxWithCell),
        Grouped(TxWithCells),
    }

    #[derive(Serialize, Deserialize, Clone, Debug)]
    pub struct TxWithCell {
        pub tx_hash: H256,
        pub block_number: BlockNumber,
        pub tx_index: Uint32,
        pub io_index: Uint32,
        pub io_type: CellType,
    }

    #[derive(Serialize, Deserialize, Clone, Debug)]
    pub struct TxWithCells {
        pub tx_hash: H256,
        pub block_number: BlockNumber,
        pub tx_index: Uint32,
        pub cells: Vec<(CellType, Uint32)>,
    }

    #[derive(Serialize, Deserialize, Clone, Debug)]
    #[serde(rename_all = "snake_case")]
    pub enum CellType {
        Input,
        Output,
    }

    #[derive(Serialize, Deserialize, Clone, Debug)]
    #[serde(rename_all = "snake_case")]
    pub enum IOType {
        Input,
        Output,
    }

    #[derive(Serialize, Deserialize)]
    pub struct Pagination<T> {
        pub objects: Vec<T>,
        pub last_cursor: JsonBytes,
    }
}

pub use json_stuff::*;

#[derive(Debug, Clone)]
pub struct LiveCell {
    pub output: CellOutput,
    pub output_data: Bytes,
    pub out_point: OutPoint,
    pub block_number: u64,
    pub tx_index: u32,
}

/// The value range option: `start <= value < end`
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub struct ValueRangeOption {
    pub start: u64,
    pub end: u64,
}

impl ValueRangeOption {
    pub fn new(start: u64, end: u64) -> ValueRangeOption {
        ValueRangeOption { start, end }
    }

    pub fn new_exact(value: u64) -> ValueRangeOption {
        ValueRangeOption {
            start: value,
            end: value + 1,
        }
    }

    pub fn new_min(start: u64) -> ValueRangeOption {
        ValueRangeOption {
            start,
            end: u64::MAX,
        }
    }

    pub fn match_value(&self, value: u64) -> bool {
        self.start <= value && value < self.end
    }
}

/// The primary serach script type
///   * if primary script type is `lock` then secondary script type is `type`
///   * if primary script type is `type` then secondary script type is `lock`
#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub enum PrimaryScriptType {
    Lock,
    Type,
}

#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub enum MaturityOption {
    Mature,
    Immature,
    Both,
}

#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub enum QueryOrder {
    Desc,
    Asc,
}

#[derive(Debug, Clone, Eq, PartialEq)]
pub struct CellQueryOptions {
    pub primary_script: Script,
    pub primary_type: PrimaryScriptType,
    pub with_data: Option<bool>,
    pub order: QueryOrder,
    pub limit: Option<u32>,

    // Options for SearchKeyFilter
    pub secondary_script: Option<Script>,
    pub secondary_script_len_range: Option<ValueRangeOption>,
    pub data_len_range: Option<ValueRangeOption>,
    pub capacity_range: Option<ValueRangeOption>,
    pub block_range: Option<ValueRangeOption>,

    /// Filter cell by its maturity
    pub maturity: MaturityOption,

    /// Try to collect at least `min_total_capacity` shannons of cells, if
    /// satisfied will stop collecting. The default value is 1 shannon means
    /// collect only one cell at most.
    pub min_total_capacity: u64,
    pub script_search_mode: Option<SearchMode>,
}

impl CellQueryOptions {
    pub fn new(primary_script: Script, primary_type: PrimaryScriptType) -> CellQueryOptions {
        CellQueryOptions {
            primary_script,
            primary_type,
            secondary_script: None,
            secondary_script_len_range: None,
            data_len_range: None,
            capacity_range: None,
            block_range: None,
            with_data: None,
            order: QueryOrder::Asc,
            limit: None,
            maturity: MaturityOption::Mature,
            min_total_capacity: 1,
            script_search_mode: None,
        }
    }

    pub fn new_lock(primary_script: Script) -> CellQueryOptions {
        CellQueryOptions::new(primary_script, PrimaryScriptType::Lock)
    }

    pub fn new_type(primary_script: Script) -> CellQueryOptions {
        CellQueryOptions::new(primary_script, PrimaryScriptType::Type)
    }
}


================================================
File: calculate/src/lib.rs
================================================
pub mod address;
pub mod indexer;
pub mod instruction;
pub mod operation;
pub mod rpc;
pub mod simulation;
pub mod skeleton;
pub use instruction::TransactionCalculator;

// Re-exports to eliminate the need for downstream dependencies to specify the version of ckb_* crates
pub mod re_exports {
    pub use async_trait;
    pub use ckb_hash;
    pub use ckb_jsonrpc_types;
    pub use ckb_types;
    pub use eyre;
    pub use secp256k1;
    pub use tokio;

    #[cfg(not(target_arch = "wasm32"))]
    pub use ckb_sdk;
}


================================================
File: calculate/src/rpc.rs
================================================
use std::{
    fmt::Display,
    future::Future,
    pin::Pin,
    str::FromStr,
    sync::{
        atomic::{AtomicU64, Ordering},
        Arc,
    },
};

use ckb_jsonrpc_types::{
    BlockNumber, BlockView, CellWithStatus, HeaderView, JsonBytes, OutPoint, OutputsValidator,
    Transaction, TransactionWithStatusResponse, TxPoolInfo, Uint32,
};
use ckb_types::H256;
use eyre::{eyre, Error};
use futures::FutureExt;
use reqwest::{Client, Url};
use serde::Deserialize;

use crate::indexer::{Cell, Order, Pagination, SearchKey};

#[cfg(target_arch = "wasm32")]
pub type Rpc<T> = Pin<Box<dyn Future<Output = Result<T, Error>>>>;

#[cfg(not(target_arch = "wasm32"))]
pub type Rpc<T> = Pin<Box<dyn Future<Output = Result<T, Error>> + Send + 'static>>;

pub const MAINNET_RPC_URL: &str = "https://mainnet.ckb.dev";
pub const TESTNET_RPC_URL: &str = "https://testnet.ckbapp.dev";

#[derive(Deserialize)]
#[serde(untagged)]
enum Output {
    Success(JsonSuccess),
    Failure(JsonError),
}

#[derive(Deserialize)]
struct JsonSuccess {
    pub result: serde_json::Value,
}

#[derive(Deserialize, Debug)]
struct JsonError {
    pub error: serde_json::Value,
}

#[allow(clippy::upper_case_acronyms)]
enum Target {
    CKB,
    Indexer,
}

macro_rules! jsonrpc {
    ($method:expr, $id:expr, $self:ident, $return:ty$(, $params:ident$(,)?)*) => {{
        let data = format!(
            r#"{{"id": {}, "jsonrpc": "2.0", "method": "{}", "params": {}}}"#,
            $self.id.load(Ordering::Relaxed),
            $method,
            serde_json::to_value(($($params,)*)).unwrap()
        );
        $self.id.fetch_add(1, Ordering::Relaxed);

        let req_json: serde_json::Value = serde_json::from_str(&data).unwrap();

        let url = match $id {
            Target::CKB => $self.ckb_uri.clone(),
            Target::Indexer => $self.indexer_uri.clone(),
        };
        let c = $self.raw.post(url).json(&req_json);
        async {
            let resp = c
                .send()
                .await
                .map_err::<Error, _>(|e| eyre!("bad ckb request url: {}", e))?;
            let output = resp
                .json::<Output>()
                .await
                .map_err::<Error, _>(|e| eyre!("failed to parse json response: {}", e))?;

            match output {
                Output::Success(success) => {
                    Ok(serde_json::from_value::<$return>(success.result).unwrap())
                }
                Output::Failure(e) => {
                    Err(eyre!("failed to get response from ckb rpc: {:?}", e.error))
                }
            }
        }
    }}
}

#[derive(Hash, PartialEq, Eq, Clone, Debug)]
pub enum Network {
    Mainnet,
    Testnet,
    Custom(Url),
    Fake,
}

impl Display for Network {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Network::Mainnet => write!(f, "mainnet"),
            Network::Testnet => write!(f, "testnet"),
            Network::Fake => write!(f, "fake"),
            Network::Custom(url) => write!(f, "{}", url),
        }
    }
}

impl FromStr for Network {
    type Err = eyre::Error;

    fn from_str(value: &str) -> Result<Self, Self::Err> {
        match value {
            "mainnet" => Ok(Network::Mainnet),
            "testnet" => Ok(Network::Testnet),
            "fake" => Ok(Network::Fake),
            _ => Ok(Network::Custom(value.parse()?)),
        }
    }
}

impl Network {
    pub fn from_prefix(prefix: &str) -> Option<Self> {
        match prefix {
            "ckb" => Some(Network::Mainnet),
            "ckt" => Some(Network::Testnet),
            _ => None,
        }
    }

    pub fn to_prefix(&self) -> &'static str {
        match self {
            Network::Mainnet => "ckb",
            _ => "ckt",
        }
    }
}

#[allow(clippy::upper_case_acronyms)]
pub trait RPC: Clone + Send + Sync {
    fn network(&self) -> Network {
        Network::Fake
    }
    fn url(&self) -> (String, String);
    fn get_live_cell(&self, out_point: &OutPoint, with_data: bool) -> Rpc<CellWithStatus>;
    fn get_cells(
        &self,
        search_key: SearchKey,
        limit: u32,
        cursor: Option<JsonBytes>,
    ) -> Rpc<Pagination<Cell>>;
    fn get_block_by_number(&self, number: BlockNumber) -> Rpc<Option<BlockView>>;
    fn get_block(&self, hash: &H256) -> Rpc<Option<BlockView>>;
    fn get_header(&self, hash: &H256) -> Rpc<Option<HeaderView>>;
    fn get_header_by_number(&self, number: BlockNumber) -> Rpc<Option<HeaderView>>;
    fn get_block_hash(&self, number: BlockNumber) -> Rpc<Option<H256>>;
    fn get_tip_block_number(&self) -> Rpc<BlockNumber>;
    fn get_tip_header(&self) -> Rpc<HeaderView>;
    fn tx_pool_info(&self) -> Rpc<TxPoolInfo>;
    fn get_transaction(&self, hash: &H256) -> Rpc<Option<TransactionWithStatusResponse>>;
    fn send_transaction(
        &self,
        tx: Transaction,
        outputs_validator: Option<OutputsValidator>,
    ) -> Rpc<H256>;
}

#[derive(Clone)]
pub struct RpcClient {
    network: Network,
    raw: Client,
    ckb_uri: Url,
    indexer_uri: Url,
    id: Arc<AtomicU64>,
}

impl RpcClient {
    pub fn new(ckb_uri: &str, indexer_uri: Option<&str>) -> Self {
        let indexer_uri = Url::parse(indexer_uri.unwrap_or(ckb_uri))
            .expect("ckb uri, e.g. \"http://127.0.0.1:8116\"");
        let ckb_uri = Url::parse(ckb_uri).expect("ckb uri, e.g. \"http://127.0.0.1:8114\"");

        RpcClient {
            network: Network::Custom(ckb_uri.clone()),
            raw: Client::new(),
            ckb_uri,
            indexer_uri,
            id: Arc::new(AtomicU64::new(0)),
        }
    }

    pub fn new_mainnet() -> Self {
        let mut rpc = RpcClient::new(MAINNET_RPC_URL, None);
        rpc.network = Network::Mainnet;
        rpc
    }

    pub fn new_testnet() -> Self {
        let mut rpc = RpcClient::new(TESTNET_RPC_URL, None);
        rpc.network = Network::Testnet;
        rpc
    }
}

impl RPC for RpcClient {
    fn network(&self) -> Network {
        self.network.clone()
    }

    fn url(&self) -> (String, String) {
        (self.ckb_uri.to_string(), self.indexer_uri.to_string())
    }

    fn get_live_cell(&self, out_point: &OutPoint, with_data: bool) -> Rpc<CellWithStatus> {
        let future = jsonrpc!(
            "get_live_cell",
            Target::CKB,
            self,
            CellWithStatus,
            out_point,
            with_data
        );
        #[cfg(not(target_arch = "wasm32"))]
        return future.boxed();
        #[cfg(target_arch = "wasm32")]
        return future.boxed_local();
    }

    fn get_cells(
        &self,
        search_key: SearchKey,
        limit: u32,
        cursor: Option<JsonBytes>,
    ) -> Rpc<Pagination<Cell>> {
        let order = Order::Asc;
        let limit = Uint32::from(limit);

        let future = jsonrpc!(
            "get_cells",
            Target::Indexer,
            self,
            Pagination<Cell>,
            search_key,
            order,
            limit,
            cursor,
        );
        #[cfg(not(target_arch = "wasm32"))]
        return future.boxed();
        #[cfg(target_arch = "wasm32")]
        return future.boxed_local();
    }

    fn get_block_by_number(&self, number: BlockNumber) -> Rpc<Option<BlockView>> {
        let future = jsonrpc!(
            "get_block_by_number",
            Target::CKB,
            self,
            Option<BlockView>,
            number
        );
        #[cfg(not(target_arch = "wasm32"))]
        return future.boxed();
        #[cfg(target_arch = "wasm32")]
        return future.boxed_local();
    }

    fn get_block(&self, hash: &H256) -> Rpc<Option<BlockView>> {
        let future = jsonrpc!("get_block", Target::CKB, self, Option<BlockView>, hash);
        #[cfg(not(target_arch = "wasm32"))]
        return future.boxed();
        #[cfg(target_arch = "wasm32")]
        return future.boxed_local();
    }

    fn get_header(&self, hash: &H256) -> Rpc<Option<HeaderView>> {
        let future = jsonrpc!("get_header", Target::CKB, self, Option<HeaderView>, hash);
        #[cfg(not(target_arch = "wasm32"))]
        return future.boxed();
        #[cfg(target_arch = "wasm32")]
        return future.boxed_local();
    }

    fn get_header_by_number(&self, number: BlockNumber) -> Rpc<Option<HeaderView>> {
        let future = jsonrpc!(
            "get_header_by_number",
            Target::CKB,
            self,
            Option<HeaderView>,
            number
        );
        #[cfg(not(target_arch = "wasm32"))]
        return future.boxed();
        #[cfg(target_arch = "wasm32")]
        return future.boxed_local();
    }

    fn get_block_hash(&self, number: BlockNumber) -> Rpc<Option<H256>> {
        let future = jsonrpc!("get_block_hash", Target::CKB, self, Option<H256>, number);
        #[cfg(not(target_arch = "wasm32"))]
        return future.boxed();
        #[cfg(target_arch = "wasm32")]
        return future.boxed_local();
    }

    fn get_tip_block_number(&self) -> Rpc<BlockNumber> {
        let future = jsonrpc!("get_tip_block_number", Target::CKB, self, BlockNumber);
        #[cfg(not(target_arch = "wasm32"))]
        return future.boxed();
        #[cfg(target_arch = "wasm32")]
        return future.boxed_local();
    }

    fn get_tip_header(&self) -> Rpc<HeaderView> {
        let future = jsonrpc!("get_tip_header", Target::CKB, self, HeaderView);
        #[cfg(not(target_arch = "wasm32"))]
        return future.boxed();
        #[cfg(target_arch = "wasm32")]
        return future.boxed_local();
    }

    fn tx_pool_info(&self) -> Rpc<TxPoolInfo> {
        let future = jsonrpc!("tx_pool_info", Target::CKB, self, TxPoolInfo);
        #[cfg(not(target_arch = "wasm32"))]
        return future.boxed();
        #[cfg(target_arch = "wasm32")]
        return future.boxed_local();
    }

    fn get_transaction(&self, hash: &H256) -> Rpc<Option<TransactionWithStatusResponse>> {
        let future = jsonrpc!(
            "get_transaction",
            Target::CKB,
            self,
            Option<TransactionWithStatusResponse>,
            hash
        );
        #[cfg(not(target_arch = "wasm32"))]
        return future.boxed();
        #[cfg(target_arch = "wasm32")]
        return future.boxed_local();
    }

    fn send_transaction(
        &self,
        tx: Transaction,
        outputs_validator: Option<OutputsValidator>,
    ) -> Rpc<H256> {
        let future = jsonrpc!(
            "send_transaction",
            Target::CKB,
            self,
            H256,
            tx,
            outputs_validator
        );
        #[cfg(not(target_arch = "wasm32"))]
        return future.boxed();
        #[cfg(target_arch = "wasm32")]
        return future.boxed_local();
    }
}

pub type Filter = Box<dyn Fn(&Cell) -> bool + Send + Sync>;

/// A wrapper of get_cells rpc call, it will automatically cross over live cells in interation
pub struct GetCellsIter<'a, T: RPC> {
    rpc: &'a T,
    search_key: SearchKey,
    cursor: Option<JsonBytes>,
    filter: Option<Filter>,
}

impl<'a, T: RPC> GetCellsIter<'a, T> {
    pub fn new(rpc: &'a T, search_key: SearchKey) -> Self {
        GetCellsIter {
            rpc,
            search_key,
            cursor: None,
            filter: None,
        }
    }

    pub fn filter(mut self, filter: Filter) -> Self {
        self.filter = Some(filter);
        self
    }

    pub async fn next_batch(&mut self, limit: u32) -> eyre::Result<Option<Vec<Cell>>> {
        let cells = self
            .rpc
            .get_cells(self.search_key.clone(), limit, self.cursor.clone())
            .await?;
        let objects = if let Some(filter) = &self.filter {
            cells.objects.into_iter().filter(filter).collect()
        } else {
            cells.objects
        };
        if objects.is_empty() {
            return Ok(None);
        }
        self.cursor = Some(cells.last_cursor);
        Ok(Some(objects))
    }

    pub async fn next(&mut self) -> eyre::Result<Option<Cell>> {
        Ok(self.next_batch(1).await?.map(|v| v[0].clone()))
    }
}


================================================
File: calculate/src/skeleton.rs
================================================
use std::{fmt::Display, time::Duration};

use ckb_hash::{blake2b_256, Blake2bBuilder};
use ckb_jsonrpc_types::{OutputsValidator, Status};
use ckb_types::{
    core::{
        cell::{CellMetaBuilder, ResolvedTransaction},
        Capacity, DepType, HeaderView, ScriptHashType, TransactionView,
    },
    h256,
    packed::{Bytes, CellDep, CellInput, CellOutput, OutPoint, OutPointVec, Script, WitnessArgs},
    prelude::{Builder, Entity, Pack, Unpack},
    H256,
};
use eyre::{eyre, Result};
use futures::future::join_all;

use crate::{
    address::{Address, AddressPayload},
    indexer::{Cell, CellQueryOptions, SearchMode, ValueRangeOption},
    rpc::{GetCellsIter, Network, RPC},
};

pub const TYPE_ID_CODE_HASH: H256 = h256!("0x545950455f4944");

/// A wrapper of packed Script
///
/// `Reference` branch: point to a celldep in the transaction, if `usize` is MAX, point to the last one
#[derive(Clone, PartialEq, Eq)]
pub enum ScriptEx {
    Script(H256, ScriptHashType, Vec<u8>),
    Reference(String, Vec<u8>),
}

impl Default for ScriptEx {
    fn default() -> Self {
        ScriptEx::Script(H256::default(), ScriptHashType::Data, Vec::new())
    }
}

impl PartialEq<Script> for ScriptEx {
    fn eq(&self, other: &Script) -> bool {
        let Ok(script) = Script::try_from(self.clone()) else {
            return false;
        };
        &script == other
    }
}

impl ScriptEx {
    /// Initialize a ScriptEx of `Data1`
    pub fn new_code(code_hash: H256, args: Vec<u8>) -> Self {
        ScriptEx::Script(code_hash, ScriptHashType::Data1, args)
    }

    /// Initialize a ScriptEx of `Type`
    pub fn new_type(type_hash: H256, args: Vec<u8>) -> Self {
        ScriptEx::Script(type_hash, ScriptHashType::Type, args)
    }

    /// Initialize a ScriptEx of `TypeId`
    pub fn new_type_id(args: H256) -> Self {
        ScriptEx::new_type(TYPE_ID_CODE_HASH, args.as_bytes().to_vec())
    }

    /// Get `code_hash` of ScriptEx
    pub fn code_hash(&self) -> eyre::Result<H256> {
        match self {
            ScriptEx::Script(code_hash, _, _) => Ok(code_hash.clone()),
            _ => Err(eyre!("reference script")),
        }
    }

    /// Get `hash_type` of ScriptEx
    pub fn hash_type(&self) -> eyre::Result<ScriptHashType> {
        match self {
            ScriptEx::Script(_, hash_type, _) => Ok(*hash_type),
            _ => Err(eyre!("reference script")),
        }
    }

    /// Get `args` of ScriptEx
    pub fn args(&self) -> Vec<u8> {
        match self {
            ScriptEx::Script(_, _, args) => args.clone(),
            ScriptEx::Reference(_, args) => args.clone(),
        }
    }

    /// Change `args` of ScriptEx
    pub fn set_args(self, args: Vec<u8>) -> Self {
        match self {
            ScriptEx::Script(code_hash, hash_type, _) => {
                ScriptEx::Script(code_hash, hash_type, args)
            }
            ScriptEx::Reference(name, _) => ScriptEx::Reference(name, args),
        }
    }

    /// Calculate blake2b hash of the script
    pub fn script_hash(&self) -> Result<H256> {
        Script::try_from(self.clone()).map(|v| v.calc_script_hash().unpack())
    }

    /// Turn into CKB address
    pub fn to_address(self, network: Network) -> Result<Address> {
        let payload = Script::try_from(self)?.into();
        Ok(Address::new(network, payload))
    }

    /// Build packed Script from ScriptEx and TransactionSkeleton
    pub fn to_script(self, skeleton: &TransactionSkeleton) -> Result<Script> {
        if let ScriptEx::Reference(name, _) = &self {
            let (_, value) = skeleton
                .find_celldep_by_script(&self)
                .ok_or(eyre!("celldep {name} not found"))?;
            if value.celldep.dep_type() == DepType::DepGroup.into() {
                return Err(eyre!("no support for group celldep"));
            }
            let output = &value.output;
            let mut script = Script::new_builder().args(self.args().pack());
            if let Some(celldep_type_hash) = output.calc_type_hash() {
                script = script
                    .code_hash(celldep_type_hash.pack())
                    .hash_type(ScriptHashType::Type.into());
            } else {
                if !value.with_data {
                    return Err(eyre!("celldep without data, cannot calculate data hash"));
                }
                script = script
                    .code_hash(output.data_hash().pack())
                    .hash_type(ScriptHashType::Data1.into());
            }
            Ok(script.build())
        } else {
            self.try_into()
        }
    }

    /// Build packed Script from ScriptEx, throw error if failed
    pub fn to_script_unchecked(self) -> Script {
        self.try_into().expect("unchecked to_script")
    }
}

impl TryFrom<ScriptEx> for Script {
    type Error = eyre::Error;

    fn try_from(value: ScriptEx) -> Result<Self> {
        match value {
            ScriptEx::Script(code_hash, hash_type, args) => Ok(Script::new_builder()
                .code_hash(code_hash.pack())
                .hash_type(hash_type.into())
                .args(args.pack())
                .build()),
            ScriptEx::Reference(_, _) => Err(eyre!("reference script")),
        }
    }
}

impl From<Script> for ScriptEx {
    fn from(value: Script) -> Self {
        ScriptEx::Script(
            value.code_hash().unpack(),
            value.hash_type().try_into().expect("hash type"),
            value.args().raw_data().to_vec(),
        )
    }
}

impl From<Address> for ScriptEx {
    fn from(value: Address) -> Self {
        value.payload().into()
    }
}

impl From<&AddressPayload> for ScriptEx {
    fn from(value: &AddressPayload) -> Self {
        Script::from(value).into()
    }
}

impl From<(String, Vec<u8>)> for ScriptEx {
    fn from((celldep_name, args): (String, Vec<u8>)) -> Self {
        ScriptEx::Reference(celldep_name, args)
    }
}

/// CellInput for transaction skeleton, which contains output cell and data
#[derive(Debug, Clone)]
pub struct CellInputEx {
    pub input: CellInput,
    pub output: CellOutputEx,
    pub with_data: bool,
}

impl PartialEq for CellInputEx {
    fn eq(&self, other: &Self) -> bool {
        self.input.as_bytes() == other.input.as_bytes()
    }
}

impl CellInputEx {
    /// Directly initialize a CellInputEx
    pub fn new(input: CellInput, output: CellOutput, data: Option<Vec<u8>>) -> Self {
        if let Some(data) = data {
            CellInputEx {
                input,
                output: CellOutputEx::new(output, data),
                with_data: true,
            }
        } else {
            CellInputEx {
                input,
                output: CellOutputEx::new(output, Vec::new()),
                with_data: false,
            }
        }
    }

    /// Initialize a CellInputEx from out point via CKB RPC
    pub async fn new_from_outpoint<T: RPC>(
        rpc: &T,
        tx_hash: H256,
        index: u32,
        since: Option<u64>,
        with_data: bool,
    ) -> Result<Self> {
        let out_point = OutPoint::new_builder()
            .tx_hash(tx_hash.pack())
            .index(index.pack())
            .build();
        let live_cell = rpc
            .get_live_cell(&out_point.clone().into(), with_data)
            .await?
            .cell
            .ok_or(eyre!(
                "cell not found at ({}:{index})",
                hex::encode(&tx_hash)
            ))?;
        let input = CellInput::new_builder()
            .previous_output(out_point)
            .since(since.unwrap_or(0).pack())
            .build();
        let output = live_cell.output.into();
        let data = live_cell.data.map(|v| v.content.into_bytes().to_vec());
        Ok(Self::new(input, output, data))
    }

    /// Initialize a CellInputEx from the ckb-indexer specific cell
    pub fn new_from_indexer_cell(indexer_cell: Cell, since: Option<u64>) -> Self {
        let input = CellInput::new_builder()
            .previous_output(indexer_cell.out_point.into())
            .since(since.unwrap_or(0).pack())
            .build();
        let data = indexer_cell.output_data.map(|v| v.into_bytes().to_vec());
        Self::new(input, indexer_cell.output.into(), data)
    }

    /// Turn a CelldepEx into CellInputEx
    pub fn new_from_celldep(celldep: &CellDepEx, since: Option<u64>) -> Self {
        let input = CellInput::new_builder()
            .previous_output(celldep.celldep.out_point())
            .since(since.unwrap_or(0).pack())
            .build();
        let data = if celldep.with_data {
            Some(celldep.output.data.clone())
        } else {
            None
        };
        Self::new(input, celldep.output.output.clone(), data)
    }
}

/// CellOutput for transaction skeleton, which contains cell data
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct CellOutputEx {
    pub output: CellOutput,
    pub data: Vec<u8>,
}

impl CellOutputEx {
    /// Directly initialize a CellOutputEx
    pub fn new(output: CellOutput, data: Vec<u8>) -> Self {
        CellOutputEx { output, data }
    }

    /// Initialize a CellOutputEx from inner types
    pub fn new_from_scripts(
        lock_script: Script,
        type_script: Option<Script>,
        data: Vec<u8>,
        capacity: Option<Capacity>,
    ) -> Result<Self> {
        let builder = CellOutput::new_builder()
            .lock(lock_script)
            .type_(type_script.pack());
        let output = if let Some(capacity) = capacity {
            builder.capacity(capacity.pack()).build()
        } else {
            builder.build_exact_capacity(Capacity::bytes(data.len())?)?
        };
        Ok(CellOutputEx::new(output, data))
    }

    /// Correct capacity if the declared is less than the occupied
    pub fn correct_capacity(mut self) -> Self {
        let declared_capacity = self.capacity();
        let occupied_capaicty = self.occupied_capacity();
        self.output = self
            .output
            .clone()
            .as_builder()
            .capacity(declared_capacity.max(occupied_capaicty).pack())
            .build();
        self
    }

    /// Exactly occupied capacity of the cell
    pub fn occupied_capacity(&self) -> Capacity {
        self.output
            .occupied_capacity(Capacity::bytes(self.data.len()).unwrap())
            .unwrap()
    }

    /// Declared capacity of the cell
    pub fn capacity(&self) -> Capacity {
        self.output.capacity().unpack()
    }

    /// Cell's lock script
    pub fn lock_script(&self) -> Script {
        self.output.lock()
    }

    /// Cell's type script
    pub fn type_script(&self) -> Option<Script> {
        self.output.type_().to_opt()
    }

    /// Calculate blake2b hash of lock script
    pub fn calc_lock_hash(&self) -> H256 {
        self.lock_script().calc_script_hash().unpack()
    }

    /// Calculate blake2b hash of type script
    pub fn calc_type_hash(&self) -> Option<H256> {
        self.type_script()
            .map(|script| script.calc_script_hash().unpack())
    }

    /// Calculate blake2b hash of cell data
    pub fn data_hash(&self) -> H256 {
        blake2b_256(&self.data).into()
    }
}

/// CellDep for transaction skeleton, which contains output cell and data
#[derive(Debug, Clone)]
pub struct CellDepEx {
    pub name: String,
    pub celldep: CellDep,
    pub output: CellOutputEx,
    pub with_data: bool,
}

impl PartialEq for CellDepEx {
    fn eq(&self, other: &Self) -> bool {
        self.celldep.as_bytes() == other.celldep.as_bytes()
    }
}

impl CellDepEx {
    /// Directly initialize a CellDepEx
    pub fn new(name: String, cell_dep: CellDep, output: CellOutput, data: Option<Vec<u8>>) -> Self {
        if let Some(data) = data {
            CellDepEx {
                name,
                celldep: cell_dep,
                output: CellOutputEx::new(output, data),
                with_data: true,
            }
        } else {
            CellDepEx {
                name,
                celldep: cell_dep,
                output: CellOutputEx::new(output, Vec::new()),
                with_data: false,
            }
        }
    }

    /// Initialize a CellDepEx from out point via CKB RPC
    pub async fn new_from_outpoint<T: RPC>(
        rpc: &T,
        name: String,
        tx_hash: H256,
        index: u32,
        dep_type: DepType,
        with_data: bool,
    ) -> Result<Self> {
        let out_point = OutPoint::new_builder()
            .tx_hash(tx_hash.pack())
            .index(index.pack())
            .build();
        let live_cell = rpc
            .get_live_cell(&out_point.clone().into(), with_data)
            .await?
            .cell
            .ok_or(eyre!(
                "cell not found at ({}:{index})",
                hex::encode(&tx_hash)
            ))?;
        let cell_dep = CellDep::new_builder()
            .out_point(out_point)
            .dep_type(dep_type.into())
            .build();
        let output = live_cell.output.into();
        let data = live_cell.data.map(|v| v.content.into_bytes().to_vec());
        Ok(Self::new(name, cell_dep, output, data))
    }

    /// Initialize a CellDepEx from the ckb-indexer specific cell
    pub fn new_from_indexer_cell(name: String, indexer_cell: Cell, dep_type: DepType) -> Self {
        let out_point = indexer_cell.out_point.into();
        let cell_dep = CellDep::new_builder()
            .out_point(out_point)
            .dep_type(dep_type.into())
            .build();
        let output = indexer_cell.output.into();
        let data = indexer_cell.output_data.map(|v| v.into_bytes().into());
        Self::new(name, cell_dep, output, data)
    }

    /// Retrive cell dep's on-chain output if there's None output field
    pub async fn refresh_cell_output<T: RPC>(&mut self, rpc: &T) -> Result<()> {
        let out_point = self.celldep.out_point().to_owned();
        let new_cell_dep = Self::new_from_outpoint(
            rpc,
            self.name.clone(),
            out_point.tx_hash().unpack(),
            out_point.index().unpack(),
            self.celldep.dep_type().try_into().unwrap(),
            true,
        )
        .await?;
        self.output = new_cell_dep.output;
        Ok(())
    }
}

/// Traditional witness args that contains lock, input_type and output_type, which
/// splited for better composability
#[derive(Debug, Clone)]
pub struct WitnessEx {
    pub empty: bool,
    pub traditional: bool,
    pub lock: Vec<u8>,
    pub input_type: Vec<u8>,
    pub output_type: Vec<u8>,
}

impl Default for WitnessEx {
    fn default() -> Self {
        WitnessEx {
            empty: true,
            traditional: true,
            lock: Vec::new(),
            input_type: Vec::new(),
            output_type: Vec::new(),
        }
    }
}

impl WitnessEx {
    /// Directly initialize a WitnessArgsEx
    pub fn new(lock: Vec<u8>, input_type: Vec<u8>, output_type: Vec<u8>) -> Self {
        WitnessEx {
            empty: false,
            traditional: true,
            lock,
            input_type,
            output_type,
        }
    }

    /// Initialize a WitnessArgsEx and mark it non-traditional
    pub fn new_plain(plain_bytes: Vec<u8>) -> Self {
        WitnessEx {
            empty: false,
            traditional: false,
            lock: plain_bytes,
            input_type: Vec::new(),
            output_type: Vec::new(),
        }
    }

    /// Turn into packed WitnessArgs
    pub fn into_witness_args(self) -> WitnessArgs {
        let bytes_opt = |bytes: Vec<u8>| {
            if bytes.is_empty() {
                None
            } else {
                Some(
                    Bytes::new_builder()
                        .set(bytes.into_iter().map(Into::into).collect())
                        .build(),
                )
            }
        };
        WitnessArgs::new_builder()
            .lock(bytes_opt(self.lock).pack())
            .input_type(bytes_opt(self.input_type).pack())
            .output_type(bytes_opt(self.output_type).pack())
            .build()
    }

    /// Turn into packed bytes of WitnessArgs
    pub fn into_packed_bytes(mut self) -> Bytes {
        if !self.lock.is_empty() || !self.input_type.is_empty() || !self.output_type.is_empty() {
            self.empty = false;
        }
        if self.empty {
            Bytes::default()
        } else if self.traditional {
            self.into_witness_args().as_bytes().pack()
        } else {
            self.into_packed_plain_bytes()
        }
    }

    /// Turn into packed raw bytes, which is normally not in format of WitnessArgs
    pub fn into_packed_plain_bytes(self) -> Bytes {
        let bytes = self
            .lock
            .into_iter()
            .chain(self.input_type)
            .chain(self.output_type)
            .collect::<Vec<_>>();
        bytes.pack()
    }
}

/// A block hash wrapper that contains the link to a cell input
#[derive(Clone, Debug)]
pub struct HeaderDepEx {
    pub block_hash: H256,
    pub header: HeaderView,
    pub cellinput_outpoint: Option<OutPoint>,
}

impl HeaderDepEx {
    pub async fn new<T: RPC>(
        rpc: &T,
        block_hash: H256,
        outpoint: Option<OutPoint>,
    ) -> Result<Self> {
        let header = rpc
            .get_header(&block_hash)
            .await?
            .ok_or(eyre!("header not found"))?;
        Ok(HeaderDepEx {
            block_hash,
            header: header.into(),
            cellinput_outpoint: outpoint,
        })
    }

    pub async fn new_from_outpoint<T: RPC>(rpc: &T, outpoint: OutPoint) -> Result<Self> {
        let tx_hash = outpoint.tx_hash();
        let tx_with_status = rpc
            .get_transaction(&tx_hash.unpack())
            .await?
            .ok_or(eyre!("transaction not found by input outpoint"))?;
        let block_hash = tx_with_status
            .tx_status
            .block_hash
            .ok_or(eyre!("transaction not in block"))?;
        HeaderDepEx::new(rpc, block_hash, Some(outpoint)).await
    }

    pub async fn new_from_block_number<T: RPC>(rpc: &T, block_number: u64) -> Result<Self> {
        let block_hash = rpc
            .get_block_hash(block_number.into())
            .await?
            .ok_or(eyre!("block not found"))?;
        HeaderDepEx::new(rpc, block_hash, None).await
    }
}

impl PartialEq for HeaderDepEx {
    fn eq(&self, other: &Self) -> bool {
        self.block_hash == other.block_hash
    }
}

/// TransactionSkeleton for building transaction
#[derive(Default, Clone, Debug)]
pub struct TransactionSkeleton {
    pub inputs: Vec<CellInputEx>,
    pub outputs: Vec<CellOutputEx>,
    pub celldeps: Vec<CellDepEx>,
    pub witnesses: Vec<WitnessEx>,
    pub headerdeps: Vec<HeaderDepEx>,
}

impl TransactionSkeleton {
    /// Initialize a TransactionSkeleton from packed TransactionView via CKB RPC
    pub async fn new_from_transaction_view<T: RPC>(rpc: &T, tx: &TransactionView) -> Result<Self> {
        let mut skeleton = TransactionSkeleton::default();
        skeleton
            .update_inputs_from_transaction_view(rpc, tx)
            .await?
            .update_celldeps_from_transaction_view(rpc, tx)
            .await?
            .update_headerdeps_from_transaction_view(rpc, tx)
            .await?
            .update_outputs_from_transaction_view(tx)
            .update_witnesses_from_transaction_view(tx)?;
        Ok(skeleton)
    }

    /// Override Inputs part of TransactionSkeleton from packed TransactionView
    pub async fn update_inputs_from_transaction_view<T: RPC>(
        &mut self,
        rpc: &T,
        tx: &TransactionView,
    ) -> Result<&mut Self> {
        let inputs = tx
            .inputs()
            .into_iter()
            .map(|input| {
                let out_point = input.previous_output();
                let tx_hash: H256 = out_point.tx_hash().unpack();
                let index: u32 = out_point.index().unpack();
                let since: u64 = input.since().unpack();
                CellInputEx::new_from_outpoint(rpc, tx_hash, index, Some(since), true)
            })
            .collect::<Vec<_>>();
        self.inputs = join_all(inputs).await.into_iter().collect::<Result<_>>()?;
        Ok(self)
    }

    /// Override CellDeps part of TransactionSkeleton from packed TransactionView
    pub async fn update_celldeps_from_transaction_view<T: RPC>(
        &mut self,
        rpc: &T,
        tx: &TransactionView,
    ) -> Result<&mut Self> {
        let celldeps = tx
            .cell_deps()
            .into_iter()
            .enumerate()
            .map(|(i, cell_dep)| {
                let name = format!("unknown-{i}");
                let out_point = cell_dep.out_point();
                let tx_hash: H256 = out_point.tx_hash().unpack();
                let index: u32 = out_point.index().unpack();
                let dep_type = cell_dep.dep_type().try_into().expect("dep type");
                CellDepEx::new_from_outpoint(rpc, name, tx_hash, index, dep_type, false)
            })
            .collect::<Vec<_>>();
        self.celldeps = join_all(celldeps)
            .await
            .into_iter()
            .collect::<Result<_>>()?;
        Ok(self)
    }

    /// Override HeaderDeps part of TransactionSkeleton from packed TransactionView
    pub async fn update_headerdeps_from_transaction_view<T: RPC>(
        &mut self,
        rpc: &T,
        tx: &TransactionView,
    ) -> Result<&mut Self> {
        let mut headerdeps = vec![];
        for header_dep in tx.header_deps_iter() {
            let block_hash: H256 = header_dep.unpack();
            let header_dep = HeaderDepEx::new(rpc, block_hash, None).await?;
            headerdeps.push(header_dep);
        }
        self.headerdeps = headerdeps;
        Ok(self)
    }

    /// Override Outputs part of TransactionSkeleton from packed TransactionView
    pub fn update_outputs_from_transaction_view(&mut self, tx: &TransactionView) -> &mut Self {
        self.outputs = tx
            .outputs_with_data_iter()
            .map(|(output, data)| CellOutputEx::new(output, data.to_vec()))
            .collect();
        self
    }

    /// Override Witnesses part of TransactionSkeleton from packed TransactionView
    pub fn update_witnesses_from_transaction_view(
        &mut self,
        tx: &TransactionView,
    ) -> Result<&mut Self> {
        self.witnesses = tx
            .witnesses()
            .into_iter()
            .map(|witness| {
                let witness_args = WitnessArgs::from_slice(&witness.raw_data())
                    .map_err(|_| eyre!("invalid witness args"))?;
                let lock = witness_args.lock().to_opt().unwrap_or_default();
                let input_type = witness_args.input_type().to_opt().unwrap_or_default();
                let output_type = witness_args.output_type().to_opt().unwrap_or_default();
                Ok(WitnessEx::new(
                    lock.raw_data().to_vec(),
                    input_type.raw_data().to_vec(),
                    output_type.raw_data().to_vec(),
                ))
            })
            .collect::<Result<_>>()?;
        Ok(self)
    }

    /// Get input cell by index, which may fail if index out of range
    ///
    /// note: if index is `usize::MAX`, return the last input cell
    pub fn get_input_by_index(&self, input_index: usize) -> Result<&CellInputEx> {
        if input_index == usize::MAX {
            self.inputs.last().ok_or(eyre!("transaction input empty"))
        } else {
            self.inputs
                .get(input_index)
                .ok_or(eyre!("transaction input index out of range"))
        }
    }

    /// Push a single input cell
    pub fn input(&mut self, cell_input: CellInputEx) -> Result<&mut Self> {
        if self.contains_input(&cell_input) {
            return Err(eyre!("input already exists"));
        }
        self.inputs.push(cell_input);
        Ok(self)
    }

    /// Push a input cell from lock script via CKB RPC
    pub async fn input_from_script<T: RPC>(
        &mut self,
        rpc: &T,
        lock_script: ScriptEx,
    ) -> Result<&mut Self> {
        let mut search_key = CellQueryOptions::new_lock(lock_script.to_script(self)?);
        search_key.secondary_script_len_range = Some(ValueRangeOption::new(0, 1));
        search_key.data_len_range = Some(ValueRangeOption::new(0, 1));
        search_key.script_search_mode = Some(SearchMode::Exact);
        let mut find_available_input = false;
        let mut iter = GetCellsIter::new(rpc, search_key.into());
        while let Some(cell) = iter.next().await? {
            let cell_input = CellInputEx::new_from_indexer_cell(cell, None);
            if self.contains_input(&cell_input) {
                continue;
            }
            self.inputs.push(cell_input);
            find_available_input = true;
            break;
        }
        if !find_available_input {
            return Err(eyre!("no available input"));
        }
        Ok(self)
    }

    /// Push a input cell from ckb address via CKB RPC, which is majorly used to inject capacity
    pub async fn input_from_address<T: RPC>(
        &mut self,
        rpc: &T,
        address: Address,
    ) -> Result<&mut Self> {
        self.input_from_script(rpc, address.payload().into()).await
    }

    /// Push a batch of input cells
    pub fn inputs(&mut self, cell_inputs: Vec<CellInputEx>) -> Result<&mut Self> {
        for cell_input in &cell_inputs {
            if self.contains_input(cell_input) {
                return Err(eyre!("input already exists"));
            }
        }
        self.inputs.extend(cell_inputs);
        Ok(self)
    }

    /// Check if input cell exists
    pub fn contains_input(&self, cell_input: &CellInputEx) -> bool {
        self.inputs.contains(cell_input)
    }

    /// Remove input cell by index, which may fail if index out of range
    pub fn remove_input(&mut self, index: usize) -> Result<CellInputEx> {
        if self.inputs.len() <= index {
            return Err(eyre!("input index out of range"));
        }
        Ok(self.inputs.remove(index))
    }

    /// Pop the last input cell, which may fail if no input cell
    pub fn pop_input(&mut self) -> Result<CellInputEx> {
        self.inputs.pop().ok_or(eyre!("no input to pop"))
    }

    /// Get output cell by index, which may fail if index out of range
    ///
    /// note: if index is `usize::MAX`, return the last output cell
    pub fn get_output_by_index(&self, output_index: usize) -> Result<&CellOutputEx> {
        if output_index == usize::MAX {
            return self.outputs.last().ok_or(eyre!("no output"));
        } else {
            self.outputs
                .get(output_index)
                .ok_or(eyre!("output index out of range"))
        }
    }

    /// Push a single output cell
    pub fn output(&mut self, cell_output: CellOutputEx) -> &mut Self {
        self.outputs.push(cell_output);
        self
    }

    /// Push a output cell from ckb address, which is majorly used to receive capacity change
    pub fn output_from_address(&mut self, address: Address, data: Vec<u8>) -> Result<&mut Self> {
        self.output_from_script(address.payload().into(), data)
    }

    /// Push a output cell from lock script
    pub fn output_from_script(
        &mut self,
        lock_script: ScriptEx,
        data: Vec<u8>,
    ) -> Result<&mut Self> {
        let output = CellOutput::new_builder()
            .lock(lock_script.to_script(self)?)
            .build_exact_capacity(Capacity::zero())
            .expect("build exact capacity");
        Ok(self.output(CellOutputEx::new(output, data)))
    }

    /// Push a batch of output cells
    pub fn outputs(&mut self, cell_outputs: Vec<CellOutputEx>) -> &mut Self {
        self.outputs.extend(cell_outputs);
        self
    }

    /// Remove output cell by index, which may fail if index out of range
    pub fn remove_output(&mut self, index: usize) -> Result<CellOutputEx> {
        if self.outputs.len() <= index {
            return Err(eyre!("output index out of range"));
        }
        Ok(self.outputs.remove(index))
    }

    /// Pop the last output cell, which may fail if no output cell
    pub fn pop_output(&mut self) -> Result<CellOutputEx> {
        self.outputs.pop().ok_or(eyre!("no output to pop"))
    }

    /// Push a single cell dep
    pub fn celldep(&mut self, cell_dep: CellDepEx) -> &mut Self {
        if !self.celldeps.contains(&cell_dep) {
            self.celldeps.push(cell_dep);
        }
        self
    }

    /// Check if cell dep exists
    pub fn contains_celldep(&self, cell_dep: &CellDepEx) -> bool {
        self.celldeps.contains(cell_dep)
    }

    /// Check if cell dep exists by name
    pub fn get_celldep_by_name(&self, name: &str) -> Option<&CellDepEx> {
        self.celldeps.iter().find(|celldep| celldep.name == name)
    }

    /// Push a batch of cell deps
    pub fn celldeps(&mut self, cell_deps: Vec<CellDepEx>) -> &mut Self {
        cell_deps.into_iter().for_each(|v| {
            if !self.celldeps.contains(&v) {
                self.celldeps.push(v);
            }
        });
        self
    }

    /// Push a single header dep
    pub fn headerdep(&mut self, header_dep: HeaderDepEx) -> &mut Self {
        if !self.headerdeps.contains(&header_dep) {
            self.headerdeps.push(header_dep);
        }
        self
    }

    /// Push a single witness
    pub fn witness(&mut self, witness: WitnessEx) -> &mut Self {
        self.witnesses.push(witness);
        self
    }

    /// Push a batch of witnesses
    pub fn witnesses(&mut self, witnesses: Vec<WitnessEx>) -> &mut Self {
        self.witnesses.extend(witnesses);
        self
    }

    /// Accumulate total input cells' capacity
    pub fn total_inputs_capacity(&self) -> Capacity {
        self.inputs
            .iter()
            .map(|input| input.output.capacity())
            .fold(Capacity::zero(), |acc, x| acc.safe_add(x).unwrap())
    }

    /// Accumulate total output cells' capacity
    pub fn total_outputs_capacity(&self) -> Capacity {
        self.outputs
            .iter()
            .map(|output| output.capacity())
            .fold(Capacity::zero(), |acc, x| acc.safe_add(x).unwrap())
    }

    /// Return the difference between total outputs capacity and total inputs capacity, saturating at zero
    pub fn needed_capacity(&self) -> Capacity {
        let inputs_capacity = self.total_inputs_capacity();
        let outputs_capacity = self.total_outputs_capacity();
        if inputs_capacity > outputs_capacity {
            Capacity::zero()
        } else {
            outputs_capacity.safe_sub(inputs_capacity).unwrap()
        }
    }

    /// Return the difference between total inputs capacity and total outputs capacity, saturating at zero
    pub fn exceeded_capacity(&self) -> Capacity {
        let inputs_capacity = self.total_inputs_capacity();
        let outputs_capacity = self.total_outputs_capacity();
        if inputs_capacity > outputs_capacity {
            inputs_capacity.safe_sub(outputs_capacity).unwrap()
        } else {
            Capacity::zero()
        }
    }

    /// Lock script groups of input and output cells
    pub fn lock_script_groups(&self, lock_script: &ScriptEx) -> (Vec<usize>, Vec<usize>) {
        let mut input_groups = Vec::new();
        let mut output_groups = Vec::new();
        for (i, input) in self.inputs.iter().enumerate() {
            if lock_script == &input.output.lock_script() {
                input_groups.push(i);
            }
        }
        for (i, output) in self.outputs.iter().enumerate() {
            if lock_script == &output.lock_script() {
                output_groups.push(i);
            }
        }
        (input_groups, output_groups)
    }

    /// Calculate type id based on the first input cell and output index
    pub fn calc_type_id(&self, out_index: usize) -> Result<H256> {
        let Some(first_input) = self.inputs.first() else {
            return Err(eyre!("empty input"));
        };
        let mut hasher = Blake2bBuilder::new(32)
            .personal(b"ckb-default-hash")
            .build();
        hasher.update(first_input.input.as_slice());
        hasher.update(&(out_index as u64).to_le_bytes());
        let mut type_id = [0u8; 32];
        hasher.finalize(&mut type_id);
        Ok(type_id.into())
    }

    /// Find CelldepEx by script, support both type and data hash
    pub fn find_celldep_by_script(&self, script: &ScriptEx) -> Option<(usize, &CellDepEx)> {
        if let ScriptEx::Reference(name, _) = script {
            return self
                .celldeps
                .iter()
                .enumerate()
                .find_map(|(index, celldep)| {
                    if &celldep.name == name {
                        Some((index, celldep))
                    } else {
                        None
                    }
                });
        }
        let index = self
            .celldeps
            .iter()
            .enumerate()
            .find_map(|(index, celldep)| {
                let expected_code_hash =
                    match (script.hash_type(), &celldep.output, celldep.with_data) {
                        (Ok(ScriptHashType::Type), output, _) => {
                            if let Some(type_hash) = output.calc_type_hash() {
                                type_hash
                            } else {
                                H256::default()
                            }
                        }
                        (Ok(_), output, true) => output.data_hash(),
                        _ => H256::default(),
                    };
                if script.code_hash().unwrap_or_default() == expected_code_hash {
                    Some(index)
                } else {
                    None
                }
            });
        index.map(|index| (index, &self.celldeps[index]))
    }

    /// Calculate transaction fee based on current minimal fee rate and additional fee rate
    pub async fn fee<T: RPC>(&self, rpc: &T, additinal_fee_rate: u64) -> Result<Capacity> {
        let fee_rate = u64::from(rpc.tx_pool_info().await?.min_fee_rate) + additinal_fee_rate;
        let tx = self.clone().into_transaction_view();
        let tx_fee = tx.data().as_slice().len() as u64 * fee_rate / 1000;
        Ok(Capacity::shannons(tx_fee))
    }

    /// Balance the transaction by adding input cells until the needed capacity is satisfied
    ///
    /// Support two modes:
    /// 1. Balance by adding an extra change cell for receiving the change capacity - ChangeReceiver::Address
    /// 2. Balance by choosing an existing output cell as the change cell - ChangeReceiver::Output
    pub async fn balance<T: RPC>(
        &mut self,
        rpc: &T,
        fee: Capacity,
        balancer: ScriptEx,
        change_receiver: ChangeReceiver,
    ) -> Result<&mut Self> {
        let change_cell_index = match change_receiver {
            ChangeReceiver::Address(changer) => {
                self.output_from_address(changer, Default::default())?;
                self.outputs.len() - 1
            }
            ChangeReceiver::Script(changer) => {
                self.output_from_script(changer, Default::default())?;
                self.outputs.len() - 1
            }
            ChangeReceiver::Output(index) => {
                if self.outputs.len() <= index {
                    return Err(eyre!("change output index out of range"));
                }
                index
            }
        };
        while self.exceeded_capacity() < fee {
            self.input_from_script(rpc, balancer.clone()).await?;
        }
        let exceeded_capacity_beyond_fee = self.exceeded_capacity().safe_sub(fee).unwrap();
        let old_capacity: Capacity = self.outputs[change_cell_index].output.capacity().unpack();
        let new_capacity = old_capacity.safe_add(exceeded_capacity_beyond_fee).unwrap();
        self.outputs[change_cell_index].output = self.outputs[change_cell_index]
            .output
            .clone()
            .as_builder()
            .capacity(new_capacity.pack())
            .build();
        if self.exceeded_capacity() != fee {
            return Err(eyre!("failed to balance transaction"));
        }
        Ok(self)
    }

    /// Turn into ResolvedTransaction for contracts native debugging
    pub async fn into_resolved_transaction<T: RPC>(self, rpc: &T) -> Result<ResolvedTransaction> {
        let tx = self.clone().into_transaction_view();
        let mut resolved_inputs = vec![];
        for v in self.inputs {
            let out_point = v.input.previous_output();
            let meta = CellMetaBuilder::from_cell_output(v.output.output, v.output.data.into())
                .out_point(out_point)
                .build();
            resolved_inputs.push(meta);
        }
        let mut resolved_cell_deps = vec![];
        let mut resolved_dep_groups = vec![];
        for mut v in self.celldeps {
            if !v.with_data {
                v.refresh_cell_output(rpc).await?;
            }
            let output = v.output;
            if v.celldep.dep_type() == DepType::DepGroup.into() {
                // dep group data is a list of out points
                let sub_out_points = OutPointVec::from_slice(&output.data)
                    .map_err(|_| eyre!("invalid dep group"))?;
                for sub_out_point in sub_out_points {
                    let tx_hash = sub_out_point.tx_hash().unpack();
                    let index = sub_out_point.index().unpack();
                    let sub_celldep = CellDepEx::new_from_outpoint(
                        rpc,
                        "".to_string(),
                        tx_hash,
                        index,
                        DepType::Code,
                        true,
                    )
                    .await?;
                    let sub_output = sub_celldep.output;
                    let meta = CellMetaBuilder::from_cell_output(
                        sub_output.output,
                        sub_output.data.into(),
                    )
                    .out_point(sub_out_point)
                    .build();
                    resolved_cell_deps.push(meta);
                }
                let meta = CellMetaBuilder::from_cell_output(output.output, output.data.into())
                    .out_point(v.celldep.out_point())
                    .build();
                resolved_dep_groups.push(meta);
            } else {
                let meta = CellMetaBuilder::from_cell_output(output.output, output.data.into())
                    .out_point(v.celldep.out_point())
                    .build();
                resolved_cell_deps.push(meta);
            }
        }
        Ok(ResolvedTransaction {
            transaction: tx,
            resolved_cell_deps,
            resolved_inputs,
            resolved_dep_groups,
        })
    }

    /// Turn into packed TransactionView
    pub fn into_transaction_view(self) -> TransactionView {
        let inputs = self.inputs.into_iter().map(|v| v.input).collect::<Vec<_>>();
        let celldeps = self
            .celldeps
            .into_iter()
            .map(|v| v.celldep)
            .collect::<Vec<_>>();
        let mut outputs = vec![];
        let mut outputs_data = vec![];
        self.outputs.into_iter().for_each(|v| {
            outputs.push(v.output);
            outputs_data.push(v.data.pack());
        });
        let witnesses = self
            .witnesses
            .into_iter()
            .map(|v| v.into_packed_bytes())
            .collect::<Vec<_>>();
        let headers = self
            .headerdeps
            .into_iter()
            .map(|v| v.block_hash.pack())
            .collect::<Vec<_>>();
        TransactionView::new_advanced_builder()
            .inputs(inputs)
            .outputs(outputs)
            .outputs_data(outputs_data)
            .cell_deps(celldeps)
            .witnesses(witnesses)
            .header_deps(headers)
            .build()
    }

    /// Consume and send this transaction, and then wait for confirmation
    ///
    /// `confirm_count`: wait how many blocks to firm confirmation, if 0, return immidiently after sending
    /// `wait_timeout`: wait how much time until throwing timeout error, if None, no timeout
    pub async fn send_and_wait<T: RPC>(
        self,
        rpc: &T,
        confirm_count: u8,
        wait_timeout: Option<Duration>,
    ) -> Result<H256> {
        let hash = rpc
            .send_transaction(self.into(), Some(OutputsValidator::Passthrough))
            .await?;
        if confirm_count == 0 {
            return Ok(hash);
        }
        let mut block_number = 0u64;
        let mut time_used = Duration::from_secs(0);
        let interval = Duration::from_secs(3);
        loop {
            if let Some(timeout) = wait_timeout {
                if time_used > timeout {
                    return Err(eyre!("timeout waiting tx: {hash:#x}"));
                }
                time_used += interval;
            }
            tokio::time::sleep(interval).await;
            let tx = rpc
                .get_transaction(&hash)
                .await?
                .ok_or(eyre!("no tx found: {hash:#x}"))?;
            if tx.tx_status.status == Status::Rejected {
                let reason = tx.tx_status.reason.unwrap_or_else(|| "unknown".to_string());
                return Err(eyre!("tx {hash:#x} rejected, reason: {reason}"));
            }
            if tx.tx_status.status != Status::Committed {
                continue;
            }
            if block_number == 0 {
                if let Some(number) = tx.tx_status.block_number {
                    block_number = number.into();
                }
            } else {
                let tip_number = rpc.get_tip_header().await?.inner.number;
                if u64::from(tip_number) >= block_number + confirm_count as u64 {
                    break;
                }
            }
        }
        Ok(hash)
    }
}

impl Display for TransactionSkeleton {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let tx = self.clone().into_transaction_view();
        let tx_json = ckb_jsonrpc_types::TransactionView::from(tx);
        f.write_fmt(format_args!(
            "{}",
            serde_json::to_string_pretty(&tx_json).unwrap()
        ))
    }
}

impl From<TransactionSkeleton> for TransactionView {
    fn from(value: TransactionSkeleton) -> Self {
        value.into_transaction_view()
    }
}

impl From<TransactionSkeleton> for ckb_jsonrpc_types::Transaction {
    fn from(value: TransactionSkeleton) -> Self {
        let view: TransactionView = value.into();
        view.data().into()
    }
}

/// Indicate how to receive the change capacity while balancing transaction
pub enum ChangeReceiver {
    /// Balance by adding an extra change cell from ckb address
    Address(Address),
    /// Balance by adding an extra change cell from lock script
    Script(ScriptEx),
    /// Balance by choosing an existing output cell
    Output(usize),
}

impl From<Address> for ChangeReceiver {
    fn from(value: Address) -> Self {
        ChangeReceiver::Address(value)
    }
}

impl From<Script> for ChangeReceiver {
    fn from(value: Script) -> Self {
        ChangeReceiver::Script(value.into())
    }
}

impl From<ScriptEx> for ChangeReceiver {
    fn from(value: ScriptEx) -> Self {
        ChangeReceiver::Script(value)
    }
}

impl From<usize> for ChangeReceiver {
    fn from(value: usize) -> Self {
        ChangeReceiver::Output(value)
    }
}


================================================
File: calculate/src/instruction/mod.rs
================================================
use eyre::Result;

use crate::{
    operation::{Log, Operation},
    rpc::{RpcClient, RPC},
    skeleton::TransactionSkeleton,
};

#[cfg(not(target_arch = "wasm32"))]
pub mod predefined;

pub type DefaultInstruction = Instruction<RpcClient>;

/// Instruction is a collection of operations that can be executed in sequence, to assemble transaction skeleton
pub struct Instruction<T: RPC> {
    operations: Vec<Box<dyn Operation<T>>>,
}

impl<T: RPC> Default for Instruction<T> {
    fn default() -> Self {
        Instruction {
            operations: Vec::new(),
        }
    }
}

impl<T: RPC> Instruction<T> {
    pub fn new(operations: Vec<Box<dyn Operation<T>>>) -> Self {
        Instruction { operations }
    }

    pub fn push(&mut self, operation: Box<dyn Operation<T>>) -> &mut Self {
        self.operations.push(operation);
        self
    }

    pub fn pop(&mut self) -> Option<Box<dyn Operation<T>>> {
        self.operations.pop()
    }

    pub fn remove(&mut self, index: usize) -> Box<dyn Operation<T>> {
        self.operations.remove(index)
    }

    pub fn append(&mut self, operations: Vec<Box<dyn Operation<T>>>) -> &mut Self {
        self.operations.extend(operations);
        self
    }

    pub fn merge(&mut self, instruction: Instruction<T>) -> &mut Self {
        self.operations.extend(instruction.operations);
        self
    }

    /// Execute all operations in sequence to assemble transaction skeleton
    pub async fn run(
        self,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        log: &mut Log,
    ) -> Result<()> {
        for operation in self.operations {
            operation.run(rpc, skeleton, log).await?;
        }
        Ok(())
    }
}

/// Take responsibility for executing instructions and then assemble transaction skeleton
pub struct TransactionCalculator<T: RPC> {
    instructions: Vec<Instruction<T>>,
    log: Log,
}

impl<T: RPC> Default for TransactionCalculator<T> {
    fn default() -> Self {
        TransactionCalculator {
            instructions: Vec::new(),
            log: Log::new(),
        }
    }
}

impl<T: RPC> TransactionCalculator<T> {
    pub fn new(instructions: Vec<Instruction<T>>) -> Self {
        TransactionCalculator {
            instructions,
            log: Log::new(),
        }
    }

    pub fn instruction(mut self, instruction: Instruction<T>) -> Self {
        self.instructions.push(instruction);
        self
    }

    pub async fn new_skeleton(self, rpc: &T) -> Result<(TransactionSkeleton, Log)> {
        let mut skeleton = TransactionSkeleton::default();
        let log = self.apply_skeleton(rpc, &mut skeleton).await?;
        Ok((skeleton, log))
    }

    pub async fn apply_skeleton(self, rpc: &T, skeleton: &mut TransactionSkeleton) -> Result<Log> {
        let mut log = self.log;
        for instruction in self.instructions {
            instruction.run(rpc, skeleton, &mut log).await?;
        }
        Ok(log)
    }
}


================================================
File: calculate/src/instruction/predefined.rs
================================================
use std::{path::PathBuf, usize};

use ckb_sdk::HumanCapacity;
use ckb_types::H256;
use secp256k1::SecretKey;

use crate::{
    address::Address,
    instruction::DefaultInstruction,
    operation::{basic::*, dao::*, spore::*},
};

/// Transfer CKB from one address to another
///
/// # Parameters
/// - `from`: The address to transfer CKB from
/// - `to`: The address to transfer CKB to
/// - `ckb`: The amount of CKB to transfer, e.g. "100.5 CKB"
/// - `sign`:
///     - 0: privkey => The private key to sign the transaction, if not provided, transaction won't balance and sign
///     - 1: additional_fee_rate => The additional fee rate to add
pub fn secp256k1_sighash_transfer(
    from: &Address,
    to: &Address,
    ckb: HumanCapacity,
) -> DefaultInstruction {
    DefaultInstruction::new(vec![
        Box::new(AddSecp256k1SighashCellDep {}),
        Box::new(AddInputCellByAddress {
            address: from.clone(),
        }),
        Box::new(AddOutputCell {
            lock_script: to.payload().into(),
            type_script: None,
            data: Vec::new(),
            capacity: ckb.into(),
            absolute_capacity: true,
            type_id: false,
        }),
    ])
}

/// Balance transaction with capacity and then sign it
///
/// # Parameters
/// - `signer`: The address who is supposed to provide capacity to balance, in the meantime, receive the change
/// - `privkey`: The private key to sign the transaction
/// - `additional_fee_rate`: The additional fee rate to add
pub fn balance_and_sign(
    signer: &Address,
    privkey: SecretKey,
    additional_fee_rate: u64,
) -> DefaultInstruction {
    DefaultInstruction::new(vec![
        Box::new(BalanceTransaction {
            balancer: signer.payload().into(),
            change_receiver: signer.clone().into(),
            additional_fee_rate,
        }),
        Box::new(AddSecp256k1SighashSignatures {
            user_lock_scripts: vec![signer.payload().into()],
            user_private_keys: vec![privkey],
        }),
    ])
}

/// Balance transaction with capacity and then sign it with native CKB-CLI
///
/// # Parameters
/// - `signer`: The address who is supposed to provide capacity to balance, in the meantime, receive the change
/// - `additional_fee_rate`: The additional fee rate to add
/// - `cache_path`: The path to store the transaction cache file, default is `/tmp`
pub fn balance_and_sign_with_ckb_cli(
    signer: &Address,
    additional_fee_rate: u64,
    cache_path: Option<PathBuf>,
) -> DefaultInstruction {
    DefaultInstruction::new(vec![
        Box::new(BalanceTransaction {
            balancer: signer.payload().into(),
            change_receiver: signer.clone().into(),
            additional_fee_rate,
        }),
        Box::new(AddSecp256k1SighashSignaturesWithCkbCli {
            signer_address: signer.clone(),
            cache_path: cache_path.unwrap_or_else(|| PathBuf::from("/tmp")),
            keep_cache_file: true,
        }),
    ])
}

pub struct Spore {
    pub owner: Option<Address>, // if None, use minter as owner
    pub content_type: String,
    pub content: Vec<u8>,
    pub cluster_id: Option<H256>,
}

/// Mint multiple spore cells
///
/// # Parameters
/// - `minter`: The address to mint Spore
/// - `spores`: The Spores to mint
/// - `cluster_lock_proxy`: Whether to use cluster lock proxy
pub fn mint_spores(
    minter: &Address,
    spores: Vec<Spore>,
    cluster_lock_proxy: bool,
) -> DefaultInstruction {
    let mut mint = DefaultInstruction::new(vec![
        Box::new(AddSecp256k1SighashCellDep {}),
        // Used to calculate the spore unique id
        Box::new(AddInputCellByAddress {
            address: minter.clone(),
        }),
    ]);
    let authority_mode = if cluster_lock_proxy {
        ClusterAuthorityMode::LockProxy
    } else {
        ClusterAuthorityMode::ClusterCell
    };
    for Spore {
        owner,
        content_type,
        content,
        cluster_id,
    } in spores
    {
        mint.push(Box::new(AddSporeOutputCell {
            lock_script: owner.unwrap_or_else(|| minter.clone()).into(),
            content_type,
            content,
            cluster_id,
            authority_mode: authority_mode.clone(),
        }));
    }
    mint.push(Box::new(AddSporeActions {}));
    mint
}

/// Transfer multiple spore cells
///
/// # Parameters
/// - `from`: The address to transfer Spore from
/// - `spores`: The Spores to transfer
///     - `0`: The address to transfer Spore to
///     - `1`: The Spore ID to transfer
pub fn transfer_spores(from: &Address, spores: Vec<(Address, H256)>) -> DefaultInstruction {
    let mut transfer = DefaultInstruction::new(vec![Box::new(AddSecp256k1SighashCellDep {})]);
    for (to, spore_id) in spores {
        transfer
            .push(Box::new(AddSporeInputCellBySporeId {
                spore_id,
                check_owner: Some(from.clone().into()),
            }))
            .push(Box::new(AddOutputCellByInputIndex {
                input_index: usize::MAX,
                lock_script: Some(to.into()),
                type_script: None,
                data: None,
                adjust_capacity: true,
            }));
    }
    transfer.push(Box::new(AddSporeActions {}));
    transfer
}

/// Burn multiple spore cells
///
/// # Parameters
/// - `owner`: The address to burn Spore from
/// - `spores`: The Spores to burn
pub fn burn_spores(owner: &Address, spores: Vec<H256>) -> DefaultInstruction {
    let mut burn = DefaultInstruction::new(vec![Box::new(AddSecp256k1SighashCellDep {})]);
    spores.into_iter().for_each(|spore_id| {
        burn.push(Box::new(AddSporeInputCellBySporeId {
            spore_id,
            check_owner: Some(owner.clone().into()),
        }));
    });
    burn.push(Box::new(AddSporeActions {}));
    burn
}

pub struct Cluster {
    pub owner: Option<Address>, // if None, use minter as owner
    pub cluster_name: String,
    pub cluster_description: Vec<u8>,
}

/// Mint multiple cluster cells
///
/// # Parameters
/// - `minter`: The address to mint Cluster
/// - `clusters`: The Clusters to mint
pub fn mint_clusters(minter: &Address, clusters: Vec<Cluster>) -> DefaultInstruction {
    let mut mint = DefaultInstruction::new(vec![
        Box::new(AddSecp256k1SighashCellDep {}),
        Box::new(AddInputCellByAddress {
            address: minter.clone(),
        }),
    ]);
    for Cluster {
        owner,
        cluster_name,
        cluster_description,
    } in clusters
    {
        mint.push(Box::new(AddClusterOutputCell {
            lock_script: owner.unwrap_or_else(|| minter.clone()).into(),
            name: cluster_name,
            description: cluster_description,
        }));
    }
    mint.push(Box::new(AddSporeActions {}));
    mint
}

/// Transfer multiple cluster cells
///
/// # Parameters
/// - `from`: The address to transfer Cluster from
/// - `clusters`: The Clusters to transfer
pub fn transfer_clusters(from: &Address, clusters: Vec<(Address, H256)>) -> DefaultInstruction {
    let mut transfer = DefaultInstruction::new(vec![
        Box::new(AddSecp256k1SighashCellDep {}),
        Box::new(AddInputCellByAddress {
            address: from.clone(),
        }),
    ]);
    for (to, cluster_id) in clusters {
        transfer
            .push(Box::new(AddClusterInputCellByClusterId { cluster_id }))
            .push(Box::new(AddOutputCellByInputIndex {
                input_index: usize::MAX,
                lock_script: Some(to.into()),
                type_script: None,
                data: None,
                adjust_capacity: true,
            }));
    }
    transfer.push(Box::new(AddSporeActions {}));
    transfer
}

/// Deposit capacity to Nervos DAO
///
/// # Parameters
/// - `depositer`: The address to deposit capacity
/// - `ckb`: The amount of CKB to deposit, e.g. "100.5 CKB"
pub fn dao_deposit(depositer: &Address, ckb: HumanCapacity) -> DefaultInstruction {
    DefaultInstruction::new(vec![
        Box::new(AddSecp256k1SighashCellDep {}),
        Box::new(AddDaoDepositOutputCell {
            owner: depositer.clone().into(),
            deposit_capacity: ckb.into(),
        }),
    ])
}

/// Withdraw capacity from Nervos DAO, which only makes a mark as phase one
///
/// # Parameters
/// - `depositer`: The address to withdraw capacity
/// - `upperbound_capacity`: The maximum capacity to withdraw from Nervos DAO
/// - `upperbound_timestamp`: The upperbound timestamp that only choose cells before it
/// - `transfer_to`: if provided, the capacity will be transferred to this address
pub fn dao_withdraw_phase_one(
    depositer: &Address,
    upperbound_capacity: Option<HumanCapacity>,
    upperbound_timestamp: Option<u64>,
    transfer_to: Option<&Address>,
) -> DefaultInstruction {
    DefaultInstruction::new(vec![
        Box::new(AddSecp256k1SighashCellDep {}),
        Box::new(AddDaoWithdrawPhaseOneCells {
            maximal_withdraw_capacity: upperbound_capacity.map(Into::into).unwrap_or(u64::MAX),
            upperbound_timesamp: upperbound_timestamp.unwrap_or(u64::MAX),
            owner: depositer.clone().into(),
            transfer_to: transfer_to.map(|v| v.clone().into()),
            throw_if_no_avaliable: true,
        }),
    ])
}

/// Withdraw capacity from Nervos DAO, which actually withdraws the capacity
///
/// # Parameters
/// - `withdrawer`: The address to withdraw capacity
/// - `upperbound_capacity`: The maximum capacity to withdraw from Nervos DAO
/// - `transfer_to`: if provided, the capacity will be transferred to this address
pub fn dao_withdraw_phase_two(
    withdrawer: &Address,
    upperbound_capacity: Option<HumanCapacity>,
    transfer_to: Option<&Address>,
) -> DefaultInstruction {
    DefaultInstruction::new(vec![
        Box::new(AddSecp256k1SighashCellDep {}),
        Box::new(AddDaoWithdrawPhaseTwoCells {
            maximal_withdraw_capacity: upperbound_capacity.map(Into::into).unwrap_or(u64::MAX),
            owner: withdrawer.clone().into(),
            transfer_to: transfer_to.map(|v| v.clone().into()),
            throw_if_no_avaliable: true,
        }),
    ])
}

// TODO: Add more predefined instructions here, e.g. xUDT


================================================
File: calculate/src/operation/basic.rs
================================================
#![allow(clippy::mutable_key_type)]

use std::{
    collections::HashMap,
    fs,
    io::Write,
    path::PathBuf,
    process::{Command, Stdio},
};

use async_trait::async_trait;
use ckb_jsonrpc_types::{JsonBytes, Transaction};
use ckb_types::{
    core::{Capacity, DepType},
    packed::CellOutput,
    prelude::{Builder, Entity, Pack, Unpack},
    H160, H256,
};
use eyre::{eyre, Result};
use serde_json::Value;

#[cfg(not(target_arch = "wasm32"))]
use ckb_sdk::{
    traits::DefaultCellDepResolver,
    transaction::signer::{SignContexts, TransactionSigner},
    types::transaction_with_groups::TransactionWithScriptGroupsBuilder,
    NetworkInfo,
};

#[cfg(not(target_arch = "wasm32"))]
use ckb_types::h256;

#[cfg(not(target_arch = "wasm32"))]
use secp256k1::SecretKey;

use crate::{
    address::Address,
    indexer::{CellQueryOptions, SearchKey, SearchMode, ValueRangeOption},
    operation::{Log, Operation},
    rpc::{GetCellsIter, RPC},
    skeleton::{
        CellDepEx, CellInputEx, CellOutputEx, ChangeReceiver, HeaderDepEx, ScriptEx,
        TransactionSkeleton, WitnessEx, TYPE_ID_CODE_HASH,
    },
};

#[cfg(not(target_arch = "wasm32"))]
use crate::rpc::Network;

/// Operation that add cell dep to transaction skeleton by tx hash with index
pub struct AddCellDep {
    pub name: String,
    pub tx_hash: H256,
    pub index: u32,
    pub dep_type: DepType,
    pub with_data: bool,
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddCellDep {
    async fn run(
        self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        _: &mut Log,
    ) -> Result<()> {
        if skeleton.get_celldep_by_name(&self.name).is_none() {
            let cell_dep = CellDepEx::new_from_outpoint(
                rpc,
                self.name,
                self.tx_hash,
                self.index,
                self.dep_type,
                self.with_data,
            )
            .await?;
            skeleton.celldep(cell_dep);
        }
        Ok(())
    }
}

/// Operation that add cell dep to transaction skeleton by type script, which is type id for specific
pub struct AddCellDepByType {
    pub name: String,
    pub type_script: ScriptEx,
    pub dep_type: DepType,
    pub with_data: bool,
}

impl AddCellDepByType {
    fn search_key(&self, skeleton: &TransactionSkeleton) -> Result<SearchKey> {
        let mut query = CellQueryOptions::new_type(self.type_script.clone().to_script(skeleton)?);
        query.script_search_mode = Some(SearchMode::Exact);
        if self.with_data {
            query.with_data = Some(true);
        }
        Ok(query.into())
    }
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddCellDepByType {
    async fn run(
        self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        _: &mut Log,
    ) -> Result<()> {
        if skeleton.get_celldep_by_name(&self.name).is_none() {
            let mut find_avaliable = false;
            let mut iter = GetCellsIter::new(rpc, self.search_key(skeleton)?);
            if let Some(cell) = iter.next().await? {
                let cell_dep = CellDepEx::new_from_indexer_cell(self.name, cell, self.dep_type);
                find_avaliable = true;
                skeleton.celldep(cell_dep);
            }
            if !find_avaliable {
                return Err(eyre!("cell dep not found"));
            }
        }
        Ok(())
    }
}

#[cfg(not(target_arch = "wasm32"))]
/// Operation that add secp256k1_sighash_all cell dep to transaction skeleton
pub struct AddSecp256k1SighashCellDep {}

#[cfg(not(target_arch = "wasm32"))]
#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddSecp256k1SighashCellDep {
    async fn run(
        self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        _: &mut Log,
    ) -> Result<()> {
        let celldep = match rpc.network() {
            Network::Custom(_) => {
                let genesis = rpc.get_block_by_number(0.into()).await?.unwrap();
                let resolver =
                    DefaultCellDepResolver::from_genesis(&genesis.clone().into()).expect("genesis");
                let (sighash_celldep, _) = resolver.sighash_dep().expect("sighash dep");
                let output: CellOutput = {
                    let tx_hash = sighash_celldep.out_point().tx_hash().unpack();
                    let tx = genesis
                        .transactions
                        .into_iter()
                        .find(|tx| tx.hash == tx_hash)
                        .unwrap();
                    let out_index: u32 = sighash_celldep.out_point().index().unpack();
                    tx.inner.outputs[out_index as usize].clone().into()
                };
                CellDepEx {
                    name: "secp256k1_sighash_all".to_string(),
                    celldep: sighash_celldep.clone(),
                    output: CellOutputEx::new(output, vec![]),
                    with_data: false,
                }
            }
            Network::Testnet => {
                CellDepEx::new_from_outpoint(
                    rpc,
                    "secp256k1_sighash_all".to_string(),
                    h256!("0xf8de3bb47d055cdf460d93a2a6e1b05f7432f9777c8c474abf4eec1d4aee5d37"),
                    0,
                    DepType::DepGroup,
                    false,
                )
                .await?
            }
            Network::Mainnet => {
                CellDepEx::new_from_outpoint(
                    rpc,
                    "secp256k1_sighash_all".to_string(),
                    h256!("0x71a7ba8fc96349fea0ed3a5c47992e3b4084b031a42264a018e0072e8172e46c"),
                    0,
                    DepType::DepGroup,
                    false,
                )
                .await?
            }
            _ => return Err(eyre!("secp256k1_sighash_all not valid for fake network")),
        };
        skeleton.celldep(celldep);
        Ok(())
    }
}

/// Operation that add a standalone header dep to transaction without linking to any input cell
pub struct AddHeaderDep {
    pub block_hash: H256,
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddHeaderDep {
    async fn run(
        self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        _: &mut Log,
    ) -> Result<()> {
        let header_dep = HeaderDepEx::new(rpc, self.block_hash, None).await?;
        skeleton.headerdep(header_dep);
        Ok(())
    }
}

/// Operation that add a header dep to transaction by block number
pub struct AddHeaderDepByBlockNumber {
    pub block_number: u64,
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddHeaderDepByBlockNumber {
    async fn run(
        self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        _: &mut Log,
    ) -> Result<()> {
        let block_hash = rpc
            .get_block_hash(self.block_number.into())
            .await?
            .ok_or(eyre!(
                "block hash not found for block number {}",
                self.block_number
            ))?;
        let header_dep = HeaderDepEx::new(rpc, block_hash, None).await?;
        skeleton.headerdep(header_dep);
        Ok(())
    }
}

/// Operation that add a header dep to transaction by input index, which will link to that input cell
pub struct AddHeaderDepByInputIndex {
    pub input_index: usize,
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddHeaderDepByInputIndex {
    async fn run(
        self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        _: &mut Log,
    ) -> Result<()> {
        let input = skeleton.get_input_by_index(self.input_index)?;
        let cell_outpoint = input.input.previous_output();
        skeleton.headerdep(HeaderDepEx::new_from_outpoint(rpc, cell_outpoint).await?);
        Ok(())
    }
}

/// Operation that add input cell to transaction skeleton by lock script
///
/// # Parameters
/// - `count`: u32, the count of input cells to add that searching coming out of ckb-indexer
pub struct AddInputCell {
    pub lock_script: ScriptEx,
    pub type_script: Option<ScriptEx>,
    pub count: u32,
    pub search_mode: SearchMode,
}

impl AddInputCell {
    fn search_key(&self, skeleton: &TransactionSkeleton) -> Result<SearchKey> {
        let mut query = CellQueryOptions::new_lock(self.lock_script.clone().to_script(skeleton)?);
        if let Some(type_script) = &self.type_script {
            query.secondary_script = Some(type_script.clone().to_script(skeleton)?);
        } else {
            query.secondary_script_len_range = Some(ValueRangeOption::new(0, 1));
            query.data_len_range = Some(ValueRangeOption::new(0, 1));
        }
        query.with_data = Some(true);
        query.script_search_mode = Some(self.search_mode.clone());
        Ok(query.into())
    }
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddInputCell {
    async fn run(
        self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        _: &mut Log,
    ) -> Result<()> {
        let mut iter = GetCellsIter::new(rpc, self.search_key(skeleton)?);
        let mut find_avaliable = false;
        while let Some(cells) = iter.next_batch(self.count).await? {
            cells.into_iter().try_for_each(|cell| {
                let cell_input = CellInputEx::new_from_indexer_cell(cell, None);
                find_avaliable = true;
                skeleton.input(cell_input)?.witness(Default::default());
                Result::<()>::Ok(())
            })?;
        }
        if !find_avaliable {
            return Err(eyre!("input cell not found"));
        }
        Ok(())
    }
}

/// Operation that add input cell to transaction skeleton by out point directly
pub struct AddInputCellByOutPoint {
    pub tx_hash: H256,
    pub index: u32,
    pub since: Option<u64>,
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddInputCellByOutPoint {
    async fn run(
        self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        _: &mut Log,
    ) -> Result<()> {
        let cell_input =
            CellInputEx::new_from_outpoint(rpc, self.tx_hash, self.index, self.since, true).await?;
        skeleton.input(cell_input)?.witness(Default::default());
        Ok(())
    }
}

/// Operation that add input cell to transaction skeleton by user address
pub struct AddInputCellByAddress {
    pub address: Address,
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddInputCellByAddress {
    async fn run(
        self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        _: &mut Log,
    ) -> Result<()> {
        skeleton
            .input_from_address(rpc, self.address.clone())
            .await?
            .witness(Default::default());
        Ok(())
    }
}

/// Operation that add input cell to transaction skeleton by type script
pub struct AddInputCellByType {
    pub type_script: ScriptEx,
    pub count: u32,
    pub search_mode: SearchMode,
}

impl AddInputCellByType {
    fn search_key(&self, skeleton: &TransactionSkeleton) -> Result<SearchKey> {
        let mut query = CellQueryOptions::new_type(self.type_script.clone().to_script(skeleton)?);
        query.script_search_mode = Some(self.search_mode.clone());
        query.with_data = Some(true);
        Ok(query.into())
    }
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddInputCellByType {
    async fn run(
        self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        _: &mut Log,
    ) -> Result<()> {
        let mut iter = GetCellsIter::new(rpc, self.search_key(skeleton)?);
        let mut find_avaliable = false;
        while let Some(cells) = iter.next_batch(self.count).await? {
            cells.into_iter().try_for_each(|cell| {
                let cell_input = CellInputEx::new_from_indexer_cell(cell, None);
                find_avaliable = true;
                skeleton.input(cell_input)?.witness(Default::default());
                Result::<()>::Ok(())
            })?;
        }
        if !find_avaliable {
            return Err(eyre!("input cell not found"));
        }
        Ok(())
    }
}

/// Operation that add output cell to transaction skeleton
///
/// # Parameters
/// - `absolute_capacity` bool, wether mark the `capacity` as absolute value or additional
/// - `type_id`: bool, if true, calculate type id and override into type script if provided
#[derive(Default)]
pub struct AddOutputCell {
    pub lock_script: ScriptEx,
    pub type_script: Option<ScriptEx>,
    pub capacity: u64,
    pub data: Vec<u8>,
    pub absolute_capacity: bool,
    pub type_id: bool,
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddOutputCell {
    async fn run(
        self: Box<Self>,
        _: &T,
        skeleton: &mut TransactionSkeleton,
        _: &mut Log,
    ) -> Result<()> {
        let type_script = if self.type_id {
            let type_id = skeleton.calc_type_id(skeleton.outputs.len())?;
            let type_script = self
                .type_script
                .map(|v| v.set_args(type_id.as_bytes().to_vec()))
                .unwrap_or(ScriptEx::new_type(
                    TYPE_ID_CODE_HASH.clone(),
                    type_id.as_bytes().to_vec(),
                ));
            Some(type_script.to_script(skeleton)?)
        } else {
            self.type_script
                .map(|v| v.to_script(skeleton))
                .transpose()?
        };
        let mut output = CellOutput::new_builder()
            .lock(self.lock_script.to_script(skeleton)?)
            .type_(type_script.pack())
            .build();
        output = output
            .as_builder()
            .build_exact_capacity(Capacity::bytes(self.data.len())?)?;
        let minimal_capacity: u64 = output.capacity().unpack();
        if !self.absolute_capacity {
            let capacity = minimal_capacity + self.capacity;
            output = output.as_builder().capacity(capacity.pack()).build();
        } else if self.capacity > minimal_capacity {
            output = output.as_builder().capacity(self.capacity.pack()).build();
        } else {
            return Err(eyre!("capacity not enough"));
        }
        let cell_output = CellOutputEx::new(output, self.data);
        skeleton.output(cell_output);
        Ok(())
    }
}

/// Operation that add output cell to transaction skeleton by address
pub struct AddOutputCellByAddress {
    pub address: Address,
    pub data: Vec<u8>,
    pub add_type_id: bool,
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddOutputCellByAddress {
    async fn run(
        self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        log: &mut Log,
    ) -> Result<()> {
        Box::new(AddOutputCell {
            lock_script: self.address.payload().into(),
            type_script: None,
            capacity: 0,
            data: self.data,
            absolute_capacity: false,
            type_id: self.add_type_id,
        })
        .run(rpc, skeleton, log)
        .await
    }
}

/// Operation that add output cell to transaction skeleton by copying input cell from target position
///
/// # Parameters
/// - `input_index`: usize, the index of input cell in inputs, if it is usize::MAX, copy the last one
/// - `adjust_capacity`: bool, if true, adjust the capacity if `data` provided
#[derive(Default)]
pub struct AddOutputCellByInputIndex {
    pub input_index: usize,
    pub data: Option<Vec<u8>>,
    pub lock_script: Option<ScriptEx>,
    pub type_script: Option<Option<ScriptEx>>,
    pub adjust_capacity: bool,
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddOutputCellByInputIndex {
    async fn run(
        self: Box<Self>,
        _: &T,
        skeleton: &mut TransactionSkeleton,
        _: &mut Log,
    ) -> Result<()> {
        let cell_input = skeleton.get_input_by_index(self.input_index)?;
        let mut cell_output = cell_input.output.clone();
        let mut output_builder = cell_output.output.as_builder();
        if let Some(data) = self.data {
            cell_output.data = data;
        }
        if let Some(lock_script) = self.lock_script {
            output_builder = output_builder.lock(lock_script.to_script(skeleton)?);
        }
        if let Some(type_script) = self.type_script {
            if let Some(type_script) = type_script {
                output_builder =
                    output_builder.type_(Some(type_script.to_script(skeleton)?).pack());
            } else {
                output_builder = output_builder.type_(None.pack());
            }
        }
        cell_output.output = if self.adjust_capacity {
            output_builder.build_exact_capacity(Capacity::bytes(cell_output.data.len())?)?
        } else {
            output_builder.build()
        };
        skeleton.output(cell_output);
        Ok(())
    }
}

/// Operation that add wintess in form of WitnessArgs to transaction skeleton
///
/// `witness_index`: Option<usize>, the index of witness to update, if None, add a new witness
pub struct AddWitnessArgs {
    pub witness_index: Option<usize>,
    pub lock: Vec<u8>,
    pub input_type: Vec<u8>,
    pub output_type: Vec<u8>,
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddWitnessArgs {
    async fn run(
        self: Box<Self>,
        _: &T,
        skeleton: &mut TransactionSkeleton,
        _: &mut Log,
    ) -> Result<()> {
        if let Some(witness_index) = self.witness_index {
            if witness_index >= skeleton.witnesses.len() {
                return Err(eyre!("witness index out of range"));
            }
            let witness = &mut skeleton.witnesses[witness_index];
            witness.lock = self.lock;
            witness.input_type = self.input_type;
            witness.output_type = self.output_type;
        } else {
            let witness = WitnessEx::new(self.lock, self.input_type, self.output_type);
            skeleton.witness(witness);
        }
        Ok(())
    }
}

#[cfg(not(target_arch = "wasm32"))]
/// Operation that sign and add secp256k1_sighash_all signatures to transaction skeleton
pub struct AddSecp256k1SighashSignatures {
    pub user_lock_scripts: Vec<ScriptEx>,
    pub user_private_keys: Vec<SecretKey>,
}

#[cfg(not(target_arch = "wasm32"))]
#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddSecp256k1SighashSignatures {
    async fn run(
        self: Box<Self>,
        _: &T,
        skeleton: &mut TransactionSkeleton,
        _: &mut Log,
    ) -> Result<()> {
        let tx = skeleton.clone().into_transaction_view();
        let mut tx_groups_builder = TransactionWithScriptGroupsBuilder::default().set_tx_view(tx);
        for lock_script in self.user_lock_scripts {
            let (input_indices, _) = skeleton.lock_script_groups(&lock_script);
            tx_groups_builder = tx_groups_builder
                .add_lock_script_group(&lock_script.to_script(skeleton)?, &input_indices);
        }
        let mut tx_groups = tx_groups_builder.build();
        let signer = TransactionSigner::new(&NetworkInfo::mainnet()); // network info is not used here
        signer
            .sign_transaction(
                &mut tx_groups,
                &SignContexts::new_sighash(self.user_private_keys),
            )
            .expect("sign");
        let tx = tx_groups.get_tx_view();
        skeleton.update_witnesses_from_transaction_view(tx)?;
        Ok(())
    }
}

/// Copy from https://github.com/nervosnetwork/ckb-cli/blob/develop/src/subcommands/tx.rs#L783
#[derive(serde::Serialize, serde::Deserialize)]
pub struct ReprMultisigConfig {
    pub sighash_addresses: Vec<String>,
    pub require_first_n: u8,
    pub threshold: u8,
}

/// Copy from https://github.com/nervosnetwork/ckb-cli/blob/develop/src/subcommands/tx.rs#L710
#[derive(serde::Serialize, serde::Deserialize, Default)]
pub struct ReprTxHelper {
    pub transaction: Transaction,
    pub multisig_configs: HashMap<H160, ReprMultisigConfig>,
    pub signatures: HashMap<JsonBytes, Vec<JsonBytes>>,
}

/// Operation that sign and add secp256k1_sighash_all signatures to transaction skeleton with ckb-cli
///
/// note: this operation requires `ckb-cli` installed and available in PATH, refer to https://github.com/nervosnetwork/ckb-cli
pub struct AddSecp256k1SighashSignaturesWithCkbCli {
    pub signer_address: Address,
    pub cache_path: PathBuf,
    pub keep_cache_file: bool,
}

#[cfg(not(target_arch = "wasm32"))]
fn get_cli_password() -> Result<String> {
    Ok(rpassword::prompt_password(
        "Enter password to unlock ckb-cli: ",
    )?)
}

#[cfg(target_arch = "wasm32")]
fn get_cli_password() -> Result<String> {
    Err(eyre!("ckb-cli is not supported in wasm environment"))
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddSecp256k1SighashSignaturesWithCkbCli {
    async fn run(
        self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        _: &mut Log,
    ) -> Result<()> {
        // complete witness if not enough
        let (signer_groups, _) = skeleton.lock_script_groups(&self.signer_address.payload().into());
        let witness_index = signer_groups
            .first()
            .cloned()
            .ok_or(eyre!("no signer address found"))?;
        if skeleton.witnesses.len() <= witness_index {
            return Err(eyre!("witnesses count not match all of inputs"));
        }
        // generate persisted tx file in cahce directory for ckb-cli
        let tx = skeleton.clone().into_transaction_view();
        let tx_hash = hex::encode(tx.hash().raw_data());
        let cache_dir = PathBuf::new().join(self.cache_path);
        if !cache_dir.exists() {
            fs::create_dir_all(&cache_dir)?;
        }
        let ckb_cli_tx = ReprTxHelper {
            transaction: tx.data().into(),
            ..Default::default()
        };
        let tx_content = serde_json::to_string_pretty(&ckb_cli_tx)?;
        let tx_file = cache_dir.join(format!("tx-{tx_hash}-{witness_index}.json"));
        fs::write(&tx_file, tx_content)?;
        // read password for unlocking ckb-cli
        let password = get_cli_password()?;
        // run ckb-cli to sign the tx
        let (url, _) = rpc.url();
        let mut ckb_cli = Command::new("ckb-cli")
            .stdin(Stdio::piped())
            .stderr(Stdio::piped())
            .stdout(Stdio::piped())
            .args(["--url", &url])
            .args(["tx", "sign-inputs"])
            .args(["--tx-file", tx_file.to_str().unwrap()])
            .args(["--from-account", &self.signer_address.to_string()])
            .args(["--output-format", "json"])
            .arg("--add-signatures")
            .spawn()?;
        ckb_cli
            .stdin
            .as_mut()
            .ok_or(eyre!("stdin not available"))?
            .write_all(password.as_bytes())?;
        let output = ckb_cli.wait_with_output()?;
        if !output.status.success() {
            let error = String::from_utf8(output.stderr)?;
            return Err(eyre!("ckb-cli error: {error}"));
        }
        if !self.keep_cache_file {
            fs::remove_file(&tx_file)?;
        }
        // fill in signature
        let ckb_cli_result = String::from_utf8(output.stdout)?;
        let signature_json: Vec<Value> =
            serde_json::from_str(ckb_cli_result.trim_start_matches("Password:").trim())?;
        let signature = signature_json
            .first()
            .ok_or(eyre!("signature not generated"))?
            .get("signature")
            .ok_or(eyre!("signature not found"))?
            .as_str()
            .ok_or(eyre!("signature not string format"))?;
        let signature_bytes = hex::decode(signature.trim_start_matches("0x"))?;
        skeleton.witnesses[witness_index].lock = signature_bytes;
        Ok(())
    }
}

/// Operation that balance transaction skeleton
pub struct BalanceTransaction {
    pub balancer: ScriptEx,
    pub change_receiver: ChangeReceiver,
    pub additional_fee_rate: u64,
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for BalanceTransaction {
    async fn run(
        self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        _: &mut Log,
    ) -> Result<()> {
        let fee = skeleton.fee(rpc, self.additional_fee_rate).await?;
        skeleton
            .balance(rpc, fee, self.balancer, self.change_receiver)
            .await?;
        (skeleton.witnesses.len()..skeleton.inputs.len()).for_each(|_| {
            skeleton.witness(Default::default());
        });
        Ok(())
    }
}


================================================
File: calculate/src/operation/component.rs
================================================
use async_trait::async_trait;
use ckb_types::{
    core::{DepType, ScriptHashType},
    h256,
    packed::Script,
    prelude::{Builder, Entity, Pack},
    H256,
};
use eyre::{eyre, Result};

use crate::{
    indexer::{CellQueryOptions, SearchKey, SearchMode},
    operation::{basic::AddOutputCell, Log, Operation},
    rpc::{GetCellsIter, Network, RPC},
    skeleton::{CellInputEx, ScriptEx, TransactionSkeleton},
};

use super::basic::AddCellDep;

/// Component-use simple scripts
///
/// note: migrations please refer to https://github.com/ckb-ecofund/ckb-proxy-locks/tree/main/migrations
pub mod hardcoded {
    use crate::simulation::random_hash;

    use super::*;

    pub const COMPONENT_MAINNET_TX_HASH: H256 =
        h256!("0x10d63a996157d32c01078058000052674ca58d15f921bec7f1dcdac2160eb66b");
    pub const COMPONENT_TESTNET_TX_HASH: H256 =
        h256!("0xb4f171c9c9caf7401f54a8e56225ae21d95032150a87a4678eac3f66a3137b93");

    lazy_static::lazy_static! {
        pub static ref COMPONENT_FAKENET_TX_HASH: H256 = random_hash().into();
    }

    pub const ALWAYS_SUCCESS_CODE_HASH: H256 =
        h256!("0x3b521cc4b552f109d092d8cc468a8048acb53c5952dbe769d2b2f9cf6e47f7f1");
    pub const INPUT_TYPE_PROXY_CODE_HASH: H256 =
        h256!("0x5123908965c711b0ffd8aec642f1ede329649bda1ebdca6bd24124d3796f768a");
    pub const OUTPUT_TYPE_PROXY_CODE_HASH: H256 =
        h256!("0x2df53b592db3ae3685b7787adcfef0332a611edb83ca3feca435809964c3aff2");
    pub const LOCK_PROXY_CODE_HASH: H256 =
        h256!("0x2df53b592db3ae3685b7787adcfef0332a611edb83ca3feca435809964c3aff2");
    pub const SINGLE_USE_CODE_HASH: H256 =
        h256!("0x8290467a512e5b9a6b816469b0edabba1f4ac474e28ffdd604c2a7c76446bbaf");
    pub const TYPE_BURN_CODE_HASH: H256 =
        h256!("0xff78bae0abf17d7a404c0be0f9ad9c9185b3f88dcc60403453d5ba8e1f22f53a");

    #[repr(u32)]
    pub enum Name {
        AlwaysSuccess = 0,
        InputTypeProxy,
        OutputTypeProxy,
        LockProxy,
        SingleUse,
        TypeBurn,
    }

    impl std::fmt::Display for Name {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                Name::AlwaysSuccess => write!(f, "always_success"),
                Name::InputTypeProxy => write!(f, "input_type_proxy"),
                Name::OutputTypeProxy => write!(f, "output_type_proxy"),
                Name::LockProxy => write!(f, "lock_proxy"),
                Name::SingleUse => write!(f, "single_use"),
                Name::TypeBurn => write!(f, "type_burn"),
            }
        }
    }

    pub fn build_script(network: Network, name: Name, args: &[u8]) -> ScriptEx {
        match network {
            Network::Mainnet | Network::Testnet => Script::new_builder()
                .code_hash(
                    match name {
                        Name::AlwaysSuccess => ALWAYS_SUCCESS_CODE_HASH,
                        Name::InputTypeProxy => INPUT_TYPE_PROXY_CODE_HASH,
                        Name::LockProxy => LOCK_PROXY_CODE_HASH,
                        Name::OutputTypeProxy => OUTPUT_TYPE_PROXY_CODE_HASH,
                        Name::SingleUse => SINGLE_USE_CODE_HASH,
                        Name::TypeBurn => TYPE_BURN_CODE_HASH,
                    }
                    .pack(),
                )
                .hash_type(ScriptHashType::Data1.into())
                .args(args.pack())
                .build()
                .into(),
            _ => (name.to_string(), args.to_owned()).into(),
        }
    }

    pub fn component_tx_hash(network: Network) -> H256 {
        match network {
            Network::Mainnet => COMPONENT_MAINNET_TX_HASH,
            Network::Testnet => COMPONENT_TESTNET_TX_HASH,
            _ => COMPONENT_FAKENET_TX_HASH.clone(),
        }
    }
}

/// Add `ckb-proxy-locks` celldep
///
/// # Parameters
/// - `name`: component name in `ckb-proxy-locks`
pub struct AddComponentCelldep {
    pub name: hardcoded::Name,
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddComponentCelldep {
    async fn run(
        self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        log: &mut Log,
    ) -> Result<()> {
        Box::new(AddCellDep {
            name: self.name.to_string(),
            tx_hash: hardcoded::component_tx_hash(rpc.network()),
            index: self.name as u32,
            dep_type: DepType::Code,
            with_data: false,
        })
        .run(rpc, skeleton, log)
        .await
    }
}

/// Add `type-burn-lock` output cell with or without type script
///
/// # Parameters
/// - `output_index`: reference output index, which is choosed to calculate type hash
/// - `type_script`: optional type script
/// - `data`: cell data
pub struct AddTypeBurnOutputCell {
    pub output_index: usize,
    pub type_script: Option<ScriptEx>,
    pub data: Vec<u8>,
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddTypeBurnOutputCell {
    async fn run(
        self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        log: &mut Log,
    ) -> Result<()> {
        let reference_output = skeleton.get_output_by_index(self.output_index)?;
        let reference_type_hash = reference_output
            .calc_type_hash()
            .ok_or(eyre!("reference output has no type script"))?;
        let type_burn_lock_script = hardcoded::build_script(
            rpc.network(),
            hardcoded::Name::TypeBurn,
            reference_type_hash.as_bytes(),
        );
        Box::new(AddOutputCell {
            lock_script: type_burn_lock_script,
            type_script: self.type_script,
            capacity: 0,
            data: self.data,
            absolute_capacity: false,
            type_id: false,
        })
        .run(rpc, skeleton, log)
        .await
    }
}

/// Search and add `type-burn-lock` input cell
///
/// # Parameters
/// - `type_hash`: the reference type script hash
/// - `count`: max number of cells to add
pub struct AddTypeBurnInputCell {
    pub type_hash: H256,
    pub count: usize,
}

impl AddTypeBurnInputCell {
    pub fn search_key(
        &self,
        network: Network,
        skeleton: &TransactionSkeleton,
    ) -> Result<SearchKey> {
        let type_burn_lock_script = hardcoded::build_script(
            network,
            hardcoded::Name::TypeBurn,
            self.type_hash.as_bytes(),
        );
        let mut query = CellQueryOptions::new_lock(type_burn_lock_script.to_script(skeleton)?);
        query.with_data = Some(true);
        Ok(query.into())
    }
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddTypeBurnInputCell {
    async fn run(
        mut self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        _: &mut Log,
    ) -> Result<()> {
        let search_key = self.search_key(rpc.network(), skeleton)?;
        let mut iter = GetCellsIter::new(rpc, search_key.clone());
        while let Some(indexer_cell) = iter.next().await? {
            let input = CellInputEx::new_from_indexer_cell(indexer_cell, None);
            skeleton.input(input)?.witness(Default::default());
            self.count -= 1;
            if self.count == 0 {
                break;
            }
        }
        Ok(())
    }
}

/// Add `type-burn-lock` input cell by input index
pub struct AddTypeBurnInputCellByInputIndex {
    pub input_index: usize,
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddTypeBurnInputCellByInputIndex {
    async fn run(
        self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        log: &mut Log,
    ) -> Result<()> {
        let type_hash = skeleton
            .get_input_by_index(self.input_index)?
            .output
            .calc_type_hash()
            .ok_or(eyre!("input cell has no type script"))?;
        Box::new(AddTypeBurnInputCell {
            type_hash,
            count: 1,
        })
        .run(rpc, skeleton, log)
        .await
    }
}

/// Add `lock-proxy` output cell with or without type script
///
/// # Parameters
/// - `lock_hash`: the proxied lock hash
/// - `lock_script`: wether the script is used as lock script, otherwise type script
/// - `type_script`: optional type script
/// - `data`: cell data
pub struct AddLockProxyOutputCell {
    pub lock_hash: H256,
    pub lock_script: bool,
    pub second_script: Option<ScriptEx>,
    pub data: Vec<u8>,
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddLockProxyOutputCell {
    async fn run(
        mut self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        log: &mut Log,
    ) -> Result<()> {
        let lock_proxy_script = hardcoded::build_script(
            rpc.network(),
            hardcoded::Name::LockProxy,
            self.lock_hash.as_bytes(),
        );
        if self.lock_script {
            Box::new(AddOutputCell {
                lock_script: lock_proxy_script,
                type_script: self.second_script,
                capacity: 0,
                data: self.data,
                absolute_capacity: false,
                type_id: false,
            })
            .run(rpc, skeleton, log)
            .await
        } else {
            Box::new(AddOutputCell {
                lock_script: self.second_script.ok_or(eyre!("missing second script"))?,
                type_script: Some(lock_proxy_script),
                capacity: 0,
                data: self.data,
                absolute_capacity: false,
                type_id: false,
            })
            .run(rpc, skeleton, log)
            .await
        }
    }
}

/// Search and add `lock-proxy` input cell (fake supported)
///
/// # Parameters
/// - `lock_hash`: the proxied lock hash
/// - `lock_script`: wether the script is used as lock script, otherwise type script
/// - `count`: max number of cells to add
pub struct AddLockProxyInputCell {
    pub lock_hash: H256,
    pub lock_script: bool,
    pub count: usize,
}

impl AddLockProxyInputCell {
    pub fn search_key(
        &self,
        network: Network,
        skeleton: &TransactionSkeleton,
    ) -> Result<SearchKey> {
        let lock_proxy_script = hardcoded::build_script(
            network,
            hardcoded::Name::LockProxy,
            self.lock_hash.as_bytes(),
        );
        let mut query = if self.lock_script {
            CellQueryOptions::new_lock(lock_proxy_script.to_script(skeleton)?)
        } else {
            CellQueryOptions::new_type(lock_proxy_script.to_script(skeleton)?)
        };
        query.with_data = Some(true);
        query.script_search_mode = Some(SearchMode::Exact);
        Ok(query.into())
    }
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddLockProxyInputCell {
    async fn run(
        mut self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        log: &mut Log,
    ) -> Result<()> {
        Box::new(AddComponentCelldep {
            name: hardcoded::Name::LockProxy,
        })
        .run(rpc, skeleton, log)
        .await?;
        let search_key = self.search_key(rpc.network(), skeleton)?;
        let mut iter = GetCellsIter::new(rpc, search_key.clone());
        while let Some(indexer_cell) = iter.next().await? {
            let input = CellInputEx::new_from_indexer_cell(indexer_cell, None);
            skeleton.input(input)?.witness(Default::default());
            self.count -= 1;
            if self.count == 0 {
                break;
            }
        }
        Ok(())
    }
}


================================================
File: calculate/src/operation/dao.rs
================================================
use async_trait::async_trait;
use ckb_jsonrpc_types::JsonBytes;
use ckb_sdk::{
    util::{calculate_dao_maximum_withdraw4, minimal_unlock_point},
    Since, SinceType,
};
use ckb_types::{
    core::{Capacity, DepType},
    h256, H256,
};
use eyre::{eyre, Result};

use crate::{
    indexer::{CellQueryOptions, SearchKey, SearchKeyFilter, SearchMode},
    operation::{basic::AddCellDep, Log, Operation},
    rpc::{GetCellsIter, Network, RPC},
    skeleton::{CellInputEx, CellOutputEx, HeaderDepEx, ScriptEx, TransactionSkeleton, WitnessEx},
};

pub mod hardcoded {
    use super::*;
    use crate::simulation::random_hash;

    pub const DAO_NAME: &str = "dao";
    pub const DAO_MAINNET_TX_HASH: H256 =
        h256!("0xe2fb199810d49a4d8beec56718ba2593b665db9d52299a0f9e6e75416d73ff5c");
    pub const DAO_TESTNET_TX_HASH: H256 =
        h256!("0x8f8c79eb6671709633fe6a46de93c0fedc9c1b8a6527a18d3983879542635c9f");
    pub const DAO_TYPE_HASH: H256 =
        h256!("0x82d76d1b75fe2fd9a27dfbaa65a039221a380d76c926f378d3f81cf3e7e13f2e");

    lazy_static::lazy_static! {
        pub static ref DAO_FAKENET_TX_HASH: H256 = random_hash().into();
    }

    pub fn dao_tx_hash(network: Network) -> H256 {
        match network {
            Network::Mainnet => DAO_MAINNET_TX_HASH,
            Network::Testnet => DAO_TESTNET_TX_HASH,
            _ => DAO_FAKENET_TX_HASH.clone(),
        }
    }

    pub fn dao_script(network: Network) -> ScriptEx {
        match network {
            Network::Mainnet | Network::Testnet => {
                ScriptEx::new_type(hardcoded::DAO_TYPE_HASH, vec![])
            }
            _ => (DAO_NAME.to_string(), vec![]).into(),
        }
    }
}

pub mod hookkey {
    pub const DAO_WITHDRAW_PHASE_ONE: &str = "DAO_WITHDRAW_PHASE_ONE";
    pub const DAO_WITHDRAW_PHASE_TWO: &str = "DAO_WITHDRAW_PHASE_TWO";
}

/// Add DAO celldep to the transaction
pub struct AddDaoCelldep {}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddDaoCelldep {
    async fn run(
        self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        log: &mut Log,
    ) -> Result<()> {
        Box::new(AddCellDep {
            name: hardcoded::DAO_NAME.to_string(),
            tx_hash: hardcoded::dao_tx_hash(rpc.network()),
            index: 2,
            dep_type: DepType::Code,
            with_data: false,
        })
        .run(rpc, skeleton, log)
        .await
    }
}

/// Add DAO deposit output cell to the transaction
///
/// # Parameters
/// - `owner`: The owner of the DAO deposit cell
/// - `deposit_capacity`: The total capacity to deposit
pub struct AddDaoDepositOutputCell {
    pub owner: ScriptEx,
    pub deposit_capacity: u64,
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddDaoDepositOutputCell {
    async fn run(
        self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        log: &mut Log,
    ) -> Result<()> {
        let dao_type_script = hardcoded::dao_script(rpc.network());
        skeleton.output(CellOutputEx::new_from_scripts(
            self.owner.to_script(skeleton)?,
            Some(dao_type_script.to_script(skeleton)?),
            vec![0u8; 8],
            Some(Capacity::shannons(self.deposit_capacity)),
        )?);
        Box::new(AddDaoCelldep {}).run(rpc, skeleton, log).await
    }
}

/// Inject DAO phase one withdraw related cells, including previous deposit cells and withdraw cells of phase one
///
/// # Parameters
/// - `maximal_withdraw_capacity`: The maximal capacity to withdraw
/// - `upperbound_timesamp`: The timestamp to figure out the maturity of deposit cells
/// - `owner`: The owner of the DAO deposit cell
/// - `transfer_to`: The lock script of the withdraw cell, if not provided, use the same lock script in deposit cell
/// - `throw_if_no_avaliable`: If true, throw an error if no available DAO deposit cells
pub struct AddDaoWithdrawPhaseOneCells {
    pub maximal_withdraw_capacity: u64,
    pub upperbound_timesamp: u64,
    pub owner: ScriptEx,
    pub transfer_to: Option<ScriptEx>,
    pub throw_if_no_avaliable: bool,
}

impl AddDaoWithdrawPhaseOneCells {
    fn search_key(&self, network: Network, skeleton: &TransactionSkeleton) -> Result<SearchKey> {
        let dao_type_script = hardcoded::dao_script(network);
        let mut search_key: SearchKey =
            CellQueryOptions::new_lock(self.owner.clone().to_script(skeleton)?).into();
        search_key.with_data = Some(true);
        search_key.filter = Some(SearchKeyFilter {
            script: Some(dao_type_script.to_script(skeleton)?.into()),
            output_data: Some(JsonBytes::from_vec(vec![0u8; 8])),
            output_data_filter_mode: Some(SearchMode::Exact),
            ..Default::default()
        });
        Ok(search_key)
    }

    async fn check_deposit_timestamp<T: RPC>(
        &self,
        rpc: &T,
        deposit_block_number: u64,
    ) -> Result<bool> {
        let Some(deposit_header) = rpc
            .get_header_by_number(deposit_block_number.into())
            .await?
        else {
            return Ok(false);
        };
        let deposit_timestamp: u64 = deposit_header.inner.timestamp.into();
        Ok(deposit_timestamp <= self.upperbound_timesamp)
    }
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddDaoWithdrawPhaseOneCells {
    async fn run(
        self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        log: &mut Log,
    ) -> Result<()> {
        let mut searched_capacity = 0u64;
        let mut search = GetCellsIter::new(rpc, self.search_key(rpc.network(), skeleton)?);
        let transfer_lock_script = if let Some(transfer_to) = self.transfer_to.clone() {
            Some(transfer_to.to_script(skeleton)?)
        } else {
            None
        };
        while let Some(cell) = search.next().await? {
            let mature_deposit = self
                .check_deposit_timestamp(rpc, cell.block_number.into())
                .await?;
            if !mature_deposit {
                continue;
            }
            let deposit_cell = CellInputEx::new_from_indexer_cell(cell, None);
            let capacity = deposit_cell.output.capacity();
            searched_capacity += capacity.as_u64();
            if searched_capacity >= self.maximal_withdraw_capacity {
                break;
            }
            let deposit_header_dep =
                HeaderDepEx::new_from_outpoint(rpc, deposit_cell.input.previous_output()).await?;
            let block_number = deposit_header_dep.header.number();
            let withdraw_cell = CellOutputEx::new_from_scripts(
                transfer_lock_script
                    .clone()
                    .unwrap_or(deposit_cell.output.lock_script()),
                deposit_cell.output.type_script(),
                block_number.to_le_bytes().to_vec(),
                Some(capacity),
            )?;
            skeleton
                .input(deposit_cell)?
                .output(withdraw_cell)
                .headerdep(deposit_header_dep)
                .witness(Default::default());
        }
        log.push((
            hookkey::DAO_WITHDRAW_PHASE_ONE,
            searched_capacity.to_le_bytes().to_vec(),
        ));
        if searched_capacity == 0 {
            if self.throw_if_no_avaliable {
                return Err(eyre!("no available DAO deposit cells"));
            }
            Ok(())
        } else {
            Box::new(AddDaoCelldep {}).run(rpc, skeleton, log).await
        }
    }
}

/// Consume withdraw cells of phase one and generate a ordinary cell to receive the withdraw capacity
///
/// # Parameters
/// - `maximal_withdraw_capacity`: The maximal capacity to withdraw
/// - `owner`: The owner of the DAO deposit cell
/// - `transfer_to`: The lock script that receives all of capacities from searched withdraw cells, if None, use owner instead
pub struct AddDaoWithdrawPhaseTwoCells {
    pub maximal_withdraw_capacity: u64,
    pub owner: ScriptEx,
    pub transfer_to: Option<ScriptEx>,
    pub throw_if_no_avaliable: bool,
}

impl AddDaoWithdrawPhaseTwoCells {
    fn search_key(&self, network: Network, skeleton: &TransactionSkeleton) -> Result<SearchKey> {
        let dao_type_script = hardcoded::dao_script(network);
        let mut query = CellQueryOptions::new_lock(self.owner.clone().to_script(skeleton)?);
        query.with_data = Some(true);
        query.secondary_script = Some(dao_type_script.to_script(skeleton)?);
        Ok(query.into())
    }

    fn minimum_since(deposit_headerdep: &HeaderDepEx, withdraw_headerdep: &HeaderDepEx) -> u64 {
        let since_unlock =
            minimal_unlock_point(&deposit_headerdep.header, &withdraw_headerdep.header);
        let since = Since::new(
            SinceType::EpochNumberWithFraction,
            since_unlock.full_value(),
            false,
        );
        since.value()
    }

    fn maximum_withdraw_capacity(
        deposit_headerdep: &HeaderDepEx,
        withdraw_headerdep: &HeaderDepEx,
        withdraw_cell: &CellInputEx,
    ) -> u64 {
        calculate_dao_maximum_withdraw4(
            &deposit_headerdep.header,
            &withdraw_headerdep.header,
            &withdraw_cell.output.output,
            withdraw_cell.output.occupied_capacity().as_u64(),
        )
    }
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddDaoWithdrawPhaseTwoCells {
    async fn run(
        self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        log: &mut Log,
    ) -> Result<()> {
        let mut searched_capacity = 0u64;
        let mut search = GetCellsIter::new(rpc, self.search_key(rpc.network(), skeleton)?);
        let mut output_capacity = 0u64;
        let mut withdraw_headerdeps = vec![];
        while let Some(cell) = search.next().await? {
            let data = cell.output_data.as_ref().unwrap();
            let deposit_block_number = u64::from_le_bytes(data.as_bytes().try_into().unwrap());
            if deposit_block_number == 0 {
                continue;
            }
            let deposit_headerdep =
                HeaderDepEx::new_from_block_number(rpc, deposit_block_number).await?;
            let withdraw_headerdep =
                HeaderDepEx::new_from_outpoint(rpc, cell.out_point.clone().into()).await?;
            let since = Self::minimum_since(&deposit_headerdep, &withdraw_headerdep);
            let withdraw_cell = CellInputEx::new_from_indexer_cell(cell, Some(since));
            searched_capacity += withdraw_cell.output.capacity().as_u64();
            if searched_capacity >= self.maximal_withdraw_capacity {
                break;
            }
            let headerdep_idx = skeleton
                .headerdeps
                .iter()
                .position(|v| v == &deposit_headerdep)
                .unwrap_or(skeleton.headerdeps.len());
            let witness_args = WitnessEx::new(vec![], headerdep_idx.to_le_bytes().to_vec(), vec![]);
            output_capacity += Self::maximum_withdraw_capacity(
                &deposit_headerdep,
                &withdraw_headerdep,
                &withdraw_cell,
            );
            skeleton
                .input(withdraw_cell)?
                .witness(witness_args)
                .headerdep(deposit_headerdep);
            if !withdraw_headerdeps.contains(&withdraw_headerdep) {
                withdraw_headerdeps.push(withdraw_headerdep);
            }
        }
        log.push((
            hookkey::DAO_WITHDRAW_PHASE_TWO,
            output_capacity.to_le_bytes().to_vec(),
        ));
        if output_capacity == 0 {
            if self.throw_if_no_avaliable {
                return Err(eyre!("no available DAO withdraw cells"));
            }
            return Ok(());
        }
        skeleton.headerdeps.extend(withdraw_headerdeps.into_iter());
        let transfer_lock_script = if let Some(transfer_to) = self.transfer_to {
            transfer_to.to_script(skeleton)?
        } else {
            self.owner.to_script(skeleton)?
        };
        let withdraw_output = CellOutputEx::new_from_scripts(
            transfer_lock_script,
            None,
            vec![],
            Some(Capacity::shannons(output_capacity)),
        )?;
        if withdraw_output.capacity() < withdraw_output.occupied_capacity() {
            return Err(eyre!("withdraw capacity cannot cover minimal requirement"));
        }
        skeleton.output(withdraw_output);
        Box::new(AddDaoCelldep {}).run(rpc, skeleton, log).await
    }
}


================================================
File: calculate/src/operation/mod.rs
================================================
pub mod basic;
pub mod component;
pub mod spore;
pub use common::{Log, Operation};

#[cfg(not(target_arch = "wasm32"))]
pub mod dao;

mod common {
    use crate::{rpc::RPC, skeleton::TransactionSkeleton};

    pub type Log = Vec<(&'static str, Vec<u8>)>;

    #[async_trait::async_trait(?Send)]
    pub trait Operation<T: RPC> {
        async fn run(
            self: Box<Self>,
            rpc: &T,
            skeleton: &mut TransactionSkeleton,
            log: &mut Log,
        ) -> eyre::Result<()>;
    }
}


================================================
File: calculate/src/operation/spore/mod.rs
================================================
use async_trait::async_trait;
use ckb_types::{
    core::DepType,
    h256,
    prelude::{Builder, Entity, Pack, Unpack},
    H256,
};
use eyre::{eyre, Result};

use crate::{
    indexer::{CellQueryOptions, SearchKey, SearchMode},
    operation::{basic::AddOutputCell, Log, Operation},
    rpc::{GetCellsIter, Network, RPC},
    skeleton::{CellDepEx, CellInputEx, CellOutputEx, ScriptEx, TransactionSkeleton, WitnessEx},
};

pub mod generated;
use generated::*;

use super::basic::AddCellDep;

/// The latest Spore and Cluster contract version
///
/// note: detail refers to https://github.com/sporeprotocol/spore-contract/blob/master/docs/VERSIONS.md
pub mod hardcoded {
    use crate::simulation::random_hash;

    use super::*;

    pub const SPORE_MAINNET_TX_HASH: H256 =
        h256!("0x96b198fb5ddbd1eed57ed667068f1f1e55d07907b4c0dbd38675a69ea1b69824");
    pub const SPORE_MAINNET_CODE_HASH: H256 =
        h256!("0x4a4dce1df3dffff7f8b2cd7dff7303df3b6150c9788cb75dcf6747247132b9f5");

    pub const SPORE_TESTNET_TX_HASH: H256 =
        h256!("0x5e8d2a517d50fd4bb4d01737a7952a1f1d35c8afc77240695bb569cd7d9d5a1f");
    pub const SPORE_TESTNET_CODE_HASH: H256 =
        h256!("0x685a60219309029d01310311dba953d67029170ca4848a4ff638e57002130a0d");

    pub const CLUSTER_MAINNET_TX_HASH: H256 =
        h256!("0xe464b7fb9311c5e2820e61c99afc615d6b98bdefbe318c34868c010cbd0dc938");
    pub const CLUSTER_MAINNET_CODE_HASH: H256 =
        h256!("0x7366a61534fa7c7e6225ecc0d828ea3b5366adec2b58206f2ee84995fe030075");

    pub const CLUSTER_TESTNET_TX_HASH: H256 =
        h256!("0xcebb174d6e300e26074aea2f5dbd7f694bb4fe3de52b6dfe205e54f90164510a");
    pub const CLUSTER_TESTNET_CODE_HASH: H256 =
        h256!("0x0bbe768b519d8ea7b96d58f1182eb7e6ef96c541fbd9526975077ee09f049058");

    lazy_static::lazy_static! {
        pub static ref SPORE_FAKENET_TX_HASH: H256 = random_hash().into();
        pub static ref CLUSTER_FAKENET_TX_HASH: H256 = random_hash().into();
    }

    pub fn spore_tx_hash(network: Network) -> H256 {
        match network {
            Network::Mainnet => SPORE_MAINNET_TX_HASH,
            Network::Testnet => SPORE_TESTNET_TX_HASH,
            _ => SPORE_FAKENET_TX_HASH.clone(),
        }
    }

    pub fn spore_script(network: Network, args: Vec<u8>) -> ScriptEx {
        match network {
            Network::Mainnet => ScriptEx::new_code(SPORE_MAINNET_CODE_HASH, args),
            Network::Testnet => ScriptEx::new_code(SPORE_TESTNET_CODE_HASH, args),
            _ => ("spore".to_string(), args).into(),
        }
    }

    pub fn cluster_tx_hash(network: Network) -> H256 {
        match network {
            Network::Mainnet => CLUSTER_MAINNET_TX_HASH,
            Network::Testnet => CLUSTER_TESTNET_TX_HASH,
            _ => CLUSTER_FAKENET_TX_HASH.clone(),
        }
    }

    pub fn cluster_script(network: Network, args: Vec<u8>) -> ScriptEx {
        match network {
            Network::Mainnet => ScriptEx::new_code(CLUSTER_MAINNET_CODE_HASH, args),
            Network::Testnet => ScriptEx::new_code(CLUSTER_TESTNET_CODE_HASH, args),
            _ => ("cluster".to_string(), args).into(),
        }
    }
}

pub mod hookkey {
    /// The owner lock script of cluster cell that put in transaction's Inputs and Outputs field, which means it
    /// should have matched signature in Witnesses
    pub const CLUSTER_CELL_OWNER_LOCK: &str = "CLUSTER_CELL_OWNER_LOCK";
    /// The new generated cluster unique id when creating new cluster cell in Outputs field
    pub const NEW_CLUSTER_ID: &str = "NEW_CLUSTER_ID";
    /// The new generated spore unique id when creating new spore cell in Outputs field
    pub const NEW_SPORE_ID: &str = "NEW_SPORE_ID";
}

/// Add the lastest Spore deployment cell into transaction skeleton according to the network type.
pub struct AddSporeCelldep {}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddSporeCelldep {
    async fn run(
        self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        log: &mut Log,
    ) -> Result<()> {
        Box::new(AddCellDep {
            name: "spore".to_string(),
            tx_hash: hardcoded::spore_tx_hash(rpc.network()),
            index: 0,
            dep_type: DepType::Code,
            with_data: false,
        })
        .run(rpc, skeleton, log)
        .await
    }
}

/// Add the lastest Cluster deployment cell into transaction skeleton according to the network type.
pub struct AddClusterCelldep {}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddClusterCelldep {
    async fn run(
        self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        log: &mut Log,
    ) -> Result<()> {
        Box::new(AddCellDep {
            name: "cluster".to_string(),
            tx_hash: hardcoded::cluster_tx_hash(rpc.network()),
            index: 0,
            dep_type: DepType::Code,
            with_data: false,
        })
        .run(rpc, skeleton, log)
        .await
    }
}

#[derive(Clone)]
pub enum ClusterAuthorityMode {
    LockProxy,
    ClusterCell,
    Skip,
}

/// Search and add cluster cell under the latest contract version with unique cluster_id
///
/// # Parameters
/// - `cluster_id`: The unique identifier of the cluster cell
/// - `authority_mode`: Indicate how to provide cluster authority while operating Spore
pub struct AddClusterCelldepByClusterId {
    pub cluster_id: H256,
    pub authority_mode: ClusterAuthorityMode,
}

impl AddClusterCelldepByClusterId {
    fn search_key<T: RPC>(&self, rpc: &T, skeleton: &TransactionSkeleton) -> Result<SearchKey> {
        let args = self.cluster_id.as_bytes().to_vec();
        let cluster_type_script = hardcoded::cluster_script(rpc.network(), args);
        let mut query = CellQueryOptions::new_type(cluster_type_script.to_script(skeleton)?);
        query.script_search_mode = Some(SearchMode::Exact);
        Ok(query.into())
    }
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddClusterCelldepByClusterId {
    async fn run(
        self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        log: &mut Log,
    ) -> Result<()> {
        let name = format!("cluster-{:#x}", self.cluster_id);
        let cluster_celldep = if let Some(celldep) = skeleton.get_celldep_by_name(&name) {
            celldep
        } else {
            let search_key = self.search_key(rpc, skeleton)?;
            let Some(indexer_cell) = GetCellsIter::new(rpc, search_key).next().await? else {
                return Err(eyre!("no cluster cell (id: {:#x})", self.cluster_id));
            };
            let celldep =
                CellDepEx::new_from_indexer_cell(name, indexer_cell.clone(), DepType::Code);
            skeleton.celldep(celldep);
            skeleton.celldeps.last().unwrap()
        };
        let cluster_owner_lock_script: ScriptEx = cluster_celldep.output.lock_script().into();
        let (inputs, outputs) = skeleton.lock_script_groups(&cluster_owner_lock_script);
        // ignore the case of only one legit cell in Inputs or Outputs
        if inputs.is_empty() || outputs.is_empty() {
            log.push((
                hookkey::CLUSTER_CELL_OWNER_LOCK,
                cluster_owner_lock_script
                    .clone()
                    .to_script_unchecked()
                    .as_slice()
                    .to_vec(),
            ));
            match self.authority_mode {
                ClusterAuthorityMode::LockProxy => {
                    skeleton
                        .input_from_script(rpc, cluster_owner_lock_script.clone())
                        .await?
                        .output_from_script(cluster_owner_lock_script, vec![])?
                        .witness(Default::default());
                }
                ClusterAuthorityMode::ClusterCell => {
                    let cluster_input_cell = CellInputEx::new_from_celldep(cluster_celldep, None);
                    let cluster_output_cell = cluster_input_cell.output.clone();
                    skeleton
                        .input(cluster_input_cell)?
                        .output(cluster_output_cell)
                        .witness(Default::default());
                    Box::new(AddClusterCelldep {})
                        .run(rpc, skeleton, log)
                        .await?;
                }
                ClusterAuthorityMode::Skip => {} // do nothing
            }
        }
        Ok(())
    }
}

/// Search and add spore cell under the latest contract version with unique cluster_id
///
/// # Parameters
/// - `lock_script`: The spore owner lock script
/// - `cluster_id`: The unique identifier of the cluster cell
/// - `count`: The number of spore cells to search and add
pub struct AddSporeInputCellByClusterId {
    pub lock_script: ScriptEx,
    pub cluster_id: H256,
    pub count: usize,
}

impl AddSporeInputCellByClusterId {
    fn search_key<T: RPC>(&self, rpc: &T, skeleton: &TransactionSkeleton) -> Result<SearchKey> {
        let partial_spore_type_script = hardcoded::spore_script(rpc.network(), vec![]);
        let mut query = CellQueryOptions::new_lock(self.lock_script.clone().to_script(skeleton)?);
        query.secondary_script = Some(partial_spore_type_script.to_script(skeleton)?);
        query.with_data = Some(true);
        query.script_search_mode = Some(SearchMode::Prefix);
        Ok(query.into())
    }
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddSporeInputCellByClusterId {
    async fn run(
        self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        log: &mut Log,
    ) -> Result<()> {
        let search_key = self.search_key(rpc, skeleton)?;
        let mut searched = 0usize;
        let mut iter = GetCellsIter::new(rpc, search_key);
        while let Some(indexer_cell) = iter.next().await? {
            let spore_cell = CellInputEx::new_from_indexer_cell(indexer_cell, None);
            let cluster_id = SporeData::from_compatible_slice(&spore_cell.output.data)?
                .cluster_id()
                .to_opt()
                .map(|v| v.raw_data().to_vec());
            if cluster_id != Some(self.cluster_id.as_bytes().to_vec()) {
                continue;
            }
            skeleton.input(spore_cell)?.witness(Default::default());
            searched += 1;
            if searched >= self.count {
                break;
            }
        }
        Box::new(AddSporeCelldep {}).run(rpc, skeleton, log).await
    }
}

/// Search and add spore cell under the latest contract version with unique spore_id
///
/// # Parameters
/// - `spore_id`: The unique identifier of the spore cell
/// - `check_owner`: The owner lock script to check if the spore cell is owned by the passed owner
pub struct AddSporeInputCellBySporeId {
    pub spore_id: H256,
    pub check_owner: Option<ScriptEx>,
}

impl AddSporeInputCellBySporeId {
    fn search_key<T: RPC>(&self, rpc: &T, skeleton: &TransactionSkeleton) -> Result<SearchKey> {
        let args = self.spore_id.as_bytes().to_vec();
        let spore_type_script = hardcoded::spore_script(rpc.network(), args);
        let mut query = CellQueryOptions::new_type(spore_type_script.to_script(skeleton)?);
        query.with_data = Some(true);
        query.script_search_mode = Some(SearchMode::Exact);
        Ok(query.into())
    }
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddSporeInputCellBySporeId {
    async fn run(
        self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        log: &mut Log,
    ) -> Result<()> {
        let search_key = self.search_key(rpc, skeleton)?;
        let Some(indexer_cell) = GetCellsIter::new(rpc, search_key).next().await? else {
            return Err(eyre!("no spore cell (id: {:#x})", self.spore_id));
        };
        let spore_cell = CellInputEx::new_from_indexer_cell(indexer_cell, None);
        if let Some(owner) = self.check_owner {
            if spore_cell.output.lock_script() != owner.to_script(skeleton)? {
                return Err(eyre!(
                    "spore cell (id: {:#x}) owner mismatch",
                    self.spore_id
                ));
            }
        }
        skeleton.input(spore_cell)?.witness(Default::default());
        Box::new(AddSporeCelldep {}).run(rpc, skeleton, log).await
    }
}

/// Add a new Spore cell under specific cluster id or not
///
/// # Parameters
/// - `lock_script`: The owner lock script
/// - `content_type`: The type of content under spore procotol, e.q. "plain/text", "text/json"
/// - `content`: The concrete content in bytes
/// - `cluster_id`: The unique identifier of the cluster cell to create from
/// - `authority_mode`: The cluster authority mode
pub struct AddSporeOutputCell {
    pub lock_script: ScriptEx,
    pub content_type: String,
    pub content: Vec<u8>,
    pub cluster_id: Option<H256>,
    pub authority_mode: ClusterAuthorityMode,
}

pub fn make_spore_data(content_type: &str, content: &[u8], cluster_id: Option<&H256>) -> Vec<u8> {
    let molecule_spore_data = SporeData::new_builder()
        .content_type(content_type.as_bytes().pack())
        .content(content.pack())
        .cluster_id(cluster_id.map(|v| v.as_bytes().pack()).pack())
        .build();
    molecule_spore_data.as_bytes().to_vec()
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddSporeOutputCell {
    async fn run(
        self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        log: &mut Log,
    ) -> Result<()> {
        if let Some(cluster_id) = self.cluster_id.clone() {
            Box::new(AddClusterCelldepByClusterId {
                cluster_id,
                authority_mode: self.authority_mode,
            })
            .run(rpc, skeleton, log)
            .await?;
        }
        let spore_data =
            make_spore_data(&self.content_type, &self.content, self.cluster_id.as_ref());
        let spore_type_script = hardcoded::spore_script(rpc.network(), vec![]); // later on, args will be filled with type_id
        Box::new(AddOutputCell {
            lock_script: self.lock_script,
            type_script: Some(spore_type_script),
            data: spore_data,
            capacity: 0,
            absolute_capacity: false,
            type_id: true,
        })
        .run(rpc, skeleton, log)
        .await?;
        let spore_id = skeleton.calc_type_id(skeleton.outputs.len() - 1)?;
        log.push((hookkey::NEW_SPORE_ID, spore_id.as_bytes().to_vec()));
        Box::new(AddSporeCelldep {}).run(rpc, skeleton, log).await
    }
}

/// Search and add cluster cell from transaction skeleton's input cells by index
///
/// # Parameters
/// - `input_index`: The index of input cell in transaction skeleton
pub struct AddClusterInputCellByClusterId {
    pub cluster_id: H256,
}

impl AddClusterInputCellByClusterId {
    fn search_key<T: RPC>(&self, rpc: &T, skeleton: &TransactionSkeleton) -> Result<SearchKey> {
        let args = self.cluster_id.as_bytes().to_vec();
        let cluster_type_script = hardcoded::cluster_script(rpc.network(), args);
        let mut query = CellQueryOptions::new_type(cluster_type_script.to_script(skeleton)?);
        query.with_data = Some(true);
        query.script_search_mode = Some(SearchMode::Exact);
        Ok(query.into())
    }
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddClusterInputCellByClusterId {
    async fn run(
        self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        log: &mut Log,
    ) -> Result<()> {
        let search_key = self.search_key(rpc, skeleton)?;
        let Some(indexer_cell) = GetCellsIter::new(rpc, search_key).next().await? else {
            return Err(eyre!("no cluster cell (id: {:#x})", self.cluster_id));
        };
        let cluster_cell = CellInputEx::new_from_indexer_cell(indexer_cell, None);
        skeleton.input(cluster_cell)?.witness(Default::default());
        Box::new(AddClusterCelldep {}).run(rpc, skeleton, log).await
    }
}

/// Add a new Cluster cell
///
/// # Parameters
/// - `lock_script`: The owner lock script
/// - `name`: The name of the cluster
/// - `description`: The description of the cluster
/// - `cluster_id_collector`: The callback function to collect the generated cluster id
pub struct AddClusterOutputCell {
    pub lock_script: ScriptEx,
    pub name: String,
    pub description: Vec<u8>,
}

pub fn make_cluster_data(name: &str, description: &[u8]) -> Vec<u8> {
    let molecule_cluster_data = ClusterDataV2::new_builder()
        .name(name.as_bytes().pack())
        .description(description.pack())
        .build();
    molecule_cluster_data.as_bytes().to_vec()
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddClusterOutputCell {
    async fn run(
        self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        log: &mut Log,
    ) -> Result<()> {
        let cluster_data = make_cluster_data(&self.name, &self.description);
        let cluster_type_script = hardcoded::cluster_script(rpc.network(), vec![]); // later on, args will be filled with type_id
        Box::new(AddOutputCell {
            lock_script: self.lock_script,
            type_script: Some(cluster_type_script),
            data: cluster_data,
            capacity: 0,
            absolute_capacity: false,
            type_id: true,
        })
        .run(rpc, skeleton, log)
        .await?;
        let cluster_id = skeleton.calc_type_id(skeleton.outputs.len() - 1)?;
        log.push((hookkey::NEW_CLUSTER_ID, cluster_id.as_bytes().to_vec()));
        Box::new(AddClusterCelldep {}).run(rpc, skeleton, log).await
    }
}

/// Search spore related cells from transaction skeleton and parse the operations' intention to spore actions
///
/// note: this is essential for a historical issue of co-build project
pub struct AddSporeActions {}

impl AddSporeActions {
    fn compare_code_hash(cell: &CellOutputEx, code_hash: &H256) -> Option<(CellOutputEx, H256)> {
        if let Some(type_script) = cell.type_script() {
            if &Unpack::<H256>::unpack(&type_script.code_hash()) == code_hash {
                let unique_id: [u8; 32] =
                    type_script.args().raw_data().to_vec().try_into().unwrap();
                return Some((cell.clone(), unique_id.into()));
            }
        }
        None
    }
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddSporeActions {
    async fn run(
        self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        _: &mut Log,
    ) -> Result<()> {
        let mut spore_actions: Vec<Action> = vec![];
        // prepare spore related action parameters
        if let Ok(spore) = hardcoded::spore_script(rpc.network(), vec![]).to_script(skeleton) {
            let spore_code_hash = spore.code_hash().unpack();
            let mut spore_output_cells = skeleton
                .outputs
                .iter()
                .filter_map(|cell| Self::compare_code_hash(cell, &spore_code_hash))
                .collect::<Vec<_>>();
            let spore_input_cells = skeleton
                .inputs
                .iter()
                .filter_map(|cell| Self::compare_code_hash(&cell.output, &spore_code_hash))
                .collect::<Vec<_>>();
            // handle spore transfers and burns
            for (input, spore_id) in spore_input_cells {
                if let Some((i, (output, _))) = spore_output_cells
                    .iter()
                    .enumerate()
                    .find(|(_, (output, _))| output.type_script() == input.type_script())
                {
                    let transfer_action = TransferSpore::new_builder()
                        .from(input.lock_script().into())
                        .to(output.lock_script().into())
                        .spore_id(spore_id.pack())
                        .build();
                    spore_actions
                        .push((output.type_script().unwrap(), transfer_action.into()).into());
                    spore_output_cells.remove(i);
                } else {
                    let burn_action = BurnSpore::new_builder()
                        .spore_id(spore_id.pack())
                        .from(input.lock_script().into())
                        .build();
                    spore_actions.push((input.type_script().unwrap(), burn_action.into()).into());
                }
            }
            // handle spore mints
            for (output, spore_id) in spore_output_cells {
                let mint_action = MintSpore::new_builder()
                    .spore_id(spore_id.pack())
                    .to(output.lock_script().into())
                    .data_hash(output.data_hash().pack())
                    .build();
                spore_actions.push((output.type_script().unwrap(), mint_action.into()).into());
            }
        }
        // prepare cluster related action parameters
        if let Ok(cluster) = hardcoded::cluster_script(rpc.network(), vec![]).to_script(skeleton) {
            let cluster_code_hash = cluster.code_hash().unpack();
            let mut cluster_output_cells = skeleton
                .outputs
                .iter()
                .filter_map(|cell| Self::compare_code_hash(cell, &cluster_code_hash))
                .collect::<Vec<_>>();
            let cluster_input_cells = skeleton
                .inputs
                .iter()
                .filter_map(|cell| Self::compare_code_hash(&cell.output, &cluster_code_hash))
                .collect::<Vec<_>>();
            // handle cluster transfers
            for (input, cluster_id) in cluster_input_cells {
                if let Some((i, (output, _))) = cluster_output_cells
                    .iter()
                    .enumerate()
                    .find(|(_, (output, _))| output.type_script() == input.type_script())
                {
                    let transfer_action = TransferCluster::new_builder()
                        .from(input.lock_script().into())
                        .to(output.lock_script().into())
                        .cluster_id(cluster_id.pack())
                        .build();
                    spore_actions
                        .push((output.type_script().unwrap(), transfer_action.into()).into());
                    cluster_output_cells.remove(i);
                }
            }
            // handle cluster mints
            for (output, cluster_id) in cluster_output_cells {
                let mint_action = MintCluster::new_builder()
                    .cluster_id(cluster_id.pack())
                    .to(output.lock_script().into())
                    .data_hash(output.data_hash().pack())
                    .build();
                spore_actions.push((output.type_script().unwrap(), mint_action.into()).into());
            }
        }
        if spore_actions.is_empty() {
            return Err(eyre!("no spore/cluster actions found"));
        }
        // add spore actions into skeleton's witness field
        let witness_layout: WitnessLayout = spore_actions.into();
        skeleton.witness(WitnessEx::new_plain(witness_layout.as_slice().to_vec()));
        Ok(())
    }
}


================================================
File: calculate/src/operation/spore/generated/mod.rs
================================================
mod molecule;
pub use molecule::*;

// Generated types casting for code simplicity
mod casting {
    use super::*;
    use ckb_types::{packed::Script, prelude::*};

    impl From<Script> for Address {
        fn from(value: Script) -> Self {
            Address::new_builder()
                .set(AddressUnion::Script(value))
                .build()
        }
    }

    impl From<TransferSpore> for SporeAction {
        fn from(value: TransferSpore) -> Self {
            SporeAction::new_builder()
                .set(SporeActionUnion::TransferSpore(value))
                .build()
        }
    }

    impl From<MintSpore> for SporeAction {
        fn from(value: MintSpore) -> Self {
            SporeAction::new_builder()
                .set(SporeActionUnion::MintSpore(value))
                .build()
        }
    }

    impl From<BurnSpore> for SporeAction {
        fn from(value: BurnSpore) -> Self {
            SporeAction::new_builder()
                .set(SporeActionUnion::BurnSpore(value))
                .build()
        }
    }

    impl From<MintCluster> for SporeAction {
        fn from(value: MintCluster) -> Self {
            SporeAction::new_builder()
                .set(SporeActionUnion::MintCluster(value))
                .build()
        }
    }

    impl From<TransferCluster> for SporeAction {
        fn from(value: TransferCluster) -> Self {
            SporeAction::new_builder()
                .set(SporeActionUnion::TransferCluster(value))
                .build()
        }
    }

    impl From<(Script, SporeAction)> for Action {
        fn from(value: (Script, SporeAction)) -> Self {
            let (script, spore_action) = value;
            Action::new_builder()
                .script_hash(script.calc_script_hash())
                .data(spore_action.as_slice().pack())
                .build()
        }
    }

    impl From<Vec<Action>> for WitnessLayout {
        fn from(value: Vec<Action>) -> Self {
            let actions = ActionVec::new_builder().set(value).build();
            let message = Message::new_builder().actions(actions).build();
            let sighash_all = SighashAll::new_builder().message(message).build();
            WitnessLayout::new_builder()
                .set(WitnessLayoutUnion::SighashAll(sighash_all))
                .build()
        }
    }
}


================================================
File: calculate/src/operation/spore/generated/molecule.rs
================================================
// Generated by Molecule 0.7.5
#![allow(clippy::all)]
#![allow(unused)]

use ckb_types::{packed::*, prelude::*};

//////////////////////////////////////
// Co-Build Structs
//////////////////////////////////////

#[derive(Clone)]
pub struct Uint32Opt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Uint32Opt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Uint32Opt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Uint32Opt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for Uint32Opt {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Uint32Opt::new_unchecked(v)
    }
}
impl Uint32Opt {
    const DEFAULT_VALUE: [u8; 0] = [];
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Uint32> {
        if self.is_none() {
            None
        } else {
            Some(Uint32::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> Uint32OptReader<'r> {
        Uint32OptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Uint32Opt {
    type Builder = Uint32OptBuilder;
    const NAME: &'static str = "Uint32Opt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Uint32Opt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Uint32OptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Uint32OptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct Uint32OptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Uint32OptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Uint32OptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Uint32OptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> Uint32OptReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Uint32Reader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(Uint32Reader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for Uint32OptReader<'r> {
    type Entity = Uint32Opt;
    const NAME: &'static str = "Uint32OptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Uint32OptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            Uint32Reader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct Uint32OptBuilder(pub(crate) Option<Uint32>);
impl Uint32OptBuilder {
    pub fn set(mut self, v: Option<Uint32>) -> Self {
        self.0 = v;
        self
    }
}
impl molecule::prelude::Builder for Uint32OptBuilder {
    type Entity = Uint32Opt;
    const NAME: &'static str = "Uint32OptBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Uint32Opt::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Action(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Action {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Action {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Action {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "script_info_hash", self.script_info_hash())?;
        write!(f, ", {}: {}", "script_hash", self.script_hash())?;
        write!(f, ", {}: {}", "data", self.data())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Action {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Action::new_unchecked(v)
    }
}
impl Action {
    const DEFAULT_VALUE: [u8; 84] = [
        84, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn script_info_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn script_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn data(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Bytes::new_unchecked(self.0.slice(start..end))
        } else {
            Bytes::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ActionReader<'r> {
        ActionReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Action {
    type Builder = ActionBuilder;
    const NAME: &'static str = "Action";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Action(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ActionReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ActionReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .script_info_hash(self.script_info_hash())
            .script_hash(self.script_hash())
            .data(self.data())
    }
}
#[derive(Clone, Copy)]
pub struct ActionReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ActionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ActionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ActionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "script_info_hash", self.script_info_hash())?;
        write!(f, ", {}: {}", "script_hash", self.script_hash())?;
        write!(f, ", {}: {}", "data", self.data())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ActionReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn script_info_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn script_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn data(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            BytesReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ActionReader<'r> {
    type Entity = Action;
    const NAME: &'static str = "ActionReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ActionReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        BytesReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ActionBuilder {
    pub(crate) script_info_hash: Byte32,
    pub(crate) script_hash: Byte32,
    pub(crate) data: Bytes,
}
impl ActionBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn script_info_hash(mut self, v: Byte32) -> Self {
        self.script_info_hash = v;
        self
    }
    pub fn script_hash(mut self, v: Byte32) -> Self {
        self.script_hash = v;
        self
    }
    pub fn data(mut self, v: Bytes) -> Self {
        self.data = v;
        self
    }
}
impl molecule::prelude::Builder for ActionBuilder {
    type Entity = Action;
    const NAME: &'static str = "ActionBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.script_info_hash.as_slice().len()
            + self.script_hash.as_slice().len()
            + self.data.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.script_info_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.script_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.data.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.script_info_hash.as_slice())?;
        writer.write_all(self.script_hash.as_slice())?;
        writer.write_all(self.data.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Action::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ActionVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ActionVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ActionVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ActionVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for ActionVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        ActionVec::new_unchecked(v)
    }
}
impl ActionVec {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Action> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Action {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            Action::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            Action::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ActionVecReader<'r> {
        ActionVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ActionVec {
    type Builder = ActionVecBuilder;
    const NAME: &'static str = "ActionVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ActionVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ActionVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ActionVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct ActionVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ActionVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ActionVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ActionVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> ActionVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<ActionReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> ActionReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            ActionReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            ActionReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ActionVecReader<'r> {
    type Entity = ActionVec;
    const NAME: &'static str = "ActionVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ActionVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            ActionReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ActionVecBuilder(pub(crate) Vec<Action>);
impl ActionVecBuilder {
    pub fn set(mut self, v: Vec<Action>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Action) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Action>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Action) -> Option<Action> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for ActionVecBuilder {
    type Entity = ActionVec;
    const NAME: &'static str = "ActionVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ActionVec::new_unchecked(inner.into())
    }
}
pub struct ActionVecIterator(ActionVec, usize, usize);
impl ::core::iter::Iterator for ActionVecIterator {
    type Item = Action;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for ActionVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for ActionVec {
    type Item = Action;
    type IntoIter = ActionVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        ActionVecIterator(self, 0, len)
    }
}
impl<'r> ActionVecReader<'r> {
    pub fn iter<'t>(&'t self) -> ActionVecReaderIterator<'t, 'r> {
        ActionVecReaderIterator(&self, 0, self.len())
    }
}
pub struct ActionVecReaderIterator<'t, 'r>(&'t ActionVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for ActionVecReaderIterator<'t, 'r> {
    type Item = ActionReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for ActionVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct Message(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Message {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Message {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Message {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "actions", self.actions())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Message {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Message::new_unchecked(v)
    }
}
impl Message {
    const DEFAULT_VALUE: [u8; 12] = [12, 0, 0, 0, 8, 0, 0, 0, 4, 0, 0, 0];
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn actions(&self) -> ActionVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            ActionVec::new_unchecked(self.0.slice(start..end))
        } else {
            ActionVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> MessageReader<'r> {
        MessageReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Message {
    type Builder = MessageBuilder;
    const NAME: &'static str = "Message";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Message(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        MessageReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        MessageReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().actions(self.actions())
    }
}
#[derive(Clone, Copy)]
pub struct MessageReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for MessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for MessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for MessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "actions", self.actions())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> MessageReader<'r> {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn actions(&self) -> ActionVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            ActionVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            ActionVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for MessageReader<'r> {
    type Entity = Message;
    const NAME: &'static str = "MessageReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        MessageReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ActionVecReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct MessageBuilder {
    pub(crate) actions: ActionVec,
}
impl MessageBuilder {
    pub const FIELD_COUNT: usize = 1;
    pub fn actions(mut self, v: ActionVec) -> Self {
        self.actions = v;
        self
    }
}
impl molecule::prelude::Builder for MessageBuilder {
    type Entity = Message;
    const NAME: &'static str = "MessageBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1) + self.actions.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.actions.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.actions.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Message::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ScriptInfo(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ScriptInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ScriptInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ScriptInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "name", self.name())?;
        write!(f, ", {}: {}", "url", self.url())?;
        write!(f, ", {}: {}", "script_hash", self.script_hash())?;
        write!(f, ", {}: {}", "schema", self.schema())?;
        write!(f, ", {}: {}", "message_type", self.message_type())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ScriptInfo {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        ScriptInfo::new_unchecked(v)
    }
}
impl ScriptInfo {
    const DEFAULT_VALUE: [u8; 72] = [
        72, 0, 0, 0, 24, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 64, 0, 0, 0, 68, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 5;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn name(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }
    pub fn url(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }
    pub fn script_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn schema(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }
    pub fn message_type(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[24..]) as usize;
            Bytes::new_unchecked(self.0.slice(start..end))
        } else {
            Bytes::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ScriptInfoReader<'r> {
        ScriptInfoReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ScriptInfo {
    type Builder = ScriptInfoBuilder;
    const NAME: &'static str = "ScriptInfo";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ScriptInfo(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ScriptInfoReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ScriptInfoReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .name(self.name())
            .url(self.url())
            .script_hash(self.script_hash())
            .schema(self.schema())
            .message_type(self.message_type())
    }
}
#[derive(Clone, Copy)]
pub struct ScriptInfoReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ScriptInfoReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ScriptInfoReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ScriptInfoReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "name", self.name())?;
        write!(f, ", {}: {}", "url", self.url())?;
        write!(f, ", {}: {}", "script_hash", self.script_hash())?;
        write!(f, ", {}: {}", "schema", self.schema())?;
        write!(f, ", {}: {}", "message_type", self.message_type())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ScriptInfoReader<'r> {
    pub const FIELD_COUNT: usize = 5;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn name(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn url(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn script_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn schema(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn message_type(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[24..]) as usize;
            BytesReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ScriptInfoReader<'r> {
    type Entity = ScriptInfo;
    const NAME: &'static str = "ScriptInfoReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ScriptInfoReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        BytesReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        BytesReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Byte32Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        BytesReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        BytesReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ScriptInfoBuilder {
    pub(crate) name: Bytes,
    pub(crate) url: Bytes,
    pub(crate) script_hash: Byte32,
    pub(crate) schema: Bytes,
    pub(crate) message_type: Bytes,
}
impl ScriptInfoBuilder {
    pub const FIELD_COUNT: usize = 5;
    pub fn name(mut self, v: Bytes) -> Self {
        self.name = v;
        self
    }
    pub fn url(mut self, v: Bytes) -> Self {
        self.url = v;
        self
    }
    pub fn script_hash(mut self, v: Byte32) -> Self {
        self.script_hash = v;
        self
    }
    pub fn schema(mut self, v: Bytes) -> Self {
        self.schema = v;
        self
    }
    pub fn message_type(mut self, v: Bytes) -> Self {
        self.message_type = v;
        self
    }
}
impl molecule::prelude::Builder for ScriptInfoBuilder {
    type Entity = ScriptInfo;
    const NAME: &'static str = "ScriptInfoBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.name.as_slice().len()
            + self.url.as_slice().len()
            + self.script_hash.as_slice().len()
            + self.schema.as_slice().len()
            + self.message_type.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.name.as_slice().len();
        offsets.push(total_size);
        total_size += self.url.as_slice().len();
        offsets.push(total_size);
        total_size += self.script_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.schema.as_slice().len();
        offsets.push(total_size);
        total_size += self.message_type.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.name.as_slice())?;
        writer.write_all(self.url.as_slice())?;
        writer.write_all(self.script_hash.as_slice())?;
        writer.write_all(self.schema.as_slice())?;
        writer.write_all(self.message_type.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ScriptInfo::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ScriptInfoVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ScriptInfoVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ScriptInfoVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ScriptInfoVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for ScriptInfoVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        ScriptInfoVec::new_unchecked(v)
    }
}
impl ScriptInfoVec {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<ScriptInfo> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> ScriptInfo {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            ScriptInfo::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            ScriptInfo::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ScriptInfoVecReader<'r> {
        ScriptInfoVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ScriptInfoVec {
    type Builder = ScriptInfoVecBuilder;
    const NAME: &'static str = "ScriptInfoVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ScriptInfoVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ScriptInfoVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ScriptInfoVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct ScriptInfoVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ScriptInfoVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ScriptInfoVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ScriptInfoVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> ScriptInfoVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<ScriptInfoReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> ScriptInfoReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            ScriptInfoReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            ScriptInfoReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ScriptInfoVecReader<'r> {
    type Entity = ScriptInfoVec;
    const NAME: &'static str = "ScriptInfoVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ScriptInfoVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            ScriptInfoReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ScriptInfoVecBuilder(pub(crate) Vec<ScriptInfo>);
impl ScriptInfoVecBuilder {
    pub fn set(mut self, v: Vec<ScriptInfo>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: ScriptInfo) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = ScriptInfo>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: ScriptInfo) -> Option<ScriptInfo> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for ScriptInfoVecBuilder {
    type Entity = ScriptInfoVec;
    const NAME: &'static str = "ScriptInfoVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ScriptInfoVec::new_unchecked(inner.into())
    }
}
pub struct ScriptInfoVecIterator(ScriptInfoVec, usize, usize);
impl ::core::iter::Iterator for ScriptInfoVecIterator {
    type Item = ScriptInfo;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for ScriptInfoVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for ScriptInfoVec {
    type Item = ScriptInfo;
    type IntoIter = ScriptInfoVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        ScriptInfoVecIterator(self, 0, len)
    }
}
impl<'r> ScriptInfoVecReader<'r> {
    pub fn iter<'t>(&'t self) -> ScriptInfoVecReaderIterator<'t, 'r> {
        ScriptInfoVecReaderIterator(&self, 0, self.len())
    }
}
pub struct ScriptInfoVecReaderIterator<'t, 'r>(&'t ScriptInfoVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for ScriptInfoVecReaderIterator<'t, 'r> {
    type Item = ScriptInfoReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for ScriptInfoVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct ResolvedInputs(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ResolvedInputs {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ResolvedInputs {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ResolvedInputs {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "outputs", self.outputs())?;
        write!(f, ", {}: {}", "outputs_data", self.outputs_data())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ResolvedInputs {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        ResolvedInputs::new_unchecked(v)
    }
}
impl ResolvedInputs {
    const DEFAULT_VALUE: [u8; 20] = [
        20, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn outputs(&self) -> CellOutputVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        CellOutputVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn outputs_data(&self) -> BytesVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            BytesVec::new_unchecked(self.0.slice(start..end))
        } else {
            BytesVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ResolvedInputsReader<'r> {
        ResolvedInputsReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ResolvedInputs {
    type Builder = ResolvedInputsBuilder;
    const NAME: &'static str = "ResolvedInputs";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ResolvedInputs(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ResolvedInputsReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ResolvedInputsReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .outputs(self.outputs())
            .outputs_data(self.outputs_data())
    }
}
#[derive(Clone, Copy)]
pub struct ResolvedInputsReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ResolvedInputsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ResolvedInputsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ResolvedInputsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "outputs", self.outputs())?;
        write!(f, ", {}: {}", "outputs_data", self.outputs_data())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ResolvedInputsReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn outputs(&self) -> CellOutputVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        CellOutputVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn outputs_data(&self) -> BytesVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            BytesVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ResolvedInputsReader<'r> {
    type Entity = ResolvedInputs;
    const NAME: &'static str = "ResolvedInputsReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ResolvedInputsReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        CellOutputVecReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        BytesVecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ResolvedInputsBuilder {
    pub(crate) outputs: CellOutputVec,
    pub(crate) outputs_data: BytesVec,
}
impl ResolvedInputsBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn outputs(mut self, v: CellOutputVec) -> Self {
        self.outputs = v;
        self
    }
    pub fn outputs_data(mut self, v: BytesVec) -> Self {
        self.outputs_data = v;
        self
    }
}
impl molecule::prelude::Builder for ResolvedInputsBuilder {
    type Entity = ResolvedInputs;
    const NAME: &'static str = "ResolvedInputsBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.outputs.as_slice().len()
            + self.outputs_data.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.outputs.as_slice().len();
        offsets.push(total_size);
        total_size += self.outputs_data.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.outputs.as_slice())?;
        writer.write_all(self.outputs_data.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ResolvedInputs::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct BuildingPacketV1(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BuildingPacketV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BuildingPacketV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BuildingPacketV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "message", self.message())?;
        write!(f, ", {}: {}", "payload", self.payload())?;
        write!(f, ", {}: {}", "resolved_inputs", self.resolved_inputs())?;
        write!(f, ", {}: {}", "change_output", self.change_output())?;
        write!(f, ", {}: {}", "script_infos", self.script_infos())?;
        write!(f, ", {}: {}", "lock_actions", self.lock_actions())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for BuildingPacketV1 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        BuildingPacketV1::new_unchecked(v)
    }
}
impl BuildingPacketV1 {
    const DEFAULT_VALUE: [u8; 136] = [
        136, 0, 0, 0, 28, 0, 0, 0, 40, 0, 0, 0, 108, 0, 0, 0, 128, 0, 0, 0, 128, 0, 0, 0, 132, 0,
        0, 0, 12, 0, 0, 0, 8, 0, 0, 0, 4, 0, 0, 0, 68, 0, 0, 0, 12, 0, 0, 0, 64, 0, 0, 0, 52, 0, 0,
        0, 28, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 20, 0, 0, 0, 12,
        0, 0, 0, 16, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn message(&self) -> Message {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Message::new_unchecked(self.0.slice(start..end))
    }
    pub fn payload(&self) -> Transaction {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Transaction::new_unchecked(self.0.slice(start..end))
    }
    pub fn resolved_inputs(&self) -> ResolvedInputs {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        ResolvedInputs::new_unchecked(self.0.slice(start..end))
    }
    pub fn change_output(&self) -> Uint32Opt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint32Opt::new_unchecked(self.0.slice(start..end))
    }
    pub fn script_infos(&self) -> ScriptInfoVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        ScriptInfoVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn lock_actions(&self) -> ActionVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            ActionVec::new_unchecked(self.0.slice(start..end))
        } else {
            ActionVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BuildingPacketV1Reader<'r> {
        BuildingPacketV1Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BuildingPacketV1 {
    type Builder = BuildingPacketV1Builder;
    const NAME: &'static str = "BuildingPacketV1";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BuildingPacketV1(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BuildingPacketV1Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BuildingPacketV1Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .message(self.message())
            .payload(self.payload())
            .resolved_inputs(self.resolved_inputs())
            .change_output(self.change_output())
            .script_infos(self.script_infos())
            .lock_actions(self.lock_actions())
    }
}
#[derive(Clone, Copy)]
pub struct BuildingPacketV1Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BuildingPacketV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BuildingPacketV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BuildingPacketV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "message", self.message())?;
        write!(f, ", {}: {}", "payload", self.payload())?;
        write!(f, ", {}: {}", "resolved_inputs", self.resolved_inputs())?;
        write!(f, ", {}: {}", "change_output", self.change_output())?;
        write!(f, ", {}: {}", "script_infos", self.script_infos())?;
        write!(f, ", {}: {}", "lock_actions", self.lock_actions())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> BuildingPacketV1Reader<'r> {
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn message(&self) -> MessageReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        MessageReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn payload(&self) -> TransactionReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        TransactionReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn resolved_inputs(&self) -> ResolvedInputsReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        ResolvedInputsReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn change_output(&self) -> Uint32OptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint32OptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn script_infos(&self) -> ScriptInfoVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        ScriptInfoVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn lock_actions(&self) -> ActionVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            ActionVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            ActionVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BuildingPacketV1Reader<'r> {
    type Entity = BuildingPacketV1;
    const NAME: &'static str = "BuildingPacketV1Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BuildingPacketV1Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        MessageReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        TransactionReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        ResolvedInputsReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Uint32OptReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        ScriptInfoVecReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        ActionVecReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct BuildingPacketV1Builder {
    pub(crate) message: Message,
    pub(crate) payload: Transaction,
    pub(crate) resolved_inputs: ResolvedInputs,
    pub(crate) change_output: Uint32Opt,
    pub(crate) script_infos: ScriptInfoVec,
    pub(crate) lock_actions: ActionVec,
}
impl BuildingPacketV1Builder {
    pub const FIELD_COUNT: usize = 6;
    pub fn message(mut self, v: Message) -> Self {
        self.message = v;
        self
    }
    pub fn payload(mut self, v: Transaction) -> Self {
        self.payload = v;
        self
    }
    pub fn resolved_inputs(mut self, v: ResolvedInputs) -> Self {
        self.resolved_inputs = v;
        self
    }
    pub fn change_output(mut self, v: Uint32Opt) -> Self {
        self.change_output = v;
        self
    }
    pub fn script_infos(mut self, v: ScriptInfoVec) -> Self {
        self.script_infos = v;
        self
    }
    pub fn lock_actions(mut self, v: ActionVec) -> Self {
        self.lock_actions = v;
        self
    }
}
impl molecule::prelude::Builder for BuildingPacketV1Builder {
    type Entity = BuildingPacketV1;
    const NAME: &'static str = "BuildingPacketV1Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.message.as_slice().len()
            + self.payload.as_slice().len()
            + self.resolved_inputs.as_slice().len()
            + self.change_output.as_slice().len()
            + self.script_infos.as_slice().len()
            + self.lock_actions.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.message.as_slice().len();
        offsets.push(total_size);
        total_size += self.payload.as_slice().len();
        offsets.push(total_size);
        total_size += self.resolved_inputs.as_slice().len();
        offsets.push(total_size);
        total_size += self.change_output.as_slice().len();
        offsets.push(total_size);
        total_size += self.script_infos.as_slice().len();
        offsets.push(total_size);
        total_size += self.lock_actions.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.message.as_slice())?;
        writer.write_all(self.payload.as_slice())?;
        writer.write_all(self.resolved_inputs.as_slice())?;
        writer.write_all(self.change_output.as_slice())?;
        writer.write_all(self.script_infos.as_slice())?;
        writer.write_all(self.lock_actions.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BuildingPacketV1::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct BuildingPacket(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BuildingPacket {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BuildingPacket {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BuildingPacket {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for BuildingPacket {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        BuildingPacket::new_unchecked(v)
    }
}
impl BuildingPacket {
    const DEFAULT_VALUE: [u8; 140] = [
        0, 0, 0, 0, 136, 0, 0, 0, 28, 0, 0, 0, 40, 0, 0, 0, 108, 0, 0, 0, 128, 0, 0, 0, 128, 0, 0,
        0, 132, 0, 0, 0, 12, 0, 0, 0, 8, 0, 0, 0, 4, 0, 0, 0, 68, 0, 0, 0, 12, 0, 0, 0, 64, 0, 0,
        0, 52, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 20,
        0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const ITEMS_COUNT: usize = 1;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> BuildingPacketUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => BuildingPacketV1::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> BuildingPacketReader<'r> {
        BuildingPacketReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BuildingPacket {
    type Builder = BuildingPacketBuilder;
    const NAME: &'static str = "BuildingPacket";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BuildingPacket(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BuildingPacketReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BuildingPacketReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct BuildingPacketReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BuildingPacketReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BuildingPacketReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BuildingPacketReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> BuildingPacketReader<'r> {
    pub const ITEMS_COUNT: usize = 1;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> BuildingPacketUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => BuildingPacketV1Reader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BuildingPacketReader<'r> {
    type Entity = BuildingPacket;
    const NAME: &'static str = "BuildingPacketReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BuildingPacketReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => BuildingPacketV1Reader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct BuildingPacketBuilder(pub(crate) BuildingPacketUnion);
impl BuildingPacketBuilder {
    pub const ITEMS_COUNT: usize = 1;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<BuildingPacketUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for BuildingPacketBuilder {
    type Entity = BuildingPacket;
    const NAME: &'static str = "BuildingPacketBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BuildingPacket::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum BuildingPacketUnion {
    BuildingPacketV1(BuildingPacketV1),
}
#[derive(Debug, Clone, Copy)]
pub enum BuildingPacketUnionReader<'r> {
    BuildingPacketV1(BuildingPacketV1Reader<'r>),
}
impl ::core::default::Default for BuildingPacketUnion {
    fn default() -> Self {
        BuildingPacketUnion::BuildingPacketV1(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for BuildingPacketUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            BuildingPacketUnion::BuildingPacketV1(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, BuildingPacketV1::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for BuildingPacketUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            BuildingPacketUnionReader::BuildingPacketV1(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, BuildingPacketV1::NAME, item)
            }
        }
    }
}
impl BuildingPacketUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            BuildingPacketUnion::BuildingPacketV1(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> BuildingPacketUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            BuildingPacketUnionReader::BuildingPacketV1(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<BuildingPacketV1> for BuildingPacketUnion {
    fn from(item: BuildingPacketV1) -> Self {
        BuildingPacketUnion::BuildingPacketV1(item)
    }
}
impl<'r> ::core::convert::From<BuildingPacketV1Reader<'r>> for BuildingPacketUnionReader<'r> {
    fn from(item: BuildingPacketV1Reader<'r>) -> Self {
        BuildingPacketUnionReader::BuildingPacketV1(item)
    }
}
impl BuildingPacketUnion {
    pub const NAME: &'static str = "BuildingPacketUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            BuildingPacketUnion::BuildingPacketV1(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            BuildingPacketUnion::BuildingPacketV1(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            BuildingPacketUnion::BuildingPacketV1(_) => 0,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            BuildingPacketUnion::BuildingPacketV1(_) => "BuildingPacketV1",
        }
    }
    pub fn as_reader<'r>(&'r self) -> BuildingPacketUnionReader<'r> {
        match self {
            BuildingPacketUnion::BuildingPacketV1(item) => item.as_reader().into(),
        }
    }
}
impl<'r> BuildingPacketUnionReader<'r> {
    pub const NAME: &'r str = "BuildingPacketUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            BuildingPacketUnionReader::BuildingPacketV1(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            BuildingPacketUnionReader::BuildingPacketV1(_) => 0,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            BuildingPacketUnionReader::BuildingPacketV1(_) => "BuildingPacketV1",
        }
    }
}
#[derive(Clone)]
pub struct SighashAll(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SighashAll {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SighashAll {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SighashAll {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "seal", self.seal())?;
        write!(f, ", {}: {}", "message", self.message())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for SighashAll {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        SighashAll::new_unchecked(v)
    }
}
impl SighashAll {
    const DEFAULT_VALUE: [u8; 28] = [
        28, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 8, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn seal(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }
    pub fn message(&self) -> Message {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Message::new_unchecked(self.0.slice(start..end))
        } else {
            Message::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> SighashAllReader<'r> {
        SighashAllReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SighashAll {
    type Builder = SighashAllBuilder;
    const NAME: &'static str = "SighashAll";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SighashAll(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SighashAllReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SighashAllReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .seal(self.seal())
            .message(self.message())
    }
}
#[derive(Clone, Copy)]
pub struct SighashAllReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SighashAllReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SighashAllReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SighashAllReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "seal", self.seal())?;
        write!(f, ", {}: {}", "message", self.message())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> SighashAllReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn seal(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn message(&self) -> MessageReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            MessageReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            MessageReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SighashAllReader<'r> {
    type Entity = SighashAll;
    const NAME: &'static str = "SighashAllReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SighashAllReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        BytesReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        MessageReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SighashAllBuilder {
    pub(crate) seal: Bytes,
    pub(crate) message: Message,
}
impl SighashAllBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn seal(mut self, v: Bytes) -> Self {
        self.seal = v;
        self
    }
    pub fn message(mut self, v: Message) -> Self {
        self.message = v;
        self
    }
}
impl molecule::prelude::Builder for SighashAllBuilder {
    type Entity = SighashAll;
    const NAME: &'static str = "SighashAllBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.seal.as_slice().len()
            + self.message.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.seal.as_slice().len();
        offsets.push(total_size);
        total_size += self.message.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.seal.as_slice())?;
        writer.write_all(self.message.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SighashAll::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SighashAllOnly(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SighashAllOnly {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SighashAllOnly {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SighashAllOnly {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "seal", self.seal())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for SighashAllOnly {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        SighashAllOnly::new_unchecked(v)
    }
}
impl SighashAllOnly {
    const DEFAULT_VALUE: [u8; 12] = [12, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0];
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn seal(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            Bytes::new_unchecked(self.0.slice(start..end))
        } else {
            Bytes::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> SighashAllOnlyReader<'r> {
        SighashAllOnlyReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SighashAllOnly {
    type Builder = SighashAllOnlyBuilder;
    const NAME: &'static str = "SighashAllOnly";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SighashAllOnly(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SighashAllOnlyReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SighashAllOnlyReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().seal(self.seal())
    }
}
#[derive(Clone, Copy)]
pub struct SighashAllOnlyReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SighashAllOnlyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SighashAllOnlyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SighashAllOnlyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "seal", self.seal())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> SighashAllOnlyReader<'r> {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn seal(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            BytesReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SighashAllOnlyReader<'r> {
    type Entity = SighashAllOnly;
    const NAME: &'static str = "SighashAllOnlyReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SighashAllOnlyReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        BytesReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SighashAllOnlyBuilder {
    pub(crate) seal: Bytes,
}
impl SighashAllOnlyBuilder {
    pub const FIELD_COUNT: usize = 1;
    pub fn seal(mut self, v: Bytes) -> Self {
        self.seal = v;
        self
    }
}
impl molecule::prelude::Builder for SighashAllOnlyBuilder {
    type Entity = SighashAllOnly;
    const NAME: &'static str = "SighashAllOnlyBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1) + self.seal.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.seal.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.seal.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SighashAllOnly::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct OtxStart(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for OtxStart {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for OtxStart {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for OtxStart {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "start_input_cell", self.start_input_cell())?;
        write!(f, ", {}: {}", "start_output_cell", self.start_output_cell())?;
        write!(f, ", {}: {}", "start_cell_deps", self.start_cell_deps())?;
        write!(f, ", {}: {}", "start_header_deps", self.start_header_deps())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for OtxStart {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        OtxStart::new_unchecked(v)
    }
}
impl OtxStart {
    const DEFAULT_VALUE: [u8; 36] = [
        36, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn start_input_cell(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn start_output_cell(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn start_cell_deps(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn start_header_deps(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            Uint32::new_unchecked(self.0.slice(start..end))
        } else {
            Uint32::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> OtxStartReader<'r> {
        OtxStartReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for OtxStart {
    type Builder = OtxStartBuilder;
    const NAME: &'static str = "OtxStart";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        OtxStart(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        OtxStartReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        OtxStartReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .start_input_cell(self.start_input_cell())
            .start_output_cell(self.start_output_cell())
            .start_cell_deps(self.start_cell_deps())
            .start_header_deps(self.start_header_deps())
    }
}
#[derive(Clone, Copy)]
pub struct OtxStartReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for OtxStartReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for OtxStartReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for OtxStartReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "start_input_cell", self.start_input_cell())?;
        write!(f, ", {}: {}", "start_output_cell", self.start_output_cell())?;
        write!(f, ", {}: {}", "start_cell_deps", self.start_cell_deps())?;
        write!(f, ", {}: {}", "start_header_deps", self.start_header_deps())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> OtxStartReader<'r> {
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn start_input_cell(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn start_output_cell(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn start_cell_deps(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn start_header_deps(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            Uint32Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Uint32Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for OtxStartReader<'r> {
    type Entity = OtxStart;
    const NAME: &'static str = "OtxStartReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        OtxStartReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Uint32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Uint32Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Uint32Reader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct OtxStartBuilder {
    pub(crate) start_input_cell: Uint32,
    pub(crate) start_output_cell: Uint32,
    pub(crate) start_cell_deps: Uint32,
    pub(crate) start_header_deps: Uint32,
}
impl OtxStartBuilder {
    pub const FIELD_COUNT: usize = 4;
    pub fn start_input_cell(mut self, v: Uint32) -> Self {
        self.start_input_cell = v;
        self
    }
    pub fn start_output_cell(mut self, v: Uint32) -> Self {
        self.start_output_cell = v;
        self
    }
    pub fn start_cell_deps(mut self, v: Uint32) -> Self {
        self.start_cell_deps = v;
        self
    }
    pub fn start_header_deps(mut self, v: Uint32) -> Self {
        self.start_header_deps = v;
        self
    }
}
impl molecule::prelude::Builder for OtxStartBuilder {
    type Entity = OtxStart;
    const NAME: &'static str = "OtxStartBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.start_input_cell.as_slice().len()
            + self.start_output_cell.as_slice().len()
            + self.start_cell_deps.as_slice().len()
            + self.start_header_deps.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.start_input_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.start_output_cell.as_slice().len();
        offsets.push(total_size);
        total_size += self.start_cell_deps.as_slice().len();
        offsets.push(total_size);
        total_size += self.start_header_deps.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.start_input_cell.as_slice())?;
        writer.write_all(self.start_output_cell.as_slice())?;
        writer.write_all(self.start_cell_deps.as_slice())?;
        writer.write_all(self.start_header_deps.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        OtxStart::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Otx(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Otx {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Otx {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Otx {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "lock", self.lock())?;
        write!(f, ", {}: {}", "input_cells", self.input_cells())?;
        write!(f, ", {}: {}", "output_cells", self.output_cells())?;
        write!(f, ", {}: {}", "cell_deps", self.cell_deps())?;
        write!(f, ", {}: {}", "header_deps", self.header_deps())?;
        write!(f, ", {}: {}", "message", self.message())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Otx {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Otx::new_unchecked(v)
    }
}
impl Otx {
    const DEFAULT_VALUE: [u8; 60] = [
        60, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 8, 0, 0, 0, 4, 0,
        0, 0,
    ];
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn lock(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }
    pub fn input_cells(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn output_cells(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn cell_deps(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn header_deps(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn message(&self) -> Message {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            Message::new_unchecked(self.0.slice(start..end))
        } else {
            Message::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> OtxReader<'r> {
        OtxReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Otx {
    type Builder = OtxBuilder;
    const NAME: &'static str = "Otx";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Otx(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        OtxReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        OtxReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .lock(self.lock())
            .input_cells(self.input_cells())
            .output_cells(self.output_cells())
            .cell_deps(self.cell_deps())
            .header_deps(self.header_deps())
            .message(self.message())
    }
}
#[derive(Clone, Copy)]
pub struct OtxReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for OtxReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for OtxReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for OtxReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "lock", self.lock())?;
        write!(f, ", {}: {}", "input_cells", self.input_cells())?;
        write!(f, ", {}: {}", "output_cells", self.output_cells())?;
        write!(f, ", {}: {}", "cell_deps", self.cell_deps())?;
        write!(f, ", {}: {}", "header_deps", self.header_deps())?;
        write!(f, ", {}: {}", "message", self.message())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> OtxReader<'r> {
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn lock(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn input_cells(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn output_cells(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn cell_deps(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn header_deps(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn message(&self) -> MessageReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            MessageReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            MessageReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for OtxReader<'r> {
    type Entity = Otx;
    const NAME: &'static str = "OtxReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        OtxReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        BytesReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Uint32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Uint32Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Uint32Reader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Uint32Reader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        MessageReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct OtxBuilder {
    pub(crate) lock: Bytes,
    pub(crate) input_cells: Uint32,
    pub(crate) output_cells: Uint32,
    pub(crate) cell_deps: Uint32,
    pub(crate) header_deps: Uint32,
    pub(crate) message: Message,
}
impl OtxBuilder {
    pub const FIELD_COUNT: usize = 6;
    pub fn lock(mut self, v: Bytes) -> Self {
        self.lock = v;
        self
    }
    pub fn input_cells(mut self, v: Uint32) -> Self {
        self.input_cells = v;
        self
    }
    pub fn output_cells(mut self, v: Uint32) -> Self {
        self.output_cells = v;
        self
    }
    pub fn cell_deps(mut self, v: Uint32) -> Self {
        self.cell_deps = v;
        self
    }
    pub fn header_deps(mut self, v: Uint32) -> Self {
        self.header_deps = v;
        self
    }
    pub fn message(mut self, v: Message) -> Self {
        self.message = v;
        self
    }
}
impl molecule::prelude::Builder for OtxBuilder {
    type Entity = Otx;
    const NAME: &'static str = "OtxBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.lock.as_slice().len()
            + self.input_cells.as_slice().len()
            + self.output_cells.as_slice().len()
            + self.cell_deps.as_slice().len()
            + self.header_deps.as_slice().len()
            + self.message.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.lock.as_slice().len();
        offsets.push(total_size);
        total_size += self.input_cells.as_slice().len();
        offsets.push(total_size);
        total_size += self.output_cells.as_slice().len();
        offsets.push(total_size);
        total_size += self.cell_deps.as_slice().len();
        offsets.push(total_size);
        total_size += self.header_deps.as_slice().len();
        offsets.push(total_size);
        total_size += self.message.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.lock.as_slice())?;
        writer.write_all(self.input_cells.as_slice())?;
        writer.write_all(self.output_cells.as_slice())?;
        writer.write_all(self.cell_deps.as_slice())?;
        writer.write_all(self.header_deps.as_slice())?;
        writer.write_all(self.message.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Otx::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct WitnessLayout(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for WitnessLayout {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for WitnessLayout {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for WitnessLayout {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for WitnessLayout {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        WitnessLayout::new_unchecked(v)
    }
}
impl WitnessLayout {
    const DEFAULT_VALUE: [u8; 32] = [
        1, 0, 0, 255, 28, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 8, 0, 0, 0,
        4, 0, 0, 0,
    ];
    pub const ITEMS_COUNT: usize = 4;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> WitnessLayoutUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            4278190081 => SighashAll::new_unchecked(inner).into(),
            4278190082 => SighashAllOnly::new_unchecked(inner).into(),
            4278190083 => Otx::new_unchecked(inner).into(),
            4278190084 => OtxStart::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> WitnessLayoutReader<'r> {
        WitnessLayoutReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for WitnessLayout {
    type Builder = WitnessLayoutBuilder;
    const NAME: &'static str = "WitnessLayout";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        WitnessLayout(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        WitnessLayoutReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        WitnessLayoutReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct WitnessLayoutReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for WitnessLayoutReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for WitnessLayoutReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for WitnessLayoutReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> WitnessLayoutReader<'r> {
    pub const ITEMS_COUNT: usize = 4;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> WitnessLayoutUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            4278190081 => SighashAllReader::new_unchecked(inner).into(),
            4278190082 => SighashAllOnlyReader::new_unchecked(inner).into(),
            4278190083 => OtxReader::new_unchecked(inner).into(),
            4278190084 => OtxStartReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for WitnessLayoutReader<'r> {
    type Entity = WitnessLayout;
    const NAME: &'static str = "WitnessLayoutReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        WitnessLayoutReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            4278190081 => SighashAllReader::verify(inner_slice, compatible),
            4278190082 => SighashAllOnlyReader::verify(inner_slice, compatible),
            4278190083 => OtxReader::verify(inner_slice, compatible),
            4278190084 => OtxStartReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct WitnessLayoutBuilder(pub(crate) WitnessLayoutUnion);
impl WitnessLayoutBuilder {
    pub const ITEMS_COUNT: usize = 4;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<WitnessLayoutUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for WitnessLayoutBuilder {
    type Entity = WitnessLayout;
    const NAME: &'static str = "WitnessLayoutBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        WitnessLayout::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum WitnessLayoutUnion {
    SighashAll(SighashAll),
    SighashAllOnly(SighashAllOnly),
    Otx(Otx),
    OtxStart(OtxStart),
}
#[derive(Debug, Clone, Copy)]
pub enum WitnessLayoutUnionReader<'r> {
    SighashAll(SighashAllReader<'r>),
    SighashAllOnly(SighashAllOnlyReader<'r>),
    Otx(OtxReader<'r>),
    OtxStart(OtxStartReader<'r>),
}
impl ::core::default::Default for WitnessLayoutUnion {
    fn default() -> Self {
        WitnessLayoutUnion::SighashAll(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for WitnessLayoutUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            WitnessLayoutUnion::SighashAll(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, SighashAll::NAME, item)
            }
            WitnessLayoutUnion::SighashAllOnly(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, SighashAllOnly::NAME, item)
            }
            WitnessLayoutUnion::Otx(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Otx::NAME, item)
            }
            WitnessLayoutUnion::OtxStart(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, OtxStart::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for WitnessLayoutUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            WitnessLayoutUnionReader::SighashAll(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, SighashAll::NAME, item)
            }
            WitnessLayoutUnionReader::SighashAllOnly(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, SighashAllOnly::NAME, item)
            }
            WitnessLayoutUnionReader::Otx(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Otx::NAME, item)
            }
            WitnessLayoutUnionReader::OtxStart(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, OtxStart::NAME, item)
            }
        }
    }
}
impl WitnessLayoutUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            WitnessLayoutUnion::SighashAll(ref item) => write!(f, "{}", item),
            WitnessLayoutUnion::SighashAllOnly(ref item) => write!(f, "{}", item),
            WitnessLayoutUnion::Otx(ref item) => write!(f, "{}", item),
            WitnessLayoutUnion::OtxStart(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> WitnessLayoutUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            WitnessLayoutUnionReader::SighashAll(ref item) => write!(f, "{}", item),
            WitnessLayoutUnionReader::SighashAllOnly(ref item) => write!(f, "{}", item),
            WitnessLayoutUnionReader::Otx(ref item) => write!(f, "{}", item),
            WitnessLayoutUnionReader::OtxStart(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<SighashAll> for WitnessLayoutUnion {
    fn from(item: SighashAll) -> Self {
        WitnessLayoutUnion::SighashAll(item)
    }
}
impl ::core::convert::From<SighashAllOnly> for WitnessLayoutUnion {
    fn from(item: SighashAllOnly) -> Self {
        WitnessLayoutUnion::SighashAllOnly(item)
    }
}
impl ::core::convert::From<Otx> for WitnessLayoutUnion {
    fn from(item: Otx) -> Self {
        WitnessLayoutUnion::Otx(item)
    }
}
impl ::core::convert::From<OtxStart> for WitnessLayoutUnion {
    fn from(item: OtxStart) -> Self {
        WitnessLayoutUnion::OtxStart(item)
    }
}
impl<'r> ::core::convert::From<SighashAllReader<'r>> for WitnessLayoutUnionReader<'r> {
    fn from(item: SighashAllReader<'r>) -> Self {
        WitnessLayoutUnionReader::SighashAll(item)
    }
}
impl<'r> ::core::convert::From<SighashAllOnlyReader<'r>> for WitnessLayoutUnionReader<'r> {
    fn from(item: SighashAllOnlyReader<'r>) -> Self {
        WitnessLayoutUnionReader::SighashAllOnly(item)
    }
}
impl<'r> ::core::convert::From<OtxReader<'r>> for WitnessLayoutUnionReader<'r> {
    fn from(item: OtxReader<'r>) -> Self {
        WitnessLayoutUnionReader::Otx(item)
    }
}
impl<'r> ::core::convert::From<OtxStartReader<'r>> for WitnessLayoutUnionReader<'r> {
    fn from(item: OtxStartReader<'r>) -> Self {
        WitnessLayoutUnionReader::OtxStart(item)
    }
}
impl WitnessLayoutUnion {
    pub const NAME: &'static str = "WitnessLayoutUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            WitnessLayoutUnion::SighashAll(item) => item.as_bytes(),
            WitnessLayoutUnion::SighashAllOnly(item) => item.as_bytes(),
            WitnessLayoutUnion::Otx(item) => item.as_bytes(),
            WitnessLayoutUnion::OtxStart(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            WitnessLayoutUnion::SighashAll(item) => item.as_slice(),
            WitnessLayoutUnion::SighashAllOnly(item) => item.as_slice(),
            WitnessLayoutUnion::Otx(item) => item.as_slice(),
            WitnessLayoutUnion::OtxStart(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            WitnessLayoutUnion::SighashAll(_) => 4278190081,
            WitnessLayoutUnion::SighashAllOnly(_) => 4278190082,
            WitnessLayoutUnion::Otx(_) => 4278190083,
            WitnessLayoutUnion::OtxStart(_) => 4278190084,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            WitnessLayoutUnion::SighashAll(_) => "SighashAll",
            WitnessLayoutUnion::SighashAllOnly(_) => "SighashAllOnly",
            WitnessLayoutUnion::Otx(_) => "Otx",
            WitnessLayoutUnion::OtxStart(_) => "OtxStart",
        }
    }
    pub fn as_reader<'r>(&'r self) -> WitnessLayoutUnionReader<'r> {
        match self {
            WitnessLayoutUnion::SighashAll(item) => item.as_reader().into(),
            WitnessLayoutUnion::SighashAllOnly(item) => item.as_reader().into(),
            WitnessLayoutUnion::Otx(item) => item.as_reader().into(),
            WitnessLayoutUnion::OtxStart(item) => item.as_reader().into(),
        }
    }
}
impl<'r> WitnessLayoutUnionReader<'r> {
    pub const NAME: &'r str = "WitnessLayoutUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            WitnessLayoutUnionReader::SighashAll(item) => item.as_slice(),
            WitnessLayoutUnionReader::SighashAllOnly(item) => item.as_slice(),
            WitnessLayoutUnionReader::Otx(item) => item.as_slice(),
            WitnessLayoutUnionReader::OtxStart(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            WitnessLayoutUnionReader::SighashAll(_) => 4278190081,
            WitnessLayoutUnionReader::SighashAllOnly(_) => 4278190082,
            WitnessLayoutUnionReader::Otx(_) => 4278190083,
            WitnessLayoutUnionReader::OtxStart(_) => 4278190084,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            WitnessLayoutUnionReader::SighashAll(_) => "SighashAll",
            WitnessLayoutUnionReader::SighashAllOnly(_) => "SighashAllOnly",
            WitnessLayoutUnionReader::Otx(_) => "Otx",
            WitnessLayoutUnionReader::OtxStart(_) => "OtxStart",
        }
    }
}

//////////////////////////////////////
// Spore Actions
//////////////////////////////////////

#[derive(Clone)]
pub struct Address(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Address {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Address {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Address {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for Address {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Address::new_unchecked(v)
    }
}
impl Address {
    const DEFAULT_VALUE: [u8; 57] = [
        0, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const ITEMS_COUNT: usize = 1;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> AddressUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => Script::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> AddressReader<'r> {
        AddressReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Address {
    type Builder = AddressBuilder;
    const NAME: &'static str = "Address";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Address(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AddressReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AddressReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct AddressReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for AddressReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for AddressReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for AddressReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> AddressReader<'r> {
    pub const ITEMS_COUNT: usize = 1;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> AddressUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => ScriptReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for AddressReader<'r> {
    type Entity = Address;
    const NAME: &'static str = "AddressReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        AddressReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => ScriptReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct AddressBuilder(pub(crate) AddressUnion);
impl AddressBuilder {
    pub const ITEMS_COUNT: usize = 1;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<AddressUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for AddressBuilder {
    type Entity = Address;
    const NAME: &'static str = "AddressBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Address::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum AddressUnion {
    Script(Script),
}
#[derive(Debug, Clone, Copy)]
pub enum AddressUnionReader<'r> {
    Script(ScriptReader<'r>),
}
impl ::core::default::Default for AddressUnion {
    fn default() -> Self {
        AddressUnion::Script(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for AddressUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            AddressUnion::Script(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Script::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for AddressUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            AddressUnionReader::Script(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Script::NAME, item)
            }
        }
    }
}
impl AddressUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            AddressUnion::Script(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> AddressUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            AddressUnionReader::Script(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<Script> for AddressUnion {
    fn from(item: Script) -> Self {
        AddressUnion::Script(item)
    }
}
impl<'r> ::core::convert::From<ScriptReader<'r>> for AddressUnionReader<'r> {
    fn from(item: ScriptReader<'r>) -> Self {
        AddressUnionReader::Script(item)
    }
}
impl AddressUnion {
    pub const NAME: &'static str = "AddressUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            AddressUnion::Script(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            AddressUnion::Script(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            AddressUnion::Script(_) => 0,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            AddressUnion::Script(_) => "Script",
        }
    }
    pub fn as_reader<'r>(&'r self) -> AddressUnionReader<'r> {
        match self {
            AddressUnion::Script(item) => item.as_reader().into(),
        }
    }
}
impl<'r> AddressUnionReader<'r> {
    pub const NAME: &'r str = "AddressUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            AddressUnionReader::Script(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            AddressUnionReader::Script(_) => 0,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            AddressUnionReader::Script(_) => "Script",
        }
    }
}
#[derive(Clone)]
pub struct MintSpore(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for MintSpore {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for MintSpore {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for MintSpore {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "spore_id", self.spore_id())?;
        write!(f, ", {}: {}", "to", self.to())?;
        write!(f, ", {}: {}", "data_hash", self.data_hash())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for MintSpore {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        MintSpore::new_unchecked(v)
    }
}
impl MintSpore {
    const DEFAULT_VALUE: [u8; 137] = [
        137, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 105, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16, 0,
        0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn spore_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn to(&self) -> Address {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Address::new_unchecked(self.0.slice(start..end))
    }
    pub fn data_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Byte32::new_unchecked(self.0.slice(start..end))
        } else {
            Byte32::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> MintSporeReader<'r> {
        MintSporeReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for MintSpore {
    type Builder = MintSporeBuilder;
    const NAME: &'static str = "MintSpore";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        MintSpore(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        MintSporeReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        MintSporeReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .spore_id(self.spore_id())
            .to(self.to())
            .data_hash(self.data_hash())
    }
}
#[derive(Clone, Copy)]
pub struct MintSporeReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for MintSporeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for MintSporeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for MintSporeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "spore_id", self.spore_id())?;
        write!(f, ", {}: {}", "to", self.to())?;
        write!(f, ", {}: {}", "data_hash", self.data_hash())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> MintSporeReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn spore_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn to(&self) -> AddressReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        AddressReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn data_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Byte32Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Byte32Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for MintSporeReader<'r> {
    type Entity = MintSpore;
    const NAME: &'static str = "MintSporeReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        MintSporeReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        AddressReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Byte32Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct MintSporeBuilder {
    pub(crate) spore_id: Byte32,
    pub(crate) to: Address,
    pub(crate) data_hash: Byte32,
}
impl MintSporeBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn spore_id(mut self, v: Byte32) -> Self {
        self.spore_id = v;
        self
    }
    pub fn to(mut self, v: Address) -> Self {
        self.to = v;
        self
    }
    pub fn data_hash(mut self, v: Byte32) -> Self {
        self.data_hash = v;
        self
    }
}
impl molecule::prelude::Builder for MintSporeBuilder {
    type Entity = MintSpore;
    const NAME: &'static str = "MintSporeBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.spore_id.as_slice().len()
            + self.to.as_slice().len()
            + self.data_hash.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.spore_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.to.as_slice().len();
        offsets.push(total_size);
        total_size += self.data_hash.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.spore_id.as_slice())?;
        writer.write_all(self.to.as_slice())?;
        writer.write_all(self.data_hash.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        MintSpore::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TransferSpore(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TransferSpore {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TransferSpore {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TransferSpore {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "spore_id", self.spore_id())?;
        write!(f, ", {}: {}", "from", self.from())?;
        write!(f, ", {}: {}", "to", self.to())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for TransferSpore {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TransferSpore::new_unchecked(v)
    }
}
impl TransferSpore {
    const DEFAULT_VALUE: [u8; 162] = [
        162, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 105, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16, 0,
        0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0,
        48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn spore_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn from(&self) -> Address {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Address::new_unchecked(self.0.slice(start..end))
    }
    pub fn to(&self) -> Address {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Address::new_unchecked(self.0.slice(start..end))
        } else {
            Address::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TransferSporeReader<'r> {
        TransferSporeReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TransferSpore {
    type Builder = TransferSporeBuilder;
    const NAME: &'static str = "TransferSpore";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TransferSpore(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TransferSporeReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TransferSporeReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .spore_id(self.spore_id())
            .from(self.from())
            .to(self.to())
    }
}
#[derive(Clone, Copy)]
pub struct TransferSporeReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TransferSporeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TransferSporeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TransferSporeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "spore_id", self.spore_id())?;
        write!(f, ", {}: {}", "from", self.from())?;
        write!(f, ", {}: {}", "to", self.to())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> TransferSporeReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn spore_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn from(&self) -> AddressReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        AddressReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn to(&self) -> AddressReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            AddressReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            AddressReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TransferSporeReader<'r> {
    type Entity = TransferSpore;
    const NAME: &'static str = "TransferSporeReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TransferSporeReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        AddressReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        AddressReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TransferSporeBuilder {
    pub(crate) spore_id: Byte32,
    pub(crate) from: Address,
    pub(crate) to: Address,
}
impl TransferSporeBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn spore_id(mut self, v: Byte32) -> Self {
        self.spore_id = v;
        self
    }
    pub fn from(mut self, v: Address) -> Self {
        self.from = v;
        self
    }
    pub fn to(mut self, v: Address) -> Self {
        self.to = v;
        self
    }
}
impl molecule::prelude::Builder for TransferSporeBuilder {
    type Entity = TransferSpore;
    const NAME: &'static str = "TransferSporeBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.spore_id.as_slice().len()
            + self.from.as_slice().len()
            + self.to.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.spore_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.from.as_slice().len();
        offsets.push(total_size);
        total_size += self.to.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.spore_id.as_slice())?;
        writer.write_all(self.from.as_slice())?;
        writer.write_all(self.to.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TransferSpore::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct BurnSpore(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BurnSpore {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BurnSpore {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BurnSpore {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "spore_id", self.spore_id())?;
        write!(f, ", {}: {}", "from", self.from())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for BurnSpore {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        BurnSpore::new_unchecked(v)
    }
}
impl BurnSpore {
    const DEFAULT_VALUE: [u8; 101] = [
        101, 0, 0, 0, 12, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0, 48, 0,
        0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn spore_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn from(&self) -> Address {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Address::new_unchecked(self.0.slice(start..end))
        } else {
            Address::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BurnSporeReader<'r> {
        BurnSporeReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BurnSpore {
    type Builder = BurnSporeBuilder;
    const NAME: &'static str = "BurnSpore";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BurnSpore(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BurnSporeReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BurnSporeReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .spore_id(self.spore_id())
            .from(self.from())
    }
}
#[derive(Clone, Copy)]
pub struct BurnSporeReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BurnSporeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BurnSporeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BurnSporeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "spore_id", self.spore_id())?;
        write!(f, ", {}: {}", "from", self.from())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> BurnSporeReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn spore_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn from(&self) -> AddressReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            AddressReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            AddressReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BurnSporeReader<'r> {
    type Entity = BurnSpore;
    const NAME: &'static str = "BurnSporeReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BurnSporeReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        AddressReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct BurnSporeBuilder {
    pub(crate) spore_id: Byte32,
    pub(crate) from: Address,
}
impl BurnSporeBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn spore_id(mut self, v: Byte32) -> Self {
        self.spore_id = v;
        self
    }
    pub fn from(mut self, v: Address) -> Self {
        self.from = v;
        self
    }
}
impl molecule::prelude::Builder for BurnSporeBuilder {
    type Entity = BurnSpore;
    const NAME: &'static str = "BurnSporeBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.spore_id.as_slice().len()
            + self.from.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.spore_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.from.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.spore_id.as_slice())?;
        writer.write_all(self.from.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BurnSpore::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct MintCluster(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for MintCluster {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for MintCluster {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for MintCluster {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cluster_id", self.cluster_id())?;
        write!(f, ", {}: {}", "to", self.to())?;
        write!(f, ", {}: {}", "data_hash", self.data_hash())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for MintCluster {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        MintCluster::new_unchecked(v)
    }
}
impl MintCluster {
    const DEFAULT_VALUE: [u8; 137] = [
        137, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 105, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16, 0,
        0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cluster_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn to(&self) -> Address {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Address::new_unchecked(self.0.slice(start..end))
    }
    pub fn data_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Byte32::new_unchecked(self.0.slice(start..end))
        } else {
            Byte32::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> MintClusterReader<'r> {
        MintClusterReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for MintCluster {
    type Builder = MintClusterBuilder;
    const NAME: &'static str = "MintCluster";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        MintCluster(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        MintClusterReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        MintClusterReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .cluster_id(self.cluster_id())
            .to(self.to())
            .data_hash(self.data_hash())
    }
}
#[derive(Clone, Copy)]
pub struct MintClusterReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for MintClusterReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for MintClusterReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for MintClusterReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cluster_id", self.cluster_id())?;
        write!(f, ", {}: {}", "to", self.to())?;
        write!(f, ", {}: {}", "data_hash", self.data_hash())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> MintClusterReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cluster_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn to(&self) -> AddressReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        AddressReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn data_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Byte32Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Byte32Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for MintClusterReader<'r> {
    type Entity = MintCluster;
    const NAME: &'static str = "MintClusterReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        MintClusterReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        AddressReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Byte32Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct MintClusterBuilder {
    pub(crate) cluster_id: Byte32,
    pub(crate) to: Address,
    pub(crate) data_hash: Byte32,
}
impl MintClusterBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn cluster_id(mut self, v: Byte32) -> Self {
        self.cluster_id = v;
        self
    }
    pub fn to(mut self, v: Address) -> Self {
        self.to = v;
        self
    }
    pub fn data_hash(mut self, v: Byte32) -> Self {
        self.data_hash = v;
        self
    }
}
impl molecule::prelude::Builder for MintClusterBuilder {
    type Entity = MintCluster;
    const NAME: &'static str = "MintClusterBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.cluster_id.as_slice().len()
            + self.to.as_slice().len()
            + self.data_hash.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.cluster_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.to.as_slice().len();
        offsets.push(total_size);
        total_size += self.data_hash.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.cluster_id.as_slice())?;
        writer.write_all(self.to.as_slice())?;
        writer.write_all(self.data_hash.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        MintCluster::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TransferCluster(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TransferCluster {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TransferCluster {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TransferCluster {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cluster_id", self.cluster_id())?;
        write!(f, ", {}: {}", "from", self.from())?;
        write!(f, ", {}: {}", "to", self.to())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for TransferCluster {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TransferCluster::new_unchecked(v)
    }
}
impl TransferCluster {
    const DEFAULT_VALUE: [u8; 162] = [
        162, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 105, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16, 0,
        0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0,
        48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cluster_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn from(&self) -> Address {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Address::new_unchecked(self.0.slice(start..end))
    }
    pub fn to(&self) -> Address {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Address::new_unchecked(self.0.slice(start..end))
        } else {
            Address::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TransferClusterReader<'r> {
        TransferClusterReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TransferCluster {
    type Builder = TransferClusterBuilder;
    const NAME: &'static str = "TransferCluster";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TransferCluster(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TransferClusterReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TransferClusterReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .cluster_id(self.cluster_id())
            .from(self.from())
            .to(self.to())
    }
}
#[derive(Clone, Copy)]
pub struct TransferClusterReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TransferClusterReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TransferClusterReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TransferClusterReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cluster_id", self.cluster_id())?;
        write!(f, ", {}: {}", "from", self.from())?;
        write!(f, ", {}: {}", "to", self.to())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> TransferClusterReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cluster_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn from(&self) -> AddressReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        AddressReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn to(&self) -> AddressReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            AddressReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            AddressReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TransferClusterReader<'r> {
    type Entity = TransferCluster;
    const NAME: &'static str = "TransferClusterReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TransferClusterReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        AddressReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        AddressReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TransferClusterBuilder {
    pub(crate) cluster_id: Byte32,
    pub(crate) from: Address,
    pub(crate) to: Address,
}
impl TransferClusterBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn cluster_id(mut self, v: Byte32) -> Self {
        self.cluster_id = v;
        self
    }
    pub fn from(mut self, v: Address) -> Self {
        self.from = v;
        self
    }
    pub fn to(mut self, v: Address) -> Self {
        self.to = v;
        self
    }
}
impl molecule::prelude::Builder for TransferClusterBuilder {
    type Entity = TransferCluster;
    const NAME: &'static str = "TransferClusterBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.cluster_id.as_slice().len()
            + self.from.as_slice().len()
            + self.to.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.cluster_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.from.as_slice().len();
        offsets.push(total_size);
        total_size += self.to.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.cluster_id.as_slice())?;
        writer.write_all(self.from.as_slice())?;
        writer.write_all(self.to.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TransferCluster::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct MintProxy(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for MintProxy {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for MintProxy {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for MintProxy {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cluster_id", self.cluster_id())?;
        write!(f, ", {}: {}", "proxy_id", self.proxy_id())?;
        write!(f, ", {}: {}", "to", self.to())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for MintProxy {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        MintProxy::new_unchecked(v)
    }
}
impl MintProxy {
    const DEFAULT_VALUE: [u8; 137] = [
        137, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16,
        0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cluster_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn proxy_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn to(&self) -> Address {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Address::new_unchecked(self.0.slice(start..end))
        } else {
            Address::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> MintProxyReader<'r> {
        MintProxyReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for MintProxy {
    type Builder = MintProxyBuilder;
    const NAME: &'static str = "MintProxy";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        MintProxy(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        MintProxyReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        MintProxyReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .cluster_id(self.cluster_id())
            .proxy_id(self.proxy_id())
            .to(self.to())
    }
}
#[derive(Clone, Copy)]
pub struct MintProxyReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for MintProxyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for MintProxyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for MintProxyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cluster_id", self.cluster_id())?;
        write!(f, ", {}: {}", "proxy_id", self.proxy_id())?;
        write!(f, ", {}: {}", "to", self.to())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> MintProxyReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cluster_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proxy_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn to(&self) -> AddressReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            AddressReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            AddressReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for MintProxyReader<'r> {
    type Entity = MintProxy;
    const NAME: &'static str = "MintProxyReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        MintProxyReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        AddressReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct MintProxyBuilder {
    pub(crate) cluster_id: Byte32,
    pub(crate) proxy_id: Byte32,
    pub(crate) to: Address,
}
impl MintProxyBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn cluster_id(mut self, v: Byte32) -> Self {
        self.cluster_id = v;
        self
    }
    pub fn proxy_id(mut self, v: Byte32) -> Self {
        self.proxy_id = v;
        self
    }
    pub fn to(mut self, v: Address) -> Self {
        self.to = v;
        self
    }
}
impl molecule::prelude::Builder for MintProxyBuilder {
    type Entity = MintProxy;
    const NAME: &'static str = "MintProxyBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.cluster_id.as_slice().len()
            + self.proxy_id.as_slice().len()
            + self.to.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.cluster_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.proxy_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.to.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.cluster_id.as_slice())?;
        writer.write_all(self.proxy_id.as_slice())?;
        writer.write_all(self.to.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        MintProxy::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TransferProxy(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TransferProxy {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TransferProxy {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TransferProxy {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cluster_id", self.cluster_id())?;
        write!(f, ", {}: {}", "proxy_id", self.proxy_id())?;
        write!(f, ", {}: {}", "from", self.from())?;
        write!(f, ", {}: {}", "to", self.to())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for TransferProxy {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TransferProxy::new_unchecked(v)
    }
}
impl TransferProxy {
    const DEFAULT_VALUE: [u8; 198] = [
        198, 0, 0, 0, 20, 0, 0, 0, 52, 0, 0, 0, 84, 0, 0, 0, 141, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        53, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0,
        0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cluster_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn proxy_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn from(&self) -> Address {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Address::new_unchecked(self.0.slice(start..end))
    }
    pub fn to(&self) -> Address {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            Address::new_unchecked(self.0.slice(start..end))
        } else {
            Address::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TransferProxyReader<'r> {
        TransferProxyReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TransferProxy {
    type Builder = TransferProxyBuilder;
    const NAME: &'static str = "TransferProxy";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TransferProxy(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TransferProxyReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TransferProxyReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .cluster_id(self.cluster_id())
            .proxy_id(self.proxy_id())
            .from(self.from())
            .to(self.to())
    }
}
#[derive(Clone, Copy)]
pub struct TransferProxyReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TransferProxyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TransferProxyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TransferProxyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cluster_id", self.cluster_id())?;
        write!(f, ", {}: {}", "proxy_id", self.proxy_id())?;
        write!(f, ", {}: {}", "from", self.from())?;
        write!(f, ", {}: {}", "to", self.to())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> TransferProxyReader<'r> {
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cluster_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proxy_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn from(&self) -> AddressReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        AddressReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn to(&self) -> AddressReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            AddressReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            AddressReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TransferProxyReader<'r> {
    type Entity = TransferProxy;
    const NAME: &'static str = "TransferProxyReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TransferProxyReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        AddressReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        AddressReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TransferProxyBuilder {
    pub(crate) cluster_id: Byte32,
    pub(crate) proxy_id: Byte32,
    pub(crate) from: Address,
    pub(crate) to: Address,
}
impl TransferProxyBuilder {
    pub const FIELD_COUNT: usize = 4;
    pub fn cluster_id(mut self, v: Byte32) -> Self {
        self.cluster_id = v;
        self
    }
    pub fn proxy_id(mut self, v: Byte32) -> Self {
        self.proxy_id = v;
        self
    }
    pub fn from(mut self, v: Address) -> Self {
        self.from = v;
        self
    }
    pub fn to(mut self, v: Address) -> Self {
        self.to = v;
        self
    }
}
impl molecule::prelude::Builder for TransferProxyBuilder {
    type Entity = TransferProxy;
    const NAME: &'static str = "TransferProxyBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.cluster_id.as_slice().len()
            + self.proxy_id.as_slice().len()
            + self.from.as_slice().len()
            + self.to.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.cluster_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.proxy_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.from.as_slice().len();
        offsets.push(total_size);
        total_size += self.to.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.cluster_id.as_slice())?;
        writer.write_all(self.proxy_id.as_slice())?;
        writer.write_all(self.from.as_slice())?;
        writer.write_all(self.to.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TransferProxy::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct BurnProxy(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BurnProxy {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BurnProxy {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BurnProxy {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cluster_id", self.cluster_id())?;
        write!(f, ", {}: {}", "proxy_id", self.proxy_id())?;
        write!(f, ", {}: {}", "from", self.from())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for BurnProxy {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        BurnProxy::new_unchecked(v)
    }
}
impl BurnProxy {
    const DEFAULT_VALUE: [u8; 137] = [
        137, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16,
        0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cluster_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn proxy_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn from(&self) -> Address {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Address::new_unchecked(self.0.slice(start..end))
        } else {
            Address::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BurnProxyReader<'r> {
        BurnProxyReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BurnProxy {
    type Builder = BurnProxyBuilder;
    const NAME: &'static str = "BurnProxy";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BurnProxy(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BurnProxyReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BurnProxyReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .cluster_id(self.cluster_id())
            .proxy_id(self.proxy_id())
            .from(self.from())
    }
}
#[derive(Clone, Copy)]
pub struct BurnProxyReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BurnProxyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BurnProxyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BurnProxyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cluster_id", self.cluster_id())?;
        write!(f, ", {}: {}", "proxy_id", self.proxy_id())?;
        write!(f, ", {}: {}", "from", self.from())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> BurnProxyReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cluster_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proxy_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn from(&self) -> AddressReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            AddressReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            AddressReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BurnProxyReader<'r> {
    type Entity = BurnProxy;
    const NAME: &'static str = "BurnProxyReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BurnProxyReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        AddressReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct BurnProxyBuilder {
    pub(crate) cluster_id: Byte32,
    pub(crate) proxy_id: Byte32,
    pub(crate) from: Address,
}
impl BurnProxyBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn cluster_id(mut self, v: Byte32) -> Self {
        self.cluster_id = v;
        self
    }
    pub fn proxy_id(mut self, v: Byte32) -> Self {
        self.proxy_id = v;
        self
    }
    pub fn from(mut self, v: Address) -> Self {
        self.from = v;
        self
    }
}
impl molecule::prelude::Builder for BurnProxyBuilder {
    type Entity = BurnProxy;
    const NAME: &'static str = "BurnProxyBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.cluster_id.as_slice().len()
            + self.proxy_id.as_slice().len()
            + self.from.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.cluster_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.proxy_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.from.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.cluster_id.as_slice())?;
        writer.write_all(self.proxy_id.as_slice())?;
        writer.write_all(self.from.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BurnProxy::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct MintAgent(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for MintAgent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for MintAgent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for MintAgent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cluster_id", self.cluster_id())?;
        write!(f, ", {}: {}", "proxy_id", self.proxy_id())?;
        write!(f, ", {}: {}", "to", self.to())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for MintAgent {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        MintAgent::new_unchecked(v)
    }
}
impl MintAgent {
    const DEFAULT_VALUE: [u8; 137] = [
        137, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16,
        0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cluster_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn proxy_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn to(&self) -> Address {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Address::new_unchecked(self.0.slice(start..end))
        } else {
            Address::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> MintAgentReader<'r> {
        MintAgentReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for MintAgent {
    type Builder = MintAgentBuilder;
    const NAME: &'static str = "MintAgent";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        MintAgent(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        MintAgentReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        MintAgentReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .cluster_id(self.cluster_id())
            .proxy_id(self.proxy_id())
            .to(self.to())
    }
}
#[derive(Clone, Copy)]
pub struct MintAgentReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for MintAgentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for MintAgentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for MintAgentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cluster_id", self.cluster_id())?;
        write!(f, ", {}: {}", "proxy_id", self.proxy_id())?;
        write!(f, ", {}: {}", "to", self.to())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> MintAgentReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cluster_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proxy_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn to(&self) -> AddressReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            AddressReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            AddressReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for MintAgentReader<'r> {
    type Entity = MintAgent;
    const NAME: &'static str = "MintAgentReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        MintAgentReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        AddressReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct MintAgentBuilder {
    pub(crate) cluster_id: Byte32,
    pub(crate) proxy_id: Byte32,
    pub(crate) to: Address,
}
impl MintAgentBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn cluster_id(mut self, v: Byte32) -> Self {
        self.cluster_id = v;
        self
    }
    pub fn proxy_id(mut self, v: Byte32) -> Self {
        self.proxy_id = v;
        self
    }
    pub fn to(mut self, v: Address) -> Self {
        self.to = v;
        self
    }
}
impl molecule::prelude::Builder for MintAgentBuilder {
    type Entity = MintAgent;
    const NAME: &'static str = "MintAgentBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.cluster_id.as_slice().len()
            + self.proxy_id.as_slice().len()
            + self.to.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.cluster_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.proxy_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.to.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.cluster_id.as_slice())?;
        writer.write_all(self.proxy_id.as_slice())?;
        writer.write_all(self.to.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        MintAgent::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TransferAgent(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TransferAgent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TransferAgent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TransferAgent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cluster_id", self.cluster_id())?;
        write!(f, ", {}: {}", "from", self.from())?;
        write!(f, ", {}: {}", "to", self.to())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for TransferAgent {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TransferAgent::new_unchecked(v)
    }
}
impl TransferAgent {
    const DEFAULT_VALUE: [u8; 162] = [
        162, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 105, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16, 0,
        0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0,
        48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cluster_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn from(&self) -> Address {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Address::new_unchecked(self.0.slice(start..end))
    }
    pub fn to(&self) -> Address {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Address::new_unchecked(self.0.slice(start..end))
        } else {
            Address::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TransferAgentReader<'r> {
        TransferAgentReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TransferAgent {
    type Builder = TransferAgentBuilder;
    const NAME: &'static str = "TransferAgent";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TransferAgent(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TransferAgentReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TransferAgentReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .cluster_id(self.cluster_id())
            .from(self.from())
            .to(self.to())
    }
}
#[derive(Clone, Copy)]
pub struct TransferAgentReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TransferAgentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TransferAgentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TransferAgentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cluster_id", self.cluster_id())?;
        write!(f, ", {}: {}", "from", self.from())?;
        write!(f, ", {}: {}", "to", self.to())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> TransferAgentReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cluster_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn from(&self) -> AddressReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        AddressReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn to(&self) -> AddressReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            AddressReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            AddressReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TransferAgentReader<'r> {
    type Entity = TransferAgent;
    const NAME: &'static str = "TransferAgentReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TransferAgentReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        AddressReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        AddressReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TransferAgentBuilder {
    pub(crate) cluster_id: Byte32,
    pub(crate) from: Address,
    pub(crate) to: Address,
}
impl TransferAgentBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn cluster_id(mut self, v: Byte32) -> Self {
        self.cluster_id = v;
        self
    }
    pub fn from(mut self, v: Address) -> Self {
        self.from = v;
        self
    }
    pub fn to(mut self, v: Address) -> Self {
        self.to = v;
        self
    }
}
impl molecule::prelude::Builder for TransferAgentBuilder {
    type Entity = TransferAgent;
    const NAME: &'static str = "TransferAgentBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.cluster_id.as_slice().len()
            + self.from.as_slice().len()
            + self.to.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.cluster_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.from.as_slice().len();
        offsets.push(total_size);
        total_size += self.to.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.cluster_id.as_slice())?;
        writer.write_all(self.from.as_slice())?;
        writer.write_all(self.to.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TransferAgent::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct BurnAgent(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BurnAgent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BurnAgent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BurnAgent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cluster_id", self.cluster_id())?;
        write!(f, ", {}: {}", "from", self.from())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for BurnAgent {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        BurnAgent::new_unchecked(v)
    }
}
impl BurnAgent {
    const DEFAULT_VALUE: [u8; 101] = [
        101, 0, 0, 0, 12, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0, 48, 0,
        0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cluster_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn from(&self) -> Address {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Address::new_unchecked(self.0.slice(start..end))
        } else {
            Address::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BurnAgentReader<'r> {
        BurnAgentReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BurnAgent {
    type Builder = BurnAgentBuilder;
    const NAME: &'static str = "BurnAgent";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BurnAgent(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BurnAgentReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BurnAgentReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .cluster_id(self.cluster_id())
            .from(self.from())
    }
}
#[derive(Clone, Copy)]
pub struct BurnAgentReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BurnAgentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BurnAgentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BurnAgentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cluster_id", self.cluster_id())?;
        write!(f, ", {}: {}", "from", self.from())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> BurnAgentReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cluster_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn from(&self) -> AddressReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            AddressReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            AddressReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BurnAgentReader<'r> {
    type Entity = BurnAgent;
    const NAME: &'static str = "BurnAgentReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BurnAgentReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        AddressReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct BurnAgentBuilder {
    pub(crate) cluster_id: Byte32,
    pub(crate) from: Address,
}
impl BurnAgentBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn cluster_id(mut self, v: Byte32) -> Self {
        self.cluster_id = v;
        self
    }
    pub fn from(mut self, v: Address) -> Self {
        self.from = v;
        self
    }
}
impl molecule::prelude::Builder for BurnAgentBuilder {
    type Entity = BurnAgent;
    const NAME: &'static str = "BurnAgentBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.cluster_id.as_slice().len()
            + self.from.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.cluster_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.from.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.cluster_id.as_slice())?;
        writer.write_all(self.from.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BurnAgent::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SporeAction(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SporeAction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SporeAction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SporeAction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for SporeAction {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        SporeAction::new_unchecked(v)
    }
}
impl SporeAction {
    const DEFAULT_VALUE: [u8; 141] = [
        0, 0, 0, 0, 137, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 105, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0,
        0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const ITEMS_COUNT: usize = 11;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> SporeActionUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => MintSpore::new_unchecked(inner).into(),
            1 => TransferSpore::new_unchecked(inner).into(),
            2 => BurnSpore::new_unchecked(inner).into(),
            3 => MintCluster::new_unchecked(inner).into(),
            4 => TransferCluster::new_unchecked(inner).into(),
            5 => MintProxy::new_unchecked(inner).into(),
            6 => TransferProxy::new_unchecked(inner).into(),
            7 => BurnProxy::new_unchecked(inner).into(),
            8 => MintAgent::new_unchecked(inner).into(),
            9 => TransferAgent::new_unchecked(inner).into(),
            10 => BurnAgent::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> SporeActionReader<'r> {
        SporeActionReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SporeAction {
    type Builder = SporeActionBuilder;
    const NAME: &'static str = "SporeAction";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SporeAction(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SporeActionReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SporeActionReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct SporeActionReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SporeActionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SporeActionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SporeActionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> SporeActionReader<'r> {
    pub const ITEMS_COUNT: usize = 11;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> SporeActionUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => MintSporeReader::new_unchecked(inner).into(),
            1 => TransferSporeReader::new_unchecked(inner).into(),
            2 => BurnSporeReader::new_unchecked(inner).into(),
            3 => MintClusterReader::new_unchecked(inner).into(),
            4 => TransferClusterReader::new_unchecked(inner).into(),
            5 => MintProxyReader::new_unchecked(inner).into(),
            6 => TransferProxyReader::new_unchecked(inner).into(),
            7 => BurnProxyReader::new_unchecked(inner).into(),
            8 => MintAgentReader::new_unchecked(inner).into(),
            9 => TransferAgentReader::new_unchecked(inner).into(),
            10 => BurnAgentReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SporeActionReader<'r> {
    type Entity = SporeAction;
    const NAME: &'static str = "SporeActionReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SporeActionReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => MintSporeReader::verify(inner_slice, compatible),
            1 => TransferSporeReader::verify(inner_slice, compatible),
            2 => BurnSporeReader::verify(inner_slice, compatible),
            3 => MintClusterReader::verify(inner_slice, compatible),
            4 => TransferClusterReader::verify(inner_slice, compatible),
            5 => MintProxyReader::verify(inner_slice, compatible),
            6 => TransferProxyReader::verify(inner_slice, compatible),
            7 => BurnProxyReader::verify(inner_slice, compatible),
            8 => MintAgentReader::verify(inner_slice, compatible),
            9 => TransferAgentReader::verify(inner_slice, compatible),
            10 => BurnAgentReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct SporeActionBuilder(pub(crate) SporeActionUnion);
impl SporeActionBuilder {
    pub const ITEMS_COUNT: usize = 11;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<SporeActionUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for SporeActionBuilder {
    type Entity = SporeAction;
    const NAME: &'static str = "SporeActionBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SporeAction::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum SporeActionUnion {
    MintSpore(MintSpore),
    TransferSpore(TransferSpore),
    BurnSpore(BurnSpore),
    MintCluster(MintCluster),
    TransferCluster(TransferCluster),
    MintProxy(MintProxy),
    TransferProxy(TransferProxy),
    BurnProxy(BurnProxy),
    MintAgent(MintAgent),
    TransferAgent(TransferAgent),
    BurnAgent(BurnAgent),
}
#[derive(Debug, Clone, Copy)]
pub enum SporeActionUnionReader<'r> {
    MintSpore(MintSporeReader<'r>),
    TransferSpore(TransferSporeReader<'r>),
    BurnSpore(BurnSporeReader<'r>),
    MintCluster(MintClusterReader<'r>),
    TransferCluster(TransferClusterReader<'r>),
    MintProxy(MintProxyReader<'r>),
    TransferProxy(TransferProxyReader<'r>),
    BurnProxy(BurnProxyReader<'r>),
    MintAgent(MintAgentReader<'r>),
    TransferAgent(TransferAgentReader<'r>),
    BurnAgent(BurnAgentReader<'r>),
}
impl ::core::default::Default for SporeActionUnion {
    fn default() -> Self {
        SporeActionUnion::MintSpore(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for SporeActionUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            SporeActionUnion::MintSpore(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, MintSpore::NAME, item)
            }
            SporeActionUnion::TransferSpore(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TransferSpore::NAME, item)
            }
            SporeActionUnion::BurnSpore(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, BurnSpore::NAME, item)
            }
            SporeActionUnion::MintCluster(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, MintCluster::NAME, item)
            }
            SporeActionUnion::TransferCluster(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TransferCluster::NAME, item)
            }
            SporeActionUnion::MintProxy(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, MintProxy::NAME, item)
            }
            SporeActionUnion::TransferProxy(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TransferProxy::NAME, item)
            }
            SporeActionUnion::BurnProxy(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, BurnProxy::NAME, item)
            }
            SporeActionUnion::MintAgent(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, MintAgent::NAME, item)
            }
            SporeActionUnion::TransferAgent(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TransferAgent::NAME, item)
            }
            SporeActionUnion::BurnAgent(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, BurnAgent::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for SporeActionUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            SporeActionUnionReader::MintSpore(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, MintSpore::NAME, item)
            }
            SporeActionUnionReader::TransferSpore(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TransferSpore::NAME, item)
            }
            SporeActionUnionReader::BurnSpore(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, BurnSpore::NAME, item)
            }
            SporeActionUnionReader::MintCluster(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, MintCluster::NAME, item)
            }
            SporeActionUnionReader::TransferCluster(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TransferCluster::NAME, item)
            }
            SporeActionUnionReader::MintProxy(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, MintProxy::NAME, item)
            }
            SporeActionUnionReader::TransferProxy(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TransferProxy::NAME, item)
            }
            SporeActionUnionReader::BurnProxy(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, BurnProxy::NAME, item)
            }
            SporeActionUnionReader::MintAgent(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, MintAgent::NAME, item)
            }
            SporeActionUnionReader::TransferAgent(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TransferAgent::NAME, item)
            }
            SporeActionUnionReader::BurnAgent(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, BurnAgent::NAME, item)
            }
        }
    }
}
impl SporeActionUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            SporeActionUnion::MintSpore(ref item) => write!(f, "{}", item),
            SporeActionUnion::TransferSpore(ref item) => write!(f, "{}", item),
            SporeActionUnion::BurnSpore(ref item) => write!(f, "{}", item),
            SporeActionUnion::MintCluster(ref item) => write!(f, "{}", item),
            SporeActionUnion::TransferCluster(ref item) => write!(f, "{}", item),
            SporeActionUnion::MintProxy(ref item) => write!(f, "{}", item),
            SporeActionUnion::TransferProxy(ref item) => write!(f, "{}", item),
            SporeActionUnion::BurnProxy(ref item) => write!(f, "{}", item),
            SporeActionUnion::MintAgent(ref item) => write!(f, "{}", item),
            SporeActionUnion::TransferAgent(ref item) => write!(f, "{}", item),
            SporeActionUnion::BurnAgent(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> SporeActionUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            SporeActionUnionReader::MintSpore(ref item) => write!(f, "{}", item),
            SporeActionUnionReader::TransferSpore(ref item) => write!(f, "{}", item),
            SporeActionUnionReader::BurnSpore(ref item) => write!(f, "{}", item),
            SporeActionUnionReader::MintCluster(ref item) => write!(f, "{}", item),
            SporeActionUnionReader::TransferCluster(ref item) => write!(f, "{}", item),
            SporeActionUnionReader::MintProxy(ref item) => write!(f, "{}", item),
            SporeActionUnionReader::TransferProxy(ref item) => write!(f, "{}", item),
            SporeActionUnionReader::BurnProxy(ref item) => write!(f, "{}", item),
            SporeActionUnionReader::MintAgent(ref item) => write!(f, "{}", item),
            SporeActionUnionReader::TransferAgent(ref item) => write!(f, "{}", item),
            SporeActionUnionReader::BurnAgent(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<MintSpore> for SporeActionUnion {
    fn from(item: MintSpore) -> Self {
        SporeActionUnion::MintSpore(item)
    }
}
impl ::core::convert::From<TransferSpore> for SporeActionUnion {
    fn from(item: TransferSpore) -> Self {
        SporeActionUnion::TransferSpore(item)
    }
}
impl ::core::convert::From<BurnSpore> for SporeActionUnion {
    fn from(item: BurnSpore) -> Self {
        SporeActionUnion::BurnSpore(item)
    }
}
impl ::core::convert::From<MintCluster> for SporeActionUnion {
    fn from(item: MintCluster) -> Self {
        SporeActionUnion::MintCluster(item)
    }
}
impl ::core::convert::From<TransferCluster> for SporeActionUnion {
    fn from(item: TransferCluster) -> Self {
        SporeActionUnion::TransferCluster(item)
    }
}
impl ::core::convert::From<MintProxy> for SporeActionUnion {
    fn from(item: MintProxy) -> Self {
        SporeActionUnion::MintProxy(item)
    }
}
impl ::core::convert::From<TransferProxy> for SporeActionUnion {
    fn from(item: TransferProxy) -> Self {
        SporeActionUnion::TransferProxy(item)
    }
}
impl ::core::convert::From<BurnProxy> for SporeActionUnion {
    fn from(item: BurnProxy) -> Self {
        SporeActionUnion::BurnProxy(item)
    }
}
impl ::core::convert::From<MintAgent> for SporeActionUnion {
    fn from(item: MintAgent) -> Self {
        SporeActionUnion::MintAgent(item)
    }
}
impl ::core::convert::From<TransferAgent> for SporeActionUnion {
    fn from(item: TransferAgent) -> Self {
        SporeActionUnion::TransferAgent(item)
    }
}
impl ::core::convert::From<BurnAgent> for SporeActionUnion {
    fn from(item: BurnAgent) -> Self {
        SporeActionUnion::BurnAgent(item)
    }
}
impl<'r> ::core::convert::From<MintSporeReader<'r>> for SporeActionUnionReader<'r> {
    fn from(item: MintSporeReader<'r>) -> Self {
        SporeActionUnionReader::MintSpore(item)
    }
}
impl<'r> ::core::convert::From<TransferSporeReader<'r>> for SporeActionUnionReader<'r> {
    fn from(item: TransferSporeReader<'r>) -> Self {
        SporeActionUnionReader::TransferSpore(item)
    }
}
impl<'r> ::core::convert::From<BurnSporeReader<'r>> for SporeActionUnionReader<'r> {
    fn from(item: BurnSporeReader<'r>) -> Self {
        SporeActionUnionReader::BurnSpore(item)
    }
}
impl<'r> ::core::convert::From<MintClusterReader<'r>> for SporeActionUnionReader<'r> {
    fn from(item: MintClusterReader<'r>) -> Self {
        SporeActionUnionReader::MintCluster(item)
    }
}
impl<'r> ::core::convert::From<TransferClusterReader<'r>> for SporeActionUnionReader<'r> {
    fn from(item: TransferClusterReader<'r>) -> Self {
        SporeActionUnionReader::TransferCluster(item)
    }
}
impl<'r> ::core::convert::From<MintProxyReader<'r>> for SporeActionUnionReader<'r> {
    fn from(item: MintProxyReader<'r>) -> Self {
        SporeActionUnionReader::MintProxy(item)
    }
}
impl<'r> ::core::convert::From<TransferProxyReader<'r>> for SporeActionUnionReader<'r> {
    fn from(item: TransferProxyReader<'r>) -> Self {
        SporeActionUnionReader::TransferProxy(item)
    }
}
impl<'r> ::core::convert::From<BurnProxyReader<'r>> for SporeActionUnionReader<'r> {
    fn from(item: BurnProxyReader<'r>) -> Self {
        SporeActionUnionReader::BurnProxy(item)
    }
}
impl<'r> ::core::convert::From<MintAgentReader<'r>> for SporeActionUnionReader<'r> {
    fn from(item: MintAgentReader<'r>) -> Self {
        SporeActionUnionReader::MintAgent(item)
    }
}
impl<'r> ::core::convert::From<TransferAgentReader<'r>> for SporeActionUnionReader<'r> {
    fn from(item: TransferAgentReader<'r>) -> Self {
        SporeActionUnionReader::TransferAgent(item)
    }
}
impl<'r> ::core::convert::From<BurnAgentReader<'r>> for SporeActionUnionReader<'r> {
    fn from(item: BurnAgentReader<'r>) -> Self {
        SporeActionUnionReader::BurnAgent(item)
    }
}
impl SporeActionUnion {
    pub const NAME: &'static str = "SporeActionUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            SporeActionUnion::MintSpore(item) => item.as_bytes(),
            SporeActionUnion::TransferSpore(item) => item.as_bytes(),
            SporeActionUnion::BurnSpore(item) => item.as_bytes(),
            SporeActionUnion::MintCluster(item) => item.as_bytes(),
            SporeActionUnion::TransferCluster(item) => item.as_bytes(),
            SporeActionUnion::MintProxy(item) => item.as_bytes(),
            SporeActionUnion::TransferProxy(item) => item.as_bytes(),
            SporeActionUnion::BurnProxy(item) => item.as_bytes(),
            SporeActionUnion::MintAgent(item) => item.as_bytes(),
            SporeActionUnion::TransferAgent(item) => item.as_bytes(),
            SporeActionUnion::BurnAgent(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            SporeActionUnion::MintSpore(item) => item.as_slice(),
            SporeActionUnion::TransferSpore(item) => item.as_slice(),
            SporeActionUnion::BurnSpore(item) => item.as_slice(),
            SporeActionUnion::MintCluster(item) => item.as_slice(),
            SporeActionUnion::TransferCluster(item) => item.as_slice(),
            SporeActionUnion::MintProxy(item) => item.as_slice(),
            SporeActionUnion::TransferProxy(item) => item.as_slice(),
            SporeActionUnion::BurnProxy(item) => item.as_slice(),
            SporeActionUnion::MintAgent(item) => item.as_slice(),
            SporeActionUnion::TransferAgent(item) => item.as_slice(),
            SporeActionUnion::BurnAgent(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            SporeActionUnion::MintSpore(_) => 0,
            SporeActionUnion::TransferSpore(_) => 1,
            SporeActionUnion::BurnSpore(_) => 2,
            SporeActionUnion::MintCluster(_) => 3,
            SporeActionUnion::TransferCluster(_) => 4,
            SporeActionUnion::MintProxy(_) => 5,
            SporeActionUnion::TransferProxy(_) => 6,
            SporeActionUnion::BurnProxy(_) => 7,
            SporeActionUnion::MintAgent(_) => 8,
            SporeActionUnion::TransferAgent(_) => 9,
            SporeActionUnion::BurnAgent(_) => 10,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            SporeActionUnion::MintSpore(_) => "MintSpore",
            SporeActionUnion::TransferSpore(_) => "TransferSpore",
            SporeActionUnion::BurnSpore(_) => "BurnSpore",
            SporeActionUnion::MintCluster(_) => "MintCluster",
            SporeActionUnion::TransferCluster(_) => "TransferCluster",
            SporeActionUnion::MintProxy(_) => "MintProxy",
            SporeActionUnion::TransferProxy(_) => "TransferProxy",
            SporeActionUnion::BurnProxy(_) => "BurnProxy",
            SporeActionUnion::MintAgent(_) => "MintAgent",
            SporeActionUnion::TransferAgent(_) => "TransferAgent",
            SporeActionUnion::BurnAgent(_) => "BurnAgent",
        }
    }
    pub fn as_reader<'r>(&'r self) -> SporeActionUnionReader<'r> {
        match self {
            SporeActionUnion::MintSpore(item) => item.as_reader().into(),
            SporeActionUnion::TransferSpore(item) => item.as_reader().into(),
            SporeActionUnion::BurnSpore(item) => item.as_reader().into(),
            SporeActionUnion::MintCluster(item) => item.as_reader().into(),
            SporeActionUnion::TransferCluster(item) => item.as_reader().into(),
            SporeActionUnion::MintProxy(item) => item.as_reader().into(),
            SporeActionUnion::TransferProxy(item) => item.as_reader().into(),
            SporeActionUnion::BurnProxy(item) => item.as_reader().into(),
            SporeActionUnion::MintAgent(item) => item.as_reader().into(),
            SporeActionUnion::TransferAgent(item) => item.as_reader().into(),
            SporeActionUnion::BurnAgent(item) => item.as_reader().into(),
        }
    }
}
impl<'r> SporeActionUnionReader<'r> {
    pub const NAME: &'r str = "SporeActionUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            SporeActionUnionReader::MintSpore(item) => item.as_slice(),
            SporeActionUnionReader::TransferSpore(item) => item.as_slice(),
            SporeActionUnionReader::BurnSpore(item) => item.as_slice(),
            SporeActionUnionReader::MintCluster(item) => item.as_slice(),
            SporeActionUnionReader::TransferCluster(item) => item.as_slice(),
            SporeActionUnionReader::MintProxy(item) => item.as_slice(),
            SporeActionUnionReader::TransferProxy(item) => item.as_slice(),
            SporeActionUnionReader::BurnProxy(item) => item.as_slice(),
            SporeActionUnionReader::MintAgent(item) => item.as_slice(),
            SporeActionUnionReader::TransferAgent(item) => item.as_slice(),
            SporeActionUnionReader::BurnAgent(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            SporeActionUnionReader::MintSpore(_) => 0,
            SporeActionUnionReader::TransferSpore(_) => 1,
            SporeActionUnionReader::BurnSpore(_) => 2,
            SporeActionUnionReader::MintCluster(_) => 3,
            SporeActionUnionReader::TransferCluster(_) => 4,
            SporeActionUnionReader::MintProxy(_) => 5,
            SporeActionUnionReader::TransferProxy(_) => 6,
            SporeActionUnionReader::BurnProxy(_) => 7,
            SporeActionUnionReader::MintAgent(_) => 8,
            SporeActionUnionReader::TransferAgent(_) => 9,
            SporeActionUnionReader::BurnAgent(_) => 10,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            SporeActionUnionReader::MintSpore(_) => "MintSpore",
            SporeActionUnionReader::TransferSpore(_) => "TransferSpore",
            SporeActionUnionReader::BurnSpore(_) => "BurnSpore",
            SporeActionUnionReader::MintCluster(_) => "MintCluster",
            SporeActionUnionReader::TransferCluster(_) => "TransferCluster",
            SporeActionUnionReader::MintProxy(_) => "MintProxy",
            SporeActionUnionReader::TransferProxy(_) => "TransferProxy",
            SporeActionUnionReader::BurnProxy(_) => "BurnProxy",
            SporeActionUnionReader::MintAgent(_) => "MintAgent",
            SporeActionUnionReader::TransferAgent(_) => "TransferAgent",
            SporeActionUnionReader::BurnAgent(_) => "BurnAgent",
        }
    }
}

//////////////////////////////////////
// Spore Structs
//////////////////////////////////////

#[derive(Clone)]
pub struct ClusterDataV2(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ClusterDataV2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ClusterDataV2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ClusterDataV2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "name", self.name())?;
        write!(f, ", {}: {}", "description", self.description())?;
        write!(f, ", {}: {}", "mutant_id", self.mutant_id())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ClusterDataV2 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        ClusterDataV2::new_unchecked(v)
    }
}
impl ClusterDataV2 {
    const DEFAULT_VALUE: [u8; 24] = [
        24, 0, 0, 0, 16, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn name(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }
    pub fn description(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }
    pub fn mutant_id(&self) -> BytesOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            BytesOpt::new_unchecked(self.0.slice(start..end))
        } else {
            BytesOpt::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ClusterDataV2Reader<'r> {
        ClusterDataV2Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ClusterDataV2 {
    type Builder = ClusterDataV2Builder;
    const NAME: &'static str = "ClusterDataV2";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ClusterDataV2(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ClusterDataV2Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ClusterDataV2Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .name(self.name())
            .description(self.description())
            .mutant_id(self.mutant_id())
    }
}
#[derive(Clone, Copy)]
pub struct ClusterDataV2Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ClusterDataV2Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ClusterDataV2Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ClusterDataV2Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "name", self.name())?;
        write!(f, ", {}: {}", "description", self.description())?;
        write!(f, ", {}: {}", "mutant_id", self.mutant_id())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ClusterDataV2Reader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn name(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn description(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn mutant_id(&self) -> BytesOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            BytesOptReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesOptReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ClusterDataV2Reader<'r> {
    type Entity = ClusterDataV2;
    const NAME: &'static str = "ClusterDataV2Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ClusterDataV2Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        BytesReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        BytesReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        BytesOptReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct ClusterDataV2Builder {
    pub(crate) name: Bytes,
    pub(crate) description: Bytes,
    pub(crate) mutant_id: BytesOpt,
}
impl ClusterDataV2Builder {
    pub const FIELD_COUNT: usize = 3;
    pub fn name(mut self, v: Bytes) -> Self {
        self.name = v;
        self
    }
    pub fn description(mut self, v: Bytes) -> Self {
        self.description = v;
        self
    }
    pub fn mutant_id(mut self, v: BytesOpt) -> Self {
        self.mutant_id = v;
        self
    }
}
impl molecule::prelude::Builder for ClusterDataV2Builder {
    type Entity = ClusterDataV2;
    const NAME: &'static str = "ClusterDataV2Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.name.as_slice().len()
            + self.description.as_slice().len()
            + self.mutant_id.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.name.as_slice().len();
        offsets.push(total_size);
        total_size += self.description.as_slice().len();
        offsets.push(total_size);
        total_size += self.mutant_id.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.name.as_slice())?;
        writer.write_all(self.description.as_slice())?;
        writer.write_all(self.mutant_id.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ClusterDataV2::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SporeData(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SporeData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SporeData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SporeData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "content_type", self.content_type())?;
        write!(f, ", {}: {}", "content", self.content())?;
        write!(f, ", {}: {}", "cluster_id", self.cluster_id())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for SporeData {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        SporeData::new_unchecked(v)
    }
}
impl SporeData {
    const DEFAULT_VALUE: [u8; 24] = [
        24, 0, 0, 0, 16, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn content_type(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }
    pub fn content(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }
    pub fn cluster_id(&self) -> BytesOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            BytesOpt::new_unchecked(self.0.slice(start..end))
        } else {
            BytesOpt::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> SporeDataReader<'r> {
        SporeDataReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SporeData {
    type Builder = SporeDataBuilder;
    const NAME: &'static str = "SporeData";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SporeData(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SporeDataReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SporeDataReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .content_type(self.content_type())
            .content(self.content())
            .cluster_id(self.cluster_id())
    }
}
#[derive(Clone, Copy)]
pub struct SporeDataReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SporeDataReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SporeDataReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SporeDataReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "content_type", self.content_type())?;
        write!(f, ", {}: {}", "content", self.content())?;
        write!(f, ", {}: {}", "cluster_id", self.cluster_id())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> SporeDataReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn content_type(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn content(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn cluster_id(&self) -> BytesOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            BytesOptReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesOptReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SporeDataReader<'r> {
    type Entity = SporeData;
    const NAME: &'static str = "SporeDataReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SporeDataReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        BytesReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        BytesReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        BytesOptReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct SporeDataBuilder {
    pub(crate) content_type: Bytes,
    pub(crate) content: Bytes,
    pub(crate) cluster_id: BytesOpt,
}
impl SporeDataBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn content_type(mut self, v: Bytes) -> Self {
        self.content_type = v;
        self
    }
    pub fn content(mut self, v: Bytes) -> Self {
        self.content = v;
        self
    }
    pub fn cluster_id(mut self, v: BytesOpt) -> Self {
        self.cluster_id = v;
        self
    }
}
impl molecule::prelude::Builder for SporeDataBuilder {
    type Entity = SporeData;
    const NAME: &'static str = "SporeDataBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.content_type.as_slice().len()
            + self.content.as_slice().len()
            + self.cluster_id.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.content_type.as_slice().len();
        offsets.push(total_size);
        total_size += self.content.as_slice().len();
        offsets.push(total_size);
        total_size += self.cluster_id.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.content_type.as_slice())?;
        writer.write_all(self.content.as_slice())?;
        writer.write_all(self.cluster_id.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SporeData::new_unchecked(inner.into())
    }
}


================================================
File: calculate/src/simulation/mod.rs
================================================
mod operation;
mod rpc;

#[cfg(not(target_arch = "wasm32"))]
mod simulator;

pub use operation::*;
pub use rpc::*;

#[cfg(not(target_arch = "wasm32"))]
pub use simulator::*;


================================================
File: calculate/src/simulation/operation.rs
================================================
use std::{fs, path::PathBuf};

use async_trait::async_trait;
use ckb_hash::blake2b_256;
use ckb_types::{
    core::{Capacity, DepType, HeaderView},
    packed::{CellOutput, Header, RawHeader},
    prelude::{Builder, Entity, IntoHeaderView, Pack, Unpack},
    H256,
};
use eyre::Result;

use crate::{
    operation::{Log, Operation},
    rpc::{Network, RPC},
    skeleton::{CellDepEx, CellInputEx, ScriptEx, TransactionSkeleton, TYPE_ID_CODE_HASH},
};

pub use ckb_always_success_script::ALWAYS_SUCCESS;
use ckb_types::{
    core::ScriptHashType,
    packed::{CellDep, CellInput, OutPoint, Script},
};
use rand::Rng;

pub fn random_hash() -> [u8; 32] {
    let mut rng = rand::thread_rng();
    let mut buf = [0u8; 32];
    rng.fill(&mut buf);
    buf
}

pub fn fake_outpoint() -> OutPoint {
    OutPoint::new(random_hash().pack(), 0)
}

pub fn fake_input() -> CellInput {
    CellInput::new(fake_outpoint(), 0)
}

pub fn always_success_script(args: Vec<u8>) -> Script {
    Script::new_builder()
        .code_hash(blake2b_256(ALWAYS_SUCCESS).pack())
        .hash_type(ScriptHashType::Data1.into())
        .args(args.pack())
        .build()
}

pub fn fake_header_view(block_number: u64, timestamp: u64, epoch: u64) -> HeaderView {
    let header = RawHeader::new_builder()
        .number(block_number.pack())
        .timestamp(timestamp.pack())
        .epoch(epoch.pack())
        .build();
    Header::new_builder().raw(header).build().into_view()
}

pub const ALWAYS_SUCCESS_NAME: &str = "always_success";

/// Add a custom contract celldep to the transaction skeleton
pub struct AddFakeContractCelldep {
    pub name: String,
    pub contract_data: Vec<u8>,
    pub type_id_args: Option<H256>,
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddFakeContractCelldep {
    async fn run(
        self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        _: &mut Log,
    ) -> Result<()> {
        if rpc.network() != Network::Fake {
            return Err(eyre::eyre!("only support fake network"));
        }
        let celldep_out_point = fake_outpoint();
        let celldep = CellDep::new_builder()
            .out_point(celldep_out_point)
            .dep_type(DepType::Code.into())
            .build();
        let mut output = CellOutput::new_builder();
        if let Some(args) = self.type_id_args {
            let type_script = Script::new_builder()
                .code_hash(TYPE_ID_CODE_HASH.pack())
                .hash_type(ScriptHashType::Type.into())
                .args(args.as_bytes().pack())
                .build();
            output = output.type_(Some(type_script).pack());
        }
        skeleton.celldep(CellDepEx::new(
            self.name,
            celldep,
            output.build(),
            Some(self.contract_data),
        ));
        Ok(())
    }
}

/// Add a custom contract celldep to the transaction skeleton by loading compiled native contract
pub struct AddFakeContractCelldepByName {
    pub contract: String,
    pub type_id_args: Option<H256>,
    pub contract_binary_path: String,
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddFakeContractCelldepByName {
    async fn run(
        self: Box<Self>,
        rpc: &T,
        skeleton: &mut TransactionSkeleton,
        log: &mut Log,
    ) -> Result<()> {
        let contract_path = PathBuf::new()
            .join(self.contract_binary_path)
            .join(&self.contract);
        let contract_data = fs::read(contract_path)?;
        Box::new(AddFakeContractCelldep {
            name: self.contract,
            contract_data,
            type_id_args: self.type_id_args,
        })
        .run(rpc, skeleton, log)
        .await
    }
}

/// Add always success celldep to the transaction skeleton
pub struct AddFakeAlwaysSuccessCelldep {}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddFakeAlwaysSuccessCelldep {
    async fn run(
        self: Box<Self>,
        _: &T,
        skeleton: &mut TransactionSkeleton,
        _: &mut Log,
    ) -> Result<()> {
        let always_success_out_point = fake_outpoint();
        let celldep = CellDep::new_builder()
            .out_point(always_success_out_point)
            .dep_type(DepType::Code.into())
            .build();
        skeleton.celldep(CellDepEx::new(
            ALWAYS_SUCCESS_NAME.to_string(),
            celldep,
            CellOutput::default(),
            Some(ALWAYS_SUCCESS.to_vec()),
        ));
        Ok(())
    }
}

/// Add a custom cell input to the transaction skeleton, which has primary and second scripts
pub struct AddFakeInputCell {
    pub lock_script: ScriptEx,
    pub type_script: Option<ScriptEx>,
    pub data: Vec<u8>,
    pub capacity: u64,
    pub absolute_capacity: bool,
}

#[async_trait(?Send)]
impl<T: RPC> Operation<T> for AddFakeInputCell {
    async fn run(
        self: Box<Self>,
        _: &T,
        skeleton: &mut TransactionSkeleton,
        _: &mut Log,
    ) -> Result<()> {
        let primary_script = self.lock_script.to_script(skeleton)?;
        let second_script = if let Some(second) = self.type_script {
            Some(second.to_script(skeleton)?)
        } else {
            None
        };
        let output = if self.absolute_capacity {
            CellOutput::new_builder()
                .lock(primary_script)
                .type_(second_script.pack())
                .capacity(self.capacity.pack())
                .build()
        } else {
            let output = CellOutput::new_builder()
                .lock(primary_script)
                .type_(second_script.pack())
                .build_exact_capacity(Capacity::bytes(self.data.len())?)?;
            let minimal_capacity: u64 = output.capacity().unpack();
            output
                .as_builder()
                .capacity((minimal_capacity + self.capacity).pack())
                .build()
        };
        skeleton
            .input(CellInputEx::new(fake_input(), output, Some(self.data)))?
            .witness(Default::default());
        Ok(())
    }
}


================================================
File: calculate/src/simulation/rpc.rs
================================================
use std::collections::HashMap;

use ckb_jsonrpc_types::{
    BlockNumber, BlockView, CellData, CellInfo, CellWithStatus, HeaderView, JsonBytes, OutPoint,
    OutputsValidator, Status, Transaction, TransactionWithStatusResponse, TxPoolInfo, TxStatus,
};
use ckb_types::{core, packed, prelude::Unpack, H256};
use eyre::eyre;

use crate::{
    indexer::{Cell, Pagination, ScriptType, SearchKey, SearchMode},
    rpc::{Rpc, RPC},
    skeleton::CellOutputEx,
};

#[derive(Default, Clone)]
pub struct FakeProvider {
    pub fake_cells: Vec<(OutPoint, CellOutputEx)>,
    pub fake_headers: HashMap<H256, HeaderView>,
    pub fake_outpoint_headers: HashMap<OutPoint, core::HeaderView>,
    pub fake_transaction_status: HashMap<H256, TxStatus>,
    pub fake_feerate: u64,
    pub fake_tipnumber: u64,
    pub fate_tipheader: HeaderView,
}

fn indexer_cell(out_point: &OutPoint, cell: &CellOutputEx) -> Cell {
    Cell {
        block_number: 0.into(),
        out_point: out_point.clone(),
        output: cell.output.clone().into(),
        tx_index: 0.into(),
        output_data: Some(JsonBytes::from_vec(cell.data.clone())),
    }
}

fn script_prefix_equal(a: Option<&packed::Script>, b: Option<&packed::Script>) -> bool {
    if let (Some(a), Some(b)) = (a, b) {
        a.code_hash() == b.code_hash()
            && a.hash_type() == b.hash_type()
            && a.args().raw_data().starts_with(&b.args().raw_data())
    } else {
        false
    }
}

impl FakeProvider {
    fn get_cells_by_search_key(
        &self,
        search_key: SearchKey,
        limit: usize,
        cursor: Option<JsonBytes>,
    ) -> (Vec<Cell>, usize) {
        if limit == 0 {
            return (vec![], 0);
        }
        let mut offset = cursor
            .map(|v| usize::from_le_bytes(v.into_bytes().to_vec().try_into().unwrap()))
            .unwrap_or_default();
        let mut objects = vec![];
        for (out_point, cell) in self.fake_cells.iter().skip(offset) {
            offset += 1;
            let (primary_script, script_a, secondary_script, script_b) =
                match search_key.script_type {
                    ScriptType::Lock => {
                        let primary_script: packed::Script = search_key.script.clone().into();
                        let secondary_script: Option<Option<packed::Script>> =
                            search_key.filter.clone().map(|v| v.script.map(Into::into));
                        let lock_script = cell.lock_script();
                        let type_script = cell.type_script();
                        (
                            primary_script,
                            Some(lock_script),
                            secondary_script,
                            type_script,
                        )
                    }
                    ScriptType::Type => {
                        let primary_script: packed::Script = search_key.script.clone().into();
                        let secondary_script: Option<Option<packed::Script>> =
                            search_key.filter.clone().map(|v| v.script.map(Into::into));
                        let lock_script = cell.lock_script();
                        let type_script = cell.type_script();
                        (
                            primary_script,
                            type_script,
                            secondary_script,
                            Some(lock_script),
                        )
                    }
                };
            match search_key.script_search_mode {
                Some(SearchMode::Exact) | None => {
                    if Some(primary_script) == script_a {
                        if let Some(script) = secondary_script {
                            if script != script_b {
                                continue;
                            }
                        }
                        objects.push(indexer_cell(out_point, cell));
                    }
                }
                Some(SearchMode::Prefix) => {
                    if script_prefix_equal(script_a.as_ref(), Some(&primary_script)) {
                        if let Some(script) = secondary_script {
                            if !script_prefix_equal(script_b.as_ref(), script.as_ref()) {
                                continue;
                            }
                        }
                        objects.push(indexer_cell(out_point, cell))
                    }
                }
                Some(SearchMode::Partial) => {
                    panic!("partial search mode is not supported");
                }
            }
            if objects.len() >= limit {
                break;
            }
        }
        (objects, offset)
    }

    fn get_cell_by_outpoint(&self, out_point: &OutPoint) -> Option<CellWithStatus> {
        let (_, cell) = self
            .fake_cells
            .iter()
            .find(|(value, _)| value == out_point)?;
        let cell_with_status = CellWithStatus {
            cell: Some(CellInfo {
                data: Some(CellData {
                    content: JsonBytes::from_vec(cell.data.clone()),
                    hash: H256::default(),
                }),
                output: cell.output.clone().into(),
            }),
            status: "live".to_owned(),
        };
        Some(cell_with_status)
    }

    fn get_header_by_hash(&self, block_hash: &H256) -> Option<HeaderView> {
        self.fake_headers.get(block_hash).cloned()
    }

    fn get_header_by_number(&self, block_number: u64) -> Option<HeaderView> {
        self.fake_headers
            .iter()
            .find(|(_, header)| header.inner.number == block_number.into())
            .map(|(_, header)| header.clone())
    }

    fn get_transaction_by_hash(&self, hash: &H256) -> Option<TransactionWithStatusResponse> {
        self.fake_transaction_status
            .get(hash)
            .map(|status| TransactionWithStatusResponse {
                transaction: None,
                cycles: None,
                time_added_to_pool: None,
                fee: None,
                min_replace_fee: None,
                tx_status: status.clone(),
            })
    }
}

#[derive(Clone, Default)]
pub struct FakeRpcClient {
    pub fake_provider: FakeProvider,
}

impl FakeRpcClient {
    pub fn set_fake_tip(&mut self, tip_number: u64, tip_header: HeaderView) -> &mut Self {
        self.fake_provider.fake_tipnumber = tip_number;
        self.fake_provider.fate_tipheader = tip_header;
        self
    }

    pub fn insert_fake_cell(
        &mut self,
        out_point: packed::OutPoint,
        cell: CellOutputEx,
        header: Option<core::HeaderView>,
    ) -> &mut Self {
        let out_point = out_point.into();
        if self
            .fake_provider
            .fake_cells
            .iter()
            .any(|(v, _)| v == &out_point)
        {
            return self;
        }
        self.fake_provider
            .fake_cells
            .push((out_point.clone(), cell));
        if let Some(header) = header {
            let tx_hash = out_point.tx_hash.clone();
            self.insert_fake_tx_status(tx_hash, header.hash().unpack(), header.number())
                .insert_fake_header(header.clone());
            self.fake_provider
                .fake_outpoint_headers
                .insert(out_point, header);
        }
        self
    }

    pub fn insert_fake_tx_status(
        &mut self,
        tx_hash: H256,
        block_hash: H256,
        block_number: u64,
    ) -> &mut Self {
        self.fake_provider.fake_transaction_status.insert(
            tx_hash,
            TxStatus {
                status: Status::Committed,
                block_hash: Some(block_hash),
                block_number: Some(block_number.into()),
                reason: None,
            },
        );
        self
    }

    pub fn insert_fake_header(&mut self, header: core::HeaderView) -> &mut Self {
        self.fake_provider
            .fake_headers
            .insert(header.hash().unpack(), header.into());
        self
    }

    pub fn get_outpoint_to_headers(&self) -> Vec<(packed::OutPoint, core::HeaderView)> {
        self.fake_provider
            .fake_outpoint_headers
            .iter()
            .map(|(k, v)| (k.clone().into(), v.clone()))
            .collect()
    }
}

unsafe impl Send for FakeRpcClient {}
unsafe impl Sync for FakeRpcClient {}

impl RPC for FakeRpcClient {
    fn url(&self) -> (String, String) {
        unimplemented!("fake url method")
    }

    fn get_live_cell(&self, out_point: &OutPoint, _with_data: bool) -> Rpc<CellWithStatus> {
        let cell = self
            .fake_provider
            .get_cell_by_outpoint(out_point)
            .ok_or(eyre!("no live cell found"));
        Box::pin(async move { cell })
    }

    fn get_cells(
        &self,
        search_key: SearchKey,
        limit: u32,
        cursor: Option<JsonBytes>,
    ) -> Rpc<Pagination<Cell>> {
        let (cells, cursor) =
            self.fake_provider
                .get_cells_by_search_key(search_key, limit as usize, cursor);
        let result = Pagination::<Cell> {
            objects: cells,
            last_cursor: JsonBytes::from_vec(cursor.to_le_bytes().to_vec()),
        };
        Box::pin(async move { Ok(result) })
    }

    fn get_block_by_number(&self, _number: BlockNumber) -> Rpc<Option<BlockView>> {
        unimplemented!("fake get_block_by_number method")
    }

    fn get_block(&self, _hash: &H256) -> Rpc<Option<BlockView>> {
        unimplemented!("fake get_block method")
    }

    fn get_header(&self, hash: &H256) -> Rpc<Option<HeaderView>> {
        let header = self.fake_provider.get_header_by_hash(hash);
        Box::pin(async move { Ok(header) })
    }

    fn get_header_by_number(&self, number: BlockNumber) -> Rpc<Option<HeaderView>> {
        let header = self.fake_provider.get_header_by_number(number.into());
        Box::pin(async move { Ok(header) })
    }

    fn get_block_hash(&self, number: BlockNumber) -> Rpc<Option<H256>> {
        let header = self.fake_provider.get_header_by_number(number.into());
        Box::pin(async move { Ok(header.map(|h| h.hash)) })
    }

    fn get_tip_block_number(&self) -> Rpc<BlockNumber> {
        let tip_number = self.fake_provider.fake_tipnumber;
        Box::pin(async move { Ok(tip_number.into()) })
    }

    fn get_tip_header(&self) -> Rpc<HeaderView> {
        let tip_header = self.fake_provider.fate_tipheader.clone();
        Box::pin(async move { Ok(tip_header) })
    }

    fn tx_pool_info(&self) -> Rpc<TxPoolInfo> {
        let pool = TxPoolInfo {
            min_fee_rate: self.fake_provider.fake_feerate.into(),
            ..Default::default()
        };
        Box::pin(async move { Ok(pool) })
    }

    fn get_transaction(&self, hash: &H256) -> Rpc<Option<TransactionWithStatusResponse>> {
        let transaction = self.fake_provider.get_transaction_by_hash(hash);
        Box::pin(async move { Ok(transaction) })
    }

    fn send_transaction(
        &self,
        _tx: Transaction,
        _outputs_validator: Option<OutputsValidator>,
    ) -> Rpc<H256> {
        unimplemented!("fake send_transaction method")
    }
}


================================================
File: calculate/src/simulation/simulator.rs
================================================
use std::{collections::HashMap, sync::Arc};

use ckb_chain_spec::consensus::{Consensus, ConsensusBuilder};
use ckb_script::{TransactionScriptsVerifier, TxVerifyEnv};
use ckb_traits::{CellDataProvider, ExtensionProvider, HeaderProvider};
use ckb_types::{
    bytes::Bytes,
    core::{
        cell::{CellMeta, ResolvedTransaction},
        hardfork::{HardForks, CKB2021, CKB2023},
        Cycle, HeaderBuilder, HeaderView, TransactionInfo,
    },
    packed::{self, Byte32, OutPoint},
    prelude::{Pack, Unpack},
    H256,
};
use eyre::Result;

use crate::{instruction::Instruction, operation::Log, rpc::RPC, skeleton::TransactionSkeleton};

pub const DEFUALT_MAX_CYCLES: u64 = 10_000_000;

/// Context for a self-custody resolved transaction
#[derive(Clone)]
struct Context {
    resolved_tx: Arc<ResolvedTransaction>,
    headers: HashMap<H256, HeaderView>,
}

impl Context {
    pub fn new(resolved_tx: Arc<ResolvedTransaction>, headers: HashMap<H256, HeaderView>) -> Self {
        Context {
            resolved_tx,
            headers,
        }
    }
}

impl CellDataProvider for Context {
    fn get_cell_data(&self, out_point: &OutPoint) -> Option<Bytes> {
        let metas = [
            self.resolved_tx.resolved_inputs.clone(),
            self.resolved_tx.resolved_cell_deps.clone(),
        ]
        .concat();
        metas.into_iter().find_map(|v| {
            if &v.out_point == out_point {
                Some(v.mem_cell_data.expect("cell data meta"))
            } else {
                None
            }
        })
    }

    fn get_cell_data_hash(&self, out_point: &OutPoint) -> Option<Byte32> {
        let metas = [
            self.resolved_tx.resolved_inputs.clone(),
            self.resolved_tx.resolved_cell_deps.clone(),
        ]
        .concat();
        metas.into_iter().find_map(|v| {
            if &v.out_point == out_point {
                Some(v.mem_cell_data_hash.expect("cell data hash meta"))
            } else {
                None
            }
        })
    }
}

impl HeaderProvider for Context {
    fn get_header(&self, hash: &Byte32) -> Option<HeaderView> {
        self.headers.get(&hash.unpack()).cloned()
    }
}

impl ExtensionProvider for Context {
    fn get_block_extension(&self, _hash: &Byte32) -> Option<packed::Bytes> {
        None
    }
}

/// Onwn a native CKB-VM runner to verify a self-custody resolved transaction
pub struct TransactionSimulator {
    consensus: Consensus,
    env: TxVerifyEnv,
    print_tx: bool,
    outpoint_to_headers: HashMap<OutPoint, HeaderView>,
    skeleton: Option<TransactionSkeleton>,
}

impl Default for TransactionSimulator {
    fn default() -> Self {
        let consensus = ConsensusBuilder::default()
            .hardfork_switch(HardForks {
                ckb2021: CKB2021::new_dev_default(),
                ckb2023: CKB2023::new_dev_default(),
            })
            .build();
        let tip = HeaderBuilder::default().number(0.pack()).build();
        let env = TxVerifyEnv::new_submit(&tip);
        Self {
            consensus,
            env,
            print_tx: false,
            outpoint_to_headers: HashMap::new(),
            skeleton: None,
        }
    }
}

impl TransactionSimulator {
    pub fn print_tx(mut self, print_tx: bool) -> Self {
        self.print_tx = print_tx;
        self
    }

    pub fn skeleton(mut self, skeleton: TransactionSkeleton) -> Self {
        self.skeleton = Some(skeleton);
        self
    }

    pub fn link_cell_to_header(mut self, link: Vec<(OutPoint, HeaderView)>) -> Self {
        link.into_iter().for_each(|(outpoint, header)| {
            self.outpoint_to_headers.insert(outpoint, header);
        });
        self
    }

    pub fn verify<T: RPC>(
        self,
        rpc: &T,
        instructions: Vec<Instruction<T>>,
        max_cycles: u64,
    ) -> Result<Cycle> {
        tokio::runtime::Builder::new_current_thread()
            .enable_all()
            .build()?
            .block_on(self.async_verify(rpc, instructions, max_cycles))
    }

    pub async fn async_verify<T: RPC>(
        self,
        rpc: &T,
        instructions: Vec<Instruction<T>>,
        max_cycles: u64,
    ) -> Result<Cycle> {
        let mut skeleton = self.skeleton.unwrap_or_default();
        let mut log = Log::new();
        for instruction in instructions {
            instruction.run(rpc, &mut skeleton, &mut log).await?;
        }
        if self.print_tx {
            println!("transaction skeleton: {}", skeleton);
        }
        log.into_iter()
            .for_each(|(name, msg)| println!("[calculate log] {name} -> {}", hex::encode(msg)));
        let headers = skeleton
            .headerdeps
            .iter()
            .map(|v| (v.block_hash.clone(), v.header.clone()))
            .collect();
        let resolved_tx = {
            let mut resolved_tx = skeleton.into_resolved_transaction(rpc).await?;
            complete_resolved_tx(self.outpoint_to_headers, &mut resolved_tx);
            Arc::new(resolved_tx)
        };
        let context = Context::new(resolved_tx.clone(), headers);
        let consensus = Arc::new(self.consensus.clone());
        let env = Arc::new(self.env.clone());
        let mut verifier = TransactionScriptsVerifier::new(resolved_tx, context, consensus, env);
        verifier.set_debug_printer(|_id, msg| {
            println!("[contract debug] {}", msg);
        });
        Ok(verifier.verify(max_cycles)?)
    }
}

#[allow(clippy::mutable_key_type)]
fn complete_resolved_tx(
    outpoint_to_headers: HashMap<OutPoint, HeaderView>,
    resolved_tx: &mut ResolvedTransaction,
) {
    let complete_cell_meta = |cell_meta: &mut CellMeta| {
        if let Some(header) = outpoint_to_headers.get(&cell_meta.out_point) {
            cell_meta.transaction_info = Some(TransactionInfo {
                block_number: header.number(),
                block_epoch: header.epoch(),
                block_hash: header.hash(),
                index: 0,
            });
        }
    };
    for resolved_input in resolved_tx.resolved_inputs.iter_mut() {
        complete_cell_meta(resolved_input);
    }
    for resolved_cell_dep in resolved_tx.resolved_cell_deps.iter_mut() {
        complete_cell_meta(resolved_cell_dep);
    }
}


================================================
File: examples/dao.rs
================================================
use chrono::prelude::Utc;
use ckb_cinnabar_calculator::{
    address::Address,
    instruction::predefined::{
        balance_and_sign_with_ckb_cli, dao_deposit, dao_withdraw_phase_one, dao_withdraw_phase_two,
    },
    re_exports::ckb_sdk::HumanCapacity,
    rpc::RpcClient,
    TransactionCalculator,
};
use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(version, about, long_about = None)]
#[command(propagate_version = true)]
pub struct Cli {
    /// The address to deposit into, or withdraw, unlock from Nervos DAO
    #[arg(long, value_name = "address")]
    operator: Address,

    #[command(subcommand)]
    pub command: Commands,
}

#[derive(Subcommand)]
pub enum Commands {
    /// Deposit some capacity into Nervos DAO from <operator>
    Deposit {
        /// The amount of capacity to deposit
        #[arg(long, value_name = "ckb")]
        ckb: HumanCapacity,
    },
    /// Search and mark deposited Nervos DAO cells under <operator> with flag of withdrawing
    Withdraw {
        /// The maximum amount of capacity to withdraw
        #[arg(long, value_name = "ckb")]
        max_ckb: Option<HumanCapacity>,
        /// The withdrawn capacity must be deposited for such days
        #[arg(long, value_name = "amount")]
        min_deposit_days: Option<u64>,
        /// The address to receive the withdrawn capacity
        #[arg(long, value_name = "address")]
        to: Option<Address>,
    },
    /// Require to unlock withdrawing cells of under <operator> in a queue and wait unlocked when time reached
    Unlock {
        /// The maximum amount of capacity to unlock
        #[arg(long, value_name = "ckb")]
        max_ckb: Option<HumanCapacity>,
        /// The address to receive the unlocked capacity
        #[arg(long, value_name = "address")]
        to: Option<Address>,
    },
}

#[tokio::main]
pub async fn main() {
    let cli = Cli::parse();
    let dao = match cli.command {
        Commands::Deposit { ckb } => dao_deposit(&cli.operator, ckb),
        Commands::Withdraw {
            max_ckb,
            min_deposit_days,
            to,
        } => {
            let timestamp = min_deposit_days.map(|day| Utc::now().timestamp() as u64 - day * 3600);
            dao_withdraw_phase_one(&cli.operator, max_ckb, timestamp, to.as_ref())
        }
        Commands::Unlock { max_ckb, to } => {
            dao_withdraw_phase_two(&cli.operator, max_ckb, to.as_ref())
        }
    };
    let balance_and_sign = balance_and_sign_with_ckb_cli(&cli.operator, 2000, None);

    // build transaction
    let rpc = RpcClient::new_testnet();
    let (skeleton, _) = TransactionCalculator::default()
        .instruction(dao)
        .instruction(balance_and_sign)
        .new_skeleton(&rpc)
        .await
        .expect("build tx");

    // send transaction without any block confirmations
    let hash = skeleton.send_and_wait(&rpc, 0, None).await.expect("send");
    println!("Transaction hash: {hash:#x}");
}


================================================
File: examples/secp256k1_transfer.rs
================================================
use ckb_cinnabar_calculator::{
    address::Address,
    instruction::{
        predefined::{balance_and_sign, balance_and_sign_with_ckb_cli, secp256k1_sighash_transfer},
        TransactionCalculator,
    },
    re_exports::{ckb_sdk::HumanCapacity, secp256k1::SecretKey, tokio},
    rpc::RpcClient,
};

const ADDITIONAL_FEE_RATE: u64 = 1000;

/// Transfer CKB from one address to another address on testnet
///
/// Usage: cargo run --example secp256k1_transfer <from> <to> <ckb> [secret_key]
#[tokio::main]
pub async fn main() {
    let mut args = std::env::args();
    args.next(); // skip program name
    let (from, to, ckb, secret_key) = match (args.next(), args.next(), args.next(), args.next()) {
        (Some(from), Some(to), Some(ckb), secret_key) => (from, to, ckb, secret_key),
        _ => panic!("args invalid"),
    };

    // prepare transfer parameters
    let from: Address = from.parse().expect("from address");
    let to: Address = to.parse().expect("to address");
    let ckb: HumanCapacity = ckb.parse().expect("ckb");
    let secret_key: Option<SecretKey> = secret_key.map(|k| k.parse().expect("secret_key"));
    let rpc = RpcClient::new_testnet();

    // build transfer instruction
    let transfer = secp256k1_sighash_transfer(&from, &to, ckb.into());
    let balance_and_sign = if let Some(secret_key) = secret_key {
        balance_and_sign(&from, secret_key, ADDITIONAL_FEE_RATE)
    } else {
        balance_and_sign_with_ckb_cli(&from, ADDITIONAL_FEE_RATE, None)
    };

    // apply transfer instructio and build transaction
    let (skeleton, _) = TransactionCalculator::default()
        .instruction(transfer)
        .instruction(balance_and_sign)
        .new_skeleton(&rpc)
        .await
        .expect("calculate");

    // send transaction without any block confirmations
    let hash = skeleton.send_and_wait(&rpc, 0, None).await.expect("send");
    println!("Transaction hash: {hash:#x}");
}


================================================
File: examples/spore.rs
================================================
use std::collections::HashSet;

use ckb_cinnabar_calculator::{
    address::Address,
    instruction::predefined::{
        balance_and_sign_with_ckb_cli, burn_spores, mint_clusters, mint_spores, transfer_clusters,
        transfer_spores, Cluster, Spore,
    },
    operation::spore::hookkey,
    re_exports::{
        ckb_types::{packed::Script, prelude::Entity, H256},
        tokio,
    },
    rpc::{RpcClient, RPC},
    skeleton::ScriptEx,
    TransactionCalculator,
};
use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(version, about, long_about = None)]
#[command(propagate_version = true)]
pub struct Cli {
    #[command(subcommand)]
    pub command: Commands,
}

#[derive(Subcommand)]
pub enum Commands {
    /// Operations on minting, transferring or burning a Spore
    Spore(SporeCli),
    /// Operations on minting or transferring a Cluster
    Cluster(ClusterCli),
}

#[derive(Parser)]
#[command(version, about, long_about = None)]
#[command(propagate_version = true)]
pub struct SporeCli {
    #[command(subcommand)]
    pub command: SporeCommands,
}

#[derive(Subcommand)]
pub enum SporeCommands {
    Mint {
        /// The address to mint Spore
        #[arg(long, value_name = "address")]
        minter: Address,
        /// The content type of the Spore
        #[arg(long, value_name = "string")]
        content_type: String,
        /// The content of the Spore (UTF8 or HEX format)
        #[arg(long, value_name = "string or hex")]
        content: String,
        /// The cluster id of the Spore
        #[arg(long, value_name = "h256")]
        cluster_id: Option<String>,
    },
    Transfer {
        /// The unique id of the Spore to transfer
        #[arg(long, value_name = "h256")]
        spore_id: String,
        /// The address to send Spore
        #[arg(long, value_name = "address")]
        from: Address,
        /// The address to receive Spore
        #[arg(long, value_name = "address")]
        to: Address,
    },
    Burn {
        /// The Spore to burn
        #[arg(long, value_name = "h256")]
        spore_id: String,
        /// The address to burn Spore
        #[arg(long, value_name = "address")]
        owner: Address,
    },
}

#[derive(Parser)]
#[command(version, about, long_about = None)]
#[command(propagate_version = true)]
pub struct ClusterCli {
    #[command(subcommand)]
    pub command: ClusterCommands,
}

#[derive(Subcommand)]
pub enum ClusterCommands {
    Mint {
        /// The address to mint Cluster
        #[arg(long, value_name = "address")]
        minter: Address,
        /// The cluster name
        #[arg(long, value_name = "string")]
        cluster_name: String,
        /// The cluster description (UTF8 or HEX format)
        #[arg(long, value_name = "string or hex")]
        cluster_description: String,
    },
    Transfer {
        /// The uniqie id of the Cluster to transfer
        #[arg(long, value_name = "hex")]
        cluster_id: String,
        /// The address to send Cluster
        #[arg(long, value_name = "address")]
        from: Address,
        /// The address to receive Cluster
        #[arg(long, value_name = "address")]
        to: Address,
    },
}

fn h256(value: String) -> H256 {
    let bytes32: [u8; 32] = hex::decode(value.trim_start_matches("0x"))
        .expect("hex")
        .try_into()
        .expect("h256");
    bytes32.into()
}

fn bytify(value: String) -> Vec<u8> {
    if let Ok(value) = hex::decode(value.trim_start_matches("0x")) {
        value
    } else {
        value.into_bytes()
    }
}

#[tokio::main]
pub async fn main() {
    #[allow(clippy::mutable_key_type)]
    let mut signers = HashSet::new();
    let spore = match Cli::parse().command {
        Commands::Spore(spore) => match spore.command {
            SporeCommands::Mint {
                minter,
                content_type,
                content,
                cluster_id,
            } => {
                let spore = Spore {
                    owner: None,
                    content_type,
                    content: bytify(content),
                    cluster_id: cluster_id.map(h256),
                };
                signers.insert(minter.clone());
                mint_spores(&minter, vec![spore], false)
            }
            SporeCommands::Transfer { spore_id, from, to } => {
                signers.insert(from.clone());
                transfer_spores(&from, vec![(to, h256(spore_id))])
            }
            SporeCommands::Burn { spore_id, owner } => {
                signers.insert(owner.clone());
                burn_spores(&owner, vec![h256(spore_id)])
            }
        },
        Commands::Cluster(cluster) => match cluster.command {
            ClusterCommands::Mint {
                minter,
                cluster_name,
                cluster_description,
            } => {
                let cluster = Cluster {
                    owner: None,
                    cluster_name,
                    cluster_description: bytify(cluster_description),
                };
                signers.insert(minter.clone());
                mint_clusters(&minter, vec![cluster])
            }
            ClusterCommands::Transfer {
                cluster_id,
                from,
                to,
            } => {
                signers.insert(from.clone());
                transfer_clusters(&from, vec![(to, h256(cluster_id))])
            }
        },
    };

    // build transaction
    let rpc = RpcClient::new_testnet();
    let (mut skeleton, log) = TransactionCalculator::default()
        .instruction(spore)
        .new_skeleton(&rpc)
        .await
        .expect("spore calculate");
    for (key, value) in log {
        match key {
            hookkey::NEW_SPORE_ID => println!("new spore_id: {}", hex::encode(value)),
            hookkey::NEW_CLUSTER_ID => println!("new cluster_id: {}", hex::encode(value)),
            hookkey::CLUSTER_CELL_OWNER_LOCK => {
                let lock_script = Script::from_compatible_slice(&value).unwrap();
                let address = ScriptEx::from(lock_script)
                    .to_address(rpc.network())
                    .unwrap();
                signers.insert(address);
            }
            _ => {}
        };
    }
    // TODO: there's a bug if signing more than once through ckb-cli, need to find out why
    let signs = signers
        .into_iter()
        .map(|signer| balance_and_sign_with_ckb_cli(&signer, 2000, None))
        .collect::<Vec<_>>();
    TransactionCalculator::new(signs)
        .apply_skeleton(&rpc, &mut skeleton)
        .await
        .expect("sign calculate");

    // send transaction without any block confirmations
    let hash = skeleton.send_and_wait(&rpc, 0, None).await.expect("send");
    println!("Transaction hash: {hash:#x}");
}


================================================
File: src/command.rs
================================================
use ckb_cinnabar_calculator::{address::Address, re_exports::eyre, rpc::Network};
use clap::{Parser, Subcommand};

use crate::{
    handle::{consume_contract, deploy_contract, migrate_contract},
    object::TypeIdMode,
};

#[derive(Parser)]
#[command(version, about, long_about = None)]
#[command(propagate_version = true)]
struct Cli {
    /// CKB network, options are `mainnet`, `testnet` or URL (e.g. http://localhost:8114)
    #[arg(short, long, default_value_t = Network::Testnet)]
    network: Network,

    /// Directory of the contract deployment information
    #[arg(long, default_value_t = String::from("deployment"))]
    deployment_path: String,

    /// Directory of the compiled contract binary
    #[arg(long, default_value_t = String::from("build/release"))]
    contract_path: String,

    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Upload contract to CKB
    Deploy {
        /// Contract that will be deployed
        #[arg(long)]
        contract_name: String,
        /// Version of the contract that used to distinguish different contracts, e.g. `v0.1.8`
        #[arg(long)]
        tag: String,
        /// Who pays the capacity and transaction fee
        #[arg(long)]
        payer_address: Address,
        /// Who owns the contract cell, if None, <payer_address> will be in charge
        #[arg(long)]
        contract_owner_address: Option<Address>,
        /// Whether to deploy contract with `type_id`
        #[arg(long, default_value_t = false)]
        type_id: bool,
    },
    /// Update on-chain contract from old version to new version
    Migrate {
        /// Contract that will be migrated
        #[arg(long)]
        contract_name: String,
        /// Previous deployed contract version
        #[arg(long)]
        from_tag: String,
        /// New contract version
        #[arg(long)]
        to_tag: String,
        /// Who onws the new contract cell, if None, previous contract owner of <from_tag> will be in charge
        #[arg(long)]
        contract_owner_address: Option<Address>,
        /// How to process the `type_id` of migrated contract, operation is `keep`, `remove` or `new`
        #[arg(long, default_value_t = TypeIdMode::Keep)]
        type_id_mode: TypeIdMode,
    },
    /// Consume on-chain contract to release the capacity
    Consume {
        /// Contract that will be consumed
        #[arg(long)]
        contract_name: String,
        /// Version of the consuming contract
        #[arg(long)]
        tag: String,
        /// Who receives the released capacity, if None, previous contract owner of <tag> will be in charge
        #[arg(long)]
        receiver_address: Option<Address>,
    },
}

/// Parse and dispatch commands
pub async fn dispatch_commands() -> eyre::Result<()> {
    let cli = Cli::parse();
    match cli.command {
        Commands::Deploy {
            contract_name,
            tag,
            payer_address,
            contract_owner_address,
            type_id,
        } => {
            deploy_contract(
                cli.network,
                contract_name,
                tag,
                payer_address,
                contract_owner_address,
                type_id,
                cli.deployment_path,
                cli.contract_path,
            )
            .await
        }
        Commands::Migrate {
            contract_name,
            from_tag,
            to_tag,
            contract_owner_address,
            type_id_mode,
        } => {
            migrate_contract(
                cli.network,
                contract_name,
                from_tag,
                to_tag,
                contract_owner_address,
                type_id_mode,
                cli.deployment_path,
                cli.contract_path,
            )
            .await
        }
        Commands::Consume {
            contract_name,
            tag,
            receiver_address,
        } => {
            consume_contract(
                cli.network,
                contract_name,
                tag,
                receiver_address,
                cli.deployment_path,
            )
            .await
        }
    }
}


================================================
File: src/lib.rs
================================================
#![allow(dead_code)]

mod command;
mod handle;
mod object;

pub use ckb_cinnabar_calculator as calculator;
pub use handle::load_contract_deployment;
pub use object::DeploymentRecord;

/// Wrap for scripts-manager runner
pub fn dispatch() {
    tokio::runtime::Runtime::new()
        .expect("tokio runtime")
        .block_on(command::dispatch_commands())
        .expect("dispatch commands");
}


================================================
File: src/main.rs
================================================
#![allow(dead_code)]

mod command;
mod handle;
mod object;

#[tokio::main]
pub async fn main() -> ckb_cinnabar_calculator::re_exports::eyre::Result<()> {
    command::dispatch_commands().await
}


================================================
File: src/object.rs
================================================
use std::{fmt::Display, str::FromStr};

use ckb_cinnabar_calculator::{
    address::Address,
    re_exports::{
        ckb_types::{core, packed, prelude::*, H256},
        eyre,
    },
    skeleton::ScriptEx,
};
use serde::{Deserialize, Serialize};

#[derive(PartialEq, Eq, Clone)]
pub enum TypeIdMode {
    Keep,
    Remove,
    New,
}

impl FromStr for TypeIdMode {
    type Err = eyre::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "keep" => Ok(TypeIdMode::Keep),
            "remove" => Ok(TypeIdMode::Remove),
            "new" => Ok(TypeIdMode::New),
            _ => Err(eyre::eyre!("invalid type_id_mode")),
        }
    }
}

impl Display for TypeIdMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let inner = match self {
            TypeIdMode::Keep => "keep",
            TypeIdMode::Remove => "remove",
            TypeIdMode::New => "new",
        };
        write!(f, "{inner}",)
    }
}

#[derive(PartialEq, Eq)]
pub enum ListMode {
    All,
    Deployed,
    Consumed,
}

impl TryFrom<String> for ListMode {
    type Error = eyre::Error;

    fn try_from(value: String) -> Result<Self, Self::Error> {
        match value.as_str() {
            "all" => Ok(ListMode::All),
            "deployed" => Ok(ListMode::Deployed),
            "consumed" => Ok(ListMode::Consumed),
            _ => Err(eyre::eyre!("invalid list mode")),
        }
    }
}

#[derive(Clone, Default)]
pub struct CkbAddress(Option<Address>);

impl TryFrom<CkbAddress> for Address {
    type Error = eyre::Error;

    fn try_from(value: CkbAddress) -> Result<Self, Self::Error> {
        value.0.ok_or_else(|| eyre::eyre!("empty ckb address"))
    }
}

impl From<Address> for CkbAddress {
    fn from(value: Address) -> Self {
        CkbAddress(Some(value))
    }
}

impl From<Option<Address>> for CkbAddress {
    fn from(value: Option<Address>) -> Self {
        CkbAddress(value)
    }
}

impl FromStr for CkbAddress {
    type Err = eyre::Error;

    fn from_str(value: &str) -> Result<Self, Self::Err> {
        Address::from_str(value)
            .map(|v| CkbAddress(Some(v)))
            .map_err(|_| eyre::eyre!("invalid ckb address"))
    }
}

impl Display for CkbAddress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let inner = self.0.as_ref().map(|v| v.to_string()).unwrap_or_default();
        write!(f, "{inner}",)
    }
}

impl<'de> Deserialize<'de> for CkbAddress {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = String::deserialize(deserializer)?;
        if value.is_empty() {
            Ok(CkbAddress(None))
        } else {
            value.parse().map_err(serde::de::Error::custom)
        }
    }
}

impl Serialize for CkbAddress {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.to_string().serialize(serializer)
    }
}

#[derive(serde::Serialize, serde::Deserialize, Clone, Default)]
pub struct DeploymentRecord {
    pub name: String,
    pub date: String,
    pub operation: String,
    pub version: String,
    pub tx_hash: H256,
    pub out_index: u32,
    pub data_hash: Option<H256>,
    pub occupied_capacity: u64,
    pub payer_address: CkbAddress,
    pub contract_owner_address: CkbAddress,
    pub type_id: Option<H256>,
    // This field is not required, so you can edit in your <contract>.json file to add comment for cooperations
    #[serde(default, rename = "__comment")]
    pub comment: Option<String>,
}

impl DeploymentRecord {
    pub fn generate_script(&self, args: Vec<u8>) -> eyre::Result<ScriptEx> {
        let mut script = packed::Script::new_builder().args(args.pack());
        if let Some(type_id) = self.type_id.clone() {
            script = script
                .code_hash(type_id.0.pack())
                .hash_type(core::ScriptHashType::Type.into());
        } else {
            let Some(data_hash) = self.data_hash.clone() else {
                return Err(eyre::eyre!("contract consumed"));
            };
            script = script
                .code_hash(data_hash.0.pack())
                .hash_type(core::ScriptHashType::Data2.into());
        }
        Ok(script.build().into())
    }
}


================================================
File: src/handle/helper.rs
================================================
use std::{fs, path::PathBuf};

use chrono::prelude::Utc;
use ckb_cinnabar_calculator::{
    address::Address,
    instruction::{Instruction, TransactionCalculator},
    re_exports::{ckb_hash::blake2b_256, ckb_jsonrpc_types::OutputsValidator, eyre},
    rpc::{Network, RpcClient, RPC},
};

use crate::object::*;

pub fn generate_contract_deployment_path(
    network: &Network,
    contract_name: &str,
    deployment_path: &str,
) -> PathBuf {
    PathBuf::new()
        .join(deployment_path)
        .join(network.to_string())
        .join(format!("{contract_name}.json"))
}

pub fn load_contract_deployment(
    network: &Network,
    contract_name: &str,
    deployment_path: &str,
    version: Option<&str>,
) -> eyre::Result<Option<DeploymentRecord>> {
    let path = generate_contract_deployment_path(network, contract_name, deployment_path);
    if path.exists() {
        let file = fs::File::open(&path)?;
        let deployments: Vec<DeploymentRecord> = serde_json::from_reader(file)?;
        if let Some(version) = version {
            Ok(deployments.into_iter().find(|r| r.version == version))
        } else {
            Ok(deployments.into_iter().last())
        }
    } else {
        Ok(None)
    }
}

pub fn load_contract_binary(
    contract_name: &str,
    binary_path: &str,
) -> eyre::Result<(Vec<u8>, [u8; 32])> {
    let contract_path = PathBuf::new().join(binary_path).join(contract_name);
    let contract_binary = fs::read(&contract_path)
        .map_err(|e| eyre::eyre!("{e}:{}", contract_path.to_string_lossy()))?;
    let contract_hash = blake2b_256(&contract_binary);
    Ok((contract_binary, contract_hash))
}

pub fn create_rpc_from_network(network: &Network) -> eyre::Result<RpcClient> {
    match network {
        Network::Mainnet => Ok(RpcClient::new_mainnet()),
        Network::Testnet => Ok(RpcClient::new_testnet()),
        Network::Fake => Err(eyre::eyre!("fake network")),
        Network::Custom(url) => Ok(RpcClient::new(url.as_str(), None)),
    }
}

pub async fn send_and_record_transaction<T: RPC>(
    rpc: T,
    instructions: Vec<Instruction<T>>,
    tx_path: PathBuf,
    operation: &str,
    contract_name: String,
    version: String,
    contract_hash: Option<[u8; 32]>,
    payer_address: Address,
    contract_owner_address: Option<Address>,
) -> eyre::Result<()> {
    let (skeleton, _) = TransactionCalculator::new(instructions)
        .new_skeleton(&rpc)
        .await?;
    let occupied_capacity = skeleton.outputs[0].occupied_capacity().as_u64();
    let type_id = skeleton.outputs[0].calc_type_hash();
    let tx_hash = rpc
        .send_transaction(
            skeleton.into_transaction_view().data().into(),
            Some(OutputsValidator::Passthrough),
        )
        .await?;
    println!("Transaction hash: {}", tx_hash);
    let deployment_record = DeploymentRecord {
        name: contract_name,
        date: Utc::now().to_rfc3339(),
        operation: operation.to_string(),
        version,
        tx_hash,
        out_index: 0,
        data_hash: contract_hash.map(Into::into),
        occupied_capacity,
        payer_address: payer_address.into(),
        contract_owner_address: contract_owner_address.into(),
        type_id: type_id.map(Into::into),
        comment: None,
    };
    save_contract_deployment(tx_path, deployment_record)
}

fn save_contract_deployment(path: PathBuf, record: DeploymentRecord) -> eyre::Result<()> {
    let mut records: Vec<DeploymentRecord> = if path.exists() {
        let content = fs::read(&path)?;
        serde_json::from_slice(&content)?
    } else {
        fs::create_dir_all(path.parent().unwrap())?;
        Vec::new()
    };
    records.push(record);
    let new_content = serde_json::to_string_pretty(&records)?;
    fs::write(path, new_content)?;
    Ok(())
}


================================================
File: src/handle/mod.rs
================================================
#![allow(clippy::too_many_arguments)]

use ckb_cinnabar_calculator::{
    address::Address,
    instruction::DefaultInstruction,
    operation::basic::{
        AddInputCellByAddress, AddInputCellByOutPoint, AddOutputCellByAddress,
        AddOutputCellByInputIndex, AddSecp256k1SighashCellDep,
        AddSecp256k1SighashSignaturesWithCkbCli, BalanceTransaction,
    },
    re_exports::eyre,
    rpc::Network,
    skeleton::ChangeReceiver,
};

use crate::object::*;

mod helper;
pub use helper::*;

/// Create a new contract version on-chain
pub async fn deploy_contract(
    network: Network,
    contract_name: String,
    version: String,
    payer_address: Address,
    contract_owner_address: Option<Address>,
    type_id: bool,
    deployment_path: String,
    binary_path: String,
) -> eyre::Result<()> {
    let deployment =
        load_contract_deployment(&network, &contract_name, &deployment_path, Some(&version))?;
    if deployment.is_some() {
        return Err(eyre::eyre!("version already exists"));
    }
    let rpc = create_rpc_from_network(&network)?;
    let (contract_binary, contract_hash) = load_contract_binary(&contract_name, &binary_path)?;
    let contract_owner_address = contract_owner_address.unwrap_or(payer_address.clone());
    let deploy_contract = DefaultInstruction::new(vec![
        Box::new(AddSecp256k1SighashCellDep {}),
        Box::new(AddInputCellByAddress {
            address: payer_address.clone(),
        }),
        Box::new(AddOutputCellByAddress {
            address: contract_owner_address.clone(),
            data: contract_binary,
            add_type_id: type_id,
        }),
        Box::new(BalanceTransaction {
            balancer: payer_address.clone().into(),
            change_receiver: ChangeReceiver::Address(payer_address.clone()),
            additional_fee_rate: 2000,
        }),
        Box::new(AddSecp256k1SighashSignaturesWithCkbCli {
            signer_address: payer_address.clone(),
            cache_path: format!("{deployment_path}/txs").into(),
            keep_cache_file: true,
        }),
    ]);
    let tx_path = generate_contract_deployment_path(&network, &contract_name, &deployment_path);
    send_and_record_transaction(
        rpc,
        vec![deploy_contract],
        tx_path,
        "deploy",
        contract_name,
        version,
        Some(contract_hash),
        payer_address,
        Some(contract_owner_address),
    )
    .await
}

/// Migrate a contract to a new version
pub async fn migrate_contract(
    network: Network,
    contract_name: String,
    from_version: String,
    version: String,
    contract_owner_address: Option<Address>,
    type_id_mode: TypeIdMode,
    deployment_path: String,
    binary_path: String,
) -> eyre::Result<()> {
    let deployment = load_contract_deployment(
        &network,
        &contract_name,
        &deployment_path,
        Some(&from_version),
    )?
    .ok_or(eyre::eyre!("version not exists"))?;
    if deployment.operation == "consume" {
        return Err(eyre::eyre!("version already consumed"));
    }
    let rpc = create_rpc_from_network(&network)?;
    let (contract_binary, contract_hash) = load_contract_binary(&contract_name, &binary_path)?;
    let payer_address: Address = deployment.contract_owner_address.clone().try_into()?;
    let contract_owner_address: Address = contract_owner_address.unwrap_or(payer_address.clone());
    let mut migrate_contract = DefaultInstruction::new(vec![
        Box::new(AddSecp256k1SighashCellDep {}),
        Box::new(AddInputCellByOutPoint {
            tx_hash: deployment.tx_hash,
            index: deployment.out_index,
            since: None,
        }),
    ]);
    match type_id_mode {
        TypeIdMode::Keep => {
            migrate_contract.push(Box::new(AddOutputCellByInputIndex {
                input_index: 0,
                data: Some(contract_binary),
                lock_script: Some(contract_owner_address.clone().into()),
                type_script: None,
                adjust_capacity: true,
            }));
        }
        TypeIdMode::Remove => {
            migrate_contract.push(Box::new(AddOutputCellByInputIndex {
                input_index: 0,
                data: Some(contract_binary),
                lock_script: Some(contract_owner_address.clone().into()),
                type_script: Some(None),
                adjust_capacity: true,
            }));
        }
        TypeIdMode::New => {
            migrate_contract.push(Box::new(AddOutputCellByAddress {
                address: contract_owner_address.clone(),
                data: contract_binary,
                add_type_id: true,
            }));
        }
    }
    migrate_contract.append(vec![
        Box::new(BalanceTransaction {
            balancer: payer_address.clone().into(),
            change_receiver: ChangeReceiver::Address(payer_address.clone()),
            additional_fee_rate: 2000,
        }),
        Box::new(AddSecp256k1SighashSignaturesWithCkbCli {
            signer_address: payer_address.clone(),
            cache_path: format!("{deployment_path}/txs").into(),
            keep_cache_file: true,
        }),
    ]);
    let tx_path = generate_contract_deployment_path(&network, &contract_name, &deployment_path);
    send_and_record_transaction(
        rpc,
        vec![migrate_contract],
        tx_path,
        "migrate",
        contract_name,
        version,
        Some(contract_hash),
        payer_address,
        Some(contract_owner_address),
    )
    .await
}

/// Consume a contract
pub async fn consume_contract(
    network: Network,
    contract_name: String,
    version: String,
    receiver_address: Option<Address>,
    deployment_path: String,
) -> eyre::Result<()> {
    let deployment =
        load_contract_deployment(&network, &contract_name, &deployment_path, Some(&version))?
            .ok_or(eyre::eyre!("version not exists"))?;
    if deployment.operation == "consume" {
        return Err(eyre::eyre!("version already consumed"));
    }
    let payer_address: Address = deployment.contract_owner_address.clone().try_into()?;
    let receiver_address: Address = receiver_address.unwrap_or(payer_address.clone());
    let rpc = create_rpc_from_network(&network)?;
    let consume_contract = DefaultInstruction::new(vec![
        Box::new(AddSecp256k1SighashCellDep {}),
        Box::new(AddInputCellByOutPoint {
            tx_hash: deployment.tx_hash,
            index: deployment.out_index,
            since: None,
        }),
        Box::new(BalanceTransaction {
            balancer: payer_address.payload().into(),
            change_receiver: ChangeReceiver::Address(receiver_address),
            additional_fee_rate: 2000,
        }),
        Box::new(AddSecp256k1SighashSignaturesWithCkbCli {
            signer_address: payer_address.clone(),
            cache_path: format!("{deployment_path}/txs").into(),
            keep_cache_file: true,
        }),
    ]);
    let tx_path = generate_contract_deployment_path(&network, &contract_name, &deployment_path);
    send_and_record_transaction(
        rpc,
        vec![consume_contract],
        tx_path,
        "consume",
        contract_name,
        "".into(),
        None,
        payer_address,
        Default::default(),
    )
    .await
}


================================================
File: verify/Cargo.toml
================================================
[package]
name = "ckb-cinnabar-verifier"
version = "0.1.0"
edition = "2021"

[dependencies]
ckb-std = "0.15.3"
blake2b-ref = "0.3.1"


================================================
File: verify/src/error.rs
================================================
use ckb_std::error::SysError;

#[macro_export]
macro_rules! define_errors {
    ($name:ident, {$($err:ident $(= $val:ident)? ,)+}) => {
        #[repr(i8)]
        pub enum $name {
            $($err $(= $val)? ,)+
        }

        impl From<$name> for ckb_cinnabar_verifier::Error {
            fn from(value: $name) -> Self {
                ckb_cinnabar_verifier::Error::Custom(value as i8)
            }
        }
    };
}

pub const CUSTOM_ERROR_START: i8 = 20;

pub enum Error {
    // Errors under 10 are reserved for system errors
    IndexOutOfBound,
    ItemMissing,
    LengthNotEnough,
    Encoding,
    UnknownSystemError,

    // Errors under 20 are reserved for framework errors
    NotFoundRootVerifier,
    NotFoundBranchVerifier,

    // Custom errors are supposed to be greator than 20
    Custom(i8),
}

impl From<SysError> for Error {
    fn from(value: SysError) -> Self {
        match value {
            SysError::IndexOutOfBound => Self::IndexOutOfBound,
            SysError::ItemMissing => Self::ItemMissing,
            SysError::LengthNotEnough(_) => Self::LengthNotEnough,
            SysError::Encoding => Self::Encoding,
            _ => Self::UnknownSystemError,
        }
    }
}

impl From<Error> for i8 {
    fn from(value: Error) -> i8 {
        match value {
            Error::IndexOutOfBound => 1,
            Error::ItemMissing => 2,
            Error::LengthNotEnough => 3,
            Error::Encoding => 4,
            Error::UnknownSystemError => 5,
            Error::NotFoundRootVerifier => 10,
            Error::NotFoundBranchVerifier => 11,
            Error::Custom(value) => value,
        }
    }
}

pub type Result<T> = core::result::Result<T, Error>;


================================================
File: verify/src/lib.rs
================================================
#![no_std]
extern crate alloc;

mod error;
mod utils;
mod verification;

pub use error::*;
pub use utils::*;
pub use verification::*;


================================================
File: verify/src/utils.rs
================================================
use alloc::vec::Vec;
use blake2b_ref::Blake2bBuilder;
use ckb_std::{
    ckb_constants::Source,
    ckb_types::prelude::{Entity, Unpack},
    high_level::{load_cell, load_input, load_script, QueryIter},
};

use crate::Error;

pub const CKB_HASH_PERSONALIZATION: &[u8] = b"ckb-default-hash";

pub fn calc_type_id(out_index: usize) -> Result<[u8; 32], Error> {
    let input = load_input(0, Source::Input)?;
    let mut hash = Blake2bBuilder::new(32)
        .personal(CKB_HASH_PERSONALIZATION)
        .build();
    hash.update(input.as_slice());
    hash.update(&(out_index as u64).to_le_bytes());
    let mut type_id = [0u8; 32];
    hash.finalize(&mut type_id);
    Ok(type_id)
}

pub fn calc_blake2b_hash<const N: usize, T: AsRef<[u8]>>(updates: &[T]) -> [u8; N] {
    let mut hash = Blake2bBuilder::new(N)
        .personal(CKB_HASH_PERSONALIZATION)
        .build();
    for update in updates {
        hash.update(update.as_ref());
    }
    let mut result = [0u8; N];
    hash.finalize(&mut result);
    result
}

pub fn this_script_args() -> Result<Vec<u8>, Error> {
    let script = load_script()?;
    let args = script.args().unpack();
    Ok(args)
}

#[derive(PartialEq, Eq, Clone, Copy)]
pub enum ScriptPlace {
    Lock,
    Type,
}

pub fn this_script_indices(source: Source, place: ScriptPlace) -> Result<Vec<usize>, Error> {
    let script = load_script()?;
    let indices = QueryIter::new(load_cell, source)
        .enumerate()
        .filter_map(|(i, cell)| {
            if place == ScriptPlace::Lock && cell.lock() == script {
                return Some(i);
            }
            if let Some(type_) = cell.type_().to_opt() {
                if place == ScriptPlace::Type && type_ == script {
                    return Some(i);
                }
            }
            None
        })
        .collect();
    Ok(indices)
}

#[derive(PartialEq, Eq, Clone, Copy)]
pub enum ScriptPattern {
    Create,
    Transfer,
    Burn,
}

pub fn this_script_pattern(place: ScriptPlace) -> Result<ScriptPattern, Error> {
    let in_input = this_script_count(Source::Input, place)? > 0;
    let in_output = this_script_count(Source::Output, place)? > 0;
    match (in_input, in_output) {
        (true, true) => Ok(ScriptPattern::Transfer),
        (true, false) => Ok(ScriptPattern::Burn),
        (false, true) => Ok(ScriptPattern::Create),
        _ => unreachable!("never touch here"),
    }
}

pub fn this_script_count(source: Source, place: ScriptPlace) -> Result<usize, Error> {
    let indices = this_script_indices(source, place)?;
    Ok(indices.len())
}


================================================
File: verify/src/verification.rs
================================================
use alloc::{borrow::ToOwned, boxed::Box, collections::BTreeMap, string::String};
use ckb_std::debug;

use crate::error::{Error, Result};

/// Where the verification tree starts
pub const TREE_ROOT: &str = "root";

pub trait Verification<T: Default> {
    fn verify(&mut self, verifier_name: &str, ctx: &mut T) -> Result<Option<&str>>;
}

/// Construct a batch of transaction verifiers in form of tree
#[derive(Default)]
pub struct TransactionVerifier<T: Default> {
    verification_tree: BTreeMap<String, Box<dyn Verification<T>>>,
}

impl<T: Default> TransactionVerifier<T> {
    pub fn add_verifier(
        &mut self,
        name: &'static str,
        verifier: Box<dyn Verification<T>>,
    ) -> &mut Self {
        self.verification_tree.insert(name.to_owned(), verifier);
        self
    }

    pub fn run(mut self, ctx: &mut T) -> Result<()> {
        let mut root = self
            .verification_tree
            .remove(TREE_ROOT)
            .ok_or(Error::NotFoundRootVerifier)?;
        let mut branch = root.verify(TREE_ROOT, ctx)?.map(ToOwned::to_owned);
        while let Some(name) = branch {
            let mut verifier = self.verification_tree.remove(&name).ok_or_else(|| {
                debug!("verifier not found: {}", name);
                Error::NotFoundBranchVerifier
            })?;
            branch = verifier.verify(&name, ctx)?.map(ToOwned::to_owned);
        }
        Ok(())
    }
}

/// Examples:
///
/// ```
/// use ckb_cinnabar_verifier::{cinnabar_main, TREE_ROOT, define_errors, CUSTOM_ERROR_START};
///
/// // define custom errors
/// define_errors!(CustomError, {
///     MyError1 = CUSTOM_ERROR_START,
///     MyError2,
///     // more errors
/// });
///
/// // contains the global context data
/// struct GlobalContext {
///    // some fields
/// }
///
/// // the entry verifier
/// #[derive(Default)]
/// struct RootVerifier;
///
/// // must implement Verification trait
/// impl Verification<GlobalContext> for RootVerifier {
///    fn verify(&mut self, verifier_name: &str, ctx: &mut GlobalContext) -> Result<Option<&str>> {
///         // ...
///         Ok(Some("branch")) // head to branch verifier
///     }
/// }
///
/// // the branch verifier
/// #[derive(Default)]
/// struct BranchVerifier;
///
/// // must implement Verification trait
/// impl Verification<GlobalContext> for RootVerifier {
///    fn verify(&mut self, verifier_name: &str, ctx: &mut GlobalContext) -> Result<Option<&str>> {
///         // ...
///         Ok(None) // end of the verification
///     }
/// }
///
/// cinnabar_main!(GlobalContext, (TREE_ROOT, RootVerifier), ("branch", BranchVerifier));
/// ```
#[macro_export]
macro_rules! cinnabar_main {
    ($ctx:ty, $(($name:expr, $verifier:ty) $(,)?)+) => {
        ckb_std::default_alloc!();
        ckb_std::entry!(program_entry);

        pub fn program_entry() -> i8 {
            let mut ctx = <$ctx>::default();
            let mut verifier = ckb_cinnabar_verifier::TransactionVerifier::default();
            $(
                verifier.add_verifier($name, alloc::boxed::Box::new(<$verifier>::default()));
            )+
            match verifier.run(&mut ctx) {
                Ok(_) => 0,
                Err(err) => err.into(),
            }
        }
    };
}


